!function(e){var t={};function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=116)}([function(e,t,r){(function(t){e.exports=function e(t,r,n){function a(i,s){if(!r[i]){if(!t[i]){if(o)return o(i,!0);throw new Error("Cannot find module '"+i+"'")}var l=r[i]={exports:{}};t[i][0].call(l.exports,(function(e){var r=t[i][1][e];return a(r||e)}),l,l.exports,e,t,r,n)}return r[i].exports}for(var o=!1,i=0;i<n.length;i++)a(n[i]);return a}({1:[function(e,t,r){"use strict";var n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,a,o,i,s,l,c="",f=0;f<e.length;)o=(t=e.charCodeAt(f++))>>2,i=(3&t)<<4|(r=e.charCodeAt(f++))>>4,s=(15&r)<<2|(a=e.charCodeAt(f++))>>6,l=63&a,isNaN(r)?s=l=64:isNaN(a)&&(l=64),c=c+n.charAt(o)+n.charAt(i)+n.charAt(s)+n.charAt(l);return c},r.decode=function(e){var t,r,a,o,i,s,l="",c=0;for(e=e.replace(/[^A-Za-z0-9\+\/\=]/g,"");c<e.length;)t=n.indexOf(e.charAt(c++))<<2|(o=n.indexOf(e.charAt(c++)))>>4,r=(15&o)<<4|(i=n.indexOf(e.charAt(c++)))>>2,a=(3&i)<<6|(s=n.indexOf(e.charAt(c++))),l+=String.fromCharCode(t),64!=i&&(l+=String.fromCharCode(r)),64!=s&&(l+=String.fromCharCode(a));return l}},{}],2:[function(e,t){"use strict";function r(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}r.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},t.exports=r},{}],3:[function(e,t,r){"use strict";r.STORE={magic:"\0\0",compress:function(e){return e},uncompress:function(e){return e},compressInputType:null,uncompressInputType:null},r.DEFLATE=e("./flate")},{"./flate":8}],4:[function(e,t){"use strict";var r=e("./utils"),n=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];t.exports=function(e,t){if(void 0===e||!e.length)return 0;var a="string"!==r.getTypeOf(e);void 0===t&&(t=0);var o=0;t^=-1;for(var i=0,s=e.length;s>i;i++)o=a?e[i]:e.charCodeAt(i),t=t>>>8^n[255&(t^o)];return-1^t}},{"./utils":21}],5:[function(e,t){"use strict";function r(){this.data=null,this.length=0,this.index=0}var n=e("./utils");r.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<e||0>e)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1)}},t.exports=r},{"./utils":21}],6:[function(e,t,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!1,r.date=null,r.compression=null,r.comment=null},{}],7:[function(e,t,r){"use strict";var n=e("./utils");r.string2binary=function(e){return n.string2binary(e)},r.string2Uint8Array=function(e){return n.transformTo("uint8array",e)},r.uint8Array2String=function(e){return n.transformTo("string",e)},r.string2Blob=function(e){var t=n.transformTo("arraybuffer",e);return n.arrayBuffer2Blob(t)},r.arrayBuffer2Blob=function(e){return n.arrayBuffer2Blob(e)},r.transformTo=function(e,t){return n.transformTo(e,t)},r.getTypeOf=function(e){return n.getTypeOf(e)},r.checkSupport=function(e){return n.checkSupport(e)},r.MAX_VALUE_16BITS=n.MAX_VALUE_16BITS,r.MAX_VALUE_32BITS=n.MAX_VALUE_32BITS,r.pretty=function(e){return n.pretty(e)},r.findCompression=function(e){return n.findCompression(e)},r.isRegExp=function(e){return n.isRegExp(e)}},{"./utils":21}],8:[function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,a=e("pako");r.uncompressInputType=n?"uint8array":"array",r.compressInputType=n?"uint8array":"array",r.magic="\b\0",r.compress=function(e){return a.deflateRaw(e)},r.uncompress=function(e){return a.inflateRaw(e)}},{pako:24}],9:[function(e,t){"use strict";function r(e,t){return this instanceof r?(this.files={},this.comment=null,this.root="",e&&this.load(e,t),void(this.clone=function(){var e=new r;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e})):new r(e,t)}var n=e("./base64");r.prototype=e("./object"),r.prototype.load=e("./load"),r.support=e("./support"),r.defaults=e("./defaults"),r.utils=e("./deprecatedPublicUtils"),r.base64={encode:function(e){return n.encode(e)},decode:function(e){return n.decode(e)}},r.compressions=e("./compressions"),t.exports=r},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(e,t){"use strict";var r=e("./base64"),n=e("./zipEntries");t.exports=function(e,t){var a,o,i,s;for((t=t||{}).base64&&(e=r.decode(e)),a=(o=new n(e,t)).files,i=0;i<a.length;i++)s=a[i],this.file(s.fileName,s.decompressed,{binary:!0,optimizedBinaryString:!0,date:s.date,dir:s.dir,comment:s.fileComment.length?s.fileComment:null,createFolders:t.createFolders});return o.zipComment.length&&(this.comment=o.zipComment),this}},{"./base64":1,"./zipEntries":22}],11:[function(e,r){(function(e){"use strict";r.exports=function(t,r){return new e(t,r)},r.exports.test=function(t){return e.isBuffer(t)}}).call(this,void 0!==t?t:void 0)},{}],12:[function(e,t){"use strict";function r(e){this.data=e,this.length=this.data.length,this.index=0}var n=e("./uint8ArrayReader");r.prototype=new n,r.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.index,this.index+e);return this.index+=e,t},t.exports=r},{"./uint8ArrayReader":18}],13:[function(e,t){"use strict";var r=e("./support"),n=e("./utils"),a=e("./crc32"),o=e("./signature"),i=e("./defaults"),s=e("./base64"),l=e("./compressions"),c=e("./compressedObject"),f=e("./nodeBuffer"),d=e("./utf8"),u=e("./stringWriter"),p=e("./uint8ArrayWriter"),h=function(e){if(e._data instanceof c&&(e._data=e._data.getContent(),e.options.binary=!0,e.options.base64=!1,"uint8array"===n.getTypeOf(e._data))){var t=e._data;e._data=new Uint8Array(t.length),0!==t.length&&e._data.set(t,0)}return e._data},v=function(e){var t=h(e);return"string"===n.getTypeOf(t)?!e.options.binary&&r.nodebuffer?f(t,"utf-8"):e.asBinary():t},m=function(e){var t=h(this);return null==t?"":(this.options.base64&&(t=s.decode(t)),t=e&&this.options.binary?R.utf8decode(t):n.transformTo("string",t),e||this.options.binary||(t=n.transformTo("string",R.utf8encode(t))),t)},x=function(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this._data=t,this.options=r,this._initialMetadata={dir:r.dir,date:r.date}};x.prototype={asText:function(){return m.call(this,!0)},asBinary:function(){return m.call(this,!1)},asNodeBuffer:function(){var e=v(this);return n.transformTo("nodebuffer",e)},asUint8Array:function(){var e=v(this);return n.transformTo("uint8array",e)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var g=function(e,t){var r,n="";for(r=0;t>r;r++)n+=String.fromCharCode(255&e),e>>>=8;return n},y=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])arguments[e].hasOwnProperty(t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},E=function(e){return!0!==(e=e||{}).base64||null!==e.binary&&void 0!==e.binary||(e.binary=!0),(e=y(e,i)).date=e.date||new Date,null!==e.compression&&(e.compression=e.compression.toUpperCase()),e},w=function(e,t,r){var a,o=n.getTypeOf(t);if((r=E(r)).createFolders&&(a=b(e))&&T.call(this,a,!0),r.dir||null==t)r.base64=!1,r.binary=!1,t=null;else if("string"===o)r.binary&&!r.base64&&!0!==r.optimizedBinaryString&&(t=n.string2binary(t));else{if(r.base64=!1,r.binary=!0,!(o||t instanceof c))throw new Error("The data of '"+e+"' is in an unsupported format !");"arraybuffer"===o&&(t=n.transformTo("uint8array",t))}var i=new x(e,t,r);return this.files[e]=i,i},b=function(e){"/"==e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return t>0?e.substring(0,t):""},T=function(e,t){return"/"!=e.slice(-1)&&(e+="/"),t=void 0!==t&&t,this.files[e]||w.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]},_=function(e,t){var r,o=new c;return e._data instanceof c?(o.uncompressedSize=e._data.uncompressedSize,o.crc32=e._data.crc32,0===o.uncompressedSize||e.dir?(t=l.STORE,o.compressedContent="",o.crc32=0):e._data.compressionMethod===t.magic?o.compressedContent=e._data.getCompressedContent():(r=e._data.getContent(),o.compressedContent=t.compress(n.transformTo(t.compressInputType,r)))):((!(r=v(e))||0===r.length||e.dir)&&(t=l.STORE,r=""),o.uncompressedSize=r.length,o.crc32=a(r),o.compressedContent=t.compress(n.transformTo(t.compressInputType,r))),o.compressedSize=o.compressedContent.length,o.compressionMethod=t.magic,o},S=function(e,t,r,i){var s,l,c,f,u=(r.compressedContent,n.transformTo("string",d.utf8encode(t.name))),p=t.comment||"",h=n.transformTo("string",d.utf8encode(p)),v=u.length!==t.name.length,m=h.length!==p.length,x=t.options,y="",E="",w="";c=t._initialMetadata.dir!==t.dir?t.dir:x.dir,s=(f=t._initialMetadata.date!==t.date?t.date:x.date).getHours(),s<<=6,s|=f.getMinutes(),s<<=5,s|=f.getSeconds()/2,l=f.getFullYear()-1980,l<<=4,l|=f.getMonth()+1,l<<=5,l|=f.getDate(),v&&(E=g(1,1)+g(a(u),4)+u,y+="up"+g(E.length,2)+E),m&&(w=g(1,1)+g(this.crc32(h),4)+h,y+="uc"+g(w.length,2)+w);var b="";return b+="\n\0",b+=v||m?"\0\b":"\0\0",b+=r.compressionMethod,b+=g(s,2),b+=g(l,2),b+=g(r.crc32,4),b+=g(r.compressedSize,4),b+=g(r.uncompressedSize,4),b+=g(u.length,2),b+=g(y.length,2),{fileRecord:o.LOCAL_FILE_HEADER+b+u+y,dirRecord:o.CENTRAL_FILE_HEADER+"\0"+b+g(h.length,2)+"\0\0\0\0"+(!0===c?"\0\0\0":"\0\0\0\0")+g(i,4)+u+y+h,compressedObject:r}},R={load:function(){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(e){var t,r,n,a,o=[];for(t in this.files)this.files.hasOwnProperty(t)&&(n=this.files[t],a=new x(n.name,n._data,y(n.options)),r=t.slice(this.root.length,t.length),t.slice(0,this.root.length)===this.root&&e(r,a)&&o.push(a));return o},file:function(e,t,r){if(1===arguments.length){if(n.isRegExp(e)){var a=e;return this.filter((function(e,t){return!t.dir&&a.test(e)}))}return this.filter((function(t,r){return!r.dir&&t===e}))[0]||null}return e=this.root+e,w.call(this,e,t,r),this},folder:function(e){if(!e)return this;if(n.isRegExp(e))return this.filter((function(t,r){return r.dir&&e.test(t)}));var t=this.root+e,r=T.call(this,t),a=this.clone();return a.root=r.name,a},remove:function(e){e=this.root+e;var t=this.files[e];if(t||("/"!=e.slice(-1)&&(e+="/"),t=this.files[e]),t&&!t.dir)delete this.files[e];else for(var r=this.filter((function(t,r){return r.name.slice(0,e.length)===e})),n=0;n<r.length;n++)delete this.files[r[n].name];return this},generate:function(e){e=y(e||{},{base64:!0,compression:"STORE",type:"base64",comment:null}),n.checkSupport(e.type);var t,r,a,i=[],c=0,f=0,d=n.transformTo("string",this.utf8encode(e.comment||this.comment||""));for(var h in this.files)if(this.files.hasOwnProperty(h)){var v=this.files[h],m=v.options.compression||e.compression.toUpperCase(),x=l[m];if(!x)throw new Error(m+" is not a valid compression method !");var E=_.call(this,v,x),w=S.call(this,h,v,E,c);c+=w.fileRecord.length+E.compressedSize,f+=w.dirRecord.length,i.push(w)}a=o.CENTRAL_DIRECTORY_END+"\0\0\0\0"+g(i.length,2)+g(i.length,2)+g(f,4)+g(c,4)+g(d.length,2)+d;var b=e.type.toLowerCase();for(t="uint8array"===b||"arraybuffer"===b||"blob"===b||"nodebuffer"===b?new p(c+f+a.length):new u(c+f+a.length),r=0;r<i.length;r++)t.append(i[r].fileRecord),t.append(i[r].compressedObject.compressedContent);for(r=0;r<i.length;r++)t.append(i[r].dirRecord);t.append(a);var T=t.finalize();switch(e.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return n.transformTo(e.type.toLowerCase(),T);case"blob":return n.arrayBuffer2Blob(n.transformTo("arraybuffer",T));case"base64":return e.base64?s.encode(T):T;default:return T}},crc32:function(e,t){return a(e,t)},utf8encode:function(e){return n.transformTo("string",d.utf8encode(e))},utf8decode:function(e){return d.utf8decode(e)}};t.exports=R},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(e,t,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],15:[function(e,t){"use strict";function r(e,t){this.data=e,t||(this.data=a.string2binary(this.data)),this.length=this.data.length,this.index=0}var n=e("./dataReader"),a=e("./utils");r.prototype=new n,r.prototype.byteAt=function(e){return this.data.charCodeAt(e)},r.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)},r.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.index,this.index+e);return this.index+=e,t},t.exports=r},{"./dataReader":5,"./utils":21}],16:[function(e,t){"use strict";var r=e("./utils"),n=function(){this.data=[]};n.prototype={append:function(e){e=r.transformTo("string",e),this.data.push(e)},finalize:function(){return this.data.join("")}},t.exports=n},{"./utils":21}],17:[function(e,r,n){(function(e){"use strict";if(n.base64=!0,n.array=!0,n.string=!0,n.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,n.nodebuffer=void 0!==e,n.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)n.blob=!1;else{var t=new ArrayBuffer(0);try{n.blob=0===new Blob([t],{type:"application/zip"}).size}catch(e){try{var r=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder);r.append(t),n.blob=0===r.getBlob("application/zip").size}catch(e){n.blob=!1}}}}).call(this,void 0!==t?t:void 0)},{}],18:[function(e,t){"use strict";function r(e){e&&(this.data=e,this.length=this.data.length,this.index=0)}var n=e("./dataReader");r.prototype=new n,r.prototype.byteAt=function(e){return this.data[e]},r.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),a=e.charCodeAt(3),o=this.length-4;o>=0;--o)if(this.data[o]===t&&this.data[o+1]===r&&this.data[o+2]===n&&this.data[o+3]===a)return o;return-1},r.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.index,this.index+e);return this.index+=e,t},t.exports=r},{"./dataReader":5}],19:[function(e,t){"use strict";var r=e("./utils"),n=function(e){this.data=new Uint8Array(e),this.index=0};n.prototype={append:function(e){0!==e.length&&(e=r.transformTo("uint8array",e),this.data.set(e,this.index),this.index+=e.length)},finalize:function(){return this.data}},t.exports=n},{"./utils":21}],20:[function(e,t,r){"use strict";for(var n=e("./utils"),a=e("./support"),o=e("./nodeBuffer"),i=new Array(256),s=0;256>s;s++)i[s]=s>=252?6:s>=248?5:s>=240?4:s>=224?3:s>=192?2:1;i[254]=i[254]=1;var l=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;r>=0&&128==(192&e[r]);)r--;return 0>r||0===r?t:r+i[e[r]]>t?r:t},c=function(e){var t,r,a,o,s=e.length,l=new Array(2*s);for(r=0,t=0;s>t;)if(128>(a=e[t++]))l[r++]=a;else if((o=i[a])>4)l[r++]=65533,t+=o-1;else{for(a&=2===o?31:3===o?15:7;o>1&&s>t;)a=a<<6|63&e[t++],o--;o>1?l[r++]=65533:65536>a?l[r++]=a:(a-=65536,l[r++]=55296|a>>10&1023,l[r++]=56320|1023&a)}return l.length!==r&&(l.subarray?l=l.subarray(0,r):l.length=r),n.applyFromCharCode(l)};r.utf8encode=function(e){return a.nodebuffer?o(e,"utf-8"):function(e){var t,r,n,o,i,s=e.length,l=0;for(o=0;s>o;o++)55296==(64512&(r=e.charCodeAt(o)))&&s>o+1&&56320==(64512&(n=e.charCodeAt(o+1)))&&(r=65536+(r-55296<<10)+(n-56320),o++),l+=128>r?1:2048>r?2:65536>r?3:4;for(t=a.uint8array?new Uint8Array(l):new Array(l),i=0,o=0;l>i;o++)55296==(64512&(r=e.charCodeAt(o)))&&s>o+1&&56320==(64512&(n=e.charCodeAt(o+1)))&&(r=65536+(r-55296<<10)+(n-56320),o++),128>r?t[i++]=r:2048>r?(t[i++]=192|r>>>6,t[i++]=128|63&r):65536>r?(t[i++]=224|r>>>12,t[i++]=128|r>>>6&63,t[i++]=128|63&r):(t[i++]=240|r>>>18,t[i++]=128|r>>>12&63,t[i++]=128|r>>>6&63,t[i++]=128|63&r);return t}(e)},r.utf8decode=function(e){if(a.nodebuffer)return n.transformTo("nodebuffer",e).toString("utf-8");for(var t=[],r=0,o=(e=n.transformTo(a.uint8array?"uint8array":"array",e)).length;o>r;){var i=l(e,Math.min(r+65536,o));t.push(a.uint8array?c(e.subarray(r,i)):c(e.slice(r,i))),r=i}return t.join("")}},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(e,t,r){"use strict";function n(e){return e}function a(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}function o(e){var t=65536,n=[],a=e.length,o=r.getTypeOf(e),i=0,s=!0;try{switch(o){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,c(0))}}catch(e){s=!1}if(!s){for(var l="",f=0;f<e.length;f++)l+=String.fromCharCode(e[f]);return l}for(;a>i&&t>1;)try{n.push("array"===o||"nodebuffer"===o?String.fromCharCode.apply(null,e.slice(i,Math.min(i+t,a))):String.fromCharCode.apply(null,e.subarray(i,Math.min(i+t,a)))),i+=t}catch(e){t=Math.floor(t/2)}return n.join("")}function i(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}var s=e("./support"),l=e("./compressions"),c=e("./nodeBuffer");r.string2binary=function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(255&e.charCodeAt(r));return t},r.arrayBuffer2Blob=function(e){r.checkSupport("blob");try{return new Blob([e],{type:"application/zip"})}catch(r){try{var t=new(window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder);return t.append(e),t.getBlob("application/zip")}catch(e){throw new Error("Bug : can't construct the Blob.")}}},r.applyFromCharCode=o;var f={};f.string={string:n,array:function(e){return a(e,new Array(e.length))},arraybuffer:function(e){return f.string.uint8array(e).buffer},uint8array:function(e){return a(e,new Uint8Array(e.length))},nodebuffer:function(e){return a(e,c(e.length))}},f.array={string:o,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return c(e)}},f.arraybuffer={string:function(e){return o(new Uint8Array(e))},array:function(e){return i(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return c(new Uint8Array(e))}},f.uint8array={string:o,array:function(e){return i(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return c(e)}},f.nodebuffer={string:o,array:function(e){return i(e,new Array(e.length))},arraybuffer:function(e){return f.nodebuffer.uint8array(e).buffer},uint8array:function(e){return i(e,new Uint8Array(e.length))},nodebuffer:n},r.transformTo=function(e,t){if(t||(t=""),!e)return t;r.checkSupport(e);var n=r.getTypeOf(t);return f[n][e](t)},r.getTypeOf=function(e){return"string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":s.nodebuffer&&c.test(e)?"nodebuffer":s.uint8array&&e instanceof Uint8Array?"uint8array":s.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},r.checkSupport=function(e){if(!s[e.toLowerCase()])throw new Error(e+" is not supported by this browser")},r.MAX_VALUE_16BITS=65535,r.MAX_VALUE_32BITS=-1,r.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+(16>(t=e.charCodeAt(r))?"0":"")+t.toString(16).toUpperCase();return n},r.findCompression=function(e){for(var t in l)if(l.hasOwnProperty(t)&&l[t].magic===e)return l[t];return null},r.isRegExp=function(e){return"[object RegExp]"===Object.prototype.toString.call(e)}},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(e,t){"use strict";function r(e,t){this.files=[],this.loadOptions=t,e&&this.load(e)}var n=e("./stringReader"),a=e("./nodeBufferReader"),o=e("./uint8ArrayReader"),i=e("./utils"),s=e("./signature"),l=e("./zipEntry"),c=e("./support"),f=e("./object");r.prototype={checkSignature:function(e){var t=this.reader.readString(4);if(t!==e)throw new Error("Corrupted zip or bug : unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2),this.zipComment=this.reader.readString(this.zipCommentLength),this.zipComment=f.utf8decode(this.zipComment)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;n>0;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readString(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===s.CENTRAL_FILE_HEADER;)(e=new l({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(-1===e)throw new Error("Corrupted zip : can't find end of central directory");if(this.reader.setIndex(e),this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,-1===(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}},prepareReader:function(e){var t=i.getTypeOf(e);this.reader="string"!==t||c.uint8array?"nodebuffer"===t?new a(e):new o(i.transformTo("uint8array",e)):new n(e,this.loadOptions.optimizedBinaryString)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=r},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(e,t){"use strict";function r(e,t){this.options=e,this.loadOptions=t}var n=e("./stringReader"),a=e("./utils"),o=e("./compressedObject"),i=e("./object");r.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},prepareCompressedContent:function(e,t,r){return function(){var n=e.index;e.setIndex(t);var a=e.readData(r);return e.setIndex(n),a}},prepareContent:function(e,t,r,n,o){return function(){var e=a.transformTo(n.uncompressInputType,this.getCompressedContent()),t=n.uncompress(e);if(t.length!==o)throw new Error("Bug : uncompressed data size mismatch");return t}},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readString(this.fileNameLength),e.skip(r),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(null===(t=a.findCompression(this.compressionMethod)))throw new Error("Corrupted zip : compression "+a.pretty(this.compressionMethod)+" unknown (inner file : "+this.fileName+")");if(this.decompressed=new o,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(e,e.index,this.compressedSize,t),this.decompressed.getContent=this.prepareContent(e,e.index,this.compressedSize,t,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=a.transformTo("string",this.decompressed.getContent()),i.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(e){if(this.versionMadeBy=e.readString(2),this.versionNeeded=e.readInt(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4),this.fileNameLength=e.readInt(2),this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=e.readString(this.fileNameLength),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readString(this.fileCommentLength),this.dir=!!(16&this.externalFileAttributes)},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=new n(this.extraFields[1].value);this.uncompressedSize===a.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===a.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===a.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===a.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(e){var t,r,n,a=e.index;for(this.extraFields=this.extraFields||{};e.index<a+this.extraFieldsLength;)t=e.readInt(2),r=e.readInt(2),n=e.readString(r),this.extraFields[t]={id:t,length:r,value:n}},handleUTF8:function(){if(this.useUTF8())this.fileName=i.utf8decode(this.fileName),this.fileComment=i.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();null!==e&&(this.fileName=e);var t=this.findExtraFieldUnicodeComment();null!==t&&(this.fileComment=t)}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=new n(e.value);return 1!==t.readInt(1)||i.crc32(this.fileName)!==t.readInt(4)?null:i.utf8decode(t.readString(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=new n(e.value);return 1!==t.readInt(1)||i.crc32(this.fileComment)!==t.readInt(4)?null:i.utf8decode(t.readString(e.length-5))}return null}},t.exports=r},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(e,t){"use strict";var r={};(0,e("./lib/utils/common").assign)(r,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=r},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(e,t,r){"use strict";function n(e,t){var r=new c(t);if(r.push(e,!0),r.err)throw r.msg;return r.result}var a=e("./zlib/deflate.js"),o=e("./utils/common"),i=e("./utils/strings"),s=e("./zlib/messages"),l=e("./zlib/zstream"),c=function(e){this.options=o.assign({level:-1,method:8,chunkSize:16384,windowBits:15,memLevel:8,strategy:0,to:""},e||{});var t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(0!==r)throw new Error(s[r]);t.header&&a.deflateSetHeader(this.strm,t.header)};c.prototype.push=function(e,t){var r,n,s=this.strm,l=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?4:0,s.input="string"==typeof e?i.string2buf(e):e,s.next_in=0,s.avail_in=s.input.length;do{if(0===s.avail_out&&(s.output=new o.Buf8(l),s.next_out=0,s.avail_out=l),1!==(r=a.deflate(s,n))&&0!==r)return this.onEnd(r),this.ended=!0,!1;(0===s.avail_out||0===s.avail_in&&4===n)&&this.onData("string"===this.options.to?i.buf2binstring(o.shrinkBuf(s.output,s.next_out)):o.shrinkBuf(s.output,s.next_out))}while((s.avail_in>0||0===s.avail_out)&&1!==r);return 4!==n||(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,0===r)},c.prototype.onData=function(e){this.chunks.push(e)},c.prototype.onEnd=function(e){0===e&&(this.result="string"===this.options.to?this.chunks.join(""):o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Deflate=c,r.deflate=n,r.deflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return(t=t||{}).gzip=!0,n(e,t)}},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(e,t,r){"use strict";function n(e,t){var r=new d(t);if(r.push(e,!0),r.err)throw r.msg;return r.result}var a=e("./zlib/inflate.js"),o=e("./utils/common"),i=e("./utils/strings"),s=e("./zlib/constants"),l=e("./zlib/messages"),c=e("./zlib/zstream"),f=e("./zlib/gzheader"),d=function(e){this.options=o.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new c,this.strm.avail_out=0;var r=a.inflateInit2(this.strm,t.windowBits);if(r!==s.Z_OK)throw new Error(l[r]);this.header=new f,a.inflateGetHeader(this.strm,this.header)};d.prototype.push=function(e,t){var r,n,l,c,f,d=this.strm,u=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?s.Z_FINISH:s.Z_NO_FLUSH,d.input="string"==typeof e?i.binstring2buf(e):e,d.next_in=0,d.avail_in=d.input.length;do{if(0===d.avail_out&&(d.output=new o.Buf8(u),d.next_out=0,d.avail_out=u),(r=a.inflate(d,s.Z_NO_FLUSH))!==s.Z_STREAM_END&&r!==s.Z_OK)return this.onEnd(r),this.ended=!0,!1;d.next_out&&(0===d.avail_out||r===s.Z_STREAM_END||0===d.avail_in&&n===s.Z_FINISH)&&("string"===this.options.to?(l=i.utf8border(d.output,d.next_out),c=d.next_out-l,f=i.buf2string(d.output,l),d.next_out=c,d.avail_out=u-c,c&&o.arraySet(d.output,d.output,l,c,0),this.onData(f)):this.onData(o.shrinkBuf(d.output,d.next_out)))}while(d.avail_in>0&&r!==s.Z_STREAM_END);return r===s.Z_STREAM_END&&(n=s.Z_FINISH),n!==s.Z_FINISH||(r=a.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===s.Z_OK)},d.prototype.onData=function(e){this.chunks.push(e)},d.prototype.onEnd=function(e){e===s.Z_OK&&(this.result="string"===this.options.to?this.chunks.join(""):o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=d,r.inflate=n,r.inflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.ungzip=n},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(e,t,r){"use strict";var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var a={arraySet:function(e,t,r,n,a){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),a);else for(var o=0;n>o;o++)e[a+o]=t[r+o]},flattenChunks:function(e){var t,r,n,a,o,i;for(n=0,t=0,r=e.length;r>t;t++)n+=e[t].length;for(i=new Uint8Array(n),a=0,t=0,r=e.length;r>t;t++)o=e[t],i.set(o,a),a+=o.length;return i}},o={arraySet:function(e,t,r,n,a){for(var o=0;n>o;o++)e[a+o]=t[r+o]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,a)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,o))},r.setTyped(n)},{}],28:[function(e,t,r){"use strict";function n(e,t){if(65537>t&&(e.subarray&&i||!e.subarray&&o))return String.fromCharCode.apply(null,a.shrinkBuf(e,t));for(var r="",n=0;t>n;n++)r+=String.fromCharCode(e[n]);return r}var a=e("./common"),o=!0,i=!0;try{String.fromCharCode.apply(null,[0])}catch(e){o=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){i=!1}for(var s=new a.Buf8(256),l=0;256>l;l++)s[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1;s[254]=s[254]=1,r.string2buf=function(e){var t,r,n,o,i,s=e.length,l=0;for(o=0;s>o;o++)55296==(64512&(r=e.charCodeAt(o)))&&s>o+1&&56320==(64512&(n=e.charCodeAt(o+1)))&&(r=65536+(r-55296<<10)+(n-56320),o++),l+=128>r?1:2048>r?2:65536>r?3:4;for(t=new a.Buf8(l),i=0,o=0;l>i;o++)55296==(64512&(r=e.charCodeAt(o)))&&s>o+1&&56320==(64512&(n=e.charCodeAt(o+1)))&&(r=65536+(r-55296<<10)+(n-56320),o++),128>r?t[i++]=r:2048>r?(t[i++]=192|r>>>6,t[i++]=128|63&r):65536>r?(t[i++]=224|r>>>12,t[i++]=128|r>>>6&63,t[i++]=128|63&r):(t[i++]=240|r>>>18,t[i++]=128|r>>>12&63,t[i++]=128|r>>>6&63,t[i++]=128|63&r);return t},r.buf2binstring=function(e){return n(e,e.length)},r.binstring2buf=function(e){for(var t=new a.Buf8(e.length),r=0,n=t.length;n>r;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,a,o,i,l=t||e.length,c=new Array(2*l);for(a=0,r=0;l>r;)if(128>(o=e[r++]))c[a++]=o;else if((i=s[o])>4)c[a++]=65533,r+=i-1;else{for(o&=2===i?31:3===i?15:7;i>1&&l>r;)o=o<<6|63&e[r++],i--;i>1?c[a++]=65533:65536>o?c[a++]=o:(o-=65536,c[a++]=55296|o>>10&1023,c[a++]=56320|1023&o)}return n(c,a)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;r>=0&&128==(192&e[r]);)r--;return 0>r||0===r?t:r+s[e[r]]>t?r:t}},{"./common":27}],29:[function(e,t){"use strict";t.exports=function(e,t,r,n){for(var a=65535&e|0,o=e>>>16&65535|0,i=0;0!==r;){r-=i=r>2e3?2e3:r;do{o=o+(a=a+t[n++]|0)|0}while(--i);a%=65521,o%=65521}return a|o<<16|0}},{}],30:[function(e,t){t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],31:[function(e,t){"use strict";var r=function(){for(var e,t=[],r=0;256>r;r++){e=r;for(var n=0;8>n;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t,n,a){var o=r,i=a+n;e^=-1;for(var s=a;i>s;s++)e=e>>>8^o[255&(e^t[s])];return-1^e}},{}],32:[function(e,t,r){"use strict";function n(e,t){return e.msg=R[t],t}function a(e){return(e<<1)-(e>4?9:0)}function o(e){for(var t=e.length;--t>=0;)e[t]=0}function i(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(b.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function s(e,t){T._tr_flush_block(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,i(e.strm)}function l(e,t){e.pending_buf[e.pending++]=t}function c(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function f(e,t,r,n){var a=e.avail_in;return a>n&&(a=n),0===a?0:(e.avail_in-=a,b.arraySet(t,e.input,e.next_in,a,r),1===e.state.wrap?e.adler=_(e.adler,t,a,r):2===e.state.wrap&&(e.adler=S(e.adler,t,a,r)),e.next_in+=a,e.total_in+=a,a)}function d(e,t){var r,n,a=e.max_chain_length,o=e.strstart,i=e.prev_length,s=e.nice_match,l=e.strstart>e.w_size-te?e.strstart-(e.w_size-te):0,c=e.window,f=e.w_mask,d=e.prev,u=e.strstart+ee,p=c[o+i-1],h=c[o+i];e.prev_length>=e.good_match&&(a>>=2),s>e.lookahead&&(s=e.lookahead);do{if(c[(r=t)+i]===h&&c[r+i-1]===p&&c[r]===c[o]&&c[++r]===c[o+1]){o+=2,r++;do{}while(c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&c[++o]===c[++r]&&u>o);if(n=ee-(u-o),o=u-ee,n>i){if(e.match_start=t,i=n,n>=s)break;p=c[o+i-1],h=c[o+i]}}}while((t=d[t&f])>l&&0!=--a);return i<=e.lookahead?i:e.lookahead}function u(e){var t,r,n,a,o,i=e.w_size;do{if(a=e.window_size-e.lookahead-e.strstart,e.strstart>=i+(i-te)){b.arraySet(e.window,e.window,i,i,0),e.match_start-=i,e.strstart-=i,e.block_start-=i,t=r=e.hash_size;do{n=e.head[--t],e.head[t]=n>=i?n-i:0}while(--r);t=r=i;do{n=e.prev[--t],e.prev[t]=n>=i?n-i:0}while(--r);a+=i}if(0===e.strm.avail_in)break;if(r=f(e.strm,e.window,e.strstart+e.lookahead,a),e.lookahead+=r,e.lookahead+e.insert>=$)for(o=e.strstart-e.insert,e.ins_h=e.window[o],e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[o+$-1])&e.hash_mask,e.prev[o&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=o,o++,e.insert--,!(e.lookahead+e.insert<$)););}while(e.lookahead<te&&0!==e.strm.avail_in)}function p(e,t){for(var r,n;;){if(e.lookahead<te){if(u(e),e.lookahead<te&&t===A)return fe;if(0===e.lookahead)break}if(r=0,e.lookahead>=$&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+$-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-te&&(e.match_length=d(e,r)),e.match_length>=$)if(n=T._tr_tally(e,e.strstart-e.match_start,e.match_length-$),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=$){e.match_length--;do{e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+$-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart}while(0!=--e.match_length);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=T._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(s(e,!1),0===e.strm.avail_out))return fe}return e.insert=e.strstart<$-1?e.strstart:$-1,t===L?(s(e,!0),0===e.strm.avail_out?ue:pe):e.last_lit&&(s(e,!1),0===e.strm.avail_out)?fe:de}function h(e,t){for(var r,n,a;;){if(e.lookahead<te){if(u(e),e.lookahead<te&&t===A)return fe;if(0===e.lookahead)break}if(r=0,e.lookahead>=$&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+$-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=$-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-te&&(e.match_length=d(e,r),e.match_length<=5&&(e.strategy===I||e.match_length===$&&e.strstart-e.match_start>4096)&&(e.match_length=$-1)),e.prev_length>=$&&e.match_length<=e.prev_length){a=e.strstart+e.lookahead-$,n=T._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-$),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=a&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+$-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart)}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=$-1,e.strstart++,n&&(s(e,!1),0===e.strm.avail_out))return fe}else if(e.match_available){if((n=T._tr_tally(e,0,e.window[e.strstart-1]))&&s(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return fe}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=T._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<$-1?e.strstart:$-1,t===L?(s(e,!0),0===e.strm.avail_out?ue:pe):e.last_lit&&(s(e,!1),0===e.strm.avail_out)?fe:de}function v(e,t){for(var r,n,a,o,i=e.window;;){if(e.lookahead<=ee){if(u(e),e.lookahead<=ee&&t===A)return fe;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=$&&e.strstart>0&&(n=i[a=e.strstart-1])===i[++a]&&n===i[++a]&&n===i[++a]){o=e.strstart+ee;do{}while(n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&n===i[++a]&&o>a);e.match_length=ee-(o-a),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=$?(r=T._tr_tally(e,1,e.match_length-$),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=T._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(s(e,!1),0===e.strm.avail_out))return fe}return e.insert=0,t===L?(s(e,!0),0===e.strm.avail_out?ue:pe):e.last_lit&&(s(e,!1),0===e.strm.avail_out)?fe:de}function m(e,t){for(var r;;){if(0===e.lookahead&&(u(e),0===e.lookahead)){if(t===A)return fe;break}if(e.match_length=0,r=T._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(s(e,!1),0===e.strm.avail_out))return fe}return e.insert=0,t===L?(s(e,!0),0===e.strm.avail_out?ue:pe):e.last_lit&&(s(e,!1),0===e.strm.avail_out)?fe:de}function x(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=j,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new b.Buf16(2*K),this.dyn_dtree=new b.Buf16(2*(2*Z+1)),this.bl_tree=new b.Buf16(2*(2*Q+1)),o(this.dyn_ltree),o(this.dyn_dtree),o(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new b.Buf16(J+1),this.heap=new b.Buf16(2*Y+1),o(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new b.Buf16(2*Y+1),o(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function g(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=V,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?ne:le,e.adler=2===t.wrap?0:1,t.last_flush=A,T._tr_init(t),P):n(e,k)}function y(e){var t=g(e);return t===P&&function(e){e.window_size=2*e.w_size,o(e.head),e.max_lazy_match=w[e.level].max_lazy,e.good_match=w[e.level].good_length,e.nice_match=w[e.level].nice_length,e.max_chain_length=w[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=$-1,e.match_available=0,e.ins_h=0}(e.state),t}function E(e,t,r,a,o,i){if(!e)return k;var s=1;if(t===F&&(t=6),0>a?(s=0,a=-a):a>15&&(s=2,a-=16),1>o||o>W||r!==j||8>a||a>15||0>t||t>9||0>i||i>G)return n(e,k);8===a&&(a=9);var l=new x;return e.state=l,l.strm=e,l.wrap=s,l.gzhead=null,l.w_bits=a,l.w_size=1<<l.w_bits,l.w_mask=l.w_size-1,l.hash_bits=o+7,l.hash_size=1<<l.hash_bits,l.hash_mask=l.hash_size-1,l.hash_shift=~~((l.hash_bits+$-1)/$),l.window=new b.Buf8(2*l.w_size),l.head=new b.Buf16(l.hash_size),l.prev=new b.Buf16(l.w_size),l.lit_bufsize=1<<o+6,l.pending_buf_size=4*l.lit_bufsize,l.pending_buf=new b.Buf8(l.pending_buf_size),l.d_buf=l.lit_bufsize>>1,l.l_buf=3*l.lit_bufsize,l.level=t,l.strategy=i,l.method=r,y(e)}var w,b=e("../utils/common"),T=e("./trees"),_=e("./adler32"),S=e("./crc32"),R=e("./messages"),A=0,M=1,C=3,L=4,H=5,P=0,z=1,k=-2,N=-3,D=-5,F=-1,I=1,O=2,U=3,G=4,B=0,V=2,j=8,W=9,q=15,X=8,Y=286,Z=30,Q=19,K=2*Y+1,J=15,$=3,ee=258,te=ee+$+1,re=32,ne=42,ae=69,oe=73,ie=91,se=103,le=113,ce=666,fe=1,de=2,ue=3,pe=4,he=3,ve=function(e,t,r,n,a){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=a};w=[new ve(0,0,0,0,(function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(u(e),0===e.lookahead&&t===A)return fe;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,s(e,!1),0===e.strm.avail_out))return fe;if(e.strstart-e.block_start>=e.w_size-te&&(s(e,!1),0===e.strm.avail_out))return fe}return e.insert=0,t===L?(s(e,!0),0===e.strm.avail_out?ue:pe):(e.strstart>e.block_start&&(s(e,!1),e.strm.avail_out),fe)})),new ve(4,4,8,4,p),new ve(4,5,16,8,p),new ve(4,6,32,32,p),new ve(4,4,16,16,h),new ve(8,16,32,32,h),new ve(8,16,128,128,h),new ve(8,32,128,256,h),new ve(32,128,258,1024,h),new ve(32,258,258,4096,h)],r.deflateInit=function(e,t){return E(e,t,j,q,X,B)},r.deflateInit2=E,r.deflateReset=y,r.deflateResetKeep=g,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?k:(e.state.gzhead=t,P):k},r.deflate=function(e,t){var r,s,f,d;if(!e||!e.state||t>H||0>t)return e?n(e,k):k;if(s=e.state,!e.output||!e.input&&0!==e.avail_in||s.status===ce&&t!==L)return n(e,0===e.avail_out?D:k);if(s.strm=e,r=s.last_flush,s.last_flush=t,s.status===ne)if(2===s.wrap)e.adler=0,l(s,31),l(s,139),l(s,8),s.gzhead?(l(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),l(s,255&s.gzhead.time),l(s,s.gzhead.time>>8&255),l(s,s.gzhead.time>>16&255),l(s,s.gzhead.time>>24&255),l(s,9===s.level?2:s.strategy>=O||s.level<2?4:0),l(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(l(s,255&s.gzhead.extra.length),l(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(e.adler=S(e.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=ae):(l(s,0),l(s,0),l(s,0),l(s,0),l(s,0),l(s,9===s.level?2:s.strategy>=O||s.level<2?4:0),l(s,he),s.status=le);else{var u=j+(s.w_bits-8<<4)<<8;u|=(s.strategy>=O||s.level<2?0:s.level<6?1:6===s.level?2:3)<<6,0!==s.strstart&&(u|=re),u+=31-u%31,s.status=le,c(s,u),0!==s.strstart&&(c(s,e.adler>>>16),c(s,65535&e.adler)),e.adler=1}if(s.status===ae)if(s.gzhead.extra){for(f=s.pending;s.gzindex<(65535&s.gzhead.extra.length)&&(s.pending!==s.pending_buf_size||(s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),i(e),f=s.pending,s.pending!==s.pending_buf_size));)l(s,255&s.gzhead.extra[s.gzindex]),s.gzindex++;s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),s.gzindex===s.gzhead.extra.length&&(s.gzindex=0,s.status=oe)}else s.status=oe;if(s.status===oe)if(s.gzhead.name){f=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),i(e),f=s.pending,s.pending===s.pending_buf_size)){d=1;break}d=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,l(s,d)}while(0!==d);s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),0===d&&(s.gzindex=0,s.status=ie)}else s.status=ie;if(s.status===ie)if(s.gzhead.comment){f=s.pending;do{if(s.pending===s.pending_buf_size&&(s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),i(e),f=s.pending,s.pending===s.pending_buf_size)){d=1;break}d=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,l(s,d)}while(0!==d);s.gzhead.hcrc&&s.pending>f&&(e.adler=S(e.adler,s.pending_buf,s.pending-f,f)),0===d&&(s.status=se)}else s.status=se;if(s.status===se&&(s.gzhead.hcrc?(s.pending+2>s.pending_buf_size&&i(e),s.pending+2<=s.pending_buf_size&&(l(s,255&e.adler),l(s,e.adler>>8&255),e.adler=0,s.status=le)):s.status=le),0!==s.pending){if(i(e),0===e.avail_out)return s.last_flush=-1,P}else if(0===e.avail_in&&a(t)<=a(r)&&t!==L)return n(e,D);if(s.status===ce&&0!==e.avail_in)return n(e,D);if(0!==e.avail_in||0!==s.lookahead||t!==A&&s.status!==ce){var p=s.strategy===O?m(s,t):s.strategy===U?v(s,t):w[s.level].func(s,t);if((p===ue||p===pe)&&(s.status=ce),p===fe||p===ue)return 0===e.avail_out&&(s.last_flush=-1),P;if(p===de&&(t===M?T._tr_align(s):t!==H&&(T._tr_stored_block(s,0,0,!1),t===C&&(o(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),i(e),0===e.avail_out))return s.last_flush=-1,P}return t!==L?P:s.wrap<=0?z:(2===s.wrap?(l(s,255&e.adler),l(s,e.adler>>8&255),l(s,e.adler>>16&255),l(s,e.adler>>24&255),l(s,255&e.total_in),l(s,e.total_in>>8&255),l(s,e.total_in>>16&255),l(s,e.total_in>>24&255)):(c(s,e.adler>>>16),c(s,65535&e.adler)),i(e),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?P:z)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==ne&&t!==ae&&t!==oe&&t!==ie&&t!==se&&t!==le&&t!==ce?n(e,k):(e.state=null,t===le?n(e,N):P):k},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(e,t){"use strict";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],34:[function(e,t){"use strict";t.exports=function(e,t){var r,n,a,o,i,s,l,c,f,d,u,p,h,v,m,x,g,y,E,w,b,T,_,S,R;r=e.state,n=e.next_in,S=e.input,a=n+(e.avail_in-5),o=e.next_out,R=e.output,i=o-(t-e.avail_out),s=o+(e.avail_out-257),l=r.dmax,c=r.wsize,f=r.whave,d=r.wnext,u=r.window,p=r.hold,h=r.bits,v=r.lencode,m=r.distcode,x=(1<<r.lenbits)-1,g=(1<<r.distbits)-1;e:do{15>h&&(p+=S[n++]<<h,h+=8,p+=S[n++]<<h,h+=8),y=v[p&x];t:for(;;){if(p>>>=E=y>>>24,h-=E,0==(E=y>>>16&255))R[o++]=65535&y;else{if(!(16&E)){if(0==(64&E)){y=v[(65535&y)+(p&(1<<E)-1)];continue t}if(32&E){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&y,(E&=15)&&(E>h&&(p+=S[n++]<<h,h+=8),w+=p&(1<<E)-1,p>>>=E,h-=E),15>h&&(p+=S[n++]<<h,h+=8,p+=S[n++]<<h,h+=8),y=m[p&g];r:for(;;){if(p>>>=E=y>>>24,h-=E,!(16&(E=y>>>16&255))){if(0==(64&E)){y=m[(65535&y)+(p&(1<<E)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(b=65535&y,(E&=15)>h&&(p+=S[n++]<<h,E>(h+=8)&&(p+=S[n++]<<h,h+=8)),(b+=p&(1<<E)-1)>l){e.msg="invalid distance too far back",r.mode=30;break e}if(p>>>=E,h-=E,b>(E=o-i)){if((E=b-E)>f&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(T=0,_=u,0===d){if(T+=c-E,w>E){w-=E;do{R[o++]=u[T++]}while(--E);T=o-b,_=R}}else if(E>d){if(T+=c+d-E,w>(E-=d)){w-=E;do{R[o++]=u[T++]}while(--E);if(T=0,w>d){w-=E=d;do{R[o++]=u[T++]}while(--E);T=o-b,_=R}}}else if(T+=d-E,w>E){w-=E;do{R[o++]=u[T++]}while(--E);T=o-b,_=R}for(;w>2;)R[o++]=_[T++],R[o++]=_[T++],R[o++]=_[T++],w-=3;w&&(R[o++]=_[T++],w>1&&(R[o++]=_[T++]))}else{T=o-b;do{R[o++]=R[T++],R[o++]=R[T++],R[o++]=R[T++],w-=3}while(w>2);w&&(R[o++]=R[T++],w>1&&(R[o++]=R[T++]))}break}}break}}while(a>n&&s>o);n-=w=h>>3,p&=(1<<(h-=w<<3))-1,e.next_in=n,e.next_out=o,e.avail_in=a>n?a-n+5:5-(n-a),e.avail_out=s>o?s-o+257:257-(o-s),r.hold=p,r.bits=h}},{}],35:[function(e,t,r){"use strict";function n(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function a(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new u.Buf16(320),this.work=new u.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function o(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=H,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new u.Buf32(ce),t.distcode=t.distdyn=new u.Buf32(fe),t.sane=1,t.back=-1,T):R}function i(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,o(e)):R}function s(e,t){var r,n;return e&&e.state?(n=e.state,0>t?(r=0,t=-t):(r=1+(t>>4),48>t&&(t&=15)),t&&(8>t||t>15)?R:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,i(e))):R}function l(e,t){var r,n;return e?(n=new a,e.state=n,n.window=null,(r=s(e,t))!==T&&(e.state=null),r):R}function c(e){if(ue){var t;for(f=new u.Buf32(512),d=new u.Buf32(32),t=0;144>t;)e.lens[t++]=8;for(;256>t;)e.lens[t++]=9;for(;280>t;)e.lens[t++]=7;for(;288>t;)e.lens[t++]=8;for(m(g,e.lens,0,288,f,0,e.work,{bits:9}),t=0;32>t;)e.lens[t++]=5;m(y,e.lens,0,32,d,0,e.work,{bits:5}),ue=!1}e.lencode=f,e.lenbits=9,e.distcode=d,e.distbits=5}var f,d,u=e("../utils/common"),p=e("./adler32"),h=e("./crc32"),v=e("./inffast"),m=e("./inftrees"),x=0,g=1,y=2,E=4,w=5,b=6,T=0,_=1,S=2,R=-2,A=-3,M=-4,C=-5,L=8,H=1,P=2,z=3,k=4,N=5,D=6,F=7,I=8,O=9,U=10,G=11,B=12,V=13,j=14,W=15,q=16,X=17,Y=18,Z=19,Q=20,K=21,J=22,$=23,ee=24,te=25,re=26,ne=27,ae=28,oe=29,ie=30,se=31,le=32,ce=852,fe=592,de=15,ue=!0;r.inflateReset=i,r.inflateReset2=s,r.inflateResetKeep=o,r.inflateInit=function(e){return l(e,de)},r.inflateInit2=l,r.inflate=function(e,t){var r,a,o,i,s,l,f,d,ce,fe,de,ue,pe,he,ve,me,xe,ge,ye,Ee,we,be,Te,_e,Se=0,Re=new u.Buf8(4),Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return R;(r=e.state).mode===B&&(r.mode=V),s=e.next_out,o=e.output,f=e.avail_out,i=e.next_in,a=e.input,l=e.avail_in,d=r.hold,ce=r.bits,fe=l,de=f,be=T;e:for(;;)switch(r.mode){case H:if(0===r.wrap){r.mode=V;break}for(;16>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(2&r.wrap&&35615===d){r.check=0,Re[0]=255&d,Re[1]=d>>>8&255,r.check=h(r.check,Re,2,0),d=0,ce=0,r.mode=P;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&d)<<8)+(d>>8))%31){e.msg="incorrect header check",r.mode=ie;break}if((15&d)!==L){e.msg="unknown compression method",r.mode=ie;break}if(ce-=4,we=8+(15&(d>>>=4)),0===r.wbits)r.wbits=we;else if(we>r.wbits){e.msg="invalid window size",r.mode=ie;break}r.dmax=1<<we,e.adler=r.check=1,r.mode=512&d?U:B,d=0,ce=0;break;case P:for(;16>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(r.flags=d,(255&r.flags)!==L){e.msg="unknown compression method",r.mode=ie;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=ie;break}r.head&&(r.head.text=d>>8&1),512&r.flags&&(Re[0]=255&d,Re[1]=d>>>8&255,r.check=h(r.check,Re,2,0)),d=0,ce=0,r.mode=z;case z:for(;32>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.head&&(r.head.time=d),512&r.flags&&(Re[0]=255&d,Re[1]=d>>>8&255,Re[2]=d>>>16&255,Re[3]=d>>>24&255,r.check=h(r.check,Re,4,0)),d=0,ce=0,r.mode=k;case k:for(;16>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.head&&(r.head.xflags=255&d,r.head.os=d>>8),512&r.flags&&(Re[0]=255&d,Re[1]=d>>>8&255,r.check=h(r.check,Re,2,0)),d=0,ce=0,r.mode=N;case N:if(1024&r.flags){for(;16>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.length=d,r.head&&(r.head.extra_len=d),512&r.flags&&(Re[0]=255&d,Re[1]=d>>>8&255,r.check=h(r.check,Re,2,0)),d=0,ce=0}else r.head&&(r.head.extra=null);r.mode=D;case D:if(1024&r.flags&&((ue=r.length)>l&&(ue=l),ue&&(r.head&&(we=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),u.arraySet(r.head.extra,a,i,ue,we)),512&r.flags&&(r.check=h(r.check,a,ue,i)),l-=ue,i+=ue,r.length-=ue),r.length))break e;r.length=0,r.mode=F;case F:if(2048&r.flags){if(0===l)break e;ue=0;do{we=a[i+ue++],r.head&&we&&r.length<65536&&(r.head.name+=String.fromCharCode(we))}while(we&&l>ue);if(512&r.flags&&(r.check=h(r.check,a,ue,i)),l-=ue,i+=ue,we)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=I;case I:if(4096&r.flags){if(0===l)break e;ue=0;do{we=a[i+ue++],r.head&&we&&r.length<65536&&(r.head.comment+=String.fromCharCode(we))}while(we&&l>ue);if(512&r.flags&&(r.check=h(r.check,a,ue,i)),l-=ue,i+=ue,we)break e}else r.head&&(r.head.comment=null);r.mode=O;case O:if(512&r.flags){for(;16>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(d!==(65535&r.check)){e.msg="header crc mismatch",r.mode=ie;break}d=0,ce=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=B;break;case U:for(;32>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}e.adler=r.check=n(d),d=0,ce=0,r.mode=G;case G:if(0===r.havedict)return e.next_out=s,e.avail_out=f,e.next_in=i,e.avail_in=l,r.hold=d,r.bits=ce,S;e.adler=r.check=1,r.mode=B;case B:if(t===w||t===b)break e;case V:if(r.last){d>>>=7&ce,ce-=7&ce,r.mode=ne;break}for(;3>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}switch(r.last=1&d,ce-=1,3&(d>>>=1)){case 0:r.mode=j;break;case 1:if(c(r),r.mode=Q,t===b){d>>>=2,ce-=2;break e}break;case 2:r.mode=X;break;case 3:e.msg="invalid block type",r.mode=ie}d>>>=2,ce-=2;break;case j:for(d>>>=7&ce,ce-=7&ce;32>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if((65535&d)!=(d>>>16^65535)){e.msg="invalid stored block lengths",r.mode=ie;break}if(r.length=65535&d,d=0,ce=0,r.mode=W,t===b)break e;case W:r.mode=q;case q:if(ue=r.length){if(ue>l&&(ue=l),ue>f&&(ue=f),0===ue)break e;u.arraySet(o,a,i,ue,s),l-=ue,i+=ue,f-=ue,s+=ue,r.length-=ue;break}r.mode=B;break;case X:for(;14>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(r.nlen=257+(31&d),d>>>=5,ce-=5,r.ndist=1+(31&d),d>>>=5,ce-=5,r.ncode=4+(15&d),d>>>=4,ce-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=ie;break}r.have=0,r.mode=Y;case Y:for(;r.have<r.ncode;){for(;3>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.lens[Ae[r.have++]]=7&d,d>>>=3,ce-=3}for(;r.have<19;)r.lens[Ae[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,Te={bits:r.lenbits},be=m(x,r.lens,0,19,r.lencode,0,r.work,Te),r.lenbits=Te.bits,be){e.msg="invalid code lengths set",r.mode=ie;break}r.have=0,r.mode=Z;case Z:for(;r.have<r.nlen+r.ndist;){for(;me=(Se=r.lencode[d&(1<<r.lenbits)-1])>>>16&255,xe=65535&Se,!(ce>=(ve=Se>>>24));){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(16>xe)d>>>=ve,ce-=ve,r.lens[r.have++]=xe;else{if(16===xe){for(_e=ve+2;_e>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(d>>>=ve,ce-=ve,0===r.have){e.msg="invalid bit length repeat",r.mode=ie;break}we=r.lens[r.have-1],ue=3+(3&d),d>>>=2,ce-=2}else if(17===xe){for(_e=ve+3;_e>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}ce-=ve,we=0,ue=3+(7&(d>>>=ve)),d>>>=3,ce-=3}else{for(_e=ve+7;_e>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}ce-=ve,we=0,ue=11+(127&(d>>>=ve)),d>>>=7,ce-=7}if(r.have+ue>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=ie;break}for(;ue--;)r.lens[r.have++]=we}}if(r.mode===ie)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=ie;break}if(r.lenbits=9,Te={bits:r.lenbits},be=m(g,r.lens,0,r.nlen,r.lencode,0,r.work,Te),r.lenbits=Te.bits,be){e.msg="invalid literal/lengths set",r.mode=ie;break}if(r.distbits=6,r.distcode=r.distdyn,Te={bits:r.distbits},be=m(y,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,Te),r.distbits=Te.bits,be){e.msg="invalid distances set",r.mode=ie;break}if(r.mode=Q,t===b)break e;case Q:r.mode=K;case K:if(l>=6&&f>=258){e.next_out=s,e.avail_out=f,e.next_in=i,e.avail_in=l,r.hold=d,r.bits=ce,v(e,de),s=e.next_out,o=e.output,f=e.avail_out,i=e.next_in,a=e.input,l=e.avail_in,d=r.hold,ce=r.bits,r.mode===B&&(r.back=-1);break}for(r.back=0;me=(Se=r.lencode[d&(1<<r.lenbits)-1])>>>16&255,xe=65535&Se,!(ce>=(ve=Se>>>24));){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(me&&0==(240&me)){for(ge=ve,ye=me,Ee=xe;me=(Se=r.lencode[Ee+((d&(1<<ge+ye)-1)>>ge)])>>>16&255,xe=65535&Se,!(ce>=ge+(ve=Se>>>24));){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}d>>>=ge,ce-=ge,r.back+=ge}if(d>>>=ve,ce-=ve,r.back+=ve,r.length=xe,0===me){r.mode=re;break}if(32&me){r.back=-1,r.mode=B;break}if(64&me){e.msg="invalid literal/length code",r.mode=ie;break}r.extra=15&me,r.mode=J;case J:if(r.extra){for(_e=r.extra;_e>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.length+=d&(1<<r.extra)-1,d>>>=r.extra,ce-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=$;case $:for(;me=(Se=r.distcode[d&(1<<r.distbits)-1])>>>16&255,xe=65535&Se,!(ce>=(ve=Se>>>24));){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(0==(240&me)){for(ge=ve,ye=me,Ee=xe;me=(Se=r.distcode[Ee+((d&(1<<ge+ye)-1)>>ge)])>>>16&255,xe=65535&Se,!(ce>=ge+(ve=Se>>>24));){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}d>>>=ge,ce-=ge,r.back+=ge}if(d>>>=ve,ce-=ve,r.back+=ve,64&me){e.msg="invalid distance code",r.mode=ie;break}r.offset=xe,r.extra=15&me,r.mode=ee;case ee:if(r.extra){for(_e=r.extra;_e>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}r.offset+=d&(1<<r.extra)-1,d>>>=r.extra,ce-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=ie;break}r.mode=te;case te:if(0===f)break e;if(ue=de-f,r.offset>ue){if((ue=r.offset-ue)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=ie;break}ue>r.wnext?(ue-=r.wnext,pe=r.wsize-ue):pe=r.wnext-ue,ue>r.length&&(ue=r.length),he=r.window}else he=o,pe=s-r.offset,ue=r.length;ue>f&&(ue=f),f-=ue,r.length-=ue;do{o[s++]=he[pe++]}while(--ue);0===r.length&&(r.mode=K);break;case re:if(0===f)break e;o[s++]=r.length,f--,r.mode=K;break;case ne:if(r.wrap){for(;32>ce;){if(0===l)break e;l--,d|=a[i++]<<ce,ce+=8}if(de-=f,e.total_out+=de,r.total+=de,de&&(e.adler=r.check=r.flags?h(r.check,o,de,s-de):p(r.check,o,de,s-de)),de=f,(r.flags?d:n(d))!==r.check){e.msg="incorrect data check",r.mode=ie;break}d=0,ce=0}r.mode=ae;case ae:if(r.wrap&&r.flags){for(;32>ce;){if(0===l)break e;l--,d+=a[i++]<<ce,ce+=8}if(d!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=ie;break}d=0,ce=0}r.mode=oe;case oe:be=_;break e;case ie:be=A;break e;case se:return M;case le:default:return R}return e.next_out=s,e.avail_out=f,e.next_in=i,e.avail_in=l,r.hold=d,r.bits=ce,(r.wsize||de!==e.avail_out&&r.mode<ie&&(r.mode<ne||t!==E))&&function(e,t,r,n){var a,o=e.state;return null===o.window&&(o.wsize=1<<o.wbits,o.wnext=0,o.whave=0,o.window=new u.Buf8(o.wsize)),n>=o.wsize?(u.arraySet(o.window,t,r-o.wsize,o.wsize,0),o.wnext=0,o.whave=o.wsize):((a=o.wsize-o.wnext)>n&&(a=n),u.arraySet(o.window,t,r-n,a,o.wnext),(n-=a)?(u.arraySet(o.window,t,r-n,n,0),o.wnext=n,o.whave=o.wsize):(o.wnext+=a,o.wnext===o.wsize&&(o.wnext=0),o.whave<o.wsize&&(o.whave+=a))),0}(e,e.output,e.next_out,de-e.avail_out)?(r.mode=se,M):(fe-=e.avail_in,de-=e.avail_out,e.total_in+=fe,e.total_out+=de,r.total+=de,r.wrap&&de&&(e.adler=r.check=r.flags?h(r.check,o,de,e.next_out-de):p(r.check,o,de,e.next_out-de)),e.data_type=r.bits+(r.last?64:0)+(r.mode===B?128:0)+(r.mode===Q||r.mode===W?256:0),(0===fe&&0===de||t===E)&&be===T&&(be=C),be)},r.inflateEnd=function(e){if(!e||!e.state)return R;var t=e.state;return t.window&&(t.window=null),e.state=null,T},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?R:(r.head=t,t.done=!1,T):R},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(e,t){"use strict";var r=e("../utils/common"),n=15,a=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],o=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],i=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],s=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,l,c,f,d,u,p){var h,v,m,x,g,y,E,w,b,T=p.bits,_=0,S=0,R=0,A=0,M=0,C=0,L=0,H=0,P=0,z=0,k=null,N=0,D=new r.Buf16(16),F=new r.Buf16(16),I=null,O=0;for(_=0;n>=_;_++)D[_]=0;for(S=0;c>S;S++)D[t[l+S]]++;for(M=T,A=n;A>=1&&0===D[A];A--);if(M>A&&(M=A),0===A)return f[d++]=20971520,f[d++]=20971520,p.bits=1,0;for(R=1;A>R&&0===D[R];R++);for(R>M&&(M=R),H=1,_=1;n>=_;_++)if(H<<=1,0>(H-=D[_]))return-1;if(H>0&&(0===e||1!==A))return-1;for(F[1]=0,_=1;n>_;_++)F[_+1]=F[_]+D[_];for(S=0;c>S;S++)0!==t[l+S]&&(u[F[t[l+S]]++]=S);if(0===e?(k=I=u,y=19):1===e?(k=a,N-=257,I=o,O-=257,y=256):(k=i,I=s,y=-1),z=0,S=0,_=R,g=d,C=M,L=0,m=-1,x=(P=1<<M)-1,1===e&&P>852||2===e&&P>592)return 1;for(;;){E=_-L,u[S]<y?(w=0,b=u[S]):u[S]>y?(w=I[O+u[S]],b=k[N+u[S]]):(w=96,b=0),h=1<<_-L,R=v=1<<C;do{f[g+(z>>L)+(v-=h)]=E<<24|w<<16|b|0}while(0!==v);for(h=1<<_-1;z&h;)h>>=1;if(0!==h?(z&=h-1,z+=h):z=0,S++,0==--D[_]){if(_===A)break;_=t[l+u[S]]}if(_>M&&(z&x)!==m){for(0===L&&(L=M),g+=R,H=1<<(C=_-L);A>C+L&&!(0>=(H-=D[C+L]));)C++,H<<=1;if(P+=1<<C,1===e&&P>852||2===e&&P>592)return 1;f[m=z&x]=M<<24|C<<16|g-d|0}}return 0!==z&&(f[g+z]=_-L<<24|64<<16|0),p.bits=M,0}},{"../utils/common":27}],37:[function(e,t){"use strict";t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],38:[function(e,t,r){"use strict";function n(e){for(var t=e.length;--t>=0;)e[t]=0}function a(e){return 256>e?q[e]:q[256+(e>>>7)]}function o(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function i(e,t,r){e.bi_valid>k-r?(e.bi_buf|=t<<e.bi_valid&65535,o(e,e.bi_buf),e.bi_buf=t>>k-e.bi_valid,e.bi_valid+=r-k):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function s(e,t,r){i(e,r[2*t],r[2*t+1])}function l(e,t){var r=0;do{r|=1&e,e>>>=1,r<<=1}while(--t>0);return r>>>1}function c(e,t,r){var n,a,o=new Array(z+1),i=0;for(n=1;z>=n;n++)o[n]=i=i+r[n-1]<<1;for(a=0;t>=a;a++){var s=e[2*a+1];0!==s&&(e[2*a]=l(o[s]++,s))}}function f(e){var t;for(t=0;C>t;t++)e.dyn_ltree[2*t]=0;for(t=0;L>t;t++)e.dyn_dtree[2*t]=0;for(t=0;H>t;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*D]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function d(e){e.bi_valid>8?o(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function u(e,t,r,n){var a=2*t,o=2*r;return e[a]<e[o]||e[a]===e[o]&&n[t]<=n[r]}function p(e,t,r){for(var n=e.heap[r],a=r<<1;a<=e.heap_len&&(a<e.heap_len&&u(t,e.heap[a+1],e.heap[a],e.depth)&&a++,!u(t,n,e.heap[a],e.depth));)e.heap[r]=e.heap[a],r=a,a<<=1;e.heap[r]=n}function h(e,t,r){var n,o,l,c,f=0;if(0!==e.last_lit)do{n=e.pending_buf[e.d_buf+2*f]<<8|e.pending_buf[e.d_buf+2*f+1],o=e.pending_buf[e.l_buf+f],f++,0===n?s(e,o,t):(s(e,(l=X[o])+M+1,t),0!==(c=U[l])&&i(e,o-=Y[l],c),s(e,l=a(--n),r),0!==(c=G[l])&&i(e,n-=Z[l],c))}while(f<e.last_lit);s(e,D,t)}function v(e,t){var r,n,a,o=t.dyn_tree,i=t.stat_desc.static_tree,s=t.stat_desc.has_stree,l=t.stat_desc.elems,f=-1;for(e.heap_len=0,e.heap_max=P,r=0;l>r;r++)0!==o[2*r]?(e.heap[++e.heap_len]=f=r,e.depth[r]=0):o[2*r+1]=0;for(;e.heap_len<2;)o[2*(a=e.heap[++e.heap_len]=2>f?++f:0)]=1,e.depth[a]=0,e.opt_len--,s&&(e.static_len-=i[2*a+1]);for(t.max_code=f,r=e.heap_len>>1;r>=1;r--)p(e,o,r);a=l;do{r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],p(e,o,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,o[2*a]=o[2*r]+o[2*n],e.depth[a]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,o[2*r+1]=o[2*n+1]=a,e.heap[1]=a++,p(e,o,1)}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,a,o,i,s,l=t.dyn_tree,c=t.max_code,f=t.stat_desc.static_tree,d=t.stat_desc.has_stree,u=t.stat_desc.extra_bits,p=t.stat_desc.extra_base,h=t.stat_desc.max_length,v=0;for(o=0;z>=o;o++)e.bl_count[o]=0;for(l[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;P>r;r++)(o=l[2*l[2*(n=e.heap[r])+1]+1]+1)>h&&(o=h,v++),l[2*n+1]=o,n>c||(e.bl_count[o]++,i=0,n>=p&&(i=u[n-p]),s=l[2*n],e.opt_len+=s*(o+i),d&&(e.static_len+=s*(f[2*n+1]+i)));if(0!==v){do{for(o=h-1;0===e.bl_count[o];)o--;e.bl_count[o]--,e.bl_count[o+1]+=2,e.bl_count[h]--,v-=2}while(v>0);for(o=h;0!==o;o--)for(n=e.bl_count[o];0!==n;)(a=e.heap[--r])>c||(l[2*a+1]!==o&&(e.opt_len+=(o-l[2*a+1])*l[2*a],l[2*a+1]=o),n--)}}(e,t),c(o,f,e.bl_count)}function m(e,t,r){var n,a,o=-1,i=t[1],s=0,l=7,c=4;for(0===i&&(l=138,c=3),t[2*(r+1)+1]=65535,n=0;r>=n;n++)a=i,i=t[2*(n+1)+1],++s<l&&a===i||(c>s?e.bl_tree[2*a]+=s:0!==a?(a!==o&&e.bl_tree[2*a]++,e.bl_tree[2*F]++):10>=s?e.bl_tree[2*I]++:e.bl_tree[2*O]++,s=0,o=a,0===i?(l=138,c=3):a===i?(l=6,c=3):(l=7,c=4))}function x(e,t,r){var n,a,o=-1,l=t[1],c=0,f=7,d=4;for(0===l&&(f=138,d=3),n=0;r>=n;n++)if(a=l,l=t[2*(n+1)+1],!(++c<f&&a===l)){if(d>c)do{s(e,a,e.bl_tree)}while(0!=--c);else 0!==a?(a!==o&&(s(e,a,e.bl_tree),c--),s(e,F,e.bl_tree),i(e,c-3,2)):10>=c?(s(e,I,e.bl_tree),i(e,c-3,3)):(s(e,O,e.bl_tree),i(e,c-11,7));c=0,o=a,0===l?(f=138,d=3):a===l?(f=6,d=3):(f=7,d=4)}}function g(e,t,r,n){i(e,(_<<1)+(n?1:0),3),function(e,t,r,n){d(e),n&&(o(e,r),o(e,~r)),y.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r}(e,t,r,!0)}var y=e("../utils/common"),E=4,w=0,b=1,T=2,_=0,S=1,R=2,A=29,M=256,C=M+1+A,L=30,H=19,P=2*C+1,z=15,k=16,N=7,D=256,F=16,I=17,O=18,U=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],G=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],B=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],V=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],j=new Array(2*(C+2));n(j);var W=new Array(2*L);n(W);var q=new Array(512);n(q);var X=new Array(256);n(X);var Y=new Array(A);n(Y);var Z=new Array(L);n(Z);var Q,K,J,$=function(e,t,r,n,a){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=a,this.has_stree=e&&e.length},ee=function(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t},te=!1;r._tr_init=function(e){te||(function(){var e,t,r,n,a,o=new Array(z+1);for(r=0,n=0;A-1>n;n++)for(Y[n]=r,e=0;e<1<<U[n];e++)X[r++]=n;for(X[r-1]=n,a=0,n=0;16>n;n++)for(Z[n]=a,e=0;e<1<<G[n];e++)q[a++]=n;for(a>>=7;L>n;n++)for(Z[n]=a<<7,e=0;e<1<<G[n]-7;e++)q[256+a++]=n;for(t=0;z>=t;t++)o[t]=0;for(e=0;143>=e;)j[2*e+1]=8,e++,o[8]++;for(;255>=e;)j[2*e+1]=9,e++,o[9]++;for(;279>=e;)j[2*e+1]=7,e++,o[7]++;for(;287>=e;)j[2*e+1]=8,e++,o[8]++;for(c(j,C+1,o),e=0;L>e;e++)W[2*e+1]=5,W[2*e]=l(e,5);Q=new $(j,U,M+1,C,z),K=new $(W,G,0,L,z),J=new $(new Array(0),B,0,H,N)}(),te=!0),e.l_desc=new ee(e.dyn_ltree,Q),e.d_desc=new ee(e.dyn_dtree,K),e.bl_desc=new ee(e.bl_tree,J),e.bi_buf=0,e.bi_valid=0,f(e)},r._tr_stored_block=g,r._tr_flush_block=function(e,t,r,n){var a,o,s=0;e.level>0?(e.strm.data_type===T&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;31>=t;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return w;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return b;for(t=32;M>t;t++)if(0!==e.dyn_ltree[2*t])return b;return w}(e)),v(e,e.l_desc),v(e,e.d_desc),s=function(e){var t;for(m(e,e.dyn_ltree,e.l_desc.max_code),m(e,e.dyn_dtree,e.d_desc.max_code),v(e,e.bl_desc),t=H-1;t>=3&&0===e.bl_tree[2*V[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),(a=e.opt_len+3+7>>>3)>=(o=e.static_len+3+7>>>3)&&(a=o)):a=o=r+5,a>=r+4&&-1!==t?g(e,t,r,n):e.strategy===E||o===a?(i(e,(S<<1)+(n?1:0),3),h(e,j,W)):(i(e,(R<<1)+(n?1:0),3),function(e,t,r,n){var a;for(i(e,t-257,5),i(e,r-1,5),i(e,n-4,4),a=0;n>a;a++)i(e,e.bl_tree[2*V[a]+1],3);x(e,e.dyn_ltree,t-1),x(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,s+1),h(e,e.dyn_ltree,e.dyn_dtree)),f(e),n&&d(e)},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(X[r]+M+1)]++,e.dyn_dtree[2*a(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){i(e,S<<1,3),s(e,D,j),function(e){16===e.bi_valid?(o(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8)}(e)}},{"../utils/common":27}],39:[function(e,t){"use strict";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}]},{},[9])(9)}).call(this,r(33).Buffer)},function(e,t,r){"undefined"!=typeof self&&self,e.exports=function(e){var t={};function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=18)}([function(e,t,r){"use strict";function n(e){return e&&0===e.length}function a(e){return null==e?[]:Object.keys(e)}function o(e){for(var t=[],r=Object.keys(e),n=0;n<r.length;n++)t.push(e[r[n]]);return t}function i(e,t){if(Array.isArray(e))for(var r=0;r<e.length;r++)t.call(null,e[r],r);else{if(!m(e))throw Error("non exhaustive match");var n=a(e);for(r=0;r<n.length;r++){var o=n[r],i=e[o];t.call(null,i,o)}}}function s(e){return void 0===e}function l(e,t){var r=[];if(Array.isArray(e))for(var n=0;n<e.length;n++){var a=e[n];t.call(null,a)&&r.push(a)}return r}function c(e,t){return l(e,(function(e){return!t(e)}))}function f(e,t){return!!m(e)&&e.hasOwnProperty(t)}function d(e,t){return void 0!==h(e,(function(e){return e===t}))}function u(e){for(var t=[],r=0;r<e.length;r++)t.push(e[r]);return t}function p(e){var t={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}function h(e,t){for(var r=0;r<e.length;r++){var n=e[r];if(t.call(null,n))return n}}function v(e,t,r){for(var n=Array.isArray(e),i=n?e:o(e),s=n?[]:a(e),l=r,c=0;c<i.length;c++)l=t.call(null,l,i[c],n?c:s[c]);return l}function m(e){return e instanceof Object}function x(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];for(var n=0;n<t.length;n++){var o=t[n];if(!s(o))for(var i=a(o),l=0;l<i.length;l++){var c=i[l];f(e,c)||(e[c]=o[c])}}return e}Object.defineProperty(t,"__esModule",{value:!0}),t.isEmpty=n,t.keys=a,t.values=o,t.mapValues=function(e,t){for(var r=[],n=a(e),o=0;o<n.length;o++){var i=n[o];r.push(t.call(null,e[i],i))}return r},t.map=function(e,t){for(var r=[],n=0;n<e.length;n++)r.push(t.call(null,e[n],n));return r},t.flatten=function e(t){for(var r=[],n=0;n<t.length;n++){var a=t[n];Array.isArray(a)?r=r.concat(e(a)):r.push(a)}return r},t.first=function(e){return n(e)?void 0:e[0]},t.last=function(e){var t=e&&e.length;return t?e[t-1]:void 0},t.forEach=i,t.isString=function(e){return"string"==typeof e},t.isUndefined=s,t.isFunction=function(e){return e instanceof Function},t.drop=function(e,t){return void 0===t&&(t=1),e.slice(t,e.length)},t.dropRight=function(e,t){return void 0===t&&(t=1),e.slice(0,e.length-t)},t.filter=l,t.reject=c,t.pick=function(e,t){for(var r=Object.keys(e),n={},a=0;a<r.length;a++){var o=r[a],i=e[o];t(i)&&(n[o]=i)}return n},t.has=f,t.contains=d,t.cloneArr=u,t.cloneObj=p,t.find=h,t.findAll=function(e,t){for(var r=[],n=0;n<e.length;n++){var a=e[n];t.call(null,a)&&r.push(a)}return r},t.reduce=v,t.compact=function(e){return c(e,(function(e){return null==e}))},t.uniq=function(e,t){void 0===t&&(t=function(e){return e});var r=[];return v(e,(function(e,n){var a=t(n);return d(r,a)?e:(r.push(a),e.concat(n))}),[])},t.partial=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var n=[null].concat(t);return Function.bind.apply(e,n)},t.isArray=function(e){return Array.isArray(e)},t.isRegExp=function(e){return e instanceof RegExp},t.isObject=m,t.every=function(e,t){for(var r=0;r<e.length;r++)if(!t(e[r],r))return!1;return!0},t.difference=function(e,t){return c(e,(function(e){return d(t,e)}))},t.some=function(e,t){for(var r=0;r<e.length;r++)if(t(e[r]))return!0;return!1},t.indexOf=function(e,t){for(var r=0;r<e.length;r++)if(e[r]===t)return r;return-1},t.sortBy=function(e,t){var r=u(e);return r.sort((function(e,r){return t(e)-t(r)})),r},t.zipObject=function(e,t){if(e.length!==t.length)throw Error("can't zipObject with different number of keys and values!");for(var r={},n=0;n<e.length;n++)r[e[n]]=t[n];return r},t.assign=function(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];for(var n=0;n<t.length;n++)for(var o=t[n],i=a(o),s=0;s<i.length;s++){var l=i[s];e[l]=o[l]}return e},t.assignNoOverwrite=x,t.defaults=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return x.apply(null,[{}].concat(e))},t.groupBy=function(e,t){var r={};return i(e,(function(e){var n=t(e),a=r[n];a?a.push(e):r[n]=[e]})),r},t.merge=function(e,t){for(var r=p(e),n=a(t),o=0;o<n.length;o++){var i=n[o],s=t[i];r[i]=s}return r},t.NOOP=function(){},t.IDENTITY=function(e){return e},t.packArray=function(e){for(var t=[],r=0;r<e.length;r++){var n=e[r];t.push(void 0!==n?n:void 0)}return t},t.PRINT_ERROR=function(e){console&&console.error&&console.error("Error: "+e)},t.PRINT_WARNING=function(e){console&&console.warn&&console.warn("Warning: "+e)},t.isES2015MapSupported=function(){return"function"==typeof Map},t.applyMixins=function(e,t){t.forEach((function(t){var r=t.prototype;Object.getOwnPropertyNames(r).forEach((function(n){if("constructor"!==n){var a=Object.getOwnPropertyDescriptor(r,n);a&&(a.get||a.set)?Object.defineProperty(e.prototype,n,a):e.prototype[n]=t.prototype[n]}}))}))},t.toFastProperties=function(e){function t(){}t.prototype=e;var r=new t;function n(){return typeof r.bar}return n(),n(),e}},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(0),i=r(2),s=function(){function e(e){this.definition=e}return e.prototype.accept=function(e){e.visit(this),o.forEach(this.definition,(function(t){t.accept(e)}))},e}();t.AbstractProduction=s;var l=function(e){function t(t){var r=e.call(this,[])||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),Object.defineProperty(t.prototype,"definition",{get:function(){return void 0!==this.referencedRule?this.referencedRule.definition:[]},set:function(e){},enumerable:!0,configurable:!0}),t.prototype.accept=function(e){e.visit(this)},t}(s);t.NonTerminal=l;var c=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.orgText="",o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.Rule=c;var f=function(e){function t(t){var r=e.call(this,t.definition)||this;return o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.Flat=f;var d=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.Option=d;var u=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.RepetitionMandatory=u;var p=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.RepetitionMandatoryWithSeparator=p;var h=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.Repetition=h;var v=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.RepetitionWithSeparator=v;var m=function(e){function t(t){var r=e.call(this,t.definition)||this;return r.idx=1,o.assign(r,o.pick(t,(function(e){return void 0!==e}))),r}return a(t,e),t}(s);t.Alternation=m;var x=function(){function e(e){this.idx=1,o.assign(this,o.pick(e,(function(e){return void 0!==e})))}return e.prototype.accept=function(e){e.visit(this)},e}();function g(e){function t(e){return o.map(e,g)}if(e instanceof l)return{type:"NonTerminal",name:e.nonTerminalName,idx:e.idx};if(e instanceof f)return{type:"Flat",definition:t(e.definition)};if(e instanceof d)return{type:"Option",idx:e.idx,definition:t(e.definition)};if(e instanceof u)return{type:"RepetitionMandatory",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof p)return{type:"RepetitionMandatoryWithSeparator",name:e.name,idx:e.idx,separator:g(new x({terminalType:e.separator})),definition:t(e.definition)};if(e instanceof v)return{type:"RepetitionWithSeparator",name:e.name,idx:e.idx,separator:g(new x({terminalType:e.separator})),definition:t(e.definition)};if(e instanceof h)return{type:"Repetition",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof m)return{type:"Alternation",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof x){var r={type:"Terminal",name:i.tokenName(e.terminalType),label:i.tokenLabel(e.terminalType),idx:e.idx},n=e.terminalType.PATTERN;return e.terminalType.PATTERN&&(r.pattern=o.isRegExp(n)?n.source:n),r}if(e instanceof c)return{type:"Rule",name:e.name,orgText:e.orgText,definition:t(e.definition)};throw Error("non exhaustive match")}t.Terminal=x,t.serializeGrammar=function(e){return o.map(e,g)},t.serializeProduction=g},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(4),o=r(15),i=r(7);function s(e){return n.isString(e.LABEL)&&""!==e.LABEL}function l(e){return n.isObject(e)&&e.hasOwnProperty("tokenName")&&n.isString(e.tokenName)?e.tokenName:a.functionName(e)}t.tokenLabel=function(e){return s(e)?e.LABEL:l(e)},t.hasTokenLabel=s,t.tokenName=l;var c="categories",f="label",d="group",u="push_mode",p="pop_mode",h="longer_alt",v="line_breaks",m="start_chars_hint";function x(e){return function(e){var t=e.name,r=e.pattern,o={};if(a.defineNameProp(o,t)||(o.tokenName=t),n.isUndefined(r)||(o.PATTERN=r),n.has(e,"parent"))throw"The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";return n.has(e,c)&&(o.CATEGORIES=e[c]),i.augmentTokenTypes([o]),n.has(e,f)&&(o.LABEL=e[f]),n.has(e,d)&&(o.GROUP=e[d]),n.has(e,p)&&(o.POP_MODE=e[p]),n.has(e,u)&&(o.PUSH_MODE=e[u]),n.has(e,h)&&(o.LONGER_ALT=e[h]),n.has(e,v)&&(o.LINE_BREAKS=e[v]),n.has(e,m)&&(o.START_CHARS_HINT=e[m]),o}(e)}t.createToken=x,t.EOF=x({name:"EOF",pattern:o.Lexer.NA}),i.augmentTokenTypes([t.EOF]),t.createTokenInstance=function(e,t,r,n,a,o,i,s){return{image:t,startOffset:r,endOffset:n,startLine:a,endLine:o,startColumn:i,endColumn:s,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}},t.tokenMatcher=function(e,t){return i.tokenStructuredMatcher(e,t)}},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(4),i=r(0),s=r(26),l=r(2),c=r(23),f=r(16),d=r(10),u=r(24),p=r(25),h=r(31),v=r(32),m=r(34),x=r(35),g=r(36),y=r(37),E=r(38);t.END_OF_FILE=l.createTokenInstance(l.EOF,"",NaN,NaN,NaN,NaN,NaN,NaN),Object.freeze(t.END_OF_FILE),t.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:4,ignoredIssues:{},dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:d.defaultParserErrorProvider,serializedGrammar:null}),t.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0}),function(e){e[e.INVALID_RULE_NAME=0]="INVALID_RULE_NAME",e[e.DUPLICATE_RULE_NAME=1]="DUPLICATE_RULE_NAME",e[e.INVALID_RULE_OVERRIDE=2]="INVALID_RULE_OVERRIDE",e[e.DUPLICATE_PRODUCTIONS=3]="DUPLICATE_PRODUCTIONS",e[e.UNRESOLVED_SUBRULE_REF=4]="UNRESOLVED_SUBRULE_REF",e[e.LEFT_RECURSION=5]="LEFT_RECURSION",e[e.NONE_LAST_EMPTY_ALT=6]="NONE_LAST_EMPTY_ALT",e[e.AMBIGUOUS_ALTS=7]="AMBIGUOUS_ALTS",e[e.CONFLICT_TOKENS_RULES_NAMESPACE=8]="CONFLICT_TOKENS_RULES_NAMESPACE",e[e.INVALID_TOKEN_NAME=9]="INVALID_TOKEN_NAME",e[e.INVALID_NESTED_RULE_NAME=10]="INVALID_NESTED_RULE_NAME",e[e.DUPLICATE_NESTED_NAME=11]="DUPLICATE_NESTED_NAME",e[e.NO_NON_EMPTY_LOOKAHEAD=12]="NO_NON_EMPTY_LOOKAHEAD",e[e.AMBIGUOUS_PREFIX_ALTS=13]="AMBIGUOUS_PREFIX_ALTS",e[e.TOO_MANY_ALTS=14]="TOO_MANY_ALTS"}(t.ParserDefinitionErrorType||(t.ParserDefinitionErrorType={})),t.EMPTY_ALT=function(e){return void 0===e&&(e=void 0),function(){return e}};var w=function(){function e(e,r){void 0===r&&(r=t.DEFAULT_PARSER_CONFIG),this.ignoredIssues=t.DEFAULT_PARSER_CONFIG.ignoredIssues,this.definitionErrors=[],this.selfAnalysisDone=!1,this.initErrorHandler(r),this.initLexerAdapter(),this.initLooksAhead(r),this.initRecognizerEngine(e,r),this.initRecoverable(r),this.initTreeBuilder(r),this.initContentAssist(),this.ignoredIssues=i.has(r,"ignoredIssues")?r.ignoredIssues:t.DEFAULT_PARSER_CONFIG.ignoredIssues,i.toFastProperties(this)}return e.performSelfAnalysis=function(e){e.performSelfAnalysis()},e.prototype.performSelfAnalysis=function(){var t,r=this;this.selfAnalysisDone=!0;var n=o.classNameFromInstance(this),a=this.gastProductionsCache;if(this.serializedGrammar){var l=c.deserializeGrammar(this.serializedGrammar,this.tokensMap);i.forEach(l,(function(e){r.gastProductionsCache.put(e.name,e)}))}var p=u.resolveGrammar({rules:a.values()});if(this.definitionErrors.push.apply(this.definitionErrors,p),i.isEmpty(p)){var h=u.validateGrammar({rules:a.values(),maxLookahead:this.maxLookahead,tokenTypes:i.values(this.tokensMap),ignoredIssues:this.ignoredIssues,errMsgProvider:d.defaultGrammarValidatorErrorProvider,grammarName:n});this.definitionErrors.push.apply(this.definitionErrors,h)}if(i.isEmpty(this.definitionErrors)){var v=s.computeAllProdsFollows(a.values());this.resyncFollows=v}var m=f.analyzeCst(a.values(),this.fullRuleNameToShort);if(this.allRuleNames=m.allRuleNames,!e.DEFER_DEFINITION_ERRORS_HANDLING&&!i.isEmpty(this.definitionErrors))throw t=i.map(this.definitionErrors,(function(e){return e.message})),new Error("Parser Definition Errors detected:\n "+t.join("\n-------------------------------\n"))},e.DEFER_DEFINITION_ERRORS_HANDLING=!1,e}();t.Parser=w,i.applyMixins(w,[p.Recoverable,h.LooksAhead,v.TreeBuilder,m.LexerAdapter,g.RecognizerEngine,x.RecognizerApi,y.ErrorHandler,E.ContentAssist]);var b=function(e){function r(r,n){void 0===n&&(n=t.DEFAULT_PARSER_CONFIG);var a=i.cloneObj(n);return a.outputCst=!0,e.call(this,r,a)||this}return a(r,e),r}(w);t.CstParser=b;var T=function(e){function r(r,n){void 0===n&&(n=t.DEFAULT_PARSER_CONFIG);var a=i.cloneObj(n);return a.outputCst=!1,e.call(this,r,a)||this}return a(r,e),r}(w);t.EmbeddedActionsParser=T},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0);t.classNameFromInstance=function(e){return i(e.constructor)};var a=/^\s*function\s*(\S*)\s*\(/,o="name";function i(e){return e.name||e.toString().match(a)[1]}t.functionName=i,t.defineNameProp=function(e,t){var r=Object.getOwnPropertyDescriptor(e,o);return!(!n.isUndefined(r)&&!r.configurable||(Object.defineProperty(e,o,{enumerable:!1,configurable:!0,writable:!1,value:t}),0))};var s=function(){function e(){this._state={}}return e.prototype.keys=function(){return n.keys(this._state)},e.prototype.values=function(){return n.values(this._state)},e.prototype.put=function(e,t){this._state[e]=t},e.prototype.putAll=function(e){this._state=n.assign(this._state,e._state)},e.prototype.get=function(e){return this._state[e]},e.prototype.containsKey=function(e){return n.has(this._state,e)},e.prototype.clear=function(){this._state={}},e}();t.HashTable=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(1),a=function(){function e(){}return e.prototype.visit=function(e){if(e instanceof n.NonTerminal)return this.visitNonTerminal(e);if(e instanceof n.Flat)return this.visitFlat(e);if(e instanceof n.Option)return this.visitOption(e);if(e instanceof n.RepetitionMandatory)return this.visitRepetitionMandatory(e);if(e instanceof n.RepetitionMandatoryWithSeparator)return this.visitRepetitionMandatoryWithSeparator(e);if(e instanceof n.RepetitionWithSeparator)return this.visitRepetitionWithSeparator(e);if(e instanceof n.Repetition)return this.visitRepetition(e);if(e instanceof n.Alternation)return this.visitAlternation(e);if(e instanceof n.Terminal)return this.visitTerminal(e);if(e instanceof n.Rule)return this.visitRule(e);throw Error("non exhaustive match")},e.prototype.visitNonTerminal=function(e){},e.prototype.visitFlat=function(e){},e.prototype.visitOption=function(e){},e.prototype.visitRepetition=function(e){},e.prototype.visitRepetitionMandatory=function(e){},e.prototype.visitRepetitionMandatoryWithSeparator=function(e){},e.prototype.visitRepetitionWithSeparator=function(e){},e.prototype.visitAlternation=function(e){},e.prototype.visitTerminal=function(e){},e.prototype.visitRule=function(e){},e}();t.GAstVisitor=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a="MismatchedTokenException",o="NoViableAltException",i="EarlyExitException",s="NotAllInputParsedException",l=[a,o,i,s];function c(e,t,r){this.name=a,this.message=e,this.token=t,this.previousToken=r,this.resyncedTokens=[]}function f(e,t,r){this.name=o,this.message=e,this.token=t,this.previousToken=r,this.resyncedTokens=[]}function d(e,t){this.name=s,this.message=e,this.token=t,this.resyncedTokens=[]}function u(e,t,r){this.name=i,this.message=e,this.token=t,this.previousToken=r,this.resyncedTokens=[]}Object.freeze(l),t.isRecognitionException=function(e){return n.contains(l,e.name)},t.MismatchedTokenException=c,c.prototype=Error.prototype,t.NoViableAltException=f,f.prototype=Error.prototype,t.NotAllInputParsedException=d,d.prototype=Error.prototype,t.EarlyExitException=u,u.prototype=Error.prototype},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(4),o=r(2);function i(e){for(var t=n.cloneArr(e),r=e,a=!0;a;){r=n.compact(n.flatten(n.map(r,(function(e){return e.CATEGORIES}))));var o=n.difference(r,t);t=t.concat(o),n.isEmpty(o)?a=!1:r=o}return t}function s(e){n.forEach(e,(function(e){d(e)||(t.tokenIdxToClass.put(t.tokenShortNameIdx,e),e.tokenTypeIdx=t.tokenShortNameIdx++),u(e)&&!n.isArray(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),u(e)||(e.CATEGORIES=[]),p(e)||(e.categoryMatches=[]),h(e)||(e.categoryMatchesMap={}),v(e)||(e.tokenName=o.tokenName(e))}))}function l(e){n.forEach(e,(function(e){e.categoryMatches=[],n.forEach(e.categoryMatchesMap,(function(r,n){e.categoryMatches.push(t.tokenIdxToClass.get(n).tokenTypeIdx)}))}))}function c(e){n.forEach(e,(function(e){f([],e)}))}function f(e,t){n.forEach(e,(function(e){t.categoryMatchesMap[e.tokenTypeIdx]=!0})),n.forEach(t.CATEGORIES,(function(r){var a=e.concat(t);n.contains(a,r)||f(a,r)}))}function d(e){return n.has(e,"tokenTypeIdx")}function u(e){return n.has(e,"CATEGORIES")}function p(e){return n.has(e,"categoryMatches")}function h(e){return n.has(e,"categoryMatchesMap")}function v(e){return n.has(e,"tokenName")}t.tokenStructuredMatcher=function(e,t){var r=e.tokenTypeIdx;return r===t.tokenTypeIdx||!0===t.isParent&&!0===t.categoryMatchesMap[r]},t.tokenStructuredMatcherNoCategories=function(e,t){return e.tokenTypeIdx===t.tokenTypeIdx},t.tokenShortNameIdx=1,t.tokenIdxToClass=new a.HashTable,t.augmentTokenTypes=function(e){var t=i(e);s(t),c(t),l(t),n.forEach(t,(function(e){e.isParent=e.categoryMatches.length>0}))},t.expandCategories=i,t.assignTokenDefaultProps=s,t.assignCategoriesTokensProp=l,t.assignCategoriesMapProp=c,t.singleAssignCategoriesToksMap=f,t.hasShortKeyProperty=d,t.hasCategoriesProperty=u,t.hasExtendingTokensTypesProperty=p,t.hasExtendingTokensTypesMapProperty=h,t.hasTokenNameProperty=v,t.isTokenType=function(e){return n.has(e,"tokenTypeIdx")}},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(0),i=r(1),s=r(5),l=r(2);t.isSequenceProd=function(e){return e instanceof i.Flat||e instanceof i.Option||e instanceof i.Repetition||e instanceof i.RepetitionMandatory||e instanceof i.RepetitionMandatoryWithSeparator||e instanceof i.RepetitionWithSeparator||e instanceof i.Terminal||e instanceof i.Rule},t.isOptionalProd=function e(t,r){return void 0===r&&(r=[]),!!(t instanceof i.Option||t instanceof i.Repetition||t instanceof i.RepetitionWithSeparator)||(t instanceof i.Alternation?o.some(t.definition,(function(t){return e(t,r)})):!(t instanceof i.NonTerminal&&o.contains(r,t))&&t instanceof i.AbstractProduction&&(t instanceof i.NonTerminal&&r.push(t),o.every(t.definition,(function(t){return e(t,r)}))))},t.isBranchingProd=function(e){return e instanceof i.Alternation},t.getProductionDslName=function(e){if(e instanceof i.NonTerminal)return"SUBRULE";if(e instanceof i.Option)return"OPTION";if(e instanceof i.Alternation)return"OR";if(e instanceof i.RepetitionMandatory)return"AT_LEAST_ONE";if(e instanceof i.RepetitionMandatoryWithSeparator)return"AT_LEAST_ONE_SEP";if(e instanceof i.RepetitionWithSeparator)return"MANY_SEP";if(e instanceof i.Repetition)return"MANY";if(e instanceof i.Terminal)return"CONSUME";throw Error("non exhaustive match")};var c=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.separator="-",t.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},t}return a(t,e),t.prototype.visitTerminal=function(e){var t=l.tokenName(e.terminalType)+this.separator+"Terminal";o.has(this.dslMethods,t)||(this.dslMethods[t]=[]),this.dslMethods[t].push(e)},t.prototype.visitNonTerminal=function(e){var t=e.nonTerminalName+this.separator+"Terminal";o.has(this.dslMethods,t)||(this.dslMethods[t]=[]),this.dslMethods[t].push(e)},t.prototype.visitOption=function(e){this.dslMethods.option.push(e)},t.prototype.visitRepetitionWithSeparator=function(e){this.dslMethods.repetitionWithSeparator.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.dslMethods.repetitionMandatory.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.dslMethods.repetitionMandatoryWithSeparator.push(e)},t.prototype.visitRepetition=function(e){this.dslMethods.repetition.push(e)},t.prototype.visitAlternation=function(e){this.dslMethods.alternation.push(e)},t}(s.GAstVisitor);t.DslMethodsCollectorVisitor=c},function(e,t,r){"use strict";function n(e,t,r){return r|t|e}Object.defineProperty(t,"__esModule",{value:!0}),t.BITS_FOR_METHOD_IDX=4,t.BITS_FOR_OCCURRENCE_IDX=4,t.BITS_FOR_RULE_IDX=24,t.BITS_FOR_ALT_IDX=8,t.OR_IDX=1<<t.BITS_FOR_METHOD_IDX,t.OPTION_IDX=2<<t.BITS_FOR_METHOD_IDX,t.MANY_IDX=3<<t.BITS_FOR_METHOD_IDX,t.AT_LEAST_ONE_IDX=4<<t.BITS_FOR_METHOD_IDX,t.MANY_SEP_IDX=5<<t.BITS_FOR_METHOD_IDX,t.AT_LEAST_ONE_SEP_IDX=6<<t.BITS_FOR_METHOD_IDX,t.getKeyForAutomaticLookahead=n;var a=32-t.BITS_FOR_ALT_IDX;t.getKeyForAltIndex=function(e,t,r,o){var i=o+1<<a;return n(e,t,r)|i}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),a=r(0),o=r(0),i=r(1),s=r(8),l=r(11),c=r(17),f=r(3);t.defaultParserErrorProvider={buildMismatchTokenMessage:function(e){var t=e.expected,r=e.actual;return e.previous,e.ruleName,"Expecting "+(n.hasTokenLabel(t)?"--\x3e "+n.tokenLabel(t)+" <--":"token of type --\x3e "+n.tokenName(t)+" <--")+" but found --\x3e '"+r.image+"' <--"},buildNotAllInputParsedMessage:function(e){var t=e.firstRedundant;return e.ruleName,"Redundant input, expecting EOF but found: "+t.image},buildNoViableAltMessage:function(e){var t=e.expectedPathsPerAlt,r=e.actual,a=(e.previous,e.customUserDescription),i=(e.ruleName,"\nbut found: '"+o.first(r).image+"'");if(a)return"Expecting: "+a+i;var s=o.reduce(t,(function(e,t){return e.concat(t)}),[]),l=o.map(s,(function(e){return"["+o.map(e,(function(e){return n.tokenLabel(e)})).join(", ")+"]"}));return"Expecting: one of these possible Token sequences:\n"+o.map(l,(function(e,t){return"  "+(t+1)+". "+e})).join("\n")+i},buildEarlyExitMessage:function(e){var t=e.expectedIterationPaths,r=e.actual,a=e.customUserDescription,i=(e.ruleName,"\nbut found: '"+o.first(r).image+"'");return a?"Expecting: "+a+i:"Expecting: expecting at least one iteration which starts with one of these possible Token sequences::\n  <"+o.map(t,(function(e){return"["+o.map(e,(function(e){return n.tokenLabel(e)})).join(",")+"]"})).join(" ,")+">"+i}},Object.freeze(t.defaultParserErrorProvider),t.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(e,t){return"Invalid grammar, reference to a rule which is not defined: ->"+t.nonTerminalName+"<-\ninside top level rule: ->"+e.name+"<-"}},t.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(e,t){var r,a=e.name,l=o.first(t),c=l.idx,f=s.getProductionDslName(l),d=(r=l)instanceof i.Terminal?n.tokenName(r.terminalType):r instanceof i.NonTerminal?r.nonTerminalName:"",u="->"+f+"<- with numerical suffix: ->"+c+"<-\n                  "+(d?"and argument: ->"+d+"<-":"")+"\n                  appears more than once ("+t.length+" times) in the top level rule: ->"+a+"<-.\n                  "+(0===c?"Also note that numerical suffix 0 means "+f+" without any suffix.":"")+"\n                  To fix this make sure each usage of "+f+" "+(d?"with the argument: ->"+d+"<-":"")+"\n                  in the rule ->"+a+"<- has a different occurrence index (0-5), as that combination acts as a unique\n                  position key in the grammar, which is needed by the parsing engine.\n                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";return(u=u.replace(/[ \t]+/g," ")).replace(/\s\s+/g,"\n")},buildInvalidNestedRuleNameError:function(e,t){return"Invalid nested rule name: ->"+t.name+"<- inside rule: ->"+e.name+"<-\nit must match the pattern: ->"+l.validNestedRuleName.toString()+"<-.\nNote that this means a nested rule name must start with the '$'(dollar) sign."},buildDuplicateNestedRuleNameError:function(e,t){return"Duplicate nested rule name: ->"+o.first(t).name+"<- inside rule: ->"+e.name+"<-\nA nested name must be unique in the scope of a top level grammar rule."},buildNamespaceConflictError:function(e){return"Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <"+e.name+">.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter."},buildAlternationPrefixAmbiguityError:function(e){var t=o.map(e.prefixPath,(function(e){return n.tokenLabel(e)})).join(", "),r=0===e.alternation.idx?"":e.alternation.idx;return"Ambiguous alternatives: <"+e.ambiguityIndices.join(" ,")+"> due to common lookahead prefix\nin <OR"+r+"> inside <"+e.topLevelRule.name+"> Rule,\n<"+t+"> may appears as a prefix path in all these alternatives.\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details."},buildAlternationAmbiguityError:function(e){var t=o.map(e.prefixPath,(function(e){return n.tokenLabel(e)})).join(", "),r=0===e.alternation.idx?"":e.alternation.idx,a="Ambiguous alternatives: <"+e.ambiguityIndices.join(" ,")+"> in <OR"+r+"> inside <"+e.topLevelRule.name+"> Rule,\n<"+t+"> may appears as a prefix path in all these alternatives.\n",i=c.VERSION.replace(/\./g,"_");return a+"To Resolve this, try one of of the following: \n1. Refactor your grammar to be LL(K) for the current value of k (by default k="+f.DEFAULT_PARSER_CONFIG.maxLookahead+"})\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/"+i+"/interfaces/iparserconfig.html#ignoredissues for more details\n"},buildEmptyRepetitionError:function(e){var t=s.getProductionDslName(e.repetition);return 0!==e.repetition.idx&&(t+=e.repetition.idx),"The repetition <"+t+"> within Rule <"+e.topLevelRule.name+"> can never consume any tokens.\nThis could lead to an infinite loop."},buildTokenNameError:function(e){return"Invalid Grammar Token name: ->"+n.tokenName(e.tokenType)+"<- it must match the pattern: ->"+e.expectedPattern.toString()+"<-"},buildEmptyAlternationError:function(e){return"Ambiguous empty alternative: <"+(e.emptyChoiceIdx+1)+"> in <OR"+e.alternation.idx+"> inside <"+e.topLevelRule.name+"> Rule.\nOnly the last alternative may be an empty alternative."},buildTooManyAlternativesError:function(e){return"An Alternation cannot have more than 256 alternatives:\n<OR"+e.alternation.idx+"> inside <"+e.topLevelRule.name+"> Rule.\n has "+(e.alternation.definition.length+1)+" alternatives."},buildLeftRecursionError:function(e){var t=e.topLevelRule.name;return"Left Recursion found in grammar.\nrule: <"+t+"> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n "+t+" --\x3e "+a.map(e.leftRecursionPath,(function(e){return e.name})).concat([t]).join(" --\x3e ")+"\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring."},buildInvalidRuleNameError:function(e){return"Invalid grammar rule name: ->"+e.topLevelRule.name+"<- it must match the pattern: ->"+e.expectedPattern.toString()+"<-"},buildDuplicateRuleNameError:function(e){return"Duplicate definition, rule: ->"+(e.topLevelRule instanceof i.Rule?e.topLevelRule.name:e.topLevelRule)+"<- is already defined in the grammar: ->"+e.grammarName+"<-"}}},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(0),i=r(0),s=r(3),l=r(8),c=r(2),f=r(12),d=r(16),u=r(13),p=r(1),h=r(5);function v(e){return l.getProductionDslName(e)+"_#_"+e.idx+"_#_"+m(e)}function m(e){return e instanceof p.Terminal?c.tokenName(e.terminalType):e instanceof p.NonTerminal?e.nonTerminalName:""}t.validateGrammar=function(e,t,r,n,a,f){var u=o.map(e,(function(e){return function(e,t){var r=new x;e.accept(r);var n=r.allProductions,a=o.groupBy(n,v),i=o.pick(a,(function(e){return e.length>1}));return o.map(o.values(i),(function(r){var n=o.first(r),a=t.buildDuplicateFoundError(e,r),i=l.getProductionDslName(n),c={message:a,type:s.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:e.name,dslName:i,occurrence:n.idx},f=m(n);return f&&(c.parameter=f),c}))}(e,a)})),p=o.map(e,(function(e){return b(e,e,a)})),h=[],T=[],_=[];i.every(p,i.isEmpty)&&(h=i.map(e,(function(e){return S(e,a)})),T=i.map(e,(function(e){return R(e,t,n,a)})),_=C(e,t,a));var A=function(e,t,r){var n=[],a=i.map(t,(function(e){return c.tokenName(e)}));return i.forEach(e,(function(e){var t=e.name;if(i.contains(a,t)){var o=r.buildNamespaceConflictError(e);n.push({message:o,type:s.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:t})}})),n}(e,r,a),L=o.map(r,(function(e){return E(e,a)})),H=function(e,t){var r=[];return i.forEach(e,(function(e){var n=new d.NamedDSLMethodsCollectorVisitor("");e.accept(n);var a=i.map(n.result,(function(e){return e.orgProd}));r.push(i.map(a,(function(r){return y(e,r,t)})))})),i.flatten(r)}(e,a),P=function(e,t){var r=[];return i.forEach(e,(function(e){var n=new d.NamedDSLMethodsCollectorVisitor("");e.accept(n);var a=i.groupBy(n.result,(function(e){return e.name})),o=i.pick(a,(function(e){return e.length>1}));i.forEach(i.values(o),(function(n){var a=i.map(n,(function(e){return e.orgProd})),o=t.buildDuplicateNestedRuleNameError(e,a);r.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,ruleName:e.name})}))})),r}(e,a),z=i.map(e,(function(e){return M(e,a)})),k=i.map(e,(function(e){return g(e,a)})),N=i.map(e,(function(t){return w(t,e,f,a)}));return o.flatten(u.concat(L,H,P,_,p,h,T,A,z,k,N))},t.identifyProductionForDuplicates=v;var x=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.allProductions=[],t}return a(t,e),t.prototype.visitNonTerminal=function(e){this.allProductions.push(e)},t.prototype.visitOption=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetition=function(e){this.allProductions.push(e)},t.prototype.visitAlternation=function(e){this.allProductions.push(e)},t.prototype.visitTerminal=function(e){this.allProductions.push(e)},t}(h.GAstVisitor);function g(e,r){var n=[],a=e.name;return a.match(t.validTermsPattern)||n.push({message:r.buildInvalidRuleNameError({topLevelRule:e,expectedPattern:t.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_RULE_NAME,ruleName:a}),n}function y(e,r,n){var a,o=[];return r.name.match(t.validNestedRuleName)||(a=n.buildInvalidNestedRuleNameError(e,r),o.push({message:a,type:s.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,ruleName:e.name})),o}function E(e,r){var n=[];return c.tokenName(e).match(t.validTermsPattern)||n.push({message:r.buildTokenNameError({tokenType:e,expectedPattern:t.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_TOKEN_NAME}),n}function w(e,t,r,n){var a=[];if(i.reduce(t,(function(t,r){return r.name===e.name?t+1:t}),0)>1){var o=n.buildDuplicateRuleNameError({topLevelRule:e,grammarName:r});a.push({message:o,type:s.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:e.name})}return a}function b(e,t,r,n){void 0===n&&(n=[]);var a=[],i=T(t.definition);if(o.isEmpty(i))return[];var l=e.name;o.contains(i,e)&&a.push({message:r.buildLeftRecursionError({topLevelRule:e,leftRecursionPath:n}),type:s.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:l});var c=o.difference(i,n.concat([e])),f=o.map(c,(function(t){var a=o.cloneArr(n);return a.push(t),b(e,t,r,a)}));return a.concat(o.flatten(f))}function T(e){var t=[];if(o.isEmpty(e))return t;var r=o.first(e);if(r instanceof p.NonTerminal)t.push(r.referencedRule);else if(r instanceof p.Flat||r instanceof p.Option||r instanceof p.RepetitionMandatory||r instanceof p.RepetitionMandatoryWithSeparator||r instanceof p.RepetitionWithSeparator||r instanceof p.Repetition)t=t.concat(T(r.definition));else if(r instanceof p.Alternation)t=o.flatten(o.map(r.definition,(function(e){return T(e.definition)})));else if(!(r instanceof p.Terminal))throw Error("non exhaustive match");var n=l.isOptionalProd(r),a=e.length>1;if(n&&a){var i=o.drop(e);return t.concat(T(i))}return t}t.OccurrenceValidationCollector=x,t.validTermsPattern=/^[a-zA-Z_]\w*$/,t.validNestedRuleName=new RegExp(t.validTermsPattern.source.replace("^","^\\$")),t.validateRuleName=g,t.validateNestedRuleName=y,t.validateTokenName=E,t.validateRuleDoesNotAlreadyExist=w,t.validateRuleIsOverridden=function(e,t,r){var n,a=[];return o.contains(t,e)||(n="Invalid rule override, rule: ->"+e+"<- cannot be overridden in the grammar: ->"+r+"<-as it is not defined in any of the super grammars ",a.push({message:n,type:s.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:e})),a},t.validateNoLeftRecursion=b,t.getFirstNoneTerminal=T;var _=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.alternations=[],t}return a(t,e),t.prototype.visitAlternation=function(e){this.alternations.push(e)},t}(h.GAstVisitor);function S(e,t){var r=new _;e.accept(r);var n=r.alternations;return o.reduce(n,(function(r,n){var a=o.dropRight(n.definition),i=o.map(a,(function(r,a){var i=u.nextPossibleTokensAfter([r],[],null,1);return o.isEmpty(i)?{message:t.buildEmptyAlternationError({topLevelRule:e,alternation:n,emptyChoiceIdx:a}),type:s.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:e.name,occurrence:n.idx,alternative:a+1}:null}));return r.concat(o.compact(i))}),[])}function R(e,t,r,n){var a=new _;e.accept(a);var c=a.alternations,d=r[e.name];return d&&(c=i.reject(c,(function(e){return d[l.getProductionDslName(e)+(0===e.idx?"":e.idx)]}))),o.reduce(c,(function(r,a){var l=a.idx,c=f.getLookaheadPathsForOr(l,e,t),d=function(e,t,r,n){var a=[],l=i.reduce(e,(function(t,r,n){return i.forEach(r,(function(r){var o=[n];i.forEach(e,(function(e,t){n!==t&&f.containsPath(e,r)&&o.push(t)})),o.length>1&&!f.containsPath(a,r)&&(a.push(r),t.push({alts:o,path:r}))})),t}),[]);return o.map(l,(function(e){var a=i.map(e.alts,(function(e){return e+1}));return{message:n.buildAlternationAmbiguityError({topLevelRule:r,alternation:t,ambiguityIndices:a,prefixPath:e.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:r.name,occurrence:t.idx,alternatives:[e.alts]}}))}(c,a,e,n),u=L(c,a,e,n);return r.concat(d,u)}),[])}t.validateEmptyOrAlternative=S,t.validateAmbiguousAlternationAlternatives=R;var A=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.allProductions=[],t}return a(t,e),t.prototype.visitRepetitionWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetition=function(e){this.allProductions.push(e)},t}(h.GAstVisitor);function M(e,t){var r=new _;e.accept(r);var n=r.alternations;return o.reduce(n,(function(r,n){return n.definition.length>255&&r.push({message:t.buildTooManyAlternativesError({topLevelRule:e,alternation:n}),type:s.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:e.name,occurrence:n.idx}),r}),[])}function C(e,t,r){var n=[];return i.forEach(e,(function(e){var a=new A;e.accept(a);var o=a.allProductions;i.forEach(o,(function(a){var o=f.getProdType(a),l=a.idx,c=f.getLookaheadPathsForOptionalProd(l,e,o,t)[0];if(i.isEmpty(i.flatten(c))){var d=r.buildEmptyRepetitionError({topLevelRule:e,repetition:a});n.push({message:d,type:s.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:e.name})}}))})),n}function L(e,t,r,n){var a=[],o=i.reduce(e,(function(e,t,r){var n=i.map(t,(function(e){return{idx:r,path:e}}));return e.concat(n)}),[]);return i.forEach(o,(function(e){var l=e.idx,c=e.path,d=i.findAll(o,(function(e){return e.idx<l&&f.isStrictPrefixOfPath(e.path,c)})),u=i.map(d,(function(e){var a=[e.idx+1,l+1],o=0===t.idx?"":t.idx;return{message:n.buildAlternationPrefixAmbiguityError({topLevelRule:r,alternation:t,ambiguityIndices:a,prefixPath:e.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:r.name,occurrence:o,alternatives:a}}));a=a.concat(u)})),a}t.RepetionCollector=A,t.validateTooManyAlts=M,t.validateSomeNonEmptyLookaheadPath=C,t.checkPrefixAlternativesAmbiguities=L},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o,i=r(0),s=r(13),l=r(14),c=r(7),f=r(1),d=r(5);!function(e){e[e.OPTION=0]="OPTION",e[e.REPETITION=1]="REPETITION",e[e.REPETITION_MANDATORY=2]="REPETITION_MANDATORY",e[e.REPETITION_MANDATORY_WITH_SEPARATOR=3]="REPETITION_MANDATORY_WITH_SEPARATOR",e[e.REPETITION_WITH_SEPARATOR=4]="REPETITION_WITH_SEPARATOR",e[e.ALTERNATION=5]="ALTERNATION"}(o=t.PROD_TYPE||(t.PROD_TYPE={})),t.getProdType=function(e){if(e instanceof f.Option)return o.OPTION;if(e instanceof f.Repetition)return o.REPETITION;if(e instanceof f.RepetitionMandatory)return o.REPETITION_MANDATORY;if(e instanceof f.RepetitionMandatoryWithSeparator)return o.REPETITION_MANDATORY_WITH_SEPARATOR;if(e instanceof f.RepetitionWithSeparator)return o.REPETITION_WITH_SEPARATOR;if(e instanceof f.Alternation)return o.ALTERNATION;throw Error("non exhaustive match")},t.buildLookaheadFuncForOr=function(e,t,r,n,a,o){var i=v(e,t,r);return o(i,n,g(i)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher,a)},t.buildLookaheadFuncForOptionalProd=function(e,t,r,n,a,o){var i=m(e,t,a,r),s=g(i)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher;return o(i[0],s,n)},t.buildAlternativesLookAheadFunc=function(e,t,r,n){var a=e.length,o=i.every(e,(function(e){return i.every(e,(function(e){return 1===e.length}))}));if(t)return function(t){for(var n=i.map(t,(function(e){return e.GATE})),o=0;o<a;o++){var s=e[o],l=s.length,c=n[o];if(void 0===c||!1!==c.call(this))e:for(var f=0;f<l;f++){for(var d=s[f],u=d.length,p=0;p<u;p++){var h=this.LA(p+1);if(!1===r(h,d[p]))continue e}return o}}};if(o&&!n){var s=i.map(e,(function(e){return i.flatten(e)})),l=i.reduce(s,(function(e,t,r){return i.forEach(t,(function(t){i.has(e,t.tokenTypeIdx)||(e[t.tokenTypeIdx]=r),i.forEach(t.categoryMatches,(function(t){i.has(e,t)||(e[t]=r)}))})),e}),[]);return function(){var e=this.LA(1);return l[e.tokenTypeIdx]}}return function(){for(var t=0;t<a;t++){var n=e[t],o=n.length;e:for(var i=0;i<o;i++){for(var s=n[i],l=s.length,c=0;c<l;c++){var f=this.LA(c+1);if(!1===r(f,s[c]))continue e}return t}}}},t.buildSingleAlternativeLookaheadFunction=function(e,t,r){var n=i.every(e,(function(e){return 1===e.length})),a=e.length;if(n&&!r){var o=i.flatten(e);if(1===o.length&&i.isEmpty(o[0].categoryMatches)){var s=o[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}var l=i.reduce(o,(function(e,t,r){return e[t.tokenTypeIdx]=!0,i.forEach(t.categoryMatches,(function(t){e[t]=!0})),e}),[]);return function(){var e=this.LA(1);return!0===l[e.tokenTypeIdx]}}return function(){e:for(var r=0;r<a;r++){for(var n=e[r],o=n.length,i=0;i<o;i++){var s=this.LA(i+1);if(!1===t(s,n[i]))continue e}return!0}return!1}};var u=function(e){function t(t,r,n){var a=e.call(this)||this;return a.topProd=t,a.targetOccurrence=r,a.targetProdType=n,a}return a(t,e),t.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},t.prototype.checkIsTarget=function(e,t,r,n){return e.idx===this.targetOccurrence&&this.targetProdType===t&&(this.restDef=r.concat(n),!0)},t.prototype.walkOption=function(t,r,n){this.checkIsTarget(t,o.OPTION,r,n)||e.prototype.walkOption.call(this,t,r,n)},t.prototype.walkAtLeastOne=function(t,r,n){this.checkIsTarget(t,o.REPETITION_MANDATORY,r,n)||e.prototype.walkOption.call(this,t,r,n)},t.prototype.walkAtLeastOneSep=function(t,r,n){this.checkIsTarget(t,o.REPETITION_MANDATORY_WITH_SEPARATOR,r,n)||e.prototype.walkOption.call(this,t,r,n)},t.prototype.walkMany=function(t,r,n){this.checkIsTarget(t,o.REPETITION,r,n)||e.prototype.walkOption.call(this,t,r,n)},t.prototype.walkManySep=function(t,r,n){this.checkIsTarget(t,o.REPETITION_WITH_SEPARATOR,r,n)||e.prototype.walkOption.call(this,t,r,n)},t}(l.RestWalker),p=function(e){function t(t,r){var n=e.call(this)||this;return n.targetOccurrence=t,n.targetProdType=r,n.result=[],n}return a(t,e),t.prototype.checkIsTarget=function(e,t){e.idx===this.targetOccurrence&&this.targetProdType===t&&(this.result=e.definition)},t.prototype.visitOption=function(e){this.checkIsTarget(e,o.OPTION)},t.prototype.visitRepetition=function(e){this.checkIsTarget(e,o.REPETITION)},t.prototype.visitRepetitionMandatory=function(e){this.checkIsTarget(e,o.REPETITION_MANDATORY)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.checkIsTarget(e,o.REPETITION_MANDATORY_WITH_SEPARATOR)},t.prototype.visitRepetitionWithSeparator=function(e){this.checkIsTarget(e,o.REPETITION_WITH_SEPARATOR)},t.prototype.visitAlternation=function(e){this.checkIsTarget(e,o.ALTERNATION)},t}(d.GAstVisitor);function h(e,t){function r(e,t){return i.reduce(e,(function(e,r,n){if(n!==t){var a=i.map(r,(function(e){return e.partialPath}));return e.concat(a)}return e}),[])}function n(e,t){return void 0===i.find(e,(function(e){return i.every(t,(function(t,r){return(n=t)===(a=e[r])||n&&a&&(n.categoryMatchesMap[a.tokenTypeIdx]||a.categoryMatchesMap[n.tokenTypeIdx]);var n,a}))}))}function a(e){for(var t=[],r=0;r<e;r++)t.push([]);return t}for(var o=i.map(e,(function(e){return s.possiblePathsFrom([e],1)})),l=a(o.length),c=o,f=1;f<=t;f++){var d=c;c=a(d.length);for(var u=0;u<d.length;u++)for(var p=d[u],h=r(d,u),v=0;v<p.length;v++){var m=p[v].partialPath,g=p[v].suffixDef;if(n(h,m)||i.isEmpty(g)||m.length===t){var y=l[u];x(y,m)||y.push(m)}else{var E=s.possiblePathsFrom(g,f+1,m);c[u]=c[u].concat(E)}}}return l}function v(e,t,r){var n=new p(e,o.ALTERNATION);return t.accept(n),h(n.result,r)}function m(e,t,r,n){var a=new p(e,r);t.accept(a);var o=a.result,i=new u(t,e,r).startWalking();return h([new f.Flat({definition:o}),new f.Flat({definition:i})],n)}function x(e,t){return void 0!==i.find(e,(function(e){return t.length===e.length&&i.every(t,(function(t,r){return t===e[r]||e[r].categoryMatchesMap[t.tokenTypeIdx]}))}))}function g(e){return i.every(e,(function(e){return i.every(e,(function(e){return i.every(e,(function(e){return i.isEmpty(e.categoryMatches)}))}))}))}t.lookAheadSequenceFromAlternatives=h,t.getLookaheadPathsForOr=v,t.getLookaheadPathsForOptionalProd=m,t.containsPath=x,t.isStrictPrefixOfPath=function(e,t){return e.length<t.length&&i.every(e,(function(e,r){var n=t[r];return e===n||n.categoryMatchesMap[e.tokenTypeIdx]}))},t.areTokenCategoriesNotUsed=g},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(14),i=r(0),s=r(2),l=r(21),c=r(1),f=function(e){function t(t,r){var n=e.call(this)||this;return n.topProd=t,n.path=r,n.possibleTokTypes=[],n.nextProductionName="",n.nextProductionOccurrence=0,n.found=!1,n.isAtEndOfPath=!1,n}return a(t,e),t.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error("The path does not start with the walker's top Rule!");return this.ruleStack=i.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=i.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},t.prototype.walk=function(t,r){void 0===r&&(r=[]),this.found||e.prototype.walk.call(this,t,r)},t.prototype.walkProdRef=function(e,t,r){if(e.referencedRule.name===this.nextProductionName&&e.idx===this.nextProductionOccurrence){var n=t.concat(r);this.updateExpectedNext(),this.walk(e.referencedRule,n)}},t.prototype.updateExpectedNext=function(){i.isEmpty(this.ruleStack)?(this.nextProductionName="",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop())},t}(o.RestWalker);t.AbstractNextPossibleTokensWalker=f;var d=function(e){function t(t,r){var n=e.call(this,t,r)||this;return n.path=r,n.nextTerminalName="",n.nextTerminalOccurrence=0,n.nextTerminalName=s.tokenName(n.path.lastTok),n.nextTerminalOccurrence=n.path.lastTokOccurrence,n}return a(t,e),t.prototype.walkTerminal=function(e,t,r){if(this.isAtEndOfPath&&s.tokenName(e.terminalType)===this.nextTerminalName&&e.idx===this.nextTerminalOccurrence&&!this.found){var n=t.concat(r),a=new c.Flat({definition:n});this.possibleTokTypes=l.first(a),this.found=!0}},t}(f);t.NextAfterTokenWalker=d;var u=function(e){function t(t,r){var n=e.call(this)||this;return n.topRule=t,n.occurrence=r,n.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},n}return a(t,e),t.prototype.startWalking=function(){return this.walk(this.topRule),this.result},t}(o.RestWalker);t.AbstractNextTerminalAfterProductionWalker=u;var p=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a(t,e),t.prototype.walkMany=function(t,r,n){if(t.idx===this.occurrence){var a=i.first(r.concat(n));this.result.isEndOfRule=void 0===a,a instanceof c.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else e.prototype.walkMany.call(this,t,r,n)},t}(u);t.NextTerminalAfterManyWalker=p;var h=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a(t,e),t.prototype.walkManySep=function(t,r,n){if(t.idx===this.occurrence){var a=i.first(r.concat(n));this.result.isEndOfRule=void 0===a,a instanceof c.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else e.prototype.walkManySep.call(this,t,r,n)},t}(u);t.NextTerminalAfterManySepWalker=h;var v=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a(t,e),t.prototype.walkAtLeastOne=function(t,r,n){if(t.idx===this.occurrence){var a=i.first(r.concat(n));this.result.isEndOfRule=void 0===a,a instanceof c.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else e.prototype.walkAtLeastOne.call(this,t,r,n)},t}(u);t.NextTerminalAfterAtLeastOneWalker=v;var m=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a(t,e),t.prototype.walkAtLeastOneSep=function(t,r,n){if(t.idx===this.occurrence){var a=i.first(r.concat(n));this.result.isEndOfRule=void 0===a,a instanceof c.Terminal&&(this.result.token=a.terminalType,this.result.occurrence=a.idx)}else e.prototype.walkAtLeastOneSep.call(this,t,r,n)},t}(u);function x(e,t,r,n){var a=i.cloneArr(r);a.push(e.name);var o=i.cloneArr(n);return o.push(1),{idx:t,def:e.definition,ruleStack:a,occurrenceStack:o}}t.NextTerminalAfterAtLeastOneSepWalker=m,t.possiblePathsFrom=function e(t,r,n){void 0===n&&(n=[]),n=i.cloneArr(n);var a=[],o=0;function s(s){var l=e(s.concat(i.drop(t,o+1)),r,n);return a.concat(l)}for(;n.length<r&&o<t.length;){var l=t[o];if(l instanceof c.Flat)return s(l.definition);if(l instanceof c.NonTerminal)return s(l.definition);if(l instanceof c.Option)a=s(l.definition);else{if(l instanceof c.RepetitionMandatory)return s(f=l.definition.concat([new c.Repetition({definition:l.definition})]));if(l instanceof c.RepetitionMandatoryWithSeparator)return s(f=[new c.Flat({definition:l.definition}),new c.Repetition({definition:[new c.Terminal({terminalType:l.separator})].concat(l.definition)})]);if(l instanceof c.RepetitionWithSeparator){var f=l.definition.concat([new c.Repetition({definition:[new c.Terminal({terminalType:l.separator})].concat(l.definition)})]);a=s(f)}else if(l instanceof c.Repetition)f=l.definition.concat([new c.Repetition({definition:l.definition})]),a=s(f);else{if(l instanceof c.Alternation)return i.forEach(l.definition,(function(e){a=s(e.definition)})),a;if(!(l instanceof c.Terminal))throw Error("non exhaustive match");n.push(l.terminalType)}}o++}return a.push({partialPath:n,suffixDef:i.drop(t,o)}),a},t.nextPossibleTokensAfter=function(e,t,r,n){var a=["EXIT_NONE_TERMINAL"],o=!1,s=t.length,l=s-n-1,f=[],d=[];for(d.push({idx:-1,def:e,ruleStack:[],occurrenceStack:[]});!i.isEmpty(d);){var u=d.pop();if("EXIT_ALTERNATIVE"!==u){var p=u.def,h=u.idx,v=u.ruleStack,m=u.occurrenceStack;if(!i.isEmpty(p)){var g=p[0];if("EXIT_NONE_TERMINAL"===g){var y={idx:h,def:i.drop(p),ruleStack:i.dropRight(v),occurrenceStack:i.dropRight(m)};d.push(y)}else if(g instanceof c.Terminal)if(h<s-1){var E=h+1;r(t[E],g.terminalType)&&(y={idx:E,def:i.drop(p),ruleStack:v,occurrenceStack:m},d.push(y))}else{if(h!==s-1)throw Error("non exhaustive match");f.push({nextTokenType:g.terminalType,nextTokenOccurrence:g.idx,ruleStack:v,occurrenceStack:m}),o=!0}else if(g instanceof c.NonTerminal){var w=i.cloneArr(v);w.push(g.nonTerminalName);var b=i.cloneArr(m);b.push(g.idx),y={idx:h,def:g.definition.concat(a,i.drop(p)),ruleStack:w,occurrenceStack:b},d.push(y)}else if(g instanceof c.Option){var T={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m};d.push(T),d.push("EXIT_ALTERNATIVE");var _={idx:h,def:g.definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m};d.push(_)}else if(g instanceof c.RepetitionMandatory){var S=new c.Repetition({definition:g.definition,idx:g.idx});y={idx:h,def:g.definition.concat([S],i.drop(p)),ruleStack:v,occurrenceStack:m},d.push(y)}else if(g instanceof c.RepetitionMandatoryWithSeparator){var R=new c.Terminal({terminalType:g.separator});S=new c.Repetition({definition:[R].concat(g.definition),idx:g.idx}),y={idx:h,def:g.definition.concat([S],i.drop(p)),ruleStack:v,occurrenceStack:m},d.push(y)}else if(g instanceof c.RepetitionWithSeparator){T={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m},d.push(T),d.push("EXIT_ALTERNATIVE"),R=new c.Terminal({terminalType:g.separator});var A=new c.Repetition({definition:[R].concat(g.definition),idx:g.idx});_={idx:h,def:g.definition.concat([A],i.drop(p)),ruleStack:v,occurrenceStack:m},d.push(_)}else if(g instanceof c.Repetition)T={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m},d.push(T),d.push("EXIT_ALTERNATIVE"),A=new c.Repetition({definition:g.definition,idx:g.idx}),_={idx:h,def:g.definition.concat([A],i.drop(p)),ruleStack:v,occurrenceStack:m},d.push(_);else if(g instanceof c.Alternation)for(var M=g.definition.length-1;M>=0;M--){var C={idx:h,def:g.definition[M].definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m};d.push(C),d.push("EXIT_ALTERNATIVE")}else if(g instanceof c.Flat)d.push({idx:h,def:g.definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m});else{if(!(g instanceof c.Rule))throw Error("non exhaustive match");d.push(x(g,h,v,m))}}}else o&&i.last(d).idx<=l&&d.pop()}return f}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(1),o=function(){function e(){}return e.prototype.walk=function(e,t){var r=this;void 0===t&&(t=[]),n.forEach(e.definition,(function(o,i){var s=n.drop(e.definition,i+1);if(o instanceof a.NonTerminal)r.walkProdRef(o,s,t);else if(o instanceof a.Terminal)r.walkTerminal(o,s,t);else if(o instanceof a.Flat)r.walkFlat(o,s,t);else if(o instanceof a.Option)r.walkOption(o,s,t);else if(o instanceof a.RepetitionMandatory)r.walkAtLeastOne(o,s,t);else if(o instanceof a.RepetitionMandatoryWithSeparator)r.walkAtLeastOneSep(o,s,t);else if(o instanceof a.RepetitionWithSeparator)r.walkManySep(o,s,t);else if(o instanceof a.Repetition)r.walkMany(o,s,t);else{if(!(o instanceof a.Alternation))throw Error("non exhaustive match");r.walkOr(o,s,t)}}))},e.prototype.walkTerminal=function(e,t,r){},e.prototype.walkProdRef=function(e,t,r){},e.prototype.walkFlat=function(e,t,r){var n=t.concat(r);this.walk(e,n)},e.prototype.walkOption=function(e,t,r){var n=t.concat(r);this.walk(e,n)},e.prototype.walkAtLeastOne=function(e,t,r){var n=[new a.Option({definition:e.definition})].concat(t,r);this.walk(e,n)},e.prototype.walkAtLeastOneSep=function(e,t,r){var n=i(e,t,r);this.walk(e,n)},e.prototype.walkMany=function(e,t,r){var n=[new a.Option({definition:e.definition})].concat(t,r);this.walk(e,n)},e.prototype.walkManySep=function(e,t,r){var n=i(e,t,r);this.walk(e,n)},e.prototype.walkOr=function(e,t,r){var o=this,i=t.concat(r);n.forEach(e.definition,(function(e){var t=new a.Flat({definition:[e]});o.walk(t,i)}))},e}();function i(e,t,r){return[new a.Option({definition:[new a.Terminal({terminalType:e.separator})].concat(e.definition)})].concat(t,r)}t.RestWalker=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(27),a=r(0),o=r(7),i=r(20);!function(e){e[e.MISSING_PATTERN=0]="MISSING_PATTERN",e[e.INVALID_PATTERN=1]="INVALID_PATTERN",e[e.EOI_ANCHOR_FOUND=2]="EOI_ANCHOR_FOUND",e[e.UNSUPPORTED_FLAGS_FOUND=3]="UNSUPPORTED_FLAGS_FOUND",e[e.DUPLICATE_PATTERNS_FOUND=4]="DUPLICATE_PATTERNS_FOUND",e[e.INVALID_GROUP_TYPE_FOUND=5]="INVALID_GROUP_TYPE_FOUND",e[e.PUSH_MODE_DOES_NOT_EXIST=6]="PUSH_MODE_DOES_NOT_EXIST",e[e.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",e[e.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",e[e.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",e[e.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",e[e.SOI_ANCHOR_FOUND=11]="SOI_ANCHOR_FOUND",e[e.EMPTY_MATCH_PATTERN=12]="EMPTY_MATCH_PATTERN",e[e.NO_LINE_BREAKS_FLAGS=13]="NO_LINE_BREAKS_FLAGS",e[e.UNREACHABLE_PATTERN=14]="UNREACHABLE_PATTERN",e[e.IDENTIFY_TERMINATOR=15]="IDENTIFY_TERMINATOR",e[e.CUSTOM_LINE_BREAK=16]="CUSTOM_LINE_BREAK"}(t.LexerDefinitionErrorType||(t.LexerDefinitionErrorType={}));var s={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:i.defaultLexerErrorProvider};Object.freeze(s);var l=function(){function e(e,t){var r=this;if(void 0===t&&(t=s),this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},"boolean"==typeof t)throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");if(this.config=a.merge(s,t),this.config.lineTerminatorsPattern===s.lineTerminatorsPattern)this.config.lineTerminatorsPattern=n.LineTerminatorOptimizedTester;else if(this.config.lineTerminatorCharacters===s.lineTerminatorCharacters)throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking);var i,l=!0;a.isArray(e)?((i={modes:{}}).modes[n.DEFAULT_MODE]=a.cloneArr(e),i[n.DEFAULT_MODE]=n.DEFAULT_MODE):(l=!1,i=a.cloneObj(e)),this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(n.performRuntimeChecks(i,this.trackStartLines,this.config.lineTerminatorCharacters)),this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(n.performWarningRuntimeChecks(i,this.trackStartLines,this.config.lineTerminatorCharacters)),i.modes=i.modes?i.modes:{},a.forEach(i.modes,(function(e,t){i.modes[t]=a.reject(e,(function(e){return a.isUndefined(e)}))}));var c=a.keys(i.modes);if(a.forEach(i.modes,(function(e,i){if(r.modes.push(i),r.lexerDefinitionErrors=r.lexerDefinitionErrors.concat(n.validatePatterns(e,c)),a.isEmpty(r.lexerDefinitionErrors)){o.augmentTokenTypes(e);var s=n.analyzeTokenTypes(e,{lineTerminatorCharacters:r.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode});r.patternIdxToConfig[i]=s.patternIdxToConfig,r.charCodeToPatternIdxToConfig[i]=s.charCodeToPatternIdxToConfig,r.emptyGroups=a.merge(r.emptyGroups,s.emptyGroups),r.hasCustom=s.hasCustom||r.hasCustom,r.canModeBeOptimized[i]=s.canBeOptimized}})),this.defaultMode=i.defaultMode,!a.isEmpty(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){var f=a.map(this.lexerDefinitionErrors,(function(e){return e.message})).join("-----------------------\n");throw new Error("Errors detected in definition of Lexer:\n"+f)}if(a.forEach(this.lexerDefinitionWarning,(function(e){a.PRINT_WARNING(e.message)})),n.SUPPORT_STICKY?(this.chopInput=a.IDENTITY,this.match=this.matchWithTest):(this.updateLastIndex=a.NOOP,this.match=this.matchWithExec),l&&(this.handleModes=a.NOOP),!1===this.trackStartLines&&(this.computeNewColumn=a.IDENTITY),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=a.NOOP),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else{if(!/onlyOffset/i.test(this.config.positionTracking))throw Error('Invalid <positionTracking> config option: "'+this.config.positionTracking+'"');this.createTokenInstance=this.createOffsetOnlyToken}this.hasCustom?this.addToken=this.addTokenUsingPush:this.addToken=this.addTokenUsingMemberAccess;var d=a.reduce(this.canModeBeOptimized,(function(e,t,r){return!1===t&&e.push(r),e}),[]);if(t.ensureOptimizations&&!a.isEmpty(d))throw Error("Lexer Modes: < "+d.join(", ")+' > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.')}return e.prototype.tokenize=function(e,t){if(void 0===t&&(t=this.defaultMode),!a.isEmpty(this.lexerDefinitionErrors)){var r=a.map(this.lexerDefinitionErrors,(function(e){return e.message})).join("-----------------------\n");throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+r)}return this.tokenizeInternal(e,t)},e.prototype.tokenizeInternal=function(e,t){var r,o,i,s,l,c,f,d,u,p,h,v,m=this,x=e,g=x.length,y=0,E=0,w=this.hasCustom?0:Math.floor(e.length/10),b=new Array(w),T=[],_=this.trackStartLines?1:void 0,S=this.trackStartLines?1:void 0,R=n.cloneEmptyGroups(this.emptyGroups),A=this.trackStartLines,M=this.config.lineTerminatorsPattern,C=0,L=[],H=[],P=[],z=[];Object.freeze(z);var k,N=void 0,D=function(e){if(1===P.length&&void 0===e.tokenType.PUSH_MODE){var t=m.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);T.push({offset:e.startOffset,line:void 0!==e.startLine?e.startLine:void 0,column:void 0!==e.startColumn?e.startColumn:void 0,length:e.image.length,message:t})}else{P.pop();var r=a.last(P);L=m.patternIdxToConfig[r],H=m.charCodeToPatternIdxToConfig[r],C=L.length;var n=m.canModeBeOptimized[r]&&!1===m.config.safeMode;N=H&&n?function(e){var t=H[e];return void 0===t?z:t}:function(){return L}}};function F(e){P.push(e),H=this.charCodeToPatternIdxToConfig[e],L=this.patternIdxToConfig[e],C=L.length,C=L.length;var t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;N=H&&t?function(e){var t=H[e];return void 0===t?z:t}:function(){return L}}for(F.call(this,t);y<g;){l=null;var I=x.charCodeAt(y),O=N(I),U=O.length;for(r=0;r<U;r++){var G=(k=O[r]).pattern;if(!1!==(K=k.short)?I===K&&(l=G):!0===k.isCustom?l=null!==(v=G.exec(x,y,b,R))?v[0]:v:(this.updateLastIndex(G,y),l=this.match(G,e,y)),null!==l){if(void 0!==(s=k.longerAlt)){var B=L[s],V=B.pattern;!0===B.isCustom?i=null!==(v=V.exec(x,y,b,R))?v[0]:v:(this.updateLastIndex(V,y),i=this.match(V,e,y)),i&&i.length>l.length&&(l=i,k=B)}break}}if(null!==l){if(c=l.length,void 0!==(f=k.group)&&(d=k.tokenTypeIdx,u=this.createTokenInstance(l,y,d,k.tokenType,_,S,c),!1===f?E=this.addToken(b,E,u):R[f].push(u)),e=this.chopInput(e,c),y+=c,S=this.computeNewColumn(S,c),!0===A&&!0===k.canLineTerminator){var j=0,W=void 0,q=void 0;M.lastIndex=0;do{!0===(W=M.test(l))&&(q=M.lastIndex-1,j++)}while(W);0!==j&&(_+=j,S=c-q,this.updateTokenEndLineColumnLocation(u,f,q,j,_,S,c))}this.handleModes(k,D,F,u)}else{for(var X=y,Y=_,Z=S,Q=!1;!Q&&y<g;)for(x.charCodeAt(y),e=this.chopInput(e,1),y++,o=0;o<C;o++){var K,J=L[o];if(G=J.pattern,!1!==(K=J.short)?x.charCodeAt(y)===K&&(Q=!0):!0===J.isCustom?Q=null!==G.exec(x,y,b,R):(this.updateLastIndex(G,y),Q=null!==G.exec(e)),!0===Q)break}p=y-X,h=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(x,X,p,Y,Z),T.push({offset:X,line:Y,column:Z,length:p,message:h})}}return this.hasCustom||(b.length=E),{tokens:b,groups:R,errors:T}},e.prototype.handleModes=function(e,t,r,n){if(!0===e.pop){var a=e.push;t(n),void 0!==a&&r.call(this,a)}else void 0!==e.push&&r.call(this,e.push)},e.prototype.chopInput=function(e,t){return e.substring(t)},e.prototype.updateLastIndex=function(e,t){e.lastIndex=t},e.prototype.updateTokenEndLineColumnLocation=function(e,t,r,n,a,o,i){var s,l;void 0!==t&&(l=(s=r===i-1)?-1:0,1===n&&!0===s||(e.endLine=a+l,e.endColumn=o-1-l))},e.prototype.computeNewColumn=function(e,t){return e+t},e.prototype.createTokenInstance=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return null},e.prototype.createOffsetOnlyToken=function(e,t,r,n){return{image:e,startOffset:t,tokenTypeIdx:r,tokenType:n}},e.prototype.createStartOnlyToken=function(e,t,r,n,a,o){return{image:e,startOffset:t,startLine:a,startColumn:o,tokenTypeIdx:r,tokenType:n}},e.prototype.createFullToken=function(e,t,r,n,a,o,i){return{image:e,startOffset:t,endOffset:t+i-1,startLine:a,endLine:a,startColumn:o,endColumn:o+i-1,tokenTypeIdx:r,tokenType:n}},e.prototype.addToken=function(e,t,r){return 666},e.prototype.addTokenUsingPush=function(e,t,r){return e.push(r),t},e.prototype.addTokenUsingMemberAccess=function(e,t,r){return e[t]=r,++t},e.prototype.match=function(e,t,r){return null},e.prototype.matchWithTest=function(e,t,r){return!0===e.test(t)?t.substring(r,e.lastIndex):null},e.prototype.matchWithExec=function(e,t){var r=e.exec(t);return null!==r?r[0]:r},e.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",e.NA=/NOT_APPLICABLE/,e}();t.Lexer=l},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(0),i=r(4),s=r(9),l=r(1),c=r(5);t.addTerminalToCst=function(e,t,r){void 0===e.children[r]?e.children[r]=[t]:e.children[r].push(t)},t.addNoneTerminalToCst=function(e,t,r){void 0===e.children[t]?e.children[t]=[r]:e.children[t].push(r)};var f=function(e){function t(t){var r=e.call(this)||this;return r.result=[],r.ruleIdx=t,r}return a(t,e),t.prototype.collectNamedDSLMethod=function(e,t,r){if(!o.isUndefined(e.name)){var n=void 0;if(e instanceof l.Option||e instanceof l.Repetition||e instanceof l.RepetitionMandatory||e instanceof l.Alternation)n=new t({definition:e.definition,idx:e.idx});else{if(!(e instanceof l.RepetitionMandatoryWithSeparator||e instanceof l.RepetitionWithSeparator))throw Error("non exhaustive match");n=new t({definition:e.definition,idx:e.idx,separator:e.separator})}var a=[n],i=s.getKeyForAutomaticLookahead(this.ruleIdx,r,e.idx);this.result.push({def:a,key:i,name:e.name,orgProd:e})}},t.prototype.visitOption=function(e){this.collectNamedDSLMethod(e,l.Option,s.OPTION_IDX)},t.prototype.visitRepetition=function(e){this.collectNamedDSLMethod(e,l.Repetition,s.MANY_IDX)},t.prototype.visitRepetitionMandatory=function(e){this.collectNamedDSLMethod(e,l.RepetitionMandatory,s.AT_LEAST_ONE_IDX)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.collectNamedDSLMethod(e,l.RepetitionMandatoryWithSeparator,s.AT_LEAST_ONE_SEP_IDX)},t.prototype.visitRepetitionWithSeparator=function(e){this.collectNamedDSLMethod(e,l.RepetitionWithSeparator,s.MANY_SEP_IDX)},t.prototype.visitAlternation=function(e){var t=this;this.collectNamedDSLMethod(e,l.Alternation,s.OR_IDX);var r=e.definition.length>1;o.forEach(e.definition,(function(n,a){if(!o.isUndefined(n.name)){var i=n.definition;i=r?[new l.Option({definition:n.definition})]:n.definition;var c=s.getKeyForAltIndex(t.ruleIdx,s.OR_IDX,e.idx,a);t.result.push({def:i,key:c,name:n.name,orgProd:n})}}))},t}(c.GAstVisitor);t.NamedDSLMethodsCollectorVisitor=f,t.analyzeCst=function(e,t){var r={dictDef:new i.HashTable,allRuleNames:[]};return o.forEach(e,(function(e){var n=t.get(e.name);r.allRuleNames.push(e.name);var a=new f(n);e.accept(a),o.forEach(a.result,(function(t){t.def,t.key;var n=t.name;r.allRuleNames.push(e.name+n)}))})),r}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VERSION="4.6.0"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),a=r(15),o=r(2),i=r(6),s=r(17),l=r(10),c=r(39),f=r(5),d=r(1),u=r(24),p=r(40),h=r(20),v={};v.VERSION=s.VERSION,v.Parser=n.Parser,v.CstParser=n.CstParser,v.EmbeddedActionsParser=n.EmbeddedActionsParser,v.ParserDefinitionErrorType=n.ParserDefinitionErrorType,v.Lexer=a.Lexer,v.LexerDefinitionErrorType=a.LexerDefinitionErrorType,v.EOF=o.EOF,v.tokenName=o.tokenName,v.tokenLabel=o.tokenLabel,v.tokenMatcher=o.tokenMatcher,v.createToken=o.createToken,v.createTokenInstance=o.createTokenInstance,v.EMPTY_ALT=n.EMPTY_ALT,v.defaultParserErrorProvider=l.defaultParserErrorProvider,v.isRecognitionException=i.isRecognitionException,v.EarlyExitException=i.EarlyExitException,v.MismatchedTokenException=i.MismatchedTokenException,v.NotAllInputParsedException=i.NotAllInputParsedException,v.NoViableAltException=i.NoViableAltException,v.defaultLexerErrorProvider=h.defaultLexerErrorProvider,v.Flat=d.Flat,v.Repetition=d.Repetition,v.RepetitionWithSeparator=d.RepetitionWithSeparator,v.RepetitionMandatory=d.RepetitionMandatory,v.RepetitionMandatoryWithSeparator=d.RepetitionMandatoryWithSeparator,v.Option=d.Option,v.Alternation=d.Alternation,v.NonTerminal=d.NonTerminal,v.Terminal=d.Terminal,v.Rule=d.Rule,v.GAstVisitor=f.GAstVisitor,v.serializeGrammar=d.serializeGrammar,v.serializeProduction=d.serializeProduction,v.resolveGrammar=u.resolveGrammar,v.defaultGrammarResolverErrorProvider=l.defaultGrammarResolverErrorProvider,v.validateGrammar=u.validateGrammar,v.defaultGrammarValidatorErrorProvider=l.defaultGrammarValidatorErrorProvider,v.assignOccurrenceIndices=u.assignOccurrenceIndices,v.clearCache=function(){console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n\t It performs no action other than printing this message.\n\t Please avoid using it as it will be completely removed in the future")},v.createSyntaxDiagramsCode=c.createSyntaxDiagramsCode,v.generateParserFactory=p.generateParserFactory,v.generateParserModule=p.generateParserModule,e.exports=v},function(e,t,r){var n,a;"undefined"!=typeof self&&self,void 0===(a="function"==typeof(n=function(){function e(){}e.prototype.saveState=function(){return{idx:this.idx,input:this.input,groupIdx:this.groupIdx}},e.prototype.restoreState=function(e){this.idx=e.idx,this.input=e.input,this.groupIdx=e.groupIdx},e.prototype.pattern=function(e){this.idx=0,this.input=e,this.groupIdx=0,this.consumeChar("/");var t=this.disjunction();this.consumeChar("/");for(var r={type:"Flags",global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case"g":s(r,"global");break;case"i":s(r,"ignoreCase");break;case"m":s(r,"multiLine");break;case"u":s(r,"unicode");break;case"y":s(r,"sticky")}if(this.idx!==this.input.length)throw Error("Redundant input: "+this.input.substring(this.idx));return{type:"Pattern",flags:r,value:t}},e.prototype.disjunction=function(){var e=[];for(e.push(this.alternative());"|"===this.peekChar();)this.consumeChar("|"),e.push(this.alternative());return{type:"Disjunction",value:e}},e.prototype.alternative=function(){for(var e=[];this.isTerm();)e.push(this.term());return{type:"Alternative",value:e}},e.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},e.prototype.assertion=function(){switch(this.popChar()){case"^":return{type:"StartAnchor"};case"$":return{type:"EndAnchor"};case"\\":switch(this.popChar()){case"b":return{type:"WordBoundary"};case"B":return{type:"NonWordBoundary"}}throw Error("Invalid Assertion Escape");case"(":var e;switch(this.consumeChar("?"),this.popChar()){case"=":e="Lookahead";break;case"!":e="NegativeLookahead"}l(e);var t=this.disjunction();return this.consumeChar(")"),{type:e,value:t}}!function(){throw Error("Internal Error - Should never get here!")}()},e.prototype.quantifier=function(e){var t;switch(this.popChar()){case"*":t={atLeast:0,atMost:1/0};break;case"+":t={atLeast:1,atMost:1/0};break;case"?":t={atLeast:0,atMost:1};break;case"{":var r=this.integerIncludingZero();switch(this.popChar()){case"}":t={atLeast:r,atMost:r};break;case",":t=this.isDigit()?{atLeast:r,atMost:this.integerIncludingZero()}:{atLeast:r,atMost:1/0},this.consumeChar("}")}if(!0===e&&void 0===t)return;l(t)}if(!0!==e||void 0!==t)return l(t),"?"===this.peekChar(0)?(this.consumeChar("?"),t.greedy=!1):t.greedy=!0,t.type="Quantifier",t},e.prototype.atom=function(){var e;switch(this.peekChar()){case".":e=this.dotAll();break;case"\\":e=this.atomEscape();break;case"[":e=this.characterClass();break;case"(":e=this.group()}return void 0===e&&this.isPatternCharacter()&&(e=this.patternCharacter()),l(e),this.isQuantifier()&&(e.quantifier=this.quantifier()),e},e.prototype.dotAll=function(){return this.consumeChar("."),{type:"Set",complement:!0,value:[o("\n"),o("\r"),o("\u2028"),o("\u2029")]}},e.prototype.atomEscape=function(){switch(this.consumeChar("\\"),this.peekChar()){case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return this.decimalEscapeAtom();case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},e.prototype.decimalEscapeAtom=function(){return{type:"GroupBackReference",value:this.positiveInteger()}},e.prototype.characterClassEscape=function(){var e,t=!1;switch(this.popChar()){case"d":e=c;break;case"D":e=c,t=!0;break;case"s":e=d;break;case"S":e=d,t=!0;break;case"w":e=f;break;case"W":e=f,t=!0}return l(e),{type:"Set",value:e,complement:t}},e.prototype.controlEscapeAtom=function(){var e;switch(this.popChar()){case"f":e=o("\f");break;case"n":e=o("\n");break;case"r":e=o("\r");break;case"t":e=o("\t");break;case"v":e=o("\v")}return l(e),{type:"Character",value:e}},e.prototype.controlLetterEscapeAtom=function(){this.consumeChar("c");var e=this.popChar();if(!1===/[a-zA-Z]/.test(e))throw Error("Invalid ");return{type:"Character",value:e.toUpperCase().charCodeAt(0)-64}},e.prototype.nulCharacterAtom=function(){return this.consumeChar("0"),{type:"Character",value:o("\0")}},e.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar("x"),this.parseHexDigits(2)},e.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar("u"),this.parseHexDigits(4)},e.prototype.identityEscapeAtom=function(){return{type:"Character",value:o(this.popChar())}},e.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case"\n":case"\r":case"\u2028":case"\u2029":case"\\":case"]":throw Error("TBD");default:return{type:"Character",value:o(this.popChar())}}},e.prototype.characterClass=function(){var e=[],t=!1;for(this.consumeChar("["),"^"===this.peekChar(0)&&(this.consumeChar("^"),t=!0);this.isClassAtom();){var r=this.classAtom();if("Character"===r.type&&this.isRangeDash()){this.consumeChar("-");var n=this.classAtom();if("Character"===n.type){if(n.value<r.value)throw Error("Range out of order in character class");e.push({from:r.value,to:n.value})}else i(r.value,e),e.push(o("-")),i(n.value,e)}else i(r.value,e)}return this.consumeChar("]"),{type:"Set",complement:t,value:e}},e.prototype.classAtom=function(){switch(this.peekChar()){case"]":case"\n":case"\r":case"\u2028":case"\u2029":throw Error("TBD");case"\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},e.prototype.classEscape=function(){switch(this.consumeChar("\\"),this.peekChar()){case"b":return this.consumeChar("b"),{type:"Character",value:o("\b")};case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},e.prototype.group=function(){var e=!0;switch(this.consumeChar("("),this.peekChar(0)){case"?":this.consumeChar("?"),this.consumeChar(":"),e=!1;break;default:this.groupIdx++}var t=this.disjunction();this.consumeChar(")");var r={type:"Group",capturing:e,value:t};return e&&(r.idx=this.groupIdx),r},e.prototype.positiveInteger=function(){var e=this.popChar();if(!1===a.test(e))throw Error("Expecting a positive integer");for(;n.test(this.peekChar(0));)e+=this.popChar();return parseInt(e,10)},e.prototype.integerIncludingZero=function(){var e=this.popChar();if(!1===n.test(e))throw Error("Expecting an integer");for(;n.test(this.peekChar(0));)e+=this.popChar();return parseInt(e,10)},e.prototype.patternCharacter=function(){var e=this.popChar();switch(e){case"\n":case"\r":case"\u2028":case"\u2029":case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":throw Error("TBD");default:return{type:"Character",value:o(e)}}},e.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case"g":case"i":case"m":case"u":case"y":return!0;default:return!1}},e.prototype.isRangeDash=function(){return"-"===this.peekChar()&&this.isClassAtom(1)},e.prototype.isDigit=function(){return n.test(this.peekChar(0))},e.prototype.isClassAtom=function(e){switch(void 0===e&&(e=0),this.peekChar(e)){case"]":case"\n":case"\r":case"\u2028":case"\u2029":return!1;default:return!0}},e.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},e.prototype.isAtom=function(){if(this.isPatternCharacter())return!0;switch(this.peekChar(0)){case".":case"\\":case"[":case"(":return!0;default:return!1}},e.prototype.isAssertion=function(){switch(this.peekChar(0)){case"^":case"$":return!0;case"\\":switch(this.peekChar(1)){case"b":case"B":return!0;default:return!1}case"(":return"?"===this.peekChar(1)&&("="===this.peekChar(2)||"!"===this.peekChar(2));default:return!1}},e.prototype.isQuantifier=function(){var e=this.saveState();try{return void 0!==this.quantifier(!0)}catch(e){return!1}finally{this.restoreState(e)}},e.prototype.isPatternCharacter=function(){switch(this.peekChar()){case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":case"/":case"\n":case"\r":case"\u2028":case"\u2029":return!1;default:return!0}},e.prototype.parseHexDigits=function(e){for(var t="",n=0;n<e;n++){var a=this.popChar();if(!1===r.test(a))throw Error("Expecting a HexDecimal digits");t+=a}return{type:"Character",value:parseInt(t,16)}},e.prototype.peekChar=function(e){return void 0===e&&(e=0),this.input[this.idx+e]},e.prototype.popChar=function(){var e=this.peekChar(0);return this.consumeChar(),e},e.prototype.consumeChar=function(e){if(void 0!==e&&this.input[this.idx]!==e)throw Error("Expected: '"+e+"' but found: '"+this.input[this.idx]+"' at offset: "+this.idx);if(this.idx>=this.input.length)throw Error("Unexpected end of input");this.idx++};var t,r=/[0-9a-fA-F]/,n=/[0-9]/,a=/[1-9]/;function o(e){return e.charCodeAt(0)}function i(e,t){void 0!==e.length?e.forEach((function(e){t.push(e)})):t.push(e)}function s(e,t){if(!0===e[t])throw"duplicate flag "+t;e[t]=!0}function l(e){if(void 0===e)throw Error("Internal Error - Should never get here!")}var c=[];for(t=o("0");t<=o("9");t++)c.push(t);var f=[o("_")].concat(c);for(t=o("a");t<=o("z");t++)f.push(t);for(t=o("A");t<=o("Z");t++)f.push(t);var d=[o(" "),o("\f"),o("\n"),o("\r"),o("\t"),o("\v"),o("\t"),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o(" "),o("\u2028"),o("\u2029"),o(" "),o(" "),o("　"),o("\ufeff")];function u(){}return u.prototype.visitChildren=function(e){for(var t in e){var r=e[t];e.hasOwnProperty(t)&&(void 0!==r.type?this.visit(r):Array.isArray(r)&&r.forEach((function(e){this.visit(e)}),this))}},u.prototype.visit=function(e){switch(e.type){case"Pattern":this.visitPattern(e);break;case"Flags":this.visitFlags(e);break;case"Disjunction":this.visitDisjunction(e);break;case"Alternative":this.visitAlternative(e);break;case"StartAnchor":this.visitStartAnchor(e);break;case"EndAnchor":this.visitEndAnchor(e);break;case"WordBoundary":this.visitWordBoundary(e);break;case"NonWordBoundary":this.visitNonWordBoundary(e);break;case"Lookahead":this.visitLookahead(e);break;case"NegativeLookahead":this.visitNegativeLookahead(e);break;case"Character":this.visitCharacter(e);break;case"Set":this.visitSet(e);break;case"Group":this.visitGroup(e);break;case"GroupBackReference":this.visitGroupBackReference(e);break;case"Quantifier":this.visitQuantifier(e)}this.visitChildren(e)},u.prototype.visitPattern=function(e){},u.prototype.visitFlags=function(e){},u.prototype.visitDisjunction=function(e){},u.prototype.visitAlternative=function(e){},u.prototype.visitStartAnchor=function(e){},u.prototype.visitEndAnchor=function(e){},u.prototype.visitWordBoundary=function(e){},u.prototype.visitNonWordBoundary=function(e){},u.prototype.visitLookahead=function(e){},u.prototype.visitNegativeLookahead=function(e){},u.prototype.visitCharacter=function(e){},u.prototype.visitSet=function(e){},u.prototype.visitGroup=function(e){},u.prototype.visitGroupBackReference=function(e){},u.prototype.visitQuantifier=function(e){},{RegExpParser:e,BaseRegExpVisitor:u,VERSION:"0.4.0"}})?n.apply(t,[]):n)||(e.exports=a)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(e){return"Unable to pop Lexer Mode after encountering Token ->"+e.image+"<- The Mode Stack is empty"},buildUnexpectedCharactersMessage:function(e,t,r,n,a){return"unexpected character: ->"+e.charAt(t)+"<- at offset: "+t+", skipped "+r+" characters."}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(1),o=r(8);function i(e){if(e instanceof a.NonTerminal)return i(e.referencedRule);if(e instanceof a.Terminal)return c(e);if(o.isSequenceProd(e))return s(e);if(o.isBranchingProd(e))return l(e);throw Error("non exhaustive match")}function s(e){for(var t,r=[],a=e.definition,s=0,l=a.length>s,c=!0;l&&c;)t=a[s],c=o.isOptionalProd(t),r=r.concat(i(t)),s+=1,l=a.length>s;return n.uniq(r)}function l(e){var t=n.map(e.definition,(function(e){return i(e)}));return n.uniq(n.flatten(t))}function c(e){return[e.terminalType]}t.first=i,t.firstForSequence=s,t.firstForBranching=l,t.firstForTerminal=c},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IN="_~IN~_"},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,a=r(29),o=r(0),i=r(1);!function(e){e[e.OPTION=0]="OPTION",e[e.OR=1]="OR",e[e.MANY=2]="MANY",e[e.MANY_SEP=3]="MANY_SEP",e[e.AT_LEAST_ONE=4]="AT_LEAST_ONE",e[e.AT_LEAST_ONE_SEP=5]="AT_LEAST_ONE_SEP",e[e.REF=6]="REF",e[e.TERMINAL=7]="TERMINAL",e[e.FLAT=8]="FLAT"}(n=t.ProdType||(t.ProdType={}));var s=/(?:\s*{\s*NAME\s*:\s*["'`]([\w$]*)["'`])?/,l=new RegExp(s.source.replace("{","").replace(")?","\\s*,)?")),c=/\.\s*CONSUME(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,f=new RegExp(c.source,"g"),d=/\.\s*SUBRULE(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,u=new RegExp(d.source,"g"),p=/\.\s*OPTION(\d+)?\s*\(/,h=new RegExp(p.source+s.source),v=new RegExp(p.source,"g"),m=/\.\s*MANY(\d+)?\s*\(/,x=new RegExp(m.source+s.source),g=new RegExp(m.source,"g"),y=/\s*SEP\s*:\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,E=new RegExp(/\.\s*MANY_SEP(\d+)?\s*\(\s*{/.source+l.source+y.source),w=new RegExp(E.source,"g"),b=new RegExp(/\.\s*AT_LEAST_ONE_SEP(\d+)?\s*\(\s*{/.source+l.source+y.source),T=new RegExp(b.source,"g"),_=/\.\s*AT_LEAST_ONE(\d+)?\s*\(/,S=new RegExp(_.source+s.source),R=new RegExp(_.source,"g"),A=/\.\s*OR(\d+)?\s*\(/,M=new RegExp(A.source+s.source),C=new RegExp(A.source,"g"),L=new RegExp(l.source+/\s*(ALT)\s*:/.source),H=new RegExp(L.source,"g");function P(e,r,a){switch(e.type){case n.AT_LEAST_ONE:return function(e,t,r){return z(S,new i.RepetitionMandatory({definition:[]}),e,t,r)}(e,r,a);case n.AT_LEAST_ONE_SEP:return function(e,t,r){return k(e,t,i.RepetitionMandatoryWithSeparator,b,r)}(e,r,a);case n.MANY_SEP:return function(e,t,r){return k(e,t,i.RepetitionWithSeparator,E,r)}(e,r,a);case n.MANY:return function(e,t,r){return z(x,new i.Repetition({definition:[]}),e,t,r)}(e,r,a);case n.OPTION:return function(e,t,r){return z(h,new i.Option({definition:[]}),e,t,r)}(e,r,a);case n.OR:return function(e,t,r){return z(M,new i.Alternation({definition:[]}),e,t,r)}(e,r,a);case n.FLAT:return function(e,t,r){var n=new i.Flat({definition:[]}),a=L.exec(e.text)[1];return o.isUndefined(a)||(n.name=a),N(n,e.range,t,r)}(e,r,a);case n.REF:return function(e){var t=d.exec(e.text),r=void 0===t[1]?0:parseInt(t[1],10),n=t[2];return new i.NonTerminal({nonTerminalName:n,idx:r})}(e);case n.TERMINAL:return function(e,r){var n=c.exec(e.text),a=void 0===n[1]?0:parseInt(n[1],10),o=n[2],s=t.terminalNameToConstructor[o];if(!s)throw Error("Terminal Token name: <"+o+"> not found in rule: <"+r+">  \n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\n\tFor Further details.");return new i.Terminal({terminalType:s,idx:a})}(e,a);default:throw Error("non exhaustive match")}}function z(e,t,r,n,a){var i=e.exec(r.text),s=void 0===i[1];t.idx=s?0:parseInt(i[1],10);var l=i[2];return o.isUndefined(l)||(t.name=l),N(t,r.range,n,a)}function k(e,r,n,a,i){var s=a.exec(e.text),l=void 0===s[1]?0:parseInt(s[1],10),c=s[3],f=t.terminalNameToConstructor[c];if(!f)throw Error("Separator Terminal Token name: "+c+" not found");var d=new n({definition:[],separator:f,idx:l}),u=s[2];return o.isUndefined(u)||(d.name=u),N(d,e.range,r,i)}function N(e,t,r,n){var a=D(t,r),i=o.sortBy(a,(function(e){return e.range.start})),s=[];return o.forEach(i,(function(e){s.push(P(e,r,n))})),e.definition=s,e}function D(e,t){return o.filter(t,(function(r){var n=e.strictlyContainsRange(r.range),a=o.every(t,(function(t){var n=t.range.strictlyContainsRange(r.range),a=t.range.isStrictlyContainedInRange(e);return!(n&&a)}));return n&&a}))}t.terminalNameToConstructor={},t.buildTopProduction=function(e,r,n){t.terminalNameToConstructor=n;var o=j(V(G("  "+e)));return function(e,t,r,n){return N(new i.Rule({name:e,definition:[],orgText:n}),t,r,e)}(r,new a.Range(0,e.length+2),o,e)},t.buildProdGast=P,t.getDirectlyContainedRanges=D;var F=/\/\/.*/g,I=/\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\//g,O=/(NAME\s*:\s*)?"([^\\"]|\\([bfnrtv"\\\/]|u[0-9a-fA-F]{4}))*"/g,U=/(NAME\s*:\s*)?'([^\\']|\\([bfnrtv'\\\/]|u[0-9a-fA-F]{4}))*'/g;function G(e){return e.replace(F,"").replace(I,"")}function B(e,t){return void 0!==t?e:""}function V(e){return e.replace(O,B).replace(U,B)}function j(e){var t=W(e),r=q(e),n=X(e),a=Y(e),o=Z(e),i=Q(e),s=K(e),l=J(e);return[].concat(t,r,n,a,o,i,s,l)}function W(e){return re(e,n.TERMINAL,f)}function q(e){return re(e,n.REF,u)}function X(e){return ne(e,n.AT_LEAST_ONE,R)}function Y(e){return ne(e,n.AT_LEAST_ONE_SEP,T)}function Z(e){return ne(e,n.MANY,g)}function Q(e){return ne(e,n.MANY_SEP,w)}function K(e){return ne(e,n.OPTION,v)}function J(e){var t=ne(e,n.OR,C),r=te(t);return t.concat(r)}t.removeComments=G,t.removeStringLiterals=V,t.createRanges=j,t.createTerminalRanges=W,t.createRefsRanges=q,t.createAtLeastOneRanges=X,t.createAtLeastOneSepRanges=Y,t.createManyRanges=Z,t.createManySepRanges=Q,t.createOptionRanges=K,t.createOrRanges=J;var $=o.partial(oe,"{","}"),ee=o.partial(oe,"(",")");function te(e){var t=[];return o.forEach(e,(function(e){var r=ae(e.text,n.FLAT,H,$),a=e.range.start;o.forEach(r,(function(e){e.range.start+=a,e.range.end+=a})),t=t.concat(r)})),o.uniq(t,(function(e){return e.type+"~"+e.range.start+"~"+e.range.end+"~"+e.text}))}function re(e,t,r){for(var n,o=[];n=r.exec(e);){var i=n.index,s=r.lastIndex,l=new a.Range(i,s),c=n[0];o.push({range:l,text:c,type:t})}return o}function ne(e,t,r){return ae(e,t,r,ee)}function ae(e,t,r,n){for(var o,i=[];o=r.exec(e);){var s=o.index,l=n(s+o[0].length,e),c=new a.Range(s,l),f=e.substr(s,l-s+1);i.push({range:c,text:f,type:t})}return i}function oe(e,t,r,n){for(var a=[1],i=-1;!o.isEmpty(a)&&i+r<n.length;){i++;var s=n.charAt(r+i);s===e?a.push(1):s===t&&a.pop()}if(o.isEmpty(a))return i+r;throw new Error("INVALID INPUT TEXT, UNTERMINATED PARENTHESIS")}function ie(e,t){return o.map(e,(function(e){return se(e,t)}))}function se(e,t){switch(e.type){case"NonTerminal":return new i.NonTerminal({nonTerminalName:e.name,idx:e.idx});case"Flat":return new i.Flat({name:e.name,definition:ie(e.definition,t)});case"Option":return new i.Option({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"RepetitionMandatory":return new i.RepetitionMandatory({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"RepetitionMandatoryWithSeparator":return new i.RepetitionMandatoryWithSeparator({name:e.name,idx:e.idx,separator:t[e.separator.name],definition:ie(e.definition,t)});case"RepetitionWithSeparator":return new i.RepetitionWithSeparator({name:e.name,idx:e.idx,separator:t[e.separator.name],definition:ie(e.definition,t)});case"Repetition":return new i.Repetition({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"Alternation":return new i.Alternation({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"Terminal":return new i.Terminal({terminalType:t[e.name],idx:e.idx});case"Rule":return new i.Rule({name:e.name,orgText:e.orgText,definition:ie(e.definition,t)})}}t.createOrPartRanges=te,t.findClosingOffset=oe,t.deserializeGrammar=ie,t.deserializeProduction=se},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(4),o=r(30),i=r(11),s=r(10),l=r(8);t.resolveGrammar=function(e){e=n.defaults(e,{errMsgProvider:s.defaultGrammarResolverErrorProvider});var t=new a.HashTable;return n.forEach(e.rules,(function(e){t.put(e.name,e)})),o.resolveGrammar(t,e.errMsgProvider)},t.validateGrammar=function(e){return e=n.defaults(e,{errMsgProvider:s.defaultGrammarValidatorErrorProvider,ignoredIssues:{}}),i.validateGrammar(e.rules,e.maxLookahead,e.tokenTypes,e.ignoredIssues,e.errMsgProvider,e.grammarName)},t.assignOccurrenceIndices=function(e){n.forEach(e.rules,(function(e){var t=new l.DslMethodsCollectorVisitor;e.accept(t),n.forEach(t.dslMethods,(function(e){n.forEach(e,(function(e,t){e.idx=t+1}))}))}))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(2),a=r(0),o=r(6),i=r(22),s=r(4),l=r(3);function c(e){this.name=t.IN_RULE_RECOVERY_EXCEPTION,this.message=e}t.EOF_FOLLOW_KEY={},t.IN_RULE_RECOVERY_EXCEPTION="InRuleRecoveryException",t.InRuleRecoveryException=c,c.prototype=Error.prototype;var f=function(){function e(){}return e.prototype.initRecoverable=function(e){this.firstAfterRepMap=new s.HashTable,this.resyncFollows=new s.HashTable,this.recoveryEnabled=a.has(e,"recoveryEnabled")?e.recoveryEnabled:l.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=d)},e.prototype.getTokenToInsert=function(e){var t=n.createTokenInstance(e,"",NaN,NaN,NaN,NaN,NaN,NaN);return t.isInsertedInRecovery=!0,t},e.prototype.canTokenTypeBeInsertedInRecovery=function(e){return!0},e.prototype.tryInRepetitionRecovery=function(e,t,r,n){for(var i=this,s=this.findReSyncTokenType(),l=this.exportLexerState(),c=[],f=!1,d=this.LA(1),u=this.LA(1),p=function(){var e=i.LA(0),t=i.errorMessageProvider.buildMismatchTokenMessage({expected:n,actual:d,previous:e,ruleName:i.getCurrRuleFullName()}),r=new o.MismatchedTokenException(t,d,i.LA(0));r.resyncedTokens=a.dropRight(c),i.SAVE_ERROR(r)};!f;){if(this.tokenMatcher(u,n))return void p();if(r.call(this))return p(),void e.apply(this,t);this.tokenMatcher(u,s)?f=!0:(u=this.SKIP_TOKEN(),this.addToResyncTokens(u,c))}this.importLexerState(l)},e.prototype.shouldInRepetitionRecoveryBeTried=function(e,t){return void 0!==e&&void 0!==t&&!this.tokenMatcher(this.LA(1),e)&&!this.isBackTracking()&&!this.canPerformInRuleRecovery(e,this.getFollowsForInRuleRecovery(e,t))},e.prototype.getFollowsForInRuleRecovery=function(e,t){var r=this.getCurrentGrammarPath(e,t);return this.getNextPossibleTokenTypes(r)},e.prototype.tryInRuleRecovery=function(e,t){if(this.canRecoverWithSingleTokenInsertion(e,t))return this.getTokenToInsert(e);if(this.canRecoverWithSingleTokenDeletion(e)){var r=this.SKIP_TOKEN();return this.consumeToken(),r}throw new c("sad sad panda")},e.prototype.canPerformInRuleRecovery=function(e,t){return this.canRecoverWithSingleTokenInsertion(e,t)||this.canRecoverWithSingleTokenDeletion(e)},e.prototype.canRecoverWithSingleTokenInsertion=function(e,t){var r=this;if(!this.canTokenTypeBeInsertedInRecovery(e))return!1;if(a.isEmpty(t))return!1;var n=this.LA(1);return void 0!==a.find(t,(function(e){return r.tokenMatcher(n,e)}))},e.prototype.canRecoverWithSingleTokenDeletion=function(e){return this.tokenMatcher(this.LA(2),e)},e.prototype.isInCurrentRuleReSyncSet=function(e){var t=this.getCurrFollowKey(),r=this.getFollowSetFromFollowKey(t);return a.contains(r,e)},e.prototype.findReSyncTokenType=function(){for(var e=this.flattenFollowSet(),t=this.LA(1),r=2;;){var n=t.tokenType;if(a.contains(e,n))return n;t=this.LA(r),r++}},e.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return t.EOF_FOLLOW_KEY;var e=this.getLastExplicitRuleShortName(),r=this.getLastExplicitRuleOccurrenceIndex(),n=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(e),idxInCallingRule:r,inRule:this.shortRuleNameToFullName(n)}},e.prototype.buildFullFollowKeyStack=function(){var e=this,r=this.RULE_STACK,n=this.RULE_OCCURRENCE_STACK;return a.isEmpty(this.LAST_EXPLICIT_RULE_STACK)||(r=a.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.RULE_STACK[t]})),n=a.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.RULE_OCCURRENCE_STACK[t]}))),a.map(r,(function(a,o){return 0===o?t.EOF_FOLLOW_KEY:{ruleName:e.shortRuleNameToFullName(a),idxInCallingRule:n[o],inRule:e.shortRuleNameToFullName(r[o-1])}}))},e.prototype.flattenFollowSet=function(){var e=this,t=a.map(this.buildFullFollowKeyStack(),(function(t){return e.getFollowSetFromFollowKey(t)}));return a.flatten(t)},e.prototype.getFollowSetFromFollowKey=function(e){if(e===t.EOF_FOLLOW_KEY)return[n.EOF];var r=e.ruleName+e.idxInCallingRule+i.IN+e.inRule;return this.resyncFollows.get(r)},e.prototype.addToResyncTokens=function(e,t){return this.tokenMatcher(e,n.EOF)||t.push(e),t},e.prototype.reSyncTo=function(e){for(var t=[],r=this.LA(1);!1===this.tokenMatcher(r,e);)r=this.SKIP_TOKEN(),this.addToResyncTokens(r,t);return a.dropRight(t)},e.prototype.attemptInRepetitionRecovery=function(e,t,r,n,a,o){},e.prototype.getCurrentGrammarPath=function(e,t){return{ruleStack:this.getHumanReadableRuleStack(),occurrenceStack:a.cloneArr(this.RULE_OCCURRENCE_STACK),lastTok:e,lastTokOccurrence:t}},e.prototype.getHumanReadableRuleStack=function(){var e=this;return a.isEmpty(this.LAST_EXPLICIT_RULE_STACK)?a.map(this.RULE_STACK,(function(t){return e.shortRuleNameToFullName(t)})):a.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.shortRuleNameToFullName(e.RULE_STACK[t])}))},e}();function d(e,t,r,a,o,i){var s=this.getKeyForAutomaticLookahead(a,o),l=this.firstAfterRepMap.get(s);if(void 0===l){var c=this.getCurrRuleFullName();l=new i(this.getGAstProductions().get(c),o).startWalking(),this.firstAfterRepMap.put(s,l)}var f=l.token,d=l.occurrence,u=l.isEndOfRule;1===this.RULE_STACK.length&&u&&void 0===f&&(f=n.EOF,d=1),this.shouldInRepetitionRecoveryBeTried(f,d)&&this.tryInRepetitionRecovery(e,t,r,f)}t.Recoverable=f,t.attemptInRepetitionRecovery=d},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(14),i=r(4),s=r(21),l=r(0),c=r(22),f=r(2),d=r(1),u=function(e){function t(t){var r=e.call(this)||this;return r.topProd=t,r.follows=new i.HashTable,r}return a(t,e),t.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},t.prototype.walkTerminal=function(e,t,r){},t.prototype.walkProdRef=function(e,t,r){var n=p(e.referencedRule,e.idx)+this.topProd.name,a=t.concat(r),o=new d.Flat({definition:a}),i=s.first(o);this.follows.put(n,i)},t}(o.RestWalker);function p(e,t){return e.name+t+c.IN}t.ResyncFollowsWalker=u,t.computeAllProdsFollows=function(e){var t=new i.HashTable;return l.forEach(e,(function(e){var r=new u(e).startWalking();t.putAll(r)})),t},t.buildBetweenProdsFollowPrefix=p,t.buildInProdFollowPrefix=function(e){return f.tokenName(e.terminalType)+e.idx+c.IN}},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(19),i=r(2),s=r(15),l=r(0),c=r(28),f=new o.RegExpParser,d="PATTERN";function u(e){var t=l.filter(e,(function(e){return!l.has(e,d)}));return{errors:l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- missing static 'PATTERN' property",type:s.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[e]}})),valid:l.difference(e,t)}}function p(e){var t=l.filter(e,(function(e){var t=e[d];return!(l.isRegExp(t)||l.isFunction(t)||l.has(t,"exec")||l.isString(t))}));return{errors:l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:s.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[e]}})),valid:l.difference(e,t)}}t.DEFAULT_MODE="defaultMode",t.MODES="modes",t.SUPPORT_STICKY="boolean"==typeof new RegExp("(?:)").sticky,t.disableSticky=function(){t.SUPPORT_STICKY=!1},t.enableSticky=function(){t.SUPPORT_STICKY=!0},t.analyzeTokenTypes=function(e,r){r=l.defaults(r,{useSticky:t.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r","\n"]});var n=l.reject(e,(function(e){return e[d]===s.Lexer.NA})),a=!1,o=l.map(n,(function(e){var t=e[d];if(l.isRegExp(t)){var n=t.source;return 1===n.length&&"^"!==n&&"$"!==n&&"."!==n?n:2!==n.length||"\\"!==n[0]||l.contains(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],n[1])?r.useSticky?S(t):_(t):n[1]}if(l.isFunction(t))return a=!0,{exec:t};if(l.has(t,"exec"))return a=!0,t;if("string"==typeof t){if(1===t.length)return t;var o=t.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"),i=new RegExp(o);return r.useSticky?S(i):_(i)}throw Error("non exhaustive match")})),f=l.map(n,(function(e){return e.tokenTypeIdx})),u=l.map(n,(function(e){var t=e.GROUP;if(t!==s.Lexer.SKIPPED){if(l.isString(t))return t;if(l.isUndefined(t))return!1;throw Error("non exhaustive match")}})),p=l.map(n,(function(e){var t=e.LONGER_ALT;if(t)return l.indexOf(n,t)})),h=l.map(n,(function(e){return e.PUSH_MODE})),v=l.map(n,(function(e){return l.has(e,"POP_MODE")})),m=L(r.lineTerminatorCharacters),x=l.map(n,(function(e){return!1}));"onlyOffset"!==r.positionTracking&&(x=l.map(n,(function(e){return l.has(e,"LINE_BREAKS")?e.LINE_BREAKS:!1===M(e,m)?c.canMatchCharCode(m,e.PATTERN):void 0})));var g=l.map(n,R),y=l.map(o,A),E=l.reduce(n,(function(e,t){var r=t.GROUP;return l.isString(r)&&r!==s.Lexer.SKIPPED&&(e[r]=[]),e}),{}),w=l.map(o,(function(e,t){return{pattern:o[t],longerAlt:p[t],canLineTerminator:x[t],isCustom:g[t],short:y[t],group:u[t],push:h[t],pop:v[t],tokenTypeIdx:f[t],tokenType:n[t]}}));function b(e,t,r){void 0===e[t]&&(e[t]=[]),e[t].push(r)}var T=!0,C=[];return r.safeMode||(C=l.reduce(n,(function(e,t,n){if("string"==typeof t.PATTERN){var a=t.PATTERN.charCodeAt(0);b(e,a,w[n])}else if(l.isArray(t.START_CHARS_HINT))l.forEach(t.START_CHARS_HINT,(function(t){var r="string"==typeof t?t.charCodeAt(0):t;b(e,r,w[n])}));else if(l.isRegExp(t.PATTERN))if(t.PATTERN.unicode)T=!1,r.ensureOptimizations&&l.PRINT_ERROR(c.failedOptimizationPrefixMsg+"\tUnable to analyze < "+t.PATTERN.toString()+" > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");else{var o=c.getStartCodes(t.PATTERN,r.ensureOptimizations);l.isEmpty(o)&&(T=!1),l.forEach(o,(function(t){b(e,t,w[n])}))}else r.ensureOptimizations&&l.PRINT_ERROR(c.failedOptimizationPrefixMsg+"\tTokenType: <"+i.tokenName(t)+"> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE"),T=!1;return e}),[])),T&&C.length<65536&&(C=l.packArray(C)),{emptyGroups:E,patternIdxToConfig:w,charCodeToPatternIdxToConfig:C,hasCustom:a,canBeOptimized:T}},t.validatePatterns=function(e,t){var r=[],n=u(e);r=r.concat(n.errors);var a=p(n.valid),o=a.valid;return(r=(r=(r=(r=r.concat(a.errors)).concat(function(e){var t=[],r=l.filter(e,(function(e){return l.isRegExp(e[d])}));return(t=(t=(t=(t=t.concat(v(r))).concat(g(r))).concat(y(r))).concat(E(r))).concat(m(r))}(o))).concat(w(o))).concat(b(o,t))).concat(T(o))},t.findMissingPatterns=u,t.findInvalidPatterns=p;var h=/[^\\][\$]/;function v(e){var t=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.found=!1,t}return a(t,e),t.prototype.visitEndAnchor=function(e){this.found=!0},t}(o.BaseRegExpVisitor),r=l.filter(e,(function(e){var r=e[d];try{var n=f.pattern(r.toString()),a=new t;return a.visit(n),a.found}catch(e){return h.test(r.source)}}));return l.map(r,(function(e){return{message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+i.tokenName(e)+"<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:s.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[e]}}))}function m(e){var t=l.filter(e,(function(e){return e[d].test("")}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' must not match an empty string",type:s.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[e]}}))}t.findEndOfInputAnchor=v,t.findEmptyMatchRegExps=m;var x=/[^\\[][\^]|^\^/;function g(e){var t=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.found=!1,t}return a(t,e),t.prototype.visitStartAnchor=function(e){this.found=!0},t}(o.BaseRegExpVisitor),r=l.filter(e,(function(e){var r=e[d];try{var n=f.pattern(r.toString()),a=new t;return a.visit(n),a.found}catch(e){return x.test(r.source)}}));return l.map(r,(function(e){return{message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+i.tokenName(e)+"<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:s.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[e]}}))}function y(e){var t=l.filter(e,(function(e){var t=e[d];return t instanceof RegExp&&(t.multiline||t.global)}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:s.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[e]}}))}function E(e){var t=[],r=l.map(e,(function(r){return l.reduce(e,(function(e,n){return r.PATTERN.source!==n.PATTERN.source||l.contains(t,n)||n.PATTERN===s.Lexer.NA||(t.push(n),e.push(n)),e}),[])}));r=l.compact(r);var n=l.filter(r,(function(e){return e.length>1}));return l.map(n,(function(e){var t=l.map(e,(function(e){return i.tokenName(e)}));return{message:"The same RegExp pattern ->"+l.first(e).PATTERN+"<-has been used in all of the following Token Types: "+t.join(", ")+" <-",type:s.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:e}}))}function w(e){var t=l.filter(e,(function(e){if(!l.has(e,"GROUP"))return!1;var t=e.GROUP;return t!==s.Lexer.SKIPPED&&t!==s.Lexer.NA&&!l.isString(t)}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:s.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[e]}}))}function b(e,t){var r=l.filter(e,(function(e){return void 0!==e.PUSH_MODE&&!l.contains(t,e.PUSH_MODE)}));return l.map(r,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->"+e.PUSH_MODE+"<-which does not exist",type:s.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[e]}}))}function T(e){var t=[],r=l.reduce(e,(function(e,t,r){var n,a=t.PATTERN;return a===s.Lexer.NA||(l.isString(a)?e.push({str:a,idx:r,tokenType:t}):l.isRegExp(a)&&(n=a,void 0===l.find([".","\\","[","]","|","^","$","(",")","?","*","+","{"],(function(e){return-1!==n.source.indexOf(e)})))&&e.push({str:a.source,idx:r,tokenType:t})),e}),[]);return l.forEach(e,(function(e,n){l.forEach(r,(function(r){var a=r.str,o=r.idx,c=r.tokenType;if(n<o&&function(e,t){if(l.isRegExp(t)){var r=t.exec(e);return null!==r&&0===r.index}if(l.isFunction(t))return t(e,0,[],{});if(l.has(t,"exec"))return t.exec(e,0,[],{});if("string"==typeof t)return t===e;throw Error("non exhaustive match")}(a,e.PATTERN)){var f="Token: ->"+i.tokenName(c)+"<- can never be matched.\nBecause it appears AFTER the Token Type ->"+i.tokenName(e)+"<-in the lexer's definition.\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";t.push({message:f,type:s.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[e,c]})}}))})),t}function _(e){var t=e.ignoreCase?"i":"";return new RegExp("^(?:"+e.source+")",t)}function S(e){var t=e.ignoreCase?"iy":"y";return new RegExp(""+e.source,t)}function R(e){var t=e.PATTERN;if(l.isRegExp(t))return!1;if(l.isFunction(t))return!0;if(l.has(t,"exec"))return!0;if(l.isString(t))return!1;throw Error("non exhaustive match")}function A(e){return!(!l.isString(e)||1!==e.length)&&e.charCodeAt(0)}function M(e,t){if(l.has(e,"LINE_BREAKS"))return!1;if(l.isRegExp(e.PATTERN)){try{c.canMatchCharCode(t,e.PATTERN)}catch(e){return{issue:s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:e.message}}return!1}if(l.isString(e.PATTERN))return!1;if(R(e))return{issue:s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}function C(e,t){if(t.issue===s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return"Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <"+e.name+"> Token Type\n\t Root cause: "+t.errMsg+".\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";if(t.issue===s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return"Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <"+e.name+"> Token Type\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";throw Error("non exhaustive match")}function L(e){return l.map(e,(function(e){return l.isString(e)&&e.length>0?e.charCodeAt(0):e}))}t.findStartOfInputAnchor=g,t.findUnsupportedFlags=y,t.findDuplicatePatterns=E,t.findInvalidGroupType=w,t.findModesThatDoNotExist=b,t.findUnreachablePatterns=T,t.addStartOfInput=_,t.addStickyFlag=S,t.performRuntimeChecks=function(e,r,n){var a=[];return l.has(e,t.DEFAULT_MODE)||a.push({message:"A MultiMode Lexer cannot be initialized without a <"+t.DEFAULT_MODE+"> property in its definition\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),l.has(e,t.MODES)||a.push({message:"A MultiMode Lexer cannot be initialized without a <"+t.MODES+"> property in its definition\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),l.has(e,t.MODES)&&l.has(e,t.DEFAULT_MODE)&&!l.has(e.modes,e.defaultMode)&&a.push({message:"A MultiMode Lexer cannot be initialized with a "+t.DEFAULT_MODE+": <"+e.defaultMode+">which does not exist\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),l.has(e,t.MODES)&&l.forEach(e.modes,(function(e,t){l.forEach(e,(function(e,r){l.isUndefined(e)&&a.push({message:"A Lexer cannot be initialized using an undefined Token Type. Mode:<"+t+"> at index: <"+r+">\n",type:s.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED})}))})),a},t.performWarningRuntimeChecks=function(e,t,r){var n=[],a=!1,o=l.compact(l.flatten(l.mapValues(e.modes,(function(e){return e})))),i=l.reject(o,(function(e){return e[d]===s.Lexer.NA})),f=L(r);return t&&l.forEach(i,(function(e){var t=M(e,f);if(!1!==t){var r={message:C(e,t),type:t.issue,tokenType:e};n.push(r)}else l.has(e,"LINE_BREAKS")?!0===e.LINE_BREAKS&&(a=!0):c.canMatchCharCode(f,e.PATTERN)&&(a=!0)})),t&&!a&&n.push({message:"Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.",type:s.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),n},t.cloneEmptyGroups=function(e){var t={},r=l.keys(e);return l.forEach(r,(function(r){var n=e[r];if(!l.isArray(n))throw Error("non exhaustive match");t[r]=[]})),t},t.isCustomPattern=R,t.isShortPattern=A,t.LineTerminatorOptimizedTester={test:function(e){for(var t=e.length,r=this.lastIndex;r<t;r++){var n=e.charCodeAt(r);if(10===n)return this.lastIndex=r+1,!0;if(13===n)return 10===e.charCodeAt(r+1)?this.lastIndex=r+2:this.lastIndex=r+1,!0}return!1},lastIndex:0},t.buildLineBreakIssueMessage=C},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(19),i=r(0),s=new o.RegExpParser,l="Complement Sets are not supported for first char optimization";function c(e){switch(e.type){case"Disjunction":return i.flatten(i.map(e.value,c));case"Alternative":for(var t=[],r=e.value,n=0;n<r.length;n++){var a=r[n];if(!i.contains(["GroupBackReference","Lookahead","NegativeLookahead","StartAnchor","EndAnchor","WordBoundary","NonWordBoundary"],a.type)){var o=a;switch(o.type){case"Character":t.push(o.value);break;case"Set":if(!0===o.complement)throw Error(l);i.forEach(o.value,(function(e){if("number"==typeof e)t.push(e);else for(var r=e,n=r.from;n<=r.to;n++)t.push(n)}));break;case"Group":var s=c(o.value);i.forEach(s,(function(e){return t.push(e)}));break;default:throw Error("Non Exhaustive Match")}var f=void 0!==o.quantifier&&0===o.quantifier.atLeast;if("Group"===o.type&&!1===u(o)||"Group"!==o.type&&!1===f)break}}return t;default:throw Error("non exhaustive match!")}}function f(e){var t=[];return i.forEach(e,(function(e){t.push(e);var r=String.fromCharCode(e);r.toUpperCase()!==r?t.push(r.toUpperCase().charCodeAt(0)):r.toLowerCase()!==r&&t.push(r.toLowerCase().charCodeAt(0))})),t}function d(e,t){return i.find(e.value,(function(e){if("number"==typeof e)return i.contains(t,e);var r=e;return void 0!==i.find(t,(function(e){return r.from<=e&&e<=r.to}))}))}function u(e){return!(!e.quantifier||0!==e.quantifier.atLeast)||!!e.value&&(i.isArray(e.value)?i.every(e.value,u):u(e.value))}t.failedOptimizationPrefixMsg='Unable to use "first char" lexer optimizations:\n',t.getStartCodes=function(e,r){void 0===r&&(r=!1);try{var n=s.pattern(e.toString()),a=c(n.value);return n.flags.ignoreCase&&(a=f(a)),a}catch(n){if(n.message===l)r&&i.PRINT_WARNING(t.failedOptimizationPrefixMsg+"\tUnable to optimize: < "+e.toString()+" >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");else{var d="";r&&(d="\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."),i.PRINT_ERROR(t.failedOptimizationPrefixMsg+"\n\tFailed parsing: < "+e.toString()+" >\n\tUsing the regexp-to-ast library version: "+o.VERSION+"\n\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues"+d)}}return[]},t.firstChar=c,t.applyIgnoreCase=f;var p=function(e){function t(t){var r=e.call(this)||this;return r.targetCharCodes=t,r.found=!1,r}return a(t,e),t.prototype.visitChildren=function(t){switch(t.type){case"Lookahead":return void this.visitLookahead(t);case"NegativeLookahead":return void this.visitNegativeLookahead(t)}e.prototype.visitChildren.call(this,t)},t.prototype.visitCharacter=function(e){i.contains(this.targetCharCodes,e.value)&&(this.found=!0)},t.prototype.visitSet=function(e){e.complement?void 0===d(e,this.targetCharCodes)&&(this.found=!0):void 0!==d(e,this.targetCharCodes)&&(this.found=!0)},t}(o.BaseRegExpVisitor);t.canMatchCharCode=function(e,t){if(t instanceof RegExp){var r=s.pattern(t.toString()),n=new p(e);return n.visit(r),n.found}return void 0!==i.find(t,(function(t){return i.contains(e,t.charCodeAt(0))}))}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function e(e,t){if(this.start=e,this.end=t,!a(e,t))throw new Error("INVALID RANGE")}return e.prototype.contains=function(e){return this.start<=e&&this.end>=e},e.prototype.containsRange=function(e){return this.start<=e.start&&this.end>=e.end},e.prototype.isContainedInRange=function(e){return e.containsRange(this)},e.prototype.strictlyContainsRange=function(e){return this.start<e.start&&this.end>e.end},e.prototype.isStrictlyContainedInRange=function(e){return e.strictlyContainsRange(this)},e}();function a(e,t){return!(e<0||t<e)}t.Range=n,t.isValidRange=a},function(e,t,r){"use strict";var n,a=this&&this.__extends||(n=function(e,t){return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])})(e,t)},function(e,t){function r(){this.constructor=e}n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)});Object.defineProperty(t,"__esModule",{value:!0});var o=r(3),i=r(0),s=r(5);t.resolveGrammar=function(e,t){var r=new l(e,t);return r.resolveRefs(),r.errors};var l=function(e){function t(t,r){var n=e.call(this)||this;return n.nameToTopRule=t,n.errMsgProvider=r,n.errors=[],n}return a(t,e),t.prototype.resolveRefs=function(){var e=this;i.forEach(this.nameToTopRule.values(),(function(t){e.currTopLevel=t,t.accept(e)}))},t.prototype.visitNonTerminal=function(e){var t=this.nameToTopRule.get(e.nonTerminalName);if(t)e.referencedRule=t;else{var r=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,e);this.errors.push({message:r,type:o.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:e.nonTerminalName})}},t}(s.GAstVisitor);t.GastRefResolverVisitor=l},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(12),a=r(0),o=r(3),i=r(9),s=function(){function e(){}return e.prototype.initLooksAhead=function(e){this.dynamicTokensEnabled=a.has(e,"dynamicTokensEnabled")?e.dynamicTokensEnabled:o.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=a.has(e,"maxLookahead")?e.maxLookahead:o.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=a.isES2015MapSupported()?new Map:[],a.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj)},e.prototype.lookAheadBuilderForOptional=function(e,t,r){return n.buildSingleAlternativeLookaheadFunction(e,t,r)},e.prototype.lookAheadBuilderForAlternatives=function(e,t,r,a){return n.buildAlternativesLookAheadFunc(e,t,r,a)},e.prototype.getKeyForAutomaticLookahead=function(e,t){var r=this.getLastExplicitRuleShortName();return i.getKeyForAutomaticLookahead(r,e,t)},e.prototype.getLookaheadFuncForOr=function(e,t){var r=this.getKeyForAutomaticLookahead(i.OR_IDX,e),o=this.getLaFuncFromCache(r);if(void 0===o){var s=this.getCurrRuleFullName(),l=this.getGAstProductions().get(s),c=a.some(t,(function(e){return a.isFunction(e.GATE)}));return o=n.buildLookaheadFuncForOr(e,l,this.maxLookahead,c,this.dynamicTokensEnabled,this.lookAheadBuilderForAlternatives),this.setLaFuncCache(r,o),o}return o},e.prototype.getLookaheadFuncForOption=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,n.PROD_TYPE.OPTION)},e.prototype.getLookaheadFuncForMany=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,n.PROD_TYPE.REPETITION)},e.prototype.getLookaheadFuncForManySep=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,n.PROD_TYPE.REPETITION_WITH_SEPARATOR)},e.prototype.getLookaheadFuncForAtLeastOne=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,n.PROD_TYPE.REPETITION_MANDATORY)},e.prototype.getLookaheadFuncForAtLeastOneSep=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,n.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)},e.prototype.getLookaheadFuncFor=function(e,t,r,a){var o=this.getLaFuncFromCache(e);if(void 0===o){var i=this.getCurrRuleFullName(),s=this.getGAstProductions().get(i);return o=n.buildLookaheadFuncForOptionalProd(t,s,r,this.dynamicTokensEnabled,a,this.lookAheadBuilderForOptional),this.setLaFuncCache(e,o),o}return o},e.prototype.getLaFuncFromCache=function(e){},e.prototype.getLaFuncFromMap=function(e){return this.lookAheadFuncsCache.get(e)},e.prototype.getLaFuncFromObj=function(e){return this.lookAheadFuncsCache[e]},e.prototype.setLaFuncCache=function(e,t){},e.prototype.setLaFuncCacheUsingMap=function(e,t){this.lookAheadFuncsCache.set(e,t)},e.prototype.setLaFuncUsingObj=function(e,t){this.lookAheadFuncsCache[e]=t},e}();t.LooksAhead=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(16),a=r(0),o=r(33),i=r(9),s=r(3),l=function(){function e(){}return e.prototype.initTreeBuilder=function(e){this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.outputCst=a.has(e,"outputCst")?e.outputCst:s.DEFAULT_PARSER_CONFIG.outputCst,this.outputCst||(this.cstInvocationStateUpdate=a.NOOP,this.cstFinallyStateUpdate=a.NOOP,this.cstPostTerminal=a.NOOP,this.cstPostNonTerminal=a.NOOP,this.getLastExplicitRuleShortName=this.getLastExplicitRuleShortNameNoCst,this.getPreviousExplicitRuleShortName=this.getPreviousExplicitRuleShortNameNoCst,this.getLastExplicitRuleOccurrenceIndex=this.getLastExplicitRuleOccurrenceIndexNoCst,this.manyInternal=this.manyInternalNoCst,this.orInternal=this.orInternalNoCst,this.optionInternal=this.optionInternalNoCst,this.atLeastOneInternal=this.atLeastOneInternalNoCst,this.manySepFirstInternal=this.manySepFirstInternalNoCst,this.atLeastOneSepFirstInternal=this.atLeastOneSepFirstInternalNoCst)},e.prototype.cstNestedInvocationStateUpdate=function(e,t){this.CST_STACK.push({name:e,fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName())+e,children:{}})},e.prototype.cstInvocationStateUpdate=function(e,t){this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length-1),this.CST_STACK.push({name:e,children:{}})},e.prototype.cstFinallyStateUpdate=function(){this.LAST_EXPLICIT_RULE_STACK.pop(),this.CST_STACK.pop()},e.prototype.cstNestedFinallyStateUpdate=function(){this.CST_STACK.pop()},e.prototype.cstPostTerminal=function(e,t){var r=this.CST_STACK[this.CST_STACK.length-1];n.addTerminalToCst(r,t,e)},e.prototype.cstPostNonTerminal=function(e,t){n.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length-1],t,e)},e.prototype.getBaseCstVisitorConstructor=function(){if(a.isUndefined(this.baseCstVisitorConstructor)){var e=o.createBaseSemanticVisitorConstructor(this.className,this.allRuleNames);return this.baseCstVisitorConstructor=e,e}return this.baseCstVisitorConstructor},e.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(a.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var e=o.createBaseVisitorConstructorWithDefaults(this.className,this.allRuleNames,this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=e,e}return this.baseCstVisitorWithDefaultsConstructor},e.prototype.nestedRuleBeforeClause=function(e,t){var r;return void 0!==e.NAME?(r=e.NAME,this.nestedRuleInvocationStateUpdate(r,t),r):void 0},e.prototype.nestedAltBeforeClause=function(e,t,r,n){var a,o=this.getLastExplicitRuleShortName(),s=i.getKeyForAltIndex(o,r,t,n);return void 0!==e.NAME?(a=e.NAME,this.nestedRuleInvocationStateUpdate(a,s),{shortName:s,nestedName:a}):void 0},e.prototype.nestedRuleFinallyClause=function(e,t){var r=this.CST_STACK,a=r[r.length-1];this.nestedRuleFinallyStateUpdate();var o=r[r.length-1];n.addNoneTerminalToCst(o,t,a)},e.prototype.getLastExplicitRuleShortName=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_STACK[e]},e.prototype.getLastExplicitRuleShortNameNoCst=function(){var e=this.RULE_STACK;return e[e.length-1]},e.prototype.getPreviousExplicitRuleShortName=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-2];return this.RULE_STACK[e]},e.prototype.getPreviousExplicitRuleShortNameNoCst=function(){var e=this.RULE_STACK;return e[e.length-2]},e.prototype.getLastExplicitRuleOccurrenceIndex=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_OCCURRENCE_STACK[e]},e.prototype.getLastExplicitRuleOccurrenceIndexNoCst=function(){var e=this.RULE_OCCURRENCE_STACK;return e[e.length-1]},e.prototype.nestedRuleInvocationStateUpdate=function(e,t){this.RULE_OCCURRENCE_STACK.push(1),this.RULE_STACK.push(t),this.cstNestedInvocationStateUpdate(e,t)},e.prototype.nestedRuleFinallyStateUpdate=function(){this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstNestedFinallyStateUpdate()},e}();t.TreeBuilder=l},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n,a=r(0),o=r(4),i=r(11);function s(e,t){for(var r=a.keys(e),n=r.length,o=0;o<n;o++)for(var i=e[r[o]],s=i.length,l=0;l<s;l++){var c=i[l];void 0===c.tokenTypeIdx&&(void 0!==c.fullName?this[c.fullName](c.children,t):this[c.name](c.children,t))}}function l(e,t){var r=c(e,t),n=d(e,t);return r.concat(n)}function c(e,t){var r=a.map(t,(function(t){if(!a.isFunction(e[t]))return{msg:"Missing visitor method: <"+t+"> on "+o.functionName(e.constructor)+" CST Visitor.",type:n.MISSING_METHOD,methodName:t}}));return a.compact(r)}t.defaultVisit=s,t.createBaseSemanticVisitorConstructor=function(e,t){var r=function(){};return o.defineNameProp(r,e+"BaseSemantics"),(r.prototype={visit:function(e,t){if(a.isArray(e)&&(e=e[0]),!a.isUndefined(e))return void 0!==e.fullName?this[e.fullName](e.children,t):this[e.name](e.children,t)},validateVisitor:function(){var e=l(this,t);if(!a.isEmpty(e)){var r=a.map(e,(function(e){return e.msg}));throw Error("Errors Detected in CST Visitor <"+o.functionName(this.constructor)+">:\n\t"+r.join("\n\n").replace(/\n/g,"\n\t"))}}}).constructor=r,r._RULE_NAMES=t,r},t.createBaseVisitorConstructorWithDefaults=function(e,t,r){var n=function(){};o.defineNameProp(n,e+"BaseSemanticsWithDefaults");var i=Object.create(r.prototype);return a.forEach(t,(function(e){i[e]=s})),(n.prototype=i).constructor=n,n},function(e){e[e.REDUNDANT_METHOD=0]="REDUNDANT_METHOD",e[e.MISSING_METHOD=1]="MISSING_METHOD"}(n=t.CstVisitorDefinitionError||(t.CstVisitorDefinitionError={})),t.validateVisitor=l,t.validateMissingCstMethods=c;var f=["constructor","visit","validateVisitor"];function d(e,t){var r=[];for(var s in e)i.validTermsPattern.test(s)&&a.isFunction(e[s])&&!a.contains(f,s)&&!a.contains(t,s)&&r.push({msg:"Redundant visitor method: <"+s+"> on "+o.functionName(e.constructor)+" CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\nFor utility methods on visitor classes use methods names that do not match /"+i.validTermsPattern.source+"/.",type:n.REDUNDANT_METHOD,methodName:s});return r}t.validateRedundantMethods=d},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(3),a=function(){function e(){}return e.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1},Object.defineProperty(e.prototype,"input",{get:function(){return this.tokVector},set:function(e){this.reset(),this.tokVector=e,this.tokVectorLength=e.length},enumerable:!0,configurable:!0}),e.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):n.END_OF_FILE},e.prototype.LA=function(e){return this.currIdx+e<0||this.tokVectorLength<=this.currIdx+e?n.END_OF_FILE:this.tokVector[this.currIdx+e]},e.prototype.consumeToken=function(){this.currIdx++},e.prototype.exportLexerState=function(){return this.currIdx},e.prototype.importLexerState=function(e){this.currIdx=e},e.prototype.resetLexerState=function(){this.currIdx=-1},e.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1},e.prototype.getLexerPosition=function(){return this.exportLexerState()},e}();t.LexerAdapter=a},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(6),o=r(3),i=r(10),s=r(23),l=r(11),c=r(1),f=function(){function e(){}return e.prototype.CONSUME=function(e,t){return this.consumeInternal(e,0,t)},e.prototype.CONSUME1=function(e,t){return this.consumeInternal(e,1,t)},e.prototype.CONSUME2=function(e,t){return this.consumeInternal(e,2,t)},e.prototype.CONSUME3=function(e,t){return this.consumeInternal(e,3,t)},e.prototype.CONSUME4=function(e,t){return this.consumeInternal(e,4,t)},e.prototype.CONSUME5=function(e,t){return this.consumeInternal(e,5,t)},e.prototype.CONSUME6=function(e,t){return this.consumeInternal(e,6,t)},e.prototype.CONSUME7=function(e,t){return this.consumeInternal(e,7,t)},e.prototype.CONSUME8=function(e,t){return this.consumeInternal(e,8,t)},e.prototype.CONSUME9=function(e,t){return this.consumeInternal(e,9,t)},e.prototype.SUBRULE=function(e,t){return this.subruleInternal(e,0,t)},e.prototype.SUBRULE1=function(e,t){return this.subruleInternal(e,1,t)},e.prototype.SUBRULE2=function(e,t){return this.subruleInternal(e,2,t)},e.prototype.SUBRULE3=function(e,t){return this.subruleInternal(e,3,t)},e.prototype.SUBRULE4=function(e,t){return this.subruleInternal(e,4,t)},e.prototype.SUBRULE5=function(e,t){return this.subruleInternal(e,5,t)},e.prototype.SUBRULE6=function(e,t){return this.subruleInternal(e,6,t)},e.prototype.SUBRULE7=function(e,t){return this.subruleInternal(e,7,t)},e.prototype.SUBRULE8=function(e,t){return this.subruleInternal(e,8,t)},e.prototype.SUBRULE9=function(e,t){return this.subruleInternal(e,9,t)},e.prototype.OPTION=function(e){return this.optionInternal(e,0)},e.prototype.OPTION1=function(e){return this.optionInternal(e,1)},e.prototype.OPTION2=function(e){return this.optionInternal(e,2)},e.prototype.OPTION3=function(e){return this.optionInternal(e,3)},e.prototype.OPTION4=function(e){return this.optionInternal(e,4)},e.prototype.OPTION5=function(e){return this.optionInternal(e,5)},e.prototype.OPTION6=function(e){return this.optionInternal(e,6)},e.prototype.OPTION7=function(e){return this.optionInternal(e,7)},e.prototype.OPTION8=function(e){return this.optionInternal(e,8)},e.prototype.OPTION9=function(e){return this.optionInternal(e,9)},e.prototype.OR=function(e){return this.orInternal(e,0)},e.prototype.OR1=function(e){return this.orInternal(e,1)},e.prototype.OR2=function(e){return this.orInternal(e,2)},e.prototype.OR3=function(e){return this.orInternal(e,3)},e.prototype.OR4=function(e){return this.orInternal(e,4)},e.prototype.OR5=function(e){return this.orInternal(e,5)},e.prototype.OR6=function(e){return this.orInternal(e,6)},e.prototype.OR7=function(e){return this.orInternal(e,7)},e.prototype.OR8=function(e){return this.orInternal(e,8)},e.prototype.OR9=function(e){return this.orInternal(e,9)},e.prototype.MANY=function(e){this.manyInternal(0,e)},e.prototype.MANY1=function(e){this.manyInternal(1,e)},e.prototype.MANY2=function(e){this.manyInternal(2,e)},e.prototype.MANY3=function(e){this.manyInternal(3,e)},e.prototype.MANY4=function(e){this.manyInternal(4,e)},e.prototype.MANY5=function(e){this.manyInternal(5,e)},e.prototype.MANY6=function(e){this.manyInternal(6,e)},e.prototype.MANY7=function(e){this.manyInternal(7,e)},e.prototype.MANY8=function(e){this.manyInternal(8,e)},e.prototype.MANY9=function(e){this.manyInternal(9,e)},e.prototype.MANY_SEP=function(e){this.manySepFirstInternal(0,e)},e.prototype.MANY_SEP1=function(e){this.manySepFirstInternal(1,e)},e.prototype.MANY_SEP2=function(e){this.manySepFirstInternal(2,e)},e.prototype.MANY_SEP3=function(e){this.manySepFirstInternal(3,e)},e.prototype.MANY_SEP4=function(e){this.manySepFirstInternal(4,e)},e.prototype.MANY_SEP5=function(e){this.manySepFirstInternal(5,e)},e.prototype.MANY_SEP6=function(e){this.manySepFirstInternal(6,e)},e.prototype.MANY_SEP7=function(e){this.manySepFirstInternal(7,e)},e.prototype.MANY_SEP8=function(e){this.manySepFirstInternal(8,e)},e.prototype.MANY_SEP9=function(e){this.manySepFirstInternal(9,e)},e.prototype.AT_LEAST_ONE=function(e){this.atLeastOneInternal(0,e)},e.prototype.AT_LEAST_ONE1=function(e){return this.atLeastOneInternal(1,e)},e.prototype.AT_LEAST_ONE2=function(e){this.atLeastOneInternal(2,e)},e.prototype.AT_LEAST_ONE3=function(e){this.atLeastOneInternal(3,e)},e.prototype.AT_LEAST_ONE4=function(e){this.atLeastOneInternal(4,e)},e.prototype.AT_LEAST_ONE5=function(e){this.atLeastOneInternal(5,e)},e.prototype.AT_LEAST_ONE6=function(e){this.atLeastOneInternal(6,e)},e.prototype.AT_LEAST_ONE7=function(e){this.atLeastOneInternal(7,e)},e.prototype.AT_LEAST_ONE8=function(e){this.atLeastOneInternal(8,e)},e.prototype.AT_LEAST_ONE9=function(e){this.atLeastOneInternal(9,e)},e.prototype.AT_LEAST_ONE_SEP=function(e){this.atLeastOneSepFirstInternal(0,e)},e.prototype.AT_LEAST_ONE_SEP1=function(e){this.atLeastOneSepFirstInternal(1,e)},e.prototype.AT_LEAST_ONE_SEP2=function(e){this.atLeastOneSepFirstInternal(2,e)},e.prototype.AT_LEAST_ONE_SEP3=function(e){this.atLeastOneSepFirstInternal(3,e)},e.prototype.AT_LEAST_ONE_SEP4=function(e){this.atLeastOneSepFirstInternal(4,e)},e.prototype.AT_LEAST_ONE_SEP5=function(e){this.atLeastOneSepFirstInternal(5,e)},e.prototype.AT_LEAST_ONE_SEP6=function(e){this.atLeastOneSepFirstInternal(6,e)},e.prototype.AT_LEAST_ONE_SEP7=function(e){this.atLeastOneSepFirstInternal(7,e)},e.prototype.AT_LEAST_ONE_SEP8=function(e){this.atLeastOneSepFirstInternal(8,e)},e.prototype.AT_LEAST_ONE_SEP9=function(e){this.atLeastOneSepFirstInternal(9,e)},e.prototype.RULE=function(e,t,r){if(void 0===r&&(r=o.DEFAULT_RULE_CONFIG),n.contains(this.definedRulesNames,e)){var a={message:i.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:e,grammarName:this.className}),type:o.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:e};this.definitionErrors.push(a)}if(this.definedRulesNames.push(e),!this.gastProductionsCache.containsKey(e)&&!this.serializedGrammar){var l=s.buildTopProduction(t.toString(),e,this.tokensMap);this.gastProductionsCache.put(e,l)}var c=this.defineRule(e,t,r);return this[e]=c,c},e.prototype.OVERRIDE_RULE=function(e,t,r){void 0===r&&(r=o.DEFAULT_RULE_CONFIG);var n=[];if(n=n.concat(l.validateRuleIsOverridden(e,this.definedRulesNames,this.className)),this.definitionErrors.push.apply(this.definitionErrors,n),!this.serializedGrammar){var a=s.buildTopProduction(t.toString(),e,this.tokensMap);this.gastProductionsCache.put(e,a)}var i=this.defineRule(e,t,r);return this[e]=i,i},e.prototype.BACKTRACK=function(e,t){return function(){this.isBackTrackingStack.push(1);var r=this.saveRecogState();try{return e.apply(this,t),!0}catch(e){if(a.isRecognitionException(e))return!1;throw e}finally{this.reloadRecogState(r),this.isBackTrackingStack.pop()}}},e.prototype.getGAstProductions=function(){return this.gastProductionsCache},e.prototype.getSerializedGastProductions=function(){return c.serializeGrammar(this.gastProductionsCache.values())},e}();t.RecognizerApi=f},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(9),o=r(6),i=r(12),s=r(13),l=r(3),c=r(25),f=r(2),d=r(7),u=r(4),p=function(){function e(){}return e.prototype.initRecognizerEngine=function(e,t){if(this.className=u.classNameFromInstance(this),this.shortRuleNameToFull=new u.HashTable,this.fullRuleNameToShort=new u.HashTable,this.ruleShortNameIdx=256,this.tokenMatcher=d.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.allRuleNames=[],this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache=new u.HashTable,this.serializedGrammar=n.has(t,"serializedGrammar")?t.serializedGrammar:l.DEFAULT_PARSER_CONFIG.serializedGrammar,n.isArray(e)){if(n.isEmpty(e))throw Error("A Token Vocabulary cannot be empty.\n\tNote that the first argument for the parser constructor\n\tis no longer a Token vector (since v4.0).");if("number"==typeof e[0].startOffset)throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n\tFor Further details.")}if(n.isArray(e))this.tokensMap=n.reduce(e,(function(e,t){return e[f.tokenName(t)]=t,e}),{});else if(n.has(e,"modes")&&n.every(n.flatten(n.values(e.modes)),d.isTokenType)){var r=n.flatten(n.values(e.modes)),a=n.uniq(r);this.tokensMap=n.reduce(a,(function(e,t){return e[f.tokenName(t)]=t,e}),{})}else{if(!n.isObject(e))throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");this.tokensMap=n.cloneObj(e)}this.tokensMap.EOF=f.EOF;var o=n.every(n.values(e),(function(e){return n.isEmpty(e.categoryMatches)}));this.tokenMatcher=o?d.tokenStructuredMatcherNoCategories:d.tokenStructuredMatcher,d.augmentTokenTypes(n.values(this.tokensMap))},e.prototype.defineRule=function(e,t,r){if(this.selfAnalysisDone)throw Error("Grammar rule <"+e+"> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");var i,s=n.has(r,"resyncEnabled")?r.resyncEnabled:l.DEFAULT_RULE_CONFIG.resyncEnabled,c=n.has(r,"recoveryValueFunc")?r.recoveryValueFunc:l.DEFAULT_RULE_CONFIG.recoveryValueFunc,f=this.ruleShortNameIdx<<a.BITS_FOR_METHOD_IDX+a.BITS_FOR_OCCURRENCE_IDX;return this.ruleShortNameIdx++,this.shortRuleNameToFull.put(f,e),this.fullRuleNameToShort.put(e,f),(i=function(r,n){return void 0===r&&(r=0),this.ruleInvocationStateUpdate(f,e,r),function(e){try{return!0===this.outputCst?(t.apply(this,e),this.CST_STACK[this.CST_STACK.length-1]):t.apply(this,e)}catch(e){var r=1===this.RULE_STACK.length,n=s&&!this.isBackTracking()&&this.recoveryEnabled;if(o.isRecognitionException(e)){if(n){var a,i=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(i))return e.resyncedTokens=this.reSyncTo(i),this.outputCst?((a=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,a):c();throw this.outputCst&&((a=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,e.partialCstResult=a),e}if(r)return this.moveToTerminatedState(),c();throw e}throw e}finally{this.ruleFinallyStateUpdate()}}.call(this,n)}).ruleName=e,i},e.prototype.optionInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.OPTION_IDX,t),n=this.nestedRuleBeforeClause(e,r);try{return this.optionInternalLogic(e,t,r)}finally{void 0!==n&&this.nestedRuleFinallyClause(r,n)}},e.prototype.optionInternalNoCst=function(e,t){var r=this.getKeyForAutomaticLookahead(a.OPTION_IDX,t);return this.optionInternalLogic(e,t,r)},e.prototype.optionInternalLogic=function(e,t,r){var n,a,o=this,i=this.getLookaheadFuncForOption(r,t);if(void 0!==e.DEF){if(n=e.DEF,void 0!==(a=e.GATE)){var s=i;i=function(){return a.call(o)&&s.call(o)}}}else n=e;if(!0===i.call(this))return n.call(this)},e.prototype.atLeastOneInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.AT_LEAST_ONE_IDX,e),n=this.nestedRuleBeforeClause(t,r);try{return this.atLeastOneInternalLogic(e,t,r)}finally{void 0!==n&&this.nestedRuleFinallyClause(r,n)}},e.prototype.atLeastOneInternalNoCst=function(e,t){var r=this.getKeyForAutomaticLookahead(a.AT_LEAST_ONE_IDX,e);this.atLeastOneInternalLogic(e,t,r)},e.prototype.atLeastOneInternalLogic=function(e,t,r){var n,o,l=this,c=this.getLookaheadFuncForAtLeastOne(r,e);if(void 0!==t.DEF){if(n=t.DEF,void 0!==(o=t.GATE)){var f=c;c=function(){return o.call(l)&&f.call(l)}}}else n=t;if(!0!==c.call(this))throw this.raiseEarlyExitException(e,i.PROD_TYPE.REPETITION_MANDATORY,t.ERR_MSG);for(var d=this.doSingleRepetition(n);!0===c.call(this)&&!0===d;)d=this.doSingleRepetition(n);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[e,t],c,a.AT_LEAST_ONE_IDX,e,s.NextTerminalAfterAtLeastOneWalker)},e.prototype.atLeastOneSepFirstInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.AT_LEAST_ONE_SEP_IDX,e),n=this.nestedRuleBeforeClause(t,r);try{this.atLeastOneSepFirstInternalLogic(e,t,r)}finally{void 0!==n&&this.nestedRuleFinallyClause(r,n)}},e.prototype.atLeastOneSepFirstInternalNoCst=function(e,t){var r=this.getKeyForAutomaticLookahead(a.AT_LEAST_ONE_SEP_IDX,e);this.atLeastOneSepFirstInternalLogic(e,t,r)},e.prototype.atLeastOneSepFirstInternalLogic=function(e,t,r){var n=this,o=t.DEF,l=t.SEP;if(!0!==this.getLookaheadFuncForAtLeastOneSep(r,e).call(this))throw this.raiseEarlyExitException(e,i.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,t.ERR_MSG);o.call(this);for(var c=function(){return n.tokenMatcher(n.LA(1),l)};!0===this.tokenMatcher(this.LA(1),l);)this.CONSUME(l),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,l,c,o,s.NextTerminalAfterAtLeastOneSepWalker],c,a.AT_LEAST_ONE_SEP_IDX,e,s.NextTerminalAfterAtLeastOneSepWalker)},e.prototype.manyInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.MANY_IDX,e),n=this.nestedRuleBeforeClause(t,r);try{return this.manyInternalLogic(e,t,r)}finally{void 0!==n&&this.nestedRuleFinallyClause(r,n)}},e.prototype.manyInternalNoCst=function(e,t){var r=this.getKeyForAutomaticLookahead(a.MANY_IDX,e);return this.manyInternalLogic(e,t,r)},e.prototype.manyInternalLogic=function(e,t,r){var n,o,i=this,l=this.getLookaheadFuncForMany(r,e);if(void 0!==t.DEF){if(n=t.DEF,void 0!==(o=t.GATE)){var c=l;l=function(){return o.call(i)&&c.call(i)}}}else n=t;for(var f=!0;!0===l.call(this)&&!0===f;)f=this.doSingleRepetition(n);this.attemptInRepetitionRecovery(this.manyInternal,[e,t],l,a.MANY_IDX,e,s.NextTerminalAfterManyWalker)},e.prototype.manySepFirstInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.MANY_SEP_IDX,e),n=this.nestedRuleBeforeClause(t,r);try{this.manySepFirstInternalLogic(e,t,r)}finally{void 0!==n&&this.nestedRuleFinallyClause(r,n)}},e.prototype.manySepFirstInternalNoCst=function(e,t){var r=this.getKeyForAutomaticLookahead(a.MANY_SEP_IDX,e);this.manySepFirstInternalLogic(e,t,r)},e.prototype.manySepFirstInternalLogic=function(e,t,r){var n=this,o=t.DEF,i=t.SEP;if(!0===this.getLookaheadFuncForManySep(r,e).call(this)){o.call(this);for(var l=function(){return n.tokenMatcher(n.LA(1),i)};!0===this.tokenMatcher(this.LA(1),i);)this.CONSUME(i),o.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,i,l,o,s.NextTerminalAfterManySepWalker],l,a.MANY_SEP_IDX,e,s.NextTerminalAfterManySepWalker)}},e.prototype.repetitionSepSecondInternal=function(e,t,r,n,o){for(;r();)this.CONSUME(t),n.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,t,r,n,o],r,a.AT_LEAST_ONE_SEP_IDX,e,o)},e.prototype.doSingleRepetition=function(e){var t=this.getLexerPosition();return e.call(this),this.getLexerPosition()>t},e.prototype.orInternalNoCst=function(e,t){var r=n.isArray(e)?e:e.DEF,a=this.getLookaheadFuncForOr(t,r).call(this,r);if(void 0!==a)return r[a].ALT.call(this);this.raiseNoAltException(t,e.ERR_MSG)},e.prototype.orInternal=function(e,t){var r=this.getKeyForAutomaticLookahead(a.OR_IDX,t),o=this.nestedRuleBeforeClause(e,r);try{var i=n.isArray(e)?e:e.DEF,s=this.getLookaheadFuncForOr(t,i).call(this,i);if(void 0!==s){var l=i[s],c=this.nestedAltBeforeClause(l,t,a.OR_IDX,s);try{return l.ALT.call(this)}finally{void 0!==c&&this.nestedRuleFinallyClause(c.shortName,c.nestedName)}}this.raiseNoAltException(t,e.ERR_MSG)}finally{void 0!==o&&this.nestedRuleFinallyClause(r,o)}},e.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),0===this.RULE_STACK.length&&!this.isAtEndOfInput()){var e=this.LA(1),t=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:e,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new o.NotAllInputParsedException(t,e))}},e.prototype.subruleInternal=function(e,t,r){var n;try{var a=void 0!==r?r.ARGS:void 0;return n=e.call(this,t,a),this.cstPostNonTerminal(n,void 0!==r&&void 0!==r.LABEL?r.LABEL:e.ruleName),n}catch(t){throw o.isRecognitionException(t)&&void 0!==t.partialCstResult&&(this.cstPostNonTerminal(t.partialCstResult,void 0!==r&&void 0!==r.LABEL?r.LABEL:e.ruleName),delete t.partialCstResult),t}},e.prototype.consumeInternal=function(e,t,r){var n;try{var a=this.LA(1);if(!0!==this.tokenMatcher(a,e)){var i,s=this.LA(0);throw i=void 0!==r&&r.ERR_MSG?r.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:e,actual:a,previous:s,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new o.MismatchedTokenException(i,a,s))}this.consumeToken(),n=a}catch(r){if(!this.recoveryEnabled||"MismatchedTokenException"!==r.name||this.isBackTracking())throw r;var l=this.getFollowsForInRuleRecovery(e,t);try{n=this.tryInRuleRecovery(e,l)}catch(e){throw e.name===c.IN_RULE_RECOVERY_EXCEPTION?r:e}}return this.cstPostTerminal(void 0!==r&&void 0!==r.LABEL?r.LABEL:e.tokenName,n),n},e.prototype.saveRecogState=function(){var e=this.errors,t=n.cloneArr(this.RULE_STACK);return{errors:e,lexerState:this.exportLexerState(),RULE_STACK:t,CST_STACK:this.CST_STACK,LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK}},e.prototype.reloadRecogState=function(e){this.errors=e.errors,this.importLexerState(e.lexerState),this.RULE_STACK=e.RULE_STACK},e.prototype.ruleInvocationStateUpdate=function(e,t,r){this.RULE_OCCURRENCE_STACK.push(r),this.RULE_STACK.push(e),this.cstInvocationStateUpdate(t,e)},e.prototype.isBackTracking=function(){return!n.isEmpty(this.isBackTrackingStack)},e.prototype.getCurrRuleFullName=function(){var e=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull.get(e)},e.prototype.shortRuleNameToFullName=function(e){return this.shortRuleNameToFull.get(e)},e.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),f.EOF)},e.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[]},e}();t.RecognizerEngine=p},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(6),a=r(0),o=r(12),i=r(3),s=function(){function e(){}return e.prototype.initErrorHandler=function(e){this._errors=[],this.errorMessageProvider=a.defaults(e.errorMessageProvider,i.DEFAULT_PARSER_CONFIG.errorMessageProvider)},e.prototype.SAVE_ERROR=function(e){if(n.isRecognitionException(e))return e.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:a.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(e),e;throw Error("Trying to save an Error which is not a RecognitionException")},Object.defineProperty(e.prototype,"errors",{get:function(){return a.cloneArr(this._errors)},set:function(e){this._errors=e},enumerable:!0,configurable:!0}),e.prototype.raiseEarlyExitException=function(e,t,r){for(var a=this.getCurrRuleFullName(),i=this.getGAstProductions().get(a),s=o.getLookaheadPathsForOptionalProd(e,i,t,this.maxLookahead)[0],l=[],c=1;c<this.maxLookahead;c++)l.push(this.LA(c));var f=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:l,previous:this.LA(0),customUserDescription:r,ruleName:a});throw this.SAVE_ERROR(new n.EarlyExitException(f,this.LA(1),this.LA(0)))},e.prototype.raiseNoAltException=function(e,t){for(var r=this.getCurrRuleFullName(),a=this.getGAstProductions().get(r),i=o.getLookaheadPathsForOr(e,a,this.maxLookahead),s=[],l=1;l<=this.maxLookahead;l++)s.push(this.LA(l));var c=this.LA(0),f=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:i,actual:s,previous:c,customUserDescription:t,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new n.NoViableAltException(f,this.LA(1),c))},e}();t.ErrorHandler=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(13),a=r(0),o=function(){function e(){}return e.prototype.initContentAssist=function(){},e.prototype.computeContentAssist=function(e,t){var r=this.gastProductionsCache.get(e);if(a.isUndefined(r))throw Error("Rule ->"+e+"<- does not exist in this grammar.");return n.nextPossibleTokensAfter([r],t,this.tokenMatcher,this.maxLookahead)},e.prototype.getNextPossibleTokenTypes=function(e){var t=a.first(e.ruleStack),r=this.getGAstProductions().get(t);return new n.NextAfterTokenWalker(r,e).startWalking()},e}();t.ContentAssist=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(17);t.createSyntaxDiagramsCode=function(e,t){var r=void 0===t?{}:t,a=r.resourceBase,o=void 0===a?"https://unpkg.com/chevrotain@"+n.VERSION+"/diagrams/":a,i=r.css;return"\n\x3c!-- This is a generated file --\x3e\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n\n<link rel='stylesheet' href='"+(void 0===i?"https://unpkg.com/chevrotain@"+n.VERSION+"/diagrams/diagrams.css":i)+"'>\n\n<script src='"+o+"vendor/railroad-diagrams.js'><\/script>\n<script src='"+o+"src/diagrams_builder.js'><\/script>\n<script src='"+o+"src/diagrams_behavior.js'><\/script>\n<script src='"+o+'src/main.js\'><\/script>\n\n<div id="diagrams" align="center"></div>    \n\n<script>\n    window.serializedGrammar = '+JSON.stringify(e,null,"  ")+';\n<\/script>\n\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n'}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(41);t.generateParserFactory=function(e){var t=n.genWrapperFunction({name:e.name,rules:e.rules}),a=new Function("tokenVocabulary","config","chevrotain",t);return function(t){return a(e.tokenVocabulary,t,r(18))}},t.generateParserModule=function(e){return n.genUmdModule({name:e.name,rules:e.rules})}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),a=r(2),o=r(1),i="\n";function s(e){return"\nfunction "+e.name+"(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    "+l(e.rules)+"\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n"+e.name+".prototype = Object.create(chevrotain.CstParser.prototype)\n"+e.name+".prototype.constructor = "+e.name+"    \n    "}function l(e){return n.map(e,(function(e){return c(e,1)})).join("\n")}function c(e,t){var r=x(t,'$.RULE("'+e.name+'", function() {')+i;return(r+=m(e.definition,t+1))+(x(t+1,"})")+i)}function f(e,t){var r=a.tokenName(e.terminalType);return x(t,"$.CONSUME"+e.idx+"(this.tokensMap."+r+")"+i)}function d(e,t){return x(t,"$.SUBRULE"+e.idx+"($."+e.nonTerminalName+")"+i)}function u(e,t){var r=x(t,"$.OR"+e.idx+"([")+i;return(r+=n.map(e.definition,(function(e){return p(e,t+1)})).join(",\n"))+(i+x(t,"])\n"))}function p(e,t){var r=x(t,"{")+i;return e.name&&(r+=x(t+1,'NAME: "'+e.name+'",')+i),r+=x(t+1,"ALT: function() {")+i,r+=m(e.definition,t+1),(r+=x(t+1,"}")+i)+x(t,"}")}function h(e,t,r){var n=x(r,"$."+(e+t.idx)+"(");return t.name||t.separator?(n+="{\n",t.name&&(n+=x(r+1,'NAME: "'+t.name+'"')+","+i),t.separator&&(n+=x(r+1,"SEP: this.tokensMap."+a.tokenName(t.separator))+","+i),n+="DEF: "+v(t.definition,r+2)+i,n+=x(r,"}")+i):n+=v(t.definition,r+1),n+(x(r,")")+i)}function v(e,t){var r="function() {\n";return(r+=m(e,t))+(x(t,"}")+i)}function m(e,t){var r="";return n.forEach(e,(function(e){r+=function(e,t){if(e instanceof o.NonTerminal)return d(e,t);if(e instanceof o.Option)return h("OPTION",e,t);if(e instanceof o.RepetitionMandatory)return h("AT_LEAST_ONE",e,t);if(e instanceof o.RepetitionMandatoryWithSeparator)return h("AT_LEAST_ONE_SEP",e,t);if(e instanceof o.RepetitionWithSeparator)return h("MANY_SEP",e,t);if(e instanceof o.Repetition)return h("MANY",e,t);if(e instanceof o.Alternation)return u(e,t);if(e instanceof o.Terminal)return f(e,t);if(e instanceof o.Flat)return m(e.definition,t);throw Error("non exhaustive match")}(e,t+1)})),r}function x(e,t){return Array(4*e+1).join(" ")+t}t.genUmdModule=function(e){return"\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n"+s(e)+"\n    \nreturn {\n    "+e.name+": "+e.name+" \n}\n}));\n"},t.genWrapperFunction=function(e){return"    \n"+s(e)+"\nreturn new "+e.name+"(tokenVocabulary, config)    \n"},t.genClass=s,t.genAllRules=l,t.genRule=c,t.genTerminal=f,t.genNonTerminal=d,t.genAlternation=u,t.genSingleAlt=p}])},function(e,t){(function(){"use strict";var e=void 0,t=this;function r(r,n){var a,o=r.split("."),i=t;!(o[0]in i)&&i.execScript&&i.execScript("var "+o[0]);for(;o.length&&(a=o.shift());)o.length||n===e?i=i[a]?i[a]:i[a]={}:i[a]=n}var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;function a(e){var t,r,a,o,i,s,l,c,f,d,u=e.length,p=0,h=Number.POSITIVE_INFINITY;for(c=0;c<u;++c)e[c]>p&&(p=e[c]),e[c]<h&&(h=e[c]);for(t=1<<p,r=new(n?Uint32Array:Array)(t),a=1,o=0,i=2;a<=p;){for(c=0;c<u;++c)if(e[c]===a){for(s=0,l=o,f=0;f<a;++f)s=s<<1|1&l,l>>=1;for(d=a<<16|c,f=s;f<t;f+=i)r[f]=d;++o}++a,o<<=1,i<<=1}return[r,p,h]}function o(e,t){switch(this.g=[],this.h=32768,this.d=this.f=this.a=this.l=0,this.input=n?new Uint8Array(e):e,this.m=!1,this.i=s,this.r=!1,!t&&(t={})||(t.index&&(this.a=t.index),t.bufferSize&&(this.h=t.bufferSize),t.bufferType&&(this.i=t.bufferType),t.resize&&(this.r=t.resize)),this.i){case i:this.b=32768,this.c=new(n?Uint8Array:Array)(32768+this.h+258);break;case s:this.b=0,this.c=new(n?Uint8Array:Array)(this.h),this.e=this.z,this.n=this.v,this.j=this.w;break;default:throw Error("invalid inflate mode")}}var i=0,s=1,l={t:i,s:s};o.prototype.k=function(){for(;!this.m;){var t=A(this,3);switch(1&t&&(this.m=!0),t>>>=1){case 0:var r=this.input,o=this.a,l=this.c,c=this.b,f=r.length,d=e,p=l.length,h=e;if(this.d=this.f=0,o+1>=f)throw Error("invalid uncompressed block header: LEN");if(d=r[o++]|r[o++]<<8,o+1>=f)throw Error("invalid uncompressed block header: NLEN");if(d===~(r[o++]|r[o++]<<8))throw Error("invalid uncompressed block header: length verify");if(o+d>r.length)throw Error("input buffer is broken");switch(this.i){case i:for(;c+d>l.length;){if(d-=h=p-c,n)l.set(r.subarray(o,o+h),c),c+=h,o+=h;else for(;h--;)l[c++]=r[o++];this.b=c,l=this.e(),c=this.b}break;case s:for(;c+d>l.length;)l=this.e({p:2});break;default:throw Error("invalid inflate mode")}if(n)l.set(r.subarray(o,o+d),c),c+=d,o+=d;else for(;d--;)l[c++]=r[o++];this.a=o,this.b=c,this.c=l;break;case 1:this.j(_,R);break;case 2:var v,m,x,g,y=A(this,5)+257,E=A(this,5)+1,w=A(this,4)+4,b=new(n?Uint8Array:Array)(u.length),T=e,S=e,C=e,L=e,H=e;for(H=0;H<w;++H)b[u[H]]=A(this,3);if(!n)for(H=w,w=b.length;H<w;++H)b[u[H]]=0;for(v=a(b),T=new(n?Uint8Array:Array)(y+E),H=0,g=y+E;H<g;)switch(S=M(this,v),S){case 16:for(L=3+A(this,2);L--;)T[H++]=C;break;case 17:for(L=3+A(this,3);L--;)T[H++]=0;C=0;break;case 18:for(L=11+A(this,7);L--;)T[H++]=0;C=0;break;default:C=T[H++]=S}m=a(n?T.subarray(0,y):T.slice(0,y)),x=a(n?T.subarray(y):T.slice(y)),this.j(m,x);break;default:throw Error("unknown BTYPE: "+t)}}return this.n()};var c,f,d=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],u=n?new Uint16Array(d):d,p=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],h=n?new Uint16Array(p):p,v=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],m=n?new Uint8Array(v):v,x=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],g=n?new Uint16Array(x):x,y=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],E=n?new Uint8Array(y):y,w=new(n?Uint8Array:Array)(288);for(c=0,f=w.length;c<f;++c)w[c]=143>=c?8:255>=c?9:279>=c?7:8;var b,T,_=a(w),S=new(n?Uint8Array:Array)(30);for(b=0,T=S.length;b<T;++b)S[b]=5;var R=a(S);function A(e,t){for(var r,n=e.f,a=e.d,o=e.input,i=e.a,s=o.length;a<t;){if(i>=s)throw Error("input buffer is broken");n|=o[i++]<<a,a+=8}return r=n&(1<<t)-1,e.f=n>>>t,e.d=a-t,e.a=i,r}function M(e,t){for(var r,n,a=e.f,o=e.d,i=e.input,s=e.a,l=i.length,c=t[0],f=t[1];o<f&&!(s>=l);)a|=i[s++]<<o,o+=8;if((n=(r=c[a&(1<<f)-1])>>>16)>o)throw Error("invalid code length: "+n);return e.f=a>>n,e.d=o-n,e.a=s,65535&r}function C(e,t){var r,n;switch(this.input=e,this.a=0,!t&&(t={})||(t.index&&(this.a=t.index),t.verify&&(this.A=t.verify)),r=e[this.a++],n=e[this.a++],15&r){case L:this.method=L;break;default:throw Error("unsupported compression method")}if(0!=((r<<8)+n)%31)throw Error("invalid fcheck flag:"+((r<<8)+n)%31);if(32&n)throw Error("fdict flag is not supported");this.q=new o(e,{index:this.a,bufferSize:t.bufferSize,bufferType:t.bufferType,resize:t.resize})}o.prototype.j=function(e,t){var r=this.c,n=this.b;this.o=e;for(var a,o,i,s,l=r.length-258;256!==(a=M(this,e));)if(256>a)n>=l&&(this.b=n,r=this.e(),n=this.b),r[n++]=a;else for(s=h[o=a-257],0<m[o]&&(s+=A(this,m[o])),a=M(this,t),i=g[a],0<E[a]&&(i+=A(this,E[a])),n>=l&&(this.b=n,r=this.e(),n=this.b);s--;)r[n]=r[n++-i];for(;8<=this.d;)this.d-=8,this.a--;this.b=n},o.prototype.w=function(e,t){var r=this.c,n=this.b;this.o=e;for(var a,o,i,s,l=r.length;256!==(a=M(this,e));)if(256>a)n>=l&&(l=(r=this.e()).length),r[n++]=a;else for(s=h[o=a-257],0<m[o]&&(s+=A(this,m[o])),a=M(this,t),i=g[a],0<E[a]&&(i+=A(this,E[a])),n+s>l&&(l=(r=this.e()).length);s--;)r[n]=r[n++-i];for(;8<=this.d;)this.d-=8,this.a--;this.b=n},o.prototype.e=function(){var e,t,r=new(n?Uint8Array:Array)(this.b-32768),a=this.b-32768,o=this.c;if(n)r.set(o.subarray(32768,r.length));else for(e=0,t=r.length;e<t;++e)r[e]=o[e+32768];if(this.g.push(r),this.l+=r.length,n)o.set(o.subarray(a,a+32768));else for(e=0;32768>e;++e)o[e]=o[a+e];return this.b=32768,o},o.prototype.z=function(e){var t,r,a,o=this.input.length/this.a+1|0,i=this.input,s=this.c;return e&&("number"==typeof e.p&&(o=e.p),"number"==typeof e.u&&(o+=e.u)),2>o?r=(a=(i.length-this.a)/this.o[2]/2*258|0)<s.length?s.length+a:s.length<<1:r=s.length*o,n?(t=new Uint8Array(r)).set(s):t=s,this.c=t},o.prototype.n=function(){var e,t,r,a,o,i=0,s=this.c,l=this.g,c=new(n?Uint8Array:Array)(this.l+(this.b-32768));if(0===l.length)return n?this.c.subarray(32768,this.b):this.c.slice(32768,this.b);for(t=0,r=l.length;t<r;++t)for(a=0,o=(e=l[t]).length;a<o;++a)c[i++]=e[a];for(t=32768,r=this.b;t<r;++t)c[i++]=s[t];return this.g=[],this.buffer=c},o.prototype.v=function(){var e,t=this.b;return n?this.r?(e=new Uint8Array(t)).set(this.c.subarray(0,t)):e=this.c.subarray(0,t):(this.c.length>t&&(this.c.length=t),e=this.c),this.buffer=e},C.prototype.k=function(){var e,t,r=this.input;if(e=this.q.k(),this.a=this.q.a,this.A){t=(r[this.a++]<<24|r[this.a++]<<16|r[this.a++]<<8|r[this.a++])>>>0;var n=e;if("string"==typeof n){var a,o,i=n.split("");for(a=0,o=i.length;a<o;a++)i[a]=(255&i[a].charCodeAt(0))>>>0;n=i}for(var s,l=1,c=0,f=n.length,d=0;0<f;){f-=s=1024<f?1024:f;do{c+=l+=n[d++]}while(--s);l%=65521,c%=65521}if(t!==(c<<16|l)>>>0)throw Error("invalid adler-32 checksum")}return e};var L=8;r("Zlib.Inflate",C),r("Zlib.Inflate.prototype.decompress",C.prototype.k);var H,P,z,k,N={ADAPTIVE:l.s,BLOCK:l.t};if(Object.keys)H=Object.keys(N);else for(P in H=[],z=0,N)H[z++]=P;for(z=0,k=H.length;z<k;++z)r("Zlib.Inflate.BufferType."+(P=H[z]),N[P])}).call(this)},function(e,t,r){!function(e){"use strict";function t(){}void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Number.isInteger&&(Number.isInteger=function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e}),void 0===Math.sign&&(Math.sign=function(e){return e<0?-1:e>0?1:+e}),"name"in Function.prototype==0&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]}}),void 0===Object.assign&&(Object.assign=function(e){if(null==e)throw new TypeError("Cannot convert undefined or null to object");for(var t=Object(e),r=1;r<arguments.length;r++){var n=arguments[r];if(null!=n)for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(t[a]=n[a])}return t}),Object.assign(t.prototype,{addEventListener:function(e,t){void 0===this._listeners&&(this._listeners={});var r=this._listeners;void 0===r[e]&&(r[e]=[]),-1===r[e].indexOf(t)&&r[e].push(t)},hasEventListener:function(e,t){if(void 0===this._listeners)return!1;var r=this._listeners;return void 0!==r[e]&&-1!==r[e].indexOf(t)},removeEventListener:function(e,t){if(void 0!==this._listeners){var r=this._listeners[e];if(void 0!==r){var n=r.indexOf(t);-1!==n&&r.splice(n,1)}}},dispatchEvent:function(e){if(void 0!==this._listeners){var t=this._listeners[e.type];if(void 0!==t){e.target=this;for(var r=t.slice(0),n=0,a=r.length;n<a;n++)r[n].call(this,e)}}}});for(var r=[],n=0;n<256;n++)r[n]=(n<16?"0":"")+n.toString(16);var a,o=1234567,i={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){var e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,a=4294967295*Math.random()|0;return(r[255&e]+r[e>>8&255]+r[e>>16&255]+r[e>>24&255]+"-"+r[255&t]+r[t>>8&255]+"-"+r[t>>16&15|64]+r[t>>24&255]+"-"+r[63&n|128]+r[n>>8&255]+"-"+r[n>>16&255]+r[n>>24&255]+r[255&a]+r[a>>8&255]+r[a>>16&255]+r[a>>24&255]).toUpperCase()},clamp:function(e,t,r){return Math.max(t,Math.min(r,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,r,n,a){return n+(e-t)*(a-n)/(r-t)},lerp:function(e,t,r){return(1-r)*e+r*t},smoothstep:function(e,t,r){return e<=t?0:e>=r?1:(e=(e-t)/(r-t))*e*(3-2*e)},smootherstep:function(e,t,r){return e<=t?0:e>=r?1:(e=(e-t)/(r-t))*e*e*(e*(6*e-15)+10)},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return void 0!==e&&(o=e%2147483647),((o=16807*o%2147483647)-1)/2147483646},degToRad:function(e){return e*i.DEG2RAD},radToDeg:function(e){return e*i.RAD2DEG},isPowerOfTwo:function(e){return 0==(e&e-1)&&0!==e},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,r,n,a){var o=Math.cos,i=Math.sin,s=o(r/2),l=i(r/2),c=o((t+n)/2),f=i((t+n)/2),d=o((t-n)/2),u=i((t-n)/2),p=o((n-t)/2),h=i((n-t)/2);switch(a){case"XYX":e.set(s*f,l*d,l*u,s*c);break;case"YZY":e.set(l*u,s*f,l*d,s*c);break;case"ZXZ":e.set(l*d,l*u,s*f,s*c);break;case"XZX":e.set(s*f,l*h,l*p,s*c);break;case"YXY":e.set(l*p,s*f,l*h,s*c);break;case"ZYZ":e.set(l*h,l*p,s*f,s*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+a)}}};function s(e,t){void 0===e&&(e=0),void 0===t&&(t=0),this.x=e,this.y=t}function l(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}Object.defineProperties(s.prototype,{width:{get:function(){return this.x},set:function(e){this.x=e}},height:{get:function(){return this.y},set:function(e){this.y=e}}}),Object.assign(s.prototype,{isVector2:!0,set:function(e,t){return this.x=e,this.y=t,this},setScalar:function(e){return this.x=e,this.y=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(e){return this.x=e.x,this.y=e.y,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)},addScalar:function(e){return this.x+=e,this.y+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)},subScalar:function(e){return this.x-=e,this.y-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this},multiply:function(e){return this.x*=e.x,this.y*=e.y,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this},divide:function(e){return this.x/=e.x,this.y/=e.y,this},divideScalar:function(e){return this.multiplyScalar(1/e)},applyMatrix3:function(e){var t=this.x,r=this.y,n=e.elements;return this.x=n[0]*t+n[3]*r+n[6],this.y=n[1]*t+n[4]*r+n[7],this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this},clampLength:function(e,t){var r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this},negate:function(){return this.x=-this.x,this.y=-this.y,this},dot:function(e){return this.x*e.x+this.y*e.y},cross:function(e){return this.x*e.y-this.y*e.x},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length()||1)},angle:function(){return Math.atan2(-this.y,-this.x)+Math.PI},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){var t=this.x-e.x,r=this.y-e.y;return t*t+r*r},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this},lerpVectors:function(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this},equals:function(e){return e.x===this.x&&e.y===this.y},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e},fromBufferAttribute:function(e,t,r){return void 0!==r&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this},rotateAround:function(e,t){var r=Math.cos(t),n=Math.sin(t),a=this.x-e.x,o=this.y-e.y;return this.x=a*r-o*n+e.x,this.y=a*n+o*r+e.y,this},random:function(){return this.x=Math.random(),this.y=Math.random(),this}}),Object.assign(l.prototype,{isMatrix3:!0,set:function(e,t,r,n,a,o,i,s,l){var c=this.elements;return c[0]=e,c[1]=n,c[2]=i,c[3]=t,c[4]=a,c[5]=s,c[6]=r,c[7]=o,c[8]=l,this},identity:function(){return this.set(1,0,0,0,1,0,0,0,1),this},clone:function(){return(new this.constructor).fromArray(this.elements)},copy:function(e){var t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this},extractBasis:function(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this},setFromMatrix4:function(e){var t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this},multiply:function(e){return this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,t){var r=e.elements,n=t.elements,a=this.elements,o=r[0],i=r[3],s=r[6],l=r[1],c=r[4],f=r[7],d=r[2],u=r[5],p=r[8],h=n[0],v=n[3],m=n[6],x=n[1],g=n[4],y=n[7],E=n[2],w=n[5],b=n[8];return a[0]=o*h+i*x+s*E,a[3]=o*v+i*g+s*w,a[6]=o*m+i*y+s*b,a[1]=l*h+c*x+f*E,a[4]=l*v+c*g+f*w,a[7]=l*m+c*y+f*b,a[2]=d*h+u*x+p*E,a[5]=d*v+u*g+p*w,a[8]=d*m+u*y+p*b,this},multiplyScalar:function(e){var t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this},determinant:function(){var e=this.elements,t=e[0],r=e[1],n=e[2],a=e[3],o=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*o*c-t*i*l-r*a*c+r*i*s+n*a*l-n*o*s},getInverse:function(e,t){void 0!==t&&console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");var r=e.elements,n=this.elements,a=r[0],o=r[1],i=r[2],s=r[3],l=r[4],c=r[5],f=r[6],d=r[7],u=r[8],p=u*l-c*d,h=c*f-u*s,v=d*s-l*f,m=a*p+o*h+i*v;if(0===m)return this.set(0,0,0,0,0,0,0,0,0);var x=1/m;return n[0]=p*x,n[1]=(i*d-u*o)*x,n[2]=(c*o-i*l)*x,n[3]=h*x,n[4]=(u*a-i*f)*x,n[5]=(i*s-c*a)*x,n[6]=v*x,n[7]=(o*f-d*a)*x,n[8]=(l*a-o*s)*x,this},transpose:function(){var e,t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this},getNormalMatrix:function(e){return this.setFromMatrix4(e).getInverse(this).transpose()},transposeIntoArray:function(e){var t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this},setUvTransform:function(e,t,r,n,a,o,i){var s=Math.cos(a),l=Math.sin(a);this.set(r*s,r*l,-r*(s*o+l*i)+o+e,-n*l,n*s,-n*(-l*o+s*i)+i+t,0,0,1)},scale:function(e,t){var r=this.elements;return r[0]*=e,r[3]*=e,r[6]*=e,r[1]*=t,r[4]*=t,r[7]*=t,this},rotate:function(e){var t=Math.cos(e),r=Math.sin(e),n=this.elements,a=n[0],o=n[3],i=n[6],s=n[1],l=n[4],c=n[7];return n[0]=t*a+r*s,n[3]=t*o+r*l,n[6]=t*i+r*c,n[1]=-r*a+t*s,n[4]=-r*o+t*l,n[7]=-r*i+t*c,this},translate:function(e,t){var r=this.elements;return r[0]+=e*r[2],r[3]+=e*r[5],r[6]+=e*r[8],r[1]+=t*r[2],r[4]+=t*r[5],r[7]+=t*r[8],this},equals:function(e){for(var t=this.elements,r=e.elements,n=0;n<9;n++)if(t[n]!==r[n])return!1;return!0},fromArray:function(e,t){void 0===t&&(t=0);for(var r=0;r<9;r++)this.elements[r]=e[r+t];return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);var r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}});var c={getDataURL:function(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;var t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===a&&(a=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),a.width=e.width,a.height=e.height;var r=a.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),t=a}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}},f=0;function d(e,t,r,n,a,o,c,u,p,h){Object.defineProperty(this,"id",{value:f++}),this.uuid=i.generateUUID(),this.name="",this.image=void 0!==e?e:d.DEFAULT_IMAGE,this.mipmaps=[],this.mapping=void 0!==t?t:d.DEFAULT_MAPPING,this.wrapS=void 0!==r?r:1001,this.wrapT=void 0!==n?n:1001,this.magFilter=void 0!==a?a:1006,this.minFilter=void 0!==o?o:1008,this.anisotropy=void 0!==p?p:1,this.format=void 0!==c?c:1023,this.internalFormat=null,this.type=void 0!==u?u:1009,this.offset=new s(0,0),this.repeat=new s(1,1),this.center=new s(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new l,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=void 0!==h?h:3e3,this.version=0,this.onUpdate=null}function u(e,t,r,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),void 0===n&&(n=1),this.x=e,this.y=t,this.z=r,this.w=n}function p(e,t,r){this.width=e,this.height=t,this.scissor=new u(0,0,e,t),this.scissorTest=!1,this.viewport=new u(0,0,e,t),r=r||{},this.texture=new d(void 0,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=void 0!==r.generateMipmaps&&r.generateMipmaps,this.texture.minFilter=void 0!==r.minFilter?r.minFilter:1006,this.depthBuffer=void 0===r.depthBuffer||r.depthBuffer,this.stencilBuffer=void 0===r.stencilBuffer||r.stencilBuffer,this.depthTexture=void 0!==r.depthTexture?r.depthTexture:null}function h(e,t,r){p.call(this,e,t,r),this.samples=4}function v(e,t,r,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),void 0===n&&(n=1),this._x=e,this._y=t,this._z=r,this._w=n}d.DEFAULT_IMAGE=void 0,d.DEFAULT_MAPPING=300,d.prototype=Object.assign(Object.create(t.prototype),{constructor:d,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){var t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];var r={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){var n=this.image;if(this.isDataTexture&&(n=document.createElement("canvas").getContext("2d").getImageData(0,0,n.width,n.height)),void 0===n.uuid&&(n.uuid=i.generateUUID()),!t&&void 0===e.images[n.uuid]){var a;if(Array.isArray(n)){a=[];for(var o=0,s=n.length;o<s;o++)a.push(c.getDataURL(n[o]))}else a=c.getDataURL(n);e.images[n.uuid]={uuid:n.uuid,url:a}}r.image=n.uuid}return t||(e.textures[this.uuid]=r),r},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(300!==this.mapping)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case 1e3:e.x=e.x-Math.floor(e.x);break;case 1001:e.x=e.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case 1e3:e.y=e.y-Math.floor(e.y);break;case 1001:e.y=e.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}}),Object.defineProperty(d.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.defineProperties(u.prototype,{width:{get:function(){return this.z},set:function(e){this.z=e}},height:{get:function(){return this.w},set:function(e){this.w=e}}}),Object.assign(u.prototype,{isVector4:!0,set:function(e,t,r,n){return this.x=e,this.y=t,this.z=r,this.w=n,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this.w=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setW:function(e){return this.w=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this},applyMatrix4:function(e){var t=this.x,r=this.y,n=this.z,a=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*n+o[12]*a,this.y=o[1]*t+o[5]*r+o[9]*n+o[13]*a,this.z=o[2]*t+o[6]*r+o[10]*n+o[14]*a,this.w=o[3]*t+o[7]*r+o[11]*n+o[15]*a,this},divideScalar:function(e){return this.multiplyScalar(1/e)},setAxisAngleFromQuaternion:function(e){this.w=2*Math.acos(e.w);var t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this},setAxisAngleFromRotationMatrix:function(e){var t,r,n,a,o=e.elements,i=o[0],s=o[4],l=o[8],c=o[1],f=o[5],d=o[9],u=o[2],p=o[6],h=o[10];if(Math.abs(s-c)<.01&&Math.abs(l-u)<.01&&Math.abs(d-p)<.01){if(Math.abs(s+c)<.1&&Math.abs(l+u)<.1&&Math.abs(d+p)<.1&&Math.abs(i+f+h-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;var v=(i+1)/2,m=(f+1)/2,x=(h+1)/2,g=(s+c)/4,y=(l+u)/4,E=(d+p)/4;return v>m&&v>x?v<.01?(r=0,n=.707106781,a=.707106781):(n=g/(r=Math.sqrt(v)),a=y/r):m>x?m<.01?(r=.707106781,n=0,a=.707106781):(r=g/(n=Math.sqrt(m)),a=E/n):x<.01?(r=.707106781,n=.707106781,a=0):(r=y/(a=Math.sqrt(x)),n=E/a),this.set(r,n,a,t),this}var w=Math.sqrt((p-d)*(p-d)+(l-u)*(l-u)+(c-s)*(c-s));return Math.abs(w)<.001&&(w=1),this.x=(p-d)/w,this.y=(l-u)/w,this.z=(c-s)/w,this.w=Math.acos((i+f+h-1)/2),this},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this},clampLength:function(e,t){var r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this},lerpVectors:function(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e},fromBufferAttribute:function(e,t,r){return void 0!==r&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}),p.prototype=Object.assign(Object.create(t.prototype),{constructor:p,isWebGLRenderTarget:!0,setSize:function(e,t){this.width===e&&this.height===t||(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),h.prototype=Object.assign(Object.create(p.prototype),{constructor:h,isWebGLMultisampleRenderTarget:!0,copy:function(e){return p.prototype.copy.call(this,e),this.samples=e.samples,this}}),Object.assign(v,{slerp:function(e,t,r,n){return r.copy(e).slerp(t,n)},slerpFlat:function(e,t,r,n,a,o,i){var s=r[n+0],l=r[n+1],c=r[n+2],f=r[n+3],d=a[o+0],u=a[o+1],p=a[o+2],h=a[o+3];if(f!==h||s!==d||l!==u||c!==p){var v=1-i,m=s*d+l*u+c*p+f*h,x=m>=0?1:-1,g=1-m*m;if(g>Number.EPSILON){var y=Math.sqrt(g),E=Math.atan2(y,m*x);v=Math.sin(v*E)/y,i=Math.sin(i*E)/y}var w=i*x;if(s=s*v+d*w,l=l*v+u*w,c=c*v+p*w,f=f*v+h*w,v===1-i){var b=1/Math.sqrt(s*s+l*l+c*c+f*f);s*=b,l*=b,c*=b,f*=b}}e[t]=s,e[t+1]=l,e[t+2]=c,e[t+3]=f},multiplyQuaternionsFlat:function(e,t,r,n,a,o){var i=r[n],s=r[n+1],l=r[n+2],c=r[n+3],f=a[o],d=a[o+1],u=a[o+2],p=a[o+3];return e[t]=i*p+c*f+s*u-l*d,e[t+1]=s*p+c*d+l*f-i*u,e[t+2]=l*p+c*u+i*d-s*f,e[t+3]=c*p-i*f-s*d-l*u,e}}),Object.defineProperties(v.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},w:{get:function(){return this._w},set:function(e){this._w=e,this._onChangeCallback()}}}),Object.assign(v.prototype,{isQuaternion:!0,set:function(e,t,r,n){return this._x=e,this._y=t,this._z=r,this._w=n,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this},setFromEuler:function(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var r=e._x,n=e._y,a=e._z,o=e.order,i=Math.cos,s=Math.sin,l=i(r/2),c=i(n/2),f=i(a/2),d=s(r/2),u=s(n/2),p=s(a/2);switch(o){case"XYZ":this._x=d*c*f+l*u*p,this._y=l*u*f-d*c*p,this._z=l*c*p+d*u*f,this._w=l*c*f-d*u*p;break;case"YXZ":this._x=d*c*f+l*u*p,this._y=l*u*f-d*c*p,this._z=l*c*p-d*u*f,this._w=l*c*f+d*u*p;break;case"ZXY":this._x=d*c*f-l*u*p,this._y=l*u*f+d*c*p,this._z=l*c*p+d*u*f,this._w=l*c*f-d*u*p;break;case"ZYX":this._x=d*c*f-l*u*p,this._y=l*u*f+d*c*p,this._z=l*c*p-d*u*f,this._w=l*c*f+d*u*p;break;case"YZX":this._x=d*c*f+l*u*p,this._y=l*u*f+d*c*p,this._z=l*c*p-d*u*f,this._w=l*c*f-d*u*p;break;case"XZY":this._x=d*c*f-l*u*p,this._y=l*u*f-d*c*p,this._z=l*c*p+d*u*f,this._w=l*c*f+d*u*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return!1!==t&&this._onChangeCallback(),this},setFromAxisAngle:function(e,t){var r=t/2,n=Math.sin(r);return this._x=e.x*n,this._y=e.y*n,this._z=e.z*n,this._w=Math.cos(r),this._onChangeCallback(),this},setFromRotationMatrix:function(e){var t=e.elements,r=t[0],n=t[4],a=t[8],o=t[1],i=t[5],s=t[9],l=t[2],c=t[6],f=t[10],d=r+i+f;if(d>0){var u=.5/Math.sqrt(d+1);this._w=.25/u,this._x=(c-s)*u,this._y=(a-l)*u,this._z=(o-n)*u}else if(r>i&&r>f){var p=2*Math.sqrt(1+r-i-f);this._w=(c-s)/p,this._x=.25*p,this._y=(n+o)/p,this._z=(a+l)/p}else if(i>f){var h=2*Math.sqrt(1+i-r-f);this._w=(a-l)/h,this._x=(n+o)/h,this._y=.25*h,this._z=(s+c)/h}else{var v=2*Math.sqrt(1+f-r-i);this._w=(o-n)/v,this._x=(a+l)/v,this._y=(s+c)/v,this._z=.25*v}return this._onChangeCallback(),this},setFromUnitVectors:function(e,t){var r=e.dot(t)+1;return r<1e-6?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()},angleTo:function(e){return 2*Math.acos(Math.abs(i.clamp(this.dot(e),-1,1)))},rotateTowards:function(e,t){var r=this.angleTo(e);if(0===r)return this;var n=Math.min(1,t/r);return this.slerp(e,n),this},identity:function(){return this.set(0,0,0,1)},inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this},dot:function(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)},premultiply:function(e){return this.multiplyQuaternions(e,this)},multiplyQuaternions:function(e,t){var r=e._x,n=e._y,a=e._z,o=e._w,i=t._x,s=t._y,l=t._z,c=t._w;return this._x=r*c+o*i+n*l-a*s,this._y=n*c+o*s+a*i-r*l,this._z=a*c+o*l+r*s-n*i,this._w=o*c-r*i-n*s-a*l,this._onChangeCallback(),this},slerp:function(e,t){if(0===t)return this;if(1===t)return this.copy(e);var r=this._x,n=this._y,a=this._z,o=this._w,i=o*e._w+r*e._x+n*e._y+a*e._z;if(i<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,i=-i):this.copy(e),i>=1)return this._w=o,this._x=r,this._y=n,this._z=a,this;var s=1-i*i;if(s<=Number.EPSILON){var l=1-t;return this._w=l*o+t*this._w,this._x=l*r+t*this._x,this._y=l*n+t*this._y,this._z=l*a+t*this._z,this.normalize(),this._onChangeCallback(),this}var c=Math.sqrt(s),f=Math.atan2(c,i),d=Math.sin((1-t)*f)/c,u=Math.sin(t*f)/c;return this._w=o*d+this._w*u,this._x=r*d+this._x*u,this._y=n*d+this._y*u,this._z=a*d+this._z*u,this._onChangeCallback(),this},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w},fromArray:function(e,t){return void 0===t&&(t=0),this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e},fromBufferAttribute:function(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}});var m=new g,x=new v;function g(e,t,r){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),this.x=e,this.y=t,this.z=r}Object.assign(g.prototype,{isVector3:!0,set:function(e,t,r){return void 0===r&&(r=this.z),this.x=e,this.y=t,this.z=r,this},setScalar:function(e){return this.x=e,this.y=e,this.z=e,this},setX:function(e){return this.x=e,this},setY:function(e){return this.y=e,this},setZ:function(e){return this.z=e,this},setComponent:function(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this},getComponent:function(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this},add:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)},addScalar:function(e){return this.x+=e,this.y+=e,this.z+=e,this},addVectors:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this},addScaledVector:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this},sub:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)},subScalar:function(e){return this.x-=e,this.y-=e,this.z-=e,this},subVectors:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)},multiplyScalar:function(e){return this.x*=e,this.y*=e,this.z*=e,this},multiplyVectors:function(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this},applyEuler:function(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(x.setFromEuler(e))},applyAxisAngle:function(e,t){return this.applyQuaternion(x.setFromAxisAngle(e,t))},applyMatrix3:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[3]*r+a[6]*n,this.y=a[1]*t+a[4]*r+a[7]*n,this.z=a[2]*t+a[5]*r+a[8]*n,this},applyNormalMatrix:function(e){return this.applyMatrix3(e).normalize()},applyMatrix4:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements,o=1/(a[3]*t+a[7]*r+a[11]*n+a[15]);return this.x=(a[0]*t+a[4]*r+a[8]*n+a[12])*o,this.y=(a[1]*t+a[5]*r+a[9]*n+a[13])*o,this.z=(a[2]*t+a[6]*r+a[10]*n+a[14])*o,this},applyQuaternion:function(e){var t=this.x,r=this.y,n=this.z,a=e.x,o=e.y,i=e.z,s=e.w,l=s*t+o*n-i*r,c=s*r+i*t-a*n,f=s*n+a*r-o*t,d=-a*t-o*r-i*n;return this.x=l*s+d*-a+c*-i-f*-o,this.y=c*s+d*-o+f*-a-l*-i,this.z=f*s+d*-i+l*-o-c*-a,this},project:function(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)},unproject:function(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)},transformDirection:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*n,this.y=a[1]*t+a[5]*r+a[9]*n,this.z=a[2]*t+a[6]*r+a[10]*n,this.normalize()},divide:function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this},divideScalar:function(e){return this.multiplyScalar(1/e)},min:function(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this},max:function(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this},clamp:function(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this},clampScalar:function(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this},clampLength:function(e,t){var r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(e){return this.x*e.x+this.y*e.y+this.z*e.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(e){return this.normalize().multiplyScalar(e)},lerp:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this},lerpVectors:function(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this},cross:function(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)},crossVectors:function(e,t){var r=e.x,n=e.y,a=e.z,o=t.x,i=t.y,s=t.z;return this.x=n*s-a*i,this.y=a*o-r*s,this.z=r*i-n*o,this},projectOnVector:function(e){var t=e.lengthSq();if(0===t)return this.set(0,0,0);var r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)},projectOnPlane:function(e){return m.copy(this).projectOnVector(e),this.sub(m)},reflect:function(e){return this.sub(m.copy(e).multiplyScalar(2*this.dot(e)))},angleTo:function(e){var t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;var r=this.dot(e)/t;return Math.acos(i.clamp(r,-1,1))},distanceTo:function(e){return Math.sqrt(this.distanceToSquared(e))},distanceToSquared:function(e){var t=this.x-e.x,r=this.y-e.y,n=this.z-e.z;return t*t+r*r+n*n},manhattanDistanceTo:function(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)},setFromSpherical:function(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)},setFromSphericalCoords:function(e,t,r){var n=Math.sin(t)*e;return this.x=n*Math.sin(r),this.y=Math.cos(t)*e,this.z=n*Math.cos(r),this},setFromCylindrical:function(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)},setFromCylindricalCoords:function(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this},setFromMatrixPosition:function(e){var t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this},setFromMatrixScale:function(e){var t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=n,this},setFromMatrixColumn:function(e,t){return this.fromArray(e.elements,4*t)},setFromMatrix3Column:function(e,t){return this.fromArray(e.elements,3*t)},equals:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z},fromArray:function(e,t){return void 0===t&&(t=0),this.x=e[t],this.y=e[t+1],this.z=e[t+2],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e},fromBufferAttribute:function(e,t,r){return void 0!==r&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this},random:function(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}});var y=new g,E=new R,w=new g(0,0,0),b=new g(1,1,1),T=new g,_=new g,S=new g;function R(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}Object.assign(R.prototype,{isMatrix4:!0,set:function(e,t,r,n,a,o,i,s,l,c,f,d,u,p,h,v){var m=this.elements;return m[0]=e,m[4]=t,m[8]=r,m[12]=n,m[1]=a,m[5]=o,m[9]=i,m[13]=s,m[2]=l,m[6]=c,m[10]=f,m[14]=d,m[3]=u,m[7]=p,m[11]=h,m[15]=v,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return(new R).fromArray(this.elements)},copy:function(e){var t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this},copyPosition:function(e){var t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this},extractBasis:function(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this},makeBasis:function(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this},extractRotation:function(e){var t=this.elements,r=e.elements,n=1/y.setFromMatrixColumn(e,0).length(),a=1/y.setFromMatrixColumn(e,1).length(),o=1/y.setFromMatrixColumn(e,2).length();return t[0]=r[0]*n,t[1]=r[1]*n,t[2]=r[2]*n,t[3]=0,t[4]=r[4]*a,t[5]=r[5]*a,t[6]=r[6]*a,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},makeRotationFromEuler:function(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var t=this.elements,r=e.x,n=e.y,a=e.z,o=Math.cos(r),i=Math.sin(r),s=Math.cos(n),l=Math.sin(n),c=Math.cos(a),f=Math.sin(a);if("XYZ"===e.order){var d=o*c,u=o*f,p=i*c,h=i*f;t[0]=s*c,t[4]=-s*f,t[8]=l,t[1]=u+p*l,t[5]=d-h*l,t[9]=-i*s,t[2]=h-d*l,t[6]=p+u*l,t[10]=o*s}else if("YXZ"===e.order){var v=s*c,m=s*f,x=l*c,g=l*f;t[0]=v+g*i,t[4]=x*i-m,t[8]=o*l,t[1]=o*f,t[5]=o*c,t[9]=-i,t[2]=m*i-x,t[6]=g+v*i,t[10]=o*s}else if("ZXY"===e.order){var y=s*c,E=s*f,w=l*c,b=l*f;t[0]=y-b*i,t[4]=-o*f,t[8]=w+E*i,t[1]=E+w*i,t[5]=o*c,t[9]=b-y*i,t[2]=-o*l,t[6]=i,t[10]=o*s}else if("ZYX"===e.order){var T=o*c,_=o*f,S=i*c,R=i*f;t[0]=s*c,t[4]=S*l-_,t[8]=T*l+R,t[1]=s*f,t[5]=R*l+T,t[9]=_*l-S,t[2]=-l,t[6]=i*s,t[10]=o*s}else if("YZX"===e.order){var A=o*s,M=o*l,C=i*s,L=i*l;t[0]=s*c,t[4]=L-A*f,t[8]=C*f+M,t[1]=f,t[5]=o*c,t[9]=-i*c,t[2]=-l*c,t[6]=M*f+C,t[10]=A-L*f}else if("XZY"===e.order){var H=o*s,P=o*l,z=i*s,k=i*l;t[0]=s*c,t[4]=-f,t[8]=l*c,t[1]=H*f+k,t[5]=o*c,t[9]=P*f-z,t[2]=z*f-P,t[6]=i*c,t[10]=k*f+H}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},makeRotationFromQuaternion:function(e){return this.compose(w,e,b)},lookAt:function(e,t,r){var n=this.elements;return S.subVectors(e,t),0===S.lengthSq()&&(S.z=1),S.normalize(),T.crossVectors(r,S),0===T.lengthSq()&&(1===Math.abs(r.z)?S.x+=1e-4:S.z+=1e-4,S.normalize(),T.crossVectors(r,S)),T.normalize(),_.crossVectors(S,T),n[0]=T.x,n[4]=_.x,n[8]=S.x,n[1]=T.y,n[5]=_.y,n[9]=S.y,n[2]=T.z,n[6]=_.z,n[10]=S.z,this},multiply:function(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)},premultiply:function(e){return this.multiplyMatrices(e,this)},multiplyMatrices:function(e,t){var r=e.elements,n=t.elements,a=this.elements,o=r[0],i=r[4],s=r[8],l=r[12],c=r[1],f=r[5],d=r[9],u=r[13],p=r[2],h=r[6],v=r[10],m=r[14],x=r[3],g=r[7],y=r[11],E=r[15],w=n[0],b=n[4],T=n[8],_=n[12],S=n[1],R=n[5],A=n[9],M=n[13],C=n[2],L=n[6],H=n[10],P=n[14],z=n[3],k=n[7],N=n[11],D=n[15];return a[0]=o*w+i*S+s*C+l*z,a[4]=o*b+i*R+s*L+l*k,a[8]=o*T+i*A+s*H+l*N,a[12]=o*_+i*M+s*P+l*D,a[1]=c*w+f*S+d*C+u*z,a[5]=c*b+f*R+d*L+u*k,a[9]=c*T+f*A+d*H+u*N,a[13]=c*_+f*M+d*P+u*D,a[2]=p*w+h*S+v*C+m*z,a[6]=p*b+h*R+v*L+m*k,a[10]=p*T+h*A+v*H+m*N,a[14]=p*_+h*M+v*P+m*D,a[3]=x*w+g*S+y*C+E*z,a[7]=x*b+g*R+y*L+E*k,a[11]=x*T+g*A+y*H+E*N,a[15]=x*_+g*M+y*P+E*D,this},multiplyScalar:function(e){var t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this},determinant:function(){var e=this.elements,t=e[0],r=e[4],n=e[8],a=e[12],o=e[1],i=e[5],s=e[9],l=e[13],c=e[2],f=e[6],d=e[10],u=e[14];return e[3]*(+a*s*f-n*l*f-a*i*d+r*l*d+n*i*u-r*s*u)+e[7]*(+t*s*u-t*l*d+a*o*d-n*o*u+n*l*c-a*s*c)+e[11]*(+t*l*f-t*i*u-a*o*f+r*o*u+a*i*c-r*l*c)+e[15]*(-n*i*c-t*s*f+t*i*d+n*o*f-r*o*d+r*s*c)},transpose:function(){var e,t=this.elements;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this},setPosition:function(e,t,r){var n=this.elements;return e.isVector3?(n[12]=e.x,n[13]=e.y,n[14]=e.z):(n[12]=e,n[13]=t,n[14]=r),this},getInverse:function(e,t){void 0!==t&&console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");var r=this.elements,n=e.elements,a=n[0],o=n[1],i=n[2],s=n[3],l=n[4],c=n[5],f=n[6],d=n[7],u=n[8],p=n[9],h=n[10],v=n[11],m=n[12],x=n[13],g=n[14],y=n[15],E=p*g*d-x*h*d+x*f*v-c*g*v-p*f*y+c*h*y,w=m*h*d-u*g*d-m*f*v+l*g*v+u*f*y-l*h*y,b=u*x*d-m*p*d+m*c*v-l*x*v-u*c*y+l*p*y,T=m*p*f-u*x*f-m*c*h+l*x*h+u*c*g-l*p*g,_=a*E+o*w+i*b+s*T;if(0===_)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var S=1/_;return r[0]=E*S,r[1]=(x*h*s-p*g*s-x*i*v+o*g*v+p*i*y-o*h*y)*S,r[2]=(c*g*s-x*f*s+x*i*d-o*g*d-c*i*y+o*f*y)*S,r[3]=(p*f*s-c*h*s-p*i*d+o*h*d+c*i*v-o*f*v)*S,r[4]=w*S,r[5]=(u*g*s-m*h*s+m*i*v-a*g*v-u*i*y+a*h*y)*S,r[6]=(m*f*s-l*g*s-m*i*d+a*g*d+l*i*y-a*f*y)*S,r[7]=(l*h*s-u*f*s+u*i*d-a*h*d-l*i*v+a*f*v)*S,r[8]=b*S,r[9]=(m*p*s-u*x*s-m*o*v+a*x*v+u*o*y-a*p*y)*S,r[10]=(l*x*s-m*c*s+m*o*d-a*x*d-l*o*y+a*c*y)*S,r[11]=(u*c*s-l*p*s-u*o*d+a*p*d+l*o*v-a*c*v)*S,r[12]=T*S,r[13]=(u*x*i-m*p*i+m*o*h-a*x*h-u*o*g+a*p*g)*S,r[14]=(m*c*i-l*x*i-m*o*f+a*x*f+l*o*g-a*c*g)*S,r[15]=(l*p*i-u*c*i+u*o*f-a*p*f-l*o*h+a*c*h)*S,this},scale:function(e){var t=this.elements,r=e.x,n=e.y,a=e.z;return t[0]*=r,t[4]*=n,t[8]*=a,t[1]*=r,t[5]*=n,t[9]*=a,t[2]*=r,t[6]*=n,t[10]*=a,t[3]*=r,t[7]*=n,t[11]*=a,this},getMaxScaleOnAxis:function(){var e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,n))},makeTranslation:function(e,t,r){return this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this},makeRotationX:function(e){var t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this},makeRotationY:function(e){var t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this},makeRotationZ:function(e){var t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(e,t){var r=Math.cos(t),n=Math.sin(t),a=1-r,o=e.x,i=e.y,s=e.z,l=a*o,c=a*i;return this.set(l*o+r,l*i-n*s,l*s+n*i,0,l*i+n*s,c*i+r,c*s-n*o,0,l*s-n*i,c*s+n*o,a*s*s+r,0,0,0,0,1),this},makeScale:function(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this},makeShear:function(e,t,r){return this.set(1,t,r,0,e,1,r,0,e,t,1,0,0,0,0,1),this},compose:function(e,t,r){var n=this.elements,a=t._x,o=t._y,i=t._z,s=t._w,l=a+a,c=o+o,f=i+i,d=a*l,u=a*c,p=a*f,h=o*c,v=o*f,m=i*f,x=s*l,g=s*c,y=s*f,E=r.x,w=r.y,b=r.z;return n[0]=(1-(h+m))*E,n[1]=(u+y)*E,n[2]=(p-g)*E,n[3]=0,n[4]=(u-y)*w,n[5]=(1-(d+m))*w,n[6]=(v+x)*w,n[7]=0,n[8]=(p+g)*b,n[9]=(v-x)*b,n[10]=(1-(d+h))*b,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,this},decompose:function(e,t,r){var n=this.elements,a=y.set(n[0],n[1],n[2]).length(),o=y.set(n[4],n[5],n[6]).length(),i=y.set(n[8],n[9],n[10]).length();this.determinant()<0&&(a=-a),e.x=n[12],e.y=n[13],e.z=n[14],E.copy(this);var s=1/a,l=1/o,c=1/i;return E.elements[0]*=s,E.elements[1]*=s,E.elements[2]*=s,E.elements[4]*=l,E.elements[5]*=l,E.elements[6]*=l,E.elements[8]*=c,E.elements[9]*=c,E.elements[10]*=c,t.setFromRotationMatrix(E),r.x=a,r.y=o,r.z=i,this},makePerspective:function(e,t,r,n,a,o){void 0===o&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");var i=this.elements,s=2*a/(t-e),l=2*a/(r-n),c=(t+e)/(t-e),f=(r+n)/(r-n),d=-(o+a)/(o-a),u=-2*o*a/(o-a);return i[0]=s,i[4]=0,i[8]=c,i[12]=0,i[1]=0,i[5]=l,i[9]=f,i[13]=0,i[2]=0,i[6]=0,i[10]=d,i[14]=u,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this},makeOrthographic:function(e,t,r,n,a,o){var i=this.elements,s=1/(t-e),l=1/(r-n),c=1/(o-a),f=(t+e)*s,d=(r+n)*l,u=(o+a)*c;return i[0]=2*s,i[4]=0,i[8]=0,i[12]=-f,i[1]=0,i[5]=2*l,i[9]=0,i[13]=-d,i[2]=0,i[6]=0,i[10]=-2*c,i[14]=-u,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this},equals:function(e){for(var t=this.elements,r=e.elements,n=0;n<16;n++)if(t[n]!==r[n])return!1;return!0},fromArray:function(e,t){void 0===t&&(t=0);for(var r=0;r<16;r++)this.elements[r]=e[r+t];return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);var r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}});var A=new R,M=new v;function C(e,t,r,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===r&&(r=0),void 0===n&&(n=C.DefaultOrder),this._x=e,this._y=t,this._z=r,this._order=n}function L(){this.mask=1}C.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"],C.DefaultOrder="XYZ",Object.defineProperties(C.prototype,{x:{get:function(){return this._x},set:function(e){this._x=e,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(e){this._y=e,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(e){this._z=e,this._onChangeCallback()}},order:{get:function(){return this._order},set:function(e){this._order=e,this._onChangeCallback()}}}),Object.assign(C.prototype,{isEuler:!0,set:function(e,t,r,n){return this._x=e,this._y=t,this._z=r,this._order=n||this._order,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this},setFromRotationMatrix:function(e,t,r){var n=i.clamp,a=e.elements,o=a[0],s=a[4],l=a[8],c=a[1],f=a[5],d=a[9],u=a[2],p=a[6],h=a[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(n(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-d,h),this._z=Math.atan2(-s,o)):(this._x=Math.atan2(p,f),this._z=0);break;case"YXZ":this._x=Math.asin(-n(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(l,h),this._z=Math.atan2(c,f)):(this._y=Math.atan2(-u,o),this._z=0);break;case"ZXY":this._x=Math.asin(n(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-u,h),this._z=Math.atan2(-s,f)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-n(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(p,h),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-s,f));break;case"YZX":this._z=Math.asin(n(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-d,f),this._y=Math.atan2(-u,o)):(this._x=0,this._y=Math.atan2(l,h));break;case"XZY":this._z=Math.asin(-n(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(p,f),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-d,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==r&&this._onChangeCallback(),this},setFromQuaternion:function(e,t,r){return A.makeRotationFromQuaternion(e),this.setFromRotationMatrix(A,t,r)},setFromVector3:function(e,t){return this.set(e.x,e.y,e.z,t||this._order)},reorder:function(e){return M.setFromEuler(this),this.setFromQuaternion(M,e)},equals:function(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order},fromArray:function(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e},toVector3:function(e){return e?e.set(this._x,this._y,this._z):new g(this._x,this._y,this._z)},_onChange:function(e){return this._onChangeCallback=e,this},_onChangeCallback:function(){}}),Object.assign(L.prototype,{set:function(e){this.mask=1<<e|0},enable:function(e){this.mask|=1<<e|0},enableAll:function(){this.mask=-1},toggle:function(e){this.mask^=1<<e|0},disable:function(e){this.mask&=~(1<<e|0)},disableAll:function(){this.mask=0},test:function(e){return 0!=(this.mask&e.mask)}});var H=0,P=new g,z=new v,k=new R,N=new g,D=new g,F=new g,I=new v,O=new g(1,0,0),U=new g(0,1,0),G=new g(0,0,1),B={type:"added"},V={type:"removed"};function j(){Object.defineProperty(this,"id",{value:H++}),this.uuid=i.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=j.DefaultUp.clone();var e=new g,t=new C,r=new v,n=new g(1,1,1);t._onChange((function(){r.setFromEuler(t,!1)})),r._onChange((function(){t.setFromQuaternion(r,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new R},normalMatrix:{value:new l}}),this.matrix=new R,this.matrixWorld=new R,this.matrixAutoUpdate=j.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new L,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.userData={}}function W(){j.call(this),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}j.DefaultUp=new g(0,1,0),j.DefaultMatrixAutoUpdate=!0,j.prototype=Object.assign(Object.create(t.prototype),{constructor:j,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return z.setFromAxisAngle(e,t),this.quaternion.multiply(z),this},rotateOnWorldAxis:function(e,t){return z.setFromAxisAngle(e,t),this.quaternion.premultiply(z),this},rotateX:function(e){return this.rotateOnAxis(O,e)},rotateY:function(e){return this.rotateOnAxis(U,e)},rotateZ:function(e){return this.rotateOnAxis(G,e)},translateOnAxis:function(e,t){return P.copy(e).applyQuaternion(this.quaternion),this.position.add(P.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(O,e)},translateY:function(e){return this.translateOnAxis(U,e)},translateZ:function(e){return this.translateOnAxis(G,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(k.getInverse(this.matrixWorld))},lookAt:function(e,t,r){e.isVector3?N.copy(e):N.set(e,t,r);var n=this.parent;this.updateWorldMatrix(!0,!1),D.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?k.lookAt(D,N,this.up):k.lookAt(N,D,this.up),this.quaternion.setFromRotationMatrix(k),n&&(k.extractRotation(n.matrixWorld),z.setFromRotationMatrix(k),this.quaternion.premultiply(z.inverse()))},add:function(e){if(arguments.length>1){for(var t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(B)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(var t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}var r=this.children.indexOf(e);return-1!==r&&(e.parent=null,this.children.splice(r,1),e.dispatchEvent(V)),this},attach:function(e){return this.updateWorldMatrix(!0,!1),k.getInverse(this.matrixWorld),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),k.multiply(e.parent.matrixWorld)),e.applyMatrix4(k),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(var r=0,n=this.children.length;r<n;r++){var a=this.children[r].getObjectByProperty(e,t);if(void 0!==a)return a}},getWorldPosition:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new g),this.updateMatrixWorld(!0),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new v),this.updateMatrixWorld(!0),this.matrixWorld.decompose(D,e,F),e},getWorldScale:function(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new g),this.updateMatrixWorld(!0),this.matrixWorld.decompose(D,I,e),e},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new g),this.updateMatrixWorld(!0);var t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);for(var t=this.children,r=0,n=t.length;r<n;r++)t[r].traverse(e)},traverseVisible:function(e){if(!1!==this.visible){e(this);for(var t=this.children,r=0,n=t.length;r<n;r++)t[r].traverseVisible(e)}},traverseAncestors:function(e){var t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);for(var t=this.children,r=0,n=t.length;r<n;r++)t[r].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){var r=this.parent;if(!0===e&&null!==r&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t)for(var n=this.children,a=0,o=n.length;a<o;a++)n[a].updateWorldMatrix(!1,!0)},toJSON:function(e){var t=void 0===e||"string"==typeof e,r={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{}},r.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var n={};function a(t,r){return void 0===t[r.uuid]&&(t[r.uuid]=r.toJSON(e)),r.uuid}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),!0===this.castShadow&&(n.castShadow=!0),!0===this.receiveShadow&&(n.receiveShadow=!0),!1===this.visible&&(n.visible=!1),!1===this.frustumCulled&&(n.frustumCulled=!1),0!==this.renderOrder&&(n.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){n.geometry=a(e.geometries,this.geometry);var o=this.geometry.parameters;if(void 0!==o&&void 0!==o.shapes){var i=o.shapes;if(Array.isArray(i))for(var s=0,l=i.length;s<l;s++){var c=i[s];a(e.shapes,c)}else a(e.shapes,i)}}if(void 0!==this.material)if(Array.isArray(this.material)){for(var f=[],d=0,u=this.material.length;d<u;d++)f.push(a(e.materials,this.material[d]));n.material=f}else n.material=a(e.materials,this.material);if(this.children.length>0){n.children=[];for(var p=0;p<this.children.length;p++)n.children.push(this.children[p].toJSON(e).object)}if(t){var h=y(e.geometries),v=y(e.materials),m=y(e.textures),x=y(e.images),g=y(e.shapes);h.length>0&&(r.geometries=h),v.length>0&&(r.materials=v),m.length>0&&(r.textures=m),x.length>0&&(r.images=x),g.length>0&&(r.shapes=g)}return r.object=n,r;function y(e){var t=[];for(var r in e){var n=e[r];delete n.metadata,t.push(n)}return t}},clone:function(e){return(new this.constructor).copy(this,e)},copy:function(e,t){if(void 0===t&&(t=!0),this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(var r=0;r<e.children.length;r++){var n=e.children[r];this.add(n.clone())}return this}}),W.prototype=Object.assign(Object.create(j.prototype),{constructor:W,isScene:!0,copy:function(e,t){return j.prototype.copy.call(this,e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this},toJSON:function(e){var t=j.prototype.toJSON.call(this,e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t},dispose:function(){this.dispatchEvent({type:"dispose"})}});var q=[new g,new g,new g,new g,new g,new g,new g,new g],X=new g,Y=new oe,Z=new g,Q=new g,K=new g,J=new g,$=new g,ee=new g,te=new g,re=new g,ne=new g,ae=new g;function oe(e,t){this.min=void 0!==e?e:new g(1/0,1/0,1/0),this.max=void 0!==t?t:new g(-1/0,-1/0,-1/0)}function ie(e,t,r,n,a){for(var o=0,i=e.length-3;o<=i;o+=3){ae.fromArray(e,o);var s=a.x*Math.abs(ae.x)+a.y*Math.abs(ae.y)+a.z*Math.abs(ae.z),l=t.dot(ae),c=r.dot(ae),f=n.dot(ae);if(Math.max(-Math.max(l,c,f),Math.min(l,c,f))>s)return!1}return!0}Object.assign(oe.prototype,{isBox3:!0,set:function(e,t){return this.min.copy(e),this.max.copy(t),this},setFromArray:function(e){for(var t=1/0,r=1/0,n=1/0,a=-1/0,o=-1/0,i=-1/0,s=0,l=e.length;s<l;s+=3){var c=e[s],f=e[s+1],d=e[s+2];c<t&&(t=c),f<r&&(r=f),d<n&&(n=d),c>a&&(a=c),f>o&&(o=f),d>i&&(i=d)}return this.min.set(t,r,n),this.max.set(a,o,i),this},setFromBufferAttribute:function(e){for(var t=1/0,r=1/0,n=1/0,a=-1/0,o=-1/0,i=-1/0,s=0,l=e.count;s<l;s++){var c=e.getX(s),f=e.getY(s),d=e.getZ(s);c<t&&(t=c),f<r&&(r=f),d<n&&(n=d),c>a&&(a=c),f>o&&(o=f),d>i&&(i=d)}return this.min.set(t,r,n),this.max.set(a,o,i),this},setFromPoints:function(e){this.makeEmpty();for(var t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this},setFromCenterAndSize:function(e,t){var r=X.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this},setFromObject:function(e){return this.makeEmpty(),this.expandByObject(e)},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},getCenter:function(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new g),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new g),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},expandByObject:function(e){e.updateWorldMatrix(!1,!1);var t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),Y.copy(t.boundingBox),Y.applyMatrix4(e.matrixWorld),this.union(Y));for(var r=e.children,n=0,a=r.length;n<a;n++)this.expandByObject(r[n]);return this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z},getParameter:function(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new g),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)},intersectsSphere:function(e){return this.clampPoint(e.center,X),X.distanceToSquared(e.center)<=e.radius*e.radius},intersectsPlane:function(e){var t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant},intersectsTriangle:function(e){if(this.isEmpty())return!1;this.getCenter(te),re.subVectors(this.max,te),Z.subVectors(e.a,te),Q.subVectors(e.b,te),K.subVectors(e.c,te),J.subVectors(Q,Z),$.subVectors(K,Q),ee.subVectors(Z,K);var t=[0,-J.z,J.y,0,-$.z,$.y,0,-ee.z,ee.y,J.z,0,-J.x,$.z,0,-$.x,ee.z,0,-ee.x,-J.y,J.x,0,-$.y,$.x,0,-ee.y,ee.x,0];return!!ie(t,Z,Q,K,re)&&!!ie(t=[1,0,0,0,1,0,0,0,1],Z,Q,K,re)&&(ne.crossVectors(J,$),ie(t=[ne.x,ne.y,ne.z],Z,Q,K,re))},clampPoint:function(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new g),t.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){return X.copy(e).clamp(this.min,this.max).sub(e).length()},getBoundingSphere:function(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(X).length(),e},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},applyMatrix4:function(e){return this.isEmpty()||(q[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),q[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),q[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),q[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),q[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),q[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),q[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),q[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(q)),this},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});var se=new oe;function le(e,t){this.center=void 0!==e?e:new g,this.radius=void 0!==t?t:-1}Object.assign(le.prototype,{set:function(e,t){return this.center.copy(e),this.radius=t,this},setFromPoints:function(e,t){var r=this.center;void 0!==t?r.copy(t):se.setFromPoints(e).getCenter(r);for(var n=0,a=0,o=e.length;a<o;a++)n=Math.max(n,r.distanceToSquared(e[a]));return this.radius=Math.sqrt(n),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.center.copy(e.center),this.radius=e.radius,this},isEmpty:function(){return this.radius<0},makeEmpty:function(){return this.center.set(0,0,0),this.radius=-1,this},containsPoint:function(e){return e.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(e){return e.distanceTo(this.center)-this.radius},intersectsSphere:function(e){var t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t},intersectsBox:function(e){return e.intersectsSphere(this)},intersectsPlane:function(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius},clampPoint:function(e,t){var r=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new g),t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t},getBoundingBox:function(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new oe),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)},applyMatrix4:function(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this},translate:function(e){return this.center.add(e),this},equals:function(e){return e.center.equals(this.center)&&e.radius===this.radius}});var ce=new g,fe=new g,de=new g,ue=new g,pe=new g,he=new g,ve=new g;function me(e,t){this.origin=void 0!==e?e:new g,this.direction=void 0!==t?t:new g(0,0,-1)}Object.assign(me.prototype,{set:function(e,t){return this.origin.copy(e),this.direction.copy(t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this},at:function(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new g),t.copy(this.direction).multiplyScalar(e).add(this.origin)},lookAt:function(e){return this.direction.copy(e).sub(this.origin).normalize(),this},recast:function(e){return this.origin.copy(this.at(e,ce)),this},closestPointToPoint:function(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new g),t.subVectors(e,this.origin);var r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(r).add(this.origin)},distanceToPoint:function(e){return Math.sqrt(this.distanceSqToPoint(e))},distanceSqToPoint:function(e){var t=ce.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(ce.copy(this.direction).multiplyScalar(t).add(this.origin),ce.distanceToSquared(e))},distanceSqToSegment:function(e,t,r,n){fe.copy(e).add(t).multiplyScalar(.5),de.copy(t).sub(e).normalize(),ue.copy(this.origin).sub(fe);var a,o,i,s,l=.5*e.distanceTo(t),c=-this.direction.dot(de),f=ue.dot(this.direction),d=-ue.dot(de),u=ue.lengthSq(),p=Math.abs(1-c*c);if(p>0)if(o=c*f-d,s=l*p,(a=c*d-f)>=0)if(o>=-s)if(o<=s){var h=1/p;i=(a*=h)*(a+c*(o*=h)+2*f)+o*(c*a+o+2*d)+u}else o=l,i=-(a=Math.max(0,-(c*o+f)))*a+o*(o+2*d)+u;else o=-l,i=-(a=Math.max(0,-(c*o+f)))*a+o*(o+2*d)+u;else o<=-s?i=-(a=Math.max(0,-(-c*l+f)))*a+(o=a>0?-l:Math.min(Math.max(-l,-d),l))*(o+2*d)+u:o<=s?(a=0,i=(o=Math.min(Math.max(-l,-d),l))*(o+2*d)+u):i=-(a=Math.max(0,-(c*l+f)))*a+(o=a>0?l:Math.min(Math.max(-l,-d),l))*(o+2*d)+u;else o=c>0?-l:l,i=-(a=Math.max(0,-(c*o+f)))*a+o*(o+2*d)+u;return r&&r.copy(this.direction).multiplyScalar(a).add(this.origin),n&&n.copy(de).multiplyScalar(o).add(fe),i},intersectSphere:function(e,t){ce.subVectors(e.center,this.origin);var r=ce.dot(this.direction),n=ce.dot(ce)-r*r,a=e.radius*e.radius;if(n>a)return null;var o=Math.sqrt(a-n),i=r-o,s=r+o;return i<0&&s<0?null:i<0?this.at(s,t):this.at(i,t)},intersectsSphere:function(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius},distanceToPlane:function(e){var t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;var r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null},intersectPlane:function(e,t){var r=this.distanceToPlane(e);return null===r?null:this.at(r,t)},intersectsPlane:function(e){var t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0},intersectBox:function(e,t){var r,n,a,o,i,s,l=1/this.direction.x,c=1/this.direction.y,f=1/this.direction.z,d=this.origin;return l>=0?(r=(e.min.x-d.x)*l,n=(e.max.x-d.x)*l):(r=(e.max.x-d.x)*l,n=(e.min.x-d.x)*l),c>=0?(a=(e.min.y-d.y)*c,o=(e.max.y-d.y)*c):(a=(e.max.y-d.y)*c,o=(e.min.y-d.y)*c),r>o||a>n?null:((a>r||r!=r)&&(r=a),(o<n||n!=n)&&(n=o),f>=0?(i=(e.min.z-d.z)*f,s=(e.max.z-d.z)*f):(i=(e.max.z-d.z)*f,s=(e.min.z-d.z)*f),r>s||i>n?null:((i>r||r!=r)&&(r=i),(s<n||n!=n)&&(n=s),n<0?null:this.at(r>=0?r:n,t)))},intersectsBox:function(e){return null!==this.intersectBox(e,ce)},intersectTriangle:function(e,t,r,n,a){pe.subVectors(t,e),he.subVectors(r,e),ve.crossVectors(pe,he);var o,i=this.direction.dot(ve);if(i>0){if(n)return null;o=1}else{if(!(i<0))return null;o=-1,i=-i}ue.subVectors(this.origin,e);var s=o*this.direction.dot(he.crossVectors(ue,he));if(s<0)return null;var l=o*this.direction.dot(pe.cross(ue));if(l<0)return null;if(s+l>i)return null;var c=-o*ue.dot(ve);return c<0?null:this.at(c/i,a)},applyMatrix4:function(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this},equals:function(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}});var xe=new g,ge=new g,ye=new l;function Ee(e,t){this.normal=void 0!==e?e:new g(1,0,0),this.constant=void 0!==t?t:0}Object.assign(Ee.prototype,{isPlane:!0,set:function(e,t){return this.normal.copy(e),this.constant=t,this},setComponents:function(e,t,r,n){return this.normal.set(e,t,r),this.constant=n,this},setFromNormalAndCoplanarPoint:function(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this},setFromCoplanarPoints:function(e,t,r){var n=xe.subVectors(r,t).cross(ge.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(n,e),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.normal.copy(e.normal),this.constant=e.constant,this},normalize:function(){var e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this},negate:function(){return this.constant*=-1,this.normal.negate(),this},distanceToPoint:function(e){return this.normal.dot(e)+this.constant},distanceToSphere:function(e){return this.distanceToPoint(e.center)-e.radius},projectPoint:function(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new g),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)},intersectLine:function(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new g);var r=e.delta(xe),n=this.normal.dot(r);if(0===n)return 0===this.distanceToPoint(e.start)?t.copy(e.start):void 0;var a=-(e.start.dot(this.normal)+this.constant)/n;return a<0||a>1?void 0:t.copy(r).multiplyScalar(a).add(e.start)},intersectsLine:function(e){var t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0},intersectsBox:function(e){return e.intersectsPlane(this)},intersectsSphere:function(e){return e.intersectsPlane(this)},coplanarPoint:function(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new g),e.copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(e,t){var r=t||ye.getNormalMatrix(e),n=this.coplanarPoint(xe).applyMatrix4(e),a=this.normal.applyMatrix3(r).normalize();return this.constant=-n.dot(a),this},translate:function(e){return this.constant-=e.dot(this.normal),this},equals:function(e){return e.normal.equals(this.normal)&&e.constant===this.constant}});var we=new g,be=new g,Te=new g,_e=new g,Se=new g,Re=new g,Ae=new g,Me=new g,Ce=new g,Le=new g;function He(e,t,r){this.a=void 0!==e?e:new g,this.b=void 0!==t?t:new g,this.c=void 0!==r?r:new g}Object.assign(He,{getNormal:function(e,t,r,n){void 0===n&&(console.warn("THREE.Triangle: .getNormal() target is now required"),n=new g),n.subVectors(r,t),we.subVectors(e,t),n.cross(we);var a=n.lengthSq();return a>0?n.multiplyScalar(1/Math.sqrt(a)):n.set(0,0,0)},getBarycoord:function(e,t,r,n,a){we.subVectors(n,t),be.subVectors(r,t),Te.subVectors(e,t);var o=we.dot(we),i=we.dot(be),s=we.dot(Te),l=be.dot(be),c=be.dot(Te),f=o*l-i*i;if(void 0===a&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),a=new g),0===f)return a.set(-2,-1,-1);var d=1/f,u=(l*s-i*c)*d,p=(o*c-i*s)*d;return a.set(1-u-p,p,u)},containsPoint:function(e,t,r,n){return He.getBarycoord(e,t,r,n,_e),_e.x>=0&&_e.y>=0&&_e.x+_e.y<=1},getUV:function(e,t,r,n,a,o,i,s){return this.getBarycoord(e,t,r,n,_e),s.set(0,0),s.addScaledVector(a,_e.x),s.addScaledVector(o,_e.y),s.addScaledVector(i,_e.z),s},isFrontFacing:function(e,t,r,n){return we.subVectors(r,t),be.subVectors(e,t),we.cross(be).dot(n)<0}}),Object.assign(He.prototype,{set:function(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this},setFromPointsAndIndices:function(e,t,r,n){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[n]),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this},getArea:function(){return we.subVectors(this.c,this.b),be.subVectors(this.a,this.b),.5*we.cross(be).length()},getMidpoint:function(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new g),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},getNormal:function(e){return He.getNormal(this.a,this.b,this.c,e)},getPlane:function(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new Ee),e.setFromCoplanarPoints(this.a,this.b,this.c)},getBarycoord:function(e,t){return He.getBarycoord(e,this.a,this.b,this.c,t)},getUV:function(e,t,r,n,a){return He.getUV(e,this.a,this.b,this.c,t,r,n,a)},containsPoint:function(e){return He.containsPoint(e,this.a,this.b,this.c)},isFrontFacing:function(e){return He.isFrontFacing(this.a,this.b,this.c,e)},intersectsBox:function(e){return e.intersectsTriangle(this)},closestPointToPoint:function(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new g);var r,n,a=this.a,o=this.b,i=this.c;Se.subVectors(o,a),Re.subVectors(i,a),Me.subVectors(e,a);var s=Se.dot(Me),l=Re.dot(Me);if(s<=0&&l<=0)return t.copy(a);Ce.subVectors(e,o);var c=Se.dot(Ce),f=Re.dot(Ce);if(c>=0&&f<=c)return t.copy(o);var d=s*f-c*l;if(d<=0&&s>=0&&c<=0)return r=s/(s-c),t.copy(a).addScaledVector(Se,r);Le.subVectors(e,i);var u=Se.dot(Le),p=Re.dot(Le);if(p>=0&&u<=p)return t.copy(i);var h=u*l-s*p;if(h<=0&&l>=0&&p<=0)return n=l/(l-p),t.copy(a).addScaledVector(Re,n);var v=c*p-u*f;if(v<=0&&f-c>=0&&u-p>=0)return Ae.subVectors(i,o),n=(f-c)/(f-c+(u-p)),t.copy(o).addScaledVector(Ae,n);var m=1/(v+h+d);return r=h*m,n=d*m,t.copy(a).addScaledVector(Se,r).addScaledVector(Re,n)},equals:function(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}});var Pe={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ze={h:0,s:0,l:0},ke={h:0,s:0,l:0};function Ne(e,t,r){return void 0===t&&void 0===r?this.set(e):this.setRGB(e,t,r)}function De(e,t,r){return r<0&&(r+=1),r>1&&(r-=1),r<1/6?e+6*(t-e)*r:r<.5?t:r<2/3?e+6*(t-e)*(2/3-r):e}function Fe(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Ie(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}function Oe(e,t,r,n,a,o){this.a=e,this.b=t,this.c=r,this.normal=n&&n.isVector3?n:new g,this.vertexNormals=Array.isArray(n)?n:[],this.color=a&&a.isColor?a:new Ne,this.vertexColors=Array.isArray(a)?a:[],this.materialIndex=void 0!==o?o:0}Object.assign(Ne.prototype,{isColor:!0,r:1,g:1,b:1,set:function(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this},setScalar:function(e){return this.r=e,this.g=e,this.b=e,this},setHex:function(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this},setRGB:function(e,t,r){return this.r=e,this.g=t,this.b=r,this},setHSL:function(e,t,r){if(e=i.euclideanModulo(e,1),t=i.clamp(t,0,1),r=i.clamp(r,0,1),0===t)this.r=this.g=this.b=r;else{var n=r<=.5?r*(1+t):r+t-r*t,a=2*r-n;this.r=De(a,n,e+1/3),this.g=De(a,n,e),this.b=De(a,n,e-1/3)}return this},setStyle:function(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}var r;if(r=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)){var n,a=r[1],o=r[2];switch(a){case"rgb":case"rgba":if(n=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(n[1],10))/255,this.g=Math.min(255,parseInt(n[2],10))/255,this.b=Math.min(255,parseInt(n[3],10))/255,t(n[5]),this;if(n=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(n[1],10))/100,this.g=Math.min(100,parseInt(n[2],10))/100,this.b=Math.min(100,parseInt(n[3],10))/100,t(n[5]),this;break;case"hsl":case"hsla":if(n=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)){var i=parseFloat(n[1])/360,s=parseInt(n[2],10)/100,l=parseInt(n[3],10)/100;return t(n[5]),this.setHSL(i,s,l)}}}else if(r=/^\#([A-Fa-f0-9]+)$/.exec(e)){var c=r[1],f=c.length;if(3===f)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===f)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this},setColorName:function(e){var t=Pe[e];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(e){return this.r=e.r,this.g=e.g,this.b=e.b,this},copyGammaToLinear:function(e,t){return void 0===t&&(t=2),this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this},copyLinearToGamma:function(e,t){void 0===t&&(t=2);var r=t>0?1/t:1;return this.r=Math.pow(e.r,r),this.g=Math.pow(e.g,r),this.b=Math.pow(e.b,r),this},convertGammaToLinear:function(e){return this.copyGammaToLinear(this,e),this},convertLinearToGamma:function(e){return this.copyLinearToGamma(this,e),this},copySRGBToLinear:function(e){return this.r=Fe(e.r),this.g=Fe(e.g),this.b=Fe(e.b),this},copyLinearToSRGB:function(e){return this.r=Ie(e.r),this.g=Ie(e.g),this.b=Ie(e.b),this},convertSRGBToLinear:function(){return this.copySRGBToLinear(this),this},convertLinearToSRGB:function(){return this.copyLinearToSRGB(this),this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});var t,r,n=this.r,a=this.g,o=this.b,i=Math.max(n,a,o),s=Math.min(n,a,o),l=(s+i)/2;if(s===i)t=0,r=0;else{var c=i-s;switch(r=l<=.5?c/(i+s):c/(2-i-s),i){case n:t=(a-o)/c+(a<o?6:0);break;case a:t=(o-n)/c+2;break;case o:t=(n-a)/c+4}t/=6}return e.h=t,e.s=r,e.l=l,e},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(e,t,r){return this.getHSL(ze),ze.h+=e,ze.s+=t,ze.l+=r,this.setHSL(ze.h,ze.s,ze.l),this},add:function(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this},addColors:function(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this},addScalar:function(e){return this.r+=e,this.g+=e,this.b+=e,this},sub:function(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this},multiply:function(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this},multiplyScalar:function(e){return this.r*=e,this.g*=e,this.b*=e,this},lerp:function(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this},lerpHSL:function(e,t){this.getHSL(ze),e.getHSL(ke);var r=i.lerp(ze.h,ke.h,t),n=i.lerp(ze.s,ke.s,t),a=i.lerp(ze.l,ke.l,t);return this.setHSL(r,n,a),this},equals:function(e){return e.r===this.r&&e.g===this.g&&e.b===this.b},fromArray:function(e,t){return void 0===t&&(t=0),this.r=e[t],this.g=e[t+1],this.b=e[t+2],this},toArray:function(e,t){return void 0===e&&(e=[]),void 0===t&&(t=0),e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e},fromBufferAttribute:function(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this},toJSON:function(){return this.getHex()}}),Ne.NAMES=Pe,Object.assign(Oe.prototype,{clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(var t=0,r=e.vertexNormals.length;t<r;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(var n=0,a=e.vertexColors.length;n<a;n++)this.vertexColors[n]=e.vertexColors[n].clone();return this}});var Ue=0;function Ge(){Object.defineProperty(this,"id",{value:Ue++}),this.uuid=i.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=0,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}function Be(e){Ge.call(this),this.type="MeshBasicMaterial",this.color=new Ne(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Ge.prototype=Object.assign(Object.create(t.prototype),{constructor:Ge,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(var t in e){var r=e[t];if(void 0!==r)if("shading"!==t){var n=this[t];void 0!==n?n&&n.isColor?n.set(r):n&&n.isVector3&&r&&r.isVector3?n.copy(r):this[t]=r:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}else console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===r;else console.warn("THREE.Material: '"+t+"' parameter is undefined.")}},toJSON:function(e){var t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});var r={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function n(e){var t=[];for(var r in e){var n=e[r];delete n.metadata,t.push(n)}return t}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),void 0!==this.roughness&&(r.roughness=this.roughness),void 0!==this.metalness&&(r.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(r.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),void 0!==this.shininess&&(r.shininess=this.shininess),void 0!==this.clearcoat&&(r.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,r.reflectivity=this.reflectivity,r.refractionRatio=this.refractionRatio,void 0!==this.combine&&(r.combine=this.combine),void 0!==this.envMapIntensity&&(r.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(r.size=this.size),void 0!==this.sizeAttenuation&&(r.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(r.blending=this.blending),!0===this.flatShading&&(r.flatShading=this.flatShading),0!==this.side&&(r.side=this.side),this.vertexColors&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),!0===this.transparent&&(r.transparent=this.transparent),r.depthFunc=this.depthFunc,r.depthTest=this.depthTest,r.depthWrite=this.depthWrite,r.stencilWrite=this.stencilWrite,r.stencilWriteMask=this.stencilWriteMask,r.stencilFunc=this.stencilFunc,r.stencilRef=this.stencilRef,r.stencilFuncMask=this.stencilFuncMask,r.stencilFail=this.stencilFail,r.stencilZFail=this.stencilZFail,r.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(r.rotation=this.rotation),!0===this.polygonOffset&&(r.polygonOffset=!0),0!==this.polygonOffsetFactor&&(r.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(r.linewidth=this.linewidth),void 0!==this.dashSize&&(r.dashSize=this.dashSize),void 0!==this.gapSize&&(r.gapSize=this.gapSize),void 0!==this.scale&&(r.scale=this.scale),!0===this.dithering&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),!0===this.premultipliedAlpha&&(r.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(r.wireframe=this.wireframe),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(r.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(r.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(r.morphTargets=!0),!0===this.morphNormals&&(r.morphNormals=!0),!0===this.skinning&&(r.skinning=!0),!1===this.visible&&(r.visible=!1),!1===this.toneMapped&&(r.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),t){var a=n(e.textures),o=n(e.images);a.length>0&&(r.textures=a),o.length>0&&(r.images=o)}return r},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;var t=e.clippingPlanes,r=null;if(null!==t){var n=t.length;r=new Array(n);for(var a=0;a!==n;++a)r[a]=t[a].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Ge.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Be.prototype=Object.create(Ge.prototype),Be.prototype.constructor=Be,Be.prototype.isMeshBasicMaterial=!0,Be.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};var Ve=new g,je=new s;function We(e,t,r){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===r,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}function qe(e,t,r){We.call(this,new Int8Array(e),t,r)}function Xe(e,t,r){We.call(this,new Uint8Array(e),t,r)}function Ye(e,t,r){We.call(this,new Uint8ClampedArray(e),t,r)}function Ze(e,t,r){We.call(this,new Int16Array(e),t,r)}function Qe(e,t,r){We.call(this,new Uint16Array(e),t,r)}function Ke(e,t,r){We.call(this,new Int32Array(e),t,r)}function Je(e,t,r){We.call(this,new Uint32Array(e),t,r)}function $e(e,t,r){We.call(this,new Float32Array(e),t,r)}function et(e,t,r){We.call(this,new Float64Array(e),t,r)}function tt(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}function rt(e){if(0===e.length)return-1/0;for(var t=e[0],r=1,n=e.length;r<n;++r)e[r]>t&&(t=e[r]);return t}Object.defineProperty(We.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(We.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,r){e*=this.itemSize,r*=t.itemSize;for(var n=0,a=this.itemSize;n<a;n++)this.array[e+n]=t.array[r+n];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){for(var t=this.array,r=0,n=0,a=e.length;n<a;n++){var o=e[n];void 0===o&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",n),o=new Ne),t[r++]=o.r,t[r++]=o.g,t[r++]=o.b}return this},copyVector2sArray:function(e){for(var t=this.array,r=0,n=0,a=e.length;n<a;n++){var o=e[n];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",n),o=new s),t[r++]=o.x,t[r++]=o.y}return this},copyVector3sArray:function(e){for(var t=this.array,r=0,n=0,a=e.length;n<a;n++){var o=e[n];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",n),o=new g),t[r++]=o.x,t[r++]=o.y,t[r++]=o.z}return this},copyVector4sArray:function(e){for(var t=this.array,r=0,n=0,a=e.length;n<a;n++){var o=e[n];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",n),o=new u),t[r++]=o.x,t[r++]=o.y,t[r++]=o.z,t[r++]=o.w}return this},applyMatrix3:function(e){if(2===this.itemSize)for(var t=0,r=this.count;t<r;t++)je.fromBufferAttribute(this,t),je.applyMatrix3(e),this.setXY(t,je.x,je.y);else if(3===this.itemSize)for(var n=0,a=this.count;n<a;n++)Ve.fromBufferAttribute(this,n),Ve.applyMatrix3(e),this.setXYZ(n,Ve.x,Ve.y,Ve.z);return this},applyMatrix4:function(e){for(var t=0,r=this.count;t<r;t++)Ve.x=this.getX(t),Ve.y=this.getY(t),Ve.z=this.getZ(t),Ve.applyMatrix4(e),this.setXYZ(t,Ve.x,Ve.y,Ve.z);return this},applyNormalMatrix:function(e){for(var t=0,r=this.count;t<r;t++)Ve.x=this.getX(t),Ve.y=this.getY(t),Ve.z=this.getZ(t),Ve.applyNormalMatrix(e),this.setXYZ(t,Ve.x,Ve.y,Ve.z);return this},transformDirection:function(e){for(var t=0,r=this.count;t<r;t++)Ve.x=this.getX(t),Ve.y=this.getY(t),Ve.z=this.getZ(t),Ve.transformDirection(e),this.setXYZ(t,Ve.x,Ve.y,Ve.z);return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this},setXYZ:function(e,t,r,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=n,this},setXYZW:function(e,t,r,n,a){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=n,this.array[e+3]=a,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}}),qe.prototype=Object.create(We.prototype),qe.prototype.constructor=qe,Xe.prototype=Object.create(We.prototype),Xe.prototype.constructor=Xe,Ye.prototype=Object.create(We.prototype),Ye.prototype.constructor=Ye,Ze.prototype=Object.create(We.prototype),Ze.prototype.constructor=Ze,Qe.prototype=Object.create(We.prototype),Qe.prototype.constructor=Qe,Ke.prototype=Object.create(We.prototype),Ke.prototype.constructor=Ke,Je.prototype=Object.create(We.prototype),Je.prototype.constructor=Je,$e.prototype=Object.create(We.prototype),$e.prototype.constructor=$e,et.prototype=Object.create(We.prototype),et.prototype.constructor=et,Object.assign(tt.prototype,{computeGroups:function(e){var t,r,n=[],a=void 0,o=e.faces;for(r=0;r<o.length;r++){var i=o[r];i.materialIndex!==a&&(a=i.materialIndex,void 0!==t&&(t.count=3*r-t.start,n.push(t)),t={start:3*r,materialIndex:a})}void 0!==t&&(t.count=3*r-t.start,n.push(t)),this.groups=n},fromGeometry:function(e){var t,r=e.faces,n=e.vertices,a=e.faceVertexUvs,o=a[0]&&a[0].length>0,i=a[1]&&a[1].length>0,l=e.morphTargets,c=l.length;if(c>0){t=[];for(var f=0;f<c;f++)t[f]={name:l[f].name,data:[]};this.morphTargets.position=t}var d,u=e.morphNormals,p=u.length;if(p>0){d=[];for(var h=0;h<p;h++)d[h]={name:u[h].name,data:[]};this.morphTargets.normal=d}var v=e.skinIndices,m=e.skinWeights,x=v.length===n.length,g=m.length===n.length;n.length>0&&0===r.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(var y=0;y<r.length;y++){var E=r[y];this.vertices.push(n[E.a],n[E.b],n[E.c]);var w=E.vertexNormals;if(3===w.length)this.normals.push(w[0],w[1],w[2]);else{var b=E.normal;this.normals.push(b,b,b)}var T=E.vertexColors;if(3===T.length)this.colors.push(T[0],T[1],T[2]);else{var _=E.color;this.colors.push(_,_,_)}if(!0===o){var S=a[0][y];void 0!==S?this.uvs.push(S[0],S[1],S[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",y),this.uvs.push(new s,new s,new s))}if(!0===i){var R=a[1][y];void 0!==R?this.uvs2.push(R[0],R[1],R[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",y),this.uvs2.push(new s,new s,new s))}for(var A=0;A<c;A++){var M=l[A].vertices;t[A].data.push(M[E.a],M[E.b],M[E.c])}for(var C=0;C<p;C++){var L=u[C].vertexNormals[y];d[C].data.push(L.a,L.b,L.c)}x&&this.skinIndices.push(v[E.a],v[E.b],v[E.c]),g&&this.skinWeights.push(m[E.a],m[E.b],m[E.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}});var nt=1,at=new R,ot=new j,it=new g,st=new oe,lt=new oe,ct=new g;function ft(){Object.defineProperty(this,"id",{value:nt+=2}),this.uuid=i.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}ft.prototype=Object.assign(Object.create(t.prototype),{constructor:ft,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){Array.isArray(e)?this.index=new(rt(e)>65535?Je:Qe)(e,1):this.index=e},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},addGroup:function(e,t,r){this.groups.push({start:e,count:t,materialIndex:void 0!==r?r:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){var t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);var r=this.attributes.normal;if(void 0!==r){var n=(new l).getNormalMatrix(e);r.applyNormalMatrix(n),r.needsUpdate=!0}var a=this.attributes.tangent;return void 0!==a&&(a.transformDirection(e),a.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},rotateX:function(e){return at.makeRotationX(e),this.applyMatrix4(at),this},rotateY:function(e){return at.makeRotationY(e),this.applyMatrix4(at),this},rotateZ:function(e){return at.makeRotationZ(e),this.applyMatrix4(at),this},translate:function(e,t,r){return at.makeTranslation(e,t,r),this.applyMatrix4(at),this},scale:function(e,t,r){return at.makeScale(e,t,r),this.applyMatrix4(at),this},lookAt:function(e){return ot.lookAt(e),ot.updateMatrix(),this.applyMatrix4(ot.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(it).negate(),this.translate(it.x,it.y,it.z),this},setFromObject:function(e){var t=e.geometry;if(e.isPoints||e.isLine){var r=new $e(3*t.vertices.length,3),n=new $e(3*t.colors.length,3);if(this.setAttribute("position",r.copyVector3sArray(t.vertices)),this.setAttribute("color",n.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){var a=new $e(t.lineDistances.length,1);this.setAttribute("lineDistance",a.copyArray(t.lineDistances))}null!==t.boundingSphere&&(this.boundingSphere=t.boundingSphere.clone()),null!==t.boundingBox&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){for(var t=[],r=0,n=e.length;r<n;r++){var a=e[r];t.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new $e(t,3)),this},updateFromObject:function(e){var t=e.geometry;if(e.isMesh){var r=t.__directGeometry;if(!0===t.elementsNeedUpdate&&(r=void 0,t.elementsNeedUpdate=!1),void 0===r)return this.fromGeometry(t);r.verticesNeedUpdate=t.verticesNeedUpdate,r.normalsNeedUpdate=t.normalsNeedUpdate,r.colorsNeedUpdate=t.colorsNeedUpdate,r.uvsNeedUpdate=t.uvsNeedUpdate,r.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=r}if(!0===t.verticesNeedUpdate){var n=this.attributes.position;void 0!==n&&(n.copyVector3sArray(t.vertices),n.needsUpdate=!0),t.verticesNeedUpdate=!1}if(!0===t.normalsNeedUpdate){var a=this.attributes.normal;void 0!==a&&(a.copyVector3sArray(t.normals),a.needsUpdate=!0),t.normalsNeedUpdate=!1}if(!0===t.colorsNeedUpdate){var o=this.attributes.color;void 0!==o&&(o.copyColorsArray(t.colors),o.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){var i=this.attributes.uv;void 0!==i&&(i.copyVector2sArray(t.uvs),i.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){var s=this.attributes.lineDistance;void 0!==s&&(s.copyArray(t.lineDistances),s.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=(new tt).fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){var t=new Float32Array(3*e.vertices.length);if(this.setAttribute("position",new We(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){var r=new Float32Array(3*e.normals.length);this.setAttribute("normal",new We(r,3).copyVector3sArray(e.normals))}if(e.colors.length>0){var n=new Float32Array(3*e.colors.length);this.setAttribute("color",new We(n,3).copyColorsArray(e.colors))}if(e.uvs.length>0){var a=new Float32Array(2*e.uvs.length);this.setAttribute("uv",new We(a,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){var o=new Float32Array(2*e.uvs2.length);this.setAttribute("uv2",new We(o,2).copyVector2sArray(e.uvs2))}for(var i in this.groups=e.groups,e.morphTargets){for(var s=[],l=e.morphTargets[i],c=0,f=l.length;c<f;c++){var d=l[c],u=new $e(3*d.data.length,3);u.name=d.name,s.push(u.copyVector3sArray(d.data))}this.morphAttributes[i]=s}if(e.skinIndices.length>0){var p=new $e(4*e.skinIndices.length,4);this.setAttribute("skinIndex",p.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){var h=new $e(4*e.skinWeights.length,4);this.setAttribute("skinWeight",h.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new oe);var e=this.attributes.position,t=this.morphAttributes.position;if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(var r=0,n=t.length;r<n;r++){var a=t[r];st.setFromBufferAttribute(a),this.morphTargetsRelative?(ct.addVectors(this.boundingBox.min,st.min),this.boundingBox.expandByPoint(ct),ct.addVectors(this.boundingBox.max,st.max),this.boundingBox.expandByPoint(ct)):(this.boundingBox.expandByPoint(st.min),this.boundingBox.expandByPoint(st.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new le);var e=this.attributes.position,t=this.morphAttributes.position;if(e){var r=this.boundingSphere.center;if(st.setFromBufferAttribute(e),t)for(var n=0,a=t.length;n<a;n++){var o=t[n];lt.setFromBufferAttribute(o),this.morphTargetsRelative?(ct.addVectors(st.min,lt.min),st.expandByPoint(ct),ct.addVectors(st.max,lt.max),st.expandByPoint(ct)):(st.expandByPoint(lt.min),st.expandByPoint(lt.max))}st.getCenter(r);for(var i=0,s=0,l=e.count;s<l;s++)ct.fromBufferAttribute(e,s),i=Math.max(i,r.distanceToSquared(ct));if(t)for(var c=0,f=t.length;c<f;c++)for(var d=t[c],u=this.morphTargetsRelative,p=0,h=d.count;p<h;p++)ct.fromBufferAttribute(d,p),u&&(it.fromBufferAttribute(e,p),ct.add(it)),i=Math.max(i,r.distanceToSquared(ct));this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){var e=this.index,t=this.getAttribute("position");if(void 0!==t){var r=this.getAttribute("normal");if(void 0===r)r=new We(new Float32Array(3*t.count),3),this.setAttribute("normal",r);else for(var n=0,a=r.count;n<a;n++)r.setXYZ(n,0,0,0);var o=new g,i=new g,s=new g,l=new g,c=new g,f=new g,d=new g,u=new g;if(e)for(var p=0,h=e.count;p<h;p+=3){var v=e.getX(p+0),m=e.getX(p+1),x=e.getX(p+2);o.fromBufferAttribute(t,v),i.fromBufferAttribute(t,m),s.fromBufferAttribute(t,x),d.subVectors(s,i),u.subVectors(o,i),d.cross(u),l.fromBufferAttribute(r,v),c.fromBufferAttribute(r,m),f.fromBufferAttribute(r,x),l.add(d),c.add(d),f.add(d),r.setXYZ(v,l.x,l.y,l.z),r.setXYZ(m,c.x,c.y,c.z),r.setXYZ(x,f.x,f.y,f.z)}else for(var y=0,E=t.count;y<E;y+=3)o.fromBufferAttribute(t,y+0),i.fromBufferAttribute(t,y+1),s.fromBufferAttribute(t,y+2),d.subVectors(s,i),u.subVectors(o,i),d.cross(u),r.setXYZ(y+0,d.x,d.y,d.z),r.setXYZ(y+1,d.x,d.y,d.z),r.setXYZ(y+2,d.x,d.y,d.z);this.normalizeNormals(),r.needsUpdate=!0}},merge:function(e,t){if(e&&e.isBufferGeometry){void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));var r=this.attributes;for(var n in r)if(void 0!==e.attributes[n])for(var a=r[n].array,o=e.attributes[n],i=o.array,s=o.itemSize*t,l=Math.min(i.length,a.length-s),c=0,f=s;c<l;c++,f++)a[f]=i[c];return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e)},normalizeNormals:function(){for(var e=this.attributes.normal,t=0,r=e.count;t<r;t++)ct.fromBufferAttribute(e,t),ct.normalize(),e.setXYZ(t,ct.x,ct.y,ct.z)},toNonIndexed:function(){function e(e,t){for(var r=e.array,n=e.itemSize,a=e.normalized,o=new r.constructor(t.length*n),i=0,s=0,l=0,c=t.length;l<c;l++){i=t[l]*n;for(var f=0;f<n;f++)o[s++]=r[i++]}return new We(o,n,a)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;var t=new ft,r=this.index.array,n=this.attributes;for(var a in n){var o=e(n[a],r);t.setAttribute(a,o)}var i=this.morphAttributes;for(var s in i){for(var l=[],c=i[s],f=0,d=c.length;f<d;f++){var u=e(c[f],r);l.push(u)}t.morphAttributes[s]=l}t.morphTargetsRelative=this.morphTargetsRelative;for(var p=this.groups,h=0,v=p.length;h<v;h++){var m=p[h];t.addGroup(m.start,m.count,m.materialIndex)}return t},toJSON:function(){var e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){var t=this.parameters;for(var r in t)void 0!==t[r]&&(e[r]=t[r]);return e}e.data={attributes:{}};var n=this.index;null!==n&&(e.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});var a=this.attributes;for(var o in a){var i=a[o],s=i.toJSON(e.data);""!==i.name&&(s.name=i.name),e.data.attributes[o]=s}var l={},c=!1;for(var f in this.morphAttributes){for(var d=this.morphAttributes[f],u=[],p=0,h=d.length;p<h;p++){var v=d[p],m=v.toJSON(e.data);""!==v.name&&(m.name=v.name),u.push(m)}u.length>0&&(l[f]=u,c=!0)}c&&(e.data.morphAttributes=l,e.data.morphTargetsRelative=this.morphTargetsRelative);var x=this.groups;x.length>0&&(e.data.groups=JSON.parse(JSON.stringify(x)));var g=this.boundingSphere;return null!==g&&(e.data.boundingSphere={center:g.center.toArray(),radius:g.radius}),e},clone:function(){return(new ft).copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;var t={};this.name=e.name;var r=e.index;null!==r&&this.setIndex(r.clone(t));var n=e.attributes;for(var a in n){var o=n[a];this.setAttribute(a,o.clone(t))}var i=e.morphAttributes;for(var s in i){for(var l=[],c=i[s],f=0,d=c.length;f<d;f++)l.push(c[f].clone(t));this.morphAttributes[s]=l}this.morphTargetsRelative=e.morphTargetsRelative;for(var u=e.groups,p=0,h=u.length;p<h;p++){var v=u[p];this.addGroup(v.start,v.count,v.materialIndex)}var m=e.boundingBox;null!==m&&(this.boundingBox=m.clone());var x=e.boundingSphere;return null!==x&&(this.boundingSphere=x.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});var dt=new R,ut=new me,pt=new le,ht=new g,vt=new g,mt=new g,xt=new g,gt=new g,yt=new g,Et=new g,wt=new g,bt=new g,Tt=new s,_t=new s,St=new s,Rt=new g,At=new g;function Mt(e,t){j.call(this),this.type="Mesh",this.geometry=void 0!==e?e:new ft,this.material=void 0!==t?t:new Be,this.updateMorphTargets()}function Ct(e,t,r,n,a,o,i,s){if(null===(1===t.side?n.intersectTriangle(i,o,a,!0,s):n.intersectTriangle(a,o,i,2!==t.side,s)))return null;At.copy(s),At.applyMatrix4(e.matrixWorld);var l=r.ray.origin.distanceTo(At);return l<r.near||l>r.far?null:{distance:l,point:At.clone(),object:e}}function Lt(e,t,r,n,a,o,i,l,c,f,d,u){ht.fromBufferAttribute(a,f),vt.fromBufferAttribute(a,d),mt.fromBufferAttribute(a,u);var p=e.morphTargetInfluences;if(t.morphTargets&&o&&p){Et.set(0,0,0),wt.set(0,0,0),bt.set(0,0,0);for(var h=0,v=o.length;h<v;h++){var m=p[h],x=o[h];0!==m&&(xt.fromBufferAttribute(x,f),gt.fromBufferAttribute(x,d),yt.fromBufferAttribute(x,u),i?(Et.addScaledVector(xt,m),wt.addScaledVector(gt,m),bt.addScaledVector(yt,m)):(Et.addScaledVector(xt.sub(ht),m),wt.addScaledVector(gt.sub(vt),m),bt.addScaledVector(yt.sub(mt),m)))}ht.add(Et),vt.add(wt),mt.add(bt)}e.isSkinnedMesh&&(e.boneTransform(f,ht),e.boneTransform(d,vt),e.boneTransform(u,mt));var g=Ct(e,t,r,n,ht,vt,mt,Rt);if(g){l&&(Tt.fromBufferAttribute(l,f),_t.fromBufferAttribute(l,d),St.fromBufferAttribute(l,u),g.uv=He.getUV(Rt,ht,vt,mt,Tt,_t,St,new s)),c&&(Tt.fromBufferAttribute(c,f),_t.fromBufferAttribute(c,d),St.fromBufferAttribute(c,u),g.uv2=He.getUV(Rt,ht,vt,mt,Tt,_t,St,new s));var y=new Oe(f,d,u);He.getNormal(ht,vt,mt,y.normal),g.face=y}return g}Mt.prototype=Object.assign(Object.create(j.prototype),{constructor:Mt,isMesh:!0,copy:function(e){return j.prototype.copy.call(this,e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){var e=this.geometry;if(e.isBufferGeometry){var t=e.morphAttributes,r=Object.keys(t);if(r.length>0){var n=t[r[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var a=0,o=n.length;a<o;a++){var i=n[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=a}}}}else{var s=e.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){var r,n=this.geometry,a=this.material,o=this.matrixWorld;if(void 0!==a&&(null===n.boundingSphere&&n.computeBoundingSphere(),pt.copy(n.boundingSphere),pt.applyMatrix4(o),!1!==e.ray.intersectsSphere(pt)&&(dt.getInverse(o),ut.copy(e.ray).applyMatrix4(dt),null===n.boundingBox||!1!==ut.intersectsBox(n.boundingBox))))if(n.isBufferGeometry){var i=n.index,l=n.attributes.position,c=n.morphAttributes.position,f=n.morphTargetsRelative,d=n.attributes.uv,u=n.attributes.uv2,p=n.groups,h=n.drawRange;if(null!==i)if(Array.isArray(a))for(var v=0,m=p.length;v<m;v++)for(var x=p[v],g=a[x.materialIndex],y=Math.max(x.start,h.start),E=Math.min(x.start+x.count,h.start+h.count);y<E;y+=3){var w=i.getX(y),b=i.getX(y+1),T=i.getX(y+2);(r=Lt(this,g,e,ut,l,c,f,d,u,w,b,T))&&(r.faceIndex=Math.floor(y/3),r.face.materialIndex=x.materialIndex,t.push(r))}else for(var _=Math.max(0,h.start),S=Math.min(i.count,h.start+h.count);_<S;_+=3){var R=i.getX(_),A=i.getX(_+1),M=i.getX(_+2);(r=Lt(this,a,e,ut,l,c,f,d,u,R,A,M))&&(r.faceIndex=Math.floor(_/3),t.push(r))}else if(void 0!==l)if(Array.isArray(a))for(var C=0,L=p.length;C<L;C++)for(var H=p[C],P=a[H.materialIndex],z=Math.max(H.start,h.start),k=Math.min(H.start+H.count,h.start+h.count);z<k;z+=3)(r=Lt(this,P,e,ut,l,c,f,d,u,z,z+1,z+2))&&(r.faceIndex=Math.floor(z/3),r.face.materialIndex=H.materialIndex,t.push(r));else for(var N=Math.max(0,h.start),D=Math.min(l.count,h.start+h.count);N<D;N+=3)(r=Lt(this,a,e,ut,l,c,f,d,u,N,N+1,N+2))&&(r.faceIndex=Math.floor(N/3),t.push(r))}else if(n.isGeometry){var F,I=Array.isArray(a),O=n.vertices,U=n.faces,G=n.faceVertexUvs[0];G.length>0&&(F=G);for(var B=0,V=U.length;B<V;B++){var j=U[B],W=I?a[j.materialIndex]:a;if(void 0!==W){var q=O[j.a],X=O[j.b],Y=O[j.c];if(r=Ct(this,W,e,ut,q,X,Y,Rt)){if(F&&F[B]){var Z=F[B];Tt.copy(Z[0]),_t.copy(Z[1]),St.copy(Z[2]),r.uv=He.getUV(Rt,q,X,Y,Tt,_t,St,new s)}r.face=j,r.faceIndex=B,t.push(r)}}}}}});var Ht=0,Pt=new R,zt=new j,kt=new g;function Nt(){Object.defineProperty(this,"id",{value:Ht+=2}),this.uuid=i.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}function Dt(e,t,r,n,a,o){Nt.call(this),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:n,heightSegments:a,depthSegments:o},this.fromBufferGeometry(new Ft(e,t,r,n,a,o)),this.mergeVertices()}function Ft(e,t,r,n,a,o){void 0===e&&(e=1),void 0===t&&(t=1),void 0===r&&(r=1),void 0===n&&(n=1),void 0===a&&(a=1),void 0===o&&(o=1),ft.call(this),this.type="BoxBufferGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:n,heightSegments:a,depthSegments:o};var i=this;n=Math.floor(n),a=Math.floor(a),o=Math.floor(o);var s=[],l=[],c=[],f=[],d=0,u=0;function p(e,t,r,n,a,o,p,h,v,m,x){for(var y=o/v,E=p/m,w=o/2,b=p/2,T=h/2,_=v+1,S=m+1,R=0,A=0,M=new g,C=0;C<S;C++)for(var L=C*E-b,H=0;H<_;H++){var P=H*y-w;M[e]=P*n,M[t]=L*a,M[r]=T,l.push(M.x,M.y,M.z),M[e]=0,M[t]=0,M[r]=h>0?1:-1,c.push(M.x,M.y,M.z),f.push(H/v),f.push(1-C/m),R+=1}for(var z=0;z<m;z++)for(var k=0;k<v;k++){var N=d+k+_*z,D=d+k+_*(z+1),F=d+(k+1)+_*(z+1),I=d+(k+1)+_*z;s.push(N,D,I),s.push(D,F,I),A+=6}i.addGroup(u,A,x),u+=A,d+=R}p("z","y","x",-1,-1,r,t,e,o,a,0),p("z","y","x",1,-1,r,t,-e,o,a,1),p("x","z","y",1,1,e,r,t,n,o,2),p("x","z","y",1,-1,e,r,-t,n,o,3),p("x","y","z",1,-1,e,t,r,n,a,4),p("x","y","z",-1,-1,e,t,-r,n,a,5),this.setIndex(s),this.setAttribute("position",new $e(l,3)),this.setAttribute("normal",new $e(c,3)),this.setAttribute("uv",new $e(f,2))}function It(e){var t={};for(var r in e)for(var n in t[r]={},e[r]){var a=e[r][n];a&&(a.isColor||a.isMatrix3||a.isMatrix4||a.isVector2||a.isVector3||a.isVector4||a.isTexture)?t[r][n]=a.clone():Array.isArray(a)?t[r][n]=a.slice():t[r][n]=a}return t}function Ot(e){for(var t={},r=0;r<e.length;r++){var n=It(e[r]);for(var a in n)t[a]=n[a]}return t}Nt.prototype=Object.assign(Object.create(t.prototype),{constructor:Nt,isGeometry:!0,applyMatrix4:function(e){for(var t=(new l).getNormalMatrix(e),r=0,n=this.vertices.length;r<n;r++)this.vertices[r].applyMatrix4(e);for(var a=0,o=this.faces.length;a<o;a++){var i=this.faces[a];i.normal.applyMatrix3(t).normalize();for(var s=0,c=i.vertexNormals.length;s<c;s++)i.vertexNormals[s].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return Pt.makeRotationX(e),this.applyMatrix4(Pt),this},rotateY:function(e){return Pt.makeRotationY(e),this.applyMatrix4(Pt),this},rotateZ:function(e){return Pt.makeRotationZ(e),this.applyMatrix4(Pt),this},translate:function(e,t,r){return Pt.makeTranslation(e,t,r),this.applyMatrix4(Pt),this},scale:function(e,t,r){return Pt.makeScale(e,t,r),this.applyMatrix4(Pt),this},lookAt:function(e){return zt.lookAt(e),zt.updateMatrix(),this.applyMatrix4(zt.matrix),this},fromBufferGeometry:function(e){var t=this,r=null!==e.index?e.index:void 0,n=e.attributes;if(void 0===n.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;var a=n.position,o=n.normal,i=n.color,l=n.uv,c=n.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(var f=0;f<a.count;f++)t.vertices.push((new g).fromBufferAttribute(a,f)),void 0!==i&&t.colors.push((new Ne).fromBufferAttribute(i,f));function d(e,r,n,a){var f=void 0===i?[]:[t.colors[e].clone(),t.colors[r].clone(),t.colors[n].clone()],d=new Oe(e,r,n,void 0===o?[]:[(new g).fromBufferAttribute(o,e),(new g).fromBufferAttribute(o,r),(new g).fromBufferAttribute(o,n)],f,a);t.faces.push(d),void 0!==l&&t.faceVertexUvs[0].push([(new s).fromBufferAttribute(l,e),(new s).fromBufferAttribute(l,r),(new s).fromBufferAttribute(l,n)]),void 0!==c&&t.faceVertexUvs[1].push([(new s).fromBufferAttribute(c,e),(new s).fromBufferAttribute(c,r),(new s).fromBufferAttribute(c,n)])}var u=e.groups;if(u.length>0)for(var p=0;p<u.length;p++)for(var h=u[p],v=h.start,m=v,x=v+h.count;m<x;m+=3)void 0!==r?d(r.getX(m),r.getX(m+1),r.getX(m+2),h.materialIndex):d(m,m+1,m+2,h.materialIndex);else if(void 0!==r)for(var y=0;y<r.count;y+=3)d(r.getX(y),r.getX(y+1),r.getX(y+2));else for(var E=0;E<a.count;E+=3)d(E,E+1,E+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(kt).negate(),this.translate(kt.x,kt.y,kt.z),this},normalize:function(){this.computeBoundingSphere();var e=this.boundingSphere.center,t=this.boundingSphere.radius,r=0===t?1:1/t,n=new R;return n.set(r,0,0,-r*e.x,0,r,0,-r*e.y,0,0,r,-r*e.z,0,0,0,1),this.applyMatrix4(n),this},computeFaceNormals:function(){for(var e=new g,t=new g,r=0,n=this.faces.length;r<n;r++){var a=this.faces[r],o=this.vertices[a.a],i=this.vertices[a.b],s=this.vertices[a.c];e.subVectors(s,i),t.subVectors(o,i),e.cross(t),e.normalize(),a.normal.copy(e)}},computeVertexNormals:function(e){void 0===e&&(e=!0);for(var t=new Array(this.vertices.length),r=0,n=this.vertices.length;r<n;r++)t[r]=new g;if(e)for(var a=new g,o=new g,i=0,s=this.faces.length;i<s;i++){var l=this.faces[i],c=this.vertices[l.a],f=this.vertices[l.b],d=this.vertices[l.c];a.subVectors(d,f),o.subVectors(c,f),a.cross(o),t[l.a].add(a),t[l.b].add(a),t[l.c].add(a)}else{this.computeFaceNormals();for(var u=0,p=this.faces.length;u<p;u++){var h=this.faces[u];t[h.a].add(h.normal),t[h.b].add(h.normal),t[h.c].add(h.normal)}}for(var v=0,m=this.vertices.length;v<m;v++)t[v].normalize();for(var x=0,y=this.faces.length;x<y;x++){var E=this.faces[x],w=E.vertexNormals;3===w.length?(w[0].copy(t[E.a]),w[1].copy(t[E.b]),w[2].copy(t[E.c])):(w[0]=t[E.a].clone(),w[1]=t[E.b].clone(),w[2]=t[E.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(var e=0,t=this.faces.length;e<t;e++){var r=this.faces[e],n=r.vertexNormals;3===n.length?(n[0].copy(r.normal),n[1].copy(r.normal),n[2].copy(r.normal)):(n[0]=r.normal.clone(),n[1]=r.normal.clone(),n[2]=r.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(var e=0,t=this.faces.length;e<t;e++){var r=this.faces[e];r.__originalFaceNormal?r.__originalFaceNormal.copy(r.normal):r.__originalFaceNormal=r.normal.clone(),r.__originalVertexNormals||(r.__originalVertexNormals=[]);for(var n=0,a=r.vertexNormals.length;n<a;n++)r.__originalVertexNormals[n]?r.__originalVertexNormals[n].copy(r.vertexNormals[n]):r.__originalVertexNormals[n]=r.vertexNormals[n].clone()}var o=new Nt;o.faces=this.faces;for(var i=0,s=this.morphTargets.length;i<s;i++){if(!this.morphNormals[i]){this.morphNormals[i]={},this.morphNormals[i].faceNormals=[],this.morphNormals[i].vertexNormals=[];for(var l=this.morphNormals[i].faceNormals,c=this.morphNormals[i].vertexNormals,f=0,d=this.faces.length;f<d;f++){var u=new g,p={a:new g,b:new g,c:new g};l.push(u),c.push(p)}}var h=this.morphNormals[i];o.vertices=this.morphTargets[i].vertices,o.computeFaceNormals(),o.computeVertexNormals();for(var v=0,m=this.faces.length;v<m;v++){var x=this.faces[v],y=h.faceNormals[v],E=h.vertexNormals[v];y.copy(x.normal),E.a.copy(x.vertexNormals[0]),E.b.copy(x.vertexNormals[1]),E.c.copy(x.vertexNormals[2])}}for(var w=0,b=this.faces.length;w<b;w++){var T=this.faces[w];T.normal=T.__originalFaceNormal,T.vertexNormals=T.__originalVertexNormals}},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new oe),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new le),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,r){if(e&&e.isGeometry){var n,a=this.vertices.length,o=this.vertices,i=e.vertices,s=this.faces,c=e.faces,f=this.colors,d=e.colors;void 0===r&&(r=0),void 0!==t&&(n=(new l).getNormalMatrix(t));for(var u=0,p=i.length;u<p;u++){var h=i[u].clone();void 0!==t&&h.applyMatrix4(t),o.push(h)}for(var v=0,m=d.length;v<m;v++)f.push(d[v].clone());for(var x=0,g=c.length;x<g;x++){var y=c[x],E=void 0,w=void 0,b=void 0,T=y.vertexNormals,_=y.vertexColors;(E=new Oe(y.a+a,y.b+a,y.c+a)).normal.copy(y.normal),void 0!==n&&E.normal.applyMatrix3(n).normalize();for(var S=0,R=T.length;S<R;S++)w=T[S].clone(),void 0!==n&&w.applyMatrix3(n).normalize(),E.vertexNormals.push(w);E.color.copy(y.color);for(var A=0,M=_.length;A<M;A++)b=_[A],E.vertexColors.push(b.clone());E.materialIndex=y.materialIndex+r,s.push(E)}for(var C=0,L=e.faceVertexUvs.length;C<L;C++){var H=e.faceVertexUvs[C];void 0===this.faceVertexUvs[C]&&(this.faceVertexUvs[C]=[]);for(var P=0,z=H.length;P<z;P++){for(var k=H[P],N=[],D=0,F=k.length;D<F;D++)N.push(k[D].clone());this.faceVertexUvs[C].push(N)}}}else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e)},mergeMesh:function(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)},mergeVertices:function(){for(var e={},t=[],r=[],n=Math.pow(10,4),a=0,o=this.vertices.length;a<o;a++){var i=this.vertices[a],s=Math.round(i.x*n)+"_"+Math.round(i.y*n)+"_"+Math.round(i.z*n);void 0===e[s]?(e[s]=a,t.push(this.vertices[a]),r[a]=t.length-1):r[a]=r[e[s]]}for(var l=[],c=0,f=this.faces.length;c<f;c++){var d=this.faces[c];d.a=r[d.a],d.b=r[d.b],d.c=r[d.c];for(var u=[d.a,d.b,d.c],p=0;p<3;p++)if(u[p]===u[(p+1)%3]){l.push(c);break}}for(var h=l.length-1;h>=0;h--){var v=l[h];this.faces.splice(v,1);for(var m=0,x=this.faceVertexUvs.length;m<x;m++)this.faceVertexUvs[m].splice(v,1)}var g=this.vertices.length-t.length;return this.vertices=t,g},setFromPoints:function(e){this.vertices=[];for(var t=0,r=e.length;t<r;t++){var n=e[t];this.vertices.push(new g(n.x,n.y,n.z||0))}return this},sortFacesByMaterialIndex:function(){for(var e=this.faces,t=e.length,r=0;r<t;r++)e[r]._id=r;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));var n,a,o=this.faceVertexUvs[0],i=this.faceVertexUvs[1];o&&o.length===t&&(n=[]),i&&i.length===t&&(a=[]);for(var s=0;s<t;s++){var l=e[s]._id;n&&n.push(o[l]),a&&a.push(i[l])}n&&(this.faceVertexUvs[0]=n),a&&(this.faceVertexUvs[1]=a)},toJSON:function(){var e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){var t=this.parameters;for(var r in t)void 0!==t[r]&&(e[r]=t[r]);return e}for(var n=[],a=0;a<this.vertices.length;a++){var o=this.vertices[a];n.push(o.x,o.y,o.z)}for(var i=[],s=[],l={},c=[],f={},d=[],u={},p=0;p<this.faces.length;p++){var h=this.faces[p],v=void 0!==this.faceVertexUvs[0][p],m=h.normal.length()>0,x=h.vertexNormals.length>0,g=1!==h.color.r||1!==h.color.g||1!==h.color.b,y=h.vertexColors.length>0,E=0;if(E=_(E,0,0),E=_(E,1,!0),E=_(E,2,!1),E=_(E,3,v),E=_(E,4,m),E=_(E,5,x),E=_(E,6,g),E=_(E,7,y),i.push(E),i.push(h.a,h.b,h.c),i.push(h.materialIndex),v){var w=this.faceVertexUvs[0][p];i.push(A(w[0]),A(w[1]),A(w[2]))}if(m&&i.push(S(h.normal)),x){var b=h.vertexNormals;i.push(S(b[0]),S(b[1]),S(b[2]))}if(g&&i.push(R(h.color)),y){var T=h.vertexColors;i.push(R(T[0]),R(T[1]),R(T[2]))}}function _(e,t,r){return r?e|1<<t:e&~(1<<t)}function S(e){var t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==l[t]||(l[t]=s.length/3,s.push(e.x,e.y,e.z)),l[t]}function R(e){var t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==f[t]||(f[t]=c.length,c.push(e.getHex())),f[t]}function A(e){var t=e.x.toString()+e.y.toString();return void 0!==u[t]||(u[t]=d.length/2,d.push(e.x,e.y)),u[t]}return e.data={},e.data.vertices=n,e.data.normals=s,c.length>0&&(e.data.colors=c),d.length>0&&(e.data.uvs=[d]),e.data.faces=i,e},clone:function(){return(new Nt).copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;for(var t=e.vertices,r=0,n=t.length;r<n;r++)this.vertices.push(t[r].clone());for(var a=e.colors,o=0,i=a.length;o<i;o++)this.colors.push(a[o].clone());for(var s=e.faces,l=0,c=s.length;l<c;l++)this.faces.push(s[l].clone());for(var f=0,d=e.faceVertexUvs.length;f<d;f++){var u=e.faceVertexUvs[f];void 0===this.faceVertexUvs[f]&&(this.faceVertexUvs[f]=[]);for(var p=0,h=u.length;p<h;p++){for(var v=u[p],m=[],x=0,g=v.length;x<g;x++){var y=v[x];m.push(y.clone())}this.faceVertexUvs[f].push(m)}}for(var E=e.morphTargets,w=0,b=E.length;w<b;w++){var T={};if(T.name=E[w].name,void 0!==E[w].vertices){T.vertices=[];for(var _=0,S=E[w].vertices.length;_<S;_++)T.vertices.push(E[w].vertices[_].clone())}if(void 0!==E[w].normals){T.normals=[];for(var R=0,A=E[w].normals.length;R<A;R++)T.normals.push(E[w].normals[R].clone())}this.morphTargets.push(T)}for(var M=e.morphNormals,C=0,L=M.length;C<L;C++){var H={};if(void 0!==M[C].vertexNormals){H.vertexNormals=[];for(var P=0,z=M[C].vertexNormals.length;P<z;P++){var k=M[C].vertexNormals[P],N={};N.a=k.a.clone(),N.b=k.b.clone(),N.c=k.c.clone(),H.vertexNormals.push(N)}}if(void 0!==M[C].faceNormals){H.faceNormals=[];for(var D=0,F=M[C].faceNormals.length;D<F;D++)H.faceNormals.push(M[C].faceNormals[D].clone())}this.morphNormals.push(H)}for(var I=e.skinWeights,O=0,U=I.length;O<U;O++)this.skinWeights.push(I[O].clone());for(var G=e.skinIndices,B=0,V=G.length;B<V;B++)this.skinIndices.push(G[B].clone());for(var j=e.lineDistances,W=0,q=j.length;W<q;W++)this.lineDistances.push(j[W]);var X=e.boundingBox;null!==X&&(this.boundingBox=X.clone());var Y=e.boundingSphere;return null!==Y&&(this.boundingSphere=Y.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Dt.prototype=Object.create(Nt.prototype),Dt.prototype.constructor=Dt,Ft.prototype=Object.create(ft.prototype),Ft.prototype.constructor=Ft;var Ut={clone:It,merge:Ot};function Gt(e){Ge.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}function Bt(){j.call(this),this.type="Camera",this.matrixWorldInverse=new R,this.projectionMatrix=new R,this.projectionMatrixInverse=new R}function Vt(e,t,r,n){Bt.call(this),this.type="PerspectiveCamera",this.fov=void 0!==e?e:50,this.zoom=1,this.near=void 0!==r?r:.1,this.far=void 0!==n?n:2e3,this.focus=10,this.aspect=void 0!==t?t:1,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}function jt(e,t,r){if(j.call(this),this.type="CubeCamera",!0===r.isWebGLCubeRenderTarget){this.renderTarget=r;var n=new Vt(90,1,e,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new g(1,0,0)),this.add(n);var a=new Vt(90,1,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new g(-1,0,0)),this.add(a);var o=new Vt(90,1,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new g(0,1,0)),this.add(o);var i=new Vt(90,1,e,t);i.layers=this.layers,i.up.set(0,0,-1),i.lookAt(new g(0,-1,0)),this.add(i);var s=new Vt(90,1,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new g(0,0,1)),this.add(s);var l=new Vt(90,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new g(0,0,-1)),this.add(l),this.update=function(e,t){null===this.parent&&this.updateMatrixWorld();var c=e.xr.enabled,f=e.getRenderTarget();e.xr.enabled=!1;var d=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0),e.render(t,n),e.setRenderTarget(r,1),e.render(t,a),e.setRenderTarget(r,2),e.render(t,o),e.setRenderTarget(r,3),e.render(t,i),e.setRenderTarget(r,4),e.render(t,s),r.texture.generateMipmaps=d,e.setRenderTarget(r,5),e.render(t,l),e.setRenderTarget(f),e.xr.enabled=c},this.clear=function(e,t,n,a){for(var o=e.getRenderTarget(),i=0;i<6;i++)e.setRenderTarget(r,i),e.clear(t,n,a);e.setRenderTarget(o)}}else console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.")}function Wt(e,t,r){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=r),p.call(this,e,e,t)}function qt(e,t,r,n,a,o,i,s,l,c,f,u){d.call(this,null,o,i,s,l,c,n,a,f,u),this.image={data:e||null,width:t||1,height:r||1},this.magFilter=void 0!==l?l:1003,this.minFilter=void 0!==c?c:1003,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Gt.prototype=Object.create(Ge.prototype),Gt.prototype.constructor=Gt,Gt.prototype.isShaderMaterial=!0,Gt.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=It(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this},Gt.prototype.toJSON=function(e){var t=Ge.prototype.toJSON.call(this,e);for(var r in t.uniforms={},this.uniforms){var n=this.uniforms[r].value;n&&n.isTexture?t.uniforms[r]={type:"t",value:n.toJSON(e).uuid}:n&&n.isColor?t.uniforms[r]={type:"c",value:n.getHex()}:n&&n.isVector2?t.uniforms[r]={type:"v2",value:n.toArray()}:n&&n.isVector3?t.uniforms[r]={type:"v3",value:n.toArray()}:n&&n.isVector4?t.uniforms[r]={type:"v4",value:n.toArray()}:n&&n.isMatrix3?t.uniforms[r]={type:"m3",value:n.toArray()}:n&&n.isMatrix4?t.uniforms[r]={type:"m4",value:n.toArray()}:t.uniforms[r]={value:n}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;var a={};for(var o in this.extensions)!0===this.extensions[o]&&(a[o]=!0);return Object.keys(a).length>0&&(t.extensions=a),t},Bt.prototype=Object.assign(Object.create(j.prototype),{constructor:Bt,isCamera:!0,copy:function(e,t){return j.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new g),this.updateMatrixWorld(!0);var t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){j.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.getInverse(this.matrixWorld)},updateWorldMatrix:function(e,t){j.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.getInverse(this.matrixWorld)},clone:function(){return(new this.constructor).copy(this)}}),Vt.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Vt,isPerspectiveCamera:!0,copy:function(e,t){return Bt.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){var t=.5*this.getFilmHeight()/e;this.fov=2*i.RAD2DEG*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){var e=Math.tan(.5*i.DEG2RAD*this.fov);return.5*this.getFilmHeight()/e},getEffectiveFOV:function(){return 2*i.RAD2DEG*Math.atan(Math.tan(.5*i.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,r,n,a,o){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){var e=this.near,t=e*Math.tan(.5*i.DEG2RAD*this.fov)/this.zoom,r=2*t,n=this.aspect*r,a=-.5*n,o=this.view;if(null!==this.view&&this.view.enabled){var s=o.fullWidth,l=o.fullHeight;a+=o.offsetX*n/s,t-=o.offsetY*r/l,n*=o.width/s,r*=o.height/l}var c=this.filmOffset;0!==c&&(a+=e*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(a,a+n,t,t-r,e,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){var t=j.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}),jt.prototype=Object.create(j.prototype),jt.prototype.constructor=jt,Wt.prototype=Object.create(p.prototype),Wt.prototype.constructor=Wt,Wt.prototype.isWebGLCubeRenderTarget=!0,Wt.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=1023,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;var r=new W,n="\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t#include <begin_vertex>\n\t\t\t\t#include <project_vertex>\n\n\t\t\t}\n\t\t",a="\n\n\t\t\tuniform sampler2D tEquirect;\n\n\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t}\n\t\t",o=new Gt({name:"CubemapFromEquirect",uniforms:It({tEquirect:{value:null}}),vertexShader:n,fragmentShader:a,side:1,blending:0});o.uniforms.tEquirect.value=t;var i=new Mt(new Ft(5,5,5),o);return r.add(i),new jt(1,10,this).update(e,r),i.geometry.dispose(),i.material.dispose(),this},qt.prototype=Object.create(d.prototype),qt.prototype.constructor=qt,qt.prototype.isDataTexture=!0;var Xt=new le,Yt=new g;function Zt(e,t,r,n,a,o){this.planes=[void 0!==e?e:new Ee,void 0!==t?t:new Ee,void 0!==r?r:new Ee,void 0!==n?n:new Ee,void 0!==a?a:new Ee,void 0!==o?o:new Ee]}Object.assign(Zt.prototype,{set:function(e,t,r,n,a,o){var i=this.planes;return i[0].copy(e),i[1].copy(t),i[2].copy(r),i[3].copy(n),i[4].copy(a),i[5].copy(o),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){for(var t=this.planes,r=0;r<6;r++)t[r].copy(e.planes[r]);return this},setFromProjectionMatrix:function(e){var t=this.planes,r=e.elements,n=r[0],a=r[1],o=r[2],i=r[3],s=r[4],l=r[5],c=r[6],f=r[7],d=r[8],u=r[9],p=r[10],h=r[11],v=r[12],m=r[13],x=r[14],g=r[15];return t[0].setComponents(i-n,f-s,h-d,g-v).normalize(),t[1].setComponents(i+n,f+s,h+d,g+v).normalize(),t[2].setComponents(i+a,f+l,h+u,g+m).normalize(),t[3].setComponents(i-a,f-l,h-u,g-m).normalize(),t[4].setComponents(i-o,f-c,h-p,g-x).normalize(),t[5].setComponents(i+o,f+c,h+p,g+x).normalize(),this},intersectsObject:function(e){var t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Xt.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Xt)},intersectsSprite:function(e){return Xt.center.set(0,0,0),Xt.radius=.7071067811865476,Xt.applyMatrix4(e.matrixWorld),this.intersectsSphere(Xt)},intersectsSphere:function(e){for(var t=this.planes,r=e.center,n=-e.radius,a=0;a<6;a++)if(t[a].distanceToPoint(r)<n)return!1;return!0},intersectsBox:function(e){for(var t=this.planes,r=0;r<6;r++){var n=t[r];if(Yt.x=n.normal.x>0?e.max.x:e.min.x,Yt.y=n.normal.y>0?e.max.y:e.min.y,Yt.z=n.normal.z>0?e.max.z:e.min.z,n.distanceToPoint(Yt)<0)return!1}return!0},containsPoint:function(e){for(var t=this.planes,r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}});var Qt={common:{diffuse:{value:new Ne(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new l},uv2Transform:{value:new l},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new s(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ne(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Ne(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new l}},sprite:{diffuse:{value:new Ne(15658734)},opacity:{value:1},center:{value:new s(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new l}}};function Kt(){var e=null,t=!1,r=null,n=null;function a(t,o){r(t,o),n=e.requestAnimationFrame(a)}return{start:function(){!0!==t&&null!==r&&(n=e.requestAnimationFrame(a),t=!0)},stop:function(){e.cancelAnimationFrame(n),t=!1},setAnimationLoop:function(e){r=e},setContext:function(t){e=t}}}function Jt(e,t){var r=t.isWebGL2,n=new WeakMap;return{get:function(e){return e.isInterleavedBufferAttribute&&(e=e.data),n.get(e)},remove:function(t){t.isInterleavedBufferAttribute&&(t=t.data);var r=n.get(t);r&&(e.deleteBuffer(r.buffer),n.delete(t))},update:function(t,a){t.isInterleavedBufferAttribute&&(t=t.data);var o=n.get(t);void 0===o?n.set(t,function(t,r){var n=t.array,a=t.usage,o=e.createBuffer();e.bindBuffer(r,o),e.bufferData(r,n,a),t.onUploadCallback();var i=5126;return n instanceof Float32Array?i=5126:n instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):n instanceof Uint16Array?i=5123:n instanceof Int16Array?i=5122:n instanceof Uint32Array?i=5125:n instanceof Int32Array?i=5124:n instanceof Int8Array?i=5120:n instanceof Uint8Array&&(i=5121),{buffer:o,type:i,bytesPerElement:n.BYTES_PER_ELEMENT,version:t.version}}(t,a)):o.version<t.version&&(function(t,n,a){var o=n.array,i=n.updateRange;e.bindBuffer(a,t),-1===i.count?e.bufferSubData(a,0,o):(r?e.bufferSubData(a,i.offset*o.BYTES_PER_ELEMENT,o,i.offset,i.count):e.bufferSubData(a,i.offset*o.BYTES_PER_ELEMENT,o.subarray(i.offset,i.offset+i.count)),i.count=-1)}(o.buffer,t,a),o.version=t.version)}}}function $t(e,t,r,n){Nt.call(this),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:n},this.fromBufferGeometry(new er(e,t,r,n)),this.mergeVertices()}function er(e,t,r,n){ft.call(this),this.type="PlaneBufferGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:n};for(var a=(e=e||1)/2,o=(t=t||1)/2,i=Math.floor(r)||1,s=Math.floor(n)||1,l=i+1,c=s+1,f=e/i,d=t/s,u=[],p=[],h=[],v=[],m=0;m<c;m++)for(var x=m*d-o,g=0;g<l;g++){var y=g*f-a;p.push(y,-x,0),h.push(0,0,1),v.push(g/i),v.push(1-m/s)}for(var E=0;E<s;E++)for(var w=0;w<i;w++){var b=w+l*E,T=w+l*(E+1),_=w+1+l*(E+1),S=w+1+l*E;u.push(b,T,S),u.push(T,_,S)}this.setIndex(u),this.setAttribute("position",new $e(p,3)),this.setAttribute("normal",new $e(h,3)),this.setAttribute("uv",new $e(v,2))}$t.prototype=Object.create(Nt.prototype),$t.prototype.constructor=$t,er.prototype=Object.create(ft.prototype),er.prototype.constructor=er;var tr={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_vertex:"#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);    } else if (face == 1.0) {\n      uv = vec2(-direction.x, -direction.z) / abs(direction.y);    } else if (face == 2.0) {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);    } else if (face == 3.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);    } else if (face == 4.0) {\n      uv = vec2(-direction.x, direction.z) / abs(direction.y);    } else {\n      uv = vec2(direction.x, direction.y) / abs(direction.z);    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV = equirectUv( reflectVec );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},rr={basic:{uniforms:Ot([Qt.common,Qt.specularmap,Qt.envmap,Qt.aomap,Qt.lightmap,Qt.fog]),vertexShader:tr.meshbasic_vert,fragmentShader:tr.meshbasic_frag},lambert:{uniforms:Ot([Qt.common,Qt.specularmap,Qt.envmap,Qt.aomap,Qt.lightmap,Qt.emissivemap,Qt.fog,Qt.lights,{emissive:{value:new Ne(0)}}]),vertexShader:tr.meshlambert_vert,fragmentShader:tr.meshlambert_frag},phong:{uniforms:Ot([Qt.common,Qt.specularmap,Qt.envmap,Qt.aomap,Qt.lightmap,Qt.emissivemap,Qt.bumpmap,Qt.normalmap,Qt.displacementmap,Qt.fog,Qt.lights,{emissive:{value:new Ne(0)},specular:{value:new Ne(1118481)},shininess:{value:30}}]),vertexShader:tr.meshphong_vert,fragmentShader:tr.meshphong_frag},standard:{uniforms:Ot([Qt.common,Qt.envmap,Qt.aomap,Qt.lightmap,Qt.emissivemap,Qt.bumpmap,Qt.normalmap,Qt.displacementmap,Qt.roughnessmap,Qt.metalnessmap,Qt.fog,Qt.lights,{emissive:{value:new Ne(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:tr.meshphysical_vert,fragmentShader:tr.meshphysical_frag},toon:{uniforms:Ot([Qt.common,Qt.aomap,Qt.lightmap,Qt.emissivemap,Qt.bumpmap,Qt.normalmap,Qt.displacementmap,Qt.gradientmap,Qt.fog,Qt.lights,{emissive:{value:new Ne(0)}}]),vertexShader:tr.meshtoon_vert,fragmentShader:tr.meshtoon_frag},matcap:{uniforms:Ot([Qt.common,Qt.bumpmap,Qt.normalmap,Qt.displacementmap,Qt.fog,{matcap:{value:null}}]),vertexShader:tr.meshmatcap_vert,fragmentShader:tr.meshmatcap_frag},points:{uniforms:Ot([Qt.points,Qt.fog]),vertexShader:tr.points_vert,fragmentShader:tr.points_frag},dashed:{uniforms:Ot([Qt.common,Qt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:tr.linedashed_vert,fragmentShader:tr.linedashed_frag},depth:{uniforms:Ot([Qt.common,Qt.displacementmap]),vertexShader:tr.depth_vert,fragmentShader:tr.depth_frag},normal:{uniforms:Ot([Qt.common,Qt.bumpmap,Qt.normalmap,Qt.displacementmap,{opacity:{value:1}}]),vertexShader:tr.normal_vert,fragmentShader:tr.normal_frag},sprite:{uniforms:Ot([Qt.sprite,Qt.fog]),vertexShader:tr.sprite_vert,fragmentShader:tr.sprite_frag},background:{uniforms:{uvTransform:{value:new l},t2D:{value:null}},vertexShader:tr.background_vert,fragmentShader:tr.background_frag},cube:{uniforms:Ot([Qt.envmap,{opacity:{value:1}}]),vertexShader:tr.cube_vert,fragmentShader:tr.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:tr.equirect_vert,fragmentShader:tr.equirect_frag},distanceRGBA:{uniforms:Ot([Qt.common,Qt.displacementmap,{referencePosition:{value:new g},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:tr.distanceRGBA_vert,fragmentShader:tr.distanceRGBA_frag},shadow:{uniforms:Ot([Qt.lights,Qt.fog,{color:{value:new Ne(0)},opacity:{value:1}}]),vertexShader:tr.shadow_vert,fragmentShader:tr.shadow_frag}};function nr(e,t,r,n){var a,o,i=new Ne(0),s=0,l=null,c=0,f=null;function d(e,r){t.buffers.color.setClear(e.r,e.g,e.b,r,n)}return{getClearColor:function(){return i},setClearColor:function(e,t){i.set(e),d(i,s=void 0!==t?t:1)},getClearAlpha:function(){return s},setClearAlpha:function(e){d(i,s=e)},render:function(t,n,u,p){var h=!0===n.isScene?n.background:null,v=e.xr,m=v.getSession&&v.getSession();if(m&&"additive"===m.environmentBlendMode&&(h=null),null===h?d(i,s):h&&h.isColor&&(d(h,1),p=!0),(e.autoClear||p)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),h&&(h.isCubeTexture||h.isWebGLCubeRenderTarget||306===h.mapping)){void 0===o&&((o=new Mt(new Ft(1,1,1),new Gt({name:"BackgroundCubeMaterial",uniforms:It(rr.cube.uniforms),vertexShader:rr.cube.vertexShader,fragmentShader:rr.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=function(e,t,r){this.matrixWorld.copyPosition(r.matrixWorld)},Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(o));var x=h.isWebGLCubeRenderTarget?h.texture:h;o.material.uniforms.envMap.value=x,o.material.uniforms.flipEnvMap.value=x.isCubeTexture?-1:1,l===h&&c===x.version&&f===e.toneMapping||(o.material.needsUpdate=!0,l=h,c=x.version,f=e.toneMapping),t.unshift(o,o.geometry,o.material,0,0,null)}else h&&h.isTexture&&(void 0===a&&((a=new Mt(new er(2,2),new Gt({name:"BackgroundMaterial",uniforms:It(rr.background.uniforms),vertexShader:rr.background.vertexShader,fragmentShader:rr.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(a)),a.material.uniforms.t2D.value=h,!0===h.matrixAutoUpdate&&h.updateMatrix(),a.material.uniforms.uvTransform.value.copy(h.matrix),l===h&&c===h.version&&f===e.toneMapping||(a.material.needsUpdate=!0,l=h,c=h.version,f=e.toneMapping),t.unshift(a,a.geometry,a.material,0,0,null))}}}function ar(e,t,r,n){var a=e.getParameter(34921),o=n.isWebGL2?null:t.get("OES_vertex_array_object"),i=n.isWebGL2||null!==o,s={},l=u(null),c=l;function f(t){return n.isWebGL2?e.bindVertexArray(t):o.bindVertexArrayOES(t)}function d(t){return n.isWebGL2?e.deleteVertexArray(t):o.deleteVertexArrayOES(t)}function u(e){for(var t=[],r=[],n=[],o=0;o<a;o++)t[o]=0,r[o]=0,n[o]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:r,attributeDivisors:n,object:e,attributes:{}}}function p(){for(var e=c.newAttributes,t=0,r=e.length;t<r;t++)e[t]=0}function h(e){v(e,0)}function v(r,a){var o=c.newAttributes,i=c.enabledAttributes,s=c.attributeDivisors;o[r]=1,0===i[r]&&(e.enableVertexAttribArray(r),i[r]=1),s[r]!==a&&((n.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](r,a),s[r]=a)}function m(){for(var t=c.newAttributes,r=c.enabledAttributes,n=0,a=r.length;n<a;n++)r[n]!==t[n]&&(e.disableVertexAttribArray(n),r[n]=0)}function x(t,r,a,o,i,s){!0!==n.isWebGL2||5124!==a&&5125!==a?e.vertexAttribPointer(t,r,a,o,i,s):e.vertexAttribIPointer(t,r,a,i,s)}function g(){y(),c!==l&&f((c=l).object)}function y(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function(a,l,d,g,y){var E=!1;if(i){var w=function(t,r,a){var i=!0===a.wireframe,l=s[t.id];void 0===l&&(l={},s[t.id]=l);var c=l[r.id];void 0===c&&(c={},l[r.id]=c);var f=c[i];return void 0===f&&(f=u(n.isWebGL2?e.createVertexArray():o.createVertexArrayOES()),c[i]=f),f}(g,d,l);c!==w&&f((c=w).object),(E=function(e){var t=c.attributes,r=e.attributes;if(Object.keys(t).length!==Object.keys(r).length)return!0;for(var n in r){var a=t[n],o=r[n];if(a.attribute!==o)return!0;if(a.data!==o.data)return!0}return!1}(g))&&function(e){var t={},r=e.attributes;for(var n in r){var a=r[n],o={};o.attribute=a,a.data&&(o.data=a.data),t[n]=o}c.attributes=t}(g)}else{var b=!0===l.wireframe;c.geometry===g.id&&c.program===d.id&&c.wireframe===b||(c.geometry=g.id,c.program=d.id,c.wireframe=b,E=!0)}!0===a.isInstancedMesh&&(E=!0),null!==y&&r.update(y,34963),E&&(function(a,o,i,s){if(!1!==n.isWebGL2||!a.isInstancedMesh&&!s.isInstancedBufferGeometry||null!==t.get("ANGLE_instanced_arrays")){p();var l=s.attributes,c=i.getAttributes(),f=o.defaultAttributeValues;for(var d in c){var u=c[d];if(u>=0){var g=l[d];if(void 0!==g){var y=g.normalized,E=g.itemSize,w=r.get(g);if(void 0===w)continue;var b=w.buffer,T=w.type,_=w.bytesPerElement;if(g.isInterleavedBufferAttribute){var S=g.data,R=S.stride,A=g.offset;S&&S.isInstancedInterleavedBuffer?(v(u,S.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=S.meshPerAttribute*S.count)):h(u),e.bindBuffer(34962,b),x(u,E,T,y,R*_,A*_)}else g.isInstancedBufferAttribute?(v(u,g.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=g.meshPerAttribute*g.count)):h(u),e.bindBuffer(34962,b),x(u,E,T,y,0,0)}else if("instanceMatrix"===d){var M=r.get(a.instanceMatrix);if(void 0===M)continue;var C=M.buffer,L=M.type;v(u+0,1),v(u+1,1),v(u+2,1),v(u+3,1),e.bindBuffer(34962,C),e.vertexAttribPointer(u+0,4,L,!1,64,0),e.vertexAttribPointer(u+1,4,L,!1,64,16),e.vertexAttribPointer(u+2,4,L,!1,64,32),e.vertexAttribPointer(u+3,4,L,!1,64,48)}else if(void 0!==f){var H=f[d];if(void 0!==H)switch(H.length){case 2:e.vertexAttrib2fv(u,H);break;case 3:e.vertexAttrib3fv(u,H);break;case 4:e.vertexAttrib4fv(u,H);break;default:e.vertexAttrib1fv(u,H)}}}}m()}}(a,l,d,g),null!==y&&e.bindBuffer(34963,r.get(y).buffer))},reset:g,resetDefaultState:y,dispose:function(){for(var e in g(),s){var t=s[e];for(var r in t){var n=t[r];for(var a in n)d(n[a].object),delete n[a];delete t[r]}delete s[e]}},releaseStatesOfGeometry:function(e){if(void 0!==s[e.id]){var t=s[e.id];for(var r in t){var n=t[r];for(var a in n)d(n[a].object),delete n[a];delete t[r]}delete s[e.id]}},releaseStatesOfProgram:function(e){for(var t in s){var r=s[t];if(void 0!==r[e.id]){var n=r[e.id];for(var a in n)d(n[a].object),delete n[a];delete r[e.id]}}},initAttributes:p,enableAttribute:h,disableUnusedAttributes:m}}function or(e,t,r,n){var a,o=n.isWebGL2;this.setMode=function(e){a=e},this.render=function(t,n){e.drawArrays(a,t,n),r.update(n,a,1)},this.renderInstances=function(n,i,s){if(0!==s){var l,c;if(o)l=e,c="drawArraysInstanced";else if(c="drawArraysInstancedANGLE",null===(l=t.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](a,n,i,s),r.update(i,a,s)}}}function ir(e,t,r){var n;function a(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}var o="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext,i=void 0!==r.precision?r.precision:"highp",s=a(i);s!==i&&(console.warn("THREE.WebGLRenderer:",i,"not supported, using",s,"instead."),i=s);var l=!0===r.logarithmicDepthBuffer,c=e.getParameter(34930),f=e.getParameter(35660),d=e.getParameter(3379),u=e.getParameter(34076),p=e.getParameter(34921),h=e.getParameter(36347),v=e.getParameter(36348),m=e.getParameter(36349),x=f>0,g=o||!!t.get("OES_texture_float");return{isWebGL2:o,getMaxAnisotropy:function(){if(void 0!==n)return n;var r=t.get("EXT_texture_filter_anisotropic");return n=null!==r?e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0},getMaxPrecision:a,precision:i,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:f,maxTextureSize:d,maxCubemapSize:u,maxAttributes:p,maxVertexUniforms:h,maxVaryings:v,maxFragmentUniforms:m,vertexTextures:x,floatFragmentTextures:g,floatVertexTextures:x&&g,maxSamples:o?e.getParameter(36183):0}}function sr(){var e=this,t=null,r=0,n=!1,a=!1,o=new Ee,i=new l,s={value:null,needsUpdate:!1};function c(){s.value!==t&&(s.value=t,s.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function f(t,r,n,a){var l=null!==t?t.length:0,c=null;if(0!==l){if(c=s.value,!0!==a||null===c){var f=n+4*l,d=r.matrixWorldInverse;i.getNormalMatrix(d),(null===c||c.length<f)&&(c=new Float32Array(f));for(var u=0,p=n;u!==l;++u,p+=4)o.copy(t[u]).applyMatrix4(d,i),o.normal.toArray(c,p),c[p+3]=o.constant}s.value=c,s.needsUpdate=!0}return e.numPlanes=l,e.numIntersection=0,c}this.uniform=s,this.numPlanes=0,this.numIntersection=0,this.init=function(e,a,o){var i=0!==e.length||a||0!==r||n;return n=a,t=f(e,o,0),r=e.length,i},this.beginShadows=function(){a=!0,f(null)},this.endShadows=function(){a=!1,c()},this.setState=function(e,o,i,l,d,u){if(!n||null===e||0===e.length||a&&!i)a?f(null):c();else{var p=a?0:r,h=4*p,v=d.clippingState||null;s.value=v,v=f(e,l,h,u);for(var m=0;m!==h;++m)v[m]=t[m];d.clippingState=v,this.numIntersection=o?this.numPlanes:0,this.numPlanes+=p}}}function lr(e){var t={};return{has:function(r){if(void 0!==t[r])return t[r];var n;switch(r){case"WEBGL_depth_texture":n=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=e.getExtension(r)}return t[r]=n,!!n},get:function(e){return this.has(e)||console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t[e]}}}function cr(e,t,r,n){var a=new WeakMap,o=new WeakMap;function i(e){var s=e.target,l=a.get(s);for(var c in null!==l.index&&t.remove(l.index),l.attributes)t.remove(l.attributes[c]);s.removeEventListener("dispose",i),a.delete(s);var f=o.get(l);f&&(t.remove(f),o.delete(l)),n.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,r.memory.geometries--}function s(e){var r=[],n=e.index,a=e.attributes.position,i=0;if(null!==n){var s=n.array;i=n.version;for(var l=0,c=s.length;l<c;l+=3){var f=s[l+0],d=s[l+1],u=s[l+2];r.push(f,d,d,u,u,f)}}else{var p=a.array;i=a.version;for(var h=0,v=p.length/3-1;h<v;h+=3){var m=h+0,x=h+1,g=h+2;r.push(m,x,x,g,g,m)}}var y=new(rt(r)>65535?Je:Qe)(r,1);y.version=i;var E=o.get(e);E&&t.remove(E),o.set(e,y)}return{get:function(e,t){var n=a.get(t);return n||(t.addEventListener("dispose",i),t.isBufferGeometry?n=t:t.isGeometry&&(void 0===t._bufferGeometry&&(t._bufferGeometry=(new ft).setFromObject(e)),n=t._bufferGeometry),a.set(t,n),r.memory.geometries++,n)},update:function(e){var r=e.attributes;for(var n in r)t.update(r[n],34962);var a=e.morphAttributes;for(var o in a)for(var i=a[o],s=0,l=i.length;s<l;s++)t.update(i[s],34962)},getWireframeAttribute:function(e){var t=o.get(e);if(t){var r=e.index;null!==r&&t.version<r.version&&s(e)}else s(e);return o.get(e)}}}function fr(e,t,r,n){var a,o,i,s=n.isWebGL2;this.setMode=function(e){a=e},this.setIndex=function(e){o=e.type,i=e.bytesPerElement},this.render=function(t,n){e.drawElements(a,n,o,t*i),r.update(n,a,1)},this.renderInstances=function(n,l,c){if(0!==c){var f,d;if(s)f=e,d="drawElementsInstanced";else if(d="drawElementsInstancedANGLE",null===(f=t.get("ANGLE_instanced_arrays")))return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");f[d](a,l,o,n*i,c),r.update(l,a,c)}}}function dr(e){var t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function(e,r,n){switch(t.calls++,r){case 4:t.triangles+=n*(e/3);break;case 1:t.lines+=n*(e/2);break;case 3:t.lines+=n*(e-1);break;case 2:t.lines+=n*e;break;case 0:t.points+=n*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}}}function ur(e,t){return e[0]-t[0]}function pr(e,t){return Math.abs(t[1])-Math.abs(e[1])}function hr(e){for(var t={},r=new Float32Array(8),n=[],a=0;a<8;a++)n[a]=[a,0];return{update:function(a,o,i,s){var l=a.morphTargetInfluences,c=void 0===l?0:l.length,f=t[o.id];if(void 0===f){f=[];for(var d=0;d<c;d++)f[d]=[d,0];t[o.id]=f}for(var u=0;u<c;u++){var p=f[u];p[0]=u,p[1]=l[u]}f.sort(pr);for(var h=0;h<8;h++)h<c&&f[h][1]?(n[h][0]=f[h][0],n[h][1]=f[h][1]):(n[h][0]=Number.MAX_SAFE_INTEGER,n[h][1]=0);n.sort(ur);for(var v=i.morphTargets&&o.morphAttributes.position,m=i.morphNormals&&o.morphAttributes.normal,x=0,g=0;g<8;g++){var y=n[g],E=y[0],w=y[1];E!==Number.MAX_SAFE_INTEGER&&w?(v&&o.getAttribute("morphTarget"+g)!==v[E]&&o.setAttribute("morphTarget"+g,v[E]),m&&o.getAttribute("morphNormal"+g)!==m[E]&&o.setAttribute("morphNormal"+g,m[E]),r[g]=w,x+=w):(v&&void 0!==o.getAttribute("morphTarget"+g)&&o.deleteAttribute("morphTarget"+g),m&&void 0!==o.getAttribute("morphNormal"+g)&&o.deleteAttribute("morphNormal"+g),r[g]=0)}var b=o.morphTargetsRelative?1:1-x;s.getUniforms().setValue(e,"morphTargetBaseInfluence",b),s.getUniforms().setValue(e,"morphTargetInfluences",r)}}}function vr(e,t,r,n){var a=new WeakMap;return{update:function(e){var o=n.render.frame,i=e.geometry,s=t.get(e,i);return a.get(s)!==o&&(i.isGeometry&&s.updateFromObject(e),t.update(s),a.set(s,o)),e.isInstancedMesh&&r.update(e.instanceMatrix,34962),s},dispose:function(){a=new WeakMap}}}function mr(e,t,r,n,a,o,i,s,l,c){e=void 0!==e?e:[],t=void 0!==t?t:301,i=void 0!==i?i:1022,d.call(this,e,t,r,n,a,o,i,s,l,c),this.flipY=!1}function xr(e,t,r,n){d.call(this,null),this.image={data:e||null,width:t||1,height:r||1,depth:n||1},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function gr(e,t,r,n){d.call(this,null),this.image={data:e||null,width:t||1,height:r||1,depth:n||1},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}rr.physical={uniforms:Ot([rr.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new s(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ne(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:tr.meshphysical_vert,fragmentShader:tr.meshphysical_frag},mr.prototype=Object.create(d.prototype),mr.prototype.constructor=mr,mr.prototype.isCubeTexture=!0,Object.defineProperty(mr.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}}),xr.prototype=Object.create(d.prototype),xr.prototype.constructor=xr,xr.prototype.isDataTexture2DArray=!0,gr.prototype=Object.create(d.prototype),gr.prototype.constructor=gr,gr.prototype.isDataTexture3D=!0;var yr=new d,Er=new xr,wr=new gr,br=new mr,Tr=[],_r=[],Sr=new Float32Array(16),Rr=new Float32Array(9),Ar=new Float32Array(4);function Mr(e,t,r){var n=e[0];if(n<=0||n>0)return e;var a=t*r,o=Tr[a];if(void 0===o&&(o=new Float32Array(a),Tr[a]=o),0!==t){n.toArray(o,0);for(var i=1,s=0;i!==t;++i)s+=r,e[i].toArray(o,s)}return o}function Cr(e,t){if(e.length!==t.length)return!1;for(var r=0,n=e.length;r<n;r++)if(e[r]!==t[r])return!1;return!0}function Lr(e,t){for(var r=0,n=t.length;r<n;r++)e[r]=t[r]}function Hr(e,t){var r=_r[t];void 0===r&&(r=new Int32Array(t),_r[t]=r);for(var n=0;n!==t;++n)r[n]=e.allocateTextureUnit();return r}function Pr(e,t){var r=this.cache;r[0]!==t&&(e.uniform1f(this.addr,t),r[0]=t)}function zr(e,t){var r=this.cache;if(void 0!==t.x)r[0]===t.x&&r[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),r[0]=t.x,r[1]=t.y);else{if(Cr(r,t))return;e.uniform2fv(this.addr,t),Lr(r,t)}}function kr(e,t){var r=this.cache;if(void 0!==t.x)r[0]===t.x&&r[1]===t.y&&r[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),r[0]=t.x,r[1]=t.y,r[2]=t.z);else if(void 0!==t.r)r[0]===t.r&&r[1]===t.g&&r[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),r[0]=t.r,r[1]=t.g,r[2]=t.b);else{if(Cr(r,t))return;e.uniform3fv(this.addr,t),Lr(r,t)}}function Nr(e,t){var r=this.cache;if(void 0!==t.x)r[0]===t.x&&r[1]===t.y&&r[2]===t.z&&r[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),r[0]=t.x,r[1]=t.y,r[2]=t.z,r[3]=t.w);else{if(Cr(r,t))return;e.uniform4fv(this.addr,t),Lr(r,t)}}function Dr(e,t){var r=this.cache,n=t.elements;if(void 0===n){if(Cr(r,t))return;e.uniformMatrix2fv(this.addr,!1,t),Lr(r,t)}else{if(Cr(r,n))return;Ar.set(n),e.uniformMatrix2fv(this.addr,!1,Ar),Lr(r,n)}}function Fr(e,t){var r=this.cache,n=t.elements;if(void 0===n){if(Cr(r,t))return;e.uniformMatrix3fv(this.addr,!1,t),Lr(r,t)}else{if(Cr(r,n))return;Rr.set(n),e.uniformMatrix3fv(this.addr,!1,Rr),Lr(r,n)}}function Ir(e,t){var r=this.cache,n=t.elements;if(void 0===n){if(Cr(r,t))return;e.uniformMatrix4fv(this.addr,!1,t),Lr(r,t)}else{if(Cr(r,n))return;Sr.set(n),e.uniformMatrix4fv(this.addr,!1,Sr),Lr(r,n)}}function Or(e,t,r){var n=this.cache,a=r.allocateTextureUnit();n[0]!==a&&(e.uniform1i(this.addr,a),n[0]=a),r.safeSetTexture2D(t||yr,a)}function Ur(e,t,r){var n=this.cache,a=r.allocateTextureUnit();n[0]!==a&&(e.uniform1i(this.addr,a),n[0]=a),r.setTexture2DArray(t||Er,a)}function Gr(e,t,r){var n=this.cache,a=r.allocateTextureUnit();n[0]!==a&&(e.uniform1i(this.addr,a),n[0]=a),r.setTexture3D(t||wr,a)}function Br(e,t,r){var n=this.cache,a=r.allocateTextureUnit();n[0]!==a&&(e.uniform1i(this.addr,a),n[0]=a),r.safeSetTextureCube(t||br,a)}function Vr(e,t){var r=this.cache;r[0]!==t&&(e.uniform1i(this.addr,t),r[0]=t)}function jr(e,t){var r=this.cache;Cr(r,t)||(e.uniform2iv(this.addr,t),Lr(r,t))}function Wr(e,t){var r=this.cache;Cr(r,t)||(e.uniform3iv(this.addr,t),Lr(r,t))}function qr(e,t){var r=this.cache;Cr(r,t)||(e.uniform4iv(this.addr,t),Lr(r,t))}function Xr(e,t){var r=this.cache;r[0]!==t&&(e.uniform1ui(this.addr,t),r[0]=t)}function Yr(e,t){e.uniform1fv(this.addr,t)}function Zr(e,t){e.uniform1iv(this.addr,t)}function Qr(e,t){e.uniform2iv(this.addr,t)}function Kr(e,t){e.uniform3iv(this.addr,t)}function Jr(e,t){e.uniform4iv(this.addr,t)}function $r(e,t){var r=Mr(t,this.size,2);e.uniform2fv(this.addr,r)}function en(e,t){var r=Mr(t,this.size,3);e.uniform3fv(this.addr,r)}function tn(e,t){var r=Mr(t,this.size,4);e.uniform4fv(this.addr,r)}function rn(e,t){var r=Mr(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,r)}function nn(e,t){var r=Mr(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,r)}function an(e,t){var r=Mr(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,r)}function on(e,t,r){var n=t.length,a=Hr(r,n);e.uniform1iv(this.addr,a);for(var o=0;o!==n;++o)r.safeSetTexture2D(t[o]||yr,a[o])}function sn(e,t,r){var n=t.length,a=Hr(r,n);e.uniform1iv(this.addr,a);for(var o=0;o!==n;++o)r.safeSetTextureCube(t[o]||br,a[o])}function ln(e,t,r){this.id=e,this.addr=r,this.cache=[],this.setValue=function(e){switch(e){case 5126:return Pr;case 35664:return zr;case 35665:return kr;case 35666:return Nr;case 35674:return Dr;case 35675:return Fr;case 35676:return Ir;case 5124:case 35670:return Vr;case 35667:case 35671:return jr;case 35668:case 35672:return Wr;case 35669:case 35673:return qr;case 5125:return Xr;case 35678:case 36198:case 36298:case 36306:case 35682:return Or;case 35679:case 36299:case 36307:return Gr;case 35680:case 36300:case 36308:case 36293:return Br;case 36289:case 36303:case 36311:case 36292:return Ur}}(t.type)}function cn(e,t,r){this.id=e,this.addr=r,this.cache=[],this.size=t.size,this.setValue=function(e){switch(e){case 5126:return Yr;case 35664:return $r;case 35665:return en;case 35666:return tn;case 35674:return rn;case 35675:return nn;case 35676:return an;case 5124:case 35670:return Zr;case 35667:case 35671:return Qr;case 35668:case 35672:return Kr;case 35669:case 35673:return Jr;case 35678:case 36198:case 36298:case 36306:case 35682:return on;case 35680:case 36300:case 36308:case 36293:return sn}}(t.type)}function fn(e){this.id=e,this.seq=[],this.map={}}cn.prototype.updateCache=function(e){var t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),Lr(t,e)},fn.prototype.setValue=function(e,t,r){for(var n=this.seq,a=0,o=n.length;a!==o;++a){var i=n[a];i.setValue(e,t[i.id],r)}};var dn=/([\w\d_]+)(\])?(\[|\.)?/g;function un(e,t){e.seq.push(t),e.map[t.id]=t}function pn(e,t,r){var n=e.name,a=n.length;for(dn.lastIndex=0;;){var o=dn.exec(n),i=dn.lastIndex,s=o[1],l="]"===o[2],c=o[3];if(l&&(s|=0),void 0===c||"["===c&&i+2===a){un(r,void 0===c?new ln(s,e,t):new cn(s,e,t));break}var f=r.map[s];void 0===f&&un(r,f=new fn(s)),r=f}}function hn(e,t){this.seq=[],this.map={};for(var r=e.getProgramParameter(t,35718),n=0;n<r;++n){var a=e.getActiveUniform(t,n);pn(a,e.getUniformLocation(t,a.name),this)}}function vn(e,t,r){var n=e.createShader(t);return e.shaderSource(n,r),e.compileShader(n),n}hn.prototype.setValue=function(e,t,r,n){var a=this.map[t];void 0!==a&&a.setValue(e,r,n)},hn.prototype.setOptional=function(e,t,r){var n=t[r];void 0!==n&&this.setValue(e,r,n)},hn.upload=function(e,t,r,n){for(var a=0,o=t.length;a!==o;++a){var i=t[a],s=r[i.id];!1!==s.needsUpdate&&i.setValue(e,s.value,n)}},hn.seqWithValue=function(e,t){for(var r=[],n=0,a=e.length;n!==a;++n){var o=e[n];o.id in t&&r.push(o)}return r};var mn=0;function xn(e){switch(e){case 3e3:return["Linear","( value )"];case 3001:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function gn(e,t,r){var n=e.getShaderParameter(t,35713),a=e.getShaderInfoLog(t).trim();return n&&""===a?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+r+"\n"+a+function(e){for(var t=e.split("\n"),r=0;r<t.length;r++)t[r]=r+1+": "+t[r];return t.join("\n")}(e.getShaderSource(t))}function yn(e,t){var r=xn(t);return"vec4 "+e+"( vec4 value ) { return "+r[0]+"ToLinear"+r[1]+"; }"}function En(e,t){var r;switch(t){case 1:r="Linear";break;case 2:r="Reinhard";break;case 3:r="OptimizedCineon";break;case 4:r="ACESFilmic";break;case 5:r="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),r="Linear"}return"vec3 "+e+"( vec3 color ) { return "+r+"ToneMapping( color ); }"}function wn(e){return""!==e}function bn(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Tn(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}var _n=/^[ \t]*#include +<([\w\d./]+)>/gm;function Sn(e){return e.replace(_n,Rn)}function Rn(e,t){var r=tr[t];if(void 0===r)throw new Error("Can not resolve #include <"+t+">");return Sn(r)}var An=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Mn=/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;function Cn(e){return e.replace(Mn,Hn).replace(An,Ln)}function Ln(e,t,r,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Hn(0,t,r,n)}function Hn(e,t,r,n){for(var a="",o=parseInt(t);o<parseInt(r);o++)a+=n.replace(/\[ i \]/g,"[ "+o+" ]").replace(/UNROLLED_LOOP_INDEX/g,o);return a}function Pn(e){var t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function zn(e,t,r,n){var a,o,i,s,l,c=e.getContext(),f=r.defines,d=r.vertexShader,u=r.fragmentShader,p=function(e){var t="SHADOWMAP_TYPE_BASIC";return 1===e.shadowMapType?t="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?t="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(t="SHADOWMAP_TYPE_VSM"),t}(r),h=function(e){var t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case 301:case 302:t="ENVMAP_TYPE_CUBE";break;case 306:case 307:t="ENVMAP_TYPE_CUBE_UV";break;case 303:case 304:t="ENVMAP_TYPE_EQUIREC"}return t}(r),v=function(e){var t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case 302:case 304:case 307:t="ENVMAP_MODE_REFRACTION"}return t}(r),m=function(e){var t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case 0:t="ENVMAP_BLENDING_MULTIPLY";break;case 1:t="ENVMAP_BLENDING_MIX";break;case 2:t="ENVMAP_BLENDING_ADD"}return t}(r),x=e.gammaFactor>0?e.gammaFactor:1,g=r.isWebGL2?"":function(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(wn).join("\n")}(r),y=function(e){var t=[];for(var r in e){var n=e[r];!1!==n&&t.push("#define "+r+" "+n)}return t.join("\n")}(f),E=c.createProgram();r.isRawShaderMaterial?((a=[y].filter(wn).join("\n")).length>0&&(a+="\n"),(o=[g,y].filter(wn).join("\n")).length>0&&(o+="\n")):(a=[Pn(r),"#define SHADER_NAME "+r.shaderName,y,r.instancing?"#define USE_INSTANCING":"",r.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+x,"#define MAX_BONES "+r.maxBones,r.useFog&&r.fog?"#define USE_FOG":"",r.useFog&&r.fogExp2?"#define FOG_EXP2":"",r.map?"#define USE_MAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+v:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.normalMap&&r.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",r.normalMap&&r.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",r.clearcoatMap?"#define USE_CLEARCOATMAP":"",r.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",r.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",r.displacementMap&&r.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.transmissionMap?"#define USE_TRANSMISSIONMAP":"",r.vertexTangents?"#define USE_TANGENT":"",r.vertexColors?"#define USE_COLOR":"",r.vertexUvs?"#define USE_UV":"",r.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",r.flatShading?"#define FLAT_SHADED":"",r.skinning?"#define USE_SKINNING":"",r.useVertexTexture?"#define BONE_TEXTURE":"",r.morphTargets?"#define USE_MORPHTARGETS":"",r.morphNormals&&!1===r.flatShading?"#define USE_MORPHNORMALS":"",r.doubleSided?"#define DOUBLE_SIDED":"",r.flipSided?"#define FLIP_SIDED":"",r.shadowMapEnabled?"#define USE_SHADOWMAP":"",r.shadowMapEnabled?"#define "+p:"",r.sizeAttenuation?"#define USE_SIZEATTENUATION":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&r.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING"," attribute mat4 instanceMatrix;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(wn).join("\n"),o=[g,Pn(r),"#define SHADER_NAME "+r.shaderName,y,r.alphaTest?"#define ALPHATEST "+r.alphaTest+(r.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+x,r.useFog&&r.fog?"#define USE_FOG":"",r.useFog&&r.fogExp2?"#define FOG_EXP2":"",r.map?"#define USE_MAP":"",r.matcap?"#define USE_MATCAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+h:"",r.envMap?"#define "+v:"",r.envMap?"#define "+m:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.normalMap&&r.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",r.normalMap&&r.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",r.clearcoatMap?"#define USE_CLEARCOATMAP":"",r.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",r.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.sheen?"#define USE_SHEEN":"",r.transmissionMap?"#define USE_TRANSMISSIONMAP":"",r.vertexTangents?"#define USE_TANGENT":"",r.vertexColors?"#define USE_COLOR":"",r.vertexUvs?"#define USE_UV":"",r.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",r.gradientMap?"#define USE_GRADIENTMAP":"",r.flatShading?"#define FLAT_SHADED":"",r.doubleSided?"#define DOUBLE_SIDED":"",r.flipSided?"#define FLIP_SIDED":"",r.shadowMapEnabled?"#define USE_SHADOWMAP":"",r.shadowMapEnabled?"#define "+p:"",r.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",r.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&r.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(r.extensionShaderTextureLOD||r.envMap)&&r.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==r.toneMapping?"#define TONE_MAPPING":"",0!==r.toneMapping?tr.tonemapping_pars_fragment:"",0!==r.toneMapping?En("toneMapping",r.toneMapping):"",r.dithering?"#define DITHERING":"",tr.encodings_pars_fragment,r.map?yn("mapTexelToLinear",r.mapEncoding):"",r.matcap?yn("matcapTexelToLinear",r.matcapEncoding):"",r.envMap?yn("envMapTexelToLinear",r.envMapEncoding):"",r.emissiveMap?yn("emissiveMapTexelToLinear",r.emissiveMapEncoding):"",r.lightMap?yn("lightMapTexelToLinear",r.lightMapEncoding):"",(i="linearToOutputTexel",s=r.outputEncoding,l=xn(s),"vec4 "+i+"( vec4 value ) { return LinearTo"+l[0]+l[1]+"; }"),r.depthPacking?"#define DEPTH_PACKING "+r.depthPacking:"","\n"].filter(wn).join("\n")),d=Tn(d=bn(d=Sn(d),r),r),u=Tn(u=bn(u=Sn(u),r),r),d=Cn(d),u=Cn(u),r.isWebGL2&&!r.isRawShaderMaterial&&(a=["#version 300 es\n","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+a,o=["#version 300 es\n","#define varying in","out highp vec4 pc_fragColor;","#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+o);var w,b,T=o+u,_=vn(c,35633,a+d),S=vn(c,35632,T);if(c.attachShader(E,_),c.attachShader(E,S),void 0!==r.index0AttributeName?c.bindAttribLocation(E,0,r.index0AttributeName):!0===r.morphTargets&&c.bindAttribLocation(E,0,"position"),c.linkProgram(E),e.debug.checkShaderErrors){var R=c.getProgramInfoLog(E).trim(),A=c.getShaderInfoLog(_).trim(),M=c.getShaderInfoLog(S).trim(),C=!0,L=!0;if(!1===c.getProgramParameter(E,35714)){C=!1;var H=gn(c,_,"vertex"),P=gn(c,S,"fragment");console.error("THREE.WebGLProgram: shader error: ",c.getError(),"35715",c.getProgramParameter(E,35715),"gl.getProgramInfoLog",R,H,P)}else""!==R?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",R):""!==A&&""!==M||(L=!1);L&&(this.diagnostics={runnable:C,programLog:R,vertexShader:{log:A,prefix:a},fragmentShader:{log:M,prefix:o}})}return c.deleteShader(_),c.deleteShader(S),this.getUniforms=function(){return void 0===w&&(w=new hn(c,E)),w},this.getAttributes=function(){return void 0===b&&(b=function(e,t){for(var r={},n=e.getProgramParameter(t,35721),a=0;a<n;a++){var o=e.getActiveAttrib(t,a).name;r[o]=e.getAttribLocation(t,o)}return r}(c,E)),b},this.destroy=function(){n.releaseStatesOfProgram(this),c.deleteProgram(E),this.program=void 0},this.name=r.shaderName,this.id=mn++,this.cacheKey=t,this.usedTimes=1,this.program=E,this.vertexShader=_,this.fragmentShader=S,this}function kn(e,t,r,n){var a=[],o=r.isWebGL2,i=r.logarithmicDepthBuffer,s=r.floatVertexTextures,l=r.maxVertexUniforms,c=r.vertexTextures,f=r.precision,d={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},u=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function p(e){var t;return e?e.isTexture?t=e.encoding:e.isWebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=3e3,t}return{getParameters:function(n,a,u,h,v,m,x){var g,y,E=h.fog,w=n.isMeshStandardMaterial?h.environment:null,b=n.envMap||w,T=d[n.type],_=x.isSkinnedMesh?function(e){var t=e.skeleton.bones;if(s)return 1024;var r=l,n=Math.floor((r-20)/4),a=Math.min(n,t.length);return a<t.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+t.length+" bones. This GPU supports "+a+"."),0):a}(x):0;if(null!==n.precision&&(f=r.getMaxPrecision(n.precision))!==n.precision&&console.warn("THREE.WebGLProgram.getParameters:",n.precision,"not supported, using",f,"instead."),T){var S=rr[T];g=S.vertexShader,y=S.fragmentShader}else g=n.vertexShader,y=n.fragmentShader;var R=e.getRenderTarget();return{isWebGL2:o,shaderID:T,shaderName:n.type,vertexShader:g,fragmentShader:y,defines:n.defines,isRawShaderMaterial:n.isRawShaderMaterial,isShaderMaterial:n.isShaderMaterial,precision:f,instancing:!0===x.isInstancedMesh,supportsVertexTextures:c,outputEncoding:null!==R?p(R.texture):e.outputEncoding,map:!!n.map,mapEncoding:p(n.map),matcap:!!n.matcap,matcapEncoding:p(n.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:p(b),envMapCubeUV:!!b&&(306===b.mapping||307===b.mapping),lightMap:!!n.lightMap,lightMapEncoding:p(n.lightMap),aoMap:!!n.aoMap,emissiveMap:!!n.emissiveMap,emissiveMapEncoding:p(n.emissiveMap),bumpMap:!!n.bumpMap,normalMap:!!n.normalMap,objectSpaceNormalMap:1===n.normalMapType,tangentSpaceNormalMap:0===n.normalMapType,clearcoatMap:!!n.clearcoatMap,clearcoatRoughnessMap:!!n.clearcoatRoughnessMap,clearcoatNormalMap:!!n.clearcoatNormalMap,displacementMap:!!n.displacementMap,roughnessMap:!!n.roughnessMap,metalnessMap:!!n.metalnessMap,specularMap:!!n.specularMap,alphaMap:!!n.alphaMap,gradientMap:!!n.gradientMap,sheen:!!n.sheen,transmissionMap:!!n.transmissionMap,combine:n.combine,vertexTangents:n.normalMap&&n.vertexTangents,vertexColors:n.vertexColors,vertexUvs:!!(n.map||n.bumpMap||n.normalMap||n.specularMap||n.alphaMap||n.emissiveMap||n.roughnessMap||n.metalnessMap||n.clearcoatMap||n.clearcoatRoughnessMap||n.clearcoatNormalMap||n.displacementMap||n.transmissionMap),uvsVertexOnly:!(n.map||n.bumpMap||n.normalMap||n.specularMap||n.alphaMap||n.emissiveMap||n.roughnessMap||n.metalnessMap||n.clearcoatNormalMap||n.transmissionMap||!n.displacementMap),fog:!!E,useFog:n.fog,fogExp2:E&&E.isFogExp2,flatShading:n.flatShading,sizeAttenuation:n.sizeAttenuation,logarithmicDepthBuffer:i,skinning:n.skinning&&_>0,maxBones:_,useVertexTexture:s,morphTargets:n.morphTargets,morphNormals:n.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:a.directional.length,numPointLights:a.point.length,numSpotLights:a.spot.length,numRectAreaLights:a.rectArea.length,numHemiLights:a.hemi.length,numDirLightShadows:a.directionalShadowMap.length,numPointLightShadows:a.pointShadowMap.length,numSpotLightShadows:a.spotShadowMap.length,numClippingPlanes:v,numClipIntersection:m,dithering:n.dithering,shadowMapEnabled:e.shadowMap.enabled&&u.length>0,shadowMapType:e.shadowMap.type,toneMapping:n.toneMapped?e.toneMapping:0,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:n.premultipliedAlpha,alphaTest:n.alphaTest,doubleSided:2===n.side,flipSided:1===n.side,depthPacking:void 0!==n.depthPacking&&n.depthPacking,index0AttributeName:n.index0AttributeName,extensionDerivatives:n.extensions&&n.extensions.derivatives,extensionFragDepth:n.extensions&&n.extensions.fragDepth,extensionDrawBuffers:n.extensions&&n.extensions.drawBuffers,extensionShaderTextureLOD:n.extensions&&n.extensions.shaderTextureLOD,rendererExtensionFragDepth:o||null!==t.get("EXT_frag_depth"),rendererExtensionDrawBuffers:o||null!==t.get("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:o||null!==t.get("EXT_shader_texture_lod"),customProgramCacheKey:n.customProgramCacheKey()}},getProgramCacheKey:function(t){var r=[];if(t.shaderID?r.push(t.shaderID):(r.push(t.fragmentShader),r.push(t.vertexShader)),void 0!==t.defines)for(var n in t.defines)r.push(n),r.push(t.defines[n]);if(void 0===t.isRawShaderMaterial){for(var a=0;a<u.length;a++)r.push(t[u[a]]);r.push(e.outputEncoding),r.push(e.gammaFactor)}return r.push(t.customProgramCacheKey),r.join()},getUniforms:function(e){var t,r=d[e.type];if(r){var n=rr[r];t=Ut.clone(n.uniforms)}else t=e.uniforms;return t},acquireProgram:function(t,r){for(var o,i=0,s=a.length;i<s;i++){var l=a[i];if(l.cacheKey===r){++(o=l).usedTimes;break}}return void 0===o&&(o=new zn(e,r,t,n),a.push(o)),o},releaseProgram:function(e){if(0==--e.usedTimes){var t=a.indexOf(e);a[t]=a[a.length-1],a.pop(),e.destroy()}},programs:a}}function Nn(){var e=new WeakMap;return{get:function(t){var r=e.get(t);return void 0===r&&(r={},e.set(t,r)),r},remove:function(t){e.delete(t)},update:function(t,r,n){e.get(t)[r]=n},dispose:function(){e=new WeakMap}}}function Dn(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Fn(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function In(e){var t=[],r=0,n=[],a=[],o={id:-1};function i(n,a,i,s,l,c){var f=t[r],d=e.get(i);return void 0===f?(f={id:n.id,object:n,geometry:a,material:i,program:d.program||o,groupOrder:s,renderOrder:n.renderOrder,z:l,group:c},t[r]=f):(f.id=n.id,f.object=n,f.geometry=a,f.material=i,f.program=d.program||o,f.groupOrder=s,f.renderOrder=n.renderOrder,f.z=l,f.group=c),r++,f}return{opaque:n,transparent:a,init:function(){r=0,n.length=0,a.length=0},push:function(e,t,r,o,s,l){var c=i(e,t,r,o,s,l);(!0===r.transparent?a:n).push(c)},unshift:function(e,t,r,o,s,l){var c=i(e,t,r,o,s,l);(!0===r.transparent?a:n).unshift(c)},finish:function(){for(var e=r,n=t.length;e<n;e++){var a=t[e];if(null===a.id)break;a.id=null,a.object=null,a.geometry=null,a.material=null,a.program=null,a.group=null}},sort:function(e,t){n.length>1&&n.sort(e||Dn),a.length>1&&a.sort(t||Fn)}}}function On(e){var t=new WeakMap;function r(e){var n=e.target;n.removeEventListener("dispose",r),t.delete(n)}return{get:function(n,a){var o,i=t.get(n);return void 0===i?(o=new In(e),t.set(n,new WeakMap),t.get(n).set(a,o),n.addEventListener("dispose",r)):void 0===(o=i.get(a))&&(o=new In(e),i.set(a,o)),o},dispose:function(){t=new WeakMap}}}function Un(){var e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];var r;switch(t.type){case"DirectionalLight":r={direction:new g,color:new Ne};break;case"SpotLight":r={position:new g,direction:new g,color:new Ne,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":r={position:new g,color:new Ne,distance:0,decay:0};break;case"HemisphereLight":r={direction:new g,skyColor:new Ne,groundColor:new Ne};break;case"RectAreaLight":r={color:new Ne,position:new g,halfWidth:new g,halfHeight:new g}}return e[t.id]=r,r}}}var Gn=0;function Bn(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function Vn(){for(var e,t=new Un,r=(e={},{get:function(t){if(void 0!==e[t.id])return e[t.id];var r;switch(t.type){case"DirectionalLight":case"SpotLight":r={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new s};break;case"PointLight":r={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new s,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=r,r}}),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},a=0;a<9;a++)n.probe.push(new g);var o=new g,i=new R,l=new R;return{setup:function(e,a,s){for(var c=0,f=0,d=0,u=0;u<9;u++)n.probe[u].set(0,0,0);var p=0,h=0,v=0,m=0,x=0,g=0,y=0,E=0,w=s.matrixWorldInverse;e.sort(Bn);for(var b=0,T=e.length;b<T;b++){var _=e[b],S=_.color,R=_.intensity,A=_.distance,M=_.shadow&&_.shadow.map?_.shadow.map.texture:null;if(_.isAmbientLight)c+=S.r*R,f+=S.g*R,d+=S.b*R;else if(_.isLightProbe)for(var C=0;C<9;C++)n.probe[C].addScaledVector(_.sh.coefficients[C],R);else if(_.isDirectionalLight){var L=t.get(_);if(L.color.copy(_.color).multiplyScalar(_.intensity),L.direction.setFromMatrixPosition(_.matrixWorld),o.setFromMatrixPosition(_.target.matrixWorld),L.direction.sub(o),L.direction.transformDirection(w),_.castShadow){var H=_.shadow,P=r.get(_);P.shadowBias=H.bias,P.shadowNormalBias=H.normalBias,P.shadowRadius=H.radius,P.shadowMapSize=H.mapSize,n.directionalShadow[p]=P,n.directionalShadowMap[p]=M,n.directionalShadowMatrix[p]=_.shadow.matrix,g++}n.directional[p]=L,p++}else if(_.isSpotLight){var z=t.get(_);if(z.position.setFromMatrixPosition(_.matrixWorld),z.position.applyMatrix4(w),z.color.copy(S).multiplyScalar(R),z.distance=A,z.direction.setFromMatrixPosition(_.matrixWorld),o.setFromMatrixPosition(_.target.matrixWorld),z.direction.sub(o),z.direction.transformDirection(w),z.coneCos=Math.cos(_.angle),z.penumbraCos=Math.cos(_.angle*(1-_.penumbra)),z.decay=_.decay,_.castShadow){var k=_.shadow,N=r.get(_);N.shadowBias=k.bias,N.shadowNormalBias=k.normalBias,N.shadowRadius=k.radius,N.shadowMapSize=k.mapSize,n.spotShadow[v]=N,n.spotShadowMap[v]=M,n.spotShadowMatrix[v]=_.shadow.matrix,E++}n.spot[v]=z,v++}else if(_.isRectAreaLight){var D=t.get(_);D.color.copy(S).multiplyScalar(R),D.position.setFromMatrixPosition(_.matrixWorld),D.position.applyMatrix4(w),l.identity(),i.copy(_.matrixWorld),i.premultiply(w),l.extractRotation(i),D.halfWidth.set(.5*_.width,0,0),D.halfHeight.set(0,.5*_.height,0),D.halfWidth.applyMatrix4(l),D.halfHeight.applyMatrix4(l),n.rectArea[m]=D,m++}else if(_.isPointLight){var F=t.get(_);if(F.position.setFromMatrixPosition(_.matrixWorld),F.position.applyMatrix4(w),F.color.copy(_.color).multiplyScalar(_.intensity),F.distance=_.distance,F.decay=_.decay,_.castShadow){var I=_.shadow,O=r.get(_);O.shadowBias=I.bias,O.shadowNormalBias=I.normalBias,O.shadowRadius=I.radius,O.shadowMapSize=I.mapSize,O.shadowCameraNear=I.camera.near,O.shadowCameraFar=I.camera.far,n.pointShadow[h]=O,n.pointShadowMap[h]=M,n.pointShadowMatrix[h]=_.shadow.matrix,y++}n.point[h]=F,h++}else if(_.isHemisphereLight){var U=t.get(_);U.direction.setFromMatrixPosition(_.matrixWorld),U.direction.transformDirection(w),U.direction.normalize(),U.skyColor.copy(_.color).multiplyScalar(R),U.groundColor.copy(_.groundColor).multiplyScalar(R),n.hemi[x]=U,x++}}n.ambient[0]=c,n.ambient[1]=f,n.ambient[2]=d;var G=n.hash;G.directionalLength===p&&G.pointLength===h&&G.spotLength===v&&G.rectAreaLength===m&&G.hemiLength===x&&G.numDirectionalShadows===g&&G.numPointShadows===y&&G.numSpotShadows===E||(n.directional.length=p,n.spot.length=v,n.rectArea.length=m,n.point.length=h,n.hemi.length=x,n.directionalShadow.length=g,n.directionalShadowMap.length=g,n.pointShadow.length=y,n.pointShadowMap.length=y,n.spotShadow.length=E,n.spotShadowMap.length=E,n.directionalShadowMatrix.length=g,n.pointShadowMatrix.length=y,n.spotShadowMatrix.length=E,G.directionalLength=p,G.pointLength=h,G.spotLength=v,G.rectAreaLength=m,G.hemiLength=x,G.numDirectionalShadows=g,G.numPointShadows=y,G.numSpotShadows=E,n.version=Gn++)},state:n}}function jn(){var e=new Vn,t=[],r=[];return{init:function(){t.length=0,r.length=0},state:{lightsArray:t,shadowsArray:r,lights:e},setupLights:function(n){e.setup(t,r,n)},pushLight:function(e){t.push(e)},pushShadow:function(e){r.push(e)}}}function Wn(){var e=new WeakMap;function t(r){var n=r.target;n.removeEventListener("dispose",t),e.delete(n)}return{get:function(r,n){var a;return!1===e.has(r)?(a=new jn,e.set(r,new WeakMap),e.get(r).set(n,a),r.addEventListener("dispose",t)):!1===e.get(r).has(n)?(a=new jn,e.get(r).set(n,a)):a=e.get(r).get(n),a},dispose:function(){e=new WeakMap}}}function qn(e){Ge.call(this),this.type="MeshDepthMaterial",this.depthPacking=3200,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}function Xn(e){Ge.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new g,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}function Yn(e,t,r){var n=new Zt,a=new s,o=new s,i=new u,l=[],c=[],f={},d={0:1,1:0,2:2},h=new Gt({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new s},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),v=h.clone();v.defines.HORIZONAL_PASS=1;var m=new ft;m.setAttribute("position",new We(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));var x=new Mt(m,h),g=this;function y(r,n){var a=t.update(x);h.uniforms.shadow_pass.value=r.map.texture,h.uniforms.resolution.value=r.mapSize,h.uniforms.radius.value=r.radius,e.setRenderTarget(r.mapPass),e.clear(),e.renderBufferDirect(n,null,a,h,x,null),v.uniforms.shadow_pass.value=r.mapPass.texture,v.uniforms.resolution.value=r.mapSize,v.uniforms.radius.value=r.radius,e.setRenderTarget(r.map),e.clear(),e.renderBufferDirect(n,null,a,v,x,null)}function E(e,t,r){var n=e<<0|t<<1|r<<2,a=l[n];return void 0===a&&(a=new qn({depthPacking:3201,morphTargets:e,skinning:t}),l[n]=a),a}function w(e,t,r){var n=e<<0|t<<1|r<<2,a=c[n];return void 0===a&&(a=new Xn({morphTargets:e,skinning:t}),c[n]=a),a}function b(t,r,n,a,o,i,s){var l=null,c=E,u=t.customDepthMaterial;if(!0===a.isPointLight&&(c=w,u=t.customDistanceMaterial),void 0===u){var p=!1;!0===n.morphTargets&&(p=r.morphAttributes&&r.morphAttributes.position&&r.morphAttributes.position.length>0);var h=!1;!0===t.isSkinnedMesh&&(!0===n.skinning?h=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t)),l=c(p,h,!0===t.isInstancedMesh)}else l=u;if(e.localClippingEnabled&&!0===n.clipShadows&&0!==n.clippingPlanes.length){var v=l.uuid,m=n.uuid,x=f[v];void 0===x&&(x={},f[v]=x);var g=x[m];void 0===g&&(g=l.clone(),x[m]=g),l=g}return l.visible=n.visible,l.wireframe=n.wireframe,l.side=3===s?null!==n.shadowSide?n.shadowSide:n.side:null!==n.shadowSide?n.shadowSide:d[n.side],l.clipShadows=n.clipShadows,l.clippingPlanes=n.clippingPlanes,l.clipIntersection=n.clipIntersection,l.wireframeLinewidth=n.wireframeLinewidth,l.linewidth=n.linewidth,!0===a.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(a.matrixWorld),l.nearDistance=o,l.farDistance=i),l}function T(r,a,o,i,s){if(!1!==r.visible){if(r.layers.test(a.layers)&&(r.isMesh||r.isLine||r.isPoints)&&(r.castShadow||r.receiveShadow&&3===s)&&(!r.frustumCulled||n.intersectsObject(r))){r.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse,r.matrixWorld);var l=t.update(r),c=r.material;if(Array.isArray(c))for(var f=l.groups,d=0,u=f.length;d<u;d++){var p=f[d],h=c[p.materialIndex];if(h&&h.visible){var v=b(r,l,h,i,o.near,o.far,s);e.renderBufferDirect(o,null,l,v,r,p)}}else if(c.visible){var m=b(r,l,c,i,o.near,o.far,s);e.renderBufferDirect(o,null,l,m,r,null)}}for(var x=r.children,g=0,y=x.length;g<y;g++)T(x[g],a,o,i,s)}}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(t,s,l){if(!1!==g.enabled&&(!1!==g.autoUpdate||!1!==g.needsUpdate)&&0!==t.length){var c=e.getRenderTarget(),f=e.getActiveCubeFace(),d=e.getActiveMipmapLevel(),u=e.state;u.setBlending(0),u.buffers.color.setClear(1,1,1,1),u.buffers.depth.setTest(!0),u.setScissorTest(!1);for(var h=0,v=t.length;h<v;h++){var m=t[h],x=m.shadow;if(!1!==x.autoUpdate||!1!==x.needsUpdate)if(void 0!==x){a.copy(x.mapSize);var E=x.getFrameExtents();if(a.multiply(E),o.copy(x.mapSize),(a.x>r||a.y>r)&&(a.x>r&&(o.x=Math.floor(r/E.x),a.x=o.x*E.x,x.mapSize.x=o.x),a.y>r&&(o.y=Math.floor(r/E.y),a.y=o.y*E.y,x.mapSize.y=o.y)),null===x.map&&!x.isPointLightShadow&&3===this.type){var w={minFilter:1006,magFilter:1006,format:1023,stencilBuffer:!1};x.map=new p(a.x,a.y,w),x.map.texture.name=m.name+".shadowMap",x.mapPass=new p(a.x,a.y,w),x.camera.updateProjectionMatrix()}if(null===x.map){var b={minFilter:1003,magFilter:1003,format:1023,stencilBuffer:!1};x.map=new p(a.x,a.y,b),x.map.texture.name=m.name+".shadowMap",x.camera.updateProjectionMatrix()}e.setRenderTarget(x.map),e.clear();for(var _=x.getViewportCount(),S=0;S<_;S++){var R=x.getViewport(S);i.set(o.x*R.x,o.y*R.y,o.x*R.z,o.y*R.w),u.viewport(i),x.updateMatrices(m,S),n=x.getFrustum(),T(s,l,x.camera,m,this.type)}x.isPointLightShadow||3!==this.type||y(x,l),x.needsUpdate=!1}else console.warn("THREE.WebGLShadowMap:",m,"has no shadow.")}g.needsUpdate=!1,e.setRenderTarget(c,f,d)}}}function Zn(e,t,r){var n=r.isWebGL2,a=new function(){var t=!1,r=new u,n=null,a=new u(0,0,0,0);return{setMask:function(r){n===r||t||(e.colorMask(r,r,r,r),n=r)},setLocked:function(e){t=e},setClear:function(t,n,o,i,s){!0===s&&(t*=i,n*=i,o*=i),r.set(t,n,o,i),!1===a.equals(r)&&(e.clearColor(t,n,o,i),a.copy(r))},reset:function(){t=!1,n=null,a.set(-1,0,0,0)}}},o=new function(){var t=!1,r=null,n=null,a=null;return{setTest:function(e){e?k(2929):N(2929)},setMask:function(n){r===n||t||(e.depthMask(n),r=n)},setFunc:function(t){if(n!==t){if(t)switch(t){case 0:e.depthFunc(512);break;case 1:e.depthFunc(519);break;case 2:e.depthFunc(513);break;case 3:e.depthFunc(515);break;case 4:e.depthFunc(514);break;case 5:e.depthFunc(518);break;case 6:e.depthFunc(516);break;case 7:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);n=t}},setLocked:function(e){t=e},setClear:function(t){a!==t&&(e.clearDepth(t),a=t)},reset:function(){t=!1,r=null,n=null,a=null}}},i=new function(){var t=!1,r=null,n=null,a=null,o=null,i=null,s=null,l=null,c=null;return{setTest:function(e){t||(e?k(2960):N(2960))},setMask:function(n){r===n||t||(e.stencilMask(n),r=n)},setFunc:function(t,r,i){n===t&&a===r&&o===i||(e.stencilFunc(t,r,i),n=t,a=r,o=i)},setOp:function(t,r,n){i===t&&s===r&&l===n||(e.stencilOp(t,r,n),i=t,s=r,l=n)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,r=null,n=null,a=null,o=null,i=null,s=null,l=null,c=null}}},s={},l=null,c=null,f=null,d=null,p=null,h=null,v=null,m=null,x=null,g=!1,y=null,E=null,w=null,b=null,T=null,_=e.getParameter(35661),S=!1,R=0,A=e.getParameter(7938);-1!==A.indexOf("WebGL")?(R=parseFloat(/^WebGL\ ([0-9])/.exec(A)[1]),S=R>=1):-1!==A.indexOf("OpenGL ES")&&(R=parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(A)[1]),S=R>=2);var M=null,C={},L=new u,H=new u;function P(t,r,n){var a=new Uint8Array(4),o=e.createTexture();e.bindTexture(t,o),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(var i=0;i<n;i++)e.texImage2D(r+i,0,6408,1,1,0,6408,5121,a);return o}var z={};function k(t){!0!==s[t]&&(e.enable(t),s[t]=!0)}function N(t){!1!==s[t]&&(e.disable(t),s[t]=!1)}z[3553]=P(3553,3553,1),z[34067]=P(34067,34069,6),a.setClear(0,0,0,1),o.setClear(1),i.setClear(0),k(2929),o.setFunc(3),U(!1),G(1),k(2884),O(0);var D={100:32774,101:32778,102:32779};if(n)D[103]=32775,D[104]=32776;else{var F=t.get("EXT_blend_minmax");null!==F&&(D[103]=F.MIN_EXT,D[104]=F.MAX_EXT)}var I={};function O(t,r,n,a,o,i,s,l){if(0!==t){if(c||(k(3042),c=!0),5===t)o=o||r,i=i||n,s=s||a,r===d&&o===v||(e.blendEquationSeparate(D[r],D[o]),d=r,v=o),n===p&&a===h&&i===m&&s===x||(e.blendFuncSeparate(I[n],I[a],I[i],I[s]),p=n,h=a,m=i,x=s),f=t,g=null;else if(t!==f||l!==g){if(100===d&&100===v||(e.blendEquation(32774),d=100,v=100),l)switch(t){case 1:e.blendFuncSeparate(1,771,1,771);break;case 2:e.blendFunc(1,1);break;case 3:e.blendFuncSeparate(0,0,769,771);break;case 4:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case 1:e.blendFuncSeparate(770,771,1,771);break;case 2:e.blendFunc(770,1);break;case 3:e.blendFunc(0,769);break;case 4:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}p=null,h=null,m=null,x=null,f=t,g=l}}else c&&(N(3042),c=!1)}function U(t){y!==t&&(t?e.frontFace(2304):e.frontFace(2305),y=t)}function G(t){0!==t?(k(2884),t!==E&&(1===t?e.cullFace(1029):2===t?e.cullFace(1028):e.cullFace(1032))):N(2884),E=t}function B(t,r,n){t?(k(32823),b===r&&T===n||(e.polygonOffset(r,n),b=r,T=n)):N(32823)}function V(t){void 0===t&&(t=33984+_-1),M!==t&&(e.activeTexture(t),M=t)}return I[200]=0,I[201]=1,I[202]=768,I[204]=770,I[210]=776,I[208]=774,I[206]=772,I[203]=769,I[205]=771,I[209]=775,I[207]=773,{buffers:{color:a,depth:o,stencil:i},enable:k,disable:N,useProgram:function(t){return l!==t&&(e.useProgram(t),l=t,!0)},setBlending:O,setMaterial:function(e,t){2===e.side?N(2884):k(2884);var r=1===e.side;t&&(r=!r),U(r),1===e.blending&&!1===e.transparent?O(0):O(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),o.setFunc(e.depthFunc),o.setTest(e.depthTest),o.setMask(e.depthWrite),a.setMask(e.colorWrite);var n=e.stencilWrite;i.setTest(n),n&&(i.setMask(e.stencilWriteMask),i.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),i.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),B(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits)},setFlipSided:U,setCullFace:G,setLineWidth:function(t){t!==w&&(S&&e.lineWidth(t),w=t)},setPolygonOffset:B,setScissorTest:function(e){e?k(3089):N(3089)},activeTexture:V,bindTexture:function(t,r){null===M&&V();var n=C[M];void 0===n&&(n={type:void 0,texture:void 0},C[M]=n),n.type===t&&n.texture===r||(e.bindTexture(t,r||z[t]),n.type=t,n.texture=r)},unbindTexture:function(){var t=C[M];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage2D:function(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},texImage3D:function(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}},scissor:function(t){!1===L.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),L.copy(t))},viewport:function(t){!1===H.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),H.copy(t))},reset:function(){s={},M=null,C={},l=null,f=null,y=null,E=null,a.reset(),o.reset(),i.reset()}}}function Qn(e,t,r,n,a,o,s){var l,c=a.isWebGL2,f=a.maxTextures,d=a.maxCubemapSize,u=a.maxTextureSize,p=a.maxSamples,h=new WeakMap,v=!1;try{v="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function m(e,t){return v?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function x(e,t,r,n){var a=1;if((e.width>n||e.height>n)&&(a=n/Math.max(e.width,e.height)),a<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){var o=t?i.floorPowerOfTwo:Math.floor,s=o(a*e.width),c=o(a*e.height);void 0===l&&(l=m(s,c));var f=r?m(s,c):l;return f.width=s,f.height=c,f.getContext("2d").drawImage(e,0,0,s,c),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+c+")."),f}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function g(e){return i.isPowerOfTwo(e.width)&&i.isPowerOfTwo(e.height)}function y(e,t){return e.generateMipmaps&&t&&1003!==e.minFilter&&1006!==e.minFilter}function E(t,r,a,o){e.generateMipmap(t),n.get(r).__maxMipLevel=Math.log(Math.max(a,o))*Math.LOG2E}function w(r,n,a){if(!1===c)return n;if(null!==r){if(void 0!==e[r])return e[r];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+r+"'")}var o=n;return 6403===n&&(5126===a&&(o=33326),5131===a&&(o=33325),5121===a&&(o=33321)),6407===n&&(5126===a&&(o=34837),5131===a&&(o=34843),5121===a&&(o=32849)),6408===n&&(5126===a&&(o=34836),5131===a&&(o=34842),5121===a&&(o=32856)),33325!==o&&33326!==o&&34842!==o&&34836!==o||t.get("EXT_color_buffer_float"),o}function b(e){return 1003===e||1004===e||1005===e?9728:9729}function T(t){var r=t.target;r.removeEventListener("dispose",T),function(t){var r=n.get(t);void 0!==r.__webglInit&&(e.deleteTexture(r.__webglTexture),n.remove(t))}(r),r.isVideoTexture&&h.delete(r),s.memory.textures--}function _(t){var r=t.target;r.removeEventListener("dispose",_),function(t){var r=n.get(t),a=n.get(t.texture);if(t){if(void 0!==a.__webglTexture&&e.deleteTexture(a.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(var o=0;o<6;o++)e.deleteFramebuffer(r.__webglFramebuffer[o]),r.__webglDepthbuffer&&e.deleteRenderbuffer(r.__webglDepthbuffer[o]);else e.deleteFramebuffer(r.__webglFramebuffer),r.__webglDepthbuffer&&e.deleteRenderbuffer(r.__webglDepthbuffer),r.__webglMultisampledFramebuffer&&e.deleteFramebuffer(r.__webglMultisampledFramebuffer),r.__webglColorRenderbuffer&&e.deleteRenderbuffer(r.__webglColorRenderbuffer),r.__webglDepthRenderbuffer&&e.deleteRenderbuffer(r.__webglDepthRenderbuffer);n.remove(t.texture),n.remove(t)}}(r),s.memory.textures--}var S=0;function R(e,t){var a=n.get(e);if(e.isVideoTexture&&function(e){var t=s.render.frame;h.get(e)!==t&&(h.set(e,t),e.update())}(e),e.version>0&&a.__version!==e.version){var o=e.image;if(void 0===o)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==o.complete)return void z(a,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}r.activeTexture(33984+t),r.bindTexture(3553,a.__webglTexture)}function A(t,a){if(6===t.image.length){var i=n.get(t);if(t.version>0&&i.__version!==t.version){P(i,t),r.activeTexture(33984+a),r.bindTexture(34067,i.__webglTexture),e.pixelStorei(37440,t.flipY);for(var s=t&&(t.isCompressedTexture||t.image[0].isCompressedTexture),l=t.image[0]&&t.image[0].isDataTexture,f=[],u=0;u<6;u++)f[u]=s||l?l?t.image[u].image:t.image[u]:x(t.image[u],!1,!0,d);var p,h=f[0],v=g(h)||c,m=o.convert(t.format),b=o.convert(t.type),T=w(t.internalFormat,m,b);if(H(34067,t,v),s){for(var _=0;_<6;_++){p=f[_].mipmaps;for(var S=0;S<p.length;S++){var R=p[S];1023!==t.format&&1022!==t.format?null!==m?r.compressedTexImage2D(34069+_,S,T,R.width,R.height,0,R.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):r.texImage2D(34069+_,S,T,R.width,R.height,0,m,b,R.data)}}i.__maxMipLevel=p.length-1}else{p=t.mipmaps;for(var A=0;A<6;A++)if(l){r.texImage2D(34069+A,0,T,f[A].width,f[A].height,0,m,b,f[A].data);for(var M=0;M<p.length;M++){var C=p[M].image[A].image;r.texImage2D(34069+A,M+1,T,C.width,C.height,0,m,b,C.data)}}else{r.texImage2D(34069+A,0,T,m,b,f[A]);for(var L=0;L<p.length;L++){var z=p[L];r.texImage2D(34069+A,L+1,T,m,b,z.image[A])}}i.__maxMipLevel=p.length}y(t,v)&&E(34067,t,h.width,h.height),i.__version=t.version,t.onUpdate&&t.onUpdate(t)}else r.activeTexture(33984+a),r.bindTexture(34067,i.__webglTexture)}}function M(e,t){r.activeTexture(33984+t),r.bindTexture(34067,n.get(e).__webglTexture)}var C={1e3:10497,1001:33071,1002:33648},L={};function H(r,o,i){i?(e.texParameteri(r,10242,C[o.wrapS]),e.texParameteri(r,10243,C[o.wrapT]),32879!==r&&35866!==r||e.texParameteri(r,32882,C[o.wrapR]),e.texParameteri(r,10240,L[o.magFilter]),e.texParameteri(r,10241,L[o.minFilter])):(e.texParameteri(r,10242,33071),e.texParameteri(r,10243,33071),32879!==r&&35866!==r||e.texParameteri(r,32882,33071),1001===o.wrapS&&1001===o.wrapT||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(r,10240,b(o.magFilter)),e.texParameteri(r,10241,b(o.minFilter)),1003!==o.minFilter&&1006!==o.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));var s=t.get("EXT_texture_filter_anisotropic");if(s){if(1015===o.type&&null===t.get("OES_texture_float_linear"))return;if(1016===o.type&&null===(c||t.get("OES_texture_half_float_linear")))return;(o.anisotropy>1||n.get(o).__currentAnisotropy)&&(e.texParameterf(r,s.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(o.anisotropy,a.getMaxAnisotropy())),n.get(o).__currentAnisotropy=o.anisotropy)}}function P(t,r){void 0===t.__webglInit&&(t.__webglInit=!0,r.addEventListener("dispose",T),t.__webglTexture=e.createTexture(),s.memory.textures++)}function z(t,n,a){var i=3553;n.isDataTexture2DArray&&(i=35866),n.isDataTexture3D&&(i=32879),P(t,n),r.activeTexture(33984+a),r.bindTexture(i,t.__webglTexture),e.pixelStorei(37440,n.flipY),e.pixelStorei(37441,n.premultiplyAlpha),e.pixelStorei(3317,n.unpackAlignment);var s,l=function(e){return!c&&(1001!==e.wrapS||1001!==e.wrapT||1003!==e.minFilter&&1006!==e.minFilter)}(n)&&!1===g(n.image),f=x(n.image,l,!1,u),d=g(f)||c,p=o.convert(n.format),h=o.convert(n.type),v=w(n.internalFormat,p,h);H(i,n,d);var m=n.mipmaps;if(n.isDepthTexture)v=6402,c?v=1015===n.type?36012:1014===n.type?33190:1020===n.type?35056:33189:1015===n.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===n.format&&6402===v&&1012!==n.type&&1014!==n.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),n.type=1012,h=o.convert(n.type)),1027===n.format&&6402===v&&(v=34041,1020!==n.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),n.type=1020,h=o.convert(n.type))),r.texImage2D(3553,0,v,f.width,f.height,0,p,h,null);else if(n.isDataTexture)if(m.length>0&&d){for(var b=0,T=m.length;b<T;b++)s=m[b],r.texImage2D(3553,b,v,s.width,s.height,0,p,h,s.data);n.generateMipmaps=!1,t.__maxMipLevel=m.length-1}else r.texImage2D(3553,0,v,f.width,f.height,0,p,h,f.data),t.__maxMipLevel=0;else if(n.isCompressedTexture){for(var _=0,S=m.length;_<S;_++)s=m[_],1023!==n.format&&1022!==n.format?null!==p?r.compressedTexImage2D(3553,_,v,s.width,s.height,0,s.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):r.texImage2D(3553,_,v,s.width,s.height,0,p,h,s.data);t.__maxMipLevel=m.length-1}else if(n.isDataTexture2DArray)r.texImage3D(35866,0,v,f.width,f.height,f.depth,0,p,h,f.data),t.__maxMipLevel=0;else if(n.isDataTexture3D)r.texImage3D(32879,0,v,f.width,f.height,f.depth,0,p,h,f.data),t.__maxMipLevel=0;else if(m.length>0&&d){for(var R=0,A=m.length;R<A;R++)s=m[R],r.texImage2D(3553,R,v,p,h,s);n.generateMipmaps=!1,t.__maxMipLevel=m.length-1}else r.texImage2D(3553,0,v,p,h,f),t.__maxMipLevel=0;y(n,d)&&E(i,n,f.width,f.height),t.__version=n.version,n.onUpdate&&n.onUpdate(n)}function k(t,a,i,s){var l=o.convert(a.texture.format),c=o.convert(a.texture.type),f=w(a.texture.internalFormat,l,c);r.texImage2D(s,0,f,a.width,a.height,0,l,c,null),e.bindFramebuffer(36160,t),e.framebufferTexture2D(36160,i,s,n.get(a.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function N(t,r,n){if(e.bindRenderbuffer(36161,t),r.depthBuffer&&!r.stencilBuffer){var a=33189;if(n){var i=r.depthTexture;i&&i.isDepthTexture&&(1015===i.type?a=36012:1014===i.type&&(a=33190));var s=F(r);e.renderbufferStorageMultisample(36161,s,a,r.width,r.height)}else e.renderbufferStorage(36161,a,r.width,r.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(r.depthBuffer&&r.stencilBuffer){if(n){var l=F(r);e.renderbufferStorageMultisample(36161,l,35056,r.width,r.height)}else e.renderbufferStorage(36161,34041,r.width,r.height);e.framebufferRenderbuffer(36160,33306,36161,t)}else{var c=o.convert(r.texture.format),f=o.convert(r.texture.type),d=w(r.texture.internalFormat,c,f);if(n){var u=F(r);e.renderbufferStorageMultisample(36161,u,d,r.width,r.height)}else e.renderbufferStorage(36161,d,r.width,r.height)}e.bindRenderbuffer(36161,null)}function D(t){var r=n.get(t),a=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(a)throw new Error("target.depthTexture not supported in Cube render targets");!function(t,r){if(r&&r.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,t),!r.depthTexture||!r.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");n.get(r.depthTexture).__webglTexture&&r.depthTexture.image.width===r.width&&r.depthTexture.image.height===r.height||(r.depthTexture.image.width=r.width,r.depthTexture.image.height=r.height,r.depthTexture.needsUpdate=!0),R(r.depthTexture,0);var a=n.get(r.depthTexture).__webglTexture;if(1026===r.depthTexture.format)e.framebufferTexture2D(36160,36096,3553,a,0);else{if(1027!==r.depthTexture.format)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(36160,33306,3553,a,0)}}(r.__webglFramebuffer,t)}else if(a){r.__webglDepthbuffer=[];for(var o=0;o<6;o++)e.bindFramebuffer(36160,r.__webglFramebuffer[o]),r.__webglDepthbuffer[o]=e.createRenderbuffer(),N(r.__webglDepthbuffer[o],t,!1)}else e.bindFramebuffer(36160,r.__webglFramebuffer),r.__webglDepthbuffer=e.createRenderbuffer(),N(r.__webglDepthbuffer,t,!1);e.bindFramebuffer(36160,null)}function F(e){return c&&e.isWebGLMultisampleRenderTarget?Math.min(p,e.samples):0}L[1003]=9728,L[1004]=9984,L[1005]=9986,L[1006]=9729,L[1007]=9985,L[1008]=9987;var I=!1,O=!1;this.allocateTextureUnit=function(){var e=S;return e>=f&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+f),S+=1,e},this.resetTextureUnits=function(){S=0},this.setTexture2D=R,this.setTexture2DArray=function(e,t){var a=n.get(e);e.version>0&&a.__version!==e.version?z(a,e,t):(r.activeTexture(33984+t),r.bindTexture(35866,a.__webglTexture))},this.setTexture3D=function(e,t){var a=n.get(e);e.version>0&&a.__version!==e.version?z(a,e,t):(r.activeTexture(33984+t),r.bindTexture(32879,a.__webglTexture))},this.setTextureCube=A,this.setTextureCubeDynamic=M,this.setupRenderTarget=function(t){var a=n.get(t),i=n.get(t.texture);t.addEventListener("dispose",_),i.__webglTexture=e.createTexture(),s.memory.textures++;var l=!0===t.isWebGLCubeRenderTarget,f=!0===t.isWebGLMultisampleRenderTarget,d=g(t)||c;if(!c||1022!==t.texture.format||1015!==t.texture.type&&1016!==t.texture.type||(t.texture.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),l){a.__webglFramebuffer=[];for(var u=0;u<6;u++)a.__webglFramebuffer[u]=e.createFramebuffer()}else if(a.__webglFramebuffer=e.createFramebuffer(),f)if(c){a.__webglMultisampledFramebuffer=e.createFramebuffer(),a.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,a.__webglColorRenderbuffer);var p=o.convert(t.texture.format),h=o.convert(t.texture.type),v=w(t.texture.internalFormat,p,h),m=F(t);e.renderbufferStorageMultisample(36161,m,v,t.width,t.height),e.bindFramebuffer(36160,a.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,a.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),t.depthBuffer&&(a.__webglDepthRenderbuffer=e.createRenderbuffer(),N(a.__webglDepthRenderbuffer,t,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(l){r.bindTexture(34067,i.__webglTexture),H(34067,t.texture,d);for(var x=0;x<6;x++)k(a.__webglFramebuffer[x],t,36064,34069+x);y(t.texture,d)&&E(34067,t.texture,t.width,t.height),r.bindTexture(34067,null)}else r.bindTexture(3553,i.__webglTexture),H(3553,t.texture,d),k(a.__webglFramebuffer,t,36064,3553),y(t.texture,d)&&E(3553,t.texture,t.width,t.height),r.bindTexture(3553,null);t.depthBuffer&&D(t)},this.updateRenderTargetMipmap=function(e){var t=e.texture;if(y(t,g(e)||c)){var a=e.isWebGLCubeRenderTarget?34067:3553,o=n.get(t).__webglTexture;r.bindTexture(a,o),E(a,t,e.width,e.height),r.bindTexture(a,null)}},this.updateMultisampleRenderTarget=function(t){if(t.isWebGLMultisampleRenderTarget)if(c){var r=n.get(t);e.bindFramebuffer(36008,r.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,r.__webglFramebuffer);var a=t.width,o=t.height,i=16384;t.depthBuffer&&(i|=256),t.stencilBuffer&&(i|=1024),e.blitFramebuffer(0,0,a,o,0,0,a,o,i,9728),e.bindFramebuffer(36160,r.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(e,t){e&&e.isWebGLRenderTarget&&(!1===I&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),I=!0),e=e.texture),R(e,t)},this.safeSetTextureCube=function(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===O&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),O=!0),e=e.texture),e&&e.isCubeTexture||Array.isArray(e.image)&&6===e.image.length?A(e,t):M(e,t)}}function Kn(e,t,r){var n=r.isWebGL2;return{convert:function(e){var r;if(1009===e)return 5121;if(1017===e)return 32819;if(1018===e)return 32820;if(1019===e)return 33635;if(1010===e)return 5120;if(1011===e)return 5122;if(1012===e)return 5123;if(1013===e)return 5124;if(1014===e)return 5125;if(1015===e)return 5126;if(1016===e)return n?5131:null!==(r=t.get("OES_texture_half_float"))?r.HALF_FLOAT_OES:null;if(1021===e)return 6406;if(1022===e)return 6407;if(1023===e)return 6408;if(1024===e)return 6409;if(1025===e)return 6410;if(1026===e)return 6402;if(1027===e)return 34041;if(1028===e)return 6403;if(1029===e)return 36244;if(1030===e)return 33319;if(1031===e)return 33320;if(1032===e)return 36248;if(1033===e)return 36249;if(33776===e||33777===e||33778===e||33779===e){if(null===(r=t.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===e)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===e)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===e)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===e)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===e||35841===e||35842===e||35843===e){if(null===(r=t.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===e)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===e)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===e)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===e)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===e)return null!==(r=t.get("WEBGL_compressed_texture_etc1"))?r.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===e||37496===e)&&null!==(r=t.get("WEBGL_compressed_texture_etc"))){if(37492===e)return r.COMPRESSED_RGB8_ETC2;if(37496===e)return r.COMPRESSED_RGBA8_ETC2_EAC}return 37808===e||37809===e||37810===e||37811===e||37812===e||37813===e||37814===e||37815===e||37816===e||37817===e||37818===e||37819===e||37820===e||37821===e||37840===e||37841===e||37842===e||37843===e||37844===e||37845===e||37846===e||37847===e||37848===e||37849===e||37850===e||37851===e||37852===e||37853===e?null!==(r=t.get("WEBGL_compressed_texture_astc"))?e:null:36492===e?null!==(r=t.get("EXT_texture_compression_bptc"))?e:null:1020===e?n?34042:null!==(r=t.get("WEBGL_depth_texture"))?r.UNSIGNED_INT_24_8_WEBGL:null:void 0}}}function Jn(e){Vt.call(this),this.cameras=e||[]}function $n(){j.call(this),this.type="Group"}function ea(){this._targetRay=null,this._grip=null,this._hand=null}function ta(e,t){var r=this,n=null,a=1,o=null,i="local-floor",s=null,l=[],c=new Map,f=new Vt;f.layers.enable(1),f.viewport=new u;var d=new Vt;d.layers.enable(2),d.viewport=new u;var p=[f,d],h=new Jn;h.layers.enable(1),h.layers.enable(2);var v=null,m=null;function x(e){var t=c.get(e.inputSource);t&&t.dispatchEvent({type:e.type})}function y(){c.forEach((function(e,t){e.disconnect(t)})),c.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),R.stop(),r.isPresenting=!1,r.dispatchEvent({type:"sessionend"})}function E(e){o=e,R.setContext(n),R.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}function w(e){for(var t=n.inputSources,r=0;r<l.length;r++)c.set(t[r],l[r]);for(var a=0;a<e.removed.length;a++){var o=e.removed[a],i=c.get(o);i&&(i.dispatchEvent({type:"disconnected",data:o}),c.delete(o))}for(var s=0;s<e.added.length;s++){var f=e.added[s],d=c.get(f);d&&d.dispatchEvent({type:"connected",data:f})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){var t=l[e];return void 0===t&&(t=new ea,l[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){var t=l[e];return void 0===t&&(t=new ea,l[e]=t),t.getGripSpace()},this.getHand=function(e){var t=l[e];return void 0===t&&(t=new ea,l[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){a=e,!0===r.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){i=e,!0===r.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getSession=function(){return n},this.setSession=function(e){if(null!==(n=e)){n.addEventListener("select",x),n.addEventListener("selectstart",x),n.addEventListener("selectend",x),n.addEventListener("squeeze",x),n.addEventListener("squeezestart",x),n.addEventListener("squeezeend",x),n.addEventListener("end",y);var r=t.getContextAttributes();!0!==r.xrCompatible&&t.makeXRCompatible();var o={antialias:r.antialias,alpha:r.alpha,depth:r.depth,stencil:r.stencil,framebufferScaleFactor:a},s=new XRWebGLLayer(n,t,o);n.updateRenderState({baseLayer:s}),n.requestReferenceSpace(i).then(E),n.addEventListener("inputsourceschange",w)}};var b=new g,T=new g;function _(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.getInverse(e.matrixWorld)}this.getCamera=function(e){h.near=d.near=f.near=e.near,h.far=d.far=f.far=e.far,v===h.near&&m===h.far||(n.updateRenderState({depthNear:h.near,depthFar:h.far}),v=h.near,m=h.far);var t=e.parent,r=h.cameras;_(h,t);for(var a=0;a<r.length;a++)_(r[a],t);e.matrixWorld.copy(h.matrixWorld);for(var o=e.children,i=0,s=o.length;i<s;i++)o[i].updateMatrixWorld(!0);return 2===r.length?function(e,t,r){b.setFromMatrixPosition(t.matrixWorld),T.setFromMatrixPosition(r.matrixWorld);var n=b.distanceTo(T),a=t.projectionMatrix.elements,o=r.projectionMatrix.elements,i=a[14]/(a[10]-1),s=a[14]/(a[10]+1),l=(a[9]+1)/a[5],c=(a[9]-1)/a[5],f=(a[8]-1)/a[0],d=(o[8]+1)/o[0],u=i*f,p=i*d,h=n/(-f+d),v=h*-f;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(v),e.translateZ(h),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.getInverse(e.matrixWorld);var m=i+h,x=s+h,g=u-v,y=p+(n-v),E=l*s/x*m,w=c*s/x*m;e.projectionMatrix.makePerspective(g,y,E,w,m,x)}(h,f,d):h.projectionMatrix.copy(f.projectionMatrix),h};var S=null,R=new Kt;R.setAnimationLoop((function(t,r){if(null!==(s=r.getViewerPose(o))){var a=s.views,i=n.renderState.baseLayer;e.setFramebuffer(i.framebuffer);var c=!1;a.length!==h.cameras.length&&(h.cameras.length=0,c=!0);for(var f=0;f<a.length;f++){var d=a[f],u=i.getViewport(d),v=p[f];v.matrix.fromArray(d.transform.matrix),v.projectionMatrix.fromArray(d.projectionMatrix),v.viewport.set(u.x,u.y,u.width,u.height),0===f&&h.matrix.copy(v.matrix),!0===c&&h.cameras.push(v)}}for(var m=n.inputSources,x=0;x<l.length;x++){var g=l[x],y=m[x];g.update(y,r,o)}S&&S(t,r)})),this.setAnimationLoop=function(e){S=e},this.dispose=function(){}}function ra(e){function t(t,r,n){t.opacity.value=r.opacity,r.color&&t.diffuse.value.copy(r.color),r.emissive&&t.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(t.map.value=r.map),r.alphaMap&&(t.alphaMap.value=r.alphaMap),r.specularMap&&(t.specularMap.value=r.specularMap);var a,o,i=r.envMap||n;if(i){t.envMap.value=i,t.flipEnvMap.value=i.isCubeTexture?-1:1,t.reflectivity.value=r.reflectivity,t.refractionRatio.value=r.refractionRatio;var s=e.get(i).__maxMipLevel;void 0!==s&&(t.maxMipLevel.value=s)}r.lightMap&&(t.lightMap.value=r.lightMap,t.lightMapIntensity.value=r.lightMapIntensity),r.aoMap&&(t.aoMap.value=r.aoMap,t.aoMapIntensity.value=r.aoMapIntensity),r.map?a=r.map:r.specularMap?a=r.specularMap:r.displacementMap?a=r.displacementMap:r.normalMap?a=r.normalMap:r.bumpMap?a=r.bumpMap:r.roughnessMap?a=r.roughnessMap:r.metalnessMap?a=r.metalnessMap:r.alphaMap?a=r.alphaMap:r.emissiveMap&&(a=r.emissiveMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uvTransform.value.copy(a.matrix)),r.aoMap?o=r.aoMap:r.lightMap&&(o=r.lightMap),void 0!==o&&(o.isWebGLRenderTarget&&(o=o.texture),!0===o.matrixAutoUpdate&&o.updateMatrix(),t.uv2Transform.value.copy(o.matrix))}function r(e,t,r){e.roughness.value=t.roughness,e.metalness.value=t.metalness,t.roughnessMap&&(e.roughnessMap.value=t.roughnessMap),t.metalnessMap&&(e.metalnessMap.value=t.metalnessMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),(t.envMap||r)&&(e.envMapIntensity.value=t.envMapIntensity)}return{refreshFogUniforms:function(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function(e,n,a,o,i){n.isMeshBasicMaterial?t(e,n):n.isMeshLambertMaterial?(t(e,n),function(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}(e,n)):n.isMeshToonMaterial?(t(e,n),function(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,n)):n.isMeshPhongMaterial?(t(e,n),function(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,n)):n.isMeshStandardMaterial?(t(e,n,a),n.isMeshPhysicalMaterial?function(e,t,n){r(e,t,n),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,1===t.side&&e.clearcoatNormalScale.value.negate()),e.transmission.value=t.transmission,t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap)}(e,n,a):r(e,n,a)):n.isMeshMatcapMaterial?(t(e,n),function(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,n)):n.isMeshDepthMaterial?(t(e,n),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,n)):n.isMeshDistanceMaterial?(t(e,n),function(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,n)):n.isMeshNormalMaterial?(t(e,n),function(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,1===t.side&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),1===t.side&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}(e,n)):n.isLineBasicMaterial?(function(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,n),n.isLineDashedMaterial&&function(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,n)):n.isPointsMaterial?function(e,t,r,n){var a;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*r,e.scale.value=.5*n,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?a=t.map:t.alphaMap&&(a=t.alphaMap),void 0!==a&&(!0===a.matrixAutoUpdate&&a.updateMatrix(),e.uvTransform.value.copy(a.matrix))}(e,n,o,i):n.isSpriteMaterial?function(e,t){var r;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?r=t.map:t.alphaMap&&(r=t.alphaMap),void 0!==r&&(!0===r.matrixAutoUpdate&&r.updateMatrix(),e.uvTransform.value.copy(r.matrix))}(e,n):n.isShadowMaterial?(e.color.value.copy(n.color),e.opacity.value=n.opacity):n.isShaderMaterial&&(n.uniformsNeedUpdate=!1)}}}function na(e){var t=void 0!==(e=e||{}).canvas?e.canvas:document.createElementNS("http://www.w3.org/1999/xhtml","canvas"),r=void 0!==e.context?e.context:null,n=void 0!==e.alpha&&e.alpha,a=void 0===e.depth||e.depth,o=void 0===e.stencil||e.stencil,l=void 0!==e.antialias&&e.antialias,c=void 0===e.premultipliedAlpha||e.premultipliedAlpha,f=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,d=void 0!==e.powerPreference?e.powerPreference:"default",p=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat,h=null,v=null;this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3e3,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;var m=this,x=!1,y=null,E=0,w=0,b=null,T=null,_=-1,S=null,A=null,M=new u,C=new u,L=null,H=t.width,P=t.height,z=1,k=null,N=null,D=new u(0,0,H,P),F=new u(0,0,H,P),I=!1,O=new Zt,U=new sr,G=!1,B=!1,V=new R,j=new g,W={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function q(){return null===b?z:1}var X,Y,Z,Q,K,J,$,ee,te,re,ne,ae,oe,ie,se,le,ce,fe,de,ue=r;function pe(e,r){for(var n=0;n<e.length;n++){var a=e[n],o=t.getContext(a,r);if(null!==o)return o}return null}try{var he={alpha:n,depth:a,stencil:o,antialias:l,premultipliedAlpha:c,preserveDrawingBuffer:f,powerPreference:d,failIfMajorPerformanceCaveat:p};if(t.addEventListener("webglcontextlost",ye,!1),t.addEventListener("webglcontextrestored",Ee,!1),null===ue){var ve=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&ve.shift(),null===(ue=pe(ve,he)))throw pe(ve)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ue.getShaderPrecisionFormat&&(ue.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function me(){X=new lr(ue),!1===(Y=new ir(ue,X,e)).isWebGL2&&(X.get("WEBGL_depth_texture"),X.get("OES_texture_float"),X.get("OES_texture_half_float"),X.get("OES_texture_half_float_linear"),X.get("OES_standard_derivatives"),X.get("OES_element_index_uint"),X.get("OES_vertex_array_object"),X.get("ANGLE_instanced_arrays")),X.get("OES_texture_float_linear"),fe=new Kn(ue,X,Y),(Z=new Zn(ue,X,Y)).scissor(C.copy(F).multiplyScalar(z).floor()),Z.viewport(M.copy(D).multiplyScalar(z).floor()),Q=new dr(ue),K=new Nn,J=new Qn(ue,X,Z,K,Y,fe,Q),$=new Jt(ue,Y),de=new ar(ue,X,$,Y),ee=new cr(ue,$,Q,de),te=new vr(ue,ee,$,Q),se=new hr(ue),re=new kn(m,X,Y,de),ne=new ra(K),ae=new On(K),oe=new Wn,ie=new nr(m,Z,te,c),le=new or(ue,X,Q,Y),ce=new fr(ue,X,Q,Y),Q.programs=re.programs,m.capabilities=Y,m.extensions=X,m.properties=K,m.renderLists=ae,m.state=Z,m.info=Q}me();var xe=new ta(m,ue);this.xr=xe;var ge=new Yn(m,te,Y.maxTextureSize);function ye(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),x=!0}function Ee(){console.log("THREE.WebGLRenderer: Context Restored."),x=!1,me()}function we(e){var t=e.target;t.removeEventListener("dispose",we),function(e){be(e),K.remove(e)}(t)}function be(e){var t=K.get(e).program;void 0!==t&&re.releaseProgram(t)}this.shadowMap=ge,this.getContext=function(){return ue},this.getContextAttributes=function(){return ue.getContextAttributes()},this.forceContextLoss=function(){var e=X.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){var e=X.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return z},this.setPixelRatio=function(e){void 0!==e&&(z=e,this.setSize(H,P,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new s),e.set(H,P)},this.setSize=function(e,r,n){xe.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(H=e,P=r,t.width=Math.floor(e*z),t.height=Math.floor(r*z),!1!==n&&(t.style.width=e+"px",t.style.height=r+"px"),this.setViewport(0,0,e,r))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new s),e.set(H*z,P*z).floor()},this.setDrawingBufferSize=function(e,r,n){H=e,P=r,z=n,t.width=Math.floor(e*n),t.height=Math.floor(r*n),this.setViewport(0,0,e,r)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new u),e.copy(M)},this.getViewport=function(e){return e.copy(D)},this.setViewport=function(e,t,r,n){e.isVector4?D.set(e.x,e.y,e.z,e.w):D.set(e,t,r,n),Z.viewport(M.copy(D).multiplyScalar(z).floor())},this.getScissor=function(e){return e.copy(F)},this.setScissor=function(e,t,r,n){e.isVector4?F.set(e.x,e.y,e.z,e.w):F.set(e,t,r,n),Z.scissor(C.copy(F).multiplyScalar(z).floor())},this.getScissorTest=function(){return I},this.setScissorTest=function(e){Z.setScissorTest(I=e)},this.setOpaqueSort=function(e){k=e},this.setTransparentSort=function(e){N=e},this.getClearColor=function(){return ie.getClearColor()},this.setClearColor=function(){ie.setClearColor.apply(ie,arguments)},this.getClearAlpha=function(){return ie.getClearAlpha()},this.setClearAlpha=function(){ie.setClearAlpha.apply(ie,arguments)},this.clear=function(e,t,r){var n=0;(void 0===e||e)&&(n|=16384),(void 0===t||t)&&(n|=256),(void 0===r||r)&&(n|=1024),ue.clear(n)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",ye,!1),t.removeEventListener("webglcontextrestored",Ee,!1),ae.dispose(),oe.dispose(),K.dispose(),te.dispose(),de.dispose(),xe.dispose(),_e.stop()},this.renderBufferImmediate=function(e,t){de.initAttributes();var r=K.get(e);e.hasPositions&&!r.position&&(r.position=ue.createBuffer()),e.hasNormals&&!r.normal&&(r.normal=ue.createBuffer()),e.hasUvs&&!r.uv&&(r.uv=ue.createBuffer()),e.hasColors&&!r.color&&(r.color=ue.createBuffer());var n=t.getAttributes();e.hasPositions&&(ue.bindBuffer(34962,r.position),ue.bufferData(34962,e.positionArray,35048),de.enableAttribute(n.position),ue.vertexAttribPointer(n.position,3,5126,!1,0,0)),e.hasNormals&&(ue.bindBuffer(34962,r.normal),ue.bufferData(34962,e.normalArray,35048),de.enableAttribute(n.normal),ue.vertexAttribPointer(n.normal,3,5126,!1,0,0)),e.hasUvs&&(ue.bindBuffer(34962,r.uv),ue.bufferData(34962,e.uvArray,35048),de.enableAttribute(n.uv),ue.vertexAttribPointer(n.uv,2,5126,!1,0,0)),e.hasColors&&(ue.bindBuffer(34962,r.color),ue.bufferData(34962,e.colorArray,35048),de.enableAttribute(n.color),ue.vertexAttribPointer(n.color,3,5126,!1,0,0)),de.disableUnusedAttributes(),ue.drawArrays(4,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,r,n,a,o){null===t&&(t=W);var i=a.isMesh&&a.matrixWorld.determinant()<0,s=Ce(e,t,n,a);Z.setMaterial(n,i);var l=r.index,c=r.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;var f,d=1;!0===n.wireframe&&(l=ee.getWireframeAttribute(r),d=2),(n.morphTargets||n.morphNormals)&&se.update(a,r,n,s),de.setup(a,n,s,r,l);var u=le;null!==l&&(f=$.get(l),(u=ce).setIndex(f));var p=null!==l?l.count:c.count,h=r.drawRange.start*d,v=r.drawRange.count*d,m=null!==o?o.start*d:0,x=null!==o?o.count*d:1/0,g=Math.max(h,m),y=Math.min(p,h+v,m+x)-1,E=Math.max(0,y-g+1);if(0!==E){if(a.isMesh)!0===n.wireframe?(Z.setLineWidth(n.wireframeLinewidth*q()),u.setMode(1)):u.setMode(4);else if(a.isLine){var w=n.linewidth;void 0===w&&(w=1),Z.setLineWidth(w*q()),a.isLineSegments?u.setMode(1):a.isLineLoop?u.setMode(2):u.setMode(3)}else a.isPoints?u.setMode(0):a.isSprite&&u.setMode(4);if(a.isInstancedMesh)u.renderInstances(g,E,a.count);else if(r.isInstancedBufferGeometry){var b=Math.min(r.instanceCount,r._maxInstanceCount);u.renderInstances(g,E,b)}else u.render(g,E)}},this.compile=function(e,t){(v=oe.get(e,t)).init(),e.traverse((function(e){e.isLight&&(v.pushLight(e),e.castShadow&&v.pushShadow(e))})),v.setupLights(t);var r=new WeakMap;e.traverse((function(t){var n=t.material;if(n)if(Array.isArray(n))for(var a=0;a<n.length;a++){var o=n[a];!1===r.has(o)&&(Me(o,e,t),r.set(o))}else!1===r.has(n)&&(Me(n,e,t),r.set(n))}))};var Te=null,_e=new Kt;function Se(e,t,r,n){if(!1!==e.visible){if(e.layers.test(t.layers))if(e.isGroup)r=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)v.pushLight(e),e.castShadow&&v.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||O.intersectsSprite(e)){n&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);var a=te.update(e),o=e.material;o.visible&&h.push(e,a,o,r,j.z,null)}}else if(e.isImmediateRenderObject)n&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V),h.push(e,null,e.material,r,j.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==Q.render.frame&&(e.skeleton.update(),e.skeleton.frame=Q.render.frame),!e.frustumCulled||O.intersectsObject(e))){n&&j.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);var i=te.update(e),s=e.material;if(Array.isArray(s))for(var l=i.groups,c=0,f=l.length;c<f;c++){var d=l[c],u=s[d.materialIndex];u&&u.visible&&h.push(e,i,u,r,j.z,d)}else s.visible&&h.push(e,i,s,r,j.z,null)}for(var p=e.children,m=0,x=p.length;m<x;m++)Se(p[m],t,r,n)}}function Re(e,t,r){for(var n=!0===t.isScene?t.overrideMaterial:null,a=0,o=e.length;a<o;a++){var i=e[a],s=i.object,l=i.geometry,c=null===n?i.material:n,f=i.group;if(r.isArrayCamera){A=r;for(var d=r.cameras,u=0,p=d.length;u<p;u++){var h=d[u];s.layers.test(h.layers)&&(Z.viewport(M.copy(h.viewport)),v.setupLights(h),Ae(s,t,h,l,c,f))}}else A=null,Ae(s,t,r,l,c,f)}}function Ae(e,t,r,n,a,o){if(e.onBeforeRender(m,t,r,n,a,o),v=oe.get(t,A||r),e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){var i=Ce(r,t,a,e);Z.setMaterial(a),de.reset(),function(e,t){e.render((function(e){m.renderBufferImmediate(e,t)}))}(e,i)}else m.renderBufferDirect(r,t,n,a,e,o);e.onAfterRender(m,t,r,n,a,o),v=oe.get(t,A||r)}function Me(e,t,r){!0!==t.isScene&&(t=W);var n=K.get(e),a=v.state.lights,o=v.state.shadowsArray,i=a.state.version,s=re.getParameters(e,a.state,o,t,U.numPlanes,U.numIntersection,r),l=re.getProgramCacheKey(s),c=n.program,f=!0;if(void 0===c)e.addEventListener("dispose",we);else if(c.cacheKey!==l)be(e);else if(n.lightsStateVersion!==i)n.lightsStateVersion=i,f=!1;else{if(void 0!==s.shaderID)return;f=!1}f&&(s.uniforms=re.getUniforms(e,s),e.onBeforeCompile(s,m),c=re.acquireProgram(s,l),n.program=c,n.uniforms=s.uniforms,n.outputEncoding=s.outputEncoding);var d=c.getAttributes();if(e.morphTargets){e.numSupportedMorphTargets=0;for(var u=0;u<m.maxMorphTargets;u++)d["morphTarget"+u]>=0&&e.numSupportedMorphTargets++}if(e.morphNormals){e.numSupportedMorphNormals=0;for(var p=0;p<m.maxMorphNormals;p++)d["morphNormal"+p]>=0&&e.numSupportedMorphNormals++}var h=n.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(n.numClippingPlanes=U.numPlanes,n.numIntersection=U.numIntersection,h.clippingPlanes=U.uniform),n.environment=e.isMeshStandardMaterial?t.environment:null,n.fog=t.fog,n.needsLights=function(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),n.lightsStateVersion=i,n.needsLights&&(h.ambientLightColor.value=a.state.ambient,h.lightProbe.value=a.state.probe,h.directionalLights.value=a.state.directional,h.directionalLightShadows.value=a.state.directionalShadow,h.spotLights.value=a.state.spot,h.spotLightShadows.value=a.state.spotShadow,h.rectAreaLights.value=a.state.rectArea,h.pointLights.value=a.state.point,h.pointLightShadows.value=a.state.pointShadow,h.hemisphereLights.value=a.state.hemi,h.directionalShadowMap.value=a.state.directionalShadowMap,h.directionalShadowMatrix.value=a.state.directionalShadowMatrix,h.spotShadowMap.value=a.state.spotShadowMap,h.spotShadowMatrix.value=a.state.spotShadowMatrix,h.pointShadowMap.value=a.state.pointShadowMap,h.pointShadowMatrix.value=a.state.pointShadowMatrix);var x=n.program.getUniforms(),g=hn.seqWithValue(x.seq,h);n.uniformsList=g}function Ce(e,t,r,n){!0!==t.isScene&&(t=W),J.resetTextureUnits();var a=t.fog,o=r.isMeshStandardMaterial?t.environment:null,s=null===b?m.outputEncoding:b.texture.encoding,l=K.get(r),c=v.state.lights;if(!0===G&&(!0===B||e!==S)){var f=e===S&&r.id===_;U.setState(r.clippingPlanes,r.clipIntersection,r.clipShadows,e,l,f)}r.version===l.__version?void 0===l.program||r.fog&&l.fog!==a||l.environment!==o||l.needsLights&&l.lightsStateVersion!==c.state.version?Me(r,t,n):void 0===l.numClippingPlanes||l.numClippingPlanes===U.numPlanes&&l.numIntersection===U.numIntersection?l.outputEncoding!==s&&Me(r,t,n):Me(r,t,n):(Me(r,t,n),l.__version=r.version);var d,u,p=!1,h=!1,x=!1,g=l.program,y=g.getUniforms(),E=l.uniforms;if(Z.useProgram(g.program)&&(p=!0,h=!0,x=!0),r.id!==_&&(_=r.id,h=!0),p||S!==e){if(y.setValue(ue,"projectionMatrix",e.projectionMatrix),Y.logarithmicDepthBuffer&&y.setValue(ue,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),S!==e&&(S=e,h=!0,x=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){var w=y.map.cameraPosition;void 0!==w&&w.setValue(ue,j.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&y.setValue(ue,"isOrthographic",!0===e.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||r.skinning)&&y.setValue(ue,"viewMatrix",e.matrixWorldInverse)}if(r.skinning){y.setOptional(ue,n,"bindMatrix"),y.setOptional(ue,n,"bindMatrixInverse");var T=n.skeleton;if(T){var R=T.bones;if(Y.floatVertexTextures){if(void 0===T.boneTexture){var A=Math.sqrt(4*R.length);A=i.ceilPowerOfTwo(A),A=Math.max(A,4);var M=new Float32Array(A*A*4);M.set(T.boneMatrices);var C=new qt(M,A,A,1023,1015);T.boneMatrices=M,T.boneTexture=C,T.boneTextureSize=A}y.setValue(ue,"boneTexture",T.boneTexture,J),y.setValue(ue,"boneTextureSize",T.boneTextureSize)}else y.setOptional(ue,T,"boneMatrices")}}return(h||l.receiveShadow!==n.receiveShadow)&&(l.receiveShadow=n.receiveShadow,y.setValue(ue,"receiveShadow",n.receiveShadow)),h&&(y.setValue(ue,"toneMappingExposure",m.toneMappingExposure),l.needsLights&&(u=x,(d=E).ambientLightColor.needsUpdate=u,d.lightProbe.needsUpdate=u,d.directionalLights.needsUpdate=u,d.directionalLightShadows.needsUpdate=u,d.pointLights.needsUpdate=u,d.pointLightShadows.needsUpdate=u,d.spotLights.needsUpdate=u,d.spotLightShadows.needsUpdate=u,d.rectAreaLights.needsUpdate=u,d.hemisphereLights.needsUpdate=u),a&&r.fog&&ne.refreshFogUniforms(E,a),ne.refreshMaterialUniforms(E,r,o,z,P),void 0!==E.ltc_1&&(E.ltc_1.value=Qt.LTC_1),void 0!==E.ltc_2&&(E.ltc_2.value=Qt.LTC_2),hn.upload(ue,l.uniformsList,E,J)),r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(hn.upload(ue,l.uniformsList,E,J),r.uniformsNeedUpdate=!1),r.isSpriteMaterial&&y.setValue(ue,"center",n.center),y.setValue(ue,"modelViewMatrix",n.modelViewMatrix),y.setValue(ue,"normalMatrix",n.normalMatrix),y.setValue(ue,"modelMatrix",n.matrixWorld),g}_e.setAnimationLoop((function(e){xe.isPresenting||Te&&Te(e)})),"undefined"!=typeof window&&_e.setContext(window),this.setAnimationLoop=function(e){Te=e,xe.setAnimationLoop(e),null===e?_e.stop():_e.start()},this.render=function(e,t){var r,n;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),r=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),n=arguments[3]),void 0===t||!0===t.isCamera){if(!0!==x){de.resetDefaultState(),_=-1,S=null,!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===xe.enabled&&!0===xe.isPresenting&&(t=xe.getCamera(t)),!0===e.isScene&&e.onBeforeRender(m,e,t,r||b),(v=oe.get(e,t)).init(),V.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),O.setFromProjectionMatrix(V),B=this.localClippingEnabled,G=U.init(this.clippingPlanes,B,t),(h=ae.get(e,t)).init(),Se(e,t,0,m.sortObjects),h.finish(),!0===m.sortObjects&&h.sort(k,N),!0===G&&U.beginShadows();var a=v.state.shadowsArray;ge.render(a,e,t),v.setupLights(t),!0===G&&U.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==r&&this.setRenderTarget(r),ie.render(h,e,t,n);var o=h.opaque,i=h.transparent;o.length>0&&Re(o,e,t),i.length>0&&Re(i,e,t),!0===e.isScene&&e.onAfterRender(m,e,t),null!==b&&(J.updateRenderTargetMipmap(b),J.updateMultisampleRenderTarget(b)),Z.buffers.depth.setTest(!0),Z.buffers.depth.setMask(!0),Z.buffers.color.setMask(!0),Z.setPolygonOffset(!1),h=null,v=null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.setFramebuffer=function(e){y!==e&&null===b&&ue.bindFramebuffer(36160,e),y=e},this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return w},this.getRenderTarget=function(){return b},this.setRenderTarget=function(e,t,r){b=e,E=t,w=r,e&&void 0===K.get(e).__webglFramebuffer&&J.setupRenderTarget(e);var n=y,a=!1;if(e){var o=K.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(n=o[t||0],a=!0):n=e.isWebGLMultisampleRenderTarget?K.get(e).__webglMultisampledFramebuffer:o,M.copy(e.viewport),C.copy(e.scissor),L=e.scissorTest}else M.copy(D).multiplyScalar(z).floor(),C.copy(F).multiplyScalar(z).floor(),L=I;if(T!==n&&(ue.bindFramebuffer(36160,n),T=n),Z.viewport(M),Z.scissor(C),Z.setScissorTest(L),a){var i=K.get(e.texture);ue.framebufferTexture2D(36160,36064,34069+(t||0),i.__webglTexture,r||0)}},this.readRenderTargetPixels=function(e,t,r,n,a,o,i){if(e&&e.isWebGLRenderTarget){var s=K.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==i&&(s=s[i]),s){var l=!1;s!==T&&(ue.bindFramebuffer(36160,s),l=!0);try{var c=e.texture,f=c.format,d=c.type;if(1023!==f&&fe.convert(f)!==ue.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");if(!(1009===d||fe.convert(d)===ue.getParameter(35738)||1015===d&&(Y.isWebGL2||X.get("OES_texture_float")||X.get("WEBGL_color_buffer_float"))||1016===d&&(Y.isWebGL2?X.get("EXT_color_buffer_float"):X.get("EXT_color_buffer_half_float"))))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===ue.checkFramebufferStatus(36160)?t>=0&&t<=e.width-n&&r>=0&&r<=e.height-a&&ue.readPixels(t,r,n,a,fe.convert(f),fe.convert(d),o):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{l&&ue.bindFramebuffer(36160,T)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=function(e,t,r){void 0===r&&(r=0);var n=Math.pow(2,-r),a=Math.floor(t.image.width*n),o=Math.floor(t.image.height*n),i=fe.convert(t.format);J.setTexture2D(t,0),ue.copyTexImage2D(3553,r,i,e.x,e.y,a,o,0),Z.unbindTexture()},this.copyTextureToTexture=function(e,t,r,n){void 0===n&&(n=0);var a=t.image.width,o=t.image.height,i=fe.convert(r.format),s=fe.convert(r.type);J.setTexture2D(r,0),ue.pixelStorei(37440,r.flipY),ue.pixelStorei(37441,r.premultiplyAlpha),ue.pixelStorei(3317,r.unpackAlignment),t.isDataTexture?ue.texSubImage2D(3553,n,e.x,e.y,a,o,i,s,t.image.data):t.isCompressedTexture?ue.compressedTexSubImage2D(3553,n,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,i,t.mipmaps[0].data):ue.texSubImage2D(3553,n,e.x,e.y,i,s,t.image),0===n&&r.generateMipmaps&&ue.generateMipmap(3553),Z.unbindTexture()},this.initTexture=function(e){J.setTexture2D(e,0),Z.unbindTexture()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function aa(e){na.call(this,e)}function oa(e,t){this.name="",this.color=new Ne(e),this.density=void 0!==t?t:25e-5}function ia(e,t,r){this.name="",this.color=new Ne(e),this.near=void 0!==t?t:1,this.far=void 0!==r?r:1e3}function sa(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=i.generateUUID()}qn.prototype=Object.create(Ge.prototype),qn.prototype.constructor=qn,qn.prototype.isMeshDepthMaterial=!0,qn.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this},Xn.prototype=Object.create(Ge.prototype),Xn.prototype.constructor=Xn,Xn.prototype.isMeshDistanceMaterial=!0,Xn.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this},Jn.prototype=Object.assign(Object.create(Vt.prototype),{constructor:Jn,isArrayCamera:!0}),$n.prototype=Object.assign(Object.create(j.prototype),{constructor:$n,isGroup:!0}),Object.assign(ea.prototype,{constructor:ea,getHandSpace:function(){if(null===this._hand&&(this._hand=new $n,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(var e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){var t=new $n;t.matrixAutoUpdate=!1,t.visible=!1,this._hand.joints.push(t),this._hand.add(t)}return this._hand},getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new $n,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return null===this._grip&&(this._grip=new $n,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this},update:function(e,t,r){var n=null,a=null,o=null,i=this._targetRay,s=this._grip,l=this._hand;if(e)if(e.hand){o=!0;for(var c=0;c<=window.XRHand.LITTLE_PHALANX_TIP;c++)if(e.hand[c]){var f=t.getJointPose(e.hand[c],r),d=l.joints[c];null!==f&&(d.matrix.fromArray(f.transform.matrix),d.matrix.decompose(d.position,d.rotation,d.scale),d.jointRadius=f.radius),d.visible=null!==f;var u=l.joints[window.XRHand.INDEX_PHALANX_TIP],p=l.joints[window.XRHand.THUMB_PHALANX_TIP],h=u.position.distanceTo(p.position);l.inputState.pinching&&h>.025?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&h<=.015&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else null!==i&&null!==(n=t.getPose(e.targetRaySpace,r))&&(i.matrix.fromArray(n.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale)),null!==s&&e.gripSpace&&null!==(a=t.getPose(e.gripSpace,r))&&(s.matrix.fromArray(a.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale));return null!==i&&(i.visible=null!==n),null!==s&&(s.visible=null!==a),null!==l&&(l.visible=null!==o),this}}),Object.assign(ta.prototype,t.prototype),aa.prototype=Object.assign(Object.create(na.prototype),{constructor:aa,isWebGL1Renderer:!0}),Object.assign(oa.prototype,{isFogExp2:!0,clone:function(){return new oa(this.color,this.density)},toJSON:function(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}),Object.assign(ia.prototype,{isFog:!0,clone:function(){return new ia(this.color,this.near,this.far)},toJSON:function(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}),Object.defineProperty(sa.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}}),Object.assign(sa.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,r){e*=this.stride,r*=t.stride;for(var n=0,a=this.stride;n<a;n++)this.array[e+n]=t.array[r+n];return this},set:function(e,t){return void 0===t&&(t=0),this.array.set(e,t),this},clone:function(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=i.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);var t=new sa(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);return t.setUsage(this.usage),t},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=i.generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});var la,ca=new g;function fa(e,t,r,n){this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=!0===n}function da(e){Ge.call(this),this.type="SpriteMaterial",this.color=new Ne(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}Object.defineProperties(fa.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}}),Object.assign(fa.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(var t=0,r=this.data.count;t<r;t++)ca.x=this.getX(t),ca.y=this.getY(t),ca.z=this.getZ(t),ca.applyMatrix4(e),this.setXYZ(t,ca.x,ca.y,ca.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this},setXYZ:function(e,t,r,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=n,this},setXYZW:function(e,t,r,n,a){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=n,this.data.array[e+3]=a,this},clone:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");for(var t=[],r=0;r<this.count;r++)for(var n=r*this.data.stride+this.offset,a=0;a<this.itemSize;a++)t.push(this.data.array[n+a]);return new We(new this.array.constructor(t),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new fa(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");for(var t=[],r=0;r<this.count;r++)for(var n=r*this.data.stride+this.offset,a=0;a<this.itemSize;a++)t.push(this.data.array[n+a]);return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}),da.prototype=Object.create(Ge.prototype),da.prototype.constructor=da,da.prototype.isSpriteMaterial=!0,da.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};var ua=new g,pa=new g,ha=new g,va=new s,ma=new s,xa=new R,ga=new g,ya=new g,Ea=new g,wa=new s,ba=new s,Ta=new s;function _a(e){if(j.call(this),this.type="Sprite",void 0===la){la=new ft;var t=new sa(new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),5);la.setIndex([0,1,2,0,2,3]),la.setAttribute("position",new fa(t,3,0,!1)),la.setAttribute("uv",new fa(t,2,3,!1))}this.geometry=la,this.material=void 0!==e?e:new da,this.center=new s(.5,.5)}function Sa(e,t,r,n,a,o){va.subVectors(e,r).addScalar(.5).multiply(n),void 0!==a?(ma.x=o*va.x-a*va.y,ma.y=a*va.x+o*va.y):ma.copy(va),e.copy(t),e.x+=ma.x,e.y+=ma.y,e.applyMatrix4(xa)}_a.prototype=Object.assign(Object.create(j.prototype),{constructor:_a,isSprite:!0,raycast:function(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),pa.setFromMatrixScale(this.matrixWorld),xa.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),ha.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&pa.multiplyScalar(-ha.z);var r,n,a=this.material.rotation;0!==a&&(n=Math.cos(a),r=Math.sin(a));var o=this.center;Sa(ga.set(-.5,-.5,0),ha,o,pa,r,n),Sa(ya.set(.5,-.5,0),ha,o,pa,r,n),Sa(Ea.set(.5,.5,0),ha,o,pa,r,n),wa.set(0,0),ba.set(1,0),Ta.set(1,1);var i=e.ray.intersectTriangle(ga,ya,Ea,!1,ua);if(null!==i||(Sa(ya.set(-.5,.5,0),ha,o,pa,r,n),ba.set(0,1),null!==(i=e.ray.intersectTriangle(ga,Ea,ya,!1,ua)))){var l=e.ray.origin.distanceTo(ua);l<e.near||l>e.far||t.push({distance:l,point:ua.clone(),uv:He.getUV(ua,ga,ya,Ea,wa,ba,Ta,new s),face:null,object:this})}},copy:function(e){return j.prototype.copy.call(this,e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}});var Ra,Aa,Ma,Ca,La,Ha=new g,Pa=new g;function za(){j.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}function ka(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),Mt.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new R,this.bindMatrixInverse=new R}za.prototype=Object.assign(Object.create(j.prototype),{constructor:za,isLOD:!0,copy:function(e){j.prototype.copy.call(this,e,!1);for(var t=e.levels,r=0,n=t.length;r<n;r++){var a=t[r];this.addLevel(a.object.clone(),a.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t){void 0===t&&(t=0),t=Math.abs(t);var r,n=this.levels;for(r=0;r<n.length&&!(t<n[r].distance);r++);return n.splice(r,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){var t=this.levels;if(t.length>0){var r,n;for(r=1,n=t.length;r<n&&!(e<t[r].distance);r++);return t[r-1].object}return null},raycast:function(e,t){if(this.levels.length>0){Ha.setFromMatrixPosition(this.matrixWorld);var r=e.ray.origin.distanceTo(Ha);this.getObjectForDistance(r).raycast(e,t)}},update:function(e){var t=this.levels;if(t.length>1){Ha.setFromMatrixPosition(e.matrixWorld),Pa.setFromMatrixPosition(this.matrixWorld);var r,n,a=Ha.distanceTo(Pa)/e.zoom;for(t[0].object.visible=!0,r=1,n=t.length;r<n&&a>=t[r].distance;r++)t[r-1].object.visible=!1,t[r].object.visible=!0;for(this._currentLevel=r-1;r<n;r++)t[r].object.visible=!1}},toJSON:function(e){var t=j.prototype.toJSON.call(this,e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];for(var r=this.levels,n=0,a=r.length;n<a;n++){var o=r[n];t.object.levels.push({object:o.object.uuid,distance:o.distance})}return t}}),ka.prototype=Object.assign(Object.create(Mt.prototype),{constructor:ka,isSkinnedMesh:!0,copy:function(e){return Mt.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.getInverse(t)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){for(var e=new u,t=this.geometry.attributes.skinWeight,r=0,n=t.count;r<n;r++){e.x=t.getX(r),e.y=t.getY(r),e.z=t.getZ(r),e.w=t.getW(r);var a=1/e.manhattanLength();a!==1/0?e.multiplyScalar(a):e.set(1,0,0,0),t.setXYZW(r,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){Mt.prototype.updateMatrixWorld.call(this,e),"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:(Ra=new g,Aa=new u,Ma=new u,Ca=new g,La=new R,function(e,t){var r=this.skeleton,n=this.geometry;Aa.fromBufferAttribute(n.attributes.skinIndex,e),Ma.fromBufferAttribute(n.attributes.skinWeight,e),Ra.fromBufferAttribute(n.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(var a=0;a<4;a++){var o=Ma.getComponent(a);if(0!==o){var i=Aa.getComponent(a);La.multiplyMatrices(r.bones[i].matrixWorld,r.boneInverses[i]),t.addScaledVector(Ca.copy(Ra).applyMatrix4(La),o)}}return t.applyMatrix4(this.bindMatrixInverse)})});var Na=new R,Da=new R;function Fa(e,t){if(e=e||[],this.bones=e.slice(0),this.boneMatrices=new Float32Array(16*this.bones.length),this.frame=-1,void 0===t)this.calculateInverses();else if(this.bones.length===t.length)this.boneInverses=t.slice(0);else{console.warn("THREE.Skeleton boneInverses is the wrong length."),this.boneInverses=[];for(var r=0,n=this.bones.length;r<n;r++)this.boneInverses.push(new R)}}function Ia(){j.call(this),this.type="Bone"}Object.assign(Fa.prototype,{calculateInverses:function(){this.boneInverses=[];for(var e=0,t=this.bones.length;e<t;e++){var r=new R;this.bones[e]&&r.getInverse(this.bones[e].matrixWorld),this.boneInverses.push(r)}},pose:function(){for(var e=0,t=this.bones.length;e<t;e++){var r=this.bones[e];r&&r.matrixWorld.getInverse(this.boneInverses[e])}for(var n=0,a=this.bones.length;n<a;n++){var o=this.bones[n];o&&(o.parent&&o.parent.isBone?(o.matrix.getInverse(o.parent.matrixWorld),o.matrix.multiply(o.matrixWorld)):o.matrix.copy(o.matrixWorld),o.matrix.decompose(o.position,o.quaternion,o.scale))}},update:function(){for(var e=this.bones,t=this.boneInverses,r=this.boneMatrices,n=this.boneTexture,a=0,o=e.length;a<o;a++){var i=e[a]?e[a].matrixWorld:Da;Na.multiplyMatrices(i,t[a]),Na.toArray(r,16*a)}void 0!==n&&(n.needsUpdate=!0)},clone:function(){return new Fa(this.bones,this.boneInverses)},getBoneByName:function(e){for(var t=0,r=this.bones.length;t<r;t++){var n=this.bones[t];if(n.name===e)return n}},dispose:function(){this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=void 0)}}),Ia.prototype=Object.assign(Object.create(j.prototype),{constructor:Ia,isBone:!0});var Oa=new R,Ua=new R,Ga=[],Ba=new Mt;function Va(e,t,r){Mt.call(this,e,t),this.instanceMatrix=new We(new Float32Array(16*r),16),this.count=r,this.frustumCulled=!1}function ja(e){Ge.call(this),this.type="LineBasicMaterial",this.color=new Ne(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}Va.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Va,isInstancedMesh:!0,copy:function(e){return Mt.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,16*e)},raycast:function(e,t){var r=this.matrixWorld,n=this.count;if(Ba.geometry=this.geometry,Ba.material=this.material,void 0!==Ba.material)for(var a=0;a<n;a++){this.getMatrixAt(a,Oa),Ua.multiplyMatrices(r,Oa),Ba.matrixWorld=Ua,Ba.raycast(e,Ga);for(var o=0,i=Ga.length;o<i;o++){var s=Ga[o];s.instanceId=a,s.object=this,t.push(s)}Ga.length=0}},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,16*e)},updateMorphTargets:function(){}}),ja.prototype=Object.create(Ge.prototype),ja.prototype.constructor=ja,ja.prototype.isLineBasicMaterial=!0,ja.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};var Wa=new g,qa=new g,Xa=new R,Ya=new me,Za=new le;function Qa(e,t,r){1===r&&console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),j.call(this),this.type="Line",this.geometry=void 0!==e?e:new ft,this.material=void 0!==t?t:new ja,this.updateMorphTargets()}Qa.prototype=Object.assign(Object.create(j.prototype),{constructor:Qa,isLine:!0,copy:function(e){return j.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){var e=this.geometry;if(e.isBufferGeometry)if(null===e.index){for(var t=e.attributes.position,r=[0],n=1,a=t.count;n<a;n++)Wa.fromBufferAttribute(t,n-1),qa.fromBufferAttribute(t,n),r[n]=r[n-1],r[n]+=Wa.distanceTo(qa);e.setAttribute("lineDistance",new $e(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){var o=e.vertices,i=e.lineDistances;i[0]=0;for(var s=1,l=o.length;s<l;s++)i[s]=i[s-1],i[s]+=o[s-1].distanceTo(o[s])}return this},raycast:function(e,t){var r=this.geometry,n=this.matrixWorld,a=e.params.Line.threshold;if(null===r.boundingSphere&&r.computeBoundingSphere(),Za.copy(r.boundingSphere),Za.applyMatrix4(n),Za.radius+=a,!1!==e.ray.intersectsSphere(Za)){Xa.getInverse(n),Ya.copy(e.ray).applyMatrix4(Xa);var o=a/((this.scale.x+this.scale.y+this.scale.z)/3),i=o*o,s=new g,l=new g,c=new g,f=new g,d=this&&this.isLineSegments?2:1;if(r.isBufferGeometry){var u=r.index,p=r.attributes.position.array;if(null!==u)for(var h=u.array,v=0,m=h.length-1;v<m;v+=d){var x=h[v],y=h[v+1];if(s.fromArray(p,3*x),l.fromArray(p,3*y),!(Ya.distanceSqToSegment(s,l,f,c)>i)){f.applyMatrix4(this.matrixWorld);var E=e.ray.origin.distanceTo(f);E<e.near||E>e.far||t.push({distance:E,point:c.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}else for(var w=0,b=p.length/3-1;w<b;w+=d)if(s.fromArray(p,3*w),l.fromArray(p,3*w+3),!(Ya.distanceSqToSegment(s,l,f,c)>i)){f.applyMatrix4(this.matrixWorld);var T=e.ray.origin.distanceTo(f);T<e.near||T>e.far||t.push({distance:T,point:c.clone().applyMatrix4(this.matrixWorld),index:w,face:null,faceIndex:null,object:this})}}else if(r.isGeometry)for(var _=r.vertices,S=_.length,R=0;R<S-1;R+=d)if(!(Ya.distanceSqToSegment(_[R],_[R+1],f,c)>i)){f.applyMatrix4(this.matrixWorld);var A=e.ray.origin.distanceTo(f);A<e.near||A>e.far||t.push({distance:A,point:c.clone().applyMatrix4(this.matrixWorld),index:R,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){var e=this.geometry;if(e.isBufferGeometry){var t=e.morphAttributes,r=Object.keys(t);if(r.length>0){var n=t[r[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var a=0,o=n.length;a<o;a++){var i=n[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=a}}}}else{var s=e.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});var Ka=new g,Ja=new g;function $a(e,t){Qa.call(this,e,t),this.type="LineSegments"}function eo(e,t){Qa.call(this,e,t),this.type="LineLoop"}function to(e){Ge.call(this),this.type="PointsMaterial",this.color=new Ne(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}$a.prototype=Object.assign(Object.create(Qa.prototype),{constructor:$a,isLineSegments:!0,computeLineDistances:function(){var e=this.geometry;if(e.isBufferGeometry)if(null===e.index){for(var t=e.attributes.position,r=[],n=0,a=t.count;n<a;n+=2)Ka.fromBufferAttribute(t,n),Ja.fromBufferAttribute(t,n+1),r[n]=0===n?0:r[n-1],r[n+1]=r[n]+Ka.distanceTo(Ja);e.setAttribute("lineDistance",new $e(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry)for(var o=e.vertices,i=e.lineDistances,s=0,l=o.length;s<l;s+=2)Ka.copy(o[s]),Ja.copy(o[s+1]),i[s]=0===s?0:i[s-1],i[s+1]=i[s]+Ka.distanceTo(Ja);return this}}),eo.prototype=Object.assign(Object.create(Qa.prototype),{constructor:eo,isLineLoop:!0}),to.prototype=Object.create(Ge.prototype),to.prototype.constructor=to,to.prototype.isPointsMaterial=!0,to.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};var ro=new R,no=new me,ao=new le,oo=new g;function io(e,t){j.call(this),this.type="Points",this.geometry=void 0!==e?e:new ft,this.material=void 0!==t?t:new to,this.updateMorphTargets()}function so(e,t,r,n,a,o,i){var s=no.distanceSqToPoint(e);if(s<r){var l=new g;no.closestPointToPoint(e,l),l.applyMatrix4(n);var c=a.ray.origin.distanceTo(l);if(c<a.near||c>a.far)return;o.push({distance:c,distanceToRay:Math.sqrt(s),point:l,index:t,face:null,object:i})}}function lo(e,t,r,n,a,o,i,s,l){d.call(this,e,t,r,n,a,o,i,s,l),this.format=void 0!==i?i:1022,this.minFilter=void 0!==o?o:1006,this.magFilter=void 0!==a?a:1006,this.generateMipmaps=!1;var c=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback((function t(){c.needsUpdate=!0,e.requestVideoFrameCallback(t)}))}function co(e,t,r,n,a,o,i,s,l,c,f,u){d.call(this,null,o,i,s,l,c,n,a,f,u),this.image={width:t,height:r},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}function fo(e,t,r,n,a,o,i,s,l){d.call(this,e,t,r,n,a,o,i,s,l),this.needsUpdate=!0}function uo(e,t,r,n,a,o,i,s,l,c){if(1026!==(c=void 0!==c?c:1026)&&1027!==c)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===r&&1026===c&&(r=1012),void 0===r&&1027===c&&(r=1020),d.call(this,null,n,a,o,i,s,c,r,l),this.image={width:e,height:t},this.magFilter=void 0!==i?i:1003,this.minFilter=void 0!==s?s:1003,this.flipY=!1,this.generateMipmaps=!1}function po(e){ft.call(this),this.type="WireframeGeometry";var t=[],r=[0,0],n={},a=["a","b","c"];if(e&&e.isGeometry){for(var o=e.faces,i=0,s=o.length;i<s;i++)for(var l=o[i],c=0;c<3;c++){var f=l[a[c]],d=l[a[(c+1)%3]];r[0]=Math.min(f,d),r[1]=Math.max(f,d);var u=r[0]+","+r[1];void 0===n[u]&&(n[u]={index1:r[0],index2:r[1]})}for(var p in n){var h=n[p],v=e.vertices[h.index1];t.push(v.x,v.y,v.z),v=e.vertices[h.index2],t.push(v.x,v.y,v.z)}}else if(e&&e.isBufferGeometry){var m=new g;if(null!==e.index){var x=e.attributes.position,y=e.index,E=e.groups;0===E.length&&(E=[{start:0,count:y.count,materialIndex:0}]);for(var w=0,b=E.length;w<b;++w)for(var T=E[w],_=T.start,S=_,R=_+T.count;S<R;S+=3)for(var A=0;A<3;A++){var M=y.getX(S+A),C=y.getX(S+(A+1)%3);r[0]=Math.min(M,C),r[1]=Math.max(M,C);var L=r[0]+","+r[1];void 0===n[L]&&(n[L]={index1:r[0],index2:r[1]})}for(var H in n){var P=n[H];m.fromBufferAttribute(x,P.index1),t.push(m.x,m.y,m.z),m.fromBufferAttribute(x,P.index2),t.push(m.x,m.y,m.z)}}else for(var z=e.attributes.position,k=0,N=z.count/3;k<N;k++)for(var D=0;D<3;D++){var F=3*k+D;m.fromBufferAttribute(z,F),t.push(m.x,m.y,m.z);var I=3*k+(D+1)%3;m.fromBufferAttribute(z,I),t.push(m.x,m.y,m.z)}}this.setAttribute("position",new $e(t,3))}function ho(e,t,r){Nt.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:r},this.fromBufferGeometry(new vo(e,t,r)),this.mergeVertices()}function vo(e,t,r){ft.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:r};var n=[],a=[],o=[],i=[],s=1e-5,l=new g,c=new g,f=new g,d=new g,u=new g;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");for(var p=t+1,h=0;h<=r;h++)for(var v=h/r,m=0;m<=t;m++){var x=m/t;e(x,v,c),a.push(c.x,c.y,c.z),x-s>=0?(e(x-s,v,f),d.subVectors(c,f)):(e(x+s,v,f),d.subVectors(f,c)),v-s>=0?(e(x,v-s,f),u.subVectors(c,f)):(e(x,v+s,f),u.subVectors(f,c)),l.crossVectors(d,u).normalize(),o.push(l.x,l.y,l.z),i.push(x,v)}for(var y=0;y<r;y++)for(var E=0;E<t;E++){var w=y*p+E,b=y*p+E+1,T=(y+1)*p+E+1,_=(y+1)*p+E;n.push(w,b,_),n.push(b,T,_)}this.setIndex(n),this.setAttribute("position",new $e(a,3)),this.setAttribute("normal",new $e(o,3)),this.setAttribute("uv",new $e(i,2))}function mo(e,t,r,n){Nt.call(this),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:n},this.fromBufferGeometry(new xo(e,t,r,n)),this.mergeVertices()}function xo(e,t,r,n){ft.call(this),this.type="PolyhedronBufferGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:n},r=r||1;var a=[],o=[];function i(e,t,r,n){for(var a=Math.pow(2,n),o=[],i=0;i<=a;i++){o[i]=[];for(var s=e.clone().lerp(r,i/a),c=t.clone().lerp(r,i/a),f=a-i,d=0;d<=f;d++)o[i][d]=0===d&&i===a?s:s.clone().lerp(c,d/f)}for(var u=0;u<a;u++)for(var p=0;p<2*(a-u)-1;p++){var h=Math.floor(p/2);p%2==0?(l(o[u][h+1]),l(o[u+1][h]),l(o[u][h])):(l(o[u][h+1]),l(o[u+1][h+1]),l(o[u+1][h]))}}function l(e){a.push(e.x,e.y,e.z)}function c(t,r){var n=3*t;r.x=e[n+0],r.y=e[n+1],r.z=e[n+2]}function f(e,t,r,n){n<0&&1===e.x&&(o[t]=e.x-1),0===r.x&&0===r.z&&(o[t]=n/2/Math.PI+.5)}function d(e){return Math.atan2(e.z,-e.x)}function u(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}!function(e){for(var r=new g,n=new g,a=new g,o=0;o<t.length;o+=3)c(t[o+0],r),c(t[o+1],n),c(t[o+2],a),i(r,n,a,e)}(n=n||0),function(e){for(var t=new g,r=0;r<a.length;r+=3)t.x=a[r+0],t.y=a[r+1],t.z=a[r+2],t.normalize().multiplyScalar(e),a[r+0]=t.x,a[r+1]=t.y,a[r+2]=t.z}(r),function(){for(var e=new g,t=0;t<a.length;t+=3){e.x=a[t+0],e.y=a[t+1],e.z=a[t+2];var r=d(e)/2/Math.PI+.5,n=u(e)/Math.PI+.5;o.push(r,1-n)}(function(){for(var e=new g,t=new g,r=new g,n=new g,i=new s,l=new s,c=new s,u=0,p=0;u<a.length;u+=9,p+=6){e.set(a[u+0],a[u+1],a[u+2]),t.set(a[u+3],a[u+4],a[u+5]),r.set(a[u+6],a[u+7],a[u+8]),i.set(o[p+0],o[p+1]),l.set(o[p+2],o[p+3]),c.set(o[p+4],o[p+5]),n.copy(e).add(t).add(r).divideScalar(3);var h=d(n);f(i,p+0,e,h),f(l,p+2,t,h),f(c,p+4,r,h)}})(),function(){for(var e=0;e<o.length;e+=6){var t=o[e+0],r=o[e+2],n=o[e+4],a=Math.max(t,r,n),i=Math.min(t,r,n);a>.9&&i<.1&&(t<.2&&(o[e+0]+=1),r<.2&&(o[e+2]+=1),n<.2&&(o[e+4]+=1))}}()}(),this.setAttribute("position",new $e(a,3)),this.setAttribute("normal",new $e(a.slice(),3)),this.setAttribute("uv",new $e(o,2)),0===n?this.computeVertexNormals():this.normalizeNormals()}function go(e,t){Nt.call(this),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new yo(e,t)),this.mergeVertices()}function yo(e,t){xo.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronBufferGeometry",this.parameters={radius:e,detail:t}}function Eo(e,t){Nt.call(this),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new wo(e,t)),this.mergeVertices()}function wo(e,t){xo.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronBufferGeometry",this.parameters={radius:e,detail:t}}function bo(e,t){Nt.call(this),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new To(e,t)),this.mergeVertices()}function To(e,t){var r=(1+Math.sqrt(5))/2,n=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1];xo.call(this,n,[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronBufferGeometry",this.parameters={radius:e,detail:t}}function _o(e,t){Nt.call(this),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t},this.fromBufferGeometry(new So(e,t)),this.mergeVertices()}function So(e,t){var r=(1+Math.sqrt(5))/2,n=1/r,a=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-n,-r,0,-n,r,0,n,-r,0,n,r,-n,-r,0,-n,r,0,n,-r,0,n,r,0,-r,0,-n,r,0,-n,-r,0,n,r,0,n];xo.call(this,a,[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronBufferGeometry",this.parameters={radius:e,detail:t}}function Ro(e,t,r,n,a,o){Nt.call(this),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:n,closed:a},void 0!==o&&console.warn("THREE.TubeGeometry: taper has been removed.");var i=new Ao(e,t,r,n,a);this.tangents=i.tangents,this.normals=i.normals,this.binormals=i.binormals,this.fromBufferGeometry(i),this.mergeVertices()}function Ao(e,t,r,n,a){ft.call(this),this.type="TubeBufferGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:n,closed:a},t=t||64,r=r||1,n=n||8,a=a||!1;var o=e.computeFrenetFrames(t,a);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;var i=new g,l=new g,c=new s,f=new g,d=[],u=[],p=[],h=[];function v(a){f=e.getPointAt(a/t,f);for(var s=o.normals[a],c=o.binormals[a],p=0;p<=n;p++){var h=p/n*Math.PI*2,v=Math.sin(h),m=-Math.cos(h);l.x=m*s.x+v*c.x,l.y=m*s.y+v*c.y,l.z=m*s.z+v*c.z,l.normalize(),u.push(l.x,l.y,l.z),i.x=f.x+r*l.x,i.y=f.y+r*l.y,i.z=f.z+r*l.z,d.push(i.x,i.y,i.z)}}!function(){for(var e=0;e<t;e++)v(e);v(!1===a?t:0),function(){for(var e=0;e<=t;e++)for(var r=0;r<=n;r++)c.x=e/t,c.y=r/n,p.push(c.x,c.y)}(),function(){for(var e=1;e<=t;e++)for(var r=1;r<=n;r++){var a=(n+1)*(e-1)+(r-1),o=(n+1)*e+(r-1),i=(n+1)*e+r,s=(n+1)*(e-1)+r;h.push(a,o,s),h.push(o,i,s)}}()}(),this.setIndex(h),this.setAttribute("position",new $e(d,3)),this.setAttribute("normal",new $e(u,3)),this.setAttribute("uv",new $e(p,2))}function Mo(e,t,r,n,a,o,i){Nt.call(this),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:n,p:a,q:o},void 0!==i&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),this.fromBufferGeometry(new Co(e,t,r,n,a,o)),this.mergeVertices()}function Co(e,t,r,n,a,o){ft.call(this),this.type="TorusKnotBufferGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:n,p:a,q:o},e=e||1,t=t||.4,r=Math.floor(r)||64,n=Math.floor(n)||8,a=a||2,o=o||3;for(var i=[],s=[],l=[],c=[],f=new g,d=new g,u=new g,p=new g,h=new g,v=new g,m=new g,x=0;x<=r;++x){var y=x/r*a*Math.PI*2;L(y,a,o,e,u),L(y+.01,a,o,e,p),v.subVectors(p,u),m.addVectors(p,u),h.crossVectors(v,m),m.crossVectors(h,v),h.normalize(),m.normalize();for(var E=0;E<=n;++E){var w=E/n*Math.PI*2,b=-t*Math.cos(w),T=t*Math.sin(w);f.x=u.x+(b*m.x+T*h.x),f.y=u.y+(b*m.y+T*h.y),f.z=u.z+(b*m.z+T*h.z),s.push(f.x,f.y,f.z),d.subVectors(f,u).normalize(),l.push(d.x,d.y,d.z),c.push(x/r),c.push(E/n)}}for(var _=1;_<=r;_++)for(var S=1;S<=n;S++){var R=(n+1)*(_-1)+(S-1),A=(n+1)*_+(S-1),M=(n+1)*_+S,C=(n+1)*(_-1)+S;i.push(R,A,C),i.push(A,M,C)}function L(e,t,r,n,a){var o=Math.cos(e),i=Math.sin(e),s=r/t*e,l=Math.cos(s);a.x=n*(2+l)*.5*o,a.y=n*(2+l)*i*.5,a.z=n*Math.sin(s)*.5}this.setIndex(i),this.setAttribute("position",new $e(s,3)),this.setAttribute("normal",new $e(l,3)),this.setAttribute("uv",new $e(c,2))}function Lo(e,t,r,n,a){Nt.call(this),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:n,arc:a},this.fromBufferGeometry(new Ho(e,t,r,n,a)),this.mergeVertices()}function Ho(e,t,r,n,a){ft.call(this),this.type="TorusBufferGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:n,arc:a},e=e||1,t=t||.4,r=Math.floor(r)||8,n=Math.floor(n)||6,a=a||2*Math.PI;for(var o=[],i=[],s=[],l=[],c=new g,f=new g,d=new g,u=0;u<=r;u++)for(var p=0;p<=n;p++){var h=p/n*a,v=u/r*Math.PI*2;f.x=(e+t*Math.cos(v))*Math.cos(h),f.y=(e+t*Math.cos(v))*Math.sin(h),f.z=t*Math.sin(v),i.push(f.x,f.y,f.z),c.x=e*Math.cos(h),c.y=e*Math.sin(h),d.subVectors(f,c).normalize(),s.push(d.x,d.y,d.z),l.push(p/n),l.push(u/r)}for(var m=1;m<=r;m++)for(var x=1;x<=n;x++){var y=(n+1)*m+x-1,E=(n+1)*(m-1)+x-1,w=(n+1)*(m-1)+x,b=(n+1)*m+x;o.push(y,E,b),o.push(E,w,b)}this.setIndex(o),this.setAttribute("position",new $e(i,3)),this.setAttribute("normal",new $e(s,3)),this.setAttribute("uv",new $e(l,2))}io.prototype=Object.assign(Object.create(j.prototype),{constructor:io,isPoints:!0,copy:function(e){return j.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){var r=this.geometry,n=this.matrixWorld,a=e.params.Points.threshold;if(null===r.boundingSphere&&r.computeBoundingSphere(),ao.copy(r.boundingSphere),ao.applyMatrix4(n),ao.radius+=a,!1!==e.ray.intersectsSphere(ao)){ro.getInverse(n),no.copy(e.ray).applyMatrix4(ro);var o=a/((this.scale.x+this.scale.y+this.scale.z)/3),i=o*o;if(r.isBufferGeometry){var s=r.index,l=r.attributes.position.array;if(null!==s)for(var c=s.array,f=0,d=c.length;f<d;f++){var u=c[f];oo.fromArray(l,3*u),so(oo,u,i,n,e,t,this)}else for(var p=0,h=l.length/3;p<h;p++)oo.fromArray(l,3*p),so(oo,p,i,n,e,t,this)}else for(var v=r.vertices,m=0,x=v.length;m<x;m++)so(v[m],m,i,n,e,t,this)}},updateMorphTargets:function(){var e=this.geometry;if(e.isBufferGeometry){var t=e.morphAttributes,r=Object.keys(t);if(r.length>0){var n=t[r[0]];if(void 0!==n){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var a=0,o=n.length;a<o;a++){var i=n[a].name||String(a);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=a}}}}else{var s=e.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),lo.prototype=Object.assign(Object.create(d.prototype),{constructor:lo,isVideoTexture:!0,update:function(){var e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}),co.prototype=Object.create(d.prototype),co.prototype.constructor=co,co.prototype.isCompressedTexture=!0,fo.prototype=Object.create(d.prototype),fo.prototype.constructor=fo,fo.prototype.isCanvasTexture=!0,uo.prototype=Object.create(d.prototype),uo.prototype.constructor=uo,uo.prototype.isDepthTexture=!0,po.prototype=Object.create(ft.prototype),po.prototype.constructor=po,ho.prototype=Object.create(Nt.prototype),ho.prototype.constructor=ho,vo.prototype=Object.create(ft.prototype),vo.prototype.constructor=vo,mo.prototype=Object.create(Nt.prototype),mo.prototype.constructor=mo,xo.prototype=Object.create(ft.prototype),xo.prototype.constructor=xo,go.prototype=Object.create(Nt.prototype),go.prototype.constructor=go,yo.prototype=Object.create(xo.prototype),yo.prototype.constructor=yo,Eo.prototype=Object.create(Nt.prototype),Eo.prototype.constructor=Eo,wo.prototype=Object.create(xo.prototype),wo.prototype.constructor=wo,bo.prototype=Object.create(Nt.prototype),bo.prototype.constructor=bo,To.prototype=Object.create(xo.prototype),To.prototype.constructor=To,_o.prototype=Object.create(Nt.prototype),_o.prototype.constructor=_o,So.prototype=Object.create(xo.prototype),So.prototype.constructor=So,Ro.prototype=Object.create(Nt.prototype),Ro.prototype.constructor=Ro,Ao.prototype=Object.create(ft.prototype),Ao.prototype.constructor=Ao,Ao.prototype.toJSON=function(){var e=ft.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e},Mo.prototype=Object.create(Nt.prototype),Mo.prototype.constructor=Mo,Co.prototype=Object.create(ft.prototype),Co.prototype.constructor=Co,Lo.prototype=Object.create(Nt.prototype),Lo.prototype.constructor=Lo,Ho.prototype=Object.create(ft.prototype),Ho.prototype.constructor=Ho;var Po=function(e,t,r){r=r||2;var n,a,o,i,s,l,c,f=t&&t.length,d=f?t[0]*r:e.length,u=zo(e,0,d,r,!0),p=[];if(!u||u.next===u.prev)return p;if(f&&(u=function(e,t,r,n){var a,o,i,s,l,c=[];for(a=0,o=t.length;a<o;a++)i=t[a]*n,s=a<o-1?t[a+1]*n:e.length,(l=zo(e,i,s,n,!1))===l.next&&(l.steiner=!0),c.push(jo(l));for(c.sort(Uo),a=0;a<c.length;a++)Go(c[a],r),r=ko(r,r.next);return r}(e,t,u,r)),e.length>80*r){n=o=e[0],a=i=e[1];for(var h=r;h<d;h+=r)(s=e[h])<n&&(n=s),(l=e[h+1])<a&&(a=l),s>o&&(o=s),l>i&&(i=l);c=0!==(c=Math.max(o-n,i-a))?1/c:0}return No(u,p,r,n,a,c),p};function zo(e,t,r,n,a){var o,i;if(a===function(e,t,r,n){for(var a=0,o=t,i=r-n;o<r;o+=n)a+=(e[i]-e[o])*(e[o+1]+e[i+1]),i=o;return a}(e,t,r,n)>0)for(o=t;o<r;o+=n)i=ei(o,e[o],e[o+1],i);else for(o=r-n;o>=t;o-=n)i=ei(o,e[o],e[o+1],i);return i&&Yo(i,i.next)&&(ti(i),i=i.next),i}function ko(e,t){if(!e)return e;t||(t=e);var r,n=e;do{if(r=!1,n.steiner||!Yo(n,n.next)&&0!==Xo(n.prev,n,n.next))n=n.next;else{if(ti(n),(n=t=n.prev)===n.next)break;r=!0}}while(r||n!==t);return t}function No(e,t,r,n,a,o,i){if(e){!i&&o&&function(e,t,r,n){var a=e;do{null===a.z&&(a.z=Vo(a.x,a.y,t,r,n)),a.prevZ=a.prev,a.nextZ=a.next,a=a.next}while(a!==e);a.prevZ.nextZ=null,a.prevZ=null,function(e){var t,r,n,a,o,i,s,l,c=1;do{for(r=e,e=null,o=null,i=0;r;){for(i++,n=r,s=0,t=0;t<c&&(s++,n=n.nextZ);t++);for(l=c;s>0||l>0&&n;)0!==s&&(0===l||!n||r.z<=n.z)?(a=r,r=r.nextZ,s--):(a=n,n=n.nextZ,l--),o?o.nextZ=a:e=a,a.prevZ=o,o=a;r=n}o.nextZ=null,c*=2}while(i>1)}(a)}(e,n,a,o);for(var s,l,c=e;e.prev!==e.next;)if(s=e.prev,l=e.next,o?Fo(e,n,a,o):Do(e))t.push(s.i/r),t.push(e.i/r),t.push(l.i/r),ti(e),e=l.next,c=l.next;else if((e=l)===c){i?1===i?No(e=Io(ko(e),t,r),t,r,n,a,o,2):2===i&&Oo(e,t,r,n,a,o):No(ko(e),t,r,n,a,o,1);break}}}function Do(e){var t=e.prev,r=e,n=e.next;if(Xo(t,r,n)>=0)return!1;for(var a=e.next.next;a!==e.prev;){if(Wo(t.x,t.y,r.x,r.y,n.x,n.y,a.x,a.y)&&Xo(a.prev,a,a.next)>=0)return!1;a=a.next}return!0}function Fo(e,t,r,n){var a=e.prev,o=e,i=e.next;if(Xo(a,o,i)>=0)return!1;for(var s=a.x<o.x?a.x<i.x?a.x:i.x:o.x<i.x?o.x:i.x,l=a.y<o.y?a.y<i.y?a.y:i.y:o.y<i.y?o.y:i.y,c=a.x>o.x?a.x>i.x?a.x:i.x:o.x>i.x?o.x:i.x,f=a.y>o.y?a.y>i.y?a.y:i.y:o.y>i.y?o.y:i.y,d=Vo(s,l,t,r,n),u=Vo(c,f,t,r,n),p=e.prevZ,h=e.nextZ;p&&p.z>=d&&h&&h.z<=u;){if(p!==e.prev&&p!==e.next&&Wo(a.x,a.y,o.x,o.y,i.x,i.y,p.x,p.y)&&Xo(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,h!==e.prev&&h!==e.next&&Wo(a.x,a.y,o.x,o.y,i.x,i.y,h.x,h.y)&&Xo(h.prev,h,h.next)>=0)return!1;h=h.nextZ}for(;p&&p.z>=d;){if(p!==e.prev&&p!==e.next&&Wo(a.x,a.y,o.x,o.y,i.x,i.y,p.x,p.y)&&Xo(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;h&&h.z<=u;){if(h!==e.prev&&h!==e.next&&Wo(a.x,a.y,o.x,o.y,i.x,i.y,h.x,h.y)&&Xo(h.prev,h,h.next)>=0)return!1;h=h.nextZ}return!0}function Io(e,t,r){var n=e;do{var a=n.prev,o=n.next.next;!Yo(a,o)&&Zo(a,n,n.next,o)&&Jo(a,o)&&Jo(o,a)&&(t.push(a.i/r),t.push(n.i/r),t.push(o.i/r),ti(n),ti(n.next),n=e=o),n=n.next}while(n!==e);return ko(n)}function Oo(e,t,r,n,a,o){var i=e;do{for(var s=i.next.next;s!==i.prev;){if(i.i!==s.i&&qo(i,s)){var l=$o(i,s);return i=ko(i,i.next),l=ko(l,l.next),No(i,t,r,n,a,o),void No(l,t,r,n,a,o)}s=s.next}i=i.next}while(i!==e)}function Uo(e,t){return e.x-t.x}function Go(e,t){if(t=function(e,t){var r,n=t,a=e.x,o=e.y,i=-1/0;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){var s=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(s<=a&&s>i){if(i=s,s===a){if(o===n.y)return n;if(o===n.next.y)return n.next}r=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!r)return null;if(a===i)return r;var l,c=r,f=r.x,d=r.y,u=1/0;n=r;do{a>=n.x&&n.x>=f&&a!==n.x&&Wo(o<d?a:i,o,f,d,o<d?i:a,o,n.x,n.y)&&(l=Math.abs(o-n.y)/(a-n.x),Jo(n,e)&&(l<u||l===u&&(n.x>r.x||n.x===r.x&&Bo(r,n)))&&(r=n,u=l)),n=n.next}while(n!==c);return r}(e,t)){var r=$o(t,e);ko(t,t.next),ko(r,r.next)}}function Bo(e,t){return Xo(e.prev,e,t.prev)<0&&Xo(t.next,e,e.next)<0}function Vo(e,t,r,n,a){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*a)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-n)*a)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function jo(e){var t=e,r=e;do{(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next}while(t!==e);return r}function Wo(e,t,r,n,a,o,i,s){return(a-i)*(t-s)-(e-i)*(o-s)>=0&&(e-i)*(n-s)-(r-i)*(t-s)>=0&&(r-i)*(o-s)-(a-i)*(n-s)>=0}function qo(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&Zo(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1}(e,t)&&(Jo(e,t)&&Jo(t,e)&&function(e,t){var r=e,n=!1,a=(e.x+t.x)/2,o=(e.y+t.y)/2;do{r.y>o!=r.next.y>o&&r.next.y!==r.y&&a<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next}while(r!==e);return n}(e,t)&&(Xo(e.prev,e,t.prev)||Xo(e,t.prev,t))||Yo(e,t)&&Xo(e.prev,e,e.next)>0&&Xo(t.prev,t,t.next)>0)}function Xo(e,t,r){return(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y)}function Yo(e,t){return e.x===t.x&&e.y===t.y}function Zo(e,t,r,n){var a=Ko(Xo(e,t,r)),o=Ko(Xo(e,t,n)),i=Ko(Xo(r,n,e)),s=Ko(Xo(r,n,t));return a!==o&&i!==s||!(0!==a||!Qo(e,r,t))||!(0!==o||!Qo(e,n,t))||!(0!==i||!Qo(r,e,n))||!(0!==s||!Qo(r,t,n))}function Qo(e,t,r){return t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y)}function Ko(e){return e>0?1:e<0?-1:0}function Jo(e,t){return Xo(e.prev,e,e.next)<0?Xo(e,t,e.next)>=0&&Xo(e,e.prev,t)>=0:Xo(e,t,e.prev)<0||Xo(e,e.next,t)<0}function $o(e,t){var r=new ri(e.i,e.x,e.y),n=new ri(t.i,t.x,t.y),a=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=a,a.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n}function ei(e,t,r,n){var a=new ri(e,t,r);return n?(a.next=n.next,a.prev=n,n.next.prev=a,n.next=a):(a.prev=a,a.next=a),a}function ti(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function ri(e,t,r){this.i=e,this.x=t,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}var ni={area:function(e){for(var t=e.length,r=0,n=t-1,a=0;a<t;n=a++)r+=e[n].x*e[a].y-e[a].x*e[n].y;return.5*r},isClockWise:function(e){return ni.area(e)<0},triangulateShape:function(e,t){var r=[],n=[],a=[];ai(e),oi(r,e);var o=e.length;t.forEach(ai);for(var i=0;i<t.length;i++)n.push(o),o+=t[i].length,oi(r,t[i]);for(var s=Po(r,n),l=0;l<s.length;l+=3)a.push(s.slice(l,l+3));return a}};function ai(e){var t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function oi(e,t){for(var r=0;r<t.length;r++)e.push(t[r].x),e.push(t[r].y)}function ii(e,t){Nt.call(this),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},this.fromBufferGeometry(new si(e,t)),this.mergeVertices()}function si(e,t){ft.call(this),this.type="ExtrudeBufferGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];for(var r=this,n=[],a=[],o=0,i=e.length;o<i;o++)l(e[o]);function l(e){var o=[],i=void 0!==t.curveSegments?t.curveSegments:12,l=void 0!==t.steps?t.steps:1,c=void 0!==t.depth?t.depth:100,f=void 0===t.bevelEnabled||t.bevelEnabled,d=void 0!==t.bevelThickness?t.bevelThickness:6,u=void 0!==t.bevelSize?t.bevelSize:d-2,p=void 0!==t.bevelOffset?t.bevelOffset:0,h=void 0!==t.bevelSegments?t.bevelSegments:3,v=t.extrudePath,m=void 0!==t.UVGenerator?t.UVGenerator:li;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),c=t.amount);var x,y,E,w,b,T=!1;v&&(x=v.getSpacedPoints(l),T=!0,f=!1,y=v.computeFrenetFrames(l,!1),E=new g,w=new g,b=new g),f||(h=0,d=0,u=0,p=0);var _=e.extractPoints(i),S=_.shape,R=_.holes;if(!ni.isClockWise(S)){S=S.reverse();for(var A=0,M=R.length;A<M;A++){var C=R[A];ni.isClockWise(C)&&(R[A]=C.reverse())}}for(var L=ni.triangulateShape(S,R),H=S,P=0,z=R.length;P<z;P++){var k=R[P];S=S.concat(k)}function N(e,t,r){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(r).add(e)}var D=S.length,F=L.length;function I(e,t,r){var n,a,o,i=e.x-t.x,l=e.y-t.y,c=r.x-e.x,f=r.y-e.y,d=i*i+l*l,u=i*f-l*c;if(Math.abs(u)>Number.EPSILON){var p=Math.sqrt(d),h=Math.sqrt(c*c+f*f),v=t.x-l/p,m=t.y+i/p,x=((r.x-f/h-v)*f-(r.y+c/h-m)*c)/(i*f-l*c),g=(n=v+i*x-e.x)*n+(a=m+l*x-e.y)*a;if(g<=2)return new s(n,a);o=Math.sqrt(g/2)}else{var y=!1;i>Number.EPSILON?c>Number.EPSILON&&(y=!0):i<-Number.EPSILON?c<-Number.EPSILON&&(y=!0):Math.sign(l)===Math.sign(f)&&(y=!0),y?(n=-l,a=i,o=Math.sqrt(d)):(n=i,a=l,o=Math.sqrt(d/2))}return new s(n/o,a/o)}for(var O=[],U=0,G=H.length,B=G-1,V=U+1;U<G;U++,B++,V++)B===G&&(B=0),V===G&&(V=0),O[U]=I(H[U],H[B],H[V]);for(var j,W=[],q=O.concat(),X=0,Y=R.length;X<Y;X++){var Z=R[X];j=[];for(var Q=0,K=Z.length,J=K-1,$=Q+1;Q<K;Q++,J++,$++)J===K&&(J=0),$===K&&($=0),j[Q]=I(Z[Q],Z[J],Z[$]);W.push(j),q=q.concat(j)}for(var ee=0;ee<h;ee++){for(var te=ee/h,re=d*Math.cos(te*Math.PI/2),ne=u*Math.sin(te*Math.PI/2)+p,ae=0,oe=H.length;ae<oe;ae++){var ie=N(H[ae],O[ae],ne);ze(ie.x,ie.y,-re)}for(var se=0,le=R.length;se<le;se++){var ce=R[se];j=W[se];for(var fe=0,de=ce.length;fe<de;fe++){var ue=N(ce[fe],j[fe],ne);ze(ue.x,ue.y,-re)}}}for(var pe=u+p,he=0;he<D;he++){var ve=f?N(S[he],q[he],pe):S[he];T?(w.copy(y.normals[0]).multiplyScalar(ve.x),E.copy(y.binormals[0]).multiplyScalar(ve.y),b.copy(x[0]).add(w).add(E),ze(b.x,b.y,b.z)):ze(ve.x,ve.y,0)}for(var me=1;me<=l;me++)for(var xe=0;xe<D;xe++){var ge=f?N(S[xe],q[xe],pe):S[xe];T?(w.copy(y.normals[me]).multiplyScalar(ge.x),E.copy(y.binormals[me]).multiplyScalar(ge.y),b.copy(x[me]).add(w).add(E),ze(b.x,b.y,b.z)):ze(ge.x,ge.y,c/l*me)}for(var ye=h-1;ye>=0;ye--){for(var Ee=ye/h,we=d*Math.cos(Ee*Math.PI/2),be=u*Math.sin(Ee*Math.PI/2)+p,Te=0,_e=H.length;Te<_e;Te++){var Se=N(H[Te],O[Te],be);ze(Se.x,Se.y,c+we)}for(var Re=0,Ae=R.length;Re<Ae;Re++){var Me=R[Re];j=W[Re];for(var Ce=0,Le=Me.length;Ce<Le;Ce++){var He=N(Me[Ce],j[Ce],be);T?ze(He.x,He.y+x[l-1].y,x[l-1].x+we):ze(He.x,He.y,c+we)}}}function Pe(e,t){for(var r=e.length;--r>=0;){var n=r,a=r-1;a<0&&(a=e.length-1);for(var o=0,i=l+2*h;o<i;o++){var s=D*o,c=D*(o+1);Ne(t+n+s,t+a+s,t+a+c,t+n+c)}}}function ze(e,t,r){o.push(e),o.push(t),o.push(r)}function ke(e,t,a){De(e),De(t),De(a);var o=n.length/3,i=m.generateTopUV(r,n,o-3,o-2,o-1);Fe(i[0]),Fe(i[1]),Fe(i[2])}function Ne(e,t,a,o){De(e),De(t),De(o),De(t),De(a),De(o);var i=n.length/3,s=m.generateSideWallUV(r,n,i-6,i-3,i-2,i-1);Fe(s[0]),Fe(s[1]),Fe(s[3]),Fe(s[1]),Fe(s[2]),Fe(s[3])}function De(e){n.push(o[3*e+0]),n.push(o[3*e+1]),n.push(o[3*e+2])}function Fe(e){a.push(e.x),a.push(e.y)}!function(){var e=n.length/3;if(f){for(var t=0,a=D*t,o=0;o<F;o++){var i=L[o];ke(i[2]+a,i[1]+a,i[0]+a)}a=D*(t=l+2*h);for(var s=0;s<F;s++){var c=L[s];ke(c[0]+a,c[1]+a,c[2]+a)}}else{for(var d=0;d<F;d++){var u=L[d];ke(u[2],u[1],u[0])}for(var p=0;p<F;p++){var v=L[p];ke(v[0]+D*l,v[1]+D*l,v[2]+D*l)}}r.addGroup(e,n.length/3-e,0)}(),function(){var e=n.length/3,t=0;Pe(H,t),t+=H.length;for(var a=0,o=R.length;a<o;a++){var i=R[a];Pe(i,t),t+=i.length}r.addGroup(e,n.length/3-e,1)}()}this.setAttribute("position",new $e(n,3)),this.setAttribute("uv",new $e(a,2)),this.computeVertexNormals()}ii.prototype=Object.create(Nt.prototype),ii.prototype.constructor=ii,ii.prototype.toJSON=function(){var e=Nt.prototype.toJSON.call(this);return ci(this.parameters.shapes,this.parameters.options,e)},si.prototype=Object.create(ft.prototype),si.prototype.constructor=si,si.prototype.toJSON=function(){var e=ft.prototype.toJSON.call(this);return ci(this.parameters.shapes,this.parameters.options,e)};var li={generateTopUV:function(e,t,r,n,a){var o=t[3*r],i=t[3*r+1],l=t[3*n],c=t[3*n+1],f=t[3*a],d=t[3*a+1];return[new s(o,i),new s(l,c),new s(f,d)]},generateSideWallUV:function(e,t,r,n,a,o){var i=t[3*r],l=t[3*r+1],c=t[3*r+2],f=t[3*n],d=t[3*n+1],u=t[3*n+2],p=t[3*a],h=t[3*a+1],v=t[3*a+2],m=t[3*o],x=t[3*o+1],g=t[3*o+2];return Math.abs(l-d)<.01?[new s(i,1-c),new s(f,1-u),new s(p,1-v),new s(m,1-g)]:[new s(l,1-c),new s(d,1-u),new s(h,1-v),new s(x,1-g)]}};function ci(e,t,r){if(r.shapes=[],Array.isArray(e))for(var n=0,a=e.length;n<a;n++){var o=e[n];r.shapes.push(o.uuid)}else r.shapes.push(e.uuid);return void 0!==t.extrudePath&&(r.options.extrudePath=t.extrudePath.toJSON()),r}function fi(e,t){Nt.call(this),this.type="TextGeometry",this.parameters={text:e,parameters:t},this.fromBufferGeometry(new di(e,t)),this.mergeVertices()}function di(e,t){var r=(t=t||{}).font;if(!r||!r.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Nt;var n=r.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),si.call(this,n,t),this.type="TextBufferGeometry"}function ui(e,t,r,n,a,o,i){Nt.call(this),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:n,phiLength:a,thetaStart:o,thetaLength:i},this.fromBufferGeometry(new pi(e,t,r,n,a,o,i)),this.mergeVertices()}function pi(e,t,r,n,a,o,i){ft.call(this),this.type="SphereBufferGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:n,phiLength:a,thetaStart:o,thetaLength:i},e=e||1,t=Math.max(3,Math.floor(t)||8),r=Math.max(2,Math.floor(r)||6),n=void 0!==n?n:0,a=void 0!==a?a:2*Math.PI,o=void 0!==o?o:0,i=void 0!==i?i:Math.PI;for(var s=Math.min(o+i,Math.PI),l=0,c=[],f=new g,d=new g,u=[],p=[],h=[],v=[],m=0;m<=r;m++){var x=[],y=m/r,E=0;0==m&&0==o?E=.5/t:m==r&&s==Math.PI&&(E=-.5/t);for(var w=0;w<=t;w++){var b=w/t;f.x=-e*Math.cos(n+b*a)*Math.sin(o+y*i),f.y=e*Math.cos(o+y*i),f.z=e*Math.sin(n+b*a)*Math.sin(o+y*i),p.push(f.x,f.y,f.z),d.copy(f).normalize(),h.push(d.x,d.y,d.z),v.push(b+E,1-y),x.push(l++)}c.push(x)}for(var T=0;T<r;T++)for(var _=0;_<t;_++){var S=c[T][_+1],R=c[T][_],A=c[T+1][_],M=c[T+1][_+1];(0!==T||o>0)&&u.push(S,R,M),(T!==r-1||s<Math.PI)&&u.push(R,A,M)}this.setIndex(u),this.setAttribute("position",new $e(p,3)),this.setAttribute("normal",new $e(h,3)),this.setAttribute("uv",new $e(v,2))}function hi(e,t,r,n,a,o){Nt.call(this),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:n,thetaStart:a,thetaLength:o},this.fromBufferGeometry(new vi(e,t,r,n,a,o)),this.mergeVertices()}function vi(e,t,r,n,a,o){ft.call(this),this.type="RingBufferGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:n,thetaStart:a,thetaLength:o},e=e||.5,t=t||1,a=void 0!==a?a:0,o=void 0!==o?o:2*Math.PI,r=void 0!==r?Math.max(3,r):8;for(var i=[],l=[],c=[],f=[],d=e,u=(t-e)/(n=void 0!==n?Math.max(1,n):1),p=new g,h=new s,v=0;v<=n;v++){for(var m=0;m<=r;m++){var x=a+m/r*o;p.x=d*Math.cos(x),p.y=d*Math.sin(x),l.push(p.x,p.y,p.z),c.push(0,0,1),h.x=(p.x/t+1)/2,h.y=(p.y/t+1)/2,f.push(h.x,h.y)}d+=u}for(var y=0;y<n;y++)for(var E=y*(r+1),w=0;w<r;w++){var b=w+E,T=b,_=b+r+1,S=b+r+2,R=b+1;i.push(T,_,R),i.push(_,S,R)}this.setIndex(i),this.setAttribute("position",new $e(l,3)),this.setAttribute("normal",new $e(c,3)),this.setAttribute("uv",new $e(f,2))}function mi(e,t,r,n){Nt.call(this),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:n},this.fromBufferGeometry(new xi(e,t,r,n)),this.mergeVertices()}function xi(e,t,r,n){ft.call(this),this.type="LatheBufferGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:n},t=Math.floor(t)||12,r=r||0,n=n||2*Math.PI,n=i.clamp(n,0,2*Math.PI);for(var a=[],o=[],l=[],c=1/t,f=new g,d=new s,u=0;u<=t;u++)for(var p=r+u*c*n,h=Math.sin(p),v=Math.cos(p),m=0;m<=e.length-1;m++)f.x=e[m].x*h,f.y=e[m].y,f.z=e[m].x*v,o.push(f.x,f.y,f.z),d.x=u/t,d.y=m/(e.length-1),l.push(d.x,d.y);for(var x=0;x<t;x++)for(var y=0;y<e.length-1;y++){var E=y+x*e.length,w=E,b=E+e.length,T=E+e.length+1,_=E+1;a.push(w,b,_),a.push(b,T,_)}if(this.setIndex(a),this.setAttribute("position",new $e(o,3)),this.setAttribute("uv",new $e(l,2)),this.computeVertexNormals(),n===2*Math.PI)for(var S=this.attributes.normal.array,R=new g,A=new g,M=new g,C=t*e.length*3,L=0,H=0;L<e.length;L++,H+=3)R.x=S[H+0],R.y=S[H+1],R.z=S[H+2],A.x=S[C+H+0],A.y=S[C+H+1],A.z=S[C+H+2],M.addVectors(R,A).normalize(),S[H+0]=S[C+H+0]=M.x,S[H+1]=S[C+H+1]=M.y,S[H+2]=S[C+H+2]=M.z}function gi(e,t){Nt.call(this),this.type="ShapeGeometry","object"==typeof t&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),t=t.curveSegments),this.parameters={shapes:e,curveSegments:t},this.fromBufferGeometry(new yi(e,t)),this.mergeVertices()}function yi(e,t){ft.call(this),this.type="ShapeBufferGeometry",this.parameters={shapes:e,curveSegments:t},t=t||12;var r=[],n=[],a=[],o=[],i=0,s=0;if(!1===Array.isArray(e))c(e);else for(var l=0;l<e.length;l++)c(e[l]),this.addGroup(i,s,l),i+=s,s=0;function c(e){var i=n.length/3,l=e.extractPoints(t),c=l.shape,f=l.holes;!1===ni.isClockWise(c)&&(c=c.reverse());for(var d=0,u=f.length;d<u;d++){var p=f[d];!0===ni.isClockWise(p)&&(f[d]=p.reverse())}for(var h=ni.triangulateShape(c,f),v=0,m=f.length;v<m;v++){var x=f[v];c=c.concat(x)}for(var g=0,y=c.length;g<y;g++){var E=c[g];n.push(E.x,E.y,0),a.push(0,0,1),o.push(E.x,E.y)}for(var w=0,b=h.length;w<b;w++){var T=h[w],_=T[0]+i,S=T[1]+i,R=T[2]+i;r.push(_,S,R),s+=3}}this.setIndex(r),this.setAttribute("position",new $e(n,3)),this.setAttribute("normal",new $e(a,3)),this.setAttribute("uv",new $e(o,2))}function Ei(e,t){if(t.shapes=[],Array.isArray(e))for(var r=0,n=e.length;r<n;r++){var a=e[r];t.shapes.push(a.uuid)}else t.shapes.push(e.uuid);return t}function wi(e,t){ft.call(this),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=void 0!==t?t:1;var r,n,a,o,s=[],l=Math.cos(i.DEG2RAD*t),c=[0,0],f={},d=["a","b","c"];e.isBufferGeometry?(o=new Nt).fromBufferGeometry(e):o=e.clone(),o.mergeVertices(),o.computeFaceNormals();for(var u=o.vertices,p=o.faces,h=0,v=p.length;h<v;h++)for(var m=p[h],x=0;x<3;x++)r=m[d[x]],n=m[d[(x+1)%3]],c[0]=Math.min(r,n),c[1]=Math.max(r,n),void 0===f[a=c[0]+","+c[1]]?f[a]={index1:c[0],index2:c[1],face1:h,face2:void 0}:f[a].face2=h;for(a in f){var g=f[a];if(void 0===g.face2||p[g.face1].normal.dot(p[g.face2].normal)<=l){var y=u[g.index1];s.push(y.x,y.y,y.z),y=u[g.index2],s.push(y.x,y.y,y.z)}}this.setAttribute("position",new $e(s,3))}function bi(e,t,r,n,a,o,i,s){Nt.call(this),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:n,heightSegments:a,openEnded:o,thetaStart:i,thetaLength:s},this.fromBufferGeometry(new Ti(e,t,r,n,a,o,i,s)),this.mergeVertices()}function Ti(e,t,r,n,a,o,i,l){ft.call(this),this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:n,heightSegments:a,openEnded:o,thetaStart:i,thetaLength:l};var c=this;e=void 0!==e?e:1,t=void 0!==t?t:1,r=r||1,n=Math.floor(n)||8,a=Math.floor(a)||1,o=void 0!==o&&o,i=void 0!==i?i:0,l=void 0!==l?l:2*Math.PI;var f=[],d=[],u=[],p=[],h=0,v=[],m=r/2,x=0;function y(r){var a,o,v=new s,y=new g,E=0,w=!0===r?e:t,b=!0===r?1:-1;a=h;for(var T=1;T<=n;T++)d.push(0,m*b,0),u.push(0,b,0),p.push(.5,.5),h++;o=h;for(var _=0;_<=n;_++){var S=_/n*l+i,R=Math.cos(S),A=Math.sin(S);y.x=w*A,y.y=m*b,y.z=w*R,d.push(y.x,y.y,y.z),u.push(0,b,0),v.x=.5*R+.5,v.y=.5*A*b+.5,p.push(v.x,v.y),h++}for(var M=0;M<n;M++){var C=a+M,L=o+M;!0===r?f.push(L,L+1,C):f.push(L+1,L,C),E+=3}c.addGroup(x,E,!0===r?1:2),x+=E}!function(){for(var o=new g,s=new g,y=0,E=(t-e)/r,w=0;w<=a;w++){for(var b=[],T=w/a,_=T*(t-e)+e,S=0;S<=n;S++){var R=S/n,A=R*l+i,M=Math.sin(A),C=Math.cos(A);s.x=_*M,s.y=-T*r+m,s.z=_*C,d.push(s.x,s.y,s.z),o.set(M,E,C).normalize(),u.push(o.x,o.y,o.z),p.push(R,1-T),b.push(h++)}v.push(b)}for(var L=0;L<n;L++)for(var H=0;H<a;H++){var P=v[H][L],z=v[H+1][L],k=v[H+1][L+1],N=v[H][L+1];f.push(P,z,N),f.push(z,k,N),y+=6}c.addGroup(x,y,0),x+=y}(),!1===o&&(e>0&&y(!0),t>0&&y(!1)),this.setIndex(f),this.setAttribute("position",new $e(d,3)),this.setAttribute("normal",new $e(u,3)),this.setAttribute("uv",new $e(p,2))}function _i(e,t,r,n,a,o,i){bi.call(this,0,e,t,r,n,a,o,i),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:n,openEnded:a,thetaStart:o,thetaLength:i}}function Si(e,t,r,n,a,o,i){Ti.call(this,0,e,t,r,n,a,o,i),this.type="ConeBufferGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:n,openEnded:a,thetaStart:o,thetaLength:i}}function Ri(e,t,r,n){Nt.call(this),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:n},this.fromBufferGeometry(new Ai(e,t,r,n)),this.mergeVertices()}function Ai(e,t,r,n){ft.call(this),this.type="CircleBufferGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:n},e=e||1,t=void 0!==t?Math.max(3,t):8,r=void 0!==r?r:0,n=void 0!==n?n:2*Math.PI;var a=[],o=[],i=[],l=[],c=new g,f=new s;o.push(0,0,0),i.push(0,0,1),l.push(.5,.5);for(var d=0,u=3;d<=t;d++,u+=3){var p=r+d/t*n;c.x=e*Math.cos(p),c.y=e*Math.sin(p),o.push(c.x,c.y,c.z),i.push(0,0,1),f.x=(o[u]/e+1)/2,f.y=(o[u+1]/e+1)/2,l.push(f.x,f.y)}for(var h=1;h<=t;h++)a.push(h,h+1,0);this.setIndex(a),this.setAttribute("position",new $e(o,3)),this.setAttribute("normal",new $e(i,3)),this.setAttribute("uv",new $e(l,2))}fi.prototype=Object.create(Nt.prototype),fi.prototype.constructor=fi,di.prototype=Object.create(si.prototype),di.prototype.constructor=di,ui.prototype=Object.create(Nt.prototype),ui.prototype.constructor=ui,pi.prototype=Object.create(ft.prototype),pi.prototype.constructor=pi,hi.prototype=Object.create(Nt.prototype),hi.prototype.constructor=hi,vi.prototype=Object.create(ft.prototype),vi.prototype.constructor=vi,mi.prototype=Object.create(Nt.prototype),mi.prototype.constructor=mi,xi.prototype=Object.create(ft.prototype),xi.prototype.constructor=xi,gi.prototype=Object.create(Nt.prototype),gi.prototype.constructor=gi,gi.prototype.toJSON=function(){var e=Nt.prototype.toJSON.call(this);return Ei(this.parameters.shapes,e)},yi.prototype=Object.create(ft.prototype),yi.prototype.constructor=yi,yi.prototype.toJSON=function(){var e=ft.prototype.toJSON.call(this);return Ei(this.parameters.shapes,e)},wi.prototype=Object.create(ft.prototype),wi.prototype.constructor=wi,bi.prototype=Object.create(Nt.prototype),bi.prototype.constructor=bi,Ti.prototype=Object.create(ft.prototype),Ti.prototype.constructor=Ti,_i.prototype=Object.create(bi.prototype),_i.prototype.constructor=_i,Si.prototype=Object.create(Ti.prototype),Si.prototype.constructor=Si,Ri.prototype=Object.create(Nt.prototype),Ri.prototype.constructor=Ri,Ai.prototype=Object.create(ft.prototype),Ai.prototype.constructor=Ai;var Mi=Object.freeze({__proto__:null,WireframeGeometry:po,ParametricGeometry:ho,ParametricBufferGeometry:vo,TetrahedronGeometry:go,TetrahedronBufferGeometry:yo,OctahedronGeometry:Eo,OctahedronBufferGeometry:wo,IcosahedronGeometry:bo,IcosahedronBufferGeometry:To,DodecahedronGeometry:_o,DodecahedronBufferGeometry:So,PolyhedronGeometry:mo,PolyhedronBufferGeometry:xo,TubeGeometry:Ro,TubeBufferGeometry:Ao,TorusKnotGeometry:Mo,TorusKnotBufferGeometry:Co,TorusGeometry:Lo,TorusBufferGeometry:Ho,TextGeometry:fi,TextBufferGeometry:di,SphereGeometry:ui,SphereBufferGeometry:pi,RingGeometry:hi,RingBufferGeometry:vi,PlaneGeometry:$t,PlaneBufferGeometry:er,LatheGeometry:mi,LatheBufferGeometry:xi,ShapeGeometry:gi,ShapeBufferGeometry:yi,ExtrudeGeometry:ii,ExtrudeBufferGeometry:si,EdgesGeometry:wi,ConeGeometry:_i,ConeBufferGeometry:Si,CylinderGeometry:bi,CylinderBufferGeometry:Ti,CircleGeometry:Ri,CircleBufferGeometry:Ai,BoxGeometry:Dt,BoxBufferGeometry:Ft});function Ci(e){Ge.call(this),this.type="ShadowMaterial",this.color=new Ne(0),this.transparent=!0,this.setValues(e)}function Li(e){Gt.call(this,e),this.type="RawShaderMaterial"}function Hi(e){Ge.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Ne(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new s(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}function Pi(e){Hi.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new s(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}function zi(e){Ge.call(this),this.type="MeshPhongMaterial",this.color=new Ne(16777215),this.specular=new Ne(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new s(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function ki(e){Ge.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Ne(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new s(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ni(e){Ge.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new s(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Di(e){Ge.call(this),this.type="MeshLambertMaterial",this.color=new Ne(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ne(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Fi(e){Ge.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Ne(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new s(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}function Ii(e){ja.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}Ci.prototype=Object.create(Ge.prototype),Ci.prototype.constructor=Ci,Ci.prototype.isShadowMaterial=!0,Ci.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this},Li.prototype=Object.create(Gt.prototype),Li.prototype.constructor=Li,Li.prototype.isRawShaderMaterial=!0,Hi.prototype=Object.create(Ge.prototype),Hi.prototype.constructor=Hi,Hi.prototype.isMeshStandardMaterial=!0,Hi.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this},Pi.prototype=Object.create(Hi.prototype),Pi.prototype.constructor=Pi,Pi.prototype.isMeshPhysicalMaterial=!0,Pi.prototype.copy=function(e){return Hi.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new Ne).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this},zi.prototype=Object.create(Ge.prototype),zi.prototype.constructor=zi,zi.prototype.isMeshPhongMaterial=!0,zi.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},ki.prototype=Object.create(Ge.prototype),ki.prototype.constructor=ki,ki.prototype.isMeshToonMaterial=!0,ki.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ni.prototype=Object.create(Ge.prototype),Ni.prototype.constructor=Ni,Ni.prototype.isMeshNormalMaterial=!0,Ni.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Di.prototype=Object.create(Ge.prototype),Di.prototype.constructor=Di,Di.prototype.isMeshLambertMaterial=!0,Di.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Fi.prototype=Object.create(Ge.prototype),Fi.prototype.constructor=Fi,Fi.prototype.isMeshMatcapMaterial=!0,Fi.prototype.copy=function(e){return Ge.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this},Ii.prototype=Object.create(ja.prototype),Ii.prototype.constructor=Ii,Ii.prototype.isLineDashedMaterial=!0,Ii.prototype.copy=function(e){return ja.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var Oi=Object.freeze({__proto__:null,ShadowMaterial:Ci,SpriteMaterial:da,RawShaderMaterial:Li,ShaderMaterial:Gt,PointsMaterial:to,MeshPhysicalMaterial:Pi,MeshStandardMaterial:Hi,MeshPhongMaterial:zi,MeshToonMaterial:ki,MeshNormalMaterial:Ni,MeshLambertMaterial:Di,MeshDepthMaterial:qn,MeshDistanceMaterial:Xn,MeshBasicMaterial:Be,MeshMatcapMaterial:Fi,LineDashedMaterial:Ii,LineBasicMaterial:ja,Material:Ge}),Ui={arraySlice:function(e,t,r){return Ui.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==r?r:e.length)):e.slice(t,r)},convertArray:function(e,t,r){return!e||!r&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){for(var t=e.length,r=new Array(t),n=0;n!==t;++n)r[n]=n;return r.sort((function(t,r){return e[t]-e[r]})),r},sortedArray:function(e,t,r){for(var n=e.length,a=new e.constructor(n),o=0,i=0;i!==n;++o)for(var s=r[o]*t,l=0;l!==t;++l)a[i++]=e[s+l];return a},flattenJSON:function(e,t,r,n){for(var a=1,o=e[0];void 0!==o&&void 0===o[n];)o=e[a++];if(void 0!==o){var i=o[n];if(void 0!==i)if(Array.isArray(i))do{void 0!==(i=o[n])&&(t.push(o.time),r.push.apply(r,i)),o=e[a++]}while(void 0!==o);else if(void 0!==i.toArray)do{void 0!==(i=o[n])&&(t.push(o.time),i.toArray(r,r.length)),o=e[a++]}while(void 0!==o);else do{void 0!==(i=o[n])&&(t.push(o.time),r.push(i)),o=e[a++]}while(void 0!==o)}},subclip:function(e,t,r,n,a){a=a||30;var o=e.clone();o.name=t;for(var i=[],s=0;s<o.tracks.length;++s){for(var l=o.tracks[s],c=l.getValueSize(),f=[],d=[],u=0;u<l.times.length;++u){var p=l.times[u]*a;if(!(p<r||p>=n)){f.push(l.times[u]);for(var h=0;h<c;++h)d.push(l.values[u*c+h])}}0!==f.length&&(l.times=Ui.convertArray(f,l.times.constructor),l.values=Ui.convertArray(d,l.values.constructor),i.push(l))}o.tracks=i;for(var v=1/0,m=0;m<o.tracks.length;++m)v>o.tracks[m].times[0]&&(v=o.tracks[m].times[0]);for(var x=0;x<o.tracks.length;++x)o.tracks[x].shift(-1*v);return o.resetDuration(),o},makeClipAdditive:function(e,t,r,n){void 0===t&&(t=0),void 0===r&&(r=e),(void 0===n||n<=0)&&(n=30);for(var a=e.tracks.length,o=t/n,i=function(t){var n=r.tracks[t],a=n.ValueTypeName;if("bool"!==a&&"string"!==a){var i=e.tracks.find((function(e){return e.name===n.name&&e.ValueTypeName===a}));if(void 0!==i){var s=n.getValueSize(),l=n.times.length-1,c=void 0;if(o<=n.times[0])c=Ui.arraySlice(n.values,0,n.valueSize);else if(o>=n.times[l]){var f=l*s;c=Ui.arraySlice(n.values,f)}else{var d=n.createInterpolant();d.evaluate(o),c=d.resultBuffer}"quaternion"===a&&new v(c[0],c[1],c[2],c[3]).normalize().conjugate().toArray(c);for(var u=i.times.length,p=0;p<u;++p){var h=p*s;if("quaternion"===a)v.multiplyQuaternionsFlat(i.values,h,c,0,i.values,h);else for(var m=0;m<s;++m)i.values[h+m]-=c[m]}}}},s=0;s<a;++s)i(s);return e.blendMode=2501,e}};function Gi(e,t,r,n){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==n?n:new t.constructor(r),this.sampleValues=t,this.valueSize=r}function Bi(e,t,r,n){Gi.call(this,e,t,r,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}function Vi(e,t,r,n){Gi.call(this,e,t,r,n)}function ji(e,t,r,n){Gi.call(this,e,t,r,n)}function Wi(e,t,r,n){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Ui.convertArray(t,this.TimeBufferType),this.values=Ui.convertArray(r,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}function qi(e,t,r){Wi.call(this,e,t,r)}function Xi(e,t,r,n){Wi.call(this,e,t,r,n)}function Yi(e,t,r,n){Wi.call(this,e,t,r,n)}function Zi(e,t,r,n){Gi.call(this,e,t,r,n)}function Qi(e,t,r,n){Wi.call(this,e,t,r,n)}function Ki(e,t,r,n){Wi.call(this,e,t,r,n)}function Ji(e,t,r,n){Wi.call(this,e,t,r,n)}function $i(e,t,r,n){this.name=e,this.tracks=r,this.duration=void 0!==t?t:-1,this.blendMode=void 0!==n?n:2500,this.uuid=i.generateUUID(),this.duration<0&&this.resetDuration()}function es(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");var t=function(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Yi;case"vector":case"vector2":case"vector3":case"vector4":return Ji;case"color":return Xi;case"quaternion":return Qi;case"bool":case"boolean":return qi;case"string":return Ki}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){var r=[],n=[];Ui.flattenJSON(e.keys,r,n,"value"),e.times=r,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(Gi.prototype,{evaluate:function(e){var t=this.parameterPositions,r=this._cachedIndex,n=t[r],a=t[r-1];e:{t:{var o;r:{n:if(!(e<n)){for(var i=r+2;;){if(void 0===n){if(e<a)break n;return r=t.length,this._cachedIndex=r,this.afterEnd_(r-1,e,a)}if(r===i)break;if(a=n,e<(n=t[++r]))break t}o=t.length;break r}if(e>=a)break e;var s=t[1];e<s&&(r=2,a=s);for(var l=r-2;;){if(void 0===a)return this._cachedIndex=0,this.beforeStart_(0,e,n);if(r===l)break;if(n=a,e>=(a=t[--r-1]))break t}o=r,r=0}for(;r<o;){var c=r+o>>>1;e<t[c]?o=c:r=c+1}if(n=t[r],void 0===(a=t[r-1]))return this._cachedIndex=0,this.beforeStart_(0,e,n);if(void 0===n)return r=t.length,this._cachedIndex=r,this.afterEnd_(r-1,a,e)}this._cachedIndex=r,this.intervalChanged_(r,a,n)}return this.interpolate_(r,a,e,n)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){for(var t=this.resultBuffer,r=this.sampleValues,n=this.valueSize,a=e*n,o=0;o!==n;++o)t[o]=r[a+o];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}}),Object.assign(Gi.prototype,{beforeStart_:Gi.prototype.copySampleValue_,afterEnd_:Gi.prototype.copySampleValue_}),Bi.prototype=Object.assign(Object.create(Gi.prototype),{constructor:Bi,DefaultSettings_:{endingStart:2400,endingEnd:2400},intervalChanged_:function(e,t,r){var n=this.parameterPositions,a=e-2,o=e+1,i=n[a],s=n[o];if(void 0===i)switch(this.getSettings_().endingStart){case 2401:a=e,i=2*t-r;break;case 2402:i=t+n[a=n.length-2]-n[a+1];break;default:a=e,i=r}if(void 0===s)switch(this.getSettings_().endingEnd){case 2401:o=e,s=2*r-t;break;case 2402:o=1,s=r+n[1]-n[0];break;default:o=e-1,s=t}var l=.5*(r-t),c=this.valueSize;this._weightPrev=l/(t-i),this._weightNext=l/(s-r),this._offsetPrev=a*c,this._offsetNext=o*c},interpolate_:function(e,t,r,n){for(var a=this.resultBuffer,o=this.sampleValues,i=this.valueSize,s=e*i,l=s-i,c=this._offsetPrev,f=this._offsetNext,d=this._weightPrev,u=this._weightNext,p=(r-t)/(n-t),h=p*p,v=h*p,m=-d*v+2*d*h-d*p,x=(1+d)*v+(-1.5-2*d)*h+(-.5+d)*p+1,g=(-1-u)*v+(1.5+u)*h+.5*p,y=u*v-u*h,E=0;E!==i;++E)a[E]=m*o[c+E]+x*o[l+E]+g*o[s+E]+y*o[f+E];return a}}),Vi.prototype=Object.assign(Object.create(Gi.prototype),{constructor:Vi,interpolate_:function(e,t,r,n){for(var a=this.resultBuffer,o=this.sampleValues,i=this.valueSize,s=e*i,l=s-i,c=(r-t)/(n-t),f=1-c,d=0;d!==i;++d)a[d]=o[l+d]*f+o[s+d]*c;return a}}),ji.prototype=Object.assign(Object.create(Gi.prototype),{constructor:ji,interpolate_:function(e){return this.copySampleValue_(e-1)}}),Object.assign(Wi,{toJSON:function(e){var t,r=e.constructor;if(void 0!==r.toJSON)t=r.toJSON(e);else{t={name:e.name,times:Ui.convertArray(e.times,Array),values:Ui.convertArray(e.values,Array)};var n=e.getInterpolation();n!==e.DefaultInterpolation&&(t.interpolation=n)}return t.type=e.ValueTypeName,t}}),Object.assign(Wi.prototype,{constructor:Wi,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:2301,InterpolantFactoryMethodDiscrete:function(e){return new ji(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new Vi(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new Bi(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){var t;switch(e){case 2300:t=this.InterpolantFactoryMethodDiscrete;break;case 2301:t=this.InterpolantFactoryMethodLinear;break;case 2302:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){var r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(r);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(0!==e)for(var t=this.times,r=0,n=t.length;r!==n;++r)t[r]+=e;return this},scale:function(e){if(1!==e)for(var t=this.times,r=0,n=t.length;r!==n;++r)t[r]*=e;return this},trim:function(e,t){for(var r=this.times,n=r.length,a=0,o=n-1;a!==n&&r[a]<e;)++a;for(;-1!==o&&r[o]>t;)--o;if(++o,0!==a||o!==n){a>=o&&(a=(o=Math.max(o,1))-1);var i=this.getValueSize();this.times=Ui.arraySlice(r,a,o),this.values=Ui.arraySlice(this.values,a*i,o*i)}return this},validate:function(){var e=!0,t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);var r=this.times,n=this.values,a=r.length;0===a&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);for(var o=null,i=0;i!==a;i++){var s=r[i];if("number"==typeof s&&isNaN(s)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i,s),e=!1;break}if(null!==o&&o>s){console.error("THREE.KeyframeTrack: Out of order keys.",this,i,s,o),e=!1;break}o=s}if(void 0!==n&&Ui.isTypedArray(n))for(var l=0,c=n.length;l!==c;++l){var f=n[l];if(isNaN(f)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,l,f),e=!1;break}}return e},optimize:function(){for(var e=Ui.arraySlice(this.times),t=Ui.arraySlice(this.values),r=this.getValueSize(),n=2302===this.getInterpolation(),a=e.length-1,o=1,i=1;i<a;++i){var s=!1,l=e[i];if(l!==e[i+1]&&(1!==i||l!==l[0]))if(n)s=!0;else for(var c=i*r,f=c-r,d=c+r,u=0;u!==r;++u){var p=t[c+u];if(p!==t[f+u]||p!==t[d+u]){s=!0;break}}if(s){if(i!==o){e[o]=e[i];for(var h=i*r,v=o*r,m=0;m!==r;++m)t[v+m]=t[h+m]}++o}}if(a>0){e[o]=e[a];for(var x=a*r,g=o*r,y=0;y!==r;++y)t[g+y]=t[x+y];++o}return o!==e.length?(this.times=Ui.arraySlice(e,0,o),this.values=Ui.arraySlice(t,0,o*r)):(this.times=e,this.values=t),this},clone:function(){var e=Ui.arraySlice(this.times,0),t=Ui.arraySlice(this.values,0),r=new(0,this.constructor)(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}),qi.prototype=Object.assign(Object.create(Wi.prototype),{constructor:qi,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Xi.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Xi,ValueTypeName:"color"}),Yi.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Yi,ValueTypeName:"number"}),Zi.prototype=Object.assign(Object.create(Gi.prototype),{constructor:Zi,interpolate_:function(e,t,r,n){for(var a=this.resultBuffer,o=this.sampleValues,i=this.valueSize,s=(r-t)/(n-t),l=e*i,c=l+i;l!==c;l+=4)v.slerpFlat(a,0,o,l-i,o,l,s);return a}}),Qi.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Qi,ValueTypeName:"quaternion",DefaultInterpolation:2301,InterpolantFactoryMethodLinear:function(e){return new Zi(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0}),Ki.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Ki,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:2300,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Ji.prototype=Object.assign(Object.create(Wi.prototype),{constructor:Ji,ValueTypeName:"vector"}),Object.assign($i,{parse:function(e){for(var t=[],r=e.tracks,n=1/(e.fps||1),a=0,o=r.length;a!==o;++a)t.push(es(r[a]).scale(n));return new $i(e.name,e.duration,t,e.blendMode)},toJSON:function(e){for(var t=[],r=e.tracks,n={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode},a=0,o=r.length;a!==o;++a)t.push(Wi.toJSON(r[a]));return n},CreateFromMorphTargetSequence:function(e,t,r,n){for(var a=t.length,o=[],i=0;i<a;i++){var s=[],l=[];s.push((i+a-1)%a,i,(i+1)%a),l.push(0,1,0);var c=Ui.getKeyframeOrder(s);s=Ui.sortedArray(s,1,c),l=Ui.sortedArray(l,1,c),n||0!==s[0]||(s.push(a),l.push(l[0])),o.push(new Yi(".morphTargetInfluences["+t[i].name+"]",s,l).scale(1/r))}return new $i(e,-1,o)},findByName:function(e,t){var r=e;if(!Array.isArray(e)){var n=e;r=n.geometry&&n.geometry.animations||n.animations}for(var a=0;a<r.length;a++)if(r[a].name===t)return r[a];return null},CreateClipsFromMorphTargetSequences:function(e,t,r){for(var n={},a=/^([\w-]*?)([\d]+)$/,o=0,i=e.length;o<i;o++){var s=e[o],l=s.name.match(a);if(l&&l.length>1){var c=l[1],f=n[c];f||(n[c]=f=[]),f.push(s)}}var d=[];for(var u in n)d.push($i.CreateFromMorphTargetSequence(u,n[u],t,r));return d},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;for(var r=function(e,t,r,n,a){if(0!==r.length){var o=[],i=[];Ui.flattenJSON(r,o,i,n),0!==o.length&&a.push(new e(t,o,i))}},n=[],a=e.name||"default",o=e.fps||30,i=e.blendMode,s=e.length||-1,l=e.hierarchy||[],c=0;c<l.length;c++){var f=l[c].keys;if(f&&0!==f.length)if(f[0].morphTargets){var d={},u=void 0;for(u=0;u<f.length;u++)if(f[u].morphTargets)for(var p=0;p<f[u].morphTargets.length;p++)d[f[u].morphTargets[p]]=-1;for(var h in d){for(var v=[],m=[],x=0;x!==f[u].morphTargets.length;++x){var g=f[u];v.push(g.time),m.push(g.morphTarget===h?1:0)}n.push(new Yi(".morphTargetInfluence["+h+"]",v,m))}s=d.length*(o||1)}else{var y=".bones["+t[c].name+"]";r(Ji,y+".position",f,"pos",n),r(Qi,y+".quaternion",f,"rot",n),r(Ji,y+".scale",f,"scl",n)}}return 0===n.length?null:new $i(a,s,n,i)}}),Object.assign($i.prototype,{resetDuration:function(){for(var e=0,t=0,r=this.tracks.length;t!==r;++t){var n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this},trim:function(){for(var e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){for(var e=!0,t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(var e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){for(var e=[],t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new $i(this.name,this.duration,e,this.blendMode)}});var ts={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function rs(e,t,r){var n=this,a=!1,o=0,i=0,s=void 0,l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=r,this.itemStart=function(e){i++,!1===a&&void 0!==n.onStart&&n.onStart(e,o,i),a=!0},this.itemEnd=function(e){o++,void 0!==n.onProgress&&n.onProgress(e,o,i),o===i&&(a=!1,void 0!==n.onLoad&&n.onLoad())},this.itemError=function(e){void 0!==n.onError&&n.onError(e)},this.resolveURL=function(e){return s?s(e):e},this.setURLModifier=function(e){return s=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){var t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(var t=0,r=l.length;t<r;t+=2){var n=l[t],a=l[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return a}return null}}var ns=new rs;function as(e){this.manager=void 0!==e?e:ns,this.crossOrigin="anonymous",this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(as.prototype,{load:function(){},loadAsync:function(e,t){var r=this;return new Promise((function(n,a){r.load(e,n,t,a)}))},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});var os={};function is(e){as.call(this,e)}function ss(e){as.call(this,e)}function ls(e){as.call(this,e)}function cs(e){as.call(this,e)}function fs(e){as.call(this,e)}function ds(e){as.call(this,e)}function us(e){as.call(this,e)}function ps(){this.type="Curve",this.arcLengthDivisions=200}function hs(e,t,r,n,a,o,i,s){ps.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=r||1,this.yRadius=n||1,this.aStartAngle=a||0,this.aEndAngle=o||2*Math.PI,this.aClockwise=i||!1,this.aRotation=s||0}function vs(e,t,r,n,a,o){hs.call(this,e,t,r,r,n,a,o),this.type="ArcCurve"}function ms(){var e=0,t=0,r=0,n=0;function a(a,o,i,s){e=a,t=i,r=-3*a+3*o-2*i-s,n=2*a-2*o+i+s}return{initCatmullRom:function(e,t,r,n,o){a(t,r,o*(r-e),o*(n-t))},initNonuniformCatmullRom:function(e,t,r,n,o,i,s){var l=(t-e)/o-(r-e)/(o+i)+(r-t)/i,c=(r-t)/i-(n-t)/(i+s)+(n-r)/s;a(t,r,l*=i,c*=i)},calc:function(a){var o=a*a;return e+t*a+r*o+n*(o*a)}}}is.prototype=Object.assign(Object.create(as.prototype),{constructor:is,load:function(e,t,r,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);var a=this,o=ts.get(e);if(void 0!==o)return a.manager.itemStart(e),setTimeout((function(){t&&t(o),a.manager.itemEnd(e)}),0),o;if(void 0===os[e]){var i,s=e.match(/^data:(.*?)(;base64)?,(.*)$/);if(s){var l=s[1],c=!!s[2],f=s[3];f=decodeURIComponent(f),c&&(f=atob(f));try{var d,u=(this.responseType||"").toLowerCase();switch(u){case"arraybuffer":case"blob":for(var p=new Uint8Array(f.length),h=0;h<f.length;h++)p[h]=f.charCodeAt(h);d="blob"===u?new Blob([p.buffer],{type:l}):p.buffer;break;case"document":var v=new DOMParser;d=v.parseFromString(f,l);break;case"json":d=JSON.parse(f);break;default:d=f}setTimeout((function(){t&&t(d),a.manager.itemEnd(e)}),0)}catch(t){setTimeout((function(){n&&n(t),a.manager.itemError(e),a.manager.itemEnd(e)}),0)}}else{for(var m in os[e]=[],os[e].push({onLoad:t,onProgress:r,onError:n}),(i=new XMLHttpRequest).open("GET",e,!0),i.addEventListener("load",(function(t){var r=this.response,n=os[e];if(delete os[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),ts.add(e,r);for(var o=0,i=n.length;o<i;o++){var s=n[o];s.onLoad&&s.onLoad(r)}a.manager.itemEnd(e)}else{for(var l=0,c=n.length;l<c;l++){var f=n[l];f.onError&&f.onError(t)}a.manager.itemError(e),a.manager.itemEnd(e)}}),!1),i.addEventListener("progress",(function(t){for(var r=os[e],n=0,a=r.length;n<a;n++){var o=r[n];o.onProgress&&o.onProgress(t)}}),!1),i.addEventListener("error",(function(t){var r=os[e];delete os[e];for(var n=0,o=r.length;n<o;n++){var i=r[n];i.onError&&i.onError(t)}a.manager.itemError(e),a.manager.itemEnd(e)}),!1),i.addEventListener("abort",(function(t){var r=os[e];delete os[e];for(var n=0,o=r.length;n<o;n++){var i=r[n];i.onError&&i.onError(t)}a.manager.itemError(e),a.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(i.responseType=this.responseType),void 0!==this.withCredentials&&(i.withCredentials=this.withCredentials),i.overrideMimeType&&i.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain"),this.requestHeader)i.setRequestHeader(m,this.requestHeader[m]);i.send(null)}return a.manager.itemStart(e),i}os[e].push({onLoad:t,onProgress:r,onError:n})},setResponseType:function(e){return this.responseType=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setMimeType:function(e){return this.mimeType=e,this}}),ss.prototype=Object.assign(Object.create(as.prototype),{constructor:ss,load:function(e,t,r,n){var a=this,o=new is(a.manager);o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(JSON.parse(r)))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){for(var t=[],r=0;r<e.length;r++){var n=$i.parse(e[r]);t.push(n)}return t}}),ls.prototype=Object.assign(Object.create(as.prototype),{constructor:ls,load:function(e,t,r,n){var a=this,o=[],i=new co;i.image=o;var s=new is(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader);var l=0;function c(c){s.load(e[c],(function(e){var r=a.parse(e,!0);o[c]={width:r.width,height:r.height,format:r.format,mipmaps:r.mipmaps},6===(l+=1)&&(1===r.mipmapCount&&(i.minFilter=1006),i.format=r.format,i.needsUpdate=!0,t&&t(i))}),r,n)}if(Array.isArray(e))for(var f=0,d=e.length;f<d;++f)c(f);else s.load(e,(function(e){var r=a.parse(e,!0);if(r.isCubemap)for(var n=r.mipmaps.length/r.mipmapCount,s=0;s<n;s++){o[s]={mipmaps:[]};for(var l=0;l<r.mipmapCount;l++)o[s].mipmaps.push(r.mipmaps[s*r.mipmapCount+l]),o[s].format=r.format,o[s].width=r.width,o[s].height=r.height}else i.image.width=r.width,i.image.height=r.height,i.mipmaps=r.mipmaps;1===r.mipmapCount&&(i.minFilter=1006),i.format=r.format,i.needsUpdate=!0,t&&t(i)}),r,n);return i}}),cs.prototype=Object.assign(Object.create(as.prototype),{constructor:cs,load:function(e,t,r,n){var a=this,o=new qt,i=new is(this.manager);return i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.load(e,(function(e){var r=a.parse(e);r&&(void 0!==r.image?o.image=r.image:void 0!==r.data&&(o.image.width=r.width,o.image.height=r.height,o.image.data=r.data),o.wrapS=void 0!==r.wrapS?r.wrapS:1001,o.wrapT=void 0!==r.wrapT?r.wrapT:1001,o.magFilter=void 0!==r.magFilter?r.magFilter:1006,o.minFilter=void 0!==r.minFilter?r.minFilter:1006,o.anisotropy=void 0!==r.anisotropy?r.anisotropy:1,void 0!==r.format&&(o.format=r.format),void 0!==r.type&&(o.type=r.type),void 0!==r.mipmaps&&(o.mipmaps=r.mipmaps,o.minFilter=1008),1===r.mipmapCount&&(o.minFilter=1006),o.needsUpdate=!0,t&&t(o,r))}),r,n),o}}),fs.prototype=Object.assign(Object.create(as.prototype),{constructor:fs,load:function(e,t,r,n){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);var a=this,o=ts.get(e);if(void 0!==o)return a.manager.itemStart(e),setTimeout((function(){t&&t(o),a.manager.itemEnd(e)}),0),o;var i=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){i.removeEventListener("load",s,!1),i.removeEventListener("error",l,!1),ts.add(e,this),t&&t(this),a.manager.itemEnd(e)}function l(t){i.removeEventListener("load",s,!1),i.removeEventListener("error",l,!1),n&&n(t),a.manager.itemError(e),a.manager.itemEnd(e)}return i.addEventListener("load",s,!1),i.addEventListener("error",l,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(i.crossOrigin=this.crossOrigin),a.manager.itemStart(e),i.src=e,i}}),ds.prototype=Object.assign(Object.create(as.prototype),{constructor:ds,load:function(e,t,r,n){var a=new mr,o=new fs(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);var i=0;function s(r){o.load(e[r],(function(e){a.images[r]=e,6==++i&&(a.needsUpdate=!0,t&&t(a))}),void 0,n)}for(var l=0;l<e.length;++l)s(l);return a}}),us.prototype=Object.assign(Object.create(as.prototype),{constructor:us,load:function(e,t,r,n){var a=new d,o=new fs(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,(function(r){a.image=r;var n=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);a.format=n?1022:1023,a.needsUpdate=!0,void 0!==t&&t(a)}),r,n),a}}),Object.assign(ps.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){var r=this.getUtoTmapping(e);return this.getPoint(r,t)},getPoints:function(e){void 0===e&&(e=5);for(var t=[],r=0;r<=e;r++)t.push(this.getPoint(r/e));return t},getSpacedPoints:function(e){void 0===e&&(e=5);for(var t=[],r=0;r<=e;r++)t.push(this.getPointAt(r/e));return t},getLength:function(){var e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(void 0===e&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var t,r=[],n=this.getPoint(0),a=0;r.push(0);for(var o=1;o<=e;o++)a+=(t=this.getPoint(o/e)).distanceTo(n),r.push(a),n=t;return this.cacheArcLengths=r,r},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){var r,n=this.getLengths(),a=0,o=n.length;r=t||e*n[o-1];for(var i,s=0,l=o-1;s<=l;)if((i=n[a=Math.floor(s+(l-s)/2)]-r)<0)s=a+1;else{if(!(i>0)){l=a;break}l=a-1}if(n[a=l]===r)return a/(o-1);var c=n[a];return(a+(r-c)/(n[a+1]-c))/(o-1)},getTangent:function(e,t){var r=e-1e-4,n=e+1e-4;r<0&&(r=0),n>1&&(n=1);var a=this.getPoint(r),o=this.getPoint(n),i=t||(a.isVector2?new s:new g);return i.copy(o).sub(a).normalize(),i},getTangentAt:function(e,t){var r=this.getUtoTmapping(e);return this.getTangent(r,t)},computeFrenetFrames:function(e,t){for(var r=new g,n=[],a=[],o=[],s=new g,l=new R,c=0;c<=e;c++){var f=c/e;n[c]=this.getTangentAt(f,new g),n[c].normalize()}a[0]=new g,o[0]=new g;var d=Number.MAX_VALUE,u=Math.abs(n[0].x),p=Math.abs(n[0].y),h=Math.abs(n[0].z);u<=d&&(d=u,r.set(1,0,0)),p<=d&&(d=p,r.set(0,1,0)),h<=d&&r.set(0,0,1),s.crossVectors(n[0],r).normalize(),a[0].crossVectors(n[0],s),o[0].crossVectors(n[0],a[0]);for(var v=1;v<=e;v++){if(a[v]=a[v-1].clone(),o[v]=o[v-1].clone(),s.crossVectors(n[v-1],n[v]),s.length()>Number.EPSILON){s.normalize();var m=Math.acos(i.clamp(n[v-1].dot(n[v]),-1,1));a[v].applyMatrix4(l.makeRotationAxis(s,m))}o[v].crossVectors(n[v],a[v])}if(!0===t){var x=Math.acos(i.clamp(a[0].dot(a[e]),-1,1));x/=e,n[0].dot(s.crossVectors(a[0],a[e]))>0&&(x=-x);for(var y=1;y<=e;y++)a[y].applyMatrix4(l.makeRotationAxis(n[y],x*y)),o[y].crossVectors(n[y],a[y])}return{tangents:n,normals:a,binormals:o}},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){var e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}),hs.prototype=Object.create(ps.prototype),hs.prototype.constructor=hs,hs.prototype.isEllipseCurve=!0,hs.prototype.getPoint=function(e,t){for(var r=t||new s,n=2*Math.PI,a=this.aEndAngle-this.aStartAngle,o=Math.abs(a)<Number.EPSILON;a<0;)a+=n;for(;a>n;)a-=n;a<Number.EPSILON&&(a=o?0:n),!0!==this.aClockwise||o||(a===n?a=-n:a-=n);var i=this.aStartAngle+e*a,l=this.aX+this.xRadius*Math.cos(i),c=this.aY+this.yRadius*Math.sin(i);if(0!==this.aRotation){var f=Math.cos(this.aRotation),d=Math.sin(this.aRotation),u=l-this.aX,p=c-this.aY;l=u*f-p*d+this.aX,c=u*d+p*f+this.aY}return r.set(l,c)},hs.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},hs.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e},hs.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this},vs.prototype=Object.create(hs.prototype),vs.prototype.constructor=vs,vs.prototype.isArcCurve=!0;var xs=new g,gs=new ms,ys=new ms,Es=new ms;function ws(e,t,r,n){ps.call(this),this.type="CatmullRomCurve3",this.points=e||[],this.closed=t||!1,this.curveType=r||"centripetal",this.tension=void 0!==n?n:.5}function bs(e,t,r,n,a){var o=.5*(n-t),i=.5*(a-r),s=e*e;return(2*r-2*n+o+i)*(e*s)+(-3*r+3*n-2*o-i)*s+o*e+r}function Ts(e,t,r,n){return function(e,t){var r=1-e;return r*r*t}(e,t)+function(e,t){return 2*(1-e)*e*t}(e,r)+function(e,t){return e*e*t}(e,n)}function _s(e,t,r,n,a){return function(e,t){var r=1-e;return r*r*r*t}(e,t)+function(e,t){var r=1-e;return 3*r*r*e*t}(e,r)+function(e,t){return 3*(1-e)*e*e*t}(e,n)+function(e,t){return e*e*e*t}(e,a)}function Ss(e,t,r,n){ps.call(this),this.type="CubicBezierCurve",this.v0=e||new s,this.v1=t||new s,this.v2=r||new s,this.v3=n||new s}function Rs(e,t,r,n){ps.call(this),this.type="CubicBezierCurve3",this.v0=e||new g,this.v1=t||new g,this.v2=r||new g,this.v3=n||new g}function As(e,t){ps.call(this),this.type="LineCurve",this.v1=e||new s,this.v2=t||new s}function Ms(e,t){ps.call(this),this.type="LineCurve3",this.v1=e||new g,this.v2=t||new g}function Cs(e,t,r){ps.call(this),this.type="QuadraticBezierCurve",this.v0=e||new s,this.v1=t||new s,this.v2=r||new s}function Ls(e,t,r){ps.call(this),this.type="QuadraticBezierCurve3",this.v0=e||new g,this.v1=t||new g,this.v2=r||new g}function Hs(e){ps.call(this),this.type="SplineCurve",this.points=e||[]}ws.prototype=Object.create(ps.prototype),ws.prototype.constructor=ws,ws.prototype.isCatmullRomCurve3=!0,ws.prototype.getPoint=function(e,t){var r,n,a,o,i=t||new g,s=this.points,l=s.length,c=(l-(this.closed?0:1))*e,f=Math.floor(c),d=c-f;if(this.closed?f+=f>0?0:(Math.floor(Math.abs(f)/l)+1)*l:0===d&&f===l-1&&(f=l-2,d=1),this.closed||f>0?r=s[(f-1)%l]:(xs.subVectors(s[0],s[1]).add(s[0]),r=xs),n=s[f%l],a=s[(f+1)%l],this.closed||f+2<l?o=s[(f+2)%l]:(xs.subVectors(s[l-1],s[l-2]).add(s[l-1]),o=xs),"centripetal"===this.curveType||"chordal"===this.curveType){var u="chordal"===this.curveType?.5:.25,p=Math.pow(r.distanceToSquared(n),u),h=Math.pow(n.distanceToSquared(a),u),v=Math.pow(a.distanceToSquared(o),u);h<1e-4&&(h=1),p<1e-4&&(p=h),v<1e-4&&(v=h),gs.initNonuniformCatmullRom(r.x,n.x,a.x,o.x,p,h,v),ys.initNonuniformCatmullRom(r.y,n.y,a.y,o.y,p,h,v),Es.initNonuniformCatmullRom(r.z,n.z,a.z,o.z,p,h,v)}else"catmullrom"===this.curveType&&(gs.initCatmullRom(r.x,n.x,a.x,o.x,this.tension),ys.initCatmullRom(r.y,n.y,a.y,o.y,this.tension),Es.initCatmullRom(r.z,n.z,a.z,o.z,this.tension));return i.set(gs.calc(d),ys.calc(d),Es.calc(d)),i},ws.prototype.copy=function(e){ps.prototype.copy.call(this,e),this.points=[];for(var t=0,r=e.points.length;t<r;t++){var n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},ws.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);e.points=[];for(var t=0,r=this.points.length;t<r;t++){var n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e},ws.prototype.fromJSON=function(e){ps.prototype.fromJSON.call(this,e),this.points=[];for(var t=0,r=e.points.length;t<r;t++){var n=e.points[t];this.points.push((new g).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this},Ss.prototype=Object.create(ps.prototype),Ss.prototype.constructor=Ss,Ss.prototype.isCubicBezierCurve=!0,Ss.prototype.getPoint=function(e,t){var r=t||new s,n=this.v0,a=this.v1,o=this.v2,i=this.v3;return r.set(_s(e,n.x,a.x,o.x,i.x),_s(e,n.y,a.y,o.y,i.y)),r},Ss.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Ss.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Ss.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},Rs.prototype=Object.create(ps.prototype),Rs.prototype.constructor=Rs,Rs.prototype.isCubicBezierCurve3=!0,Rs.prototype.getPoint=function(e,t){var r=t||new g,n=this.v0,a=this.v1,o=this.v2,i=this.v3;return r.set(_s(e,n.x,a.x,o.x,i.x),_s(e,n.y,a.y,o.y,i.y),_s(e,n.z,a.z,o.z,i.z)),r},Rs.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this},Rs.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e},Rs.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this},As.prototype=Object.create(ps.prototype),As.prototype.constructor=As,As.prototype.isLineCurve=!0,As.prototype.getPoint=function(e,t){var r=t||new s;return 1===e?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r},As.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},As.prototype.getTangent=function(e,t){var r=t||new s;return r.copy(this.v2).sub(this.v1).normalize(),r},As.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},As.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},As.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},Ms.prototype=Object.create(ps.prototype),Ms.prototype.constructor=Ms,Ms.prototype.isLineCurve3=!0,Ms.prototype.getPoint=function(e,t){var r=t||new g;return 1===e?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r},Ms.prototype.getPointAt=function(e,t){return this.getPoint(e,t)},Ms.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Ms.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Ms.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},Cs.prototype=Object.create(ps.prototype),Cs.prototype.constructor=Cs,Cs.prototype.isQuadraticBezierCurve=!0,Cs.prototype.getPoint=function(e,t){var r=t||new s,n=this.v0,a=this.v1,o=this.v2;return r.set(Ts(e,n.x,a.x,o.x),Ts(e,n.y,a.y,o.y)),r},Cs.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Cs.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Cs.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},Ls.prototype=Object.create(ps.prototype),Ls.prototype.constructor=Ls,Ls.prototype.isQuadraticBezierCurve3=!0,Ls.prototype.getPoint=function(e,t){var r=t||new g,n=this.v0,a=this.v1,o=this.v2;return r.set(Ts(e,n.x,a.x,o.x),Ts(e,n.y,a.y,o.y),Ts(e,n.z,a.z,o.z)),r},Ls.prototype.copy=function(e){return ps.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this},Ls.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e},Ls.prototype.fromJSON=function(e){return ps.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this},Hs.prototype=Object.create(ps.prototype),Hs.prototype.constructor=Hs,Hs.prototype.isSplineCurve=!0,Hs.prototype.getPoint=function(e,t){var r=t||new s,n=this.points,a=(n.length-1)*e,o=Math.floor(a),i=a-o,l=n[0===o?o:o-1],c=n[o],f=n[o>n.length-2?n.length-1:o+1],d=n[o>n.length-3?n.length-1:o+2];return r.set(bs(i,l.x,c.x,f.x,d.x),bs(i,l.y,c.y,f.y,d.y)),r},Hs.prototype.copy=function(e){ps.prototype.copy.call(this,e),this.points=[];for(var t=0,r=e.points.length;t<r;t++){var n=e.points[t];this.points.push(n.clone())}return this},Hs.prototype.toJSON=function(){var e=ps.prototype.toJSON.call(this);e.points=[];for(var t=0,r=this.points.length;t<r;t++){var n=this.points[t];e.points.push(n.toArray())}return e},Hs.prototype.fromJSON=function(e){ps.prototype.fromJSON.call(this,e),this.points=[];for(var t=0,r=e.points.length;t<r;t++){var n=e.points[t];this.points.push((new s).fromArray(n))}return this};var Ps=Object.freeze({__proto__:null,ArcCurve:vs,CatmullRomCurve3:ws,CubicBezierCurve:Ss,CubicBezierCurve3:Rs,EllipseCurve:hs,LineCurve:As,LineCurve3:Ms,QuadraticBezierCurve:Cs,QuadraticBezierCurve3:Ls,SplineCurve:Hs});function zs(){ps.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}function ks(e){zs.call(this),this.type="Path",this.currentPoint=new s,e&&this.setFromPoints(e)}function Ns(e){ks.call(this,e),this.uuid=i.generateUUID(),this.type="Shape",this.holes=[]}function Ds(e,t){j.call(this),this.type="Light",this.color=new Ne(e),this.intensity=void 0!==t?t:1,this.receiveShadow=void 0}function Fs(e,t,r){Ds.call(this,e,r),this.type="HemisphereLight",this.castShadow=void 0,this.position.copy(j.DefaultUp),this.updateMatrix(),this.groundColor=new Ne(t)}function Is(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new s(512,512),this.map=null,this.mapPass=null,this.matrix=new R,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Zt,this._frameExtents=new s(1,1),this._viewportCount=1,this._viewports=[new u(0,0,1,1)]}function Os(){Is.call(this,new Vt(50,1,.5,500))}function Us(e,t,r,n,a,o){Ds.call(this,e,t),this.type="SpotLight",this.position.copy(j.DefaultUp),this.updateMatrix(),this.target=new j,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(e){this.intensity=e/Math.PI}}),this.distance=void 0!==r?r:0,this.angle=void 0!==n?n:Math.PI/3,this.penumbra=void 0!==a?a:0,this.decay=void 0!==o?o:1,this.shadow=new Os}function Gs(){Is.call(this,new Vt(90,1,.5,500)),this._frameExtents=new s(4,2),this._viewportCount=6,this._viewports=[new u(2,1,1,1),new u(0,1,1,1),new u(3,1,1,1),new u(1,1,1,1),new u(3,0,1,1),new u(1,0,1,1)],this._cubeDirections=[new g(1,0,0),new g(-1,0,0),new g(0,0,1),new g(0,0,-1),new g(0,1,0),new g(0,-1,0)],this._cubeUps=[new g(0,1,0),new g(0,1,0),new g(0,1,0),new g(0,1,0),new g(0,0,1),new g(0,0,-1)]}function Bs(e,t,r,n){Ds.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(e){this.intensity=e/(4*Math.PI)}}),this.distance=void 0!==r?r:0,this.decay=void 0!==n?n:1,this.shadow=new Gs}function Vs(e,t,r,n,a,o){Bt.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=void 0!==e?e:-1,this.right=void 0!==t?t:1,this.top=void 0!==r?r:1,this.bottom=void 0!==n?n:-1,this.near=void 0!==a?a:.1,this.far=void 0!==o?o:2e3,this.updateProjectionMatrix()}function js(){Is.call(this,new Vs(-5,5,5,-5,.5,500))}function Ws(e,t){Ds.call(this,e,t),this.type="DirectionalLight",this.position.copy(j.DefaultUp),this.updateMatrix(),this.target=new j,this.shadow=new js}function qs(e,t){Ds.call(this,e,t),this.type="AmbientLight",this.castShadow=void 0}function Xs(e,t,r,n){Ds.call(this,e,t),this.type="RectAreaLight",this.width=void 0!==r?r:10,this.height=void 0!==n?n:10}function Ys(){this.coefficients=[];for(var e=0;e<9;e++)this.coefficients.push(new g)}function Zs(e,t){Ds.call(this,void 0,t),this.type="LightProbe",this.sh=void 0!==e?e:new Ys}function Qs(e){as.call(this,e),this.textures={}}zs.prototype=Object.assign(Object.create(ps.prototype),{constructor:zs,add:function(e){this.curves.push(e)},closePath:function(){var e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new As(t,e))},getPoint:function(e){for(var t=e*this.getLength(),r=this.getCurveLengths(),n=0;n<r.length;){if(r[n]>=t){var a=r[n]-t,o=this.curves[n],i=o.getLength(),s=0===i?0:1-a/i;return o.getPointAt(s)}n++}return null},getLength:function(){var e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var e=[],t=0,r=0,n=this.curves.length;r<n;r++)t+=this.curves[r].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e){void 0===e&&(e=40);for(var t=[],r=0;r<=e;r++)t.push(this.getPoint(r/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e){e=e||12;for(var t,r=[],n=0,a=this.curves;n<a.length;n++)for(var o=a[n],i=o&&o.isEllipseCurve?2*e:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?e*o.points.length:e,s=o.getPoints(i),l=0;l<s.length;l++){var c=s[l];t&&t.equals(c)||(r.push(c),t=c)}return this.autoClose&&r.length>1&&!r[r.length-1].equals(r[0])&&r.push(r[0]),r},copy:function(e){ps.prototype.copy.call(this,e),this.curves=[];for(var t=0,r=e.curves.length;t<r;t++){var n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){var e=ps.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(var t=0,r=this.curves.length;t<r;t++){var n=this.curves[t];e.curves.push(n.toJSON())}return e},fromJSON:function(e){ps.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(var t=0,r=e.curves.length;t<r;t++){var n=e.curves[t];this.curves.push((new Ps[n.type]).fromJSON(n))}return this}}),ks.prototype=Object.assign(Object.create(zs.prototype),{constructor:ks,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(var t=1,r=e.length;t<r;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){var r=new As(this.currentPoint.clone(),new s(e,t));return this.curves.push(r),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,r,n){var a=new Cs(this.currentPoint.clone(),new s(e,t),new s(r,n));return this.curves.push(a),this.currentPoint.set(r,n),this},bezierCurveTo:function(e,t,r,n,a,o){var i=new Ss(this.currentPoint.clone(),new s(e,t),new s(r,n),new s(a,o));return this.curves.push(i),this.currentPoint.set(a,o),this},splineThru:function(e){var t=new Hs([this.currentPoint.clone()].concat(e));return this.curves.push(t),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,r,n,a,o){var i=this.currentPoint.x,s=this.currentPoint.y;return this.absarc(e+i,t+s,r,n,a,o),this},absarc:function(e,t,r,n,a,o){return this.absellipse(e,t,r,r,n,a,o),this},ellipse:function(e,t,r,n,a,o,i,s){var l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,r,n,a,o,i,s),this},absellipse:function(e,t,r,n,a,o,i,s){var l=new hs(e,t,r,n,a,o,i,s);if(this.curves.length>0){var c=l.getPoint(0);c.equals(this.currentPoint)||this.lineTo(c.x,c.y)}this.curves.push(l);var f=l.getPoint(1);return this.currentPoint.copy(f),this},copy:function(e){return zs.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){var e=zs.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return zs.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}}),Ns.prototype=Object.assign(Object.create(ks.prototype),{constructor:Ns,getPointsHoles:function(e){for(var t=[],r=0,n=this.holes.length;r<n;r++)t[r]=this.holes[r].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){ks.prototype.copy.call(this,e),this.holes=[];for(var t=0,r=e.holes.length;t<r;t++){var n=e.holes[t];this.holes.push(n.clone())}return this},toJSON:function(){var e=ks.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(var t=0,r=this.holes.length;t<r;t++){var n=this.holes[t];e.holes.push(n.toJSON())}return e},fromJSON:function(e){ks.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(var t=0,r=e.holes.length;t<r;t++){var n=e.holes[t];this.holes.push((new ks).fromJSON(n))}return this}}),Ds.prototype=Object.assign(Object.create(j.prototype),{constructor:Ds,isLight:!0,copy:function(e){return j.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){var t=j.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}),Fs.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Fs,isHemisphereLight:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}),Object.assign(Is.prototype,{_projScreenMatrix:new R,_lightPositionWorld:new g,_lookTarget:new g,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){var t=this.camera,r=this.matrix,n=this._projScreenMatrix,a=this._lookTarget,o=this._lightPositionWorld;o.setFromMatrixPosition(e.matrixWorld),t.position.copy(o),a.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(a),t.updateMatrixWorld(),n.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(n),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(t.projectionMatrix),r.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}),Os.prototype=Object.assign(Object.create(Is.prototype),{constructor:Os,isSpotLightShadow:!0,updateMatrices:function(e){var t=this.camera,r=2*i.RAD2DEG*e.angle,n=this.mapSize.width/this.mapSize.height,a=e.distance||t.far;r===t.fov&&n===t.aspect&&a===t.far||(t.fov=r,t.aspect=n,t.far=a,t.updateProjectionMatrix()),Is.prototype.updateMatrices.call(this,e)}}),Us.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Us,isSpotLight:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),Gs.prototype=Object.assign(Object.create(Is.prototype),{constructor:Gs,isPointLightShadow:!0,updateMatrices:function(e,t){void 0===t&&(t=0);var r=this.camera,n=this.matrix,a=this._lightPositionWorld,o=this._lookTarget,i=this._projScreenMatrix;a.setFromMatrixPosition(e.matrixWorld),r.position.copy(a),o.copy(r.position),o.add(this._cubeDirections[t]),r.up.copy(this._cubeUps[t]),r.lookAt(o),r.updateMatrixWorld(),n.makeTranslation(-a.x,-a.y,-a.z),i.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i)}}),Bs.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Bs,isPointLight:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}),Vs.prototype=Object.assign(Object.create(Bt.prototype),{constructor:Vs,isOrthographicCamera:!0,copy:function(e,t){return Bt.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this},setViewOffset:function(e,t,r,n,a,o){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=n,this.view.width=a,this.view.height=o,this.updateProjectionMatrix()},clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){var e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,n=(this.top+this.bottom)/2,a=r-e,o=r+e,i=n+t,s=n-t;if(null!==this.view&&this.view.enabled){var l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;o=(a+=l*this.view.offsetX)+l*this.view.width,s=(i-=c*this.view.offsetY)-c*this.view.height}this.projectionMatrix.makeOrthographic(a,o,i,s,this.near,this.far),this.projectionMatrixInverse.getInverse(this.projectionMatrix)},toJSON:function(e){var t=j.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}),js.prototype=Object.assign(Object.create(Is.prototype),{constructor:js,isDirectionalLightShadow:!0,updateMatrices:function(e){Is.prototype.updateMatrices.call(this,e)}}),Ws.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Ws,isDirectionalLight:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}),qs.prototype=Object.assign(Object.create(Ds.prototype),{constructor:qs,isAmbientLight:!0}),Xs.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Xs,isRectAreaLight:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){var t=Ds.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}}),Object.assign(Ys.prototype,{isSphericalHarmonics3:!0,set:function(e){for(var t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this},zero:function(){for(var e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this},getAt:function(e,t){var r=e.x,n=e.y,a=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*n),t.addScaledVector(o[2],.488603*a),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],r*n*1.092548),t.addScaledVector(o[5],n*a*1.092548),t.addScaledVector(o[6],.315392*(3*a*a-1)),t.addScaledVector(o[7],r*a*1.092548),t.addScaledVector(o[8],.546274*(r*r-n*n)),t},getIrradianceAt:function(e,t){var r=e.x,n=e.y,a=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],1.023328*n),t.addScaledVector(o[2],1.023328*a),t.addScaledVector(o[3],1.023328*r),t.addScaledVector(o[4],.858086*r*n),t.addScaledVector(o[5],.858086*n*a),t.addScaledVector(o[6],.743125*a*a-.247708),t.addScaledVector(o[7],.858086*r*a),t.addScaledVector(o[8],.429043*(r*r-n*n)),t},add:function(e){for(var t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this},addScaledSH:function(e,t){for(var r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this},scale:function(e){for(var t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this},lerp:function(e,t){for(var r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this},equals:function(e){for(var t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0},copy:function(e){return this.set(e.coefficients)},clone:function(){return(new this.constructor).copy(this)},fromArray:function(e,t){void 0===t&&(t=0);for(var r=this.coefficients,n=0;n<9;n++)r[n].fromArray(e,t+3*n);return this},toArray:function(e,t){void 0===e&&(e=[]),void 0===t&&(t=0);for(var r=this.coefficients,n=0;n<9;n++)r[n].toArray(e,t+3*n);return e}}),Object.assign(Ys,{getBasisAt:function(e,t){var r=e.x,n=e.y,a=e.z;t[0]=.282095,t[1]=.488603*n,t[2]=.488603*a,t[3]=.488603*r,t[4]=1.092548*r*n,t[5]=1.092548*n*a,t[6]=.315392*(3*a*a-1),t[7]=1.092548*r*a,t[8]=.546274*(r*r-n*n)}}),Zs.prototype=Object.assign(Object.create(Ds.prototype),{constructor:Zs,isLightProbe:!0,copy:function(e){return Ds.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){var t=Ds.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}}),Qs.prototype=Object.assign(Object.create(as.prototype),{constructor:Qs,load:function(e,t,r,n){var a=this,o=new is(a.manager);o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(JSON.parse(r)))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t=this.textures;function r(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}var n=new Oi[e.type];if(void 0!==e.uuid&&(n.uuid=e.uuid),void 0!==e.name&&(n.name=e.name),void 0!==e.color&&n.color.setHex(e.color),void 0!==e.roughness&&(n.roughness=e.roughness),void 0!==e.metalness&&(n.metalness=e.metalness),void 0!==e.sheen&&(n.sheen=(new Ne).setHex(e.sheen)),void 0!==e.emissive&&n.emissive.setHex(e.emissive),void 0!==e.specular&&n.specular.setHex(e.specular),void 0!==e.shininess&&(n.shininess=e.shininess),void 0!==e.clearcoat&&(n.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(n.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(n.fog=e.fog),void 0!==e.flatShading&&(n.flatShading=e.flatShading),void 0!==e.blending&&(n.blending=e.blending),void 0!==e.combine&&(n.combine=e.combine),void 0!==e.side&&(n.side=e.side),void 0!==e.opacity&&(n.opacity=e.opacity),void 0!==e.transparent&&(n.transparent=e.transparent),void 0!==e.alphaTest&&(n.alphaTest=e.alphaTest),void 0!==e.depthTest&&(n.depthTest=e.depthTest),void 0!==e.depthWrite&&(n.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(n.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(n.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(n.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(n.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(n.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(n.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(n.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(n.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(n.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(n.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(n.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(n.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(n.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(n.rotation=e.rotation),1!==e.linewidth&&(n.linewidth=e.linewidth),void 0!==e.dashSize&&(n.dashSize=e.dashSize),void 0!==e.gapSize&&(n.gapSize=e.gapSize),void 0!==e.scale&&(n.scale=e.scale),void 0!==e.polygonOffset&&(n.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(n.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(n.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(n.skinning=e.skinning),void 0!==e.morphTargets&&(n.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(n.morphNormals=e.morphNormals),void 0!==e.dithering&&(n.dithering=e.dithering),void 0!==e.vertexTangents&&(n.vertexTangents=e.vertexTangents),void 0!==e.visible&&(n.visible=e.visible),void 0!==e.toneMapped&&(n.toneMapped=e.toneMapped),void 0!==e.userData&&(n.userData=e.userData),void 0!==e.vertexColors&&("number"==typeof e.vertexColors?n.vertexColors=e.vertexColors>0:n.vertexColors=e.vertexColors),void 0!==e.uniforms)for(var a in e.uniforms){var o=e.uniforms[a];switch(n.uniforms[a]={},o.type){case"t":n.uniforms[a].value=r(o.value);break;case"c":n.uniforms[a].value=(new Ne).setHex(o.value);break;case"v2":n.uniforms[a].value=(new s).fromArray(o.value);break;case"v3":n.uniforms[a].value=(new g).fromArray(o.value);break;case"v4":n.uniforms[a].value=(new u).fromArray(o.value);break;case"m3":n.uniforms[a].value=(new l).fromArray(o.value);case"m4":n.uniforms[a].value=(new R).fromArray(o.value);break;default:n.uniforms[a].value=o.value}}if(void 0!==e.defines&&(n.defines=e.defines),void 0!==e.vertexShader&&(n.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(n.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(var i in e.extensions)n.extensions[i]=e.extensions[i];if(void 0!==e.shading&&(n.flatShading=1===e.shading),void 0!==e.size&&(n.size=e.size),void 0!==e.sizeAttenuation&&(n.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(n.map=r(e.map)),void 0!==e.matcap&&(n.matcap=r(e.matcap)),void 0!==e.alphaMap&&(n.alphaMap=r(e.alphaMap)),void 0!==e.bumpMap&&(n.bumpMap=r(e.bumpMap)),void 0!==e.bumpScale&&(n.bumpScale=e.bumpScale),void 0!==e.normalMap&&(n.normalMap=r(e.normalMap)),void 0!==e.normalMapType&&(n.normalMapType=e.normalMapType),void 0!==e.normalScale){var c=e.normalScale;!1===Array.isArray(c)&&(c=[c,c]),n.normalScale=(new s).fromArray(c)}return void 0!==e.displacementMap&&(n.displacementMap=r(e.displacementMap)),void 0!==e.displacementScale&&(n.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(n.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(n.roughnessMap=r(e.roughnessMap)),void 0!==e.metalnessMap&&(n.metalnessMap=r(e.metalnessMap)),void 0!==e.emissiveMap&&(n.emissiveMap=r(e.emissiveMap)),void 0!==e.emissiveIntensity&&(n.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(n.specularMap=r(e.specularMap)),void 0!==e.envMap&&(n.envMap=r(e.envMap)),void 0!==e.envMapIntensity&&(n.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(n.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(n.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(n.lightMap=r(e.lightMap)),void 0!==e.lightMapIntensity&&(n.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(n.aoMap=r(e.aoMap)),void 0!==e.aoMapIntensity&&(n.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(n.gradientMap=r(e.gradientMap)),void 0!==e.clearcoatMap&&(n.clearcoatMap=r(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(n.clearcoatRoughnessMap=r(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(n.clearcoatNormalMap=r(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(n.clearcoatNormalScale=(new s).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(n.transmission=e.transmission),void 0!==e.transmissionMap&&(n.transmissionMap=r(e.transmissionMap)),n},setTextures:function(e){return this.textures=e,this}});var Ks={decodeText:function(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);for(var t="",r=0,n=e.length;r<n;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch(e){return t}},extractUrlBase:function(e){var t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}};function Js(){ft.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}function $s(e,t,r,n){"number"==typeof r&&(n=r,r=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),We.call(this,e,t,r),this.meshPerAttribute=n||1}function el(e){as.call(this,e)}Js.prototype=Object.assign(Object.create(ft.prototype),{constructor:Js,isInstancedBufferGeometry:!0,copy:function(e){return ft.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var e=ft.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}),$s.prototype=Object.assign(Object.create(We.prototype),{constructor:$s,isInstancedBufferAttribute:!0,copy:function(e){return We.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){var e=We.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}),el.prototype=Object.assign(Object.create(as.prototype),{constructor:el,load:function(e,t,r,n){var a=this,o=new is(a.manager);o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(JSON.parse(r)))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t={},r={};function n(e,n){if(void 0!==t[n])return t[n];var a=e.interleavedBuffers[n],o=function(e,t){if(void 0!==r[t])return r[t];var n=e.arrayBuffers[t],a=new Uint32Array(n).buffer;return r[t]=a,a}(e,a.buffer),i=new sa(new tl[a.type](o),a.stride);return i.uuid=a.uuid,t[n]=i,i}var a=e.isInstancedBufferGeometry?new Js:new ft,o=e.data.index;if(void 0!==o){var i=new tl[o.type](o.array);a.setIndex(new We(i,1))}var s=e.data.attributes;for(var l in s){var c=s[l],f=void 0;if(c.isInterleavedBufferAttribute)f=new fa(n(e.data,c.data),c.itemSize,c.offset,c.normalized);else{var d=new tl[c.type](c.array);f=new(c.isInstancedBufferAttribute?$s:We)(d,c.itemSize,c.normalized)}void 0!==c.name&&(f.name=c.name),a.setAttribute(l,f)}var u=e.data.morphAttributes;if(u)for(var p in u){for(var h=u[p],v=[],m=0,x=h.length;m<x;m++){var y=h[m],E=void 0;E=y.isInterleavedBufferAttribute?new fa(n(e.data,y.data),y.itemSize,y.offset,y.normalized):new We(new tl[y.type](y.array),y.itemSize,y.normalized),void 0!==y.name&&(E.name=y.name),v.push(E)}a.morphAttributes[p]=v}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);var w=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==w)for(var b=0,T=w.length;b!==T;++b){var _=w[b];a.addGroup(_.start,_.count,_.materialIndex)}var S=e.data.boundingSphere;if(void 0!==S){var R=new g;void 0!==S.center&&R.fromArray(S.center),a.boundingSphere=new le(R,S.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}});var tl={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function rl(e){as.call(this,e)}rl.prototype=Object.assign(Object.create(as.prototype),{constructor:rl,load:function(e,t,r,n){var a=this,o=""===this.path?Ks.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;var i=new is(a.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.load(e,(function(r){var o=null;try{o=JSON.parse(r)}catch(t){return void 0!==n&&n(t),void console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message)}var i=o.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?a.parse(o,t):console.error("THREE.ObjectLoader: Can't load "+e)}),r,n)},parse:function(e,t){var r=this.parseShape(e.shapes),n=this.parseGeometries(e.geometries,r),a=this.parseImages(e.images,(function(){void 0!==t&&t(s)})),o=this.parseTextures(e.textures,a),i=this.parseMaterials(e.materials,o),s=this.parseObject(e.object,n,i);return e.animations&&(s.animations=this.parseAnimations(e.animations)),void 0!==e.images&&0!==e.images.length||void 0!==t&&t(s),s},parseShape:function(e){var t={};if(void 0!==e)for(var r=0,n=e.length;r<n;r++){var a=(new Ns).fromJSON(e[r]);t[a.uuid]=a}return t},parseGeometries:function(e,t){var r,n={};if(void 0!==e)for(var a=new el,o=0,i=e.length;o<i;o++){var s=void 0,l=e[o];switch(l.type){case"PlaneGeometry":case"PlaneBufferGeometry":s=new Mi[l.type](l.width,l.height,l.widthSegments,l.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":case"CubeGeometry":s=new Mi[l.type](l.width,l.height,l.depth,l.widthSegments,l.heightSegments,l.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":s=new Mi[l.type](l.radius,l.segments,l.thetaStart,l.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":s=new Mi[l.type](l.radiusTop,l.radiusBottom,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":s=new Mi[l.type](l.radius,l.height,l.radialSegments,l.heightSegments,l.openEnded,l.thetaStart,l.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":s=new Mi[l.type](l.radius,l.widthSegments,l.heightSegments,l.phiStart,l.phiLength,l.thetaStart,l.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":s=new Mi[l.type](l.radius,l.detail);break;case"RingGeometry":case"RingBufferGeometry":s=new Mi[l.type](l.innerRadius,l.outerRadius,l.thetaSegments,l.phiSegments,l.thetaStart,l.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":s=new Mi[l.type](l.radius,l.tube,l.radialSegments,l.tubularSegments,l.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":s=new Mi[l.type](l.radius,l.tube,l.tubularSegments,l.radialSegments,l.p,l.q);break;case"TubeGeometry":case"TubeBufferGeometry":s=new Mi[l.type]((new Ps[l.path.type]).fromJSON(l.path),l.tubularSegments,l.radius,l.radialSegments,l.closed);break;case"LatheGeometry":case"LatheBufferGeometry":s=new Mi[l.type](l.points,l.segments,l.phiStart,l.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":s=new Mi[l.type](l.vertices,l.indices,l.radius,l.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(var c=0,f=l.shapes.length;c<f;c++){var d=t[l.shapes[c]];r.push(d)}s=new Mi[l.type](r,l.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(var u=0,p=l.shapes.length;u<p;u++){var h=t[l.shapes[u]];r.push(h)}var v=l.options.extrudePath;void 0!==v&&(l.options.extrudePath=(new Ps[v.type]).fromJSON(v)),s=new Mi[l.type](r,l.options);break;case"BufferGeometry":case"InstancedBufferGeometry":s=a.parse(l);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+l.type+'"');continue}s.uuid=l.uuid,void 0!==l.name&&(s.name=l.name),!0===s.isBufferGeometry&&void 0!==l.userData&&(s.userData=l.userData),n[l.uuid]=s}return n},parseMaterials:function(e,t){var r={},n={};if(void 0!==e){var a=new Qs;a.setTextures(t);for(var o=0,i=e.length;o<i;o++){var s=e[o];if("MultiMaterial"===s.type){for(var l=[],c=0;c<s.materials.length;c++){var f=s.materials[c];void 0===r[f.uuid]&&(r[f.uuid]=a.parse(f)),l.push(r[f.uuid])}n[s.uuid]=l}else void 0===r[s.uuid]&&(r[s.uuid]=a.parse(s)),n[s.uuid]=r[s.uuid]}}return n},parseAnimations:function(e){for(var t=[],r=0;r<e.length;r++){var n=e[r],a=$i.parse(n);void 0!==n.uuid&&(a.uuid=n.uuid),t.push(a)}return t},parseImages:function(e,t){var r,n=this,a={};function o(e){return n.manager.itemStart(e),r.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}if(void 0!==e&&e.length>0){var i=new rs(t);(r=new fs(i)).setCrossOrigin(this.crossOrigin);for(var s=0,l=e.length;s<l;s++){var c=e[s],f=c.url;if(Array.isArray(f)){a[c.uuid]=[];for(var d=0,u=f.length;d<u;d++){var p=f[d],h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(p)?p:n.resourcePath+p;a[c.uuid].push(o(h))}}else{var v=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url)?c.url:n.resourcePath+c.url;a[c.uuid]=o(v)}}}return a},parseTextures:function(e,t){function r(e,t){return"number"==typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}var n={};if(void 0!==e)for(var a=0,o=e.length;a<o;a++){var i=e[a];void 0===i.image&&console.warn('THREE.ObjectLoader: No "image" specified for',i.uuid),void 0===t[i.image]&&console.warn("THREE.ObjectLoader: Undefined image",i.image);var s=void 0;(s=Array.isArray(t[i.image])?new mr(t[i.image]):new d(t[i.image])).needsUpdate=!0,s.uuid=i.uuid,void 0!==i.name&&(s.name=i.name),void 0!==i.mapping&&(s.mapping=r(i.mapping,al)),void 0!==i.offset&&s.offset.fromArray(i.offset),void 0!==i.repeat&&s.repeat.fromArray(i.repeat),void 0!==i.center&&s.center.fromArray(i.center),void 0!==i.rotation&&(s.rotation=i.rotation),void 0!==i.wrap&&(s.wrapS=r(i.wrap[0],ol),s.wrapT=r(i.wrap[1],ol)),void 0!==i.format&&(s.format=i.format),void 0!==i.type&&(s.type=i.type),void 0!==i.encoding&&(s.encoding=i.encoding),void 0!==i.minFilter&&(s.minFilter=r(i.minFilter,il)),void 0!==i.magFilter&&(s.magFilter=r(i.magFilter,il)),void 0!==i.anisotropy&&(s.anisotropy=i.anisotropy),void 0!==i.flipY&&(s.flipY=i.flipY),void 0!==i.premultiplyAlpha&&(s.premultiplyAlpha=i.premultiplyAlpha),void 0!==i.unpackAlignment&&(s.unpackAlignment=i.unpackAlignment),n[i.uuid]=s}return n},parseObject:function(e,t,r){var n,a,o;function i(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function s(e){if(void 0!==e){if(Array.isArray(e)){for(var t=[],n=0,a=e.length;n<a;n++){var o=e[n];void 0===r[o]&&console.warn("THREE.ObjectLoader: Undefined material",o),t.push(r[o])}return t}return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),r[e]}}switch(e.type){case"Scene":n=new W,void 0!==e.background&&Number.isInteger(e.background)&&(n.background=new Ne(e.background)),void 0!==e.fog&&("Fog"===e.fog.type?n.fog=new ia(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(n.fog=new oa(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":n=new Vt(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(n.focus=e.focus),void 0!==e.zoom&&(n.zoom=e.zoom),void 0!==e.filmGauge&&(n.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(n.filmOffset=e.filmOffset),void 0!==e.view&&(n.view=Object.assign({},e.view));break;case"OrthographicCamera":n=new Vs(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(n.zoom=e.zoom),void 0!==e.view&&(n.view=Object.assign({},e.view));break;case"AmbientLight":n=new qs(e.color,e.intensity);break;case"DirectionalLight":n=new Ws(e.color,e.intensity);break;case"PointLight":n=new Bs(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":n=new Xs(e.color,e.intensity,e.width,e.height);break;case"SpotLight":n=new Us(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":n=new Fs(e.color,e.groundColor,e.intensity);break;case"LightProbe":n=(new Zs).fromJSON(e);break;case"SkinnedMesh":console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");case"Mesh":n=new Mt(a=i(e.geometry),o=s(e.material));break;case"InstancedMesh":a=i(e.geometry),o=s(e.material);var l=e.count,c=e.instanceMatrix;(n=new Va(a,o,l)).instanceMatrix=new We(new Float32Array(c.array),16);break;case"LOD":n=new za;break;case"Line":n=new Qa(i(e.geometry),s(e.material),e.mode);break;case"LineLoop":n=new eo(i(e.geometry),s(e.material));break;case"LineSegments":n=new $a(i(e.geometry),s(e.material));break;case"PointCloud":case"Points":n=new io(i(e.geometry),s(e.material));break;case"Sprite":n=new _a(s(e.material));break;case"Group":n=new $n;break;default:n=new j}if(n.uuid=e.uuid,void 0!==e.name&&(n.name=e.name),void 0!==e.matrix?(n.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(n.matrixAutoUpdate=e.matrixAutoUpdate),n.matrixAutoUpdate&&n.matrix.decompose(n.position,n.quaternion,n.scale)):(void 0!==e.position&&n.position.fromArray(e.position),void 0!==e.rotation&&n.rotation.fromArray(e.rotation),void 0!==e.quaternion&&n.quaternion.fromArray(e.quaternion),void 0!==e.scale&&n.scale.fromArray(e.scale)),void 0!==e.castShadow&&(n.castShadow=e.castShadow),void 0!==e.receiveShadow&&(n.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(n.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(n.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(n.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&n.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(n.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(n.visible=e.visible),void 0!==e.frustumCulled&&(n.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(n.renderOrder=e.renderOrder),void 0!==e.userData&&(n.userData=e.userData),void 0!==e.layers&&(n.layers.mask=e.layers),void 0!==e.children)for(var f=e.children,d=0;d<f.length;d++)n.add(this.parseObject(f[d],t,r));if("LOD"===e.type){void 0!==e.autoUpdate&&(n.autoUpdate=e.autoUpdate);for(var u=e.levels,p=0;p<u.length;p++){var h=u[p],v=n.getObjectByProperty("uuid",h.object);void 0!==v&&n.addLevel(v,h.distance)}}return n}});var nl,al={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307},ol={RepeatWrapping:1e3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},il={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};function sl(e){"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),as.call(this,e),this.options={premultiplyAlpha:"none"}}function ll(){this.type="ShapePath",this.color=new Ne,this.subPaths=[],this.currentPath=null}function cl(e){this.type="Font",this.data=e}function fl(e,t,r,n,a){var o=a.glyphs[e]||a.glyphs["?"];if(o){var i,s,l,c,f,d,u,p,h=new ll;if(o.o)for(var v=o._cachedOutline||(o._cachedOutline=o.o.split(" ")),m=0,x=v.length;m<x;)switch(v[m++]){case"m":i=v[m++]*t+r,s=v[m++]*t+n,h.moveTo(i,s);break;case"l":i=v[m++]*t+r,s=v[m++]*t+n,h.lineTo(i,s);break;case"q":l=v[m++]*t+r,c=v[m++]*t+n,f=v[m++]*t+r,d=v[m++]*t+n,h.quadraticCurveTo(f,d,l,c);break;case"b":l=v[m++]*t+r,c=v[m++]*t+n,f=v[m++]*t+r,d=v[m++]*t+n,u=v[m++]*t+r,p=v[m++]*t+n,h.bezierCurveTo(f,d,u,p,l,c)}return{offsetX:o.ha*t,path:h}}console.error('THREE.Font: character "'+e+'" does not exists in font family '+a.familyName+".")}function dl(e){as.call(this,e)}sl.prototype=Object.assign(Object.create(as.prototype),{constructor:sl,isImageBitmapLoader:!0,setOptions:function(e){return this.options=e,this},load:function(e,t,r,n){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);var a=this,o=ts.get(e);if(void 0!==o)return a.manager.itemStart(e),setTimeout((function(){t&&t(o),a.manager.itemEnd(e)}),0),o;fetch(e).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,a.options)})).then((function(r){ts.add(e,r),t&&t(r),a.manager.itemEnd(e)})).catch((function(t){n&&n(t),a.manager.itemError(e),a.manager.itemEnd(e)})),a.manager.itemStart(e)}}),Object.assign(ll.prototype,{moveTo:function(e,t){return this.currentPath=new ks,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,r,n){return this.currentPath.quadraticCurveTo(e,t,r,n),this},bezierCurveTo:function(e,t,r,n,a,o){return this.currentPath.bezierCurveTo(e,t,r,n,a,o),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function r(e){for(var t=[],r=0,n=e.length;r<n;r++){var a=e[r],o=new Ns;o.curves=a.curves,t.push(o)}return t}function n(e,t){for(var r=t.length,n=!1,a=r-1,o=0;o<r;a=o++){var i=t[a],s=t[o],l=s.x-i.x,c=s.y-i.y;if(Math.abs(c)>Number.EPSILON){if(c<0&&(i=t[o],l=-l,s=t[a],c=-c),e.y<i.y||e.y>s.y)continue;if(e.y===i.y){if(e.x===i.x)return!0}else{var f=c*(e.x-i.x)-l*(e.y-i.y);if(0===f)return!0;if(f<0)continue;n=!n}}else{if(e.y!==i.y)continue;if(s.x<=e.x&&e.x<=i.x||i.x<=e.x&&e.x<=s.x)return!0}}return n}var a=ni.isClockWise,o=this.subPaths;if(0===o.length)return[];if(!0===t)return r(o);var i,s,l,c=[];if(1===o.length)return s=o[0],(l=new Ns).curves=s.curves,c.push(l),c;var f=!a(o[0].getPoints());f=e?!f:f;var d,u,p=[],h=[],v=[],m=0;h[m]=void 0,v[m]=[];for(var x=0,g=o.length;x<g;x++)i=a(d=(s=o[x]).getPoints()),(i=e?!i:i)?(!f&&h[m]&&m++,h[m]={s:new Ns,p:d},h[m].s.curves=s.curves,f&&m++,v[m]=[]):v[m].push({h:s,p:d[0]});if(!h[0])return r(o);if(h.length>1){for(var y=!1,E=[],w=0,b=h.length;w<b;w++)p[w]=[];for(var T=0,_=h.length;T<_;T++)for(var S=v[T],R=0;R<S.length;R++){for(var A=S[R],M=!0,C=0;C<h.length;C++)n(A.p,h[C].p)&&(T!==C&&E.push({froms:T,tos:C,hole:R}),M?(M=!1,p[C].push(A)):y=!0);M&&p[T].push(A)}E.length>0&&(y||(v=p))}for(var L=0,H=h.length;L<H;L++){l=h[L].s,c.push(l);for(var P=0,z=(u=v[L]).length;P<z;P++)l.holes.push(u[P].h)}return c}}),Object.assign(cl.prototype,{isFont:!0,generateShapes:function(e,t){void 0===t&&(t=100);for(var r=[],n=function(e,t,r){for(var n=Array.from?Array.from(e):String(e).split(""),a=t/r.resolution,o=(r.boundingBox.yMax-r.boundingBox.yMin+r.underlineThickness)*a,i=[],s=0,l=0,c=0;c<n.length;c++){var f=n[c];if("\n"===f)s=0,l-=o;else{var d=fl(f,a,s,l,r);s+=d.offsetX,i.push(d.path)}}return i}(e,t,this.data),a=0,o=n.length;a<o;a++)Array.prototype.push.apply(r,n[a].toShapes());return r}}),dl.prototype=Object.assign(Object.create(as.prototype),{constructor:dl,load:function(e,t,r,n){var a=this,o=new is(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.load(e,(function(e){var r;try{r=JSON.parse(e)}catch(t){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),r=JSON.parse(e.substring(65,e.length-2))}var n=a.parse(r);t&&t(n)}),r,n)},parse:function(e){return new cl(e)}});var ul={getContext:function(){return void 0===nl&&(nl=new(window.AudioContext||window.webkitAudioContext)),nl},setContext:function(e){nl=e}};function pl(e){as.call(this,e)}function hl(e,t,r){Zs.call(this,void 0,r);var n=(new Ne).set(e),a=(new Ne).set(t),o=new g(n.r,n.g,n.b),i=new g(a.r,a.g,a.b),s=Math.sqrt(Math.PI),l=s*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(i).multiplyScalar(s),this.sh.coefficients[1].copy(o).sub(i).multiplyScalar(l)}function vl(e,t){Zs.call(this,void 0,t);var r=(new Ne).set(e);this.sh.coefficients[0].set(r.r,r.g,r.b).multiplyScalar(2*Math.sqrt(Math.PI))}pl.prototype=Object.assign(Object.create(as.prototype),{constructor:pl,load:function(e,t,r,n){var a=this,o=new is(a.manager);o.setResponseType("arraybuffer"),o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{var o=r.slice(0);ul.getContext().decodeAudioData(o,(function(e){t(e)}))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)}}),hl.prototype=Object.assign(Object.create(Zs.prototype),{constructor:hl,isHemisphereLightProbe:!0,copy:function(e){return Zs.prototype.copy.call(this,e),this},toJSON:function(e){return Zs.prototype.toJSON.call(this,e)}}),vl.prototype=Object.assign(Object.create(Zs.prototype),{constructor:vl,isAmbientLightProbe:!0,copy:function(e){return Zs.prototype.copy.call(this,e),this},toJSON:function(e){return Zs.prototype.toJSON.call(this,e)}});var ml=new R,xl=new R;function gl(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Vt,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Vt,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}function yl(e){this.autoStart=void 0===e||e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}Object.assign(gl.prototype,{update:function(e){var t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;var r,n,a=e.projectionMatrix.clone(),o=t.eyeSep/2,s=o*t.near/t.focus,l=t.near*Math.tan(i.DEG2RAD*t.fov*.5)/t.zoom;xl.elements[12]=-o,ml.elements[12]=o,r=-l*t.aspect+s,n=l*t.aspect+s,a.elements[0]=2*t.near/(n-r),a.elements[8]=(n+r)/(n-r),this.cameraL.projectionMatrix.copy(a),r=-l*t.aspect-s,n=l*t.aspect-s,a.elements[0]=2*t.near/(n-r),a.elements[8]=(n+r)/(n-r),this.cameraR.projectionMatrix.copy(a)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(xl),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ml)}}),Object.assign(yl.prototype,{start:function(){this.startTime=("undefined"==typeof performance?Date:performance).now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0},stop:function(){this.getElapsedTime(),this.running=!1,this.autoStart=!1},getElapsedTime:function(){return this.getDelta(),this.elapsedTime},getDelta:function(){var e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){var t=("undefined"==typeof performance?Date:performance).now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}});var El=new g,wl=new v,bl=new g,Tl=new g;function _l(){j.call(this),this.type="AudioListener",this.context=ul.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new yl}function Sl(e){j.call(this),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.sourceType="empty",this._startedAt=0,this._progress=0,this.filters=[]}_l.prototype=Object.assign(Object.create(j.prototype),{constructor:_l,getInput:function(){return this.gain},removeFilter:function(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this},getFilter:function(){return this.filter},setFilter:function(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this},updateMatrixWorld:function(e){j.prototype.updateMatrixWorld.call(this,e);var t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(El,wl,bl),Tl.set(0,0,-1).applyQuaternion(wl),t.positionX){var n=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(El.x,n),t.positionY.linearRampToValueAtTime(El.y,n),t.positionZ.linearRampToValueAtTime(El.z,n),t.forwardX.linearRampToValueAtTime(Tl.x,n),t.forwardY.linearRampToValueAtTime(Tl.y,n),t.forwardZ.linearRampToValueAtTime(Tl.z,n),t.upX.linearRampToValueAtTime(r.x,n),t.upY.linearRampToValueAtTime(r.y,n),t.upZ.linearRampToValueAtTime(r.z,n)}else t.setPosition(El.x,El.y,El.z),t.setOrientation(Tl.x,Tl.y,Tl.z,r.x,r.y,r.z)}}),Sl.prototype=Object.assign(Object.create(j.prototype),{constructor:Sl,getOutput:function(){return this.gain},setNodeSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this},setMediaElementSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this},setMediaStreamSource:function(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this},setBuffer:function(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this},play:function(e){if(void 0===e&&(e=0),!0!==this.isPlaying){if(!1!==this.hasPlaybackControl){this._startedAt=this.context.currentTime+e;var t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}console.warn("THREE.Audio: this Audio has no playback control.")}else console.warn("THREE.Audio: Audio is already playing.")},pause:function(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")},stop:function(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")},connect:function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(e){return e||(e=[]),!0===this.isPlaying?(this.disconnect(),this.filters=e,this.connect()):this.filters=e,this},setDetune:function(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this},getDetune:function(){return this.detune},getFilter:function(){return this.getFilters()[0]},setFilter:function(e){return this.setFilters(e?[e]:[])},setPlaybackRate:function(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop},setLoop:function(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")},setLoopStart:function(e){return this.loopStart=e,this},setLoopEnd:function(e){return this.loopEnd=e,this},getVolume:function(){return this.gain.gain.value},setVolume:function(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}});var Rl=new g,Al=new v,Ml=new g,Cl=new g;function Ll(e){Sl.call(this,e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}function Hl(e,t){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=void 0!==t?t:2048,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}function Pl(e,t,r){var n,a,o;switch(this.binding=e,this.valueSize=r,t){case"quaternion":n=this._slerp,a=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*r),this._workIndex=5;break;case"string":case"bool":n=this._select,a=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(5*r);break;default:n=this._lerp,a=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*r)}this._mixBufferRegion=n,this._mixBufferRegionAdditive=a,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Ll.prototype=Object.assign(Object.create(Sl.prototype),{constructor:Ll,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(e){return this.panner.refDistance=e,this},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(e){return this.panner.rolloffFactor=e,this},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(e){return this.panner.distanceModel=e,this},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(e){return this.panner.maxDistance=e,this},setDirectionalCone:function(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this},updateMatrixWorld:function(e){if(j.prototype.updateMatrixWorld.call(this,e),!0!==this.hasPlaybackControl||!1!==this.isPlaying){this.matrixWorld.decompose(Rl,Al,Ml),Cl.set(0,0,1).applyQuaternion(Al);var t=this.panner;if(t.positionX){var r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Rl.x,r),t.positionY.linearRampToValueAtTime(Rl.y,r),t.positionZ.linearRampToValueAtTime(Rl.z,r),t.orientationX.linearRampToValueAtTime(Cl.x,r),t.orientationY.linearRampToValueAtTime(Cl.y,r),t.orientationZ.linearRampToValueAtTime(Cl.z,r)}else t.setPosition(Rl.x,Rl.y,Rl.z),t.setOrientation(Cl.x,Cl.y,Cl.z)}}}),Object.assign(Hl.prototype,{getFrequencyData:function(){return this.analyser.getByteFrequencyData(this.data),this.data},getAverageFrequency:function(){for(var e=0,t=this.getFrequencyData(),r=0;r<t.length;r++)e+=t[r];return e/t.length}}),Object.assign(Pl.prototype,{accumulate:function(e,t){var r=this.buffer,n=this.valueSize,a=e*n+n,o=this.cumulativeWeight;if(0===o){for(var i=0;i!==n;++i)r[a+i]=r[i];o=t}else{var s=t/(o+=t);this._mixBufferRegion(r,a,0,s,n)}this.cumulativeWeight=o},accumulateAdditive:function(e){var t=this.buffer,r=this.valueSize,n=r*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,n,0,e,r),this.cumulativeWeightAdditive+=e},apply:function(e){var t=this.valueSize,r=this.buffer,n=e*t+t,a=this.cumulativeWeight,o=this.cumulativeWeightAdditive,i=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,a<1){var s=t*this._origIndex;this._mixBufferRegion(r,n,s,1-a,t)}o>0&&this._mixBufferRegionAdditive(r,n,this._addIndex*t,1,t);for(var l=t,c=t+t;l!==c;++l)if(r[l]!==r[l+t]){i.setValue(r,n);break}},saveOriginalState:function(){var e=this.binding,t=this.buffer,r=this.valueSize,n=r*this._origIndex;e.getValue(t,n);for(var a=r,o=n;a!==o;++a)t[a]=t[n+a%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){var e=3*this.valueSize;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){for(var e=this._addIndex*this.valueSize,t=e+this.valueSize,r=e;r<t;r++)this.buffer[r]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[4*this._addIndex+3]=1},_setAdditiveIdentityOther:function(){for(var e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize,r=0;r<this.valueSize;r++)this.buffer[t+r]=this.buffer[e+r]},_select:function(e,t,r,n,a){if(n>=.5)for(var o=0;o!==a;++o)e[t+o]=e[r+o]},_slerp:function(e,t,r,n){v.slerpFlat(e,t,e,t,e,r,n)},_slerpAdditive:function(e,t,r,n,a){var o=this._workIndex*a;v.multiplyQuaternionsFlat(e,o,e,t,e,r),v.slerpFlat(e,t,e,t,e,o,n)},_lerp:function(e,t,r,n,a){for(var o=1-n,i=0;i!==a;++i){var s=t+i;e[s]=e[s]*o+e[r+i]*n}},_lerpAdditive:function(e,t,r,n,a){for(var o=0;o!==a;++o){var i=t+o;e[i]=e[i]+e[r+o]*n}}});var zl=new RegExp("[\\[\\]\\.:\\/]","g"),kl="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",Nl=/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]"),Dl=/(WCOD+)?/.source.replace("WCOD",kl),Fl=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Il=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]"),Ol=new RegExp("^"+Nl+Dl+Fl+Il+"$"),Ul=["material","materials","bones"];function Gl(e,t,r){var n=r||Bl.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,n)}function Bl(e,t,r){this.path=t,this.parsedPath=r||Bl.parseTrackName(t),this.node=Bl.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}function Vl(){this.uuid=i.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;var e={};this._indicesByUUID=e;for(var t=0,r=arguments.length;t!==r;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};var n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}function jl(e,t,r,n){this._mixer=e,this._clip=t,this._localRoot=r||null,this.blendMode=n||t.blendMode;for(var a=t.tracks,o=a.length,i=new Array(o),s={endingStart:2400,endingEnd:2400},l=0;l!==o;++l){var c=a[l].createInterpolant(null);i[l]=c,c.settings=s}this._interpolantSettings=s,this._interpolants=i,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}function Wl(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}function ql(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}function Xl(e,t,r){sa.call(this,e,t),this.meshPerAttribute=r||1}function Yl(e,t,r,n){this.ray=new me(e,t),this.near=r||0,this.far=n||1/0,this.camera=null,this.layers=new L,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Zl(e,t){return e.distance-t.distance}function Ql(e,t,r,n){if(e.layers.test(t.layers)&&e.raycast(t,r),!0===n)for(var a=e.children,o=0,i=a.length;o<i;o++)Ql(a[o],t,r,!0)}Object.assign(Gl.prototype,{getValue:function(e,t){this.bind();var r=this._targetGroup.nCachedObjects_,n=this._bindings[r];void 0!==n&&n.getValue(e,t)},setValue:function(e,t){for(var r=this._bindings,n=this._targetGroup.nCachedObjects_,a=r.length;n!==a;++n)r[n].setValue(e,t)},bind:function(){for(var e=this._bindings,t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].bind()},unbind:function(){for(var e=this._bindings,t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].unbind()}}),Object.assign(Bl,{Composite:Gl,create:function(e,t,r){return e&&e.isAnimationObjectGroup?new Bl.Composite(e,t,r):new Bl(e,t,r)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(zl,"")},parseTrackName:function(e){var t=Ol.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);var r={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},n=r.nodeName&&r.nodeName.lastIndexOf(".");if(void 0!==n&&-1!==n){var a=r.nodeName.substring(n+1);-1!==Ul.indexOf(a)&&(r.nodeName=r.nodeName.substring(0,n),r.objectName=a)}if(null===r.propertyName||0===r.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r},findNode:function(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){var r=e.skeleton.getBoneByName(t);if(void 0!==r)return r}if(e.children){var n=function(e){for(var r=0;r<e.length;r++){var a=e[r];if(a.name===t||a.uuid===t)return a;var o=n(a.children);if(o)return o}return null},a=n(e.children);if(a)return a}return null}}),Object.assign(Bl.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(e,t){e[t]=this.node[this.propertyName]},function(e,t){for(var r=this.resolvedProperty,n=0,a=r.length;n!==a;++n)e[t++]=r[n]},function(e,t){e[t]=this.resolvedProperty[this.propertyIndex]},function(e,t){this.resolvedProperty.toArray(e,t)}],SetterByBindingTypeAndVersioning:[[function(e,t){this.targetObject[this.propertyName]=e[t]},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){for(var r=this.resolvedProperty,n=0,a=r.length;n!==a;++n)r[n]=e[t++]},function(e,t){for(var r=this.resolvedProperty,n=0,a=r.length;n!==a;++n)r[n]=e[t++];this.targetObject.needsUpdate=!0},function(e,t){for(var r=this.resolvedProperty,n=0,a=r.length;n!==a;++n)r[n]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty[this.propertyIndex]=e[t]},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(e,t){this.resolvedProperty.fromArray(e,t)},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0},function(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(e,t){this.bind(),this.getValue(e,t)},setValue:function(e,t){this.bind(),this.setValue(e,t)},bind:function(){var e=this.node,t=this.parsedPath,r=t.objectName,n=t.propertyName,a=t.propertyIndex;if(e||(e=Bl.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,e){if(r){var o=t.objectIndex;switch(r){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(var i=0;i<e.length;i++)if(e[i].name===o){o=i;break}break;default:if(void 0===e[r])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[r]}if(void 0!==o){if(void 0===e[o])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[o]}}var s=e[n];if(void 0!==s){var l=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?l=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(l=this.Versioning.MatrixWorldNeedsUpdate);var c=this.BindingType.Direct;if(void 0!==a){if("morphTargetInfluences"===n){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[a]&&(a=e.morphTargetDictionary[a])}c=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=a}else void 0!==s.fromArray&&void 0!==s.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(c=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=n;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][l]}else{var f=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+f+"."+n+" but it wasn't found.",e)}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}),Object.assign(Bl.prototype,{_getValue_unbound:Bl.prototype.getValue,_setValue_unbound:Bl.prototype.setValue}),Object.assign(Vl.prototype,{isAnimationObjectGroup:!0,add:function(){for(var e=this._objects,t=this._indicesByUUID,r=this._paths,n=this._parsedPaths,a=this._bindings,o=a.length,i=void 0,s=e.length,l=this.nCachedObjects_,c=0,f=arguments.length;c!==f;++c){var d=arguments[c],u=d.uuid,p=t[u];if(void 0===p){p=s++,t[u]=p,e.push(d);for(var h=0,v=o;h!==v;++h)a[h].push(new Bl(d,r[h],n[h]))}else if(p<l){i=e[p];var m=--l,x=e[m];t[x.uuid]=p,e[p]=x,t[u]=m,e[m]=d;for(var g=0,y=o;g!==y;++g){var E=a[g],w=E[m],b=E[p];E[p]=w,void 0===b&&(b=new Bl(d,r[g],n[g])),E[m]=b}}else e[p]!==i&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){for(var e=this._objects,t=this._indicesByUUID,r=this._bindings,n=r.length,a=this.nCachedObjects_,o=0,i=arguments.length;o!==i;++o){var s=arguments[o],l=s.uuid,c=t[l];if(void 0!==c&&c>=a){var f=a++,d=e[f];t[d.uuid]=c,e[c]=d,t[l]=f,e[f]=s;for(var u=0,p=n;u!==p;++u){var h=r[u],v=h[f],m=h[c];h[c]=v,h[f]=m}}}this.nCachedObjects_=a},uncache:function(){for(var e=this._objects,t=this._indicesByUUID,r=this._bindings,n=r.length,a=this.nCachedObjects_,o=e.length,i=0,s=arguments.length;i!==s;++i){var l=arguments[i],c=l.uuid,f=t[c];if(void 0!==f)if(delete t[c],f<a){var d=--a,u=e[d],p=--o,h=e[p];t[u.uuid]=f,e[f]=u,t[h.uuid]=d,e[d]=h,e.pop();for(var v=0,m=n;v!==m;++v){var x=r[v],g=x[d],y=x[p];x[f]=g,x[d]=y,x.pop()}}else{var E=--o,w=e[E];t[w.uuid]=f,e[f]=w,e.pop();for(var b=0,T=n;b!==T;++b){var _=r[b];_[f]=_[E],_.pop()}}}this.nCachedObjects_=a},subscribe_:function(e,t){var r=this._bindingsIndicesByPath,n=r[e],a=this._bindings;if(void 0!==n)return a[n];var o=this._paths,i=this._parsedPaths,s=this._objects,l=s.length,c=this.nCachedObjects_,f=new Array(l);n=a.length,r[e]=n,o.push(e),i.push(t),a.push(f);for(var d=c,u=s.length;d!==u;++d){var p=s[d];f[d]=new Bl(p,e,t)}return f},unsubscribe_:function(e){var t=this._bindingsIndicesByPath,r=t[e];if(void 0!==r){var n=this._paths,a=this._parsedPaths,o=this._bindings,i=o.length-1,s=o[i];t[e[i]]=r,o[r]=s,o.pop(),a[r]=a[i],a.pop(),n[r]=n[i],n.pop()}}}),Object.assign(jl.prototype,{play:function(){return this._mixer._activateAction(this),this},stop:function(){return this._mixer._deactivateAction(this),this.reset()},reset:function(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},startAt:function(e){return this._startTime=e,this},setLoop:function(e,t){return this.loop=e,this.repetitions=t,this},setEffectiveWeight:function(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(e){return this._scheduleFading(e,0,1)},fadeOut:function(e){return this._scheduleFading(e,1,0)},crossFadeFrom:function(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){var n=this._clip.duration,a=e._clip.duration,o=a/n,i=n/a;e.warp(1,o,t),this.warp(i,1,t)}return this},crossFadeTo:function(e,t,r){return e.crossFadeFrom(this,t,r)},stopFading:function(){var e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},setEffectiveTimeScale:function(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(e){return this.timeScale=this._clip.duration/e,this.stopWarping()},syncWith:function(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()},halt:function(e){return this.warp(this._effectiveTimeScale,0,e)},warp:function(e,t,r){var n=this._mixer,a=n.time,o=this.timeScale,i=this._timeScaleInterpolant;null===i&&(i=n._lendControlInterpolant(),this._timeScaleInterpolant=i);var s=i.parameterPositions,l=i.sampleValues;return s[0]=a,s[1]=a+r,l[0]=e/o,l[1]=t/o,this},stopWarping:function(){var e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(e,t,r,n){if(this.enabled){var a=this._startTime;if(null!==a){var o=(e-a)*r;if(o<0||0===r)return;this._startTime=null,t=r*o}t*=this._updateTimeScale(e);var i=this._updateTime(t),s=this._updateWeight(e);if(s>0){var l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case 2501:for(var f=0,d=l.length;f!==d;++f)l[f].evaluate(i),c[f].accumulateAdditive(s);break;case 2500:default:for(var u=0,p=l.length;u!==p;++u)l[u].evaluate(i),c[u].accumulate(n,s)}}}else this._updateWeight(e)},_updateWeight:function(e){var t=0;if(this.enabled){t=this.weight;var r=this._weightInterpolant;if(null!==r){var n=r.evaluate(e)[0];t*=n,e>r.parameterPositions[1]&&(this.stopFading(),0===n&&(this.enabled=!1))}}return this._effectiveWeight=t,t},_updateTimeScale:function(e){var t=0;if(!this.paused){t=this.timeScale;var r=this._timeScaleInterpolant;null!==r&&(t*=r.evaluate(e)[0],e>r.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t},_updateTime:function(e){var t=this._clip.duration,r=this.loop,n=this.time+e,a=this._loopCount,o=2202===r;if(0===e)return-1===a?n:o&&1==(1&a)?t-n:n;if(2200===r){-1===a&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(n>=t)n=t;else{if(!(n<0)){this.time=n;break e}n=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===a&&(e>=0?(a=0,this._setEndings(!0,0===this.repetitions,o)):this._setEndings(0===this.repetitions,!0,o)),n>=t||n<0){var i=Math.floor(n/t);n-=t*i,a+=Math.abs(i);var s=this.repetitions-a;if(s<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,n=e>0?t:0,this.time=n,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===s){var l=e<0;this._setEndings(l,!l,o)}else this._setEndings(!1,!1,o);this._loopCount=a,this.time=n,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=n;if(o&&1==(1&a))return t-n}return n},_setEndings:function(e,t,r){var n=this._interpolantSettings;r?(n.endingStart=2401,n.endingEnd=2401):(n.endingStart=e?this.zeroSlopeAtStart?2401:2400:2402,n.endingEnd=t?this.zeroSlopeAtEnd?2401:2400:2402)},_scheduleFading:function(e,t,r){var n=this._mixer,a=n.time,o=this._weightInterpolant;null===o&&(o=n._lendControlInterpolant(),this._weightInterpolant=o);var i=o.parameterPositions,s=o.sampleValues;return i[0]=a,s[0]=t,i[1]=a+e,s[1]=r,this}}),Wl.prototype=Object.assign(Object.create(t.prototype),{constructor:Wl,_bindAction:function(e,t){var r=e._localRoot||this._root,n=e._clip.tracks,a=n.length,o=e._propertyBindings,i=e._interpolants,s=r.uuid,l=this._bindingsByRootAndName,c=l[s];void 0===c&&(c={},l[s]=c);for(var f=0;f!==a;++f){var d=n[f],u=d.name,p=c[u];if(void 0!==p)o[f]=p;else{if(void 0!==(p=o[f])){null===p._cacheIndex&&(++p.referenceCount,this._addInactiveBinding(p,s,u));continue}var h=t&&t._propertyBindings[f].binding.parsedPath;++(p=new Pl(Bl.create(r,u,h),d.ValueTypeName,d.getValueSize())).referenceCount,this._addInactiveBinding(p,s,u),o[f]=p}i[f].resultBuffer=p.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){var t=(e._localRoot||this._root).uuid,r=e._clip.uuid,n=this._actionsByClip[r];this._bindAction(e,n&&n.knownActions[0]),this._addInactiveAction(e,r,t)}for(var a=e._propertyBindings,o=0,i=a.length;o!==i;++o){var s=a[o];0==s.useCount++&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){for(var t=e._propertyBindings,r=0,n=t.length;r!==n;++r){var a=t[r];0==--a.useCount&&(a.restoreOriginalState(),this._takeBackBinding(a))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;var e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){var t=e._cacheIndex;return null!==t&&t<this._nActiveActions},_addInactiveAction:function(e,t,r){var n=this._actions,a=this._actionsByClip,o=a[t];if(void 0===o)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,a[t]=o;else{var i=o.knownActions;e._byClipCacheIndex=i.length,i.push(e)}e._cacheIndex=n.length,n.push(e),o.actionByRoot[r]=e},_removeInactiveAction:function(e){var t=this._actions,r=t[t.length-1],n=e._cacheIndex;r._cacheIndex=n,t[n]=r,t.pop(),e._cacheIndex=null;var a=e._clip.uuid,o=this._actionsByClip,i=o[a],s=i.knownActions,l=s[s.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c,s[c]=l,s.pop(),e._byClipCacheIndex=null,delete i.actionByRoot[(e._localRoot||this._root).uuid],0===s.length&&delete o[a],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){for(var t=e._propertyBindings,r=0,n=t.length;r!==n;++r){var a=t[r];0==--a.referenceCount&&this._removeInactiveBinding(a)}},_lendAction:function(e){var t=this._actions,r=e._cacheIndex,n=this._nActiveActions++,a=t[n];e._cacheIndex=n,t[n]=e,a._cacheIndex=r,t[r]=a},_takeBackAction:function(e){var t=this._actions,r=e._cacheIndex,n=--this._nActiveActions,a=t[n];e._cacheIndex=n,t[n]=e,a._cacheIndex=r,t[r]=a},_addInactiveBinding:function(e,t,r){var n=this._bindingsByRootAndName,a=this._bindings,o=n[t];void 0===o&&(o={},n[t]=o),o[r]=e,e._cacheIndex=a.length,a.push(e)},_removeInactiveBinding:function(e){var t=this._bindings,r=e.binding,n=r.rootNode.uuid,a=r.path,o=this._bindingsByRootAndName,i=o[n],s=t[t.length-1],l=e._cacheIndex;s._cacheIndex=l,t[l]=s,t.pop(),delete i[a],0===Object.keys(i).length&&delete o[n]},_lendBinding:function(e){var t=this._bindings,r=e._cacheIndex,n=this._nActiveBindings++,a=t[n];e._cacheIndex=n,t[n]=e,a._cacheIndex=r,t[r]=a},_takeBackBinding:function(e){var t=this._bindings,r=e._cacheIndex,n=--this._nActiveBindings,a=t[n];e._cacheIndex=n,t[n]=e,a._cacheIndex=r,t[r]=a},_lendControlInterpolant:function(){var e=this._controlInterpolants,t=this._nActiveControlInterpolants++,r=e[t];return void 0===r&&((r=new Vi(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=t,e[t]=r),r},_takeBackControlInterpolant:function(e){var t=this._controlInterpolants,r=e.__cacheIndex,n=--this._nActiveControlInterpolants,a=t[n];e.__cacheIndex=n,t[n]=e,a.__cacheIndex=r,t[r]=a},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,r){var n=t||this._root,a=n.uuid,o="string"==typeof e?$i.findByName(n,e):e,i=null!==o?o.uuid:e,s=this._actionsByClip[i],l=null;if(void 0===r&&(r=null!==o?o.blendMode:2500),void 0!==s){var c=s.actionByRoot[a];if(void 0!==c&&c.blendMode===r)return c;l=s.knownActions[0],null===o&&(o=l._clip)}if(null===o)return null;var f=new jl(this,o,t,r);return this._bindAction(f,l),this._addInactiveAction(f,i,a),f},existingAction:function(e,t){var r=t||this._root,n=r.uuid,a="string"==typeof e?$i.findByName(r,e):e,o=a?a.uuid:e,i=this._actionsByClip[o];return void 0!==i&&i.actionByRoot[n]||null},stopAllAction:function(){for(var e=this._actions,t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this},update:function(e){e*=this.timeScale;for(var t=this._actions,r=this._nActiveActions,n=this.time+=e,a=Math.sign(e),o=this._accuIndex^=1,i=0;i!==r;++i)t[i]._update(n,e,a,o);for(var s=this._bindings,l=this._nActiveBindings,c=0;c!==l;++c)s[c].apply(o);return this},setTime:function(e){this.time=0;for(var t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){var t=this._actions,r=e.uuid,n=this._actionsByClip,a=n[r];if(void 0!==a){for(var o=a.knownActions,i=0,s=o.length;i!==s;++i){var l=o[i];this._deactivateAction(l);var c=l._cacheIndex,f=t[t.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,f._cacheIndex=c,t[c]=f,t.pop(),this._removeInactiveBindingsForAction(l)}delete n[r]}},uncacheRoot:function(e){var t=e.uuid,r=this._actionsByClip;for(var n in r){var a=r[n].actionByRoot[t];void 0!==a&&(this._deactivateAction(a),this._removeInactiveAction(a))}var o=this._bindingsByRootAndName[t];if(void 0!==o)for(var i in o){var s=o[i];s.restoreOriginalState(),this._removeInactiveBinding(s)}},uncacheAction:function(e,t){var r=this.existingAction(e,t);null!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}}),ql.prototype.clone=function(){return new ql(void 0===this.value.clone?this.value:this.value.clone())},Xl.prototype=Object.assign(Object.create(sa.prototype),{constructor:Xl,isInstancedInterleavedBuffer:!0,copy:function(e){return sa.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){var t=sa.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){var t=sa.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}),Object.assign(Yl.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type.")},intersectObject:function(e,t,r){var n=r||[];return Ql(e,this,n,t),n.sort(Zl),n},intersectObjects:function(e,t,r){var n=r||[];if(!1===Array.isArray(e))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),n;for(var a=0,o=e.length;a<o;a++)Ql(e[a],this,n,t);return n.sort(Zl),n}});var Kl=function(e,t,r){return void 0===e&&(e=1),void 0===t&&(t=0),void 0===r&&(r=0),this.radius=e,this.phi=t,this.theta=r,this};function Jl(e,t,r){return this.radius=void 0!==e?e:1,this.theta=void 0!==t?t:0,this.y=void 0!==r?r:0,this}Kl.prototype.set=function(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this},Kl.prototype.clone=function(){return(new this.constructor).copy(this)},Kl.prototype.copy=function(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this},Kl.prototype.makeSafe=function(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this},Kl.prototype.setFromVector3=function(e){return this.setFromCartesianCoords(e.x,e.y,e.z)},Kl.prototype.setFromCartesianCoords=function(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(i.clamp(t/this.radius,-1,1))),this},Object.assign(Jl.prototype,{set:function(e,t,r){return this.radius=e,this.theta=t,this.y=r,this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this},setFromVector3:function(e){return this.setFromCartesianCoords(e.x,e.y,e.z)},setFromCartesianCoords:function(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}});var $l=new s;function ec(e,t){this.min=void 0!==e?e:new s(1/0,1/0),this.max=void 0!==t?t:new s(-1/0,-1/0)}Object.assign(ec.prototype,{set:function(e,t){return this.min.copy(e),this.max.copy(t),this},setFromPoints:function(e){this.makeEmpty();for(var t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this},setFromCenterAndSize:function(e,t){var r=$l.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.min.copy(e.min),this.max.copy(e.max),this},makeEmpty:function(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},getCenter:function(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new s),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)},getSize:function(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new s),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)},expandByPoint:function(e){return this.min.min(e),this.max.max(e),this},expandByVector:function(e){return this.min.sub(e),this.max.add(e),this},expandByScalar:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this},containsPoint:function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)},containsBox:function(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y},getParameter:function(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new s),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)},clampPoint:function(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new s),t.copy(e).clamp(this.min,this.max)},distanceToPoint:function(e){return $l.copy(e).clamp(this.min,this.max).sub(e).length()},intersect:function(e){return this.min.max(e.min),this.max.min(e.max),this},union:function(e){return this.min.min(e.min),this.max.max(e.max),this},translate:function(e){return this.min.add(e),this.max.add(e),this},equals:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}});var tc=new g,rc=new g;function nc(e,t){this.start=void 0!==e?e:new g,this.end=void 0!==t?t:new g}function ac(e){j.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Object.assign(nc.prototype,{set:function(e,t){return this.start.copy(e),this.end.copy(t),this},clone:function(){return(new this.constructor).copy(this)},copy:function(e){return this.start.copy(e.start),this.end.copy(e.end),this},getCenter:function(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new g),e.addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new g),e.subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new g),this.delta(t).multiplyScalar(e).add(this.start)},closestPointToPointParameter:function(e,t){tc.subVectors(e,this.start),rc.subVectors(this.end,this.start);var r=rc.dot(rc),n=rc.dot(tc)/r;return t&&(n=i.clamp(n,0,1)),n},closestPointToPoint:function(e,t,r){var n=this.closestPointToPointParameter(e,t);return void 0===r&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),r=new g),this.delta(r).multiplyScalar(n).add(this.start)},applyMatrix4:function(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this},equals:function(e){return e.start.equals(this.start)&&e.end.equals(this.end)}}),ac.prototype=Object.create(j.prototype),ac.prototype.constructor=ac,ac.prototype.isImmediateRenderObject=!0;var oc=new g;function ic(e,t){j.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;for(var r=new ft,n=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],a=0,o=1;a<32;a++,o++){var i=a/32*Math.PI*2,s=o/32*Math.PI*2;n.push(Math.cos(i),Math.sin(i),1,Math.cos(s),Math.sin(s),1)}r.setAttribute("position",new $e(n,3));var l=new ja({fog:!1,toneMapped:!1});this.cone=new $a(r,l),this.add(this.cone),this.update()}ic.prototype=Object.create(j.prototype),ic.prototype.constructor=ic,ic.prototype.dispose=function(){this.cone.geometry.dispose(),this.cone.material.dispose()},ic.prototype.update=function(){this.light.updateMatrixWorld();var e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),oc.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(oc),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)};var sc=new g,lc=new R,cc=new R;function fc(e){for(var t=function e(t){var r=[];t&&t.isBone&&r.push(t);for(var n=0;n<t.children.length;n++)r.push.apply(r,e(t.children[n]));return r}(e),r=new ft,n=[],a=[],o=new Ne(0,0,1),i=new Ne(0,1,0),s=0;s<t.length;s++){var l=t[s];l.parent&&l.parent.isBone&&(n.push(0,0,0),n.push(0,0,0),a.push(o.r,o.g,o.b),a.push(i.r,i.g,i.b))}r.setAttribute("position",new $e(n,3)),r.setAttribute("color",new $e(a,3));var c=new ja({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});$a.call(this,r,c),this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}function dc(e,t,r){this.light=e,this.light.updateMatrixWorld(),this.color=r;var n=new pi(t,4,2),a=new Be({wireframe:!0,fog:!1,toneMapped:!1});Mt.call(this,n,a),this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}fc.prototype=Object.create($a.prototype),fc.prototype.constructor=fc,fc.prototype.isSkeletonHelper=!0,fc.prototype.updateMatrixWorld=function(e){var t=this.bones,r=this.geometry,n=r.getAttribute("position");cc.getInverse(this.root.matrixWorld);for(var a=0,o=0;a<t.length;a++){var i=t[a];i.parent&&i.parent.isBone&&(lc.multiplyMatrices(cc,i.matrixWorld),sc.setFromMatrixPosition(lc),n.setXYZ(o,sc.x,sc.y,sc.z),lc.multiplyMatrices(cc,i.parent.matrixWorld),sc.setFromMatrixPosition(lc),n.setXYZ(o+1,sc.x,sc.y,sc.z),o+=2)}r.getAttribute("position").needsUpdate=!0,j.prototype.updateMatrixWorld.call(this,e)},dc.prototype=Object.create(Mt.prototype),dc.prototype.constructor=dc,dc.prototype.dispose=function(){this.geometry.dispose(),this.material.dispose()},dc.prototype.update=function(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)};var uc=new g,pc=new Ne,hc=new Ne;function vc(e,t,r){j.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r;var n=new wo(t);n.rotateY(.5*Math.PI),this.material=new Be({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);var a=n.getAttribute("position"),o=new Float32Array(3*a.count);n.setAttribute("color",new We(o,3)),this.add(new Mt(n,this.material)),this.update()}function mc(e,t,r,n){e=e||10,t=t||10,r=new Ne(void 0!==r?r:4473924),n=new Ne(void 0!==n?n:8947848);for(var a=t/2,o=e/t,i=e/2,s=[],l=[],c=0,f=0,d=-i;c<=t;c++,d+=o){s.push(-i,0,d,i,0,d),s.push(d,0,-i,d,0,i);var u=c===a?r:n;u.toArray(l,f),f+=3,u.toArray(l,f),f+=3,u.toArray(l,f),f+=3,u.toArray(l,f),f+=3}var p=new ft;p.setAttribute("position",new $e(s,3)),p.setAttribute("color",new $e(l,3));var h=new ja({vertexColors:!0,toneMapped:!1});$a.call(this,p,h),this.type="GridHelper"}function xc(e,t,r,n,a,o){e=e||10,t=t||16,r=r||8,n=n||64,a=new Ne(void 0!==a?a:4473924),o=new Ne(void 0!==o?o:8947848);for(var i=[],s=[],l=0;l<=t;l++){var c=l/t*(2*Math.PI),f=Math.sin(c)*e,d=Math.cos(c)*e;i.push(0,0,0),i.push(f,0,d);var u=1&l?a:o;s.push(u.r,u.g,u.b),s.push(u.r,u.g,u.b)}for(var p=0;p<=r;p++)for(var h=1&p?a:o,v=e-e/r*p,m=0;m<n;m++){var x=m/n*(2*Math.PI),g=Math.sin(x)*v,y=Math.cos(x)*v;i.push(g,0,y),s.push(h.r,h.g,h.b),x=(m+1)/n*(2*Math.PI),g=Math.sin(x)*v,y=Math.cos(x)*v,i.push(g,0,y),s.push(h.r,h.g,h.b)}var E=new ft;E.setAttribute("position",new $e(i,3)),E.setAttribute("color",new $e(s,3));var w=new ja({vertexColors:!0,toneMapped:!1});$a.call(this,E,w),this.type="PolarGridHelper"}vc.prototype=Object.create(j.prototype),vc.prototype.constructor=vc,vc.prototype.dispose=function(){this.children[0].geometry.dispose(),this.children[0].material.dispose()},vc.prototype.update=function(){var e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{var t=e.geometry.getAttribute("color");pc.copy(this.light.color),hc.copy(this.light.groundColor);for(var r=0,n=t.count;r<n;r++){var a=r<n/2?pc:hc;t.setXYZ(r,a.r,a.g,a.b)}t.needsUpdate=!0}e.lookAt(uc.setFromMatrixPosition(this.light.matrixWorld).negate())},mc.prototype=Object.create($a.prototype),mc.prototype.constructor=mc,xc.prototype=Object.create($a.prototype),xc.prototype.constructor=xc;var gc=new g,yc=new g,Ec=new g;function wc(e,t,r){j.call(this),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,void 0===t&&(t=1);var n=new ft;n.setAttribute("position",new $e([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));var a=new ja({fog:!1,toneMapped:!1});this.lightPlane=new Qa(n,a),this.add(this.lightPlane),(n=new ft).setAttribute("position",new $e([0,0,0,0,0,1],3)),this.targetLine=new Qa(n,a),this.add(this.targetLine),this.update()}wc.prototype=Object.create(j.prototype),wc.prototype.constructor=wc,wc.prototype.dispose=function(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()},wc.prototype.update=function(){gc.setFromMatrixPosition(this.light.matrixWorld),yc.setFromMatrixPosition(this.light.target.matrixWorld),Ec.subVectors(yc,gc),this.lightPlane.lookAt(yc),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(yc),this.targetLine.scale.z=Ec.length()};var bc=new g,Tc=new Bt;function _c(e){var t=new ft,r=new ja({color:16777215,vertexColors:!0,toneMapped:!1}),n=[],a=[],o={},i=new Ne(16755200),s=new Ne(16711680),l=new Ne(43775),c=new Ne(16777215),f=new Ne(3355443);function d(e,t,r){u(e,r),u(t,r)}function u(e,t){n.push(0,0,0),a.push(t.r,t.g,t.b),void 0===o[e]&&(o[e]=[]),o[e].push(n.length/3-1)}d("n1","n2",i),d("n2","n4",i),d("n4","n3",i),d("n3","n1",i),d("f1","f2",i),d("f2","f4",i),d("f4","f3",i),d("f3","f1",i),d("n1","f1",i),d("n2","f2",i),d("n3","f3",i),d("n4","f4",i),d("p","n1",s),d("p","n2",s),d("p","n3",s),d("p","n4",s),d("u1","u2",l),d("u2","u3",l),d("u3","u1",l),d("c","t",c),d("p","c",f),d("cn1","cn2",f),d("cn3","cn4",f),d("cf1","cf2",f),d("cf3","cf4",f),t.setAttribute("position",new $e(n,3)),t.setAttribute("color",new $e(a,3)),$a.call(this,t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update()}function Sc(e,t,r,n,a,o,i){bc.set(a,o,i).unproject(n);var s=t[e];if(void 0!==s)for(var l=r.getAttribute("position"),c=0,f=s.length;c<f;c++)l.setXYZ(s[c],bc.x,bc.y,bc.z)}_c.prototype=Object.create($a.prototype),_c.prototype.constructor=_c,_c.prototype.update=function(){var e=this.geometry,t=this.pointMap;Tc.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Sc("c",t,e,Tc,0,0,-1),Sc("t",t,e,Tc,0,0,1),Sc("n1",t,e,Tc,-1,-1,-1),Sc("n2",t,e,Tc,1,-1,-1),Sc("n3",t,e,Tc,-1,1,-1),Sc("n4",t,e,Tc,1,1,-1),Sc("f1",t,e,Tc,-1,-1,1),Sc("f2",t,e,Tc,1,-1,1),Sc("f3",t,e,Tc,-1,1,1),Sc("f4",t,e,Tc,1,1,1),Sc("u1",t,e,Tc,.7,1.1,-1),Sc("u2",t,e,Tc,-.7,1.1,-1),Sc("u3",t,e,Tc,0,2,-1),Sc("cf1",t,e,Tc,-1,0,1),Sc("cf2",t,e,Tc,1,0,1),Sc("cf3",t,e,Tc,0,-1,1),Sc("cf4",t,e,Tc,0,1,1),Sc("cn1",t,e,Tc,-1,0,-1),Sc("cn2",t,e,Tc,1,0,-1),Sc("cn3",t,e,Tc,0,-1,-1),Sc("cn4",t,e,Tc,0,1,-1),e.getAttribute("position").needsUpdate=!0};var Rc=new oe;function Ac(e,t){this.object=e,void 0===t&&(t=16776960);var r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),a=new ft;a.setIndex(new We(r,1)),a.setAttribute("position",new We(n,3)),$a.call(this,a,new ja({color:t,toneMapped:!1})),this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}function Mc(e,t){this.type="Box3Helper",this.box=e,void 0===t&&(t=16776960);var r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new ft;n.setIndex(new We(r,1)),n.setAttribute("position",new $e([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),$a.call(this,n,new ja({color:t,toneMapped:!1})),this.type="Box3Helper",this.geometry.computeBoundingSphere()}function Cc(e,t,r){this.plane=e,this.size=void 0===t?1:t;var n=void 0!==r?r:16776960,a=new ft;a.setAttribute("position",new $e([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),a.computeBoundingSphere(),Qa.call(this,a,new ja({color:n,toneMapped:!1})),this.type="PlaneHelper";var o=new ft;o.setAttribute("position",new $e([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),o.computeBoundingSphere(),this.add(new Mt(o,new Be({color:n,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}Ac.prototype=Object.create($a.prototype),Ac.prototype.constructor=Ac,Ac.prototype.update=function(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Rc.setFromObject(this.object),!Rc.isEmpty()){var t=Rc.min,r=Rc.max,n=this.geometry.attributes.position,a=n.array;a[0]=r.x,a[1]=r.y,a[2]=r.z,a[3]=t.x,a[4]=r.y,a[5]=r.z,a[6]=t.x,a[7]=t.y,a[8]=r.z,a[9]=r.x,a[10]=t.y,a[11]=r.z,a[12]=r.x,a[13]=r.y,a[14]=t.z,a[15]=t.x,a[16]=r.y,a[17]=t.z,a[18]=t.x,a[19]=t.y,a[20]=t.z,a[21]=r.x,a[22]=t.y,a[23]=t.z,n.needsUpdate=!0,this.geometry.computeBoundingSphere()}},Ac.prototype.setFromObject=function(e){return this.object=e,this.update(),this},Ac.prototype.copy=function(e){return $a.prototype.copy.call(this,e),this.object=e.object,this},Mc.prototype=Object.create($a.prototype),Mc.prototype.constructor=Mc,Mc.prototype.updateMatrixWorld=function(e){var t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),j.prototype.updateMatrixWorld.call(this,e))},Cc.prototype=Object.create(Qa.prototype),Cc.prototype.constructor=Cc,Cc.prototype.updateMatrixWorld=function(e){var t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?1:0,this.lookAt(this.plane.normal),j.prototype.updateMatrixWorld.call(this,e)};var Lc,Hc,Pc=new g;function zc(e,t,r,n,a,o){j.call(this),this.type="ArrowHelper",void 0===e&&(e=new g(0,0,1)),void 0===t&&(t=new g(0,0,0)),void 0===r&&(r=1),void 0===n&&(n=16776960),void 0===a&&(a=.2*r),void 0===o&&(o=.2*a),void 0===Lc&&((Lc=new ft).setAttribute("position",new $e([0,0,0,0,1,0],3)),(Hc=new Ti(0,.5,1,5,1)).translate(0,-.5,0)),this.position.copy(t),this.line=new Qa(Lc,new ja({color:n,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mt(Hc,new Be({color:n,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,a,o)}function kc(e){var t=[0,0,0,e=e||1,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=new ft;r.setAttribute("position",new $e(t,3)),r.setAttribute("color",new $e([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));var n=new ja({vertexColors:!0,toneMapped:!1});$a.call(this,r,n),this.type="AxesHelper"}zc.prototype=Object.create(j.prototype),zc.prototype.constructor=zc,zc.prototype.setDirection=function(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Pc.set(e.z,0,-e.x).normalize();var t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Pc,t)}},zc.prototype.setLength=function(e,t,r){void 0===t&&(t=.2*e),void 0===r&&(r=.2*t),this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()},zc.prototype.setColor=function(e){this.line.material.color.set(e),this.cone.material.color.set(e)},zc.prototype.copy=function(e){return j.prototype.copy.call(this,e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this},kc.prototype=Object.create($a.prototype),kc.prototype.constructor=kc;var Nc=Math.pow(2,8),Dc=[.125,.215,.35,.446,.526,.582],Fc=5+Dc.length,Ic={3e3:0,3001:1,3002:2,3004:3,3005:4,3006:5,3007:6},Oc=new Vs,Uc=function(){for(var e=[],t=[],r=[],n=8,a=0;a<Fc;a++){var o=Math.pow(2,n);t.push(o);var i=1/o;a>4?i=Dc[a-8+4-1]:0==a&&(i=0),r.push(i);for(var s=1/(o-1),l=-s/2,c=1+s/2,f=[l,l,c,l,c,c,l,l,c,c,l,c],d=new Float32Array(108),u=new Float32Array(72),p=new Float32Array(36),h=0;h<6;h++){var v=h%3*2/3-1,m=h>2?0:-1,x=[v,m,0,v+2/3,m,0,v+2/3,m+1,0,v,m,0,v+2/3,m+1,0,v,m+1,0];d.set(x,18*h),u.set(f,12*h);var g=[h,h,h,h,h,h];p.set(g,6*h)}var y=new ft;y.setAttribute("position",new We(d,3)),y.setAttribute("uv",new We(u,2)),y.setAttribute("faceIndex",new We(p,1)),e.push(y),n>4&&n--}return{_lodPlanes:e,_sizeLods:t,_sigmas:r}}(),Gc=Uc._lodPlanes,Bc=Uc._sizeLods,Vc=Uc._sigmas,jc=null,Wc=(1+Math.sqrt(5))/2,qc=1/Wc,Xc=[new g(1,1,1),new g(-1,1,1),new g(1,1,-1),new g(-1,1,-1),new g(0,Wc,qc),new g(0,Wc,-qc),new g(qc,0,Wc),new g(-qc,0,Wc),new g(Wc,qc,0),new g(-Wc,qc,0)];function Yc(e){var t,r,n;this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=(t=20,r=new Float32Array(t),n=new g(0,1,0),new Li({name:"SphericalGaussianBlur",defines:{n:t},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:Ic[3e3]},outputEncoding:{value:Ic[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}function Zc(e){return void 0!==e&&1009===e.type&&(3e3===e.encoding||3001===e.encoding||3007===e.encoding)}function Qc(e){var t=new p(3*Nc,3*Nc,e);return t.texture.mapping=306,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Kc(e,t,r,n,a){e.viewport.set(t,r,n,a),e.scissor.set(t,r,n,a)}function Jc(){return new Li({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:new s(1,1)},inputEncoding:{value:Ic[3e3]},outputEncoding:{value:Ic[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function $c(){return new Li({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Ic[3e3]},outputEncoding:{value:Ic[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})}function ef(e){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),ws.call(this,e),this.type="catmullrom",this.closed=!0}function tf(e){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),ws.call(this,e),this.type="catmullrom"}function rf(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),ws.call(this,e),this.type="catmullrom"}Yc.prototype={constructor:Yc,fromScene:function(e,t,r,n){void 0===t&&(t=0),void 0===r&&(r=.1),void 0===n&&(n=100),jc=this._renderer.getRenderTarget();var a=this._allocateTargets();return this._sceneToCubeUV(e,r,n,a),t>0&&this._blur(a,0,0,t),this._applyPMREM(a),this._cleanup(a),a},fromEquirectangular:function(e){return this._fromTexture(e)},fromCubemap:function(e){return this._fromTexture(e)},compileCubemapShader:function(){null===this._cubemapShader&&(this._cubemapShader=$c(),this._compileMaterial(this._cubemapShader))},compileEquirectangularShader:function(){null===this._equirectShader&&(this._equirectShader=Jc(),this._compileMaterial(this._equirectShader))},dispose:function(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(var e=0;e<Gc.length;e++)Gc[e].dispose()},_cleanup:function(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(jc),e.scissorTest=!1,Kc(e,0,0,e.width,e.height)},_fromTexture:function(e){jc=this._renderer.getRenderTarget();var t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t},_allocateTargets:function(e){var t={magFilter:1003,minFilter:1003,generateMipmaps:!1,type:1009,format:1023,encoding:Zc(e)?e.encoding:3002,depthBuffer:!1,stencilBuffer:!1},r=Qc(t);return r.depthBuffer=!e,this._pingPongRenderTarget=Qc(t),r},_compileMaterial:function(e){var t=new Mt(Gc[0],e);this._renderer.compile(t,Oc)},_sceneToCubeUV:function(e,t,r,n){var a=new Vt(90,1,t,r),o=[1,-1,1,1,1,1],i=[1,1,1,-1,-1,-1],s=this._renderer,l=s.outputEncoding,c=s.toneMapping,f=s.getClearColor(),d=s.getClearAlpha();s.toneMapping=0,s.outputEncoding=3e3;var u=e.background;if(u&&u.isColor){u.convertSRGBToLinear();var p=Math.max(u.r,u.g,u.b),h=Math.min(Math.max(Math.ceil(Math.log2(p)),-128),127);u=u.multiplyScalar(Math.pow(2,-h));var v=(h+128)/255;s.setClearColor(u,v),e.background=null}for(var m=0;m<6;m++){var x=m%3;0==x?(a.up.set(0,o[m],0),a.lookAt(i[m],0,0)):1==x?(a.up.set(0,0,o[m]),a.lookAt(0,i[m],0)):(a.up.set(0,o[m],0),a.lookAt(0,0,i[m])),Kc(n,x*Nc,m>2?Nc:0,Nc,Nc),s.setRenderTarget(n),s.render(e,a)}s.toneMapping=c,s.outputEncoding=l,s.setClearColor(f,d)},_textureToCubeUV:function(e,t){var r=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=$c()):null==this._equirectShader&&(this._equirectShader=Jc());var n=e.isCubeTexture?this._cubemapShader:this._equirectShader,a=new Mt(Gc[0],n),o=n.uniforms;o.envMap.value=e,e.isCubeTexture||o.texelSize.value.set(1/e.image.width,1/e.image.height),o.inputEncoding.value=Ic[e.encoding],o.outputEncoding.value=Ic[t.texture.encoding],Kc(t,0,0,3*Nc,2*Nc),r.setRenderTarget(t),r.render(a,Oc)},_applyPMREM:function(e){var t=this._renderer,r=t.autoClear;t.autoClear=!1;for(var n=1;n<Fc;n++){var a=Math.sqrt(Vc[n]*Vc[n]-Vc[n-1]*Vc[n-1]),o=Xc[(n-1)%Xc.length];this._blur(e,n-1,n,a,o)}t.autoClear=r},_blur:function(e,t,r,n,a){var o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,n,"latitudinal",a),this._halfBlur(o,e,r,r,n,"longitudinal",a)},_halfBlur:function(e,t,r,n,a,o,i){var s=this._renderer,l=this._blurMaterial;"latitudinal"!==o&&"longitudinal"!==o&&console.error("blur direction must be either latitudinal or longitudinal!");var c=new Mt(Gc[n],l),f=l.uniforms,d=Bc[r]-1,u=isFinite(a)?Math.PI/(2*d):2*Math.PI/39,p=a/u,h=isFinite(a)?1+Math.floor(3*p):20;h>20&&console.warn("sigmaRadians, "+a+", is too large and will clip, as it requested "+h+" samples when the maximum is set to 20");for(var v=[],m=0,x=0;x<20;++x){var g=x/p,y=Math.exp(-g*g/2);v.push(y),0==x?m+=y:x<h&&(m+=2*y)}for(var E=0;E<v.length;E++)v[E]=v[E]/m;f.envMap.value=e.texture,f.samples.value=h,f.weights.value=v,f.latitudinal.value="latitudinal"===o,i&&(f.poleAxis.value=i),f.dTheta.value=u,f.mipInt.value=8-r,f.inputEncoding.value=Ic[e.texture.encoding],f.outputEncoding.value=Ic[e.texture.encoding];var w=Bc[n];Kc(t,3*Math.max(0,Nc-2*w),(0===n?0:2*Nc)+2*w*(n>4?n-8+4:0),3*w,2*w),s.setRenderTarget(t),s.render(c,Oc)}},ps.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(ps.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},Object.assign(zs.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");var t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");for(var t=new Nt,r=0,n=e.length;r<n;r++){var a=e[r];t.vertices.push(new g(a.x,a.y,a.z||0))}return t}}),Object.assign(ks.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}}),ef.prototype=Object.create(ws.prototype),tf.prototype=Object.create(ws.prototype),rf.prototype=Object.create(ws.prototype),Object.assign(rf.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),mc.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},fc.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(as.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ks.extractUrlBase(e)}}),as.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(rl.prototype,{setTexturePath:function(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}),Object.assign(ec.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(oe.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}}),Object.assign(le.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),Zt.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},nc.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Object.assign(i,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),i.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),i.ceilPowerOfTwo(e)}}),Object.assign(l.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")}}),Object.assign(R.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new g).setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,r,n,a,o){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,n,r,a,o)}}),Ee.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},v.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},Object.assign(me.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}}),Object.assign(He.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}}),Object.assign(He,{barycoordFromPoint:function(e,t,r,n,a){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),He.getBarycoord(e,t,r,n,a)},normal:function(e,t,r,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),He.getNormal(e,t,r,n)}}),Object.assign(Ns.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new ii(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new gi(this,e)}}),Object.assign(s.prototype,{fromAttribute:function(e,t,r){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,r)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(g.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,r){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,r)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(u.prototype,{fromAttribute:function(e,t,r){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,r)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Nt.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.assign(j.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(j.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(Mt.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(Mt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(za.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(Fa.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),ka.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(ps.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}}),Vt.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(Ds.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(We.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),Object.assign(We.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?35048:35044),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(ft.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new We(arguments[1],arguments[2])))},addDrawCall:function(e,t,r){void 0!==r&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}}),Object.defineProperties(ft.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(Js.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}}),Object.defineProperties(Yl.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}}),Object.defineProperties(sa.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),35048===this.usage},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}}),Object.assign(sa.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?35048:35044),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(si.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}}),Object.defineProperties(ql.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this}}}),Object.defineProperties(Ge.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Ne}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===e}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(zi.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Pi.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}}),Object.defineProperties(Gt.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Object.assign(na.prototype,{clearTarget:function(e,t,r,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,r,n)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(na.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?3001:3e3}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(Yn.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(p.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),Object.defineProperties(Sl.prototype,{load:{value:function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");var t=this;return(new pl).load(e,(function(e){t.setBuffer(e)})),this}},startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),Hl.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},jt.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)};var nf={merge:function(e,t,r){var n;console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),t.isMesh&&(t.matrixAutoUpdate&&t.updateMatrix(),n=t.matrix,t=t.geometry),e.merge(t,n,r)},center:function(e){return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),e.center()}};c.crossOrigin=void 0,c.loadTexture=function(e,t,r,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var a=new us;a.setCrossOrigin(this.crossOrigin);var o=a.load(e,r,void 0,n);return t&&(o.mapping=t),o},c.loadTextureCube=function(e,t,r,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");var a=new ds;a.setCrossOrigin(this.crossOrigin);var o=a.load(e,r,void 0,n);return t&&(o.mapping=t),o},c.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},c.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};var af={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"119"}})),e.ACESFilmicToneMapping=4,e.AddEquation=100,e.AddOperation=2,e.AdditiveAnimationBlendMode=2501,e.AdditiveBlending=2,e.AlphaFormat=1021,e.AlwaysDepth=1,e.AlwaysStencilFunc=519,e.AmbientLight=qs,e.AmbientLightProbe=vl,e.AnimationClip=$i,e.AnimationLoader=ss,e.AnimationMixer=Wl,e.AnimationObjectGroup=Vl,e.AnimationUtils=Ui,e.ArcCurve=vs,e.ArrayCamera=Jn,e.ArrowHelper=zc,e.Audio=Sl,e.AudioAnalyser=Hl,e.AudioContext=ul,e.AudioListener=_l,e.AudioLoader=pl,e.AxesHelper=kc,e.AxisHelper=function(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new kc(e)},e.BackSide=1,e.BasicDepthPacking=3200,e.BasicShadowMap=0,e.BinaryTextureLoader=function(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new cs(e)},e.Bone=Ia,e.BooleanKeyframeTrack=qi,e.BoundingBoxHelper=function(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Ac(e,t)},e.Box2=ec,e.Box3=oe,e.Box3Helper=Mc,e.BoxBufferGeometry=Ft,e.BoxGeometry=Dt,e.BoxHelper=Ac,e.BufferAttribute=We,e.BufferGeometry=ft,e.BufferGeometryLoader=el,e.ByteType=1010,e.Cache=ts,e.Camera=Bt,e.CameraHelper=_c,e.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},e.CanvasTexture=fo,e.CatmullRomCurve3=ws,e.CineonToneMapping=3,e.CircleBufferGeometry=Ai,e.CircleGeometry=Ri,e.ClampToEdgeWrapping=1001,e.Clock=yl,e.ClosedSplineCurve3=ef,e.Color=Ne,e.ColorKeyframeTrack=Xi,e.CompressedTexture=co,e.CompressedTextureLoader=ls,e.ConeBufferGeometry=Si,e.ConeGeometry=_i,e.CubeCamera=jt,e.CubeGeometry=Dt,e.CubeReflectionMapping=301,e.CubeRefractionMapping=302,e.CubeTexture=mr,e.CubeTextureLoader=ds,e.CubeUVReflectionMapping=306,e.CubeUVRefractionMapping=307,e.CubicBezierCurve=Ss,e.CubicBezierCurve3=Rs,e.CubicInterpolant=Bi,e.CullFaceBack=1,e.CullFaceFront=2,e.CullFaceFrontBack=3,e.CullFaceNone=0,e.Curve=ps,e.CurvePath=zs,e.CustomBlending=5,e.CustomToneMapping=5,e.CylinderBufferGeometry=Ti,e.CylinderGeometry=bi,e.Cylindrical=Jl,e.DataTexture=qt,e.DataTexture2DArray=xr,e.DataTexture3D=gr,e.DataTextureLoader=cs,e.DecrementStencilOp=7683,e.DecrementWrapStencilOp=34056,e.DefaultLoadingManager=ns,e.DepthFormat=1026,e.DepthStencilFormat=1027,e.DepthTexture=uo,e.DirectionalLight=Ws,e.DirectionalLightHelper=wc,e.DirectionalLightShadow=js,e.DiscreteInterpolant=ji,e.DodecahedronBufferGeometry=So,e.DodecahedronGeometry=_o,e.DoubleSide=2,e.DstAlphaFactor=206,e.DstColorFactor=208,e.DynamicBufferAttribute=function(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new We(e,t).setUsage(35048)},e.DynamicCopyUsage=35050,e.DynamicDrawUsage=35048,e.DynamicReadUsage=35049,e.EdgesGeometry=wi,e.EdgesHelper=function(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new $a(new wi(e.geometry),new ja({color:void 0!==t?t:16777215}))},e.EllipseCurve=hs,e.EqualDepth=4,e.EqualStencilFunc=514,e.EquirectangularReflectionMapping=303,e.EquirectangularRefractionMapping=304,e.Euler=C,e.EventDispatcher=t,e.ExtrudeBufferGeometry=si,e.ExtrudeGeometry=ii,e.Face3=Oe,e.Face4=function(e,t,r,n,a,o,i){return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),new Oe(e,t,r,a,o,i)},e.FaceColors=1,e.FileLoader=is,e.FlatShading=1,e.Float32Attribute=function(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new $e(e,t)},e.Float32BufferAttribute=$e,e.Float64Attribute=function(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new et(e,t)},e.Float64BufferAttribute=et,e.FloatType=1015,e.Fog=ia,e.FogExp2=oa,e.Font=cl,e.FontLoader=dl,e.FrontSide=0,e.Frustum=Zt,e.GammaEncoding=3007,e.Geometry=Nt,e.GeometryUtils=nf,e.GreaterDepth=6,e.GreaterEqualDepth=5,e.GreaterEqualStencilFunc=518,e.GreaterStencilFunc=516,e.GridHelper=mc,e.Group=$n,e.HalfFloatType=1016,e.HemisphereLight=Fs,e.HemisphereLightHelper=vc,e.HemisphereLightProbe=hl,e.IcosahedronBufferGeometry=To,e.IcosahedronGeometry=bo,e.ImageBitmapLoader=sl,e.ImageLoader=fs,e.ImageUtils=c,e.ImmediateRenderObject=ac,e.IncrementStencilOp=7682,e.IncrementWrapStencilOp=34055,e.InstancedBufferAttribute=$s,e.InstancedBufferGeometry=Js,e.InstancedInterleavedBuffer=Xl,e.InstancedMesh=Va,e.Int16Attribute=function(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Ze(e,t)},e.Int16BufferAttribute=Ze,e.Int32Attribute=function(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new Ke(e,t)},e.Int32BufferAttribute=Ke,e.Int8Attribute=function(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new qe(e,t)},e.Int8BufferAttribute=qe,e.IntType=1013,e.InterleavedBuffer=sa,e.InterleavedBufferAttribute=fa,e.Interpolant=Gi,e.InterpolateDiscrete=2300,e.InterpolateLinear=2301,e.InterpolateSmooth=2302,e.InvertStencilOp=5386,e.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},e.KeepStencilOp=7680,e.KeyframeTrack=Wi,e.LOD=za,e.LatheBufferGeometry=xi,e.LatheGeometry=mi,e.Layers=L,e.LensFlare=function(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")},e.LessDepth=2,e.LessEqualDepth=3,e.LessEqualStencilFunc=515,e.LessStencilFunc=513,e.Light=Ds,e.LightProbe=Zs,e.LightShadow=Is,e.Line=Qa,e.Line3=nc,e.LineBasicMaterial=ja,e.LineCurve=As,e.LineCurve3=Ms,e.LineDashedMaterial=Ii,e.LineLoop=eo,e.LinePieces=1,e.LineSegments=$a,e.LineStrip=0,e.LinearEncoding=3e3,e.LinearFilter=1006,e.LinearInterpolant=Vi,e.LinearMipMapLinearFilter=1008,e.LinearMipMapNearestFilter=1007,e.LinearMipmapLinearFilter=1008,e.LinearMipmapNearestFilter=1007,e.LinearToneMapping=1,e.Loader=as,e.LoaderUtils=Ks,e.LoadingManager=rs,e.LogLuvEncoding=3003,e.LoopOnce=2200,e.LoopPingPong=2202,e.LoopRepeat=2201,e.LuminanceAlphaFormat=1025,e.LuminanceFormat=1024,e.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},e.Material=Ge,e.MaterialLoader=Qs,e.Math=i,e.MathUtils=i,e.Matrix3=l,e.Matrix4=R,e.MaxEquation=104,e.Mesh=Mt,e.MeshBasicMaterial=Be,e.MeshDepthMaterial=qn,e.MeshDistanceMaterial=Xn,e.MeshFaceMaterial=function(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e},e.MeshLambertMaterial=Di,e.MeshMatcapMaterial=Fi,e.MeshNormalMaterial=Ni,e.MeshPhongMaterial=zi,e.MeshPhysicalMaterial=Pi,e.MeshStandardMaterial=Hi,e.MeshToonMaterial=ki,e.MinEquation=103,e.MirroredRepeatWrapping=1002,e.MixOperation=1,e.MultiMaterial=function(e){return void 0===e&&(e=[]),console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e},e.MultiplyBlending=4,e.MultiplyOperation=0,e.NearestFilter=1003,e.NearestMipMapLinearFilter=1005,e.NearestMipMapNearestFilter=1004,e.NearestMipmapLinearFilter=1005,e.NearestMipmapNearestFilter=1004,e.NeverDepth=0,e.NeverStencilFunc=512,e.NoBlending=0,e.NoColors=0,e.NoToneMapping=0,e.NormalAnimationBlendMode=2500,e.NormalBlending=1,e.NotEqualDepth=7,e.NotEqualStencilFunc=517,e.NumberKeyframeTrack=Yi,e.Object3D=j,e.ObjectLoader=rl,e.ObjectSpaceNormalMap=1,e.OctahedronBufferGeometry=wo,e.OctahedronGeometry=Eo,e.OneFactor=201,e.OneMinusDstAlphaFactor=207,e.OneMinusDstColorFactor=209,e.OneMinusSrcAlphaFactor=205,e.OneMinusSrcColorFactor=203,e.OrthographicCamera=Vs,e.PCFShadowMap=1,e.PCFSoftShadowMap=2,e.PMREMGenerator=Yc,e.ParametricBufferGeometry=vo,e.ParametricGeometry=ho,e.Particle=function(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new _a(e)},e.ParticleBasicMaterial=function(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new to(e)},e.ParticleSystem=function(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new io(e,t)},e.ParticleSystemMaterial=function(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new to(e)},e.Path=ks,e.PerspectiveCamera=Vt,e.Plane=Ee,e.PlaneBufferGeometry=er,e.PlaneGeometry=$t,e.PlaneHelper=Cc,e.PointCloud=function(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new io(e,t)},e.PointCloudMaterial=function(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new to(e)},e.PointLight=Bs,e.PointLightHelper=dc,e.Points=io,e.PointsMaterial=to,e.PolarGridHelper=xc,e.PolyhedronBufferGeometry=xo,e.PolyhedronGeometry=mo,e.PositionalAudio=Ll,e.PropertyBinding=Bl,e.PropertyMixer=Pl,e.QuadraticBezierCurve=Cs,e.QuadraticBezierCurve3=Ls,e.Quaternion=v,e.QuaternionKeyframeTrack=Qi,e.QuaternionLinearInterpolant=Zi,e.REVISION="119",e.RGBADepthPacking=3201,e.RGBAFormat=1023,e.RGBAIntegerFormat=1033,e.RGBA_ASTC_10x10_Format=37819,e.RGBA_ASTC_10x5_Format=37816,e.RGBA_ASTC_10x6_Format=37817,e.RGBA_ASTC_10x8_Format=37818,e.RGBA_ASTC_12x10_Format=37820,e.RGBA_ASTC_12x12_Format=37821,e.RGBA_ASTC_4x4_Format=37808,e.RGBA_ASTC_5x4_Format=37809,e.RGBA_ASTC_5x5_Format=37810,e.RGBA_ASTC_6x5_Format=37811,e.RGBA_ASTC_6x6_Format=37812,e.RGBA_ASTC_8x5_Format=37813,e.RGBA_ASTC_8x6_Format=37814,e.RGBA_ASTC_8x8_Format=37815,e.RGBA_BPTC_Format=36492,e.RGBA_ETC2_EAC_Format=37496,e.RGBA_PVRTC_2BPPV1_Format=35843,e.RGBA_PVRTC_4BPPV1_Format=35842,e.RGBA_S3TC_DXT1_Format=33777,e.RGBA_S3TC_DXT3_Format=33778,e.RGBA_S3TC_DXT5_Format=33779,e.RGBDEncoding=3006,e.RGBEEncoding=3002,e.RGBEFormat=1023,e.RGBFormat=1022,e.RGBIntegerFormat=1032,e.RGBM16Encoding=3005,e.RGBM7Encoding=3004,e.RGB_ETC1_Format=36196,e.RGB_ETC2_Format=37492,e.RGB_PVRTC_2BPPV1_Format=35841,e.RGB_PVRTC_4BPPV1_Format=35840,e.RGB_S3TC_DXT1_Format=33776,e.RGFormat=1030,e.RGIntegerFormat=1031,e.RawShaderMaterial=Li,e.Ray=me,e.Raycaster=Yl,e.RectAreaLight=Xs,e.RedFormat=1028,e.RedIntegerFormat=1029,e.ReinhardToneMapping=2,e.RepeatWrapping=1e3,e.ReplaceStencilOp=7681,e.ReverseSubtractEquation=102,e.RingBufferGeometry=vi,e.RingGeometry=hi,e.SRGB8_ALPHA8_ASTC_10x10_Format=37851,e.SRGB8_ALPHA8_ASTC_10x5_Format=37848,e.SRGB8_ALPHA8_ASTC_10x6_Format=37849,e.SRGB8_ALPHA8_ASTC_10x8_Format=37850,e.SRGB8_ALPHA8_ASTC_12x10_Format=37852,e.SRGB8_ALPHA8_ASTC_12x12_Format=37853,e.SRGB8_ALPHA8_ASTC_4x4_Format=37840,e.SRGB8_ALPHA8_ASTC_5x4_Format=37841,e.SRGB8_ALPHA8_ASTC_5x5_Format=37842,e.SRGB8_ALPHA8_ASTC_6x5_Format=37843,e.SRGB8_ALPHA8_ASTC_6x6_Format=37844,e.SRGB8_ALPHA8_ASTC_8x5_Format=37845,e.SRGB8_ALPHA8_ASTC_8x6_Format=37846,e.SRGB8_ALPHA8_ASTC_8x8_Format=37847,e.Scene=W,e.SceneUtils=af,e.ShaderChunk=tr,e.ShaderLib=rr,e.ShaderMaterial=Gt,e.ShadowMaterial=Ci,e.Shape=Ns,e.ShapeBufferGeometry=yi,e.ShapeGeometry=gi,e.ShapePath=ll,e.ShapeUtils=ni,e.ShortType=1011,e.Skeleton=Fa,e.SkeletonHelper=fc,e.SkinnedMesh=ka,e.SmoothShading=2,e.Sphere=le,e.SphereBufferGeometry=pi,e.SphereGeometry=ui,e.Spherical=Kl,e.SphericalHarmonics3=Ys,e.Spline=rf,e.SplineCurve=Hs,e.SplineCurve3=tf,e.SpotLight=Us,e.SpotLightHelper=ic,e.SpotLightShadow=Os,e.Sprite=_a,e.SpriteMaterial=da,e.SrcAlphaFactor=204,e.SrcAlphaSaturateFactor=210,e.SrcColorFactor=202,e.StaticCopyUsage=35046,e.StaticDrawUsage=35044,e.StaticReadUsage=35045,e.StereoCamera=gl,e.StreamCopyUsage=35042,e.StreamDrawUsage=35040,e.StreamReadUsage=35041,e.StringKeyframeTrack=Ki,e.SubtractEquation=101,e.SubtractiveBlending=3,e.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},e.TangentSpaceNormalMap=0,e.TetrahedronBufferGeometry=yo,e.TetrahedronGeometry=go,e.TextBufferGeometry=di,e.TextGeometry=fi,e.Texture=d,e.TextureLoader=us,e.TorusBufferGeometry=Ho,e.TorusGeometry=Lo,e.TorusKnotBufferGeometry=Co,e.TorusKnotGeometry=Mo,e.Triangle=He,e.TriangleFanDrawMode=2,e.TriangleStripDrawMode=1,e.TrianglesDrawMode=0,e.TubeBufferGeometry=Ao,e.TubeGeometry=Ro,e.UVMapping=300,e.Uint16Attribute=function(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new Qe(e,t)},e.Uint16BufferAttribute=Qe,e.Uint32Attribute=function(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new Je(e,t)},e.Uint32BufferAttribute=Je,e.Uint8Attribute=function(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Xe(e,t)},e.Uint8BufferAttribute=Xe,e.Uint8ClampedAttribute=function(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Ye(e,t)},e.Uint8ClampedBufferAttribute=Ye,e.Uniform=ql,e.UniformsLib=Qt,e.UniformsUtils=Ut,e.UnsignedByteType=1009,e.UnsignedInt248Type=1020,e.UnsignedIntType=1014,e.UnsignedShort4444Type=1017,e.UnsignedShort5551Type=1018,e.UnsignedShort565Type=1019,e.UnsignedShortType=1012,e.VSMShadowMap=3,e.Vector2=s,e.Vector3=g,e.Vector4=u,e.VectorKeyframeTrack=Ji,e.Vertex=function(e,t,r){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new g(e,t,r)},e.VertexColors=2,e.VideoTexture=lo,e.WebGL1Renderer=aa,e.WebGLCubeRenderTarget=Wt,e.WebGLMultisampleRenderTarget=h,e.WebGLRenderTarget=p,e.WebGLRenderTargetCube=function(e,t,r){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Wt(e,r)},e.WebGLRenderer=na,e.WebGLUtils=Kn,e.WireframeGeometry=po,e.WireframeHelper=function(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new $a(new po(e.geometry),new ja({color:void 0!==t?t:16777215}))},e.WrapAroundEnding=2402,e.XHRLoader=function(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new is(e)},e.ZeroCurvatureEnding=2400,e.ZeroFactor=200,e.ZeroSlopeEnding=2401,e.ZeroStencilOp=0,e.sRGBEncoding=3001,Object.defineProperty(e,"__esModule",{value:!0})}(t)},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t){(function(){"use strict";function e(e){throw e}var t=void 0,r=this;function n(e,n){var a,o=e.split("."),i=r;!(o[0]in i)&&i.execScript&&i.execScript("var "+o[0]);for(;o.length&&(a=o.shift());)o.length||n===t?i=i[a]?i[a]:i[a]={}:i[a]=n}var a,o="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array&&"undefined"!=typeof DataView;for(new(o?Uint8Array:Array)(256),a=0;256>a;++a)for(var i=(i=a)>>>1;i;i>>>=1)0;function s(e,t,r){var n,a="number"==typeof t?t:t=0,o="number"==typeof r?r:e.length;for(n=-1,a=7&o;a--;++t)n=n>>>8^c[255&(n^e[t])];for(a=o>>3;a--;t+=8)n=(n=(n=(n=(n=(n=(n=(n=n>>>8^c[255&(n^e[t])])>>>8^c[255&(n^e[t+1])])>>>8^c[255&(n^e[t+2])])>>>8^c[255&(n^e[t+3])])>>>8^c[255&(n^e[t+4])])>>>8^c[255&(n^e[t+5])])>>>8^c[255&(n^e[t+6])])>>>8^c[255&(n^e[t+7])];return(4294967295^n)>>>0}var l=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],c=o?new Uint32Array(l):l;function f(){}function d(e){var t,r,n,a,i,s,l,c,f,d,u=e.length,p=0,h=Number.POSITIVE_INFINITY;for(c=0;c<u;++c)e[c]>p&&(p=e[c]),e[c]<h&&(h=e[c]);for(t=1<<p,r=new(o?Uint32Array:Array)(t),n=1,a=0,i=2;n<=p;){for(c=0;c<u;++c)if(e[c]===n){for(s=0,l=a,f=0;f<n;++f)s=s<<1|1&l,l>>=1;for(d=n<<16|c,f=s;f<t;f+=i)r[f]=d;++a}++n,a<<=1,i<<=1}return[r,p,h]}f.prototype.getName=function(){return this.name},f.prototype.getData=function(){return this.data},f.prototype.G=function(){return this.H};var u,p=[];for(u=0;288>u;u++)switch(!0){case 143>=u:p.push([u+48,8]);break;case 255>=u:p.push([u-144+400,9]);break;case 279>=u:p.push([u-256+0,7]);break;case 287>=u:p.push([u-280+192,8]);break;default:e("invalid literal: "+u)}var h=function(){function t(t){switch(!0){case 3===t:return[257,t-3,0];case 4===t:return[258,t-4,0];case 5===t:return[259,t-5,0];case 6===t:return[260,t-6,0];case 7===t:return[261,t-7,0];case 8===t:return[262,t-8,0];case 9===t:return[263,t-9,0];case 10===t:return[264,t-10,0];case 12>=t:return[265,t-11,1];case 14>=t:return[266,t-13,1];case 16>=t:return[267,t-15,1];case 18>=t:return[268,t-17,1];case 22>=t:return[269,t-19,2];case 26>=t:return[270,t-23,2];case 30>=t:return[271,t-27,2];case 34>=t:return[272,t-31,2];case 42>=t:return[273,t-35,3];case 50>=t:return[274,t-43,3];case 58>=t:return[275,t-51,3];case 66>=t:return[276,t-59,3];case 82>=t:return[277,t-67,4];case 98>=t:return[278,t-83,4];case 114>=t:return[279,t-99,4];case 130>=t:return[280,t-115,4];case 162>=t:return[281,t-131,5];case 194>=t:return[282,t-163,5];case 226>=t:return[283,t-195,5];case 257>=t:return[284,t-227,5];case 258===t:return[285,t-258,0];default:e("invalid length: "+t)}}var r,n,a=[];for(r=3;258>=r;r++)n=t(r),a[r]=n[2]<<24|n[1]<<16|n[0];return a}();function v(t,r){switch(this.i=[],this.j=32768,this.d=this.f=this.c=this.n=0,this.input=o?new Uint8Array(t):t,this.o=!1,this.k=x,this.w=!1,!r&&(r={})||(r.index&&(this.c=r.index),r.bufferSize&&(this.j=r.bufferSize),r.bufferType&&(this.k=r.bufferType),r.resize&&(this.w=r.resize)),this.k){case m:this.a=32768,this.b=new(o?Uint8Array:Array)(32768+this.j+258);break;case x:this.a=0,this.b=new(o?Uint8Array:Array)(this.j),this.e=this.D,this.q=this.A,this.l=this.C;break;default:e(Error("invalid inflate mode"))}}o&&new Uint32Array(h);var m=0,x=1;v.prototype.g=function(){for(;!this.o;){var r=D(this,3);switch(1&r&&(this.o=!0),r>>>=1){case 0:var n=this.input,a=this.c,i=this.b,s=this.a,l=n.length,c=t,f=i.length,u=t;switch(this.d=this.f=0,a+1>=l&&e(Error("invalid uncompressed block header: LEN")),c=n[a++]|n[a++]<<8,a+1>=l&&e(Error("invalid uncompressed block header: NLEN")),c===~(n[a++]|n[a++]<<8)&&e(Error("invalid uncompressed block header: length verify")),a+c>n.length&&e(Error("input buffer is broken")),this.k){case m:for(;s+c>i.length;){if(c-=u=f-s,o)i.set(n.subarray(a,a+u),s),s+=u,a+=u;else for(;u--;)i[s++]=n[a++];this.a=s,i=this.e(),s=this.a}break;case x:for(;s+c>i.length;)i=this.e({t:2});break;default:e(Error("invalid inflate mode"))}if(o)i.set(n.subarray(a,a+c),s),s+=c,a+=c;else for(;c--;)i[s++]=n[a++];this.c=a,this.a=s,this.b=i;break;case 1:this.l(z,N);break;case 2:var p,h,v,g,y=D(this,5)+257,E=D(this,5)+1,b=D(this,4)+4,T=new(o?Uint8Array:Array)(w.length),_=t,S=t,R=t,A=t,M=t;for(M=0;M<b;++M)T[w[M]]=D(this,3);if(!o)for(M=b,b=T.length;M<b;++M)T[w[M]]=0;for(p=d(T),_=new(o?Uint8Array:Array)(y+E),M=0,g=y+E;M<g;)switch(S=F(this,p),S){case 16:for(A=3+D(this,2);A--;)_[M++]=R;break;case 17:for(A=3+D(this,3);A--;)_[M++]=0;R=0;break;case 18:for(A=11+D(this,7);A--;)_[M++]=0;R=0;break;default:R=_[M++]=S}h=d(o?_.subarray(0,y):_.slice(0,y)),v=d(o?_.subarray(y):_.slice(y)),this.l(h,v);break;default:e(Error("unknown BTYPE: "+r))}}return this.q()};var g,y,E=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],w=o?new Uint16Array(E):E,b=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],T=o?new Uint16Array(b):b,_=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],S=o?new Uint8Array(_):_,R=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],A=o?new Uint16Array(R):R,M=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],C=o?new Uint8Array(M):M,L=new(o?Uint8Array:Array)(288);for(g=0,y=L.length;g<y;++g)L[g]=143>=g?8:255>=g?9:279>=g?7:8;var H,P,z=d(L),k=new(o?Uint8Array:Array)(30);for(H=0,P=k.length;H<P;++H)k[H]=5;var N=d(k);function D(t,r){for(var n,a=t.f,o=t.d,i=t.input,s=t.c,l=i.length;o<r;)s>=l&&e(Error("input buffer is broken")),a|=i[s++]<<o,o+=8;return n=a&(1<<r)-1,t.f=a>>>r,t.d=o-r,t.c=s,n}function F(t,r){for(var n,a,o=t.f,i=t.d,s=t.input,l=t.c,c=s.length,f=r[0],d=r[1];i<d&&!(l>=c);)o|=s[l++]<<i,i+=8;return(a=(n=f[o&(1<<d)-1])>>>16)>i&&e(Error("invalid code length: "+a)),t.f=o>>a,t.d=i-a,t.c=l,65535&n}function I(e){this.input=e,this.c=0,this.m=[],this.s=!1}v.prototype.l=function(e,t){var r=this.b,n=this.a;this.r=e;for(var a,o,i,s,l=r.length-258;256!==(a=F(this,e));)if(256>a)n>=l&&(this.a=n,r=this.e(),n=this.a),r[n++]=a;else for(s=T[o=a-257],0<S[o]&&(s+=D(this,S[o])),a=F(this,t),i=A[a],0<C[a]&&(i+=D(this,C[a])),n>=l&&(this.a=n,r=this.e(),n=this.a);s--;)r[n]=r[n++-i];for(;8<=this.d;)this.d-=8,this.c--;this.a=n},v.prototype.C=function(e,t){var r=this.b,n=this.a;this.r=e;for(var a,o,i,s,l=r.length;256!==(a=F(this,e));)if(256>a)n>=l&&(l=(r=this.e()).length),r[n++]=a;else for(s=T[o=a-257],0<S[o]&&(s+=D(this,S[o])),a=F(this,t),i=A[a],0<C[a]&&(i+=D(this,C[a])),n+s>l&&(l=(r=this.e()).length);s--;)r[n]=r[n++-i];for(;8<=this.d;)this.d-=8,this.c--;this.a=n},v.prototype.e=function(){var e,t,r=new(o?Uint8Array:Array)(this.a-32768),n=this.a-32768,a=this.b;if(o)r.set(a.subarray(32768,r.length));else for(e=0,t=r.length;e<t;++e)r[e]=a[e+32768];if(this.i.push(r),this.n+=r.length,o)a.set(a.subarray(n,n+32768));else for(e=0;32768>e;++e)a[e]=a[n+e];return this.a=32768,a},v.prototype.D=function(e){var t,r,n,a=this.input.length/this.c+1|0,i=this.input,s=this.b;return e&&("number"==typeof e.t&&(a=e.t),"number"==typeof e.z&&(a+=e.z)),2>a?r=(n=(i.length-this.c)/this.r[2]/2*258|0)<s.length?s.length+n:s.length<<1:r=s.length*a,o?(t=new Uint8Array(r)).set(s):t=s,this.b=t},v.prototype.q=function(){var e,t,r,n,a,i=0,s=this.b,l=this.i,c=new(o?Uint8Array:Array)(this.n+(this.a-32768));if(0===l.length)return o?this.b.subarray(32768,this.a):this.b.slice(32768,this.a);for(t=0,r=l.length;t<r;++t)for(n=0,a=(e=l[t]).length;n<a;++n)c[i++]=e[n];for(t=32768,r=this.a;t<r;++t)c[i++]=s[t];return this.i=[],this.buffer=c},v.prototype.A=function(){var e,t=this.a;return o?this.w?(e=new Uint8Array(t)).set(this.b.subarray(0,t)):e=this.b.subarray(0,t):(this.b.length>t&&(this.b.length=t),e=this.b),this.buffer=e},I.prototype.F=function(){return this.s||this.g(),this.m.slice()},I.prototype.g=function(){for(var r=this.input.length;this.c<r;){var n,a,i=new f,l=t,c=t,d=t,u=t,p=t,h=t,m=t,x=this.input,g=this.c;switch(i.u=x[g++],i.v=x[g++],(31!==i.u||139!==i.v)&&e(Error("invalid file signature:"+i.u+","+i.v)),i.p=x[g++],i.p){case 8:break;default:e(Error("unknown compression method: "+i.p))}if(i.h=x[g++],a=x[g++]|x[g++]<<8|x[g++]<<16|x[g++]<<24,i.H=new Date(1e3*a),i.N=x[g++],i.M=x[g++],0<(4&i.h)&&(i.I=x[g++]|x[g++]<<8,g+=i.I),0<(8&i.h)){for(h=[],p=0;0<(u=x[g++]);)h[p++]=String.fromCharCode(u);i.name=h.join("")}if(0<(16&i.h)){for(h=[],p=0;0<(u=x[g++]);)h[p++]=String.fromCharCode(u);i.J=h.join("")}0<(2&i.h)&&(i.B=65535&s(x,0,g),i.B!==(x[g++]|x[g++]<<8)&&e(Error("invalid header crc16"))),l=x[x.length-4]|x[x.length-3]<<8|x[x.length-2]<<16|x[x.length-1]<<24,x.length-g-4-4<512*l&&(d=l),c=new v(x,{index:g,bufferSize:d}),i.data=n=c.g(),g=c.c,i.K=m=(x[g++]|x[g++]<<8|x[g++]<<16|x[g++]<<24)>>>0,s(n,t,t)!==m&&e(Error("invalid CRC-32 checksum: 0x"+s(n,t,t).toString(16)+" / 0x"+m.toString(16))),i.L=l=(x[g++]|x[g++]<<8|x[g++]<<16|x[g++]<<24)>>>0,(4294967295&n.length)!==l&&e(Error("invalid input size: "+(4294967295&n.length)+" / "+l)),this.m.push(i),this.c=g}this.s=!0;var y,E,w,b=this.m,T=0,_=0;for(y=0,E=b.length;y<E;++y)_+=b[y].data.length;if(o)for(w=new Uint8Array(_),y=0;y<E;++y)w.set(b[y].data,T),T+=b[y].data.length;else{for(w=[],y=0;y<E;++y)w[y]=b[y].data;w=Array.prototype.concat.apply([],w)}return w},n("Zlib.Gunzip",I),n("Zlib.Gunzip.prototype.decompress",I.prototype.g),n("Zlib.Gunzip.prototype.getMembers",I.prototype.F),n("Zlib.GunzipMember",f),n("Zlib.GunzipMember.prototype.getName",f.prototype.getName),n("Zlib.GunzipMember.prototype.getData",f.prototype.getData),n("Zlib.GunzipMember.prototype.getMtime",f.prototype.G)}).call(this)},function(e,t,r){"use strict";var n,a,o;function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}!function(r,s){"object"===i(t)&&void 0!==e?s(t):(a=[t],void 0===(o="function"==typeof(n=s)?n.apply(t,a):n)||(e.exports=o))}(0,(function(e){var t=Math.round,r=Math.abs,n=Math.min,a=Math.max,o=Math.sqrt;function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){for(var r,n=0;n<t.length;n++)(r=t[n]).enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}function c(e,t,r){return t&&l(e.prototype,t),r&&l(e,r),e}function f(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)}function d(e){return(d=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function h(e,t,r){return(h="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=d(e)););return e}(e,t);if(n){var a=Object.getOwnPropertyDescriptor(n,t);return a.get?a.get.call(r):a.value}})(e,t,r||e)}function v(e){return function(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function m(e,t,r){var n,a,i,s,l,c,f,d,u,p,h,v=t.params.Points.threshold;for(l=0,f=e.length;l<f;++l)if(null!==(p=(u=e[l]).points))for(c=0,d=p.length;c<d;++c)h=p[c],(s=t.ray.distanceSqToPoint(h))<v*v&&(n=t.ray.closestPointToPoint(h,new M),(a=t.ray.origin.distanceTo(n))>=t.near&&a<=t.far&&(i=o(s),r.push(new I(a,i,n,u.data[c]))))}function x(e,t,r,n,a,o){var i=0;return e>t&&e>r?(a<e&&(i|=2),o<e&&(i|=1)):t>r?(n<t&&(i|=4),o<t&&(i|=1)):(n<r&&(i|=4),a<r&&(i|=2)),i}function g(e,t,r,n){var a,o=0;return t<r?(a=t,o=0):(a=r,o=1),n<a&&(o=2),U[e][o]}function y(e,t,r){var o,i,s,l,c,f,d,u,p,h=B.min.set(0,0,0),v=B.max.subVectors(e.max,e.min),m=e.getDimensions(V.min),x=V.max.copy(m).multiplyScalar(.5),g=j.origin.copy(t.origin),y=j.direction.copy(t.direction);return g.sub(e.getCenter(G)).add(x),r.value=0,0>y.x&&(g.x=m.x-g.x,y.x=-y.x,r.value|=4),0>y.y&&(g.y=m.y-g.y,y.y=-y.y,r.value|=2),0>y.z&&(g.z=m.z-g.z,y.z=-y.z,r.value|=1),o=1/y.x,i=1/y.y,s=1/y.z,l=(h.x-g.x)*o,c=(v.x-g.x)*o,f=(h.y-g.y)*i,d=(v.y-g.y)*i,u=(h.z-g.z)*s,p=(v.z-g.z)*s,a(a(l,f),u)<n(n(c,d),p)?[l,f,u,c,d,p]:null}function E(e,t,r,n,a,o,i,s){if(0<=a&&0<=o&&0<=i){var l=e.children;if(null===l)s.push(e);else{var c=.5*(t+a),f=.5*(r+o),d=.5*(n+i),u=W.value,p=x(t,r,n,c,f,d);do{0===p?(E(l[u],t,r,n,c,f,d,s),p=g(p,c,f,d)):1===p?(E(l[1^u],t,r,d,c,f,i,s),p=g(p,c,f,i)):2===p?(E(l[2^u],t,f,n,c,o,d,s),p=g(p,c,o,d)):3===p?(E(l[3^u],t,f,d,c,o,i,s),p=g(p,c,o,i)):4===p?(E(l[4^u],c,r,n,a,f,d,s),p=g(p,a,f,d)):5===p?(E(l[5^u],c,r,d,a,f,i,s),p=g(p,a,f,i)):6===p?(E(l[6^u],c,f,n,a,o,d,s),p=g(p,a,o,d)):7===p&&(E(l[7^u],c,f,d,a,o,i,s),p=8)}while(8>p)}}}function w(e){var t,r,n=e.children,a=0;if(null!==n)for(t=0,r=n.length;t<r;++t)a+=w(n[t]);else null!==e.points&&(a=e.points.length);return a}function b(e,t,r,n,a){var o,i,s=n.children,l=!1,c=!1;if(n.contains(e,r.bias)){if(null===s){if(null===n.points)n.points=[],n.data=[];else for(o=0,i=n.points.length;!l&&o<i;++o)l=n.points[o].equals(e);l?(n.data[o-1]=t,c=!0):n.points.length<r.maxPoints||a===r.maxDepth?(n.points.push(e.clone()),n.data.push(t),++r.pointCount,c=!0):(n.split(),n.redistribute(r.bias),s=n.children)}if(null!==s)for(++a,o=0,i=s.length;!c&&o<i;++o)c=b(e,t,r,s[o],a)}return c}function T(e,t,r,n){var a,o,i,s,l,c=r.children,f=null;if(r.contains(e,t.bias))if(null!==c)for(a=0,o=c.length;null===f&&a<o;++a)f=T(e,t,c[a],r);else if(null!==r.points)for(i=r.points,s=r.data,a=0,o=i.length;a<o;++a)if(i[a].equals(e)){l=o-1,f=s[a],a<l&&(i[a]=i[l],s[a]=s[l]),i.pop(),s.pop(),--t.pointCount,null!==n&&w(n)<=t.maxPoints&&n.merge();break}return f}function _(e,t,r,n){var a,o,i=null,s=t;if(null!==n.children){var l,c,f=n.children.map((function(t){return{octant:t,distance:t.distanceToCenterSquared(e)}})).sort((function(e,t){return e.distance-t.distance}));for(a=0,o=f.length;a<o&&(!(l=f[a].octant).contains(e,s)||(null===(c=_(e,s,r,l))||(i=c,0!==(s=c.distance))));++a);}else if(null!==n.points){var d,u=n.points,p=-1;for(a=0,o=u.length;a<o;++a)if(u[a].equals(e)){if(!r){s=0,p=a;break}}else(d=e.distanceTo(u[a]))<s&&(s=d,p=a);0<=p&&(i={point:u[p],data:n.data[p],distance:s})}return i}function S(e,t,r,n,a){var o,i,s,l=n.children;if(null!==l)for(o=0,i=l.length;o<i;++o)(s=l[o]).contains(e,t)&&S(e,t,r,s,a);else if(null!==n.points){var c,f=n.points;for(o=0,i=f.length;o<i;++o)(c=f[o]).equals(e)?!r&&a.push({point:c.clone(),data:n.data[o]}):c.distanceToSquared(e)<=t*t&&a.push({point:c.clone(),data:n.data[o]})}}var R=[new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7]),new Uint8Array([0,2]),new Uint8Array([1,3]),new Uint8Array([4,6]),new Uint8Array([5,7]),new Uint8Array([0,1]),new Uint8Array([2,3]),new Uint8Array([4,5]),new Uint8Array([6,7])],A=[new Uint8Array([0,0,0]),new Uint8Array([0,0,1]),new Uint8Array([0,1,0]),new Uint8Array([0,1,1]),new Uint8Array([1,0,0]),new Uint8Array([1,0,1]),new Uint8Array([1,1,0]),new Uint8Array([1,1,1])],M=function(){var e=Math.cos,i=Math.sin;function l(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;s(this,l),this.x=e,this.y=t,this.z=r}return c(l,[{key:"set",value:function(e,t,r){return this.x=e,this.y=t,this.z=r,this}},{key:"copy",value:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"fromArray",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}},{key:"toArray",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[],t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}},{key:"setFromSpherical",value:function(e){this.setFromSphericalCoords(e.radius,e.phi,e.theta)}},{key:"setFromSphericalCoords",value:function(t,r,n){var a=i(r)*t;return this.x=a*i(n),this.y=e(r)*t,this.z=a*e(n),this}},{key:"setFromCylindrical",value:function(e){this.setFromCylindricalCoords(e.radius,e.theta,e.y)}},{key:"setFromCylindricalCoords",value:function(t,r,n){return this.x=t*i(r),this.y=n,this.z=t*e(r),this}},{key:"setFromMatrixColumn",value:function(e,t){return this.fromArray(e.elements,4*t)}},{key:"setFromMatrixPosition",value:function(e){var t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}},{key:"setFromMatrixScale",value:function(e){var t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),n=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=n,this}},{key:"add",value:function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}},{key:"addScalar",value:function(e){return this.x+=e,this.y+=e,this.z+=e,this}},{key:"addVectors",value:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}},{key:"addScaledVector",value:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}},{key:"sub",value:function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}},{key:"subScalar",value:function(e){return this.x-=e,this.y-=e,this.z-=e,this}},{key:"subVectors",value:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}},{key:"multiply",value:function(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}},{key:"multiplyScalar",value:function(e){return this.x*=e,this.y*=e,this.z*=e,this}},{key:"multiplyVectors",value:function(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}},{key:"divide",value:function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}},{key:"divideScalar",value:function(e){return this.x/=e,this.y/=e,this.z/=e,this}},{key:"crossVectors",value:function(e,t){var r=e.x,n=e.y,a=e.z,o=t.x,i=t.y,s=t.z;return this.x=n*s-a*i,this.y=a*o-r*s,this.z=r*i-n*o,this}},{key:"cross",value:function(e){return this.crossVectors(this,e)}},{key:"transformDirection",value:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*n,this.y=a[1]*t+a[5]*r+a[9]*n,this.z=a[2]*t+a[6]*r+a[10]*n,this.normalize()}},{key:"applyMatrix3",value:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[3]*r+a[6]*n,this.y=a[1]*t+a[4]*r+a[7]*n,this.z=a[2]*t+a[5]*r+a[8]*n,this}},{key:"applyMatrix4",value:function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*n+a[12],this.y=a[1]*t+a[5]*r+a[9]*n+a[13],this.z=a[2]*t+a[6]*r+a[10]*n+a[14],this}},{key:"applyQuaternion",value:function(e){var t=this.x,r=this.y,n=this.z,a=e.x,o=e.y,i=e.z,s=e.w,l=s*t+o*n-i*r,c=s*r+i*t-a*n,f=s*n+a*r-o*t,d=-a*t-o*r-i*n;return this.x=l*s+d*-a+c*-i-f*-o,this.y=c*s+d*-o+f*-a-l*-i,this.z=f*s+d*-i+l*-o-c*-a,this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(e){return this.x*e.x+this.y*e.y+this.z*e.z}},{key:"reflect",value:function(e){var t=e.x,r=e.y,n=e.z;return this.sub(e.multiplyScalar(2*this.dot(e))),e.set(t,r,n),this}},{key:"angleTo",value:function(e){var t=Math.acos,r=this.dot(e)/o(this.lengthSquared()*e.lengthSquared());return t(n(a(r,-1),1))}},{key:"manhattanLength",value:function(){return r(this.x)+r(this.y)+r(this.z)}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return o(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanDistanceTo",value:function(e){return r(this.x-e.x)+r(this.y-e.y)+r(this.z-e.z)}},{key:"distanceToSquared",value:function(e){var t=this.x-e.x,r=this.y-e.y,n=this.z-e.z;return t*t+r*r+n*n}},{key:"distanceTo",value:function(e){return o(this.distanceToSquared(e))}},{key:"normalize",value:function(){return this.divideScalar(this.length())}},{key:"setLength",value:function(e){return this.normalize().multiplyScalar(e)}},{key:"min",value:function(e){return this.x=n(this.x,e.x),this.y=n(this.y,e.y),this.z=n(this.z,e.z),this}},{key:"max",value:function(e){return this.x=a(this.x,e.x),this.y=a(this.y,e.y),this.z=a(this.z,e.z),this}},{key:"clamp",value:function(e,t){return this.x=a(e.x,n(t.x,this.x)),this.y=a(e.y,n(t.y,this.y)),this.z=a(e.z,n(t.z,this.z)),this}},{key:"floor",value:function(){var e=Math.floor;return this.x=e(this.x),this.y=e(this.y),this.z=e(this.z),this}},{key:"ceil",value:function(){var e=Math.ceil;return this.x=e(this.x),this.y=e(this.y),this.z=e(this.z),this}},{key:"round",value:function(){return this.x=t(this.x),this.y=t(this.y),this.z=t(this.z),this}},{key:"lerp",value:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}},{key:"lerpVectors",value:function(e,t,r){return this.subVectors(t,e).multiplyScalar(r).add(e)}},{key:"equals",value:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}}]),l}(),C=new M,L=[new M,new M,new M,new M,new M,new M,new M,new M],H=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M(1/0,1/0,1/0),r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M(-1/0,-1/0,-1/0);s(this,e),this.min=t,this.max=r}return c(e,[{key:"set",value:function(e,t){return this.min.copy(e),this.max.copy(t),this}},{key:"copy",value:function(e){return this.min.copy(e.min),this.max.copy(e.max),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M;return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M;return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}},{key:"setFromSphere",value:function(e){return this.set(e.center,e.center),this.expandByScalar(e.radius),this}},{key:"expandByPoint",value:function(e){return this.min.min(e),this.max.max(e),this}},{key:"expandByVector",value:function(e){return this.min.sub(e),this.max.add(e),this}},{key:"expandByScalar",value:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this}},{key:"setFromPoints",value:function(e){var t,r;for(this.min.set(0,0,0),this.max.set(0,0,0),t=0,r=e.length;t<r;++t)this.expandByPoint(e[t]);return this}},{key:"setFromCenterAndSize",value:function(e,t){var r=C.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}},{key:"clampPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M;return t.copy(e).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(e){return C.copy(e).clamp(this.min,this.max).sub(e).length()}},{key:"applyMatrix4",value:function(e){var t=this.min,r=this.max;return this.isEmpty()||(L[0].set(t.x,t.y,t.z).applyMatrix4(e),L[1].set(t.x,t.y,r.z).applyMatrix4(e),L[2].set(t.x,r.y,t.z).applyMatrix4(e),L[3].set(t.x,r.y,r.z).applyMatrix4(e),L[4].set(r.x,t.y,t.z).applyMatrix4(e),L[5].set(r.x,t.y,r.z).applyMatrix4(e),L[6].set(r.x,r.y,t.z).applyMatrix4(e),L[7].set(r.x,r.y,r.z).applyMatrix4(e),this.setFromPoints(L)),this}},{key:"translate",value:function(e){return this.min.add(e),this.max.add(e),this}},{key:"intersect",value:function(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(e){return this.min.min(e.min),this.max.max(e.max),this}},{key:"containsPoint",value:function(e){var t=this.min,r=this.max;return e.x>=t.x&&e.y>=t.y&&e.z>=t.z&&e.x<=r.x&&e.y<=r.y&&e.z<=r.z}},{key:"containsBox",value:function(e){var t=this.min,r=this.max,n=e.min,a=e.max;return t.x<=n.x&&a.x<=r.x&&t.y<=n.y&&a.y<=r.y&&t.z<=n.z&&a.z<=r.z}},{key:"intersectsBox",value:function(e){var t=this.min,r=this.max,n=e.min,a=e.max;return a.x>=t.x&&a.y>=t.y&&a.z>=t.z&&n.x<=r.x&&n.y<=r.y&&n.z<=r.z}},{key:"intersectsSphere",value:function(e){return this.clampPoint(e.center,C).distanceToSquared(e.center)<=e.radius*e.radius}},{key:"intersectsPlane",value:function(e){var t,r;return 0<e.normal.x?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),0<e.normal.y?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),0<e.normal.z?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}},{key:"equals",value:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}]),e}(),P=[new M,new M,new M,new M],z=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M;s(this,e),this.origin=t,this.direction=r}return c(e,[{key:"set",value:function(e,t){return this.origin.copy(e),this.direction.copy(t),this}},{key:"copy",value:function(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"at",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M;return t.copy(this.direction).multiplyScalar(e).add(this.origin)}},{key:"lookAt",value:function(e){return this.direction.copy(e).sub(this.origin).normalize(),this}},{key:"recast",value:function(e){return this.origin.copy(this.at(e,P[0])),this}},{key:"closestPointToPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M,r=t.subVectors(e,this.origin).dot(this.direction);return 0<=r?t.copy(this.direction).multiplyScalar(r).add(this.origin):t.copy(this.origin)}},{key:"distanceSquaredToPoint",value:function(e){var t=P[0].subVectors(e,this.origin).dot(this.direction);return 0>t?this.origin.distanceToSquared(e):P[0].copy(this.direction).multiplyScalar(t).add(this.origin).distanceToSquared(e)}},{key:"distanceToPoint",value:function(e){return o(this.distanceSquaredToPoint(e))}},{key:"distanceToPlane",value:function(e){var t=e.normal.dot(this.direction),r=0===t?0===e.distanceToPoint(this.origin)?0:-1:-(this.origin.dot(e.normal)+e.constant)/t;return 0<=r?r:null}},{key:"distanceSquaredToSegment",value:function(e,t,o,i){var s,l,c,f,d,u=P[0].copy(e).add(t).multiplyScalar(.5),p=P[1].copy(t).sub(e).normalize(),h=P[2].copy(this.origin).sub(u),v=.5*e.distanceTo(t),m=-this.direction.dot(p),x=h.dot(this.direction),g=-h.dot(p),y=h.lengthSq(),E=r(1-m*m);return 0<E?(l=m*x-g,c=v*E,0<=(s=m*g-x)?l>=-c?l<=c?d=(s*=f=1/E)*(s+m*(l*=f)+2*x)+l*(m*s+l+2*g)+y:d=-(s=a(0,-(m*(l=v)+x)))*s+l*(l+2*g)+y:d=-(s=a(0,-(m*(l=-v)+x)))*s+l*(l+2*g)+y:l<=-c?d=-(s=a(0,-(-m*v+x)))*s+(l=0<s?-v:n(a(-v,-g),v))*(l+2*g)+y:l<=c?(s=0,d=(l=n(a(-v,-g),v))*(l+2*g)+y):d=-(s=a(0,-(m*v+x)))*s+(l=0<s?v:n(a(-v,-g),v))*(l+2*g)+y):d=-(s=a(0,-(m*(l=0<m?-v:v)+x)))*s+l*(l+2*g)+y,void 0!==o&&o.copy(this.direction).multiplyScalar(s).add(this.origin),void 0!==i&&i.copy(p).multiplyScalar(l).add(u),d}},{key:"intersectSphere",value:function(e){var t,r,n,a=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M,i=P[0].subVectors(e.center,this.origin),s=i.dot(this.direction),l=i.dot(i)-s*s,c=e.radius*e.radius,f=null;return l<=c&&(n=s+(t=o(c-l)),(0<=(r=s-t)||0<=n)&&(f=0>r?this.at(n,a):this.at(r,a))),f}},{key:"intersectsSphere",value:function(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}},{key:"intersectPlane",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M,r=this.distanceToPlane(e);return null===r?null:this.at(r,t)}},{key:"intersectsPlane",value:function(e){var t=e.distanceToPoint(this.origin);return 0===t||0>e.normal.dot(this.direction)*t}},{key:"intersectBox",value:function(e){var t,r,n,a,o,i,s=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M,l=this.origin,c=this.direction,f=e.min,d=e.max,u=1/c.x,p=1/c.y,h=1/c.z,v=null;return 0<=u?(t=(f.x-l.x)*u,r=(d.x-l.x)*u):(t=(d.x-l.x)*u,r=(f.x-l.x)*u),0<=p?(n=(f.y-l.y)*p,a=(d.y-l.y)*p):(n=(d.y-l.y)*p,a=(f.y-l.y)*p),t<=a&&n<=r&&((n>t||t!=t)&&(t=n),(a<r||r!=r)&&(r=a),0<=h?(o=(f.z-l.z)*h,i=(d.z-l.z)*h):(o=(d.z-l.z)*h,i=(f.z-l.z)*h),t<=i&&o<=r&&((o>t||t!=t)&&(t=o),(i<r||r!=r)&&(r=i),0<=r&&(v=this.at(0<=t?t:r,s)))),v}},{key:"intersectsBox",value:function(e){return null!==this.intersectBox(e,P[0])}},{key:"intersectTriangle",value:function(e,t,r,n,a){var o,i,s,l,c,f=this.direction,d=P[0],u=P[1],p=P[2],h=P[3],v=null;return u.subVectors(t,e),p.subVectors(r,e),h.crossVectors(u,p),0===(o=f.dot(h))||n&&0<o||(0<o?i=1:(i=-1,o=-o),d.subVectors(this.origin,e),0<=(s=i*f.dot(p.crossVectors(d,p)))&&(0<=(l=i*f.dot(u.cross(d)))&&s+l<=o&&(0<=(c=-i*d.dot(h))&&(v=this.at(c/o,a))))),v}},{key:"applyMatrix4",value:function(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}},{key:"equals",value:function(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}]),e}(),k=new M,N=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;s(this,e),this.min=t,this.size=r,this.children=null}return c(e,[{key:"getCenter",value:function(e){return e.copy(this.min).addScalar(.5*this.size)}},{key:"getDimensions",value:function(e){return e.set(this.size,this.size,this.size)}},{key:"split",value:function(){var e,t,r=this.min,n=this.getCenter(k),a=.5*this.size,o=this.children=[null,null,null,null,null,null,null,null];for(e=0;8>e;++e)t=A[e],o[e]=new this.constructor(new M(0===t[0]?r.x:n.x,0===t[1]?r.y:n.y,0===t[2]?r.z:n.z),a)}},{key:"max",get:function(){return this.min.clone().addScalar(this.size)}}]),e}(),D=new M,F=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new M,r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new M;s(this,e),this.min=t,this.max=r,this.children=null}return c(e,[{key:"getCenter",value:function(e){return e.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getDimensions",value:function(e){return e.subVectors(this.max,this.min)}},{key:"split",value:function(){var e,t,r=this.min,n=this.max,a=this.getCenter(D),o=this.children=[null,null,null,null,null,null,null,null];for(e=0;8>e;++e)t=A[e],o[e]=new this.constructor(new M(0===t[0]?r.x:a.x,0===t[1]?r.y:a.y,0===t[2]?r.z:a.z),new M(0===t[0]?a.x:n.x,0===t[1]?a.y:n.y,0===t[2]?a.z:n.z))}}]),e}(),I=function e(t,r,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s(this,e),this.distance=t,this.distanceToRay=r,this.point=n,this.object=a},O=function e(){s(this,e),this.value=0},U=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],G=new M,B=new H,V=new H,j=new z,W=new O,q=function(){function e(){s(this,e)}return c(e,null,[{key:"intersectOctree",value:function(e,t){var r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:[],n=y(e,t,W);null!==n&&E.apply(void 0,[e.root].concat(v(n),[r]))}}]),e}(),X=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,r=!!(1<arguments.length&&void 0!==arguments[1])&&arguments[1];s(this,e),this.value=t,this.done=r}return c(e,[{key:"reset",value:function(){this.value=null,this.done=!1}}]),e}(),Y=new H,Z=function(){function e(t){var r=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;s(this,e),this.octree=t,this.region=r,this.cull=null!==r,this.result=new X,this.trace=null,this.indices=null,this.reset()}return c(e,[{key:"reset",value:function(){var e=this.octree.root;return this.trace=[],this.indices=[],null!==e&&(Y.min=e.min,Y.max=e.max,(!this.cull||this.region.intersectsBox(Y))&&(this.trace.push(e),this.indices.push(0))),this.result.reset(),this}},{key:"next",value:function(){for(var e,t,r,n=this.cull,a=this.region,o=this.indices,i=this.trace,s=null,l=i.length-1;null===s&&0<=l;)if(e=o[l]++,t=i[l].children,8>e)if(null!==t){if(r=t[e],n&&(Y.min=r.min,Y.max=r.max,!a.intersectsBox(Y)))continue;i.push(r),o.push(0),++l}else s=i.pop(),o.pop();else i.pop(),o.pop(),--l;return this.result.value=s,this.result.done=null===s,this.result}},{key:"return",value:function(e){return this.result.value=e,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),Q=new H,K=function(){function e(t){s(this,e),this.root=t}return c(e,[{key:"getCenter",value:function(e){return this.root.getCenter(e)}},{key:"getDimensions",value:function(e){return this.root.getDimensions(e)}},{key:"cull",value:function(e){var t=[];return function e(t,r,n){var a,o,i=t.children;if(Q.min=t.min,Q.max=t.max,r.intersectsBox(Q))if(null!==i)for(a=0,o=i.length;a<o;++a)e(i[a],r,n);else n.push(t)}(this.root,e,t),t}},{key:"getDepth",value:function(){return function e(t){var r,n,a,o=t.children,i=0;if(null!==o)for(r=0,n=o.length;r<n;++r)(a=1+e(o[r]))>i&&(i=a);return i}(this.root)}},{key:"findNodesByLevel",value:function(e){var t=[];return function e(t,r,n,a){var o,i,s=t.children;if(n===r)a.push(t);else if(null!==s)for(++n,o=0,i=s.length;o<i;++o)e(s[o],r,n,a)}(this.root,e,0,t),t}},{key:"raycast",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[];return q.intersectOctree(this,e.ray,t),t}},{key:"leaves",value:function(e){return new Z(this,e)}},{key:Symbol.iterator,value:function(){return new Z(this)}},{key:"min",get:function(){return this.root.min}},{key:"max",get:function(){return this.root.max}},{key:"children",get:function(){return this.root.children}}]),e}(),J=new M,$=function(e){function t(e,r){var n;return s(this,t),(n=p(this,d(t).call(this,e,r))).points=null,n.data=null,n}return f(t,e),c(t,[{key:"distanceToSquared",value:function(e){return J.copy(e).clamp(this.min,this.max).sub(e).lengthSquared()}},{key:"distanceToCenterSquared",value:function(e){var t=this.getCenter(J),r=e.x-t.x,n=e.y-t.x,a=e.z-t.z;return r*r+n*n+a*a}},{key:"contains",value:function(e,t){var r=this.min,n=this.max;return e.x>=r.x-t&&e.y>=r.y-t&&e.z>=r.z-t&&e.x<=n.x+t&&e.y<=n.y+t&&e.z<=n.z+t}},{key:"redistribute",value:function(e){var t,r,n,a,o,i,s,l=this.children,c=this.points,f=this.data;if(null!==l&&null!==c){for(t=0,n=c.length;t<n;++t)for(i=c[t],s=f[t],r=0,a=l.length;r<a;++r)if((o=l[r]).contains(i,e)){null===o.points&&(o.points=[],o.data=[]),o.points.push(i),o.data.push(s);break}this.points=null,this.data=null}}},{key:"merge",value:function(){var e=this.children;if(null!==e){var t,r,n,a=[],o=[];for(t=0,r=e.length;t<r;++t)null!==(n=e[t]).points&&(a=a.concat(n.points),o=o.concat(n.data));this.children=null,this.points=a,this.data=o}}}]),t}(F),ee=function(e){function r(e,n){var o,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,l=3<arguments.length&&void 0!==arguments[3]?arguments[3]:8,c=4<arguments.length&&void 0!==arguments[4]?arguments[4]:8;return s(this,r),(o=p(this,d(r).call(this,new $(e,n)))).bias=a(0,i),o.maxPoints=a(1,t(l)),o.maxDepth=a(0,t(c)),o.pointCount=0,o}return f(r,e),c(r,[{key:"countPoints",value:function(e){return w(e)}},{key:"insert",value:function(e,t){return b(e,t,this,this.root,0)}},{key:"remove",value:function(e){return T(e,this,this.root,null)}},{key:"get",value:function(e){return function e(t,r,n){var a,o,i,s=n.children,l=null;if(n.contains(t,r.bias))if(null!==s)for(a=0,o=s.length;null===l&&a<o;++a)l=e(t,r,s[a]);else if(null!==n.points)for(a=0,o=(i=n.points).length;null===l&&a<o;++a)t.equals(i[a])&&(l=n.data[a]);return l}(e,this,this.root)}},{key:"move",value:function(e,t){return function e(t,r,n,a,o,i){var s,l,c,f=a.children,d=null;if(a.contains(t,n.bias))if(a.contains(r,n.bias)){if(null!==f)for(++i,s=0,l=f.length;null===d&&s<l;++s)d=e(t,r,n,f[s],a,i);else if(null!==a.points)for(s=0,l=(c=a.points).length;s<l;++s)if(t.equals(c[s])){c[s].copy(r),d=a.data[s];break}}else b(r,d=T(t,n,a,o),n,o,i-1);return d}(e,t,this,this.root,null,0)}},{key:"findNearestPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1/0,r=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],n=_(e,t,r,this.root);return null!==n&&(n.point=n.point.clone()),n}},{key:"findPoints",value:function(e,t){var r=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],n=[];return S(e,t,r,this.root,n),n}},{key:"raycast",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[],n=h(d(r.prototype),"raycast",this).call(this,e);return 0<n.length&&m(n,e,t),t}}]),r}(K);e.CubicOctant=N,e.Flags=O,e.Octant=F,e.Octree=K,e.OctreeIterator=Z,e.OctreeRaycaster=q,e.PointOctant=$,e.PointOctree=ee,e.RayPointIntersection=I,e.edges=R,e.findEntryOctant=x,e.findNextOctant=g,e.intersectOctree=y,e.layout=A,e.testPoints=m,Object.defineProperty(e,"__esModule",{value:!0})}))},function(e,t,r){var n;!function(a){function o(e,t,r,n,a){this._listener=t,this._isOnce=r,this.context=n,this._signal=e,this._priority=a||0}function i(e,t){if("function"!=typeof e)throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}",t))}function s(){this._bindings=[],this._prevParams=null;var e=this;this.dispatch=function(){s.prototype.dispatch.apply(e,arguments)}}o.prototype={active:!0,params:null,execute:function(e){var t;return this.active&&this._listener&&(e=this.params?this.params.concat(e):e,t=this._listener.apply(this.context,e),this._isOnce&&this.detach()),t},detach:function(){return this.isBound()?this._signal.remove(this._listener,this.context):null},isBound:function(){return!!this._signal&&!!this._listener},isOnce:function(){return this._isOnce},getListener:function(){return this._listener},getSignal:function(){return this._signal},_destroy:function(){delete this._signal,delete this._listener,delete this.context},toString:function(){return"[SignalBinding isOnce:"+this._isOnce+", isBound:"+this.isBound()+", active:"+this.active+"]"}},s.prototype={VERSION:"1.0.0",memorize:!1,_shouldPropagate:!0,active:!0,_registerListener:function(e,t,r,n){var a=this._indexOfListener(e,r);if(-1!==a){if((e=this._bindings[a]).isOnce()!==t)throw Error("You cannot add"+(t?"":"Once")+"() then add"+(t?"Once":"")+"() the same listener without removing the relationship first.")}else e=new o(this,e,t,r,n),this._addBinding(e);return this.memorize&&this._prevParams&&e.execute(this._prevParams),e},_addBinding:function(e){var t=this._bindings.length;do{--t}while(this._bindings[t]&&e._priority<=this._bindings[t]._priority);this._bindings.splice(t+1,0,e)},_indexOfListener:function(e,t){for(var r,n=this._bindings.length;n--;)if((r=this._bindings[n])._listener===e&&r.context===t)return n;return-1},has:function(e,t){return-1!==this._indexOfListener(e,t)},add:function(e,t,r){return i(e,"add"),this._registerListener(e,!1,t,r)},addOnce:function(e,t,r){return i(e,"addOnce"),this._registerListener(e,!0,t,r)},remove:function(e,t){i(e,"remove");var r=this._indexOfListener(e,t);return-1!==r&&(this._bindings[r]._destroy(),this._bindings.splice(r,1)),e},removeAll:function(){for(var e=this._bindings.length;e--;)this._bindings[e]._destroy();this._bindings.length=0},getNumListeners:function(){return this._bindings.length},halt:function(){this._shouldPropagate=!1},dispatch:function(e){if(this.active){var t,r=Array.prototype.slice.call(arguments),n=this._bindings.length;if(this.memorize&&(this._prevParams=r),n){t=this._bindings.slice(),this._shouldPropagate=!0;do{n--}while(t[n]&&this._shouldPropagate&&!1!==t[n].execute(r))}}},forget:function(){this._prevParams=null},dispose:function(){this.removeAll(),delete this._bindings,delete this._prevParams},toString:function(){return"[Signal active:"+this.active+" numListeners:"+this.getNumListeners()+"]"}};var l=s;l.Signal=s,void 0===(n=function(){return l}.call(t,r,t,e))||(e.exports=n)}()},function(e,t,r){var n=function(){function e(e){return a.appendChild(e.dom),e}function t(e){for(var t=0;t<a.children.length;t++)a.children[t].style.display=t===e?"block":"none";r=e}var r=0,a=document.createElement("div");a.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",a.addEventListener("click",(function(e){e.preventDefault(),t(++r%a.children.length)}),!1);var o=(performance||Date).now(),i=o,s=0,l=e(new n.Panel("FPS","#0ff","#002")),c=e(new n.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var f=e(new n.Panel("MB","#f08","#201"));return t(0),{REVISION:16,dom:a,addPanel:e,showPanel:t,begin:function(){o=(performance||Date).now()},end:function(){s++;var e=(performance||Date).now();if(c.update(e-o,200),e>i+1e3&&(l.update(1e3*s/(e-i),100),i=e,s=0,f)){var t=performance.memory;f.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){o=this.end()},domElement:a,setMode:t}};n.Panel=function(e,t,r){var n=1/0,a=0,o=Math.round,i=o(window.devicePixelRatio||1),s=80*i,l=48*i,c=3*i,f=2*i,d=3*i,u=15*i,p=74*i,h=30*i,v=document.createElement("canvas");v.width=s,v.height=l,v.style.cssText="width:80px;height:48px";var m=v.getContext("2d");return m.font="bold "+9*i+"px Helvetica,Arial,sans-serif",m.textBaseline="top",m.fillStyle=r,m.fillRect(0,0,s,l),m.fillStyle=t,m.fillText(e,c,f),m.fillRect(d,u,p,h),m.fillStyle=r,m.globalAlpha=.9,m.fillRect(d,u,p,h),{dom:v,update:function(l,x){n=Math.min(n,l),a=Math.max(a,l),m.fillStyle=r,m.globalAlpha=1,m.fillRect(0,0,s,u),m.fillStyle=t,m.fillText(o(l)+" "+e+" ("+o(n)+"-"+o(a)+")",c,f),m.drawImage(v,d+i,u,p-i,h,d,u,p-i,h),m.fillRect(d+p-i,u,i,h),m.fillStyle=r,m.globalAlpha=.9,m.fillRect(d+p-i,u,i,o((1-l/x)*h))}}},e.exports=n},function(e,t,r){(function(r){var n;!function(){"use strict";var a=function(){this.init()};a.prototype={init:function(){var e=this||o;return e._counter=1e3,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var t=this||o;if(e=parseFloat(e),t.ctx||p(),void 0!==e&&e>=0&&e<=1){if(t._volume=e,t._muted)return t;t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e,o.ctx.currentTime);for(var r=0;r<t._howls.length;r++)if(!t._howls[r]._webAudio)for(var n=t._howls[r]._getSoundIds(),a=0;a<n.length;a++){var i=t._howls[r]._soundById(n[a]);i&&i._node&&(i._node.volume=i._volume*e)}return t}return t._volume},mute:function(e){var t=this||o;t.ctx||p(),t._muted=e,t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e?0:t._volume,o.ctx.currentTime);for(var r=0;r<t._howls.length;r++)if(!t._howls[r]._webAudio)for(var n=t._howls[r]._getSoundIds(),a=0;a<n.length;a++){var i=t._howls[r]._soundById(n[a]);i&&i._node&&(i._node.muted=!!e||i._muted)}return t},unload:function(){for(var e=this||o,t=e._howls.length-1;t>=0;t--)e._howls[t].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,p()),e},codecs:function(e){return(this||o)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||o;if(e.state=e.ctx&&e.ctx.state||"running",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{void 0===(new Audio).oncanplaythrough&&(e._canPlayEvent="canplay")}catch(t){e.noAudio=!0}else e.noAudio=!0;try{(new Audio).muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||o,t=null;try{t="undefined"!=typeof Audio?new Audio:null}catch(t){return e}if(!t||"function"!=typeof t.canPlayType)return e;var r=t.canPlayType("audio/mpeg;").replace(/^no$/,""),n=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),a=n&&parseInt(n[0].split("/")[1],10)<33;return e._codecs={mp3:!(a||!r&&!t.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!r,opus:!!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!t.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),aac:!!t.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!t.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(t.canPlayType("audio/x-m4a;")||t.canPlayType("audio/m4a;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(t.canPlayType("audio/x-mp4;")||t.canPlayType("audio/mp4;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(t.canPlayType("audio/x-flac;")||t.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_enableMobileAudio:function(){var e=this||o,t=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),r=!!("ontouchend"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(t||r)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var n=function(){o._autoResume();var t=e.ctx.createBufferSource();t.buffer=e._scratchBuffer,t.connect(e.ctx.destination),void 0===t.start?t.noteOn(0):t.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),t.onended=function(){t.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener("touchstart",n,!0),document.removeEventListener("touchend",n,!0)}};return document.addEventListener("touchstart",n,!0),document.addEventListener("touchend",n,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&o.usingWebAudio){for(var t=0;t<e._howls.length;t++)if(e._howls[t]._webAudio)for(var r=0;r<e._howls[t]._sounds.length;r++)if(!e._howls[t]._sounds[r]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout((function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then((function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())})))}),3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&o.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then((function(){e.state="running";for(var t=0;t<e._howls.length;t++)e._howls[t]._emit("resume")})),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var o=new a,i=function(e){e.src&&0!==e.src.length?this.init(e):console.error("An array of source files must be passed with any new Howl.")};i.prototype={init:function(e){var t=this;return o.ctx||p(),t._autoplay=e.autoplay||!1,t._format="string"!=typeof e.format?e.format:[e.format],t._html5=e.html5||!1,t._muted=e.mute||!1,t._loop=e.loop||!1,t._pool=e.pool||5,t._preload="boolean"!=typeof e.preload||e.preload,t._rate=e.rate||1,t._sprite=e.sprite||{},t._src="string"!=typeof e.src?e.src:[e.src],t._volume=void 0!==e.volume?e.volume:1,t._xhrWithCredentials=e.xhrWithCredentials||!1,t._duration=0,t._state="unloaded",t._sounds=[],t._endTimers={},t._queue=[],t._playLock=!1,t._onend=e.onend?[{fn:e.onend}]:[],t._onfade=e.onfade?[{fn:e.onfade}]:[],t._onload=e.onload?[{fn:e.onload}]:[],t._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],t._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],t._onpause=e.onpause?[{fn:e.onpause}]:[],t._onplay=e.onplay?[{fn:e.onplay}]:[],t._onstop=e.onstop?[{fn:e.onstop}]:[],t._onmute=e.onmute?[{fn:e.onmute}]:[],t._onvolume=e.onvolume?[{fn:e.onvolume}]:[],t._onrate=e.onrate?[{fn:e.onrate}]:[],t._onseek=e.onseek?[{fn:e.onseek}]:[],t._onresume=[],t._webAudio=o.usingWebAudio&&!t._html5,void 0!==o.ctx&&o.ctx&&o.mobileAutoEnable&&o._enableMobileAudio(),o._howls.push(t),t._autoplay&&t._queue.push({event:"play",action:function(){t.play()}}),t._preload&&t.load(),t},load:function(){var e=null;if(o.noAudio)this._emit("loaderror",null,"No audio support.");else{"string"==typeof this._src&&(this._src=[this._src]);for(var t=0;t<this._src.length;t++){var r,n;if(this._format&&this._format[t])r=this._format[t];else{if("string"!=typeof(n=this._src[t])){this._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}(r=/^data:audio\/([^;,]+);/i.exec(n))||(r=/\.([^.]+)$/.exec(n.split("?",1)[0])),r&&(r=r[1].toLowerCase())}if(r||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),r&&o.codecs(r)){e=this._src[t];break}}if(e)return this._src=e,this._state="loading","https:"===window.location.protocol&&"http:"===e.slice(0,5)&&(this._html5=!0,this._webAudio=!1),new s(this),this._webAudio&&c(this),this;this._emit("loaderror",null,"No codec support for selected audio sources.")}},play:function(e,t){var r=this,n=null;if("number"==typeof e)n=e,e=null;else{if("string"==typeof e&&"loaded"===r._state&&!r._sprite[e])return null;if(void 0===e){e="__default";for(var a=0,i=0;i<r._sounds.length;i++)r._sounds[i]._paused&&!r._sounds[i]._ended&&(a++,n=r._sounds[i]._id);1===a?e=null:n=null}}var s=n?r._soundById(n):r._inactiveSound();if(!s)return null;if(n&&!e&&(e=s._sprite||"__default"),"loaded"!==r._state){s._sprite=e,s._ended=!1;var l=s._id;return r._queue.push({event:"play",action:function(){r.play(l)}}),l}if(n&&!s._paused)return t||setTimeout((function(){r._emit("play",s._id)}),0),s._id;r._webAudio&&o._autoResume();var c=Math.max(0,s._seek>0?s._seek:r._sprite[e][0]/1e3),f=Math.max(0,(r._sprite[e][0]+r._sprite[e][1])/1e3-c),d=1e3*f/Math.abs(s._rate);s._paused=!1,s._ended=!1,s._sprite=e,s._seek=c,s._start=r._sprite[e][0]/1e3,s._stop=(r._sprite[e][0]+r._sprite[e][1])/1e3,s._loop=!(!s._loop&&!r._sprite[e][2]);var u=s._node;if(r._webAudio){var p=function(){r._refreshBuffer(s);var e=s._muted||r._muted?0:s._volume;u.gain.setValueAtTime(e,o.ctx.currentTime),s._playStart=o.ctx.currentTime,void 0===u.bufferSource.start?s._loop?u.bufferSource.noteGrainOn(0,c,86400):u.bufferSource.noteGrainOn(0,c,f):s._loop?u.bufferSource.start(0,c,86400):u.bufferSource.start(0,c,f),d!==1/0&&(r._endTimers[s._id]=setTimeout(r._ended.bind(r,s),d)),t||setTimeout((function(){r._emit("play",s._id)}),0)};"running"===o.state?p():(r.once("resume",p),r._clearTimer(s._id))}else{var h=function(){u.currentTime=c,u.muted=s._muted||r._muted||o._muted||u.muted,u.volume=s._volume*o.volume(),u.playbackRate=s._rate;try{var e=u.play();if("undefined"!=typeof Promise&&e instanceof Promise&&(r._playLock=!0,e.then((function(){r._playLock=!1,r._loadQueue()}))),u.paused)return void r._emit("playerror",s._id,"Playback was unable to start. This is most commonly an issue on mobile devices where playback was not within a user interaction.");d!==1/0&&(r._endTimers[s._id]=setTimeout(r._ended.bind(r,s),d)),t||r._emit("play",s._id)}catch(e){r._emit("playerror",s._id,e)}},v=window&&window.ejecta||!u.readyState&&o._navigator.isCocoonJS;if(4===u.readyState||v)h();else{var m=function(){h(),u.removeEventListener(o._canPlayEvent,m,!1)};u.addEventListener(o._canPlayEvent,m,!1),r._clearTimer(s._id)}}return s._id},pause:function(e){var t=this;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"pause",action:function(){t.pause(e)}}),t;for(var r=t._getSoundIds(e),n=0;n<r.length;n++){t._clearTimer(r[n]);var a=t._soundById(r[n]);if(a&&!a._paused&&(a._seek=t.seek(r[n]),a._rateSeek=0,a._paused=!0,t._stopFade(r[n]),a._node))if(t._webAudio){if(!a._node.bufferSource)continue;void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),t._cleanBuffer(a._node)}else isNaN(a._node.duration)&&a._node.duration!==1/0||a._node.pause();arguments[1]||t._emit("pause",a?a._id:null)}return t},stop:function(e,t){var r=this;if("loaded"!==r._state)return r._queue.push({event:"stop",action:function(){r.stop(e)}}),r;for(var n=r._getSoundIds(e),a=0;a<n.length;a++){r._clearTimer(n[a]);var o=r._soundById(n[a]);o&&(o._seek=o._start||0,o._rateSeek=0,o._paused=!0,o._ended=!0,r._stopFade(n[a]),o._node&&(r._webAudio?o._node.bufferSource&&(void 0===o._node.bufferSource.stop?o._node.bufferSource.noteOff(0):o._node.bufferSource.stop(0),r._cleanBuffer(o._node)):isNaN(o._node.duration)&&o._node.duration!==1/0||(o._node.currentTime=o._start||0,o._node.pause())),t||r._emit("stop",o._id))}return r},mute:function(e,t){var r=this;if("loaded"!==r._state)return r._queue.push({event:"mute",action:function(){r.mute(e,t)}}),r;if(void 0===t){if("boolean"!=typeof e)return r._muted;r._muted=e}for(var n=r._getSoundIds(t),a=0;a<n.length;a++){var i=r._soundById(n[a]);i&&(i._muted=e,i._interval&&r._stopFade(i._id),r._webAudio&&i._node?i._node.gain.setValueAtTime(e?0:i._volume,o.ctx.currentTime):i._node&&(i._node.muted=!!o._muted||e),r._emit("mute",i._id))}return r},volume:function(){var e,t,r,n=this,a=arguments;if(0===a.length)return n._volume;if(1===a.length||2===a.length&&void 0===a[1]){var i=n._getSoundIds(),s=i.indexOf(a[0]);s>=0?t=parseInt(a[0],10):e=parseFloat(a[0])}else a.length>=2&&(e=parseFloat(a[0]),t=parseInt(a[1],10));if(!(void 0!==e&&e>=0&&e<=1))return(r=t?n._soundById(t):n._sounds[0])?r._volume:0;if("loaded"!==n._state)return n._queue.push({event:"volume",action:function(){n.volume.apply(n,a)}}),n;void 0===t&&(n._volume=e),t=n._getSoundIds(t);for(var l=0;l<t.length;l++)(r=n._soundById(t[l]))&&(r._volume=e,a[2]||n._stopFade(t[l]),n._webAudio&&r._node&&!r._muted?r._node.gain.setValueAtTime(e,o.ctx.currentTime):r._node&&!r._muted&&(r._node.volume=e*o.volume()),n._emit("volume",r._id));return n},fade:function(e,t,r,n){var a=this;if("loaded"!==a._state)return a._queue.push({event:"fade",action:function(){a.fade(e,t,r,n)}}),a;a.volume(e,n);for(var i=a._getSoundIds(n),s=0;s<i.length;s++){var l=a._soundById(i[s]);if(l){if(n||a._stopFade(i[s]),a._webAudio&&!l._muted){var c=o.ctx.currentTime,f=c+r/1e3;l._volume=e,l._node.gain.setValueAtTime(e,c),l._node.gain.linearRampToValueAtTime(t,f)}a._startFadeInterval(l,e,t,r,i[s],void 0===n)}}return a},_startFadeInterval:function(e,t,r,n,a,o){var i=this,s=t,l=r-t,c=Math.abs(l/.01),f=Math.max(4,c>0?n/c:n),d=Date.now();e._fadeTo=r,e._interval=setInterval((function(){var a=(Date.now()-d)/n;d=Date.now(),s+=l*a,s=Math.max(0,s),s=Math.min(1,s),s=Math.round(100*s)/100,i._webAudio?e._volume=s:i.volume(s,e._id,!0),o&&(i._volume=s),(r<t&&s<=r||r>t&&s>=r)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,i.volume(r,e._id),i._emit("fade",e._id))}),f)},_stopFade:function(e){var t=this._soundById(e);return t&&t._interval&&(this._webAudio&&t._node.gain.cancelScheduledValues(o.ctx.currentTime),clearInterval(t._interval),t._interval=null,this.volume(t._fadeTo,e),t._fadeTo=null,this._emit("fade",e)),this},loop:function(){var e,t,r,n=this,a=arguments;if(0===a.length)return n._loop;if(1===a.length){if("boolean"!=typeof a[0])return!!(r=n._soundById(parseInt(a[0],10)))&&r._loop;e=a[0],n._loop=e}else 2===a.length&&(e=a[0],t=parseInt(a[1],10));for(var o=n._getSoundIds(t),i=0;i<o.length;i++)(r=n._soundById(o[i]))&&(r._loop=e,n._webAudio&&r._node&&r._node.bufferSource&&(r._node.bufferSource.loop=e,e&&(r._node.bufferSource.loopStart=r._start||0,r._node.bufferSource.loopEnd=r._stop)));return n},rate:function(){var e,t,r,n=this,a=arguments;if(0===a.length)t=n._sounds[0]._id;else if(1===a.length){var i=n._getSoundIds(),s=i.indexOf(a[0]);s>=0?t=parseInt(a[0],10):e=parseFloat(a[0])}else 2===a.length&&(e=parseFloat(a[0]),t=parseInt(a[1],10));if("number"!=typeof e)return(r=n._soundById(t))?r._rate:n._rate;if("loaded"!==n._state)return n._queue.push({event:"rate",action:function(){n.rate.apply(n,a)}}),n;void 0===t&&(n._rate=e),t=n._getSoundIds(t);for(var l=0;l<t.length;l++)if(r=n._soundById(t[l])){r._rateSeek=n.seek(t[l]),r._playStart=n._webAudio?o.ctx.currentTime:r._playStart,r._rate=e,n._webAudio&&r._node&&r._node.bufferSource?r._node.bufferSource.playbackRate.setValueAtTime(e,o.ctx.currentTime):r._node&&(r._node.playbackRate=e);var c=n.seek(t[l]),f=(n._sprite[r._sprite][0]+n._sprite[r._sprite][1])/1e3-c,d=1e3*f/Math.abs(r._rate);!n._endTimers[t[l]]&&r._paused||(n._clearTimer(t[l]),n._endTimers[t[l]]=setTimeout(n._ended.bind(n,r),d)),n._emit("rate",r._id)}return n},seek:function(){var e,t,r=this,n=arguments;if(0===n.length)t=r._sounds[0]._id;else if(1===n.length){var a=r._getSoundIds(),i=a.indexOf(n[0]);i>=0?t=parseInt(n[0],10):r._sounds.length&&(t=r._sounds[0]._id,e=parseFloat(n[0]))}else 2===n.length&&(e=parseFloat(n[0]),t=parseInt(n[1],10));if(void 0===t)return r;if("loaded"!==r._state)return r._queue.push({event:"seek",action:function(){r.seek.apply(r,n)}}),r;var s=r._soundById(t);if(s){if(!("number"==typeof e&&e>=0)){if(r._webAudio){var l=r.playing(t)?o.ctx.currentTime-s._playStart:0,c=s._rateSeek?s._rateSeek-s._seek:0;return s._seek+(c+l*Math.abs(s._rate))}return s._node.currentTime}var f=r.playing(t);f&&r.pause(t,!0),s._seek=e,s._ended=!1,r._clearTimer(t),f&&r.play(t,!0),!r._webAudio&&s._node&&(s._node.currentTime=e),r._emit("seek",t)}return r},playing:function(e){if("number"==typeof e){var t=this._soundById(e);return!!t&&!t._paused}for(var r=0;r<this._sounds.length;r++)if(!this._sounds[r]._paused)return!0;return!1},duration:function(e){var t=this._duration,r=this._soundById(e);return r&&(t=this._sprite[r._sprite][1]/1e3),t},state:function(){return this._state},unload:function(){for(var e=this,t=e._sounds,r=0;r<t.length;r++){if(t[r]._paused||e.stop(t[r]._id),!e._webAudio)/MSIE |Trident\//.test(o._navigator&&o._navigator.userAgent)||(t[r]._node.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),t[r]._node.removeEventListener("error",t[r]._errorFn,!1),t[r]._node.removeEventListener(o._canPlayEvent,t[r]._loadFn,!1);delete t[r]._node,e._clearTimer(t[r]._id);var n=o._howls.indexOf(e);n>=0&&o._howls.splice(n,1)}var a=!0;for(r=0;r<o._howls.length;r++)if(o._howls[r]._src===e._src){a=!1;break}return l&&a&&delete l[e._src],o.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,t,r,n){var a=this["_on"+e];return"function"==typeof t&&a.push(n?{id:r,fn:t,once:n}:{id:r,fn:t}),this},off:function(e,t,r){var n=this["_on"+e],a=0;if("number"==typeof t&&(r=t,t=null),t||r)for(a=0;a<n.length;a++){var o=r===n[a].id;if(t===n[a].fn&&o||!t&&o){n.splice(a,1);break}}else if(e)this["_on"+e]=[];else{var i=Object.keys(this);for(a=0;a<i.length;a++)0===i[a].indexOf("_on")&&Array.isArray(this[i[a]])&&(this[i[a]]=[])}return this},once:function(e,t,r){return this.on(e,t,r,1),this},_emit:function(e,t,r){for(var n=this["_on"+e],a=n.length-1;a>=0;a--)n[a].id&&n[a].id!==t&&"load"!==e||(setTimeout(function(e){e.call(this,t,r)}.bind(this,n[a].fn),0),n[a].once&&this.off(e,n[a].fn,n[a].id));return this},_loadQueue:function(){var e=this;if(e._queue.length>0){var t=e._queue[0];e.once(t.event,(function(){e._queue.shift(),e._loadQueue()})),t.action()}return e},_ended:function(e){var t=e._sprite;if(!this._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(this._ended.bind(this,e),100),this;var r=!(!e._loop&&!this._sprite[t][2]);if(this._emit("end",e._id),!this._webAudio&&r&&this.stop(e._id,!0).play(e._id),this._webAudio&&r){this._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=o.ctx.currentTime;var n=1e3*(e._stop-e._start)/Math.abs(e._rate);this._endTimers[e._id]=setTimeout(this._ended.bind(this,e),n)}return this._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,this._clearTimer(e._id),this._cleanBuffer(e._node),o._autoSuspend()),this._webAudio||r||this.stop(e._id),this},_clearTimer:function(e){return this._endTimers[e]&&(clearTimeout(this._endTimers[e]),delete this._endTimers[e]),this},_soundById:function(e){for(var t=0;t<this._sounds.length;t++)if(e===this._sounds[t]._id)return this._sounds[t];return null},_inactiveSound:function(){this._drain();for(var e=0;e<this._sounds.length;e++)if(this._sounds[e]._ended)return this._sounds[e].reset();return new s(this)},_drain:function(){var e=this._pool,t=0,r=0;if(!(this._sounds.length<e)){for(r=0;r<this._sounds.length;r++)this._sounds[r]._ended&&t++;for(r=this._sounds.length-1;r>=0;r--){if(t<=e)return;this._sounds[r]._ended&&(this._webAudio&&this._sounds[r]._node&&this._sounds[r]._node.disconnect(0),this._sounds.splice(r,1),t--)}}},_getSoundIds:function(e){if(void 0===e){for(var t=[],r=0;r<this._sounds.length;r++)t.push(this._sounds[r]._id);return t}return[e]},_refreshBuffer:function(e){return e._node.bufferSource=o.ctx.createBufferSource(),e._node.bufferSource.buffer=l[this._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,o.ctx.currentTime),this},_cleanBuffer:function(e){if(o._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=o._scratchBuffer}catch(e){}}return e.bufferSource=null,this}};var s=function(e){this._parent=e,this.init()};s.prototype={init:function(){var e=this._parent;return this._muted=e._muted,this._loop=e._loop,this._volume=e._volume,this._rate=e._rate,this._seek=0,this._paused=!0,this._ended=!0,this._sprite="__default",this._id=++o._counter,e._sounds.push(this),this.create(),this},create:function(){var e=this._parent,t=o._muted||this._muted||this._parent._muted?0:this._volume;return e._webAudio?(this._node=void 0===o.ctx.createGain?o.ctx.createGainNode():o.ctx.createGain(),this._node.gain.setValueAtTime(t,o.ctx.currentTime),this._node.paused=!0,this._node.connect(o.masterGain)):(this._node=new Audio,this._errorFn=this._errorListener.bind(this),this._node.addEventListener("error",this._errorFn,!1),this._loadFn=this._loadListener.bind(this),this._node.addEventListener(o._canPlayEvent,this._loadFn,!1),this._node.src=e._src,this._node.preload="auto",this._node.volume=t*o.volume(),this._node.load()),this},reset:function(){var e=this._parent;return this._muted=e._muted,this._loop=e._loop,this._volume=e._volume,this._rate=e._rate,this._seek=0,this._rateSeek=0,this._paused=!0,this._ended=!0,this._sprite="__default",this._id=++o._counter,this},_errorListener:function(){this._parent._emit("loaderror",this._id,this._node.error?this._node.error.code:0),this._node.removeEventListener("error",this._errorFn,!1)},_loadListener:function(){var e=this._parent;e._duration=Math.ceil(10*this._node.duration)/10,0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue()),this._node.removeEventListener(o._canPlayEvent,this._loadFn,!1)}};var l={},c=function(e){var t=e._src;if(l[t])return e._duration=l[t].duration,void u(e);if(/^data:[^;]+;base64,/.test(t)){for(var r=atob(t.split(",")[1]),n=new Uint8Array(r.length),a=0;a<r.length;++a)n[a]=r.charCodeAt(a);d(n.buffer,e)}else{var o=new XMLHttpRequest;o.open("GET",t,!0),o.withCredentials=e._xhrWithCredentials,o.responseType="arraybuffer",o.onload=function(){var t=(o.status+"")[0];"0"===t||"2"===t||"3"===t?d(o.response,e):e._emit("loaderror",null,"Failed loading audio file with status: "+o.status+".")},o.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete l[t],e.load())},f(o)}},f=function(e){try{e.send()}catch(t){e.onerror()}},d=function(e,t){o.ctx.decodeAudioData(e,(function(e){e&&t._sounds.length>0&&(l[t._src]=e,u(t,e))}),(function(){t._emit("loaderror",null,"Decoding audio data failed.")}))},u=function(e,t){t&&!e._duration&&(e._duration=t.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},p=function(){try{"undefined"!=typeof AudioContext?o.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?o.ctx=new webkitAudioContext:o.usingWebAudio=!1}catch(e){o.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(o._navigator&&o._navigator.platform),t=o._navigator&&o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),r=t?parseInt(t[1],10):null;if(e&&r&&r<9){var n=/safari/.test(o._navigator&&o._navigator.userAgent.toLowerCase());(o._navigator&&o._navigator.standalone&&!n||o._navigator&&!o._navigator.standalone&&!n)&&(o.usingWebAudio=!1)}o.usingWebAudio&&(o.masterGain=void 0===o.ctx.createGain?o.ctx.createGainNode():o.ctx.createGain(),o.masterGain.gain.setValueAtTime(o._muted?0:1,o.ctx.currentTime),o.masterGain.connect(o.ctx.destination)),o._setup()};void 0===(n=function(){return{Howler:o,Howl:i}}.apply(t,[]))||(e.exports=n),t.Howler=o,t.Howl=i,"undefined"!=typeof window?(window.HowlerGlobal=a,window.Howler=o,window.Howl=i,window.Sound=s):void 0!==r&&(r.HowlerGlobal=a,r.Howler=o,r.Howl=i,r.Sound=s)}(),function(){"use strict";var e;HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(e){if(!this.ctx||!this.ctx.listener)return this;for(var t=this._howls.length-1;t>=0;t--)this._howls[t].stereo(e);return this},HowlerGlobal.prototype.pos=function(e,t,r){return this.ctx&&this.ctx.listener?(t="number"!=typeof t?this._pos[1]:t,r="number"!=typeof r?this._pos[2]:r,"number"!=typeof e?this._pos:(this._pos=[e,t,r],this.ctx.listener.setPosition(this._pos[0],this._pos[1],this._pos[2]),this)):this},HowlerGlobal.prototype.orientation=function(e,t,r,n,a,o){if(!this.ctx||!this.ctx.listener)return this;var i=this._orientation;return t="number"!=typeof t?i[1]:t,r="number"!=typeof r?i[2]:r,n="number"!=typeof n?i[3]:n,a="number"!=typeof a?i[4]:a,o="number"!=typeof o?i[5]:o,"number"!=typeof e?i:(this._orientation=[e,t,r,n,a,o],this.ctx.listener.setOrientation(e,t,r,n,a,o),this)},Howl.prototype.init=(e=Howl.prototype.init,function(t){return this._orientation=t.orientation||[1,0,0],this._stereo=t.stereo||null,this._pos=t.pos||null,this._pannerAttr={coneInnerAngle:void 0!==t.coneInnerAngle?t.coneInnerAngle:360,coneOuterAngle:void 0!==t.coneOuterAngle?t.coneOuterAngle:360,coneOuterGain:void 0!==t.coneOuterGain?t.coneOuterGain:0,distanceModel:void 0!==t.distanceModel?t.distanceModel:"inverse",maxDistance:void 0!==t.maxDistance?t.maxDistance:1e4,panningModel:void 0!==t.panningModel?t.panningModel:"HRTF",refDistance:void 0!==t.refDistance?t.refDistance:1,rolloffFactor:void 0!==t.rolloffFactor?t.rolloffFactor:1},this._onstereo=t.onstereo?[{fn:t.onstereo}]:[],this._onpos=t.onpos?[{fn:t.onpos}]:[],this._onorientation=t.onorientation?[{fn:t.onorientation}]:[],e.call(this,t)}),Howl.prototype.stereo=function(e,r){var n=this;if(!n._webAudio)return n;if("loaded"!==n._state)return n._queue.push({event:"stereo",action:function(){n.stereo(e,r)}}),n;var a=void 0===Howler.ctx.createStereoPanner?"spatial":"stereo";if(void 0===r){if("number"!=typeof e)return n._stereo;n._stereo=e,n._pos=[e,0,0]}for(var o=n._getSoundIds(r),i=0;i<o.length;i++){var s=n._soundById(o[i]);if(s){if("number"!=typeof e)return s._stereo;s._stereo=e,s._pos=[e,0,0],s._node&&(s._pannerAttr.panningModel="equalpower",s._panner&&s._panner.pan||t(s,a),"spatial"===a?s._panner.setPosition(e,0,0):s._panner.pan.setValueAtTime(e,Howler.ctx.currentTime)),n._emit("stereo",s._id)}}return n},Howl.prototype.pos=function(e,r,n,a){var o=this;if(!o._webAudio)return o;if("loaded"!==o._state)return o._queue.push({event:"pos",action:function(){o.pos(e,r,n,a)}}),o;if(r="number"!=typeof r?0:r,n="number"!=typeof n?-.5:n,void 0===a){if("number"!=typeof e)return o._pos;o._pos=[e,r,n]}for(var i=o._getSoundIds(a),s=0;s<i.length;s++){var l=o._soundById(i[s]);if(l){if("number"!=typeof e)return l._pos;l._pos=[e,r,n],l._node&&(l._panner&&!l._panner.pan||t(l,"spatial"),l._panner.setPosition(e,r,n)),o._emit("pos",l._id)}}return o},Howl.prototype.orientation=function(e,r,n,a){var o=this;if(!o._webAudio)return o;if("loaded"!==o._state)return o._queue.push({event:"orientation",action:function(){o.orientation(e,r,n,a)}}),o;if(r="number"!=typeof r?o._orientation[1]:r,n="number"!=typeof n?o._orientation[2]:n,void 0===a){if("number"!=typeof e)return o._orientation;o._orientation=[e,r,n]}for(var i=o._getSoundIds(a),s=0;s<i.length;s++){var l=o._soundById(i[s]);if(l){if("number"!=typeof e)return l._orientation;l._orientation=[e,r,n],l._node&&(l._panner||(l._pos||(l._pos=o._pos||[0,0,-.5]),t(l,"spatial")),l._panner.setOrientation(e,r,n)),o._emit("orientation",l._id)}}return o},Howl.prototype.pannerAttr=function(){var e,r,n,a=this,o=arguments;if(!a._webAudio)return a;if(0===o.length)return a._pannerAttr;if(1===o.length){if("object"!=typeof o[0])return(n=a._soundById(parseInt(o[0],10)))?n._pannerAttr:a._pannerAttr;e=o[0],void 0===r&&(e.pannerAttr||(e.pannerAttr={coneInnerAngle:e.coneInnerAngle,coneOuterAngle:e.coneOuterAngle,coneOuterGain:e.coneOuterGain,distanceModel:e.distanceModel,maxDistance:e.maxDistance,refDistance:e.refDistance,rolloffFactor:e.rolloffFactor,panningModel:e.panningModel}),a._pannerAttr={coneInnerAngle:void 0!==e.pannerAttr.coneInnerAngle?e.pannerAttr.coneInnerAngle:a._coneInnerAngle,coneOuterAngle:void 0!==e.pannerAttr.coneOuterAngle?e.pannerAttr.coneOuterAngle:a._coneOuterAngle,coneOuterGain:void 0!==e.pannerAttr.coneOuterGain?e.pannerAttr.coneOuterGain:a._coneOuterGain,distanceModel:void 0!==e.pannerAttr.distanceModel?e.pannerAttr.distanceModel:a._distanceModel,maxDistance:void 0!==e.pannerAttr.maxDistance?e.pannerAttr.maxDistance:a._maxDistance,refDistance:void 0!==e.pannerAttr.refDistance?e.pannerAttr.refDistance:a._refDistance,rolloffFactor:void 0!==e.pannerAttr.rolloffFactor?e.pannerAttr.rolloffFactor:a._rolloffFactor,panningModel:void 0!==e.pannerAttr.panningModel?e.pannerAttr.panningModel:a._panningModel})}else 2===o.length&&(e=o[0],r=parseInt(o[1],10));for(var i=a._getSoundIds(r),s=0;s<i.length;s++)if(n=a._soundById(i[s])){var l=n._pannerAttr;l={coneInnerAngle:void 0!==e.coneInnerAngle?e.coneInnerAngle:l.coneInnerAngle,coneOuterAngle:void 0!==e.coneOuterAngle?e.coneOuterAngle:l.coneOuterAngle,coneOuterGain:void 0!==e.coneOuterGain?e.coneOuterGain:l.coneOuterGain,distanceModel:void 0!==e.distanceModel?e.distanceModel:l.distanceModel,maxDistance:void 0!==e.maxDistance?e.maxDistance:l.maxDistance,refDistance:void 0!==e.refDistance?e.refDistance:l.refDistance,rolloffFactor:void 0!==e.rolloffFactor?e.rolloffFactor:l.rolloffFactor,panningModel:void 0!==e.panningModel?e.panningModel:l.panningModel};var c=n._panner;c?(c.coneInnerAngle=l.coneInnerAngle,c.coneOuterAngle=l.coneOuterAngle,c.coneOuterGain=l.coneOuterGain,c.distanceModel=l.distanceModel,c.maxDistance=l.maxDistance,c.refDistance=l.refDistance,c.rolloffFactor=l.rolloffFactor,c.panningModel=l.panningModel):(n._pos||(n._pos=a._pos||[0,0,-.5]),t(n,"spatial"))}return a},Sound.prototype.init=function(e){return function(){var t=this._parent;this._orientation=t._orientation,this._stereo=t._stereo,this._pos=t._pos,this._pannerAttr=t._pannerAttr,e.call(this),this._stereo?t.stereo(this._stereo):this._pos&&t.pos(this._pos[0],this._pos[1],this._pos[2],this._id)}}(Sound.prototype.init),Sound.prototype.reset=function(e){return function(){var t=this._parent;return this._orientation=t._orientation,this._pos=t._pos,this._pannerAttr=t._pannerAttr,e.call(this)}}(Sound.prototype.reset);var t=function(e,t){"spatial"===(t=t||"spatial")?(e._panner=Howler.ctx.createPanner(),e._panner.coneInnerAngle=e._pannerAttr.coneInnerAngle,e._panner.coneOuterAngle=e._pannerAttr.coneOuterAngle,e._panner.coneOuterGain=e._pannerAttr.coneOuterGain,e._panner.distanceModel=e._pannerAttr.distanceModel,e._panner.maxDistance=e._pannerAttr.maxDistance,e._panner.refDistance=e._pannerAttr.refDistance,e._panner.rolloffFactor=e._pannerAttr.rolloffFactor,e._panner.panningModel=e._pannerAttr.panningModel,e._panner.setPosition(e._pos[0],e._pos[1],e._pos[2]),e._panner.setOrientation(e._orientation[0],e._orientation[1],e._orientation[2])):(e._panner=Howler.ctx.createStereoPanner(),e._panner.pan.setValueAtTime(e._stereo,Howler.ctx.currentTime)),e._panner.connect(e._node),e._paused||e._parent.pause(e._id,!0).play(e._id,!0)}}()}).call(this,r(4))},function(e,t){THREE.OrbitControls=function(e,t){var r,n,a,o,i,s;void 0===t&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=e,this.domElement=t,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return v.phi},this.getAzimuthalAngle=function(){return v.theta},this.saveState=function(){l.target0.copy(l.target),l.position0.copy(l.object.position),l.zoom0=l.object.zoom},this.reset=function(){l.target.copy(l.target0),l.object.position.copy(l.position0),l.object.zoom=l.zoom0,l.object.updateProjectionMatrix(),l.dispatchEvent(c),l.update(),p=u.NONE},this.update=(r=new THREE.Vector3,n=(new THREE.Quaternion).setFromUnitVectors(e.up,new THREE.Vector3(0,1,0)),a=n.clone().inverse(),o=new THREE.Vector3,i=new THREE.Quaternion,s=2*Math.PI,function(){var e=l.object.position;r.copy(e).sub(l.target),r.applyQuaternion(n),v.setFromVector3(r),l.autoRotate&&p===u.NONE&&L(2*Math.PI/60/60*l.autoRotateSpeed),l.enableDamping?(v.theta+=m.theta*l.dampingFactor,v.phi+=m.phi*l.dampingFactor):(v.theta+=m.theta,v.phi+=m.phi);var t=l.minAzimuthAngle,f=l.maxAzimuthAngle;return isFinite(t)&&isFinite(f)&&(t<-Math.PI?t+=s:t>Math.PI&&(t-=s),f<-Math.PI?f+=s:f>Math.PI&&(f-=s),v.theta=t<f?Math.max(t,Math.min(f,v.theta)):v.theta>(t+f)/2?Math.max(t,v.theta):Math.min(f,v.theta)),v.phi=Math.max(l.minPolarAngle,Math.min(l.maxPolarAngle,v.phi)),v.makeSafe(),v.radius*=x,v.radius=Math.max(l.minDistance,Math.min(l.maxDistance,v.radius)),!0===l.enableDamping?l.target.addScaledVector(g,l.dampingFactor):l.target.add(g),r.setFromSpherical(v),r.applyQuaternion(a),e.copy(l.target).add(r),l.object.lookAt(l.target),!0===l.enableDamping?(m.theta*=1-l.dampingFactor,m.phi*=1-l.dampingFactor,g.multiplyScalar(1-l.dampingFactor)):(m.set(0,0,0),g.set(0,0,0)),x=1,!!(y||o.distanceToSquared(l.object.position)>h||8*(1-i.dot(l.object.quaternion))>h)&&(l.dispatchEvent(c),o.copy(l.object.position),i.copy(l.object.quaternion),y=!1,!0)}),this.dispose=function(){l.domElement.removeEventListener("contextmenu",ee,!1),l.domElement.removeEventListener("mousedown",q,!1),l.domElement.removeEventListener("wheel",Z,!1),l.domElement.removeEventListener("touchstart",K,!1),l.domElement.removeEventListener("touchend",$,!1),l.domElement.removeEventListener("touchmove",J,!1),l.domElement.ownerDocument.removeEventListener("mousemove",X,!1),l.domElement.ownerDocument.removeEventListener("mouseup",Y,!1),l.domElement.removeEventListener("keydown",Q,!1)};var l=this,c={type:"change"},f={type:"start"},d={type:"end"},u={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},p=u.NONE,h=1e-6,v=new THREE.Spherical,m=new THREE.Spherical,x=1,g=new THREE.Vector3,y=!1,E=new THREE.Vector2,w=new THREE.Vector2,b=new THREE.Vector2,T=new THREE.Vector2,_=new THREE.Vector2,S=new THREE.Vector2,R=new THREE.Vector2,A=new THREE.Vector2,M=new THREE.Vector2;function C(){return Math.pow(.95,l.zoomSpeed)}function L(e){m.theta-=e}function H(e){m.phi-=e}var P,z=(P=new THREE.Vector3,function(e,t){P.setFromMatrixColumn(t,0),P.multiplyScalar(-e),g.add(P)}),k=function(){var e=new THREE.Vector3;return function(t,r){!0===l.screenSpacePanning?e.setFromMatrixColumn(r,1):(e.setFromMatrixColumn(r,0),e.crossVectors(l.object.up,e)),e.multiplyScalar(t),g.add(e)}}(),N=function(){var e=new THREE.Vector3;return function(t,r){var n=l.domElement;if(l.object.isPerspectiveCamera){var a=l.object.position;e.copy(a).sub(l.target);var o=e.length();o*=Math.tan(l.object.fov/2*Math.PI/180),z(2*t*o/n.clientHeight,l.object.matrix),k(2*r*o/n.clientHeight,l.object.matrix)}else l.object.isOrthographicCamera?(z(t*(l.object.right-l.object.left)/l.object.zoom/n.clientWidth,l.object.matrix),k(r*(l.object.top-l.object.bottom)/l.object.zoom/n.clientHeight,l.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),l.enablePan=!1)}}();function D(e){l.object.isPerspectiveCamera?x/=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom*e)),l.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function F(e){l.object.isPerspectiveCamera?x*=e:l.object.isOrthographicCamera?(l.object.zoom=Math.max(l.minZoom,Math.min(l.maxZoom,l.object.zoom/e)),l.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),l.enableZoom=!1)}function I(e){E.set(e.clientX,e.clientY)}function O(e){T.set(e.clientX,e.clientY)}function U(e){if(1==e.touches.length)E.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);E.set(t,r)}}function G(e){if(1==e.touches.length)T.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);T.set(t,r)}}function B(e){var t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,n=Math.sqrt(t*t+r*r);R.set(0,n)}function V(e){if(1==e.touches.length)w.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);w.set(t,r)}b.subVectors(w,E).multiplyScalar(l.rotateSpeed);var n=l.domElement;L(2*Math.PI*b.x/n.clientHeight),H(2*Math.PI*b.y/n.clientHeight),E.copy(w)}function j(e){if(1==e.touches.length)_.set(e.touches[0].pageX,e.touches[0].pageY);else{var t=.5*(e.touches[0].pageX+e.touches[1].pageX),r=.5*(e.touches[0].pageY+e.touches[1].pageY);_.set(t,r)}S.subVectors(_,T).multiplyScalar(l.panSpeed),N(S.x,S.y),T.copy(_)}function W(e){var t=e.touches[0].pageX-e.touches[1].pageX,r=e.touches[0].pageY-e.touches[1].pageY,n=Math.sqrt(t*t+r*r);A.set(0,n),M.set(0,Math.pow(A.y/R.y,l.zoomSpeed)),D(M.y),R.copy(A)}function q(e){if(!1!==l.enabled){var t;switch(e.preventDefault(),l.domElement.focus?l.domElement.focus():window.focus(),e.button){case 0:t=l.mouseButtons.LEFT;break;case 1:t=l.mouseButtons.MIDDLE;break;case 2:t=l.mouseButtons.RIGHT;break;default:t=-1}switch(t){case THREE.MOUSE.DOLLY:if(!1===l.enableZoom)return;!function(e){R.set(e.clientX,e.clientY)}(e),p=u.DOLLY;break;case THREE.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===l.enablePan)return;O(e),p=u.PAN}else{if(!1===l.enableRotate)return;I(e),p=u.ROTATE}break;case THREE.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===l.enableRotate)return;I(e),p=u.ROTATE}else{if(!1===l.enablePan)return;O(e),p=u.PAN}break;default:p=u.NONE}p!==u.NONE&&(l.domElement.ownerDocument.addEventListener("mousemove",X,!1),l.domElement.ownerDocument.addEventListener("mouseup",Y,!1),l.dispatchEvent(f))}}function X(e){if(!1!==l.enabled)switch(e.preventDefault(),p){case u.ROTATE:if(!1===l.enableRotate)return;!function(e){w.set(e.clientX,e.clientY),b.subVectors(w,E).multiplyScalar(l.rotateSpeed);var t=l.domElement;L(2*Math.PI*b.x/t.clientHeight),H(2*Math.PI*b.y/t.clientHeight),E.copy(w),l.update()}(e);break;case u.DOLLY:if(!1===l.enableZoom)return;!function(e){A.set(e.clientX,e.clientY),M.subVectors(A,R),M.y>0?D(C()):M.y<0&&F(C()),R.copy(A),l.update()}(e);break;case u.PAN:if(!1===l.enablePan)return;!function(e){_.set(e.clientX,e.clientY),S.subVectors(_,T).multiplyScalar(l.panSpeed),N(S.x,S.y),T.copy(_),l.update()}(e)}}function Y(e){!1!==l.enabled&&(l.domElement.ownerDocument.removeEventListener("mousemove",X,!1),l.domElement.ownerDocument.removeEventListener("mouseup",Y,!1),l.dispatchEvent(d),p=u.NONE)}function Z(e){!1===l.enabled||!1===l.enableZoom||p!==u.NONE&&p!==u.ROTATE||(e.preventDefault(),e.stopPropagation(),l.dispatchEvent(f),function(e){e.deltaY<0?F(C()):e.deltaY>0&&D(C()),l.update()}(e),l.dispatchEvent(d))}function Q(e){!1!==l.enabled&&!1!==l.enableKeys&&!1!==l.enablePan&&function(e){var t=!1;switch(e.keyCode){case l.keys.UP:N(0,l.keyPanSpeed),t=!0;break;case l.keys.BOTTOM:N(0,-l.keyPanSpeed),t=!0;break;case l.keys.LEFT:N(l.keyPanSpeed,0),t=!0;break;case l.keys.RIGHT:N(-l.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),l.update())}(e)}function K(e){if(!1!==l.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(l.touches.ONE){case THREE.TOUCH.ROTATE:if(!1===l.enableRotate)return;U(e),p=u.TOUCH_ROTATE;break;case THREE.TOUCH.PAN:if(!1===l.enablePan)return;G(e),p=u.TOUCH_PAN;break;default:p=u.NONE}break;case 2:switch(l.touches.TWO){case THREE.TOUCH.DOLLY_PAN:if(!1===l.enableZoom&&!1===l.enablePan)return;!function(e){l.enableZoom&&B(e),l.enablePan&&G(e)}(e),p=u.TOUCH_DOLLY_PAN;break;case THREE.TOUCH.DOLLY_ROTATE:if(!1===l.enableZoom&&!1===l.enableRotate)return;!function(e){l.enableZoom&&B(e),l.enableRotate&&U(e)}(e),p=u.TOUCH_DOLLY_ROTATE;break;default:p=u.NONE}break;default:p=u.NONE}p!==u.NONE&&l.dispatchEvent(f)}}function J(e){if(!1!==l.enabled)switch(e.preventDefault(),e.stopPropagation(),p){case u.TOUCH_ROTATE:if(!1===l.enableRotate)return;V(e),l.update();break;case u.TOUCH_PAN:if(!1===l.enablePan)return;j(e),l.update();break;case u.TOUCH_DOLLY_PAN:if(!1===l.enableZoom&&!1===l.enablePan)return;!function(e){l.enableZoom&&W(e),l.enablePan&&j(e)}(e),l.update();break;case u.TOUCH_DOLLY_ROTATE:if(!1===l.enableZoom&&!1===l.enableRotate)return;!function(e){l.enableZoom&&W(e),l.enableRotate&&V(e)}(e),l.update();break;default:p=u.NONE}}function $(e){!1!==l.enabled&&(l.dispatchEvent(d),p=u.NONE)}function ee(e){!1!==l.enabled&&e.preventDefault()}l.domElement.addEventListener("contextmenu",ee,!1),l.domElement.addEventListener("mousedown",q,!1),l.domElement.addEventListener("wheel",Z,!1),l.domElement.addEventListener("touchstart",K,!1),l.domElement.addEventListener("touchend",$,!1),l.domElement.addEventListener("touchmove",J,!1),l.domElement.addEventListener("keydown",Q,!1),-1===l.domElement.tabIndex&&(l.domElement.tabIndex=0),this.update()},THREE.OrbitControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.OrbitControls.prototype.constructor=THREE.OrbitControls,THREE.MapControls=function(e,t){THREE.OrbitControls.call(this,e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=THREE.MOUSE.PAN,this.mouseButtons.RIGHT=THREE.MOUSE.ROTATE,this.touches.ONE=THREE.TOUCH.PAN,this.touches.TWO=THREE.TOUCH.DOLLY_ROTATE},THREE.MapControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.MapControls.prototype.constructor=THREE.MapControls},function(e,t){THREE.TrackballControls=function(e,t){void 0===t&&console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');var r=this,n=-1,a=0,o=1,i=2,s=3,l=4;this.object=e,this.domElement=t,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.keys=[65,83,68],this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.ZOOM,RIGHT:THREE.MOUSE.PAN},this.target=new THREE.Vector3;var c=new THREE.Vector3,f=1,d=n,u=n,p=new THREE.Vector3,h=new THREE.Vector2,v=new THREE.Vector2,m=new THREE.Vector3,x=0,g=new THREE.Vector2,y=new THREE.Vector2,E=0,w=0,b=new THREE.Vector2,T=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.zoom0=this.object.zoom;var _={type:"change"},S={type:"start"},R={type:"end"};this.handleResize=function(){var e=r.domElement.getBoundingClientRect(),t=r.domElement.ownerDocument.documentElement;r.screen.left=e.left+window.pageXOffset-t.clientLeft,r.screen.top=e.top+window.pageYOffset-t.clientTop,r.screen.width=e.width,r.screen.height=e.height};var A,M,C,L,H,P,z,k,N,D,F,I=(A=new THREE.Vector2,function(e,t){return A.set((e-r.screen.left)/r.screen.width,(t-r.screen.top)/r.screen.height),A}),O=function(){var e=new THREE.Vector2;return function(t,n){return e.set((t-.5*r.screen.width-r.screen.left)/(.5*r.screen.width),(r.screen.height+2*(r.screen.top-n))/r.screen.width),e}}();function U(e){!1!==r.enabled&&(window.removeEventListener("keydown",U),u===n&&(e.keyCode!==r.keys[a]||r.noRotate?e.keyCode!==r.keys[o]||r.noZoom?e.keyCode!==r.keys[i]||r.noPan||(u=i):u=o:u=a))}function G(){!1!==r.enabled&&(u=n,window.addEventListener("keydown",U,!1))}function B(e){if(!1!==r.enabled){if(e.preventDefault(),e.stopPropagation(),d===n)switch(e.button){case r.mouseButtons.LEFT:d=a;break;case r.mouseButtons.MIDDLE:d=o;break;case r.mouseButtons.RIGHT:d=i;break;default:d=n}var t=u!==n?u:d;t!==a||r.noRotate?t!==o||r.noZoom?t!==i||r.noPan||(b.copy(I(e.pageX,e.pageY)),T.copy(b)):(g.copy(I(e.pageX,e.pageY)),y.copy(g)):(v.copy(O(e.pageX,e.pageY)),h.copy(v)),r.domElement.ownerDocument.addEventListener("mousemove",V,!1),r.domElement.ownerDocument.addEventListener("mouseup",j,!1),r.dispatchEvent(S)}}function V(e){if(!1!==r.enabled){e.preventDefault(),e.stopPropagation();var t=u!==n?u:d;t!==a||r.noRotate?t!==o||r.noZoom?t!==i||r.noPan||T.copy(I(e.pageX,e.pageY)):y.copy(I(e.pageX,e.pageY)):(h.copy(v),v.copy(O(e.pageX,e.pageY)))}}function j(e){!1!==r.enabled&&(e.preventDefault(),e.stopPropagation(),d=n,r.domElement.ownerDocument.removeEventListener("mousemove",V),r.domElement.ownerDocument.removeEventListener("mouseup",j),r.dispatchEvent(R))}function W(e){if(!1!==r.enabled&&!0!==r.noZoom){switch(e.preventDefault(),e.stopPropagation(),e.deltaMode){case 2:g.y-=.025*e.deltaY;break;case 1:g.y-=.01*e.deltaY;break;default:g.y-=25e-5*e.deltaY}r.dispatchEvent(S),r.dispatchEvent(R)}}function q(e){if(!1!==r.enabled){switch(e.preventDefault(),e.touches.length){case 1:d=s,v.copy(O(e.touches[0].pageX,e.touches[0].pageY)),h.copy(v);break;default:d=l;var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;w=E=Math.sqrt(t*t+n*n);var a=(e.touches[0].pageX+e.touches[1].pageX)/2,o=(e.touches[0].pageY+e.touches[1].pageY)/2;b.copy(I(a,o)),T.copy(b)}r.dispatchEvent(S)}}function X(e){if(!1!==r.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:h.copy(v),v.copy(O(e.touches[0].pageX,e.touches[0].pageY));break;default:var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;w=Math.sqrt(t*t+n*n);var a=(e.touches[0].pageX+e.touches[1].pageX)/2,o=(e.touches[0].pageY+e.touches[1].pageY)/2;T.copy(I(a,o))}}function Y(e){if(!1!==r.enabled){switch(e.touches.length){case 0:d=n;break;case 1:d=s,v.copy(O(e.touches[0].pageX,e.touches[0].pageY)),h.copy(v)}r.dispatchEvent(R)}}function Z(e){!1!==r.enabled&&e.preventDefault()}this.rotateCamera=(C=new THREE.Vector3,L=new THREE.Quaternion,H=new THREE.Vector3,P=new THREE.Vector3,z=new THREE.Vector3,k=new THREE.Vector3,function(){k.set(v.x-h.x,v.y-h.y,0),(M=k.length())?(p.copy(r.object.position).sub(r.target),H.copy(p).normalize(),P.copy(r.object.up).normalize(),z.crossVectors(P,H).normalize(),P.setLength(v.y-h.y),z.setLength(v.x-h.x),k.copy(P.add(z)),C.crossVectors(k,p).normalize(),M*=r.rotateSpeed,L.setFromAxisAngle(C,M),p.applyQuaternion(L),r.object.up.applyQuaternion(L),m.copy(C),x=M):!r.staticMoving&&x&&(x*=Math.sqrt(1-r.dynamicDampingFactor),p.copy(r.object.position).sub(r.target),L.setFromAxisAngle(m,x),p.applyQuaternion(L),r.object.up.applyQuaternion(L)),h.copy(v)}),this.zoomCamera=function(){var e;d===l?(e=E/w,E=w,r.object.isPerspectiveCamera?p.multiplyScalar(e):r.object.isOrthographicCamera?(r.object.zoom*=e,r.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(1!==(e=1+(y.y-g.y)*r.zoomSpeed)&&e>0&&(r.object.isPerspectiveCamera?p.multiplyScalar(e):r.object.isOrthographicCamera?(r.object.zoom/=e,r.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),r.staticMoving?g.copy(y):g.y+=(y.y-g.y)*this.dynamicDampingFactor)},this.panCamera=(N=new THREE.Vector2,D=new THREE.Vector3,F=new THREE.Vector3,function(){if(N.copy(T).sub(b),N.lengthSq()){if(r.object.isOrthographicCamera){var e=(r.object.right-r.object.left)/r.object.zoom/r.domElement.clientWidth,t=(r.object.top-r.object.bottom)/r.object.zoom/r.domElement.clientWidth;N.x*=e,N.y*=t}N.multiplyScalar(p.length()*r.panSpeed),F.copy(p).cross(r.object.up).setLength(N.x),F.add(D.copy(r.object.up).setLength(N.y)),r.object.position.add(F),r.target.add(F),r.staticMoving?b.copy(T):b.add(N.subVectors(T,b).multiplyScalar(r.dynamicDampingFactor))}}),this.checkDistances=function(){r.noZoom&&r.noPan||(p.lengthSq()>r.maxDistance*r.maxDistance&&(r.object.position.addVectors(r.target,p.setLength(r.maxDistance)),g.copy(y)),p.lengthSq()<r.minDistance*r.minDistance&&(r.object.position.addVectors(r.target,p.setLength(r.minDistance)),g.copy(y)))},this.update=function(){p.subVectors(r.object.position,r.target),r.noRotate||r.rotateCamera(),r.noZoom||r.zoomCamera(),r.noPan||r.panCamera(),r.object.position.addVectors(r.target,p),r.object.isPerspectiveCamera?(r.checkDistances(),r.object.lookAt(r.target),c.distanceToSquared(r.object.position)>1e-6&&(r.dispatchEvent(_),c.copy(r.object.position))):r.object.isOrthographicCamera?(r.object.lookAt(r.target),(c.distanceToSquared(r.object.position)>1e-6||f!==r.object.zoom)&&(r.dispatchEvent(_),c.copy(r.object.position),f=r.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type")},this.reset=function(){d=n,u=n,r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.up.copy(r.up0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),p.subVectors(r.object.position,r.target),r.object.lookAt(r.target),r.dispatchEvent(_),c.copy(r.object.position),f=r.object.zoom},this.dispose=function(){r.domElement.removeEventListener("contextmenu",Z,!1),r.domElement.removeEventListener("mousedown",B,!1),r.domElement.removeEventListener("wheel",W,!1),r.domElement.removeEventListener("touchstart",q,!1),r.domElement.removeEventListener("touchend",Y,!1),r.domElement.removeEventListener("touchmove",X,!1),r.domElement.ownerDocument.removeEventListener("mousemove",V,!1),r.domElement.ownerDocument.removeEventListener("mouseup",j,!1),window.removeEventListener("keydown",U,!1),window.removeEventListener("keyup",G,!1)},this.domElement.addEventListener("contextmenu",Z,!1),this.domElement.addEventListener("mousedown",B,!1),this.domElement.addEventListener("wheel",W,!1),this.domElement.addEventListener("touchstart",q,!1),this.domElement.addEventListener("touchend",Y,!1),this.domElement.addEventListener("touchmove",X,!1),window.addEventListener("keydown",U,!1),window.addEventListener("keyup",G,!1),this.handleResize(),this.update()},THREE.TrackballControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.TrackballControls.prototype.constructor=THREE.TrackballControls},function(e,t){THREE.FirstPersonControls=function(e,t){void 0===t&&(console.warn('THREE.FirstPersonControls: The second parameter "domElement" is now mandatory.'),t=document),this.object=e,this.domElement=t,this.enabled=!0,this.movementSpeed=1,this.lookSpeed=.005,this.lookVertical=!0,this.autoForward=!1,this.activeLook=!0,this.heightSpeed=!1,this.heightCoef=1,this.heightMin=0,this.heightMax=1,this.constrainVertical=!1,this.verticalMin=0,this.verticalMax=Math.PI,this.mouseDragOn=!1,this.autoSpeedFactor=0,this.mouseX=0,this.mouseY=0,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.viewHalfX=0,this.viewHalfY=0;var r,n=0,a=0,o=new THREE.Vector3,i=new THREE.Spherical,s=new THREE.Vector3;function l(e){e.preventDefault()}this.domElement!==document&&this.domElement.setAttribute("tabindex",-1),this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)},this.onMouseDown=function(e){if(this.domElement!==document&&this.domElement.focus(),e.preventDefault(),e.stopPropagation(),this.activeLook)switch(e.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0},this.onMouseUp=function(e){if(e.preventDefault(),e.stopPropagation(),this.activeLook)switch(e.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1},this.onMouseMove=function(e){this.domElement===document?(this.mouseX=e.pageX-this.viewHalfX,this.mouseY=e.pageY-this.viewHalfY):(this.mouseX=e.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=e.pageY-this.domElement.offsetTop-this.viewHalfY)},this.onKeyDown=function(e){switch(e.keyCode){case 38:case 87:this.moveForward=!0;break;case 37:case 65:this.moveLeft=!0;break;case 40:case 83:this.moveBackward=!0;break;case 39:case 68:this.moveRight=!0;break;case 82:this.moveUp=!0;break;case 70:this.moveDown=!0}},this.onKeyUp=function(e){switch(e.keyCode){case 38:case 87:this.moveForward=!1;break;case 37:case 65:this.moveLeft=!1;break;case 40:case 83:this.moveBackward=!1;break;case 39:case 68:this.moveRight=!1;break;case 82:this.moveUp=!1;break;case 70:this.moveDown=!1}},this.lookAt=function(e,t,r){return e.isVector3?s.copy(e):s.set(e,t,r),this.object.lookAt(s),v(this),this},this.update=(r=new THREE.Vector3,function(e){if(!1!==this.enabled){if(this.heightSpeed){var t=THREE.MathUtils.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=e*(t*this.heightCoef)}else this.autoSpeedFactor=0;var o=e*this.movementSpeed;(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(o+this.autoSpeedFactor)),this.moveBackward&&this.object.translateZ(o),this.moveLeft&&this.object.translateX(-o),this.moveRight&&this.object.translateX(o),this.moveUp&&this.object.translateY(o),this.moveDown&&this.object.translateY(-o);var i=e*this.lookSpeed;this.activeLook||(i=0);var s=1;this.constrainVertical&&(s=Math.PI/(this.verticalMax-this.verticalMin)),a-=this.mouseX*i,this.lookVertical&&(n-=this.mouseY*i*s),n=Math.max(-85,Math.min(85,n));var l=THREE.MathUtils.degToRad(90-n),c=THREE.MathUtils.degToRad(a);this.constrainVertical&&(l=THREE.MathUtils.mapLinear(l,0,Math.PI,this.verticalMin,this.verticalMax));var f=this.object.position;r.setFromSphericalCoords(1,l,c).add(f),this.object.lookAt(r)}}),this.dispose=function(){this.domElement.removeEventListener("contextmenu",l,!1),this.domElement.removeEventListener("mousedown",f,!1),this.domElement.removeEventListener("mousemove",c,!1),this.domElement.removeEventListener("mouseup",d,!1),window.removeEventListener("keydown",u,!1),window.removeEventListener("keyup",p,!1)};var c=h(this,this.onMouseMove),f=h(this,this.onMouseDown),d=h(this,this.onMouseUp),u=h(this,this.onKeyDown),p=h(this,this.onKeyUp);function h(e,t){return function(){t.apply(e,arguments)}}function v(e){var t=e.object.quaternion;o.set(0,0,-1).applyQuaternion(t),i.setFromVector3(o),n=90-THREE.MathUtils.radToDeg(i.phi),a=THREE.MathUtils.radToDeg(i.theta)}this.domElement.addEventListener("contextmenu",l,!1),this.domElement.addEventListener("mousemove",c,!1),this.domElement.addEventListener("mousedown",f,!1),this.domElement.addEventListener("mouseup",d,!1),window.addEventListener("keydown",u,!1),window.addEventListener("keyup",p,!1),this.handleResize(),v(this)}},function(e,t){THREE.Reflector=function(e,t){THREE.Mesh.call(this,e),this.type="Reflector";var r=this,n=void 0!==(t=t||{}).color?new THREE.Color(t.color):new THREE.Color(8355711),a=t.textureWidth||512,o=t.textureHeight||512,i=t.clipBias||0,s=t.shader||THREE.Reflector.ReflectorShader,l=new THREE.Plane,c=new THREE.Vector3,f=new THREE.Vector3,d=new THREE.Vector3,u=new THREE.Matrix4,p=new THREE.Vector3(0,0,-1),h=new THREE.Vector4,v=new THREE.Vector3,m=new THREE.Vector3,x=new THREE.Vector4,g=new THREE.Matrix4,y=new THREE.PerspectiveCamera,E={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1},w=new THREE.WebGLRenderTarget(a,o,E);THREE.MathUtils.isPowerOfTwo(a)&&THREE.MathUtils.isPowerOfTwo(o)||(w.texture.generateMipmaps=!1);var b=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(s.uniforms),fragmentShader:s.fragmentShader,vertexShader:s.vertexShader});b.uniforms.tDiffuse.value=w.texture,b.uniforms.color.value=n,b.uniforms.textureMatrix.value=g,this.material=b,this.onBeforeRender=function(e,t,n){if(f.setFromMatrixPosition(r.matrixWorld),d.setFromMatrixPosition(n.matrixWorld),u.extractRotation(r.matrixWorld),c.set(0,0,1),c.applyMatrix4(u),v.subVectors(f,d),!(v.dot(c)>0)){v.reflect(c).negate(),v.add(f),u.extractRotation(n.matrixWorld),p.set(0,0,-1),p.applyMatrix4(u),p.add(d),m.subVectors(f,p),m.reflect(c).negate(),m.add(f),y.position.copy(v),y.up.set(0,1,0),y.up.applyMatrix4(u),y.up.reflect(c),y.lookAt(m),y.far=n.far,y.updateMatrixWorld(),y.projectionMatrix.copy(n.projectionMatrix),g.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),g.multiply(y.projectionMatrix),g.multiply(y.matrixWorldInverse),g.multiply(r.matrixWorld),l.setFromNormalAndCoplanarPoint(c,f),l.applyMatrix4(y.matrixWorldInverse),h.set(l.normal.x,l.normal.y,l.normal.z,l.constant);var a=y.projectionMatrix;x.x=(Math.sign(h.x)+a.elements[8])/a.elements[0],x.y=(Math.sign(h.y)+a.elements[9])/a.elements[5],x.z=-1,x.w=(1+a.elements[10])/a.elements[14],h.multiplyScalar(2/h.dot(x)),a.elements[2]=h.x,a.elements[6]=h.y,a.elements[10]=h.z+1-i,a.elements[14]=h.w,w.texture.encoding=THREE.LinearEncoding,r.visible=!1;var o=e.getRenderTarget(),s=e.xr.enabled,E=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(w),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,y),e.xr.enabled=s,e.shadowMap.autoUpdate=E,e.setRenderTarget(o);var b=n.viewport;void 0!==b&&e.state.viewport(b),r.visible=!0}},this.getRenderTarget=function(){return w}},THREE.Reflector.prototype=Object.create(THREE.Mesh.prototype),THREE.Reflector.prototype.constructor=THREE.Reflector,THREE.Reflector.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","\tvec4 base = texture2DProj( tDiffuse, vUv );","\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join("\n")}},function(e,t){THREE.Refractor=function(e,t){THREE.Mesh.call(this,e),this.type="Refractor";var r=this,n=void 0!==(t=t||{}).color?new THREE.Color(t.color):new THREE.Color(8355711),a=t.textureWidth||512,o=t.textureHeight||512,i=t.clipBias||0,s=t.shader||THREE.Refractor.RefractorShader,l=new THREE.PerspectiveCamera;l.matrixAutoUpdate=!1,l.userData.refractor=!0;var c=new THREE.Plane,f=new THREE.Matrix4,d={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1},u=new THREE.WebGLRenderTarget(a,o,d);THREE.MathUtils.isPowerOfTwo(a)&&THREE.MathUtils.isPowerOfTwo(o)||(u.texture.generateMipmaps=!1),this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,transparent:!0}),this.material.uniforms.color.value=n,this.material.uniforms.tDiffuse.value=u.texture,this.material.uniforms.textureMatrix.value=f;p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Matrix4,m=new THREE.Vector3,x=new THREE.Vector3;var p,h,v,m,x,g,y,E,w=function(){var e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Quaternion,a=new THREE.Vector3;return function(){r.matrixWorld.decompose(t,n,a),e.set(0,0,1).applyQuaternion(n).normalize(),e.negate(),c.setFromNormalAndCoplanarPoint(e,t)}}(),b=(g=new THREE.Plane,y=new THREE.Vector4,E=new THREE.Vector4,function(e){l.matrixWorld.copy(e.matrixWorld),l.matrixWorldInverse.getInverse(l.matrixWorld),l.projectionMatrix.copy(e.projectionMatrix),l.far=e.far,g.copy(c),g.applyMatrix4(l.matrixWorldInverse),y.set(g.normal.x,g.normal.y,g.normal.z,g.constant);var t=l.projectionMatrix;E.x=(Math.sign(y.x)+t.elements[8])/t.elements[0],E.y=(Math.sign(y.y)+t.elements[9])/t.elements[5],E.z=-1,E.w=(1+t.elements[10])/t.elements[14],y.multiplyScalar(2/y.dot(E)),t.elements[2]=y.x,t.elements[6]=y.y,t.elements[10]=y.z+1-i,t.elements[14]=y.w});this.onBeforeRender=function(e,t,n){u.texture.encoding=e.outputEncoding,!0!==n.userData.refractor&&(w(),function(e){f.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),f.multiply(e.projectionMatrix),f.multiply(e.matrixWorldInverse),f.multiply(r.matrixWorld)}(n),b(n),function(e,t,n){r.visible=!1;var a=e.getRenderTarget(),o=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(u),!1===e.autoClear&&e.clear(),e.render(t,l),e.xr.enabled=o,e.shadowMap.autoUpdate=i,e.setRenderTarget(a);var s=n.viewport;void 0!==s&&e.state.viewport(s),r.visible=!0}(e,t,n))},this.getRenderTarget=function(){return u}},THREE.Refractor.prototype=Object.create(THREE.Mesh.prototype),THREE.Refractor.prototype.constructor=THREE.Refractor,THREE.Refractor.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:["uniform mat4 textureMatrix;","varying vec4 vUv;","void main() {","\tvUv = textureMatrix * vec4( position, 1.0 );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D tDiffuse;","varying vec4 vUv;","float blendOverlay( float base, float blend ) {","\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );","}","vec3 blendOverlay( vec3 base, vec3 blend ) {","\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );","}","void main() {","\tvec4 base = texture2DProj( tDiffuse, vUv );","\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );","}"].join("\n")}},function(e,t){THREE.FresnelShader={uniforms:{mRefractionRatio:{value:1.02},mFresnelBias:{value:.1},mFresnelPower:{value:2},mFresnelScale:{value:1},tCube:{value:null}},vertexShader:["uniform float mRefractionRatio;","uniform float mFresnelBias;","uniform float mFresnelScale;","uniform float mFresnelPower;","varying vec3 vReflect;","varying vec3 vRefract[3];","varying float vReflectionFactor;","void main() {","\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );","\tvec3 I = worldPosition.xyz - cameraPosition;","\tvReflect = reflect( I, worldNormal );","\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );","\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );","\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );","\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );","\tgl_Position = projectionMatrix * mvPosition;","}"].join("\n"),fragmentShader:["uniform samplerCube tCube;","varying vec3 vReflect;","varying vec3 vRefract[3];","varying float vReflectionFactor;","void main() {","\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );","\tvec4 refractedColor = vec4( 1.0 );","\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;","\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;","\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;","\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );","}"].join("\n")}},function(e,t){THREE.RGBELoader=function(e){THREE.DataTextureLoader.call(this,e),this.type=THREE.UnsignedByteType},THREE.RGBELoader.prototype=Object.assign(Object.create(THREE.DataTextureLoader.prototype),{constructor:THREE.RGBELoader,parse:function(e){var t=function(e,t){switch(e){case 1:console.error("THREE.RGBELoader Read Error: "+(t||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(t||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(t||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(t||""))}return-1},r=function(e,t,r){t=t||1024;for(var n=e.pos,a=-1,o=0,i="",s=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));0>(a=s.indexOf("\n"))&&o<t&&n<e.byteLength;)i+=s,o+=s.length,n+=128,s+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+128)));return-1<a&&(!1!==r&&(e.pos+=o+a+1),i+s.slice(0,a))},n=function(){var e=new Float32Array(1),t=new Int32Array(e.buffer);function r(r){e[0]=r;var n=t[0],a=n>>16&32768,o=n>>12&2047,i=n>>23&255;return i<103?a:i>142?(a|=31744,a|=(255==i?0:1)&&8388607&n):i<113?a|=((o|=2048)>>114-i)+(o>>113-i&1):(a|=i-112<<10|o>>1,a+=1&o)}return function(e,t,n,a){var o=e[t+3],i=Math.pow(2,o-128)/255;n[a+0]=r(e[t+0]*i),n[a+1]=r(e[t+1]*i),n[a+2]=r(e[t+2]*i)}}(),a=new Uint8Array(e);a.pos=0;var o,i,s,l,c,f,d=function(e){var n,a,o=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,i=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,s=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,c={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};if(e.pos>=e.byteLength||!(n=r(e)))return t(1,"no header found");if(!(a=n.match(/^#\?(\S+)$/)))return t(3,"bad initial token");for(c.valid|=1,c.programtype=a[1],c.string+=n+"\n";!1!==(n=r(e));)if(c.string+=n+"\n","#"!==n.charAt(0)){if((a=n.match(o))&&(c.gamma=parseFloat(a[1],10)),(a=n.match(i))&&(c.exposure=parseFloat(a[1],10)),(a=n.match(s))&&(c.valid|=2,c.format=a[1]),(a=n.match(l))&&(c.valid|=4,c.height=parseInt(a[1],10),c.width=parseInt(a[2],10)),2&c.valid&&4&c.valid)break}else c.comments+=n+"\n";return 2&c.valid?4&c.valid?c:t(3,"missing image size specifier"):t(3,"missing format specifier")}(a);if(-1!==d){var u=d.width,p=d.height,h=function(e,r,n){var a,o,i,s,l,c,f,d,u,p,h,v,m,x=r,g=n;if(x<8||x>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);if(x!==(e[2]<<8|e[3]))return t(3,"wrong scanline width");if(!(a=new Uint8Array(4*r*n)).length)return t(4,"unable to allocate buffer space");for(o=0,i=0,d=4*x,m=new Uint8Array(4),c=new Uint8Array(d);g>0&&i<e.byteLength;){if(i+4>e.byteLength)return t(1);if(m[0]=e[i++],m[1]=e[i++],m[2]=e[i++],m[3]=e[i++],2!=m[0]||2!=m[1]||(m[2]<<8|m[3])!=x)return t(3,"bad rgbe scanline format");for(f=0;f<d&&i<e.byteLength;){if((v=(s=e[i++])>128)&&(s-=128),0===s||f+s>d)return t(3,"bad scanline data");if(v)for(l=e[i++],u=0;u<s;u++)c[f++]=l;else c.set(e.subarray(i,i+s),f),f+=s,i+=s}for(p=x,u=0;u<p;u++)h=0,a[o]=c[u+h],h+=x,a[o+1]=c[u+h],h+=x,a[o+2]=c[u+h],h+=x,a[o+3]=c[u+h],o+=4;g--}return a}(a.subarray(a.pos),u,p);if(-1!==h){switch(this.type){case THREE.UnsignedByteType:var v=h,m=THREE.RGBEFormat,x=THREE.UnsignedByteType;break;case THREE.FloatType:for(var g=h.length/4*3,y=new Float32Array(g),E=0;E<g;E++)s=y,l=3*E,c=void 0,f=void 0,c=(o=h)[(i=4*E)+3],f=Math.pow(2,c-128)/255,s[l+0]=o[i+0]*f,s[l+1]=o[i+1]*f,s[l+2]=o[i+2]*f;v=y,m=THREE.RGBFormat,x=THREE.FloatType;break;case THREE.HalfFloatType:g=h.length/4*3;var w=new Uint16Array(g);for(E=0;E<g;E++)n(h,4*E,w,3*E);v=w,m=THREE.RGBFormat,x=THREE.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:u,height:p,data:v,header:d.string,gamma:d.gamma,exposure:d.exposure,format:m,type:x}}}return null},setDataType:function(e){return this.type=e,this},load:function(e,t,r,n){return THREE.DataTextureLoader.prototype.load.call(this,e,(function(e,r){switch(e.type){case THREE.UnsignedByteType:e.encoding=THREE.RGBEEncoding,e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.generateMipmaps=!1,e.flipY=!0;break;case THREE.FloatType:case THREE.HalfFloatType:e.encoding=THREE.LinearEncoding,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,r)}),r,n)}})},function(e,t){THREE.HDRCubeTextureLoader=function(e){THREE.Loader.call(this,e),this.hdrLoader=new THREE.RGBELoader,this.type=THREE.UnsignedByteType},THREE.HDRCubeTextureLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.HDRCubeTextureLoader,load:function(e,t,r,n){Array.isArray(e)||(console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."),this.setDataType(e),e=t,t=r,r=n,n=arguments[4]);var a=new THREE.CubeTexture;switch(a.type=this.type,a.type){case THREE.UnsignedByteType:a.encoding=THREE.RGBEEncoding,a.format=THREE.RGBAFormat,a.minFilter=THREE.NearestFilter,a.magFilter=THREE.NearestFilter,a.generateMipmaps=!1;break;case THREE.FloatType:case THREE.HalfFloatType:a.encoding=THREE.LinearEncoding,a.format=THREE.RGBFormat,a.minFilter=THREE.LinearFilter,a.magFilter=THREE.LinearFilter,a.generateMipmaps=!1}var o=this,i=0;function s(t,r,n,s){new THREE.FileLoader(o.manager).setPath(o.path).setResponseType("arraybuffer").load(e[t],(function(e){i++;var n=o.hdrLoader.parse(e);if(n){if(void 0!==n.data){var s=new THREE.DataTexture(n.data,n.width,n.height);s.type=a.type,s.encoding=a.encoding,s.format=a.format,s.minFilter=a.minFilter,s.magFilter=a.magFilter,s.generateMipmaps=a.generateMipmaps,a.images[t]=s}6===i&&(a.needsUpdate=!0,r&&r(a))}}),n,s)}for(var l=0;l<e.length;l++)s(l,t,r,n);return a},setDataType:function(e){return this.type=e,this.hdrLoader.setDataType(e),this}})},function(e,t){THREE.OBJLoader=function(){var e=/^[og]\s*(.+)?/,t=/^mtllib /,r=/^usemtl /,n=/^usemap /,a=new THREE.Vector3,o=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,l=new THREE.Vector3;function c(){var e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);var r=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasNormalIndices:!1,hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){var r=this._finalize(!1);r&&(r.inherited||r.groupCount<=0)&&this.materials.splice(r.index,1);var n={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==r?r.smooth:this.smooth,groupStart:void 0!==r?r.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){var t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(n),n},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){var t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(var r=this.materials.length-1;r>=0;r--)this.materials[r].groupCount<=0&&this.materials.splice(r,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},r&&r.name&&"function"==typeof r.clone){var n=r.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseNormalIndex:function(e,t){var r=parseInt(e,10);return 3*(r>=0?r-1:r+t/3)},parseUVIndex:function(e,t){var r=parseInt(e,10);return 2*(r>=0?r-1:r+t/2)},addVertex:function(e,t,r){var n=this.vertices,a=this.object.geometry.vertices;a.push(n[e+0],n[e+1],n[e+2]),a.push(n[t+0],n[t+1],n[t+2]),a.push(n[r+0],n[r+1],n[r+2])},addVertexPoint:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){var t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,r){var n=this.normals,a=this.object.geometry.normals;a.push(n[e+0],n[e+1],n[e+2]),a.push(n[t+0],n[t+1],n[t+2]),a.push(n[r+0],n[r+1],n[r+2])},addFaceNormal:function(e,t,r){var n=this.vertices,c=this.object.geometry.normals;a.fromArray(n,e),o.fromArray(n,t),i.fromArray(n,r),l.subVectors(i,o),s.subVectors(a,o),l.cross(s),l.normalize(),c.push(l.x,l.y,l.z),c.push(l.x,l.y,l.z),c.push(l.x,l.y,l.z)},addColor:function(e,t,r){var n=this.colors,a=this.object.geometry.colors;void 0!==n[e]&&a.push(n[e+0],n[e+1],n[e+2]),void 0!==n[t]&&a.push(n[t+0],n[t+1],n[t+2]),void 0!==n[r]&&a.push(n[r+0],n[r+1],n[r+2])},addUV:function(e,t,r){var n=this.uvs,a=this.object.geometry.uvs;a.push(n[e+0],n[e+1]),a.push(n[t+0],n[t+1]),a.push(n[r+0],n[r+1])},addDefaultUV:function(){var e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){var t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,r,n,a,o,i,s,l){var c=this.vertices.length,f=this.parseVertexIndex(e,c),d=this.parseVertexIndex(t,c),u=this.parseVertexIndex(r,c);if(this.addVertex(f,d,u),this.addColor(f,d,u),void 0!==i&&""!==i){var p=this.normals.length;f=this.parseNormalIndex(i,p),d=this.parseNormalIndex(s,p),u=this.parseNormalIndex(l,p),this.addNormal(f,d,u),this.object.geometry.hasNormalIndices=!0}else this.addFaceNormal(f,d,u);if(void 0!==n&&""!==n){var h=this.uvs.length;f=this.parseUVIndex(n,h),d=this.parseUVIndex(a,h),u=this.parseUVIndex(o,h),this.addUV(f,d,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";for(var t=this.vertices.length,r=0,n=e.length;r<n;r++)this.addVertexPoint(this.parseVertexIndex(e[r],t))},addLineGeometry:function(e,t){this.object.geometry.type="Line";for(var r=this.vertices.length,n=this.uvs.length,a=0,o=e.length;a<o;a++)this.addVertexLine(this.parseVertexIndex(e[a],r));var i=0;for(o=t.length;i<o;i++)this.addUVLine(this.parseUVIndex(t[i],n))}};return e.startObject("",!1),e}function f(e){THREE.Loader.call(this,e),this.materials=null}return f.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:f,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},setMaterials:function(e){return this.materials=e,this},parse:function(a){var o=new c;-1!==a.indexOf("\r\n")&&(a=a.replace(/\r\n/g,"\n")),-1!==a.indexOf("\\\n")&&(a=a.replace(/\\\n/g,""));for(var i=a.split("\n"),s="",l="",f=[],d="function"==typeof"".trimLeft,u=0,p=i.length;u<p;u++)if(s=i[u],0!==(s=d?s.trimLeft():s.trim()).length&&"#"!==(l=s.charAt(0)))if("v"===l){var h=s.split(/\s+/);switch(h[0]){case"v":o.vertices.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),h.length>=7?o.colors.push(parseFloat(h[4]/255),parseFloat(h[5]/255),parseFloat(h[6]/255)):o.colors.push(void 0,void 0,void 0);break;case"vn":o.normals.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3]));break;case"vt":o.uvs.push(parseFloat(h[1]),parseFloat(h[2]))}}else if("f"===l){for(var v=s.substr(1).trim().split(/\s+/),m=[],x=0,g=v.length;x<g;x++){var y=v[x];if(y.length>0){var E=y.split("/");m.push(E)}}var w=m[0];for(x=1,g=m.length-1;x<g;x++){var b=m[x],T=m[x+1];o.addFace(w[0],b[0],T[0],w[1],b[1],T[1],w[2],b[2],T[2])}}else if("l"===l){var _=s.substring(1).trim().split(" "),S=[],R=[];if(-1===s.indexOf("/"))S=_;else for(var A=0,M=_.length;A<M;A++){var C=_[A].split("/");""!==C[0]&&S.push(C[0]),""!==C[1]&&R.push(C[1])}o.addLineGeometry(S,R)}else if("p"===l){var L=s.substr(1).trim().split(" ");o.addPointGeometry(L)}else if(null!==(f=e.exec(s))){var H=(" "+f[0].substr(1).trim()).substr(1);o.startObject(H)}else if(r.test(s))o.object.startMaterial(s.substring(7).trim(),o.materialLibraries);else if(t.test(s))o.materialLibraries.push(s.substring(7).trim());else if(n.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===l){if((f=s.split(" ")).length>1){var P=f[1].trim().toLowerCase();o.object.smooth="0"!==P&&"off"!==P}else o.object.smooth=!0;(q=o.object.currentMaterial())&&(q.smooth=o.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}o.finalize();var z=new THREE.Group;z.materialLibraries=[].concat(o.materialLibraries);for(u=0,p=o.objects.length;u<p;u++){var k=o.objects[u],N=k.geometry,D=k.materials,F="Line"===N.type,I="Points"===N.type,O=!1;if(0!==N.vertices.length){var U=new THREE.BufferGeometry;U.setAttribute("position",new THREE.Float32BufferAttribute(N.vertices,3)),!0===N.hasNormalIndices&&U.setAttribute("normal",new THREE.Float32BufferAttribute(N.normals,3)),N.colors.length>0&&(O=!0,U.setAttribute("color",new THREE.Float32BufferAttribute(N.colors,3))),!0===N.hasUVIndices&&U.setAttribute("uv",new THREE.Float32BufferAttribute(N.uvs,2));for(var G,B=[],V=0,j=D.length;V<j;V++){var W=(Z=D[V]).name+"_"+Z.smooth+"_"+O,q=o.materials[W];if(null!==this.materials)if(q=this.materials.create(Z.name),!F||!q||q instanceof THREE.LineBasicMaterial){if(I&&q&&!(q instanceof THREE.PointsMaterial)){var X=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(X,q),X.color.copy(q.color),X.map=q.map,q=X}}else{var Y=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(Y,q),Y.color.copy(q.color),q=Y}void 0===q&&((q=F?new THREE.LineBasicMaterial:I?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial).name=Z.name,q.flatShading=!Z.smooth,q.vertexColors=O,o.materials[W]=q),B.push(q)}if(B.length>1){for(V=0,j=D.length;V<j;V++){var Z=D[V];U.addGroup(Z.groupStart,Z.groupCount,V)}G=F?new THREE.LineSegments(U,B):I?new THREE.Points(U,B):new THREE.Mesh(U,B)}else G=F?new THREE.LineSegments(U,B[0]):I?new THREE.Points(U,B[0]):new THREE.Mesh(U,B[0]);G.name=k.name,z.add(G)}}return z}}),f}()},function(e,t){THREE.OBJExporter=function(){},THREE.OBJExporter.prototype={constructor:THREE.OBJExporter,parse:function(e){var t,r,n,a,o,i="",s=0,l=0,c=0,f=new THREE.Vector3,d=new THREE.Vector3,u=new THREE.Vector2,p=[];return e.traverse((function(e){e instanceof THREE.Mesh&&function(e){var n=0,h=0,v=0,m=e.geometry,x=new THREE.Matrix3;if(m instanceof THREE.Geometry&&(m=(new THREE.BufferGeometry).setFromObject(e)),m instanceof THREE.BufferGeometry){var g=m.getAttribute("position"),y=m.getAttribute("normal"),E=m.getAttribute("uv"),w=m.getIndex();if(i+="o "+e.name+"\n",e.material&&e.material.name&&(i+="usemtl "+e.material.name+"\n"),void 0!==g)for(t=0,a=g.count;t<a;t++,n++)f.x=g.getX(t),f.y=g.getY(t),f.z=g.getZ(t),f.applyMatrix4(e.matrixWorld),i+="v "+f.x+" "+f.y+" "+f.z+"\n";if(void 0!==E)for(t=0,a=E.count;t<a;t++,v++)u.x=E.getX(t),u.y=E.getY(t),i+="vt "+u.x+" "+u.y+"\n";if(void 0!==y)for(x.getNormalMatrix(e.matrixWorld),t=0,a=y.count;t<a;t++,h++)d.x=y.getX(t),d.y=y.getY(t),d.z=y.getZ(t),d.applyMatrix3(x).normalize(),i+="vn "+d.x+" "+d.y+" "+d.z+"\n";if(null!==w)for(t=0,a=w.count;t<a;t+=3){for(o=0;o<3;o++)r=w.getX(t+o)+1,p[o]=s+r+(y||E?"/"+(E?l+r:"")+(y?"/"+(c+r):""):"");i+="f "+p.join(" ")+"\n"}else for(t=0,a=g.count;t<a;t+=3){for(o=0;o<3;o++)r=t+o+1,p[o]=s+r+(y||E?"/"+(E?l+r:"")+(y?"/"+(c+r):""):"");i+="f "+p.join(" ")+"\n"}}else console.warn("THREE.OBJExporter.parseMesh(): geometry type unsupported",m);s+=n,l+=v,c+=h}(e),e instanceof THREE.Line&&function(e){var o=0,l=e.geometry,c=e.type;if(l instanceof THREE.Geometry&&(l=(new THREE.BufferGeometry).setFromObject(e)),l instanceof THREE.BufferGeometry){var d=l.getAttribute("position");if(i+="o "+e.name+"\n",void 0!==d)for(t=0,a=d.count;t<a;t++,o++)f.x=d.getX(t),f.y=d.getY(t),f.z=d.getZ(t),f.applyMatrix4(e.matrixWorld),i+="v "+f.x+" "+f.y+" "+f.z+"\n";if("Line"===c){for(i+="l ",r=1,a=d.count;r<=a;r++)i+=s+r+" ";i+="\n"}if("LineSegments"===c)for(n=(r=1)+1,a=d.count;r<a;n=(r+=2)+1)i+="l "+(s+r)+" "+(s+n)+"\n"}else console.warn("THREE.OBJExporter.parseLine(): geometry type unsupported",l);s+=o}(e)})),i}}},function(e,t){THREE.MTLLoader=function(e){THREE.Loader.call(this,e)},THREE.MTLLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.MTLLoader,load:function(e,t,r,n){var a=this,o=""===this.path?THREE.LoaderUtils.extractUrlBase(e):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.load(e,(function(r){try{t(a.parse(r,o))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},setMaterialOptions:function(e){return this.materialOptions=e,this},parse:function(e,t){for(var r=e.split("\n"),n={},a=/\s+/,o={},i=0;i<r.length;i++){var s=r[i];if(0!==(s=s.trim()).length&&"#"!==s.charAt(0)){var l=s.indexOf(" "),c=l>=0?s.substring(0,l):s;c=c.toLowerCase();var f=l>=0?s.substring(l+1):"";if(f=f.trim(),"newmtl"===c)n={name:f},o[f]=n;else if("ka"===c||"kd"===c||"ks"===c||"ke"===c){var d=f.split(a,3);n[c]=[parseFloat(d[0]),parseFloat(d[1]),parseFloat(d[2])]}else n[c]=f}}var u=new THREE.MTLLoader.MaterialCreator(this.resourcePath||t,this.materialOptions);return u.setCrossOrigin(this.crossOrigin),u.setManager(this.manager),u.setMaterials(o),u}}),THREE.MTLLoader.MaterialCreator=function(e,t){this.baseUrl=e||"",this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.side=this.options&&this.options.side?this.options.side:THREE.FrontSide,this.wrap=this.options&&this.options.wrap?this.options.wrap:THREE.RepeatWrapping},THREE.MTLLoader.MaterialCreator.prototype={constructor:THREE.MTLLoader.MaterialCreator,crossOrigin:"anonymous",setCrossOrigin:function(e){return this.crossOrigin=e,this},setManager:function(e){this.manager=e},setMaterials:function(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}},convert:function(e){if(!this.options)return e;var t={};for(var r in e){var n=e[r],a={};for(var o in t[r]=a,n){var i=!0,s=n[o],l=o.toLowerCase();switch(l){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(s=[s[0]/255,s[1]/255,s[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===s[0]&&0===s[1]&&0===s[2]&&(i=!1)}i&&(a[l]=s)}}return t},preload:function(){for(var e in this.materialsInfo)this.create(e)},getIndex:function(e){return this.nameLookup[e]},getAsArray:function(){var e=0;for(var t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray},create:function(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]},createMaterial_:function(e){var t=this,r=this.materialsInfo[e],n={name:e,side:this.side};function a(e,r){if(!n[e]){var a,o,i=t.getTextureParams(r,n),s=t.loadTexture((a=t.baseUrl,"string"!=typeof(o=i.url)||""===o?"":/^https?:\/\//i.test(o)?o:a+o));s.repeat.copy(i.scale),s.offset.copy(i.offset),s.wrapS=t.wrap,s.wrapT=t.wrap,n[e]=s}}for(var o in r){var i,s=r[o];if(""!==s)switch(o.toLowerCase()){case"kd":n.color=(new THREE.Color).fromArray(s);break;case"ks":n.specular=(new THREE.Color).fromArray(s);break;case"ke":n.emissive=(new THREE.Color).fromArray(s);break;case"map_kd":a("map",s);break;case"map_ks":a("specularMap",s);break;case"map_ke":a("emissiveMap",s);break;case"norm":a("normalMap",s);break;case"map_bump":case"bump":a("bumpMap",s);break;case"map_d":a("alphaMap",s),n.transparent=!0;break;case"ns":n.shininess=parseFloat(s);break;case"d":(i=parseFloat(s))<1&&(n.opacity=i,n.transparent=!0);break;case"tr":i=parseFloat(s),this.options&&this.options.invertTrProperty&&(i=1-i),i>0&&(n.opacity=1-i,n.transparent=!0)}}return this.materials[e]=new THREE.MeshPhongMaterial(n),this.materials[e]},getTextureParams:function(e,t){var r,n={scale:new THREE.Vector2(1,1),offset:new THREE.Vector2(0,0)},a=e.split(/\s+/);return(r=a.indexOf("-bm"))>=0&&(t.bumpScale=parseFloat(a[r+1]),a.splice(r,2)),(r=a.indexOf("-s"))>=0&&(n.scale.set(parseFloat(a[r+1]),parseFloat(a[r+2])),a.splice(r,4)),(r=a.indexOf("-o"))>=0&&(n.offset.set(parseFloat(a[r+1]),parseFloat(a[r+2])),a.splice(r,4)),n.url=a.join(" ").trim(),n},loadTexture:function(e,t,r,n,a){var o,i=void 0!==this.manager?this.manager:THREE.DefaultLoadingManager,s=i.getHandler(e);return null===s&&(s=new THREE.TextureLoader(i)),s.setCrossOrigin&&s.setCrossOrigin(this.crossOrigin),o=s.load(e,r,n,a),void 0!==t&&(o.mapping=t),o}}},function(e,t){THREE.STLLoader=function(e){THREE.Loader.call(this,e)},THREE.STLLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.STLLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){function t(e,t,r){for(var n=0,a=e.length;n<a;n++)if(e[n]!==t.getUint8(r+n,!1))return!1;return!0}var r,n=function(e){if("string"==typeof e){for(var t=new Uint8Array(e.length),r=0;r<e.length;r++)t[r]=255&e.charCodeAt(r);return t.buffer||t}return e}(e);return function(e){var r;if(50,84+50*(r=new DataView(e)).getUint32(80,!0)===r.byteLength)return!0;for(var n=[115,111,108,105,100],a=0;a<5;a++)if(t(n,r,a))return!1;return!0}(n)?function(e){for(var t,r,n,a,o,i,s,l,c=new DataView(e),f=c.getUint32(80,!0),d=!1,u=0;u<70;u++)1129270351==c.getUint32(u,!1)&&82==c.getUint8(u+4)&&61==c.getUint8(u+5)&&(d=!0,a=new Float32Array(3*f*3),o=c.getUint8(u+6)/255,i=c.getUint8(u+7)/255,s=c.getUint8(u+8)/255,l=c.getUint8(u+9)/255);for(var p=new THREE.BufferGeometry,h=new Float32Array(3*f*3),v=new Float32Array(3*f*3),m=0;m<f;m++){var x=84+50*m,g=c.getFloat32(x,!0),y=c.getFloat32(x+4,!0),E=c.getFloat32(x+8,!0);if(d){var w=c.getUint16(x+48,!0);0==(32768&w)?(t=(31&w)/31,r=(w>>5&31)/31,n=(w>>10&31)/31):(t=o,r=i,n=s)}for(var b=1;b<=3;b++){var T=x+12*b,_=3*m*3+3*(b-1);h[_]=c.getFloat32(T,!0),h[_+1]=c.getFloat32(T+4,!0),h[_+2]=c.getFloat32(T+8,!0),v[_]=g,v[_+1]=y,v[_+2]=E,d&&(a[_]=t,a[_+1]=r,a[_+2]=n)}}return p.setAttribute("position",new THREE.BufferAttribute(h,3)),p.setAttribute("normal",new THREE.BufferAttribute(v,3)),d&&(p.setAttribute("color",new THREE.BufferAttribute(a,3)),p.hasColors=!0,p.alpha=l),p}(n):function(e){for(var t,r=new THREE.BufferGeometry,n=/solid([\s\S]*?)endsolid/g,a=/facet([\s\S]*?)endfacet/g,o=0,i=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,s=new RegExp("vertex"+i+i+i,"g"),l=new RegExp("normal"+i+i+i,"g"),c=[],f=[],d=new THREE.Vector3,u=0,p=0,h=0;null!==(t=n.exec(e));){p=h;for(var v=t[0];null!==(t=a.exec(v));){for(var m=0,x=0,g=t[0];null!==(t=l.exec(g));)d.x=parseFloat(t[1]),d.y=parseFloat(t[2]),d.z=parseFloat(t[3]),x++;for(;null!==(t=s.exec(g));)c.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),f.push(d.x,d.y,d.z),m++,h++;1!==x&&console.error("THREE.STLLoader: Something isn't right with the normal of face number "+o),3!==m&&console.error("THREE.STLLoader: Something isn't right with the vertices of face number "+o),o++}var y=p,E=h-p;r.addGroup(y,E,u),u++}return r.setAttribute("position",new THREE.Float32BufferAttribute(c,3)),r.setAttribute("normal",new THREE.Float32BufferAttribute(f,3)),r}("string"!=typeof(r=e)?THREE.LoaderUtils.decodeText(new Uint8Array(r)):r)}})},function(e,t){var r,n;THREE.STLExporter=function(){},THREE.STLExporter.prototype={constructor:THREE.STLExporter,parse:(r=new THREE.Vector3,n=new THREE.Matrix3,function(e,t){void 0===t&&(t={});var a=void 0!==t.binary&&t.binary,o=[],i=0;if(e.traverse((function(e){if(e.isMesh){var t=e.geometry;t.isBufferGeometry&&(t=(new THREE.Geometry).fromBufferGeometry(t)),t.isGeometry&&(i+=t.faces.length,o.push({geometry:t,matrixWorld:e.matrixWorld}))}})),a){var s=80,l=new ArrayBuffer(2*i+3*i*4*4+80+4);(y=new DataView(l)).setUint32(s,i,!0),s+=4;for(var c=0,f=o.length;c<f;c++){var d=(E=o[c]).geometry.vertices,u=E.geometry.faces,p=E.matrixWorld;n.getNormalMatrix(p);for(var h=0,v=u.length;h<v;h++){var m=u[h];r.copy(m.normal).applyMatrix3(n).normalize(),y.setFloat32(s,r.x,!0),s+=4,y.setFloat32(s,r.y,!0),s+=4,y.setFloat32(s,r.z,!0),s+=4;for(var x=[m.a,m.b,m.c],g=0;g<3;g++)r.copy(d[x[g]]).applyMatrix4(p),y.setFloat32(s,r.x,!0),s+=4,y.setFloat32(s,r.y,!0),s+=4,y.setFloat32(s,r.z,!0),s+=4;y.setUint16(s,0,!0),s+=2}}return y}var y="";for(y+="solid exported\n",c=0,f=o.length;c<f;c++){var E;for(d=(E=o[c]).geometry.vertices,u=E.geometry.faces,p=E.matrixWorld,n.getNormalMatrix(p),h=0,v=u.length;h<v;h++){for(m=u[h],r.copy(m.normal).applyMatrix3(n).normalize(),y+="\tfacet normal "+r.x+" "+r.y+" "+r.z+"\n",y+="\t\touter loop\n",x=[m.a,m.b,m.c],g=0;g<3;g++)r.copy(d[x[g]]).applyMatrix4(p),y+="\t\t\tvertex "+r.x+" "+r.y+" "+r.z+"\n";y+="\t\tendloop\n",y+="\tendfacet\n"}}return y+="endsolid exported\n"})}},function(e,t){THREE.PLYLoader=function(e){THREE.Loader.call(this,e),this.propertyNameMapping={}},THREE.PLYLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.PLYLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},setPropertyNameMapping:function(e){this.propertyNameMapping=e},parse:function(e){function t(e){var t="",r=0,n=/ply([\s\S]*)end_header\r?\n/.exec(e);null!==n&&(t=n[1],r=n[0].length);var a,o,i,s,l,c,d={comments:[],elements:[],headerLength:r},u=t.split("\n");for(var p=0;p<u.length;p++){var h=u[p];if(""!==(h=h.trim()))switch(o=(i=h.split(/\s+/)).shift(),h=i.join(" "),o){case"format":d.format=i[0],d.version=i[1];break;case"comment":d.comments.push(h);break;case"element":void 0!==a&&d.elements.push(a),(a={}).name=i[0],a.count=parseInt(i[1]),a.properties=[];break;case"property":a.properties.push((s=i,l=f.propertyNameMapping,c=void 0,"list"===(c={type:s[0]}).type?(c.name=s[3],c.countType=s[1],c.itemType=s[2]):c.name=s[1],c.name in l&&(c.name=l[c.name]),c));break;default:console.log("unhandled",o,i)}}return void 0!==a&&d.elements.push(a),d}function r(e,t){switch(t){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(e);case"float":case"double":case"float32":case"float64":return parseFloat(e)}}function n(e,t){for(var n=t.split(/\s+/),a={},o=0;o<e.length;o++)if("list"===e[o].type){for(var i=[],s=r(n.shift(),e[o].countType),l=0;l<s;l++)i.push(r(n.shift(),e[o].itemType));a[e[o].name]=i}else a[e[o].name]=r(n.shift(),e[o].type);return a}function a(e,t){var r,a={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]},s="";null!==(r=/end_header\s([\s\S]*)$/.exec(e))&&(s=r[1]);for(var l=s.split("\n"),c=0,f=0,d=0;d<l.length;d++){var u=l[d];if(""!==(u=u.trim())){f>=t.elements[c].count&&(c++,f=0);var p=n(t.elements[c].properties,u);i(a,t.elements[c].name,p),f++}}return o(a)}function o(e){var t=new THREE.BufferGeometry;return e.indices.length>0&&t.setIndex(e.indices),t.setAttribute("position",new THREE.Float32BufferAttribute(e.vertices,3)),e.normals.length>0&&t.setAttribute("normal",new THREE.Float32BufferAttribute(e.normals,3)),e.uvs.length>0&&t.setAttribute("uv",new THREE.Float32BufferAttribute(e.uvs,2)),e.colors.length>0&&t.setAttribute("color",new THREE.Float32BufferAttribute(e.colors,3)),e.faceVertexUvs.length>0&&(t=t.toNonIndexed()).setAttribute("uv",new THREE.Float32BufferAttribute(e.faceVertexUvs,2)),t.computeBoundingSphere(),t}function i(e,t,r){if("vertex"===t)e.vertices.push(r.x,r.y,r.z),"nx"in r&&"ny"in r&&"nz"in r&&e.normals.push(r.nx,r.ny,r.nz),"s"in r&&"t"in r&&e.uvs.push(r.s,r.t),"red"in r&&"green"in r&&"blue"in r&&e.colors.push(r.red/255,r.green/255,r.blue/255);else if("face"===t){var n=r.vertex_indices||r.vertex_index,a=r.texcoord;3===n.length?(e.indices.push(n[0],n[1],n[2]),a&&6===a.length&&(e.faceVertexUvs.push(a[0],a[1]),e.faceVertexUvs.push(a[2],a[3]),e.faceVertexUvs.push(a[4],a[5]))):4===n.length&&(e.indices.push(n[0],n[1],n[3]),e.indices.push(n[1],n[2],n[3]))}}function s(e,t,r,n){switch(r){case"int8":case"char":return[e.getInt8(t),1];case"uint8":case"uchar":return[e.getUint8(t),1];case"int16":case"short":return[e.getInt16(t,n),2];case"uint16":case"ushort":return[e.getUint16(t,n),2];case"int32":case"int":return[e.getInt32(t,n),4];case"uint32":case"uint":return[e.getUint32(t,n),4];case"float32":case"float":return[e.getFloat32(t,n),4];case"float64":case"double":return[e.getFloat64(t,n),8]}}function l(e,t,r,n){for(var a,o={},i=0,l=0;l<r.length;l++)if("list"===r[l].type){var c=[],f=(a=s(e,t+i,r[l].countType,n))[0];i+=a[1];for(var d=0;d<f;d++)a=s(e,t+i,r[l].itemType,n),c.push(a[0]),i+=a[1];o[r[l].name]=c}else a=s(e,t+i,r[l].type,n),o[r[l].name]=a[0],i+=a[1];return[o,i]}var c,f=this;if(e instanceof ArrayBuffer){var d=THREE.LoaderUtils.decodeText(new Uint8Array(e)),u=t(d);c="ascii"===u.format?a(d,u):function(e,t){for(var r,n={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]},a="binary_little_endian"===t.format,s=new DataView(e,t.headerLength),c=0,f=0;f<t.elements.length;f++)for(var d=0;d<t.elements[f].count;d++){c+=(r=l(s,c,t.elements[f].properties,a))[1];var u=r[0];i(n,t.elements[f].name,u)}return o(n)}(e,u)}else c=a(e,t(e));return c}})},function(e,t){THREE.PLYExporter=function(){},THREE.PLYExporter.prototype={constructor:THREE.PLYExporter,parse:function(e,t,r){function n(t){e.traverse((function(e){if(!0===e.isMesh){var r=e,n=r.geometry;!0===n.isGeometry&&(n=o.get(n)),!0===n.isBufferGeometry&&void 0!==n.getAttribute("position")&&t(r,n)}}))}t&&"object"==typeof t&&(console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.'),r=t,t=void 0);var a=(r=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},r)).excludeAttributes,o=new WeakMap,i=!1,s=!1,l=!1,c=0,f=0;e.traverse((function(e){if(!0===e.isMesh){var t=e,r=t.geometry;if(!0===r.isGeometry){var n=o.get(r)||(new THREE.BufferGeometry).setFromObject(t);o.set(r,n),r=n}if(!0===r.isBufferGeometry){var a=r.getAttribute("position"),d=r.getAttribute("normal"),u=r.getAttribute("uv"),p=r.getAttribute("color"),h=r.getIndex();if(void 0===a)return;c+=a.count,f+=h?h.count/3:a.count/3,void 0!==d&&(i=!0),void 0!==u&&(l=!0),void 0!==p&&(s=!0)}}}));var d=-1===a.indexOf("index");if(i=i&&-1===a.indexOf("normal"),s=s&&-1===a.indexOf("color"),l=l&&-1===a.indexOf("uv"),d&&f!==Math.floor(f))return console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."),null;var u=`ply\nformat ${r.binary?r.littleEndian?"binary_little_endian":"binary_big_endian":"ascii"} 1.0\nelement vertex ${c}\nproperty float x\nproperty float y\nproperty float z\n`;!0===i&&(u+="property float nx\nproperty float ny\nproperty float nz\n"),!0===l&&(u+="property float s\nproperty float t\n"),!0===s&&(u+="property uchar red\nproperty uchar green\nproperty uchar blue\n"),!0===d&&(u+=`element face ${f}\nproperty list uchar int vertex_index\n`),u+="end_header\n";var p=new THREE.Vector3,h=new THREE.Matrix3,v=null;if(!0===r.binary){var m=(new TextEncoder).encode(u),x=c*(12+(i?12:0)+(s?3:0)+(l?8:0)),g=d?13*f:0,y=new DataView(new ArrayBuffer(m.length+x+g));new Uint8Array(y.buffer).set(m,0);var E=m.length,w=m.length+x,b=0;n((function(e,t){var n=t.getAttribute("position"),a=t.getAttribute("normal"),o=t.getAttribute("uv"),c=t.getAttribute("color"),f=t.getIndex();h.getNormalMatrix(e.matrixWorld);for(var u=0,v=n.count;u<v;u++)p.x=n.getX(u),p.y=n.getY(u),p.z=n.getZ(u),p.applyMatrix4(e.matrixWorld),y.setFloat32(E,p.x,r.littleEndian),E+=4,y.setFloat32(E,p.y,r.littleEndian),E+=4,y.setFloat32(E,p.z,r.littleEndian),E+=4,!0===i&&(null!=a?(p.x=a.getX(u),p.y=a.getY(u),p.z=a.getZ(u),p.applyMatrix3(h).normalize(),y.setFloat32(E,p.x,r.littleEndian),E+=4,y.setFloat32(E,p.y,r.littleEndian),E+=4,y.setFloat32(E,p.z,r.littleEndian),E+=4):(y.setFloat32(E,0,r.littleEndian),E+=4,y.setFloat32(E,0,r.littleEndian),E+=4,y.setFloat32(E,0,r.littleEndian),E+=4)),!0===l&&(null!=o?(y.setFloat32(E,o.getX(u),r.littleEndian),E+=4,y.setFloat32(E,o.getY(u),r.littleEndian),E+=4):!1!==l&&(y.setFloat32(E,0,r.littleEndian),E+=4,y.setFloat32(E,0,r.littleEndian),E+=4)),!0===s&&(null!=c?(y.setUint8(E,Math.floor(255*c.getX(u))),E+=1,y.setUint8(E,Math.floor(255*c.getY(u))),E+=1,y.setUint8(E,Math.floor(255*c.getZ(u))),E+=1):(y.setUint8(E,255),E+=1,y.setUint8(E,255),E+=1,y.setUint8(E,255),E+=1));if(!0===d)if(null!==f)for(u=0,v=f.count;u<v;u+=3)y.setUint8(w,3),w+=1,y.setUint32(w,f.getX(u+0)+b,r.littleEndian),w+=4,y.setUint32(w,f.getX(u+1)+b,r.littleEndian),w+=4,y.setUint32(w,f.getX(u+2)+b,r.littleEndian),w+=4;else for(u=0,v=n.count;u<v;u+=3)y.setUint8(w,3),w+=1,y.setUint32(w,b+u,r.littleEndian),w+=4,y.setUint32(w,b+u+1,r.littleEndian),w+=4,y.setUint32(w,b+u+2,r.littleEndian),w+=4;b+=n.count})),v=y.buffer}else{b=0;var T="",_="";n((function(e,t){var r=t.getAttribute("position"),n=t.getAttribute("normal"),a=t.getAttribute("uv"),o=t.getAttribute("color"),c=t.getIndex();h.getNormalMatrix(e.matrixWorld);for(var u=0,v=r.count;u<v;u++){p.x=r.getX(u),p.y=r.getY(u),p.z=r.getZ(u),p.applyMatrix4(e.matrixWorld);var m=p.x+" "+p.y+" "+p.z;!0===i&&(null!=n?(p.x=n.getX(u),p.y=n.getY(u),p.z=n.getZ(u),p.applyMatrix3(h).normalize(),m+=" "+p.x+" "+p.y+" "+p.z):m+=" 0 0 0"),!0===l&&(null!=a?m+=" "+a.getX(u)+" "+a.getY(u):!1!==l&&(m+=" 0 0")),!0===s&&(m+=null!=o?" "+Math.floor(255*o.getX(u))+" "+Math.floor(255*o.getY(u))+" "+Math.floor(255*o.getZ(u)):" 255 255 255"),T+=m+"\n"}if(!0===d){if(null!==c)for(u=0,v=c.count;u<v;u+=3)_+="3 "+(c.getX(u+0)+b),_+=" "+(c.getX(u+1)+b),_+=` ${c.getX(u+2)+b}\n`;else for(u=0,v=r.count;u<v;u+=3)_+=`3 ${b+u} ${b+u+1} ${b+u+2}\n`;f+=c?c.count/3:r.count/3}b+=r.count})),v=`${u}${T}${d?_+"\n":"\n"}`}return"function"==typeof t&&requestAnimationFrame(()=>t(v)),v}}},function(e,t){THREE.ColladaLoader=function(e){THREE.Loader.call(this,e)},THREE.ColladaLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.ColladaLoader,load:function(e,t,r,n){var a=this,o=""===a.path?THREE.LoaderUtils.extractUrlBase(e):a.path,i=new THREE.FileLoader(a.manager);i.setPath(a.path),i.setRequestHeader(a.requestHeader),i.load(e,(function(r){try{t(a.parse(r,o))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},options:{set convertUpAxis(e){console.warn("THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.")}},parse:function(e,t){function r(e,t){for(var r=[],n=e.childNodes,a=0,o=n.length;a<o;a++){var i=n[a];i.nodeName===t&&r.push(i)}return r}function n(e){if(0===e.length)return[];for(var t=e.trim().split(/\s+/),r=new Array(t.length),n=0,a=t.length;n<a;n++)r[n]=t[n];return r}function a(e){if(0===e.length)return[];for(var t=e.trim().split(/\s+/),r=new Array(t.length),n=0,a=t.length;n<a;n++)r[n]=parseFloat(t[n]);return r}function o(e){if(0===e.length)return[];for(var t=e.trim().split(/\s+/),r=new Array(t.length),n=0,a=t.length;n<a;n++)r[n]=parseInt(t[n]);return r}function i(e){return e.substring(1)}function s(e){return 0===Object.keys(e).length}function l(e){return void 0!==e&&!0===e.hasAttribute("meter")?parseFloat(e.getAttribute("meter")):1}function c(e){return void 0!==e?e.textContent:"Y_UP"}function f(e,t,n,a){var o=r(e,t)[0];if(void 0!==o)for(var i=r(o,n),s=0;s<i.length;s++)a(i[s])}function d(e,t){for(var r in e){e[r].build=t(e[r])}}function u(e,t){return void 0!==e.build||(e.build=t(e)),e.build}function p(e){for(var t={inputs:{}},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"input":var o=i(a.getAttribute("source")),s=a.getAttribute("semantic");t.inputs[s]=o}}return t}function h(e){var t={},r=e.getAttribute("target").split("/"),n=r.shift(),a=r.shift(),o=-1!==a.indexOf("("),s=-1!==a.indexOf(".");if(s)r=a.split("."),a=r.shift(),t.member=r.shift();else if(o){var l=a.split("(");a=l.shift();for(var c=0;c<l.length;c++)l[c]=parseInt(l[c].replace(/\)/,""));t.indices=l}return t.id=n,t.sid=a,t.arraySyntax=o,t.memberSyntax=s,t.sampler=i(e.getAttribute("source")),t}function v(e){var t=[],r=e.channels,n=e.samplers,a=e.sources;for(var o in r)if(r.hasOwnProperty(o)){var i=r[o],s=n[i.sampler],l=s.inputs.INPUT,c=s.inputs.OUTPUT;w(x(i,a[l],a[c]),t)}return t}function m(e){return u(Qe.animations[e],v)}function x(e,t,r){var n,a,o,i,s,l,c=Qe.nodes[e.id],f=Ne(c.id),d=c.transforms[e.sid],u=c.matrix.clone().transpose(),p={};switch(d){case"matrix":for(o=0,i=t.array.length;o<i;o++)if(n=t.array[o],a=o*r.stride,void 0===p[n]&&(p[n]={}),!0===e.arraySyntax){var h=r.array[a],v=e.indices[0]+4*e.indices[1];p[n][v]=h}else for(s=0,l=r.stride;s<l;s++)p[n][s]=r.array[a+s];break;case"translate":case"rotate":case"scale":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',d)}var m=function(e,t){var r=[];for(var n in e)r.push({time:parseFloat(n),value:e[n]});r.sort((function(e,t){return e.time-t.time}));for(var a=0;a<16;a++)b(r,a,t.elements[a]);return r}(p,u);return{name:f.uuid,keyframes:m}}var g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Quaternion;function w(e,t){for(var r=e.keyframes,n=e.name,a=[],o=[],i=[],s=[],l=0,c=r.length;l<c;l++){var f=r[l],d=f.time,u=f.value;_e.fromArray(u).transpose(),_e.decompose(g,E,y),a.push(d),o.push(g.x,g.y,g.z),i.push(E.x,E.y,E.z,E.w),s.push(y.x,y.y,y.z)}return o.length>0&&t.push(new THREE.VectorKeyframeTrack(n+".position",a,o)),i.length>0&&t.push(new THREE.QuaternionKeyframeTrack(n+".quaternion",a,i)),s.length>0&&t.push(new THREE.VectorKeyframeTrack(n+".scale",a,s)),t}function b(e,t,r){var n,a,o,i=!0;for(a=0,o=e.length;a<o;a++)void 0===(n=e[a]).value[t]?n.value[t]=null:i=!1;if(!0===i)for(a=0,o=e.length;a<o;a++)(n=e[a]).value[t]=r;else!function(e,t){for(var r,n,a=0,o=e.length;a<o;a++){var i=e[a];if(null===i.value[t]){if(r=T(e,a,t),n=_(e,a,t),null===r){i.value[t]=n.value[t];continue}if(null===n){i.value[t]=r.value[t];continue}S(i,r,n,t)}}}(e,t)}function T(e,t,r){for(;t>=0;){var n=e[t];if(null!==n.value[r])return n;t--}return null}function _(e,t,r){for(;t<e.length;){var n=e[t];if(null!==n.value[r])return n;t++}return null}function S(e,t,r,n){r.time-t.time!=0?e.value[n]=(e.time-t.time)*(r.value[n]-t.value[n])/(r.time-t.time)+t.value[n]:e.value[n]=t.value[n]}function R(e){for(var t=[],r=e.name,n=e.end-e.start||-1,a=e.animations,o=0,i=a.length;o<i;o++)for(var s=m(a[o]),l=0,c=s.length;l<c;l++)t.push(s[l]);return new THREE.AnimationClip(r,n,t)}function A(e){return u(Qe.clips[e],R)}function M(e){for(var t={sources:{}},r=0,n=e.childNodes.length;r<n;r++){var o=e.childNodes[r];if(1===o.nodeType)switch(o.nodeName){case"bind_shape_matrix":t.bindShapeMatrix=a(o.textContent);break;case"source":var i=o.getAttribute("id");t.sources[i]=ae(o);break;case"joints":t.joints=C(o);break;case"vertex_weights":t.vertexWeights=L(o)}}return t}function C(e){for(var t={inputs:{}},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"input":var o=a.getAttribute("semantic"),s=i(a.getAttribute("source"));t.inputs[o]=s}}return t}function L(e){for(var t={inputs:{}},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"input":var s=a.getAttribute("semantic"),l=i(a.getAttribute("source")),c=parseInt(a.getAttribute("offset"));t.inputs[s]={id:l,offset:c};break;case"vcount":t.vcount=o(a.textContent);break;case"v":t.v=o(a.textContent)}}return t}function H(e){var t={id:e.id},r=Qe.geometries[t.id];return void 0!==e.skin&&(t.skin=function(e){var t,r,n,a={joints:[],indices:{array:[],stride:4},weights:{array:[],stride:4}},o=e.sources,i=e.vertexWeights,s=i.vcount,l=i.v,c=i.inputs.JOINT.offset,f=i.inputs.WEIGHT.offset,d=e.sources[e.joints.inputs.JOINT],u=e.sources[e.joints.inputs.INV_BIND_MATRIX],p=o[i.inputs.WEIGHT.id].array,h=0;for(t=0,n=s.length;t<n;t++){var v=s[t],m=[];for(r=0;r<v;r++){var x=l[h+c],g=l[h+f],y=p[g];m.push({index:x,weight:y}),h+=2}for(m.sort(T),r=0;r<4;r++){var E=m[r];void 0!==E?(a.indices.array.push(E.index),a.weights.array.push(E.weight)):(a.indices.array.push(0),a.weights.array.push(0))}}e.bindShapeMatrix?a.bindMatrix=(new THREE.Matrix4).fromArray(e.bindShapeMatrix).transpose():a.bindMatrix=(new THREE.Matrix4).identity();for(t=0,n=d.array.length;t<n;t++){var w=d.array[t],b=(new THREE.Matrix4).fromArray(u.array,t*u.stride).transpose();a.joints.push({name:w,boneInverse:b})}return a;function T(e,t){return t.weight-e.weight}}(e.skin),r.sources.skinIndices=t.skin.indices,r.sources.skinWeights=t.skin.weights),t}function P(e){return void 0!==e.build?e.build:e.init_from}function z(e){var t=Qe.images[e];return void 0!==t?u(t,P):(console.warn("THREE.ColladaLoader: Couldn't find image with ID:",e),null)}function k(e){for(var t={surfaces:{},samplers:{}},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"newparam":N(a,t);break;case"technique":t.technique=I(a);break;case"extra":t.extra=j(a)}}return t}function N(e,t){for(var r=e.getAttribute("sid"),n=0,a=e.childNodes.length;n<a;n++){var o=e.childNodes[n];if(1===o.nodeType)switch(o.nodeName){case"surface":t.surfaces[r]=D(o);break;case"sampler2D":t.samplers[r]=F(o)}}}function D(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"init_from":t.init_from=a.textContent}}return t}function F(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"source":t.source=a.textContent}}return t}function I(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"constant":case"lambert":case"blinn":case"phong":t.type=a.nodeName,t.parameters=O(a)}}return t}function O(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"emission":case"diffuse":case"specular":case"bump":case"ambient":case"shininess":case"transparency":t[a.nodeName]=U(a);break;case"transparent":t[a.nodeName]={opaque:a.getAttribute("opaque"),data:U(a)}}}return t}function U(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var o=e.childNodes[r];if(1===o.nodeType)switch(o.nodeName){case"color":t[o.nodeName]=a(o.textContent);break;case"float":t[o.nodeName]=parseFloat(o.textContent);break;case"texture":t[o.nodeName]={id:o.getAttribute("texture"),extra:G(o)}}}return t}function G(e){for(var t={technique:{}},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"extra":B(a,t)}}return t}function B(e,t){for(var r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"technique":V(a,t)}}}function V(e,t){for(var r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"repeatU":case"repeatV":case"offsetU":case"offsetV":t.technique[a.nodeName]=parseFloat(a.textContent);break;case"wrapU":case"wrapV":"TRUE"===a.textContent.toUpperCase()?t.technique[a.nodeName]=1:"FALSE"===a.textContent.toUpperCase()?t.technique[a.nodeName]=0:t.technique[a.nodeName]=parseInt(a.textContent)}}}function j(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"technique":t.technique=W(a)}}return t}function W(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"double_sided":t[a.nodeName]=parseInt(a.textContent)}}return t}function q(e){return e}function X(e){var t,r,n=(t=e.url,u(Qe.effects[t],q)),a=n.profile.technique,o=n.profile.extra;switch(a.type){case"phong":case"blinn":r=new THREE.MeshPhongMaterial;break;case"lambert":r=new THREE.MeshLambertMaterial;break;default:r=new THREE.MeshBasicMaterial}function i(e){var t=n.profile.samplers[e.id],r=null;void 0!==t?r=z(n.profile.surfaces[t.source].init_from):(console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),r=z(e.id));if(null!==r){var a=function(e){var t,r=e.slice(2+(e.lastIndexOf(".")-1>>>0));switch(r=r.toLowerCase()){case"tga":t=je;break;default:t=qe}return t}(r);if(void 0!==a){var o=a.load(r),i=e.extra;if(void 0!==i&&void 0!==i.technique&&!1===s(i.technique)){var l=i.technique;o.wrapS=l.wrapU?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,o.wrapT=l.wrapV?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,o.offset.set(l.offsetU||0,l.offsetV||0),o.repeat.set(l.repeatU||1,l.repeatV||1)}else o.wrapS=THREE.RepeatWrapping,o.wrapT=THREE.RepeatWrapping;return o}return console.warn("THREE.ColladaLoader: Loader for texture %s not found.",r),null}return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:",e.id),null}r.name=e.name||"";var l=a.parameters;for(var c in l){var f=l[c];switch(c){case"diffuse":f.color&&r.color.fromArray(f.color),f.texture&&(r.map=i(f.texture));break;case"specular":f.color&&r.specular&&r.specular.fromArray(f.color),f.texture&&(r.specularMap=i(f.texture));break;case"bump":f.texture&&(r.normalMap=i(f.texture));break;case"ambient":f.texture&&(r.lightMap=i(f.texture));break;case"shininess":f.float&&r.shininess&&(r.shininess=f.float);break;case"emission":f.color&&r.emissive&&r.emissive.fromArray(f.color),f.texture&&(r.emissiveMap=i(f.texture))}}var d=l.transparent,p=l.transparency;if(void 0===p&&d&&(p={float:1}),void 0===d&&p&&(d={opaque:"A_ONE",data:{color:[1,1,1,1]}}),d&&p)if(d.data.texture)r.transparent=!0;else{var h=d.data.color;switch(d.opaque){case"A_ONE":r.opacity=h[3]*p.float;break;case"RGB_ZERO":r.opacity=1-h[0]*p.float;break;case"A_ZERO":r.opacity=1-h[3]*p.float;break;case"RGB_ONE":r.opacity=h[0]*p.float;break;default:console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',d.opaque)}r.opacity<1&&(r.transparent=!0)}return void 0!==o&&void 0!==o.technique&&1===o.technique.double_sided&&(r.side=THREE.DoubleSide),r}function Y(e){return u(Qe.materials[e],X)}function Z(e){for(var t=0;t<e.childNodes.length;t++){var r=e.childNodes[t];switch(r.nodeName){case"technique_common":return Q(r)}}return{}}function Q(e){for(var t={},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];switch(n.nodeName){case"perspective":case"orthographic":t.technique=n.nodeName,t.parameters=K(n)}}return t}function K(e){for(var t={},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];switch(n.nodeName){case"xfov":case"yfov":case"xmag":case"ymag":case"znear":case"zfar":case"aspect_ratio":t[n.nodeName]=parseFloat(n.textContent)}}return t}function J(e){var t;switch(e.optics.technique){case"perspective":t=new THREE.PerspectiveCamera(e.optics.parameters.yfov,e.optics.parameters.aspect_ratio,e.optics.parameters.znear,e.optics.parameters.zfar);break;case"orthographic":var r=e.optics.parameters.ymag,n=e.optics.parameters.xmag,a=e.optics.parameters.aspect_ratio;n=void 0===n?r*a:n,r=void 0===r?n/a:r,n*=.5,r*=.5,t=new THREE.OrthographicCamera(-n,n,r,-r,e.optics.parameters.znear,e.optics.parameters.zfar);break;default:t=new THREE.PerspectiveCamera}return t.name=e.name||"",t}function $(e){var t=Qe.cameras[e];return void 0!==t?u(t,J):(console.warn("THREE.ColladaLoader: Couldn't find camera with ID:",e),null)}function ee(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"directional":case"point":case"spot":case"ambient":t.technique=a.nodeName,t.parameters=te(a)}}return t}function te(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var o=e.childNodes[r];if(1===o.nodeType)switch(o.nodeName){case"color":var i=a(o.textContent);t.color=(new THREE.Color).fromArray(i);break;case"falloff_angle":t.falloffAngle=parseFloat(o.textContent);break;case"quadratic_attenuation":var s=parseFloat(o.textContent);t.distance=s?Math.sqrt(1/s):0}}return t}function re(e){var t;switch(e.technique){case"directional":t=new THREE.DirectionalLight;break;case"point":t=new THREE.PointLight;break;case"spot":t=new THREE.SpotLight;break;case"ambient":t=new THREE.AmbientLight}return e.parameters.color&&t.color.copy(e.parameters.color),e.parameters.distance&&(t.distance=e.parameters.distance),t}function ne(e){var t=Qe.lights[e];return void 0!==t?u(t,re):(console.warn("THREE.ColladaLoader: Couldn't find light with ID:",e),null)}function ae(e){for(var t={array:[],stride:3},o=0;o<e.childNodes.length;o++){var i=e.childNodes[o];if(1===i.nodeType)switch(i.nodeName){case"float_array":t.array=a(i.textContent);break;case"Name_array":t.array=n(i.textContent);break;case"technique_common":var s=r(i,"accessor")[0];void 0!==s&&(t.stride=parseInt(s.getAttribute("stride")))}}return t}function oe(e){for(var t={},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];1===n.nodeType&&(t[n.getAttribute("semantic")]=i(n.getAttribute("source")))}return t}function ie(e){for(var t={type:e.nodeName,material:e.getAttribute("material"),count:parseInt(e.getAttribute("count")),inputs:{},stride:0,hasUV:!1},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"input":var s=i(a.getAttribute("source")),l=a.getAttribute("semantic"),c=parseInt(a.getAttribute("offset")),f=parseInt(a.getAttribute("set")),d=f>0?l+f:l;t.inputs[d]={id:s,offset:c},t.stride=Math.max(t.stride,c+1),"TEXCOORD"===l&&(t.hasUV=!0);break;case"vcount":t.vcount=o(a.textContent);break;case"p":t.p=o(a.textContent)}}return t}function se(e){for(var t=0,r=0,n=e.length;r<n;r++){!0===e[r].hasUV&&t++}t>0&&t<e.length&&(e.uvsNeedsFix=!0)}function le(e){var t={},r=e.sources,n=e.vertices,a=e.primitives;if(0===a.length)return{};var o=function(e){for(var t={},r=0;r<e.length;r++){var n=e[r];void 0===t[n.type]&&(t[n.type]=[]),t[n.type].push(n)}return t}(a);for(var i in o){var s=o[i];se(s),t[i]=ce(s,r,n)}return t}function ce(e,t,r){for(var n={},a={array:[],stride:0},o={array:[],stride:0},i={array:[],stride:0},s={array:[],stride:0},l={array:[],stride:0},c=[],f=4,d=[],u=4,p=new THREE.BufferGeometry,h=[],v=0,m=0;m<e.length;m++){var x=e[m],g=x.inputs,y=0;switch(x.type){case"lines":case"linestrips":y=2*x.count;break;case"triangles":y=3*x.count;break;case"polylist":for(var E=0;E<x.count;E++){var w=x.vcount[E];switch(w){case 3:y+=3;break;case 4:y+=6;break;default:y+=3*(w-2)}}break;default:console.warn("THREE.ColladaLoader: Unknow primitive type:",x.type)}for(var b in p.addGroup(v,y,m),v+=y,x.material&&h.push(x.material),g){var T=g[b];switch(b){case"VERTEX":for(var _ in r){var S=r[_];switch(_){case"POSITION":var R=a.array.length;if(fe(x,t[S],T.offset,a.array),a.stride=t[S].stride,t.skinWeights&&t.skinIndices&&(fe(x,t.skinIndices,T.offset,c),fe(x,t.skinWeights,T.offset,d)),!1===x.hasUV&&!0===e.uvsNeedsFix){y=(a.array.length-R)/a.stride;for(var A=0;A<y;A++)i.array.push(0,0)}break;case"NORMAL":fe(x,t[S],T.offset,o.array),o.stride=t[S].stride;break;case"COLOR":fe(x,t[S],T.offset,l.array),l.stride=t[S].stride;break;case"TEXCOORD":fe(x,t[S],T.offset,i.array),i.stride=t[S].stride;break;case"TEXCOORD1":fe(x,t[S],T.offset,s.array),i.stride=t[S].stride;break;default:console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',_)}}break;case"NORMAL":fe(x,t[T.id],T.offset,o.array),o.stride=t[T.id].stride;break;case"COLOR":fe(x,t[T.id],T.offset,l.array),l.stride=t[T.id].stride;break;case"TEXCOORD":fe(x,t[T.id],T.offset,i.array),i.stride=t[T.id].stride;break;case"TEXCOORD1":fe(x,t[T.id],T.offset,s.array),s.stride=t[T.id].stride}}}return a.array.length>0&&p.setAttribute("position",new THREE.Float32BufferAttribute(a.array,a.stride)),o.array.length>0&&p.setAttribute("normal",new THREE.Float32BufferAttribute(o.array,o.stride)),l.array.length>0&&p.setAttribute("color",new THREE.Float32BufferAttribute(l.array,l.stride)),i.array.length>0&&p.setAttribute("uv",new THREE.Float32BufferAttribute(i.array,i.stride)),s.array.length>0&&p.setAttribute("uv2",new THREE.Float32BufferAttribute(s.array,s.stride)),c.length>0&&p.setAttribute("skinIndex",new THREE.Float32BufferAttribute(c,f)),d.length>0&&p.setAttribute("skinWeight",new THREE.Float32BufferAttribute(d,u)),n.data=p,n.type=e[0].type,n.materialKeys=h,n}function fe(e,t,r,n){var a=e.p,o=e.stride,i=e.vcount;function s(e){for(var t=a[e+r]*c,o=t+c;t<o;t++)n.push(l[t])}var l=t.array,c=t.stride;if(void 0!==e.vcount)for(var f=0,d=0,u=i.length;d<u;d++){var p=i[d];if(4===p){var h=f+1*o,v=f+2*o,m=f+3*o;s(f+0*o),s(h),s(m),s(h),s(v),s(m)}else if(3===p){h=f+1*o,v=f+2*o;s(f+0*o),s(h),s(v)}else if(p>4)for(var x=1,g=p-2;x<=g;x++){h=f+o*x,v=f+o*(x+1);s(f+0*o),s(h),s(v)}f+=o*p}else for(d=0,u=a.length;d<u;d+=o)s(d)}function de(e){return u(Qe.geometries[e],le)}function ue(e){return void 0!==e.build?e.build:e}function pe(e,t){for(var r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"joint":t.joints[n.getAttribute("sid")]=he(n);break;case"link":t.links.push(me(n))}}}function he(e){for(var t,r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"prismatic":case"revolute":t=ve(n)}}return t}function ve(e,t){t={sid:e.getAttribute("sid"),name:e.getAttribute("name")||"",axis:new THREE.Vector3,limits:{min:0,max:0},type:e.nodeName,static:!1,zeroPosition:0,middlePosition:0};for(var r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"axis":var o=a(n.textContent);t.axis.fromArray(o);break;case"limits":var i=n.getElementsByTagName("max")[0],s=n.getElementsByTagName("min")[0];t.limits.max=parseFloat(i.textContent),t.limits.min=parseFloat(s.textContent)}}return t.limits.min>=t.limits.max&&(t.static=!0),t.middlePosition=(t.limits.min+t.limits.max)/2,t}function me(e){for(var t={sid:e.getAttribute("sid"),name:e.getAttribute("name")||"",attachments:[],transforms:[]},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"attachment_full":t.attachments.push(xe(n));break;case"matrix":case"translate":case"rotate":t.transforms.push(ge(n))}}return t}function xe(e){for(var t={joint:e.getAttribute("joint").split("/").pop(),transforms:[],links:[]},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"link":t.links.push(me(n));break;case"matrix":case"translate":case"rotate":t.transforms.push(ge(n))}}return t}function ge(e){var t={type:e.nodeName},r=a(e.textContent);switch(t.type){case"matrix":t.obj=new THREE.Matrix4,t.obj.fromArray(r).transpose();break;case"translate":t.obj=new THREE.Vector3,t.obj.fromArray(r);break;case"rotate":t.obj=new THREE.Vector3,t.obj.fromArray(r),t.angle=THREE.MathUtils.degToRad(r[3])}return t}function ye(e,t){for(var r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"technique_common":Ee(n,t)}}}function Ee(e,t){for(var r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"inertia":t.inertia=a(n.textContent);break;case"mass":t.mass=a(n.textContent)[0]}}}function we(e){for(var t={target:e.getAttribute("target").split("/").pop()},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"axis":var a=n.getElementsByTagName("param")[0];t.axis=a.textContent;var o=t.axis.split("inst_").pop().split("axis")[0];t.jointIndex=o.substr(0,o.length-1)}}return t}function be(e){return void 0!==e.build?e.build:e}function Te(e){for(var t=[],r=Oe.querySelector('[id="'+e.id+'"]'),n=0;n<r.childNodes.length;n++){var o=r.childNodes[n];if(1===o.nodeType)switch(o.nodeName){case"matrix":var i=a(o.textContent),s=(new THREE.Matrix4).fromArray(i).transpose();t.push({sid:o.getAttribute("sid"),type:o.nodeName,obj:s});break;case"translate":case"scale":i=a(o.textContent);var l=(new THREE.Vector3).fromArray(i);t.push({sid:o.getAttribute("sid"),type:o.nodeName,obj:l});break;case"rotate":i=a(o.textContent),l=(new THREE.Vector3).fromArray(i);var c=THREE.MathUtils.degToRad(i[3]);t.push({sid:o.getAttribute("sid"),type:o.nodeName,obj:l,angle:c})}}return t}var _e=new THREE.Matrix4,Se=new THREE.Vector3;function Re(e){for(var t={name:e.getAttribute("name")||"",type:e.getAttribute("type"),id:e.getAttribute("id"),sid:e.getAttribute("sid"),matrix:new THREE.Matrix4,nodes:[],instanceCameras:[],instanceControllers:[],instanceLights:[],instanceGeometries:[],instanceNodes:[],transforms:{}},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"node":t.nodes.push(n.getAttribute("id")),Re(n);break;case"instance_camera":t.instanceCameras.push(i(n.getAttribute("url")));break;case"instance_controller":t.instanceControllers.push(Ae(n));break;case"instance_light":t.instanceLights.push(i(n.getAttribute("url")));break;case"instance_geometry":t.instanceGeometries.push(Ae(n));break;case"instance_node":t.instanceNodes.push(i(n.getAttribute("url")));break;case"matrix":var o=a(n.textContent);t.matrix.multiply(_e.fromArray(o).transpose()),t.transforms[n.getAttribute("sid")]=n.nodeName;break;case"translate":o=a(n.textContent);Se.fromArray(o),t.matrix.multiply(_e.makeTranslation(Se.x,Se.y,Se.z)),t.transforms[n.getAttribute("sid")]=n.nodeName;break;case"rotate":o=a(n.textContent);var s=THREE.MathUtils.degToRad(o[3]);t.matrix.multiply(_e.makeRotationAxis(Se.fromArray(o),s)),t.transforms[n.getAttribute("sid")]=n.nodeName;break;case"scale":o=a(n.textContent);t.matrix.scale(Se.fromArray(o)),t.transforms[n.getAttribute("sid")]=n.nodeName;break;case"extra":break;default:console.log(n)}}return ke(t.id)?console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",t.id):Qe.nodes[t.id]=t,t}function Ae(e){for(var t={id:i(e.getAttribute("url")),materials:{},skeletons:[]},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];switch(n.nodeName){case"bind_material":for(var a=n.getElementsByTagName("instance_material"),o=0;o<a.length;o++){var s=a[o],l=s.getAttribute("symbol"),c=s.getAttribute("target");t.materials[l]=i(c)}break;case"skeleton":t.skeletons.push(i(n.textContent))}}return t}function Me(e,t){var r,n,a,o=[],i=[];for(r=0;r<e.length;r++){var s=e[r];if(ke(s))Ce(Ne(s),t,o);else if(a=s,void 0!==Qe.visualScenes[a])for(var l=Qe.visualScenes[s].children,c=0;c<l.length;c++){var f=l[c];if("JOINT"===f.type)Ce(Ne(f.id),t,o)}else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",s)}for(r=0;r<t.length;r++)for(c=0;c<o.length;c++)if((n=o[c]).bone.name===t[r].name){i[r]=n,n.processed=!0;break}for(r=0;r<o.length;r++)!1===(n=o[r]).processed&&(i.push(n),n.processed=!0);var d=[],u=[];for(r=0;r<i.length;r++)n=i[r],d.push(n.bone),u.push(n.boneInverse);return new THREE.Skeleton(d,u)}function Ce(e,t,r){e.traverse((function(e){if(!0===e.isBone){for(var n,a=0;a<t.length;a++){var o=t[a];if(o.name===e.name){n=o.boneInverse;break}}void 0===n&&(n=new THREE.Matrix4),r.push({bone:e,boneInverse:n,processed:!1})}}))}function Le(e){for(var t,r=[],n=e.matrix,a=e.nodes,o=e.type,i=e.instanceCameras,s=e.instanceControllers,l=e.instanceLights,c=e.instanceGeometries,f=e.instanceNodes,d=0,p=a.length;d<p;d++)r.push(Ne(a[d]));for(d=0,p=i.length;d<p;d++){var h=$(i[d]);null!==h&&r.push(h.clone())}for(d=0,p=s.length;d<p;d++)for(var v=s[d],m=(t=v.id,u(Qe.controllers[t],H)),x=ze(de(m.id),v.materials),g=Me(v.skeletons,m.skin.joints),y=0,E=x.length;y<E;y++){var w;(w=x[y]).isSkinnedMesh&&(w.bind(g,m.skin.bindMatrix),w.normalizeSkinWeights()),r.push(w)}for(d=0,p=l.length;d<p;d++){var b=ne(l[d]);null!==b&&r.push(b.clone())}for(d=0,p=c.length;d<p;d++)for(y=0,E=(x=ze(de((v=c[d]).id),v.materials)).length;y<E;y++)r.push(x[y]);for(d=0,p=f.length;d<p;d++)r.push(Ne(f[d]).clone());if(0===a.length&&1===r.length)w=r[0];else{w="JOINT"===o?new THREE.Bone:new THREE.Group;for(d=0;d<r.length;d++)w.add(r[d])}return w.name="JOINT"===o?e.sid:e.name,w.matrix.copy(n),w.matrix.decompose(w.position,w.quaternion,w.scale),w}var He=new THREE.MeshBasicMaterial({color:16711935});function Pe(e,t){for(var r=[],n=0,a=e.length;n<a;n++){var o=t[e[n]];void 0===o?(console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",e[n]),r.push(He)):r.push(Y(o))}return r}function ze(e,t){var r=[];for(var n in e){var a=e[n],o=Pe(a.materialKeys,t);0===o.length&&("lines"===n||"linestrips"===n?o.push(new THREE.LineBasicMaterial):o.push(new THREE.MeshPhongMaterial));var i=void 0!==a.data.attributes.skinIndex;if(i)for(var s=0,l=o.length;s<l;s++)o[s].skinning=!0;var c,f=1===o.length?o[0]:o;switch(n){case"lines":c=new THREE.LineSegments(a.data,f);break;case"linestrips":c=new THREE.Line(a.data,f);break;case"triangles":case"polylist":c=i?new THREE.SkinnedMesh(a.data,f):new THREE.Mesh(a.data,f)}r.push(c)}return r}function ke(e){return void 0!==Qe.nodes[e]}function Ne(e){return u(Qe.nodes[e],Le)}function De(e){var t=new THREE.Group;t.name=e.name;for(var r=e.children,n=0;n<r.length;n++){var a=r[n];t.add(Ne(a.id))}return t}function Fe(e){return u(Qe.visualScenes[e],De)}if(0===e.length)return{scene:new THREE.Scene};var Ie=(new DOMParser).parseFromString(e,"application/xml"),Oe=r(Ie,"COLLADA")[0],Ue=Ie.getElementsByTagName("parsererror")[0];if(void 0!==Ue){var Ge,Be=r(Ue,"div")[0];return Ge=Be?Be.textContent:function(e){for(var t="",r=[e];r.length;){var n=r.shift();n.nodeType===Node.TEXT_NODE?t+=n.textContent:(t+="\n",r.push.apply(r,n.childNodes))}return t.trim()}(Ue),console.error("THREE.ColladaLoader: Failed to parse collada file.\n",Ge),null}var Ve=Oe.getAttribute("version");console.log("THREE.ColladaLoader: File version",Ve);var je,We=function(e){return{unit:l(r(e,"unit")[0]),upAxis:c(r(e,"up_axis")[0])}}(r(Oe,"asset")[0]),qe=new THREE.TextureLoader(this.manager);qe.setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin),THREE.TGALoader&&(je=new THREE.TGALoader(this.manager)).setPath(this.resourcePath||t);var Xe=[],Ye={},Ze=0,Qe={animations:{},clips:{},controllers:{},images:{},effects:{},materials:{},cameras:{},lights:{},geometries:{},nodes:{},visualScenes:{},kinematicsModels:{},physicsModels:{},kinematicsScenes:{}};f(Oe,"library_animations","animation",(function e(t){for(var r={sources:{},samplers:{},channels:{}},n=!1,a=0,o=t.childNodes.length;a<o;a++){var i,s=t.childNodes[a];if(1===s.nodeType)switch(s.nodeName){case"source":i=s.getAttribute("id"),r.sources[i]=ae(s);break;case"sampler":i=s.getAttribute("id"),r.samplers[i]=p(s);break;case"channel":i=s.getAttribute("target"),r.channels[i]=h(s);break;case"animation":e(s),n=!0;break;default:console.log(s)}}!1===n&&(Qe.animations[t.getAttribute("id")||THREE.MathUtils.generateUUID()]=r)})),f(Oe,"library_animation_clips","animation_clip",(function(e){for(var t={name:e.getAttribute("id")||"default",start:parseFloat(e.getAttribute("start")||0),end:parseFloat(e.getAttribute("end")||0),animations:[]},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"instance_animation":t.animations.push(i(a.getAttribute("url")))}}Qe.clips[e.getAttribute("id")]=t})),f(Oe,"library_controllers","controller",(function(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"skin":t.id=i(a.getAttribute("source")),t.skin=M(a);break;case"morph":t.id=i(a.getAttribute("source")),console.warn("THREE.ColladaLoader: Morph target animation not supported yet.")}}Qe.controllers[e.getAttribute("id")]=t})),f(Oe,"library_images","image",(function(e){var t={init_from:r(e,"init_from")[0].textContent};Qe.images[e.getAttribute("id")]=t})),f(Oe,"library_effects","effect",(function(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"profile_COMMON":t.profile=k(a)}}Qe.effects[e.getAttribute("id")]=t})),f(Oe,"library_materials","material",(function(e){for(var t={name:e.getAttribute("name")},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"instance_effect":t.url=i(a.getAttribute("url"))}}Qe.materials[e.getAttribute("id")]=t})),f(Oe,"library_cameras","camera",(function(e){for(var t={name:e.getAttribute("name")},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"optics":t.optics=Z(a)}}Qe.cameras[e.getAttribute("id")]=t})),f(Oe,"library_lights","light",(function(e){for(var t={},r=0,n=e.childNodes.length;r<n;r++){var a=e.childNodes[r];if(1===a.nodeType)switch(a.nodeName){case"technique_common":t=ee(a)}}Qe.lights[e.getAttribute("id")]=t})),f(Oe,"library_geometries","geometry",(function(e){var t={name:e.getAttribute("name"),sources:{},vertices:{},primitives:[]},n=r(e,"mesh")[0];if(void 0!==n){for(var a=0;a<n.childNodes.length;a++){var o=n.childNodes[a];if(1===o.nodeType){var i=o.getAttribute("id");switch(o.nodeName){case"source":t.sources[i]=ae(o);break;case"vertices":t.vertices=oe(o);break;case"polygons":console.warn("THREE.ColladaLoader: Unsupported primitive type: ",o.nodeName);break;case"lines":case"linestrips":case"polylist":case"triangles":t.primitives.push(ie(o));break;default:console.log(o)}}}Qe.geometries[e.getAttribute("id")]=t}})),f(Oe,"library_nodes","node",Re),f(Oe,"library_visual_scenes","visual_scene",(function(e){var t={name:e.getAttribute("name"),children:[]};!function(e){for(var t=e.getElementsByTagName("node"),r=0;r<t.length;r++){var n=t[r];!1===n.hasAttribute("id")&&n.setAttribute("id","three_default_"+Ze++)}}(e);for(var n=r(e,"node"),a=0;a<n.length;a++)t.children.push(Re(n[a]));Qe.visualScenes[e.getAttribute("id")]=t})),f(Oe,"library_kinematics_models","kinematics_model",(function(e){for(var t={name:e.getAttribute("name")||"",joints:{},links:[]},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"technique_common":pe(n,t)}}Qe.kinematicsModels[e.getAttribute("id")]=t})),f(Oe,"library_physics_models","physics_model",(function(e){for(var t={name:e.getAttribute("name")||"",rigidBodies:{}},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"rigid_body":t.rigidBodies[n.getAttribute("name")]={},ye(n,t.rigidBodies[n.getAttribute("name")])}}Qe.physicsModels[e.getAttribute("id")]=t})),f(Oe,"scene","instance_kinematics_scene",(function(e){for(var t={bindJointAxis:[]},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];if(1===n.nodeType)switch(n.nodeName){case"bind_joint_axis":t.bindJointAxis.push(we(n))}}Qe.kinematicsScenes[i(e.getAttribute("url"))]=t})),d(Qe.animations,v),d(Qe.clips,R),d(Qe.controllers,H),d(Qe.images,P),d(Qe.effects,q),d(Qe.materials,X),d(Qe.cameras,J),d(Qe.lights,re),d(Qe.geometries,le),d(Qe.visualScenes,De),function(){var e=Qe.clips;if(!0===s(e)){if(!1===s(Qe.animations)){var t=[];for(var r in Qe.animations)for(var n=m(r),a=0,o=n.length;a<o;a++)t.push(n[a]);Xe.push(new THREE.AnimationClip("default",-1,t))}}else for(var r in e)Xe.push(A(r))}(),function(){var e=Object.keys(Qe.kinematicsModels)[0],t=Object.keys(Qe.kinematicsScenes)[0],r=Object.keys(Qe.visualScenes)[0];if(void 0!==e&&void 0!==t){for(var n,a=(n=e,u(Qe.kinematicsModels[n],ue)),o=function(e){return u(Qe.kinematicsScenes[e],be)}(t),i=Fe(r),s=o.bindJointAxis,l={},c=0,f=s.length;c<f;c++){var d=s[c],p=Oe.querySelector('[sid="'+d.target+'"]');if(p){var h=p.parentElement;m(d.jointIndex,h)}}var v=new THREE.Matrix4;Ye={joints:a&&a.joints,getJointValue:function(e){var t=l[e];if(t)return t.position;console.warn("THREE.ColladaLoader: Joint "+e+" doesn't exist.")},setJointValue:function(e,t){var r=l[e];if(r){var n=r.joint;if(t>n.limits.max||t<n.limits.min)console.warn("THREE.ColladaLoader: Joint "+e+" value "+t+" outside of limits (min: "+n.limits.min+", max: "+n.limits.max+").");else if(n.static)console.warn("THREE.ColladaLoader: Joint "+e+" is static.");else{var a=r.object,o=n.axis,i=r.transforms;_e.identity();for(var s=0;s<i.length;s++){var c=i[s];if(c.sid&&-1!==c.sid.indexOf(e))switch(n.type){case"revolute":_e.multiply(v.makeRotationAxis(o,THREE.MathUtils.degToRad(t)));break;case"prismatic":_e.multiply(v.makeTranslation(o.x*t,o.y*t,o.z*t));break;default:console.warn("THREE.ColladaLoader: Unknown joint type: "+n.type)}else switch(c.type){case"matrix":_e.multiply(c.obj);break;case"translate":_e.multiply(v.makeTranslation(c.obj.x,c.obj.y,c.obj.z));break;case"scale":_e.scale(c.obj);break;case"rotate":_e.multiply(v.makeRotationAxis(c.obj,c.angle))}}a.matrix.copy(_e),a.matrix.decompose(a.position,a.quaternion,a.scale),l[e].position=t}}else console.log("THREE.ColladaLoader: "+e+" does not exist.")}}}function m(e,t){var r=t.getAttribute("name"),n=a.joints[e];i.traverse((function(a){a.name===r&&(l[e]={object:a,transforms:Te(t),joint:n,position:n.zeroPosition})}))}}();var Ke=function(e){return Fe(i(r(e,"instance_visual_scene")[0].getAttribute("url")))}(r(Oe,"scene")[0]);return"Z_UP"===We.upAxis&&Ke.quaternion.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)),Ke.scale.multiplyScalar(We.unit),{animations:Xe,kinematics:Ye,library:Qe,scene:Ke}}})},function(e,t){THREE.ColladaExporter=function(){},THREE.ColladaExporter.prototype={constructor:THREE.ColladaExporter,parse:function(e,t,r){r=r||{},""!==(r=Object.assign({version:"1.4.1",author:null,textureDirectory:""},r)).textureDirectory&&(r.textureDirectory=(r.textureDirectory+"/").replace(/\\/g,"/").replace(/\/+/g,"/"));var n,a,o=r.version;if("1.4.1"!==o&&"1.5.0"!==o)return console.warn(`ColladaExporter : Version ${o} not supported for export. Only 1.4.1 and 1.5.0.`),null;function i(e,t){return n=n||document.createElement("canvas"),a=a||n.getContext("2d"),n.width=e.naturalWidth,n.height=e.naturalHeight,a.drawImage(e,0,0),function(e){for(var t=atob(e),r=new Uint8Array(t.length),n=0,a=r.length;n<a;n++)r[n]=t.charCodeAt(n);return r}(n.toDataURL("image/"+t,1).replace(/^data:image\/(png|jpg);base64,/,""))}var s,l=["getX","getY","getZ","getW"];function c(e){if(e.isInterleavedBufferAttribute){for(var t=new e.array.constructor(e.count*e.itemSize),r=e.itemSize,n=0,a=e.count;n<a;n++)for(var o=0;o<r;o++)t[n*r+o]=e[l[o]](n);return t}return e.array}function f(e,t,r,n){var a=c(e);return`<source id="${t}"><float_array id="${t}-array" count="${a.length}">`+a.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(a.length/e.itemSize)}" stride="${e.itemSize}">`+r.map(e=>`<param name="${e}" type="${n}" />`).join("")+"</accessor></technique_common></source>"}function d(e){var t=h.get(e);if(null==t){t="image-"+(m.length+1);var n=e.name||t,a=`<image id="${t}" name="${n}">`;a+="1.5.0"===o?`<init_from><ref>${r.textureDirectory}${n}.png</ref></init_from>`:`<init_from>${r.textureDirectory}${n}.png</init_from>`,a+="</image>",m.push(a),h.set(e,t),v.push({directory:r.textureDirectory,name:n,ext:"png",data:i(e.image,"png"),original:e})}return t}var u=new WeakMap,p=new WeakMap,h=new WeakMap,v=[],m=[],x=[],g=[],y=[],E=function e(t){var r=`<node name="${t.name}">`;if(r+=function(e){return e.updateMatrix(),(s=s||new THREE.Matrix4).copy(e.matrix),s.transpose(),`<matrix>${s.toArray().join(" ")}</matrix>`}(t),t instanceof THREE.Mesh&&null!=t.geometry){var n=function(e){var t,r,n,a=u.get(e);if(!a){var o=e;o instanceof THREE.Geometry&&(o=(new THREE.BufferGeometry).fromGeometry(o));var i="Mesh"+(x.length+1),s=o.index?o.index.count*o.index.itemSize:o.attributes.position.count,l=null!=o.groups&&0!==o.groups.length?o.groups:[{start:0,count:s,materialIndex:0}],d=`<geometry id="${i}"${e.name?` name="${e.name}"`:""}><mesh>`,p=i+"-position",h=i+"-vertices";d+=f(o.attributes.position,p,["X","Y","Z"],"float"),d+=`<vertices id="${h}"><input semantic="POSITION" source="#${p}" /></vertices>`;var v=`<input semantic="VERTEX" source="#${h}" offset="0" />`;if("normal"in o.attributes){var m=i+"-normal";d+=f(o.attributes.normal,m,["X","Y","Z"],"float"),v+=`<input semantic="NORMAL" source="#${m}" offset="0" />`}if("uv"in o.attributes){var g=i+"-texcoord";d+=f(o.attributes.uv,g,["S","T"],"float"),v+=`<input semantic="TEXCOORD" source="#${g}" offset="0" set="0" />`}if("uv2"in o.attributes){g=i+"-texcoord2";d+=f(o.attributes.uv2,g,["S","T"],"float"),v+=`<input semantic="TEXCOORD" source="#${g}" offset="0" set="1" />`}if("color"in o.attributes){var y=i+"-color";d+=f(o.attributes.color,y,["X","Y","Z"],"uint8"),v+=`<input semantic="COLOR" source="#${y}" offset="0" />`}var E=null;if(o.index)E=c(o.index);else for(var w=0,b=(E=new Array(s)).length;w<b;w++)E[w]=w;for(w=0,b=l.length;w<b;w++){var T=l[w],_=(t=E,r=T.start,n=T.count,Array.isArray(t)?t.slice(r,r+n):new t.constructor(t.buffer,r*t.BYTES_PER_ELEMENT,n)),S=_.length/3;d+=`<triangles material="MESH_MATERIAL_${T.materialIndex}" count="${S}">`,d+=v,d+=`<p>${_.join(" ")}</p>`,d+="</triangles>"}d+="</mesh></geometry>",x.push(d),a={meshid:i,bufferGeometry:o},u.set(e,a)}return a}(t.geometry),a=n.meshid,o=n.bufferGeometry,i=null,l=t.material||new THREE.MeshBasicMaterial,h=Array.isArray(l)?l:[l];i=(o.groups.length>h.length?new Array(o.groups.length):new Array(h.length)).fill().map((e,t)=>function(e){var t=p.get(e);if(null==t){t="Mat"+(g.length+1);var r="phong";e instanceof THREE.MeshLambertMaterial?r="lambert":e instanceof THREE.MeshBasicMaterial&&(r="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with MeshBasicMaterial."));var n=e.emissive?e.emissive:new THREE.Color(0,0,0),a=e.color?e.color:new THREE.Color(0,0,0),o=e.specular?e.specular:new THREE.Color(1,1,1),i=e.shininess||0,s=e.reflectivity||0,l="";!0===e.transparent&&(l+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(l+=`<transparency><float>${e.opacity}</float></transparency>`));var c=`<technique sid="common"><${r}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${n.r} ${n.g} ${n.b} 1</color>`)+"</emission>"+("constant"!==r?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${a.r} ${a.g} ${a.b} 1</color>`)+"</diffuse>":"")+("constant"!==r?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===r?`<specular><color sid="specular">${o.r} ${o.g} ${o.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${i}</float>`)+"</shininess>":"")+`<reflective><color>${a.r} ${a.g} ${a.b} 1</color></reflective>`+`<reflectivity><float>${s}</float></reflectivity>`+l+`</${r}></technique>`,f=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${d(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${d(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${d(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${d(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+c+(e.side===THREE.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",u=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;y.push(u),g.push(f),p.set(e,t)}return t}(h[t%h.length])),r+=`<instance_geometry url="#${a}">`+(null!=i?"<bind_material><technique_common>"+i.map((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach(t=>r+=e(t)),r+="</node>"}(e),w=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===o?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${o}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==r.author?`<author>${r.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified><up_axis>Y_UP</up_axis></asset>`;w+=`<library_images>${m.join("")}</library_images>`,w+=`<library_effects>${g.join("")}</library_effects>`,w+=`<library_materials>${y.join("")}</library_materials>`,w+=`<library_geometries>${x.join("")}</library_geometries>`,w+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${E}</visual_scene></library_visual_scenes>`,w+='<scene><instance_visual_scene url="#Scene"/></scene>';var b,T,_,S,R,A,M={data:(b=w+="</COLLADA>",T=/^<\//,_=/(\?>$)|(\/>$)/,S=/<[^>]+>[^<]*<\/[^<]+>/,R=(e,t)=>t>0?e+R(e,t-1):"",A=0,b.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map(e=>{S.test(e)||_.test(e)||!T.test(e)||A--;var t=`${R("  ",A)}${e}`;return S.test(e)||_.test(e)||T.test(e)||A++,t}).join("\n")),textures:v};return"function"==typeof t&&requestAnimationFrame(()=>t(M)),M}}},function(e,t){THREE.GCodeLoader=function(e){THREE.Loader.call(this,e),this.splitLayer=!1},THREE.GCodeLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.GCodeLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t={x:0,y:0,z:0,e:0,f:0,extruding:!1,relative:!1},r=[],n=void 0,a=new THREE.LineBasicMaterial({color:16711680});a.name="path";var o=new THREE.LineBasicMaterial({color:65280});function i(e){n={vertex:[],pathVertex:[],z:e.z},r.push(n)}function s(e,r){return t.relative?r:r-e}function l(e,r){return t.relative?e+r:r}o.name="extruded";for(var c,f,d=e.replace(/;.+/g,"").split("\n"),u=0;u<d.length;u++){var p=d[u].split(" "),h=p[0].toUpperCase(),v={};if(p.splice(1).forEach((function(e){if(void 0!==e[0]){var t=e[0].toLowerCase(),r=parseFloat(e.substring(1));v[t]=r}})),"G0"===h||"G1"===h){var m={x:void 0!==v.x?l(t.x,v.x):t.x,y:void 0!==v.y?l(t.y,v.y):t.y,z:void 0!==v.z?l(t.z,v.z):t.z,e:void 0!==v.e?l(t.e,v.e):t.e,f:void 0!==v.f?l(t.f,v.f):t.f};s(t.e,m.e)>0&&(m.extruding=s(t.e,m.e)>0,null!=n&&m.z==n.z||i(m)),c=t,f=m,void 0===n&&i(c),m.extruding?(n.vertex.push(c.x,c.y,c.z),n.vertex.push(f.x,f.y,f.z)):(n.pathVertex.push(c.x,c.y,c.z),n.pathVertex.push(f.x,f.y,f.z)),t=m}else if("G2"===h||"G3"===h);else if("G90"===h)t.relative=!1;else if("G91"===h)t.relative=!0;else if("G92"===h){(m=t).x=void 0!==v.x?v.x:m.x,m.y=void 0!==v.y?v.y:m.y,m.z=void 0!==v.z?v.z:m.z,m.e=void 0!==v.e?v.e:m.e,t=m}}function x(e,t){var r=new THREE.BufferGeometry;r.setAttribute("position",new THREE.Float32BufferAttribute(e,3));var n=new THREE.LineSegments(r,t?o:a);n.name="layer"+u,g.add(n)}var g=new THREE.Group;if(g.name="gcode",this.splitLayer)for(u=0;u<r.length;u++){x((w=r[u]).vertex,!0),x(w.pathVertex,!1)}else{var y=[],E=[];for(u=0;u<r.length;u++){for(var w,b=(w=r[u]).vertex,T=w.pathVertex,_=0;_<b.length;_++)y.push(b[_]);for(_=0;_<T.length;_++)E.push(T[_])}x(y,!0),x(E,!1)}return g.quaternion.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)),g}})},function(e,t){THREE.DRACOLoader=function(e){THREE.Loader.call(this,e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}},THREE.DRACOLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.DRACOLoader,setDecoderPath:function(e){return this.decoderPath=e,this},setDecoderConfig:function(e){return this.decoderConfig=e,this},setWorkerLimit:function(e){return this.workerLimit=e,this},setVerbosity:function(){console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.")},setDrawMode:function(){console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.")},setSkipDequantization:function(){console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.")},load:function(e,t,r,n){var a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),"use-credentials"===this.crossOrigin&&a.setWithCredentials(!0),a.load(e,e=>{var r={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(e,r).then(t).catch(n)},r,n)},decodeDracoFile:function(e,t,r,n){var a={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:n||this.defaultAttributeTypes,useUniqueIDs:!!r};this.decodeGeometry(e,a).then(t)},decodeGeometry:function(e,t){for(var r in t.attributeTypes){var n=t.attributeTypes[r];void 0!==n.BYTES_PER_ELEMENT&&(t.attributeTypes[r]=n.name)}var a,o=JSON.stringify(t);if(THREE.DRACOLoader.taskCache.has(e)){var i=THREE.DRACOLoader.taskCache.get(e);if(i.key===o)return i.promise;if(0===e.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}var s=this.workerNextTaskID++,l=e.byteLength,c=this._getWorker(s,l).then(r=>(a=r,new Promise((r,n)=>{a._callbacks[s]={resolve:r,reject:n},a.postMessage({type:"decode",id:s,taskConfig:t,buffer:e},[e])}))).then(e=>this._createGeometry(e.geometry));return c.catch(()=>!0).then(()=>{a&&s&&this._releaseTask(a,s)}),THREE.DRACOLoader.taskCache.set(e,{key:o,promise:c}),c},_createGeometry:function(e){var t=new THREE.BufferGeometry;e.index&&t.setIndex(new THREE.BufferAttribute(e.index.array,1));for(var r=0;r<e.attributes.length;r++){var n=e.attributes[r],a=n.name,o=n.array,i=n.itemSize;t.setAttribute(a,new THREE.BufferAttribute(o,i))}return t},_loadLibrary:function(e,t){var r=new THREE.FileLoader(this.manager);return r.setPath(this.decoderPath),r.setResponseType(t),new Promise((t,n)=>{r.load(e,t,void 0,n)})},preload:function(){return this._initDecoder(),this},_initDecoder:function(){if(this.decoderPending)return this.decoderPending;var e="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(t=>{var r=t[0];e||(this.decoderConfig.wasmBinary=t[1]);var n=THREE.DRACOLoader.DRACOWorker.toString(),a=["/* draco decoder */",r,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([a]))}),this.decoderPending},_getWorker:function(e,t){return this._initDecoder().then(()=>{var r;this.workerPool.length<this.workerLimit?((r=new Worker(this.workerSourceURL))._callbacks={},r._taskCosts={},r._taskLoad=0,r.postMessage({type:"init",decoderConfig:this.decoderConfig}),r.onmessage=function(e){var t=e.data;switch(t.type){case"decode":r._callbacks[t.id].resolve(t);break;case"error":r._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},this.workerPool.push(r)):this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));return(r=this.workerPool[this.workerPool.length-1])._taskCosts[e]=t,r._taskLoad+=t,r})},_releaseTask:function(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]},debug:function(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))},dispose:function(){for(var e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}),THREE.DRACOLoader.DRACOWorker=function(){var e,t;function r(e,t,r,n,a,o){var i,s,l=o.num_components(),c=r.num_points()*l;switch(a){case Float32Array:i=new e.DracoFloat32Array,t.GetAttributeFloatForAllPoints(r,o,i),s=new Float32Array(c);break;case Int8Array:i=new e.DracoInt8Array,t.GetAttributeInt8ForAllPoints(r,o,i),s=new Int8Array(c);break;case Int16Array:i=new e.DracoInt16Array,t.GetAttributeInt16ForAllPoints(r,o,i),s=new Int16Array(c);break;case Int32Array:i=new e.DracoInt32Array,t.GetAttributeInt32ForAllPoints(r,o,i),s=new Int32Array(c);break;case Uint8Array:i=new e.DracoUInt8Array,t.GetAttributeUInt8ForAllPoints(r,o,i),s=new Uint8Array(c);break;case Uint16Array:i=new e.DracoUInt16Array,t.GetAttributeUInt16ForAllPoints(r,o,i),s=new Uint16Array(c);break;case Uint32Array:i=new e.DracoUInt32Array,t.GetAttributeUInt32ForAllPoints(r,o,i),s=new Uint32Array(c);break;default:throw new Error("THREE.DRACOLoader: Unexpected attribute type.")}for(var f=0;f<c;f++)s[f]=i.GetValue(f);return e.destroy(i),{name:n,array:s,itemSize:l}}onmessage=function(n){var a=n.data;switch(a.type){case"init":e=a.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":var o=a.buffer,i=a.taskConfig;t.then(e=>{var t=e.draco,n=new t.Decoder,s=new t.DecoderBuffer;s.Init(new Int8Array(o),o.byteLength);try{var l=function(e,t,n,a){var o,i,s=a.attributeIDs,l=a.attributeTypes,c=t.GetEncodedGeometryType(n);if(c===e.TRIANGULAR_MESH)o=new e.Mesh,i=t.DecodeBufferToMesh(n,o);else{if(c!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");o=new e.PointCloud,i=t.DecodeBufferToPointCloud(n,o)}if(!i.ok()||0===o.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+i.error_msg());var f={index:null,attributes:[]};for(var d in s){var u,p,h=self[l[d]];if(a.useUniqueIDs)p=s[d],u=t.GetAttributeByUniqueId(o,p);else{if(-1===(p=t.GetAttributeId(o,e[s[d]])))continue;u=t.GetAttribute(o,p)}f.attributes.push(r(e,t,o,d,h,u))}if(c===e.TRIANGULAR_MESH){for(var v=o.num_faces(),m=new Uint32Array(3*v),x=new e.DracoInt32Array,g=0;g<v;++g){t.GetFaceFromMesh(o,g,x);for(var y=0;y<3;++y)m[3*g+y]=x.GetValue(y)}f.index={array:m,itemSize:1},e.destroy(x)}return e.destroy(o),f}(t,n,s,i),c=l.attributes.map(e=>e.array.buffer);l.index&&c.push(l.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:l},c)}catch(e){console.error(e),self.postMessage({type:"error",id:a.id,error:e.message})}finally{t.destroy(s),t.destroy(n)}})}}},THREE.DRACOLoader.taskCache=new WeakMap,THREE.DRACOLoader.setDecoderPath=function(){console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.")},THREE.DRACOLoader.setDecoderConfig=function(){console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.")},THREE.DRACOLoader.releaseDecoderModule=function(){console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.")},THREE.DRACOLoader.getDecoderModule=function(){console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.")}},function(e,t){THREE.DDSLoader=function(e){THREE.CompressedTextureLoader.call(this,e)},THREE.DDSLoader.prototype=Object.assign(Object.create(THREE.CompressedTextureLoader.prototype),{constructor:THREE.DDSLoader,parse:function(e,t){var r={mipmaps:[],width:0,height:0,format:null,mipmapCount:1};function n(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}function a(e,t,r,n){for(var a=r*n*4,o=new Uint8Array(e,t,a),i=new Uint8Array(a),s=0,l=0,c=0;c<n;c++)for(var f=0;f<r;f++){var d=o[l],u=o[++l],p=o[++l],h=o[++l];l++,i[s]=p,i[++s]=u,i[++s]=d,i[++s]=h,s++}return i}var o,i=n("DXT1"),s=n("DXT3"),l=n("DXT5"),c=n("ETC1"),f=new Int32Array(e,0,31);if(542327876!==f[0])return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."),r;if(4&!f[20])return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."),r;var d,u=f[21],p=!1;switch(u){case i:o=8,r.format=THREE.RGB_S3TC_DXT1_Format;break;case s:o=16,r.format=THREE.RGBA_S3TC_DXT3_Format;break;case l:o=16,r.format=THREE.RGBA_S3TC_DXT5_Format;break;case c:o=8,r.format=THREE.RGB_ETC1_Format;break;default:if(!(32===f[22]&&16711680&f[23]&&65280&f[24]&&255&f[25]&&4278190080&f[26]))return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ",(d=u,String.fromCharCode(255&d,d>>8&255,d>>16&255,d>>24&255))),r;p=!0,o=64,r.format=THREE.RGBAFormat}r.mipmapCount=1,131072&f[2]&&!1!==t&&(r.mipmapCount=Math.max(1,f[7]));var h=f[28];if(r.isCubemap=!!(512&h),r.isCubemap&&(!(1024&h)||!(2048&h)||!(4096&h)||!(8192&h)||!(16384&h)||!(32768&h)))return console.error("THREE.DDSLoader.parse: Incomplete cubemap faces"),r;r.width=f[4],r.height=f[3];for(var v=f[1]+4,m=r.isCubemap?6:1,x=0;x<m;x++)for(var g=r.width,y=r.height,E=0;E<r.mipmapCount;E++){if(p)var w=(b=a(e,v,g,y)).length;else{w=Math.max(4,g)/4*Math.max(4,y)/4*o;var b=new Uint8Array(e,v,w)}var T={data:b,width:g,height:y};r.mipmaps.push(T),v+=w,g=Math.max(g>>1,1),y=Math.max(y>>1,1)}return r}})},function(e,t){THREE.GLTFLoader=function(){function e(e){THREE.Loader.call(this,e),this.dracoLoader=null,this.ddsLoader=null,this.ktx2Loader=null,this.pluginCallbacks=[],this.register((function(e){return new i(e)})),this.register((function(e){return new l(e)})),this.register((function(e){return new s(e)}))}function t(){var e={};return{get:function(t){return e[t]},add:function(t,r){e[t]=r},remove:function(t){delete e[t]},removeAll:function(){e={}}}}e.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:e,load:function(e,t,r,n){var a,o=this;a=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:THREE.LoaderUtils.extractUrlBase(e),o.manager.itemStart(e);var i=function(t){n?n(t):console.error(t),o.manager.itemError(e),o.manager.itemEnd(e)},s=new THREE.FileLoader(o.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),"use-credentials"===o.crossOrigin&&s.setWithCredentials(!0),s.load(e,(function(r){try{o.parse(r,a,(function(r){t(r),o.manager.itemEnd(e)}),i)}catch(e){i(e)}}),r,i)},setDRACOLoader:function(e){return this.dracoLoader=e,this},setDDSLoader:function(e){return this.ddsLoader=e,this},setKTX2Loader:function(e){return this.ktx2Loader=e,this},register:function(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this},unregister:function(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this},parse:function(e,t,i,s){var l,f={},d={};if("string"==typeof e)l=e;else if(THREE.LoaderUtils.decodeText(new Uint8Array(e,0,4))===c){try{f[r.KHR_BINARY_GLTF]=new u(e)}catch(e){return void(s&&s(e))}l=f[r.KHR_BINARY_GLTF].content}else l=THREE.LoaderUtils.decodeText(new Uint8Array(e));var v=JSON.parse(l);if(void 0===v.asset||v.asset.version[0]<2)s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));else{var g=new B(v,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,manager:this.manager,ktx2Loader:this.ktx2Loader});g.fileLoader.setRequestHeader(this.requestHeader);for(var y=0;y<this.pluginCallbacks.length;y++){var E=this.pluginCallbacks[y](g);d[E.name]=E,f[E.name]=!0}if(v.extensionsUsed)for(y=0;y<v.extensionsUsed.length;++y){var w=v.extensionsUsed[y],b=v.extensionsRequired||[];switch(w){case r.KHR_LIGHTS_PUNCTUAL:f[w]=new a(v);break;case r.KHR_MATERIALS_UNLIT:f[w]=new o;break;case r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:f[w]=new m;break;case r.KHR_DRACO_MESH_COMPRESSION:f[w]=new p(v,this.dracoLoader);break;case r.MSFT_TEXTURE_DDS:f[w]=new n(this.ddsLoader);break;case r.KHR_TEXTURE_TRANSFORM:f[w]=new h;break;case r.KHR_MESH_QUANTIZATION:f[w]=new x;break;default:b.indexOf(w)>=0&&void 0===d[w]&&console.warn('THREE.GLTFLoader: Unknown extension "'+w+'".')}}g.setExtensions(f),g.setPlugins(d),g.parse(i,s)}}});var r={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",MSFT_TEXTURE_DDS:"MSFT_texture_dds"};function n(e){if(!e)throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader");this.name=r.MSFT_TEXTURE_DDS,this.ddsLoader=e}function a(e){this.name=r.KHR_LIGHTS_PUNCTUAL;var t=e.extensions&&e.extensions[r.KHR_LIGHTS_PUNCTUAL]||{};this.lightDefs=t.lights||[]}function o(){this.name=r.KHR_MATERIALS_UNLIT}function i(e){this.parser=e,this.name=r.KHR_MATERIALS_CLEARCOAT}function s(e){this.parser=e,this.name=r.KHR_MATERIALS_TRANSMISSION}function l(e){this.parser=e,this.name=r.KHR_TEXTURE_BASISU}a.prototype.loadLight=function(e){var t,r=this.lightDefs[e],n=new THREE.Color(16777215);void 0!==r.color&&n.fromArray(r.color);var a=void 0!==r.range?r.range:0;switch(r.type){case"directional":(t=new THREE.DirectionalLight(n)).target.position.set(0,0,-1),t.add(t.target);break;case"point":(t=new THREE.PointLight(n)).distance=a;break;case"spot":(t=new THREE.SpotLight(n)).distance=a,r.spot=r.spot||{},r.spot.innerConeAngle=void 0!==r.spot.innerConeAngle?r.spot.innerConeAngle:0,r.spot.outerConeAngle=void 0!==r.spot.outerConeAngle?r.spot.outerConeAngle:Math.PI/4,t.angle=r.spot.outerConeAngle,t.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,t.target.position.set(0,0,-1),t.add(t.target);break;default:throw new Error('THREE.GLTFLoader: Unexpected light type, "'+r.type+'".')}return t.position.set(0,0,0),t.decay=2,void 0!==r.intensity&&(t.intensity=r.intensity),t.name=r.name||"light_"+e,Promise.resolve(t)},o.prototype.getMaterialType=function(){return THREE.MeshBasicMaterial},o.prototype.extendParams=function(e,t,r){var n=[];e.color=new THREE.Color(1,1,1),e.opacity=1;var a=t.pbrMetallicRoughness;if(a){if(Array.isArray(a.baseColorFactor)){var o=a.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}void 0!==a.baseColorTexture&&n.push(r.assignTexture(e,"map",a.baseColorTexture))}return Promise.all(n)},i.prototype.getMaterialType=function(){return THREE.MeshPhysicalMaterial},i.prototype.extendMaterialParams=function(e,t){var r=this.parser,n=r.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();var a=[],o=n.extensions[this.name];if(void 0!==o.clearcoatFactor&&(t.clearcoat=o.clearcoatFactor),void 0!==o.clearcoatTexture&&a.push(r.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),void 0!==o.clearcoatRoughnessFactor&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),void 0!==o.clearcoatRoughnessTexture&&a.push(r.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),void 0!==o.clearcoatNormalTexture&&(a.push(r.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),void 0!==o.clearcoatNormalTexture.scale)){var i=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new THREE.Vector2(i,i)}return Promise.all(a)},s.prototype.getMaterialType=function(){return THREE.MeshPhysicalMaterial},s.prototype.extendMaterialParams=function(e,t){var r=this.parser,n=r.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();var a=[],o=n.extensions[this.name];return void 0!==o.transmissionFactor&&(t.transmission=o.transmissionFactor),void 0!==o.transmissionTexture&&a.push(r.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(a)},l.prototype.loadTexture=function(e){var t=this.parser,r=t.json,n=r.textures[e];if(!n.extensions||!n.extensions[this.name])return null;var a=n.extensions[this.name],o=r.images[a.source],i=t.options.ktx2Loader;if(!i)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return t.loadTextureImage(e,o,i)};var c="glTF",f=1313821514,d=5130562;function u(e){this.name=r.KHR_BINARY_GLTF,this.content=null,this.body=null;var t=new DataView(e,0,12);if(this.header={magic:THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==c)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");for(var n=new DataView(e,12),a=0;a<n.byteLength;){var o=n.getUint32(a,!0);a+=4;var i=n.getUint32(a,!0);if(a+=4,i===f){var s=new Uint8Array(e,12+a,o);this.content=THREE.LoaderUtils.decodeText(s)}else if(i===d){var l=12+a;this.body=e.slice(l,l+o)}a+=o}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}function p(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=r.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}function h(){this.name=r.KHR_TEXTURE_TRANSFORM}function v(e){THREE.MeshStandardMaterial.call(this),this.isGLTFSpecularGlossinessMaterial=!0;var t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),r=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),n=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),a=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb;","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor.rgb;"].join("\n"),i={specular:{value:(new THREE.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=i,this.onBeforeCompile=function(e){for(var s in i)e.uniforms[s]=i[s];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;"),e.fragmentShader=e.fragmentShader.replace("uniform float metalness;","uniform float glossiness;"),e.fragmentShader=e.fragmentShader.replace("#include <roughnessmap_pars_fragment>",t),e.fragmentShader=e.fragmentShader.replace("#include <metalnessmap_pars_fragment>",r),e.fragmentShader=e.fragmentShader.replace("#include <roughnessmap_fragment>",n),e.fragmentShader=e.fragmentShader.replace("#include <metalnessmap_fragment>",a),e.fragmentShader=e.fragmentShader.replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return i.specular.value},set:function(e){i.specular.value=e}},specularMap:{get:function(){return i.specularMap.value},set:function(e){i.specularMap.value=e}},glossiness:{get:function(){return i.glossiness.value},set:function(e){i.glossiness.value=e}},glossinessMap:{get:function(){return i.glossinessMap.value},set:function(e){i.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_ROUGHNESSMAP=""):(delete this.defines.USE_ROUGHNESSMAP,delete this.defines.USE_GLOSSINESSMAP)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}function m(){return{name:r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,specularGlossinessParams:["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"],getMaterialType:function(){return v},extendParams:function(e,t,r){var n=t.extensions[this.name];e.color=new THREE.Color(1,1,1),e.opacity=1;var a=[];if(Array.isArray(n.diffuseFactor)){var o=n.diffuseFactor;e.color.fromArray(o),e.opacity=o[3]}if(void 0!==n.diffuseTexture&&a.push(r.assignTexture(e,"map",n.diffuseTexture)),e.emissive=new THREE.Color(0,0,0),e.glossiness=void 0!==n.glossinessFactor?n.glossinessFactor:1,e.specular=new THREE.Color(1,1,1),Array.isArray(n.specularFactor)&&e.specular.fromArray(n.specularFactor),void 0!==n.specularGlossinessTexture){var i=n.specularGlossinessTexture;a.push(r.assignTexture(e,"glossinessMap",i)),a.push(r.assignTexture(e,"specularMap",i))}return Promise.all(a)},createMaterial:function(e){var t=new v(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=THREE.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}}function x(){this.name=r.KHR_MESH_QUANTIZATION}function g(e,t,r,n){THREE.Interpolant.call(this,e,t,r,n)}p.prototype.decodePrimitive=function(e,t){var r=this.json,n=this.dracoLoader,a=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,i={},s={},l={};for(var c in o){var f=L[c]||c.toLowerCase();i[f]=o[c]}for(c in e.attributes){f=L[c]||c.toLowerCase();if(void 0!==o[c]){var d=r.accessors[e.attributes[c]],u=R[d.componentType];l[f]=u,s[f]=!0===d.normalized}}return t.getDependency("bufferView",a).then((function(e){return new Promise((function(t){n.decodeDracoFile(e,(function(e){for(var r in e.attributes){var n=e.attributes[r],a=s[r];void 0!==a&&(n.normalized=a)}t(e)}),i,l)}))}))},h.prototype.extendTexture=function(e,t){return e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.needsUpdate=!0,e},v.prototype=Object.create(THREE.MeshStandardMaterial.prototype),v.prototype.constructor=v,v.prototype.copy=function(e){return THREE.MeshStandardMaterial.prototype.copy.call(this,e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this},g.prototype=Object.create(THREE.Interpolant.prototype),g.prototype.constructor=g,g.prototype.copySampleValue_=function(e){for(var t=this.resultBuffer,r=this.sampleValues,n=this.valueSize,a=e*n*3+n,o=0;o!==n;o++)t[o]=r[a+o];return t},g.prototype.beforeStart_=g.prototype.copySampleValue_,g.prototype.afterEnd_=g.prototype.copySampleValue_,g.prototype.interpolate_=function(e,t,r,n){for(var a=this.resultBuffer,o=this.sampleValues,i=this.valueSize,s=2*i,l=3*i,c=n-t,f=(r-t)/c,d=f*f,u=d*f,p=e*l,h=p-l,v=-2*u+3*d,m=u-d,x=1-v,g=m-d+f,y=0;y!==i;y++){var E=o[h+y+i],w=o[h+y+s]*c,b=o[p+y+i],T=o[p+y]*c;a[y]=x*E+g*w+v*b+m*T}return a};var y=0,E=1,w=2,b=3,T=4,_=5,S=6,R={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},A={9728:THREE.NearestFilter,9729:THREE.LinearFilter,9984:THREE.NearestMipmapNearestFilter,9985:THREE.LinearMipmapNearestFilter,9986:THREE.NearestMipmapLinearFilter,9987:THREE.LinearMipmapLinearFilter},M={33071:THREE.ClampToEdgeWrapping,33648:THREE.MirroredRepeatWrapping,10497:THREE.RepeatWrapping},C={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},L={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},H={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},P={CUBICSPLINE:void 0,LINEAR:THREE.InterpolateLinear,STEP:THREE.InterpolateDiscrete},z="OPAQUE",k="MASK",N="BLEND",D={"image/png":THREE.RGBAFormat,"image/jpeg":THREE.RGBFormat};function F(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}function I(e,t,r){for(var n in r.extensions)void 0===e[n]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[n]=r.extensions[n])}function O(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function U(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(var r=0,n=t.weights.length;r<n;r++)e.morphTargetInfluences[r]=t.weights[r];if(t.extras&&Array.isArray(t.extras.targetNames)){var a=t.extras.targetNames;if(e.morphTargetInfluences.length===a.length){e.morphTargetDictionary={};for(r=0,n=a.length;r<n;r++)e.morphTargetDictionary[a[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function G(e){for(var t="",r=Object.keys(e).sort(),n=0,a=r.length;n<a;n++)t+=r[n]+":"+e[r[n]]+";";return t}function B(e,r){this.json=e||{},this.extensions={},this.plugins={},this.options=r||{},this.cache=new t,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},"undefined"!=typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?this.textureLoader=new THREE.ImageBitmapLoader(this.options.manager):this.textureLoader=new THREE.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.fileLoader=new THREE.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}function V(e,t,r){var n=t.attributes,a=[];function o(t,n){return r.getDependency("accessor",t).then((function(t){e.setAttribute(n,t)}))}for(var i in n){var s=L[i]||i.toLowerCase();s in e.attributes||a.push(o(n[i],s))}if(void 0!==t.indices&&!e.index){var l=r.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));a.push(l)}return O(e,t),function(e,t,r){var n=t.attributes,a=new THREE.Box3;if(void 0!==n.POSITION){var o=(p=r.json.accessors[n.POSITION]).min,i=p.max;if(void 0!==o&&void 0!==i){a.set(new THREE.Vector3(o[0],o[1],o[2]),new THREE.Vector3(i[0],i[1],i[2]));var s=t.targets;if(void 0!==s){for(var l=new THREE.Vector3,c=new THREE.Vector3,f=0,d=s.length;f<d;f++){var u=s[f];if(void 0!==u.POSITION){var p;o=(p=r.json.accessors[u.POSITION]).min,i=p.max;void 0!==o&&void 0!==i?(c.setX(Math.max(Math.abs(o[0]),Math.abs(i[0]))),c.setY(Math.max(Math.abs(o[1]),Math.abs(i[1]))),c.setZ(Math.max(Math.abs(o[2]),Math.abs(i[2]))),l.max(c)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}a.expandByVector(l)}e.boundingBox=a;var h=new THREE.Sphere;a.getCenter(h.center),h.radius=a.min.distanceTo(a.max)/2,e.boundingSphere=h}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}(e,t,r),Promise.all(a).then((function(){return void 0!==t.targets?function(e,t,r){for(var n=!1,a=!1,o=0,i=t.length;o<i;o++){if(void 0!==(c=t[o]).POSITION&&(n=!0),void 0!==c.NORMAL&&(a=!0),n&&a)break}if(!n&&!a)return Promise.resolve(e);var s=[],l=[];for(o=0,i=t.length;o<i;o++){var c=t[o];if(n){var f=void 0!==c.POSITION?r.getDependency("accessor",c.POSITION):e.attributes.position;s.push(f)}if(a){f=void 0!==c.NORMAL?r.getDependency("accessor",c.NORMAL):e.attributes.normal;l.push(f)}}return Promise.all([Promise.all(s),Promise.all(l)]).then((function(t){var r=t[0],o=t[1];return n&&(e.morphAttributes.position=r),a&&(e.morphAttributes.normal=o),e.morphTargetsRelative=!0,e}))}(e,t.targets,r):e}))}function j(e,t){var r=e.getIndex();if(null===r){var n=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var o=0;o<a.count;o++)n.push(o);e.setIndex(n),r=e.getIndex()}var i=r.count-2,s=[];if(t===THREE.TriangleFanDrawMode)for(o=1;o<=i;o++)s.push(r.getX(0)),s.push(r.getX(o)),s.push(r.getX(o+1));else for(o=0;o<i;o++)o%2==0?(s.push(r.getX(o)),s.push(r.getX(o+1)),s.push(r.getX(o+2))):(s.push(r.getX(o+2)),s.push(r.getX(o+1)),s.push(r.getX(o)));s.length/3!==i&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=e.clone();return l.setIndex(s),l}return B.prototype.setExtensions=function(e){this.extensions=e},B.prototype.setPlugins=function(e){this.plugins=e},B.prototype.parse=function(e,t){var r=this,n=this.json,a=this.extensions;this.cache.removeAll(),this._markDefs(),Promise.all([this.getDependencies("scene"),this.getDependencies("animation"),this.getDependencies("camera")]).then((function(t){var o={scene:t[0][n.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:n.asset,parser:r,userData:{}};I(a,o,n),O(o,n),e(o)})).catch(t)},B.prototype._markDefs=function(){for(var e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[],a=0,o=t.length;a<o;a++)for(var i=t[a].joints,s=0,l=i.length;s<l;s++)e[i[s]].isBone=!0;for(var c=0,f=e.length;c<f;c++){var d=e[c];void 0!==d.mesh&&(this._addNodeRef(this.meshCache,d.mesh),void 0!==d.skin&&(n[d.mesh].isSkinnedMesh=!0)),void 0!==d.camera&&this._addNodeRef(this.cameraCache,d.camera),d.extensions&&d.extensions[r.KHR_LIGHTS_PUNCTUAL]&&void 0!==d.extensions[r.KHR_LIGHTS_PUNCTUAL].light&&this._addNodeRef(this.lightCache,d.extensions[r.KHR_LIGHTS_PUNCTUAL].light)}},B.prototype._addNodeRef=function(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)},B.prototype._getNodeRef=function(e,t,r){if(e.refs[t]<=1)return r;var n=r.clone();return n.name+="_instance_"+e.uses[t]++,n},B.prototype._invokeOne=function(e){var t=Object.values(this.plugins);t.push(this);for(var r=0;r<t.length;r++){var n=e(t[r]);if(n)return n}},B.prototype._invokeAll=function(e){var t=Object.values(this.plugins);t.unshift(this);for(var r=[],n=0;n<t.length;n++)r.push(e(t[n]));return Promise.all(r)},B.prototype.getDependency=function(e,t){var n=e+":"+t,a=this.cache.get(n);if(!a){switch(e){case"scene":a=this.loadScene(t);break;case"node":a=this.loadNode(t);break;case"mesh":a=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":a=this.loadAccessor(t);break;case"bufferView":a=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":a=this.loadBuffer(t);break;case"material":a=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":a=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":a=this.loadSkin(t);break;case"animation":a=this.loadAnimation(t);break;case"camera":a=this.loadCamera(t);break;case"light":a=this.extensions[r.KHR_LIGHTS_PUNCTUAL].loadLight(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,a)}return a},B.prototype.getDependencies=function(e){var t=this.cache.get(e);if(!t){var r=this,n=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(n.map((function(t,n){return r.getDependency(e,n)}))),this.cache.add(e,t)}return t},B.prototype.loadBuffer=function(e){var t=this.json.buffers[e],n=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[r.KHR_BINARY_GLTF].body);var a=this.options;return new Promise((function(e,r){n.load(F(t.uri,a.path),e,void 0,(function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))},B.prototype.loadBufferView=function(e){var t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){var r=t.byteLength||0,n=t.byteOffset||0;return e.slice(n,n+r)}))},B.prototype.loadAccessor=function(e){var t=this,r=this.json,n=this.json.accessors[e];if(void 0===n.bufferView&&void 0===n.sparse)return Promise.resolve(null);var a=[];return void 0!==n.bufferView?a.push(this.getDependency("bufferView",n.bufferView)):a.push(null),void 0!==n.sparse&&(a.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),a.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(a).then((function(e){var a,o,i=e[0],s=C[n.type],l=R[n.componentType],c=l.BYTES_PER_ELEMENT,f=c*s,d=n.byteOffset||0,u=void 0!==n.bufferView?r.bufferViews[n.bufferView].byteStride:void 0,p=!0===n.normalized;if(u&&u!==f){var h=Math.floor(d/u),v="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+h+":"+n.count,m=t.cache.get(v);m||(a=new l(i,h*u,n.count*u/c),m=new THREE.InterleavedBuffer(a,u/c),t.cache.add(v,m)),o=new THREE.InterleavedBufferAttribute(m,s,d%u/c,p)}else a=null===i?new l(n.count*s):new l(i,d,n.count*s),o=new THREE.BufferAttribute(a,s,p);if(void 0!==n.sparse){var x=C.SCALAR,g=R[n.sparse.indices.componentType],y=n.sparse.indices.byteOffset||0,E=n.sparse.values.byteOffset||0,w=new g(e[1],y,n.sparse.count*x),b=new l(e[2],E,n.sparse.count*s);null!==i&&(o=new THREE.BufferAttribute(o.array.slice(),o.itemSize,o.normalized));for(var T=0,_=w.length;T<_;T++){var S=w[T];if(o.setX(S,b[T*s]),s>=2&&o.setY(S,b[T*s+1]),s>=3&&o.setZ(S,b[T*s+2]),s>=4&&o.setW(S,b[T*s+3]),s>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return o}))},B.prototype.loadTexture=function(e){var t,n,a=this.json,o=this.options,i=a.textures[e],s=i.extensions||{};return(t=s[r.MSFT_TEXTURE_DDS]?a.images[s[r.MSFT_TEXTURE_DDS].source]:a.images[i.source]).uri&&(n=o.manager.getHandler(t.uri)),n||(n=s[r.MSFT_TEXTURE_DDS]?this.extensions[r.MSFT_TEXTURE_DDS].ddsLoader:this.textureLoader),this.loadTextureImage(e,t,n)},B.prototype.loadTextureImage=function(e,t,r){var n=this,a=this.json,o=this.options,i=a.textures[e],s=self.URL||self.webkitURL,l=t.uri,c=!1;return void 0!==t.bufferView&&(l=n.getDependency("bufferView",t.bufferView).then((function(e){c=!0;var r=new Blob([e],{type:t.mimeType});return l=s.createObjectURL(r)}))),Promise.resolve(l).then((function(e){return new Promise((function(t,n){var a=t;!0===r.isImageBitmapLoader&&(a=function(e){t(new THREE.CanvasTexture(e))}),r.load(F(e,o.path),a,void 0,n)}))})).then((function(r){!0===c&&s.revokeObjectURL(l),r.flipY=!1,i.name&&(r.name=i.name),t.mimeType in D&&(r.format=D[t.mimeType]);var o=(a.samplers||{})[i.sampler]||{};return r.magFilter=A[o.magFilter]||THREE.LinearFilter,r.minFilter=A[o.minFilter]||THREE.LinearMipmapLinearFilter,r.wrapS=M[o.wrapS]||THREE.RepeatWrapping,r.wrapT=M[o.wrapT]||THREE.RepeatWrapping,n.associations.set(r,{type:"textures",index:e}),r}))},B.prototype.assignTexture=function(e,t,n){var a=this;return this.getDependency("texture",n.index).then((function(o){if(!o.isCompressedTexture)switch(t){case"aoMap":case"emissiveMap":case"metalnessMap":case"normalMap":case"roughnessMap":o.format=THREE.RGBFormat}if(void 0===n.texCoord||0==n.texCoord||"aoMap"===t&&1==n.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),a.extensions[r.KHR_TEXTURE_TRANSFORM]){var i=void 0!==n.extensions?n.extensions[r.KHR_TEXTURE_TRANSFORM]:void 0;if(i){var s=a.associations.get(o);o=a.extensions[r.KHR_TEXTURE_TRANSFORM].extendTexture(o,i),a.associations.set(o,s)}}e[t]=o}))},B.prototype.assignFinalMaterial=function(e){var t=e.geometry,r=e.material,n=void 0!==t.attributes.color,a=void 0===t.attributes.normal,o=!0===e.isSkinnedMesh,i=Object.keys(t.morphAttributes).length>0,s=i&&void 0!==t.morphAttributes.normal;if(e.isPoints){var l="PointsMaterial:"+r.uuid,c=this.cache.get(l);c||(c=new THREE.PointsMaterial,THREE.Material.prototype.copy.call(c,r),c.color.copy(r.color),c.map=r.map,c.sizeAttenuation=!1,this.cache.add(l,c)),r=c}else if(e.isLine){l="LineBasicMaterial:"+r.uuid;var f=this.cache.get(l);f||(f=new THREE.LineBasicMaterial,THREE.Material.prototype.copy.call(f,r),f.color.copy(r.color),this.cache.add(l,f)),r=f}if(n||a||o||i){l="ClonedMaterial:"+r.uuid+":";r.isGLTFSpecularGlossinessMaterial&&(l+="specular-glossiness:"),o&&(l+="skinning:"),n&&(l+="vertex-colors:"),a&&(l+="flat-shading:"),i&&(l+="morph-targets:"),s&&(l+="morph-normals:");var d=this.cache.get(l);d||(d=r.clone(),o&&(d.skinning=!0),n&&(d.vertexColors=!0),a&&(d.flatShading=!0),i&&(d.morphTargets=!0),s&&(d.morphNormals=!0),this.cache.add(l,d),this.associations.set(d,this.associations.get(r))),r=d}r.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),r.normalScale&&(r.normalScale.y=-r.normalScale.y),r.clearcoatNormalScale&&(r.clearcoatNormalScale.y=-r.clearcoatNormalScale.y),e.material=r},B.prototype.getMaterialType=function(){return THREE.MeshStandardMaterial},B.prototype.loadMaterial=function(e){var t,n=this,a=this.json,o=this.extensions,i=a.materials[e],s={},l=i.extensions||{},c=[];if(l[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){var f=o[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];t=f.getMaterialType(),c.push(f.extendParams(s,i,n))}else if(l[r.KHR_MATERIALS_UNLIT]){var d=o[r.KHR_MATERIALS_UNLIT];t=d.getMaterialType(),c.push(d.extendParams(s,i,n))}else{var u=i.pbrMetallicRoughness||{};if(s.color=new THREE.Color(1,1,1),s.opacity=1,Array.isArray(u.baseColorFactor)){var p=u.baseColorFactor;s.color.fromArray(p),s.opacity=p[3]}void 0!==u.baseColorTexture&&c.push(n.assignTexture(s,"map",u.baseColorTexture)),s.metalness=void 0!==u.metallicFactor?u.metallicFactor:1,s.roughness=void 0!==u.roughnessFactor?u.roughnessFactor:1,void 0!==u.metallicRoughnessTexture&&(c.push(n.assignTexture(s,"metalnessMap",u.metallicRoughnessTexture)),c.push(n.assignTexture(s,"roughnessMap",u.metallicRoughnessTexture))),t=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),c.push(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,s)})))}!0===i.doubleSided&&(s.side=THREE.DoubleSide);var h=i.alphaMode||z;return h===N?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,h===k&&(s.alphaTest=void 0!==i.alphaCutoff?i.alphaCutoff:.5)),void 0!==i.normalTexture&&t!==THREE.MeshBasicMaterial&&(c.push(n.assignTexture(s,"normalMap",i.normalTexture)),s.normalScale=new THREE.Vector2(1,1),void 0!==i.normalTexture.scale&&s.normalScale.set(i.normalTexture.scale,i.normalTexture.scale)),void 0!==i.occlusionTexture&&t!==THREE.MeshBasicMaterial&&(c.push(n.assignTexture(s,"aoMap",i.occlusionTexture)),void 0!==i.occlusionTexture.strength&&(s.aoMapIntensity=i.occlusionTexture.strength)),void 0!==i.emissiveFactor&&t!==THREE.MeshBasicMaterial&&(s.emissive=(new THREE.Color).fromArray(i.emissiveFactor)),void 0!==i.emissiveTexture&&t!==THREE.MeshBasicMaterial&&c.push(n.assignTexture(s,"emissiveMap",i.emissiveTexture)),Promise.all(c).then((function(){var a;return a=t===v?o[r.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s):new t(s),i.name&&(a.name=i.name),a.map&&(a.map.encoding=THREE.sRGBEncoding),a.emissiveMap&&(a.emissiveMap.encoding=THREE.sRGBEncoding),O(a,i),n.associations.set(a,{type:"materials",index:e}),i.extensions&&I(o,a,i),a}))},B.prototype.loadGeometries=function(e){var t=this,n=this.extensions,a=this.primitiveCache;function o(e){return n[r.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(r){return V(r,e,t)}))}for(var i,s,l=[],c=0,f=e.length;c<f;c++){var d,u=e[c],p=(s=void 0,(s=(i=u).extensions&&i.extensions[r.KHR_DRACO_MESH_COMPRESSION])?"draco:"+s.bufferView+":"+s.indices+":"+G(s.attributes):i.indices+":"+G(i.attributes)+":"+i.mode),h=a[p];if(h)l.push(h.promise);else d=u.extensions&&u.extensions[r.KHR_DRACO_MESH_COMPRESSION]?o(u):V(new THREE.BufferGeometry,u,t),a[p]={primitive:u,promise:d},l.push(d)}return Promise.all(l)},B.prototype.loadMesh=function(e){for(var t,r=this,n=this.json.meshes[e],a=n.primitives,o=[],i=0,s=a.length;i<s;i++){var l=void 0===a[i].material?(void 0===(t=this.cache).DefaultMaterial&&(t.DefaultMaterial=new THREE.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:THREE.FrontSide})),t.DefaultMaterial):this.getDependency("material",a[i].material);o.push(l)}return o.push(r.loadGeometries(a)),Promise.all(o).then((function(t){for(var o=t.slice(0,t.length-1),i=t[t.length-1],s=[],l=0,c=i.length;l<c;l++){var f,d=i[l],u=a[l],p=o[l];if(u.mode===T||u.mode===_||u.mode===S||void 0===u.mode)!0!==(f=!0===n.isSkinnedMesh?new THREE.SkinnedMesh(d,p):new THREE.Mesh(d,p)).isSkinnedMesh||f.geometry.attributes.skinWeight.normalized||f.normalizeSkinWeights(),u.mode===_?f.geometry=j(f.geometry,THREE.TriangleStripDrawMode):u.mode===S&&(f.geometry=j(f.geometry,THREE.TriangleFanDrawMode));else if(u.mode===E)f=new THREE.LineSegments(d,p);else if(u.mode===b)f=new THREE.Line(d,p);else if(u.mode===w)f=new THREE.LineLoop(d,p);else{if(u.mode!==y)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+u.mode);f=new THREE.Points(d,p)}Object.keys(f.geometry.morphAttributes).length>0&&U(f,n),f.name=n.name||"mesh_"+e,i.length>1&&(f.name+="_"+l),O(f,n),r.assignFinalMaterial(f),s.push(f)}if(1===s.length)return s[0];var h=new THREE.Group;for(l=0,c=s.length;l<c;l++)h.add(s[l]);return h}))},B.prototype.loadCamera=function(e){var t,r=this.json.cameras[e],n=r[r.type];if(n)return"perspective"===r.type?t=new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):"orthographic"===r.type&&(t=new THREE.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),r.name&&(t.name=r.name),O(t,r),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")},B.prototype.loadSkin=function(e){var t=this.json.skins[e],r={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(r):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return r.inverseBindMatrices=e,r}))},B.prototype.loadAnimation=function(e){for(var t=this.json.animations[e],r=[],n=[],a=[],o=[],i=[],s=0,l=t.channels.length;s<l;s++){var c=t.channels[s],f=t.samplers[c.sampler],d=c.target,u=void 0!==d.node?d.node:d.id,p=void 0!==t.parameters?t.parameters[f.input]:f.input,h=void 0!==t.parameters?t.parameters[f.output]:f.output;r.push(this.getDependency("node",u)),n.push(this.getDependency("accessor",p)),a.push(this.getDependency("accessor",h)),o.push(f),i.push(d)}return Promise.all([Promise.all(r),Promise.all(n),Promise.all(a),Promise.all(o),Promise.all(i)]).then((function(r){for(var n=r[0],a=r[1],o=r[2],i=r[3],s=r[4],l=[],c=0,f=n.length;c<f;c++){var d=n[c],u=a[c],p=o[c],h=i[c],v=s[c];if(void 0!==d){var m;switch(d.updateMatrix(),d.matrixAutoUpdate=!0,H[v.path]){case H.weights:m=THREE.NumberKeyframeTrack;break;case H.rotation:m=THREE.QuaternionKeyframeTrack;break;case H.position:case H.scale:default:m=THREE.VectorKeyframeTrack}var x=d.name?d.name:d.uuid,y=void 0!==h.interpolation?P[h.interpolation]:THREE.InterpolateLinear,E=[];H[v.path]===H.weights?d.traverse((function(e){!0===e.isMesh&&e.morphTargetInfluences&&E.push(e.name?e.name:e.uuid)})):E.push(x);var w=p.array;if(p.normalized){var b;if(w.constructor===Int8Array)b=1/127;else if(w.constructor===Uint8Array)b=1/255;else if(w.constructor==Int16Array)b=1/32767;else{if(w.constructor!==Uint16Array)throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");b=1/65535}for(var T=new Float32Array(w.length),_=0,S=w.length;_<S;_++)T[_]=w[_]*b;w=T}for(_=0,S=E.length;_<S;_++){var R=new m(E[_]+"."+H[v.path],u.array,w,y);"CUBICSPLINE"===h.interpolation&&(R.createInterpolant=function(e){return new g(this.times,this.values,this.getValueSize()/3,e)},R.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(R)}}}var A=t.name?t.name:"animation_"+e;return new THREE.AnimationClip(A,void 0,l)}))},B.prototype.loadNode=function(e){var t=this.json,n=this.extensions,a=this,o=t.nodes[e];return function(){var e=[];if(void 0!==o.mesh&&e.push(a.getDependency("mesh",o.mesh).then((function(e){var t=a._getNodeRef(a.meshCache,o.mesh,e);return void 0!==o.weights&&t.traverse((function(e){if(e.isMesh)for(var t=0,r=o.weights.length;t<r;t++)e.morphTargetInfluences[t]=o.weights[t]})),t}))),void 0!==o.camera&&e.push(a.getDependency("camera",o.camera).then((function(e){return a._getNodeRef(a.cameraCache,o.camera,e)}))),o.extensions&&o.extensions[r.KHR_LIGHTS_PUNCTUAL]&&void 0!==o.extensions[r.KHR_LIGHTS_PUNCTUAL].light){var t=o.extensions[r.KHR_LIGHTS_PUNCTUAL].light;e.push(a.getDependency("light",t).then((function(e){return a._getNodeRef(a.lightCache,t,e)})))}return Promise.all(e)}().then((function(t){var r;if((r=!0===o.isBone?new THREE.Bone:t.length>1?new THREE.Group:1===t.length?t[0]:new THREE.Object3D)!==t[0])for(var i=0,s=t.length;i<s;i++)r.add(t[i]);if(o.name&&(r.userData.name=o.name,r.name=THREE.PropertyBinding.sanitizeNodeName(o.name)),O(r,o),o.extensions&&I(n,r,o),void 0!==o.matrix){var l=new THREE.Matrix4;l.fromArray(o.matrix),r.applyMatrix4(l)}else void 0!==o.translation&&r.position.fromArray(o.translation),void 0!==o.rotation&&r.quaternion.fromArray(o.rotation),void 0!==o.scale&&r.scale.fromArray(o.scale);return a.associations.set(r,{type:"nodes",index:e}),r}))},B.prototype.loadScene=function(){function e(t,r,n,a){var o=n.nodes[t];return a.getDependency("node",t).then((function(e){return void 0===o.skin?e:a.getDependency("skin",o.skin).then((function(e){for(var r=[],n=0,o=(t=e).joints.length;n<o;n++)r.push(a.getDependency("node",t.joints[n]));return Promise.all(r)})).then((function(r){return e.traverse((function(e){if(e.isMesh){for(var n=[],a=[],o=0,i=r.length;o<i;o++){var s=r[o];if(s){n.push(s);var l=new THREE.Matrix4;void 0!==t.inverseBindMatrices&&l.fromArray(t.inverseBindMatrices.array,16*o),a.push(l)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[o])}e.bind(new THREE.Skeleton(n,a),e.matrixWorld)}})),e}));var t})).then((function(t){r.add(t);var i=[];if(o.children)for(var s=o.children,l=0,c=s.length;l<c;l++){var f=s[l];i.push(e(f,t,n,a))}return Promise.all(i)}))}return function(t){var r=this.json,n=this.extensions,a=this.json.scenes[t],o=new THREE.Group;a.name&&(o.name=a.name),O(o,a),a.extensions&&I(n,o,a);for(var i=a.nodes||[],s=[],l=0,c=i.length;l<c;l++)s.push(e(i[l],o,r,this));return Promise.all(s).then((function(){return o}))}}(),e}()},function(e,t){var r=0,n=1,a=2,o=3,i=4,s=5121,l=5123,c=5126,f=5125,d=34962,u=34963,p=9728,h=9729,v=9984,m=9985,x=9986,g=9987,y=33071,E=33648,w=10497,b={};b[THREE.NearestFilter]=p,b[THREE.NearestMipmapNearestFilter]=v,b[THREE.NearestMipmapLinearFilter]=x,b[THREE.LinearFilter]=h,b[THREE.LinearMipmapNearestFilter]=m,b[THREE.LinearMipmapLinearFilter]=g,b[THREE.ClampToEdgeWrapping]=y,b[THREE.RepeatWrapping]=w,b[THREE.MirroredRepeatWrapping]=E;var T={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};THREE.GLTFExporter=function(){},THREE.GLTFExporter.prototype={constructor:THREE.GLTFExporter,parse:function(e,t,p){var h={binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],forcePowerOfTwoTextures:!1,includeCustomExtensions:!1};(p=Object.assign({},h,p)).animations.length>0&&(p.trs=!0);var v,m={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},x=0,g=[],y=[],E=new Map,w=[],_={},S={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},R=new Map,A=0;function M(e){return R.has(e)||R.set(e,A++),R.get(e)}function C(e,t){return e.length===t.length&&e.every((function(e,r){return e===t[r]}))}function L(e){return 4*Math.ceil(e/4)}function H(e,t){t=t||0;var r=L(e.byteLength);if(r!==e.byteLength){var n=new Uint8Array(r);if(n.set(new Uint8Array(e)),0!==t)for(var a=e.byteLength;a<r;a++)n[a]=t;return n.buffer}return e}function P(e,t){if(0!==Object.keys(e.userData).length)try{var r=JSON.parse(JSON.stringify(e.userData));if(p.includeCustomExtensions&&r.gltfExtensions){for(var n in void 0===t.extensions&&(t.extensions={}),r.gltfExtensions)t.extensions[n]=r.gltfExtensions[n],_[n]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(t){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}function z(e,t){var r=!1,n={};0===t.offset.x&&0===t.offset.y||(n.offset=t.offset.toArray(),r=!0),0!==t.rotation&&(n.rotation=t.rotation,r=!0),1===t.repeat.x&&1===t.repeat.y||(n.scale=t.repeat.toArray(),r=!0),r&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=n,_.KHR_texture_transform=!0)}function k(e){return m.buffers||(m.buffers=[{byteLength:0}]),g.push(e),0}function N(e,t,r,n){var a;if(e.array.constructor===Float32Array)a=c;else if(e.array.constructor===Uint32Array)a=f;else if(e.array.constructor===Uint16Array)a=l;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");a=s}if(void 0===r&&(r=0),void 0===n&&(n=e.count),p.truncateDrawRange&&void 0!==t&&null===t.index){var o=r+n,i=t.drawRange.count===1/0?e.count:t.drawRange.start+t.drawRange.count;r=Math.max(r,t.drawRange.start),(n=Math.min(o,i)-r)<0&&(n=0)}if(0===n)return null;var h,v=function(e,t,r){for(var n={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)},a=t;a<t+r;a++)for(var o=0;o<e.itemSize;o++){var i=e.array[a*e.itemSize+o];n.min[o]=Math.min(n.min[o],i),n.max[o]=Math.max(n.max[o],i)}return n}(e,r,n);void 0!==t&&(h=e===t.index?u:d);var g=function(e,t,r,n,a){var o;m.bufferViews||(m.bufferViews=[]),o=t===s?1:t===l?2:4;for(var i=L(n*e.itemSize*o),u=new DataView(new ArrayBuffer(i)),p=0,h=r;h<r+n;h++)for(var v=0;v<e.itemSize;v++){var g;e.itemSize>4?g=e.array[h*e.itemSize+v]:0===v?g=e.getX(h):1===v?g=e.getY(h):2===v?g=e.getZ(h):3===v&&(g=e.getW(h)),t===c?u.setFloat32(p,g,!0):t===f?u.setUint32(p,g,!0):t===l?u.setUint16(p,g,!0):t===s&&u.setUint8(p,g),p+=o}var y={buffer:k(u.buffer),byteOffset:x,byteLength:i};return void 0!==a&&(y.target=a),a===d&&(y.byteStride=e.itemSize*o),x+=i,m.bufferViews.push(y),{id:m.bufferViews.length-1,byteLength:0}}(e,a,r,n,h),y={bufferView:g.id,byteOffset:g.byteOffset,componentType:a,count:n,max:v.max,min:v.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return!0===e.normalized&&(y.normalized=!0),m.accessors||(m.accessors=[]),m.accessors.push(y),m.accessors.length-1}function D(e,t,r){S.images.has(e)||S.images.set(e,{});var n=S.images.get(e),a=t===THREE.RGBAFormat?"image/png":"image/jpeg",o=a+":flipY/"+r.toString();if(void 0!==n[o])return n[o];m.images||(m.images=[]);var i={mimeType:a};if(p.embedImages){var s=v=v||document.createElement("canvas");s.width=Math.min(e.width,p.maxTextureSize),s.height=Math.min(e.height,p.maxTextureSize),p.forcePowerOfTwoTextures&&!function(e){return THREE.MathUtils.isPowerOfTwo(e.width)&&THREE.MathUtils.isPowerOfTwo(e.height)}(s)&&(console.warn("GLTFExporter: Resized non-power-of-two image.",e),s.width=THREE.MathUtils.floorPowerOfTwo(s.width),s.height=THREE.MathUtils.floorPowerOfTwo(s.height));var l=s.getContext("2d");!0===r&&(l.translate(0,s.height),l.scale(1,-1)),l.drawImage(e,0,0,s.width,s.height),!0===p.binary?y.push(new Promise((function(e){s.toBlob((function(t){(function(e){return m.bufferViews||(m.bufferViews=[]),new Promise((function(t){var r=new window.FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){var e=H(r.result),n={buffer:k(e),byteOffset:x,byteLength:e.byteLength};x+=e.byteLength,m.bufferViews.push(n),t(m.bufferViews.length-1)}}))})(t).then((function(t){i.bufferView=t,e()}))}),a)}))):i.uri=s.toDataURL(a)}else i.uri=e.src;m.images.push(i);var c=m.images.length-1;return n[o]=c,c}function F(e){m.samplers||(m.samplers=[]);var t={magFilter:b[e.magFilter],minFilter:b[e.minFilter],wrapS:b[e.wrapS],wrapT:b[e.wrapT]};return m.samplers.push(t),m.samplers.length-1}function I(e){if(S.textures.has(e))return S.textures.get(e);m.textures||(m.textures=[]);var t={sampler:F(e),source:D(e.image,e.format,e.flipY)};e.name&&(t.name=e.name),m.textures.push(t);var r=m.textures.length-1;return S.textures.set(e,r),r}function O(e){if(S.materials.has(e))return S.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;m.materials||(m.materials=[]);var t={pbrMetallicRoughness:{}};e.isMeshBasicMaterial?(t.extensions={KHR_materials_unlit:{}},_.KHR_materials_unlit=!0):e.isGLTFSpecularGlossinessMaterial?(t.extensions={KHR_materials_pbrSpecularGlossiness:{}},_.KHR_materials_pbrSpecularGlossiness=!0):e.isMeshStandardMaterial||console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");var r=e.color.toArray().concat([e.opacity]);if(C(r,[1,1,1,1])||(t.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(t.pbrMetallicRoughness.metallicFactor=e.metalness,t.pbrMetallicRoughness.roughnessFactor=e.roughness):e.isMeshBasicMaterial?(t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9):(t.pbrMetallicRoughness.metallicFactor=.5,t.pbrMetallicRoughness.roughnessFactor=.5),e.isGLTFSpecularGlossinessMaterial){t.pbrMetallicRoughness.baseColorFactor&&(t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);var n=[1,1,1];e.specular.toArray(n,0),t.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor=n,t.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor=e.glossiness}if(e.metalnessMap||e.roughnessMap)if(e.metalnessMap===e.roughnessMap){var a={index:I(e.metalnessMap)};z(a,e.metalnessMap),t.pbrMetallicRoughness.metallicRoughnessTexture=a}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(e.map){var o={index:I(e.map)};z(o,e.map),e.isGLTFSpecularGlossinessMaterial&&(t.extensions.KHR_materials_pbrSpecularGlossiness.diffuseTexture=o),t.pbrMetallicRoughness.baseColorTexture=o}if(e.isGLTFSpecularGlossinessMaterial&&e.specularMap){var i={index:I(e.specularMap)};z(i,e.specularMap),t.extensions.KHR_materials_pbrSpecularGlossiness.specularGlossinessTexture=i}if(e.emissive){var s=e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray();if(C(s,[0,0,0])||(t.emissiveFactor=s),e.emissiveMap){var l={index:I(e.emissiveMap)};z(l,e.emissiveMap),t.emissiveTexture=l}}if(e.normalMap){var c={index:I(e.normalMap)};e.normalScale&&-1!==e.normalScale.x&&(e.normalScale.x!==e.normalScale.y&&console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),c.scale=e.normalScale.x),z(c,e.normalMap),t.normalTexture=c}if(e.aoMap){var f={index:I(e.aoMap),texCoord:1};1!==e.aoMapIntensity&&(f.strength=e.aoMapIntensity),z(f,e.aoMap),t.occlusionTexture=f}e.transparent?t.alphaMode="BLEND":e.alphaTest>0&&(t.alphaMode="MASK",t.alphaCutoff=e.alphaTest),e.side===THREE.DoubleSide&&(t.doubleSided=!0),""!==e.name&&(t.name=e.name),P(e,t),m.materials.push(t);var d=m.materials.length-1;return S.materials.set(e,d),d}function U(e){var t=[e.geometry.uuid];if(Array.isArray(e.material))for(var s=0,l=e.material.length;s<l;s++)t.push(e.material[s].uuid);else t.push(e.material.uuid);var c=t.join(":");if(S.meshes.has(c))return S.meshes.get(c);var f,d=e.geometry;f=e.isLineSegments?n:e.isLineLoop?a:e.isLine?o:e.isPoints?r:e.material.wireframe?n:i,d.isBufferGeometry||(console.warn("GLTFExporter: Exporting THREE.Geometry will increase file size. Use THREE.BufferGeometry instead."),d=(new THREE.BufferGeometry).setFromObject(e));var u={},p={},h=[],v=[],x={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},g=d.getAttribute("normal");void 0===g||function(e){if(S.attributesNormalized.has(e))return!1;for(var t=new THREE.Vector3,r=0,n=e.count;r<n;r++)if(Math.abs(t.fromArray(e.array,3*r).length()-1)>5e-4)return!1;return!0}(g)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),d.setAttribute("normal",function(e){if(S.attributesNormalized.has(e))return S.attributesNormalized.get(e);for(var t=e.clone(),r=new THREE.Vector3,n=0,a=t.count;n<a;n++)r.fromArray(t.array,3*n),0===r.x&&0===r.y&&0===r.z?r.setX(1):r.normalize(),r.toArray(t.array,3*n);return S.attributesNormalized.set(e,t),t}(g)));var y=null;for(var E in d.attributes)if("morph"!==E.substr(0,5)){var w=d.attributes[E];E=x[E]||E.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(E)||(E="_"+E),S.attributes.has(M(w)))p[E]=S.attributes.get(M(w));else{y=null;var b=w.array;"JOINTS_0"!==E||b instanceof Uint16Array||b instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),y=new THREE.BufferAttribute(new Uint16Array(b),w.itemSize,w.normalized));var T=N(y||w,d);null!==T&&(p[E]=T,S.attributes.set(M(w),T))}}if(void 0!==g&&d.setAttribute("normal",g),0===Object.keys(p).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){var _=[],R=[],A={};if(void 0!==e.morphTargetDictionary)for(var C in e.morphTargetDictionary)A[e.morphTargetDictionary[C]]=C;for(s=0;s<e.morphTargetInfluences.length;++s){var L={},H=!1;for(var E in d.morphAttributes)if("position"===E||"normal"===E){w=d.morphAttributes[E][s];var z=E.toUpperCase(),k=d.attributes[E];if(S.attributes.has(M(w)))L[z]=S.attributes.get(M(w));else{var D=w.clone();if(!d.morphTargetsRelative)for(var F=0,I=w.count;F<I;F++)D.setXYZ(F,w.getX(F)-k.getX(F),w.getY(F)-k.getY(F),w.getZ(F)-k.getZ(F));L[z]=N(D,d),S.attributes.set(M(k),L[z])}}else H||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),H=!0);v.push(L),_.push(e.morphTargetInfluences[s]),void 0!==e.morphTargetDictionary&&R.push(A[s])}u.weights=_,R.length>0&&(u.extras={},u.extras.targetNames=R)}var U=Array.isArray(e.material);if(U&&0===d.groups.length)return null;for(var G=U?e.material:[e.material],B=U?d.groups:[{materialIndex:0,start:void 0,count:void 0}],V=(s=0,B.length);s<V;s++){var j={mode:f,attributes:p};if(P(d,j),v.length>0&&(j.targets=v),null!==d.index){var W=M(d.index);void 0===B[s].start&&void 0===B[s].count||(W+=":"+B[s].start+":"+B[s].count),S.attributes.has(W)?j.indices=S.attributes.get(W):(j.indices=N(d.index,d,B[s].start,B[s].count),S.attributes.set(W,j.indices)),null===j.indices&&delete j.indices}var q=O(G[B[s].materialIndex]);null!==q&&(j.material=q),h.push(j)}u.primitives=h,m.meshes||(m.meshes=[]),m.meshes.push(u);var X=m.meshes.length-1;return S.meshes.set(c,X),X}function G(e,t){m.animations||(m.animations=[]);for(var r=(e=THREE.GLTFExporter.Utils.mergeMorphTargetTracks(e.clone(),t)).tracks,n=[],a=[],o=0;o<r.length;++o){var i=r[o],s=THREE.PropertyBinding.parseTrackName(i.name),l=THREE.PropertyBinding.findNode(t,s.nodeName),c=T[s.propertyName];if("bones"===s.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(s.objectIndex):void 0),!l||!c)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',i.name),null;var f,d=i.values.length/i.times.length;c===T.morphTargetInfluences&&(d/=l.morphTargetInfluences.length),!0===i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(f="CUBICSPLINE",d/=3):f=i.getInterpolation()===THREE.InterpolateDiscrete?"STEP":"LINEAR",a.push({input:N(new THREE.BufferAttribute(i.times,1)),output:N(new THREE.BufferAttribute(i.values,d)),interpolation:f}),n.push({sampler:a.length-1,target:{node:E.get(l),path:c}})}return m.animations.push({name:e.name||"clip_"+m.animations.length,samplers:a,channels:n}),m.animations.length-1}function B(e){var t=m.nodes[E.get(e)],r=e.skeleton;if(void 0===r)return null;var n=e.skeleton.bones[0];if(void 0===n)return null;for(var a=[],o=new Float32Array(16*r.bones.length),i=0;i<r.bones.length;++i)a.push(E.get(r.bones[i])),r.boneInverses[i].toArray(o,16*i);return void 0===m.skins&&(m.skins=[]),m.skins.push({inverseBindMatrices:N(new THREE.BufferAttribute(o,16)),joints:a,skeleton:E.get(n)}),t.skin=m.skins.length-1}function V(e){var t={};e.name&&(t.name=e.name),t.color=e.color.toArray(),t.intensity=e.intensity,e.isDirectionalLight?t.type="directional":e.isPointLight?(t.type="point",e.distance>0&&(t.range=e.distance)):e.isSpotLight&&(t.type="spot",e.distance>0&&(t.range=e.distance),t.spot={},t.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,t.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1.");var r=m.extensions.KHR_lights_punctual.lights;return r.push(t),r.length-1}function j(e){m.nodes||(m.nodes=[]);var t={};if(p.trs){var r=e.quaternion.toArray(),n=e.position.toArray(),a=e.scale.toArray();C(r,[0,0,0,1])||(t.rotation=r),C(n,[0,0,0])||(t.translation=n),C(a,[1,1,1])||(t.scale=a)}else e.matrixAutoUpdate&&e.updateMatrix(),C(e.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])||(t.matrix=e.matrix.elements);if(""!==e.name&&(t.name=String(e.name)),P(e,t),e.isMesh||e.isLine||e.isPoints){var o=U(e);null!==o&&(t.mesh=o)}else if(e.isCamera)t.camera=function(e){m.cameras||(m.cameras=[]);var t=e.isOrthographicCamera,r={type:t?"orthographic":"perspective"};return t?r.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:r.perspective={aspectRatio:e.aspect,yfov:THREE.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},""!==e.name&&(r.name=e.type),m.cameras.push(r),m.cameras.length-1}(e);else if(e.isDirectionalLight||e.isPointLight||e.isSpotLight)_.KHR_lights_punctual||(m.extensions=m.extensions||{},m.extensions.KHR_lights_punctual={lights:[]},_.KHR_lights_punctual=!0),t.extensions=t.extensions||{},t.extensions.KHR_lights_punctual={light:V(e)};else if(e.isLight)return console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e),null;if(e.isSkinnedMesh&&w.push(e),e.children.length>0){for(var i=[],s=0,l=e.children.length;s<l;s++){var c=e.children[s];if(c.visible||!1===p.onlyVisible){var f=j(c);null!==f&&i.push(f)}}i.length>0&&(t.children=i)}m.nodes.push(t);var d=m.nodes.length-1;return E.set(e,d),d}function W(e){m.scenes||(m.scenes=[],m.scene=0);var t={};""!==e.name&&(t.name=e.name),m.scenes.push(t);for(var r=[],n=0,a=e.children.length;n<a;n++){var o=e.children[n];if(o.visible||!1===p.onlyVisible){var i=j(o);null!==i&&r.push(i)}}r.length>0&&(t.nodes=r),P(e,t)}!function(e){e=e instanceof Array?e:[e];for(var t=[],r=0;r<e.length;r++)e[r]instanceof THREE.Scene?W(e[r]):t.push(e[r]);for(t.length>0&&function(e){var t=new THREE.Scene;t.name="AuxScene";for(var r=0;r<e.length;r++)t.children.push(e[r]);W(t)}(t),r=0;r<w.length;++r)B(w[r]);for(r=0;r<p.animations.length;++r)G(p.animations[r],e[0])}(e),Promise.all(y).then((function(){var e=new Blob(g,{type:"application/octet-stream"}),r=Object.keys(_);if(r.length>0&&(m.extensionsUsed=r),m.buffers&&m.buffers.length>0&&(m.buffers[0].byteLength=e.size),!0===p.binary){(n=new window.FileReader).readAsArrayBuffer(e),n.onloadend=function(){var e=H(n.result),r=new DataView(new ArrayBuffer(8));r.setUint32(0,e.byteLength,!0),r.setUint32(4,5130562,!0);var a=H(function(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;for(var t=new Uint8Array(new ArrayBuffer(e.length)),r=0,n=e.length;r<n;r++){var a=e.charCodeAt(r);t[r]=a>255?32:a}return t.buffer}(JSON.stringify(m)),32),o=new DataView(new ArrayBuffer(8));o.setUint32(0,a.byteLength,!0),o.setUint32(4,1313821514,!0);var i=new ArrayBuffer(12),s=new DataView(i);s.setUint32(0,1179937895,!0),s.setUint32(4,2,!0);var l=12+o.byteLength+a.byteLength+r.byteLength+e.byteLength;s.setUint32(8,l,!0);var c=new Blob([i,o,a,r,e],{type:"application/octet-stream"}),f=new window.FileReader;f.readAsArrayBuffer(c),f.onloadend=function(){t(f.result)}}}else{var n;if(m.buffers&&m.buffers.length>0)(n=new window.FileReader).readAsDataURL(e),n.onloadend=function(){var e=n.result;m.buffers[0].uri=e,t(m)};else t(m)}}))}},THREE.GLTFExporter.Utils={insertKeyframe:function(e,t){var r,n=e.getValueSize(),a=new e.TimeBufferType(e.times.length+1),o=new e.ValueBufferType(e.values.length+n),i=e.createInterpolant(new e.ValueBufferType(n));if(0===e.times.length){a[0]=t;for(var s=0;s<n;s++)o[s]=0;r=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<.001)return 0;a[0]=t,a.set(e.times,1),o.set(i.evaluate(t),0),o.set(e.values,n),r=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<.001)return e.times.length-1;a[a.length-1]=t,a.set(e.times,0),o.set(e.values,0),o.set(i.evaluate(t),e.values.length),r=a.length-1}else for(s=0;s<e.times.length;s++){if(Math.abs(e.times[s]-t)<.001)return s;if(e.times[s]<t&&e.times[s+1]>t){a.set(e.times.slice(0,s+1),0),a[s+1]=t,a.set(e.times.slice(s+1),s+2),o.set(e.values.slice(0,(s+1)*n),0),o.set(i.evaluate(t),(s+1)*n),o.set(e.values.slice((s+1)*n),(s+2)*n),r=s+1;break}}return e.times=a,e.values=o,r},mergeMorphTargetTracks:function(e,t){for(var r=[],n={},a=e.tracks,o=0;o<a.length;++o){var i=a[o],s=THREE.PropertyBinding.parseTrackName(i.name),l=THREE.PropertyBinding.findNode(t,s.nodeName);if("morphTargetInfluences"===s.propertyName&&void 0!==s.propertyIndex){if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),(i=i.clone()).setInterpolation(THREE.InterpolateLinear)}var c,f=l.morphTargetInfluences.length,d=l.morphTargetDictionary[s.propertyIndex];if(void 0===d)throw new Error("THREE.GLTFExporter: Morph target name not found: "+s.propertyIndex);if(void 0!==n[l.uuid]){var u=i.createInterpolant(new i.ValueBufferType(1));c=n[l.uuid];for(v=0;v<c.times.length;v++)c.values[v*f+d]=u.evaluate(c.times[v]);for(v=0;v<i.times.length;v++){var p=this.insertKeyframe(c,i.times[v]);c.values[p*f+d]=i.values[v]}}else{for(var h=new((c=i.clone()).ValueBufferType)(f*c.times.length),v=0;v<c.times.length;v++)h[v*f+d]=c.values[v];c.name=s.nodeName+".morphTargetInfluences",c.values=h,n[l.uuid]=c,r.push(c)}}else r.push(i)}return e.tracks=r,e}}},function(e,t,r){"use strict";r.r(t);var n=r(0);THREE.AMFLoader=function(e){THREE.Loader.call(this,e)},THREE.AMFLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.AMFLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){function t(e){for(var t="AMF Material",n=e.attributes.id.textContent,a={r:1,g:1,b:1,a:1},o=null,i=0;i<e.childNodes.length;i++){var s=e.childNodes[i];"metadata"===s.nodeName&&void 0!==s.attributes.type?"name"===s.attributes.type.value&&(t=s.textContent):"color"===s.nodeName&&(a=r(s))}return o=new THREE.MeshPhongMaterial({flatShading:!0,color:new THREE.Color(a.r,a.g,a.b),name:t}),1!==a.a&&(o.transparent=!0,o.opacity=a.a),{id:n,material:o}}function r(e){for(var t={r:1,g:1,b:1,a:1},r=0;r<e.childNodes.length;r++){var n=e.childNodes[r];"r"===n.nodeName?t.r=n.textContent:"g"===n.nodeName?t.g=n.textContent:"b"===n.nodeName?t.b=n.textContent:"a"===n.nodeName&&(t.a=n.textContent)}return t}function a(e){var t={name:"",triangles:[],materialid:null},r=e.firstElementChild;for(void 0!==e.attributes.materialid&&(t.materialId=e.attributes.materialid.nodeValue);r;){if("metadata"===r.nodeName)void 0!==r.attributes.type&&"name"===r.attributes.type.value&&(t.name=r.textContent);else if("triangle"===r.nodeName){var n=r.getElementsByTagName("v1")[0].textContent,a=r.getElementsByTagName("v2")[0].textContent,o=r.getElementsByTagName("v3")[0].textContent;t.triangles.push(n,a,o)}r=r.nextElementSibling}return t}function o(e){for(var t=[],r=[],n=e.firstElementChild;n;){if("vertex"===n.nodeName)for(var a=n.firstElementChild;a;){if("coordinates"===a.nodeName){var o=a.getElementsByTagName("x")[0].textContent,i=a.getElementsByTagName("y")[0].textContent,s=a.getElementsByTagName("z")[0].textContent;t.push(o,i,s)}else if("normal"===a.nodeName){var l=a.getElementsByTagName("nx")[0].textContent,c=a.getElementsByTagName("ny")[0].textContent,f=a.getElementsByTagName("nz")[0].textContent;r.push(l,c,f)}a=a.nextElementSibling}n=n.nextElementSibling}return{vertices:t,normals:r}}function i(e){for(var t=e.attributes.id.textContent,n={name:"amfobject",meshes:[]},i=null,s=e.firstElementChild;s;){if("metadata"===s.nodeName)void 0!==s.attributes.type&&"name"===s.attributes.type.value&&(n.name=s.textContent);else if("color"===s.nodeName)i=r(s);else if("mesh"===s.nodeName){for(var l=s.firstElementChild,c={vertices:[],normals:[],volumes:[],color:i};l;){if("vertices"===l.nodeName){var f=o(l);c.normals=c.normals.concat(f.normals),c.vertices=c.vertices.concat(f.vertices)}else"volume"===l.nodeName&&c.volumes.push(a(l));l=l.nextElementSibling}n.meshes.push(c)}s=s.nextElementSibling}return{id:t,obj:n}}var s,l,c=function(e){var t=new DataView(e);if("PK"===String.fromCharCode(t.getUint8(0),t.getUint8(1))){var r=null,a=null;console.log("THREE.AMFLoader: Loading Zip");try{r=new n(e)}catch(e){if(e instanceof ReferenceError)return console.log("THREE.AMFLoader: jszip missing and file is compressed."),null}for(a in r.files)if(".amf"===a.toLowerCase().substr(-4))break;console.log("THREE.AMFLoader: Trying to load file asset: "+a),t=new DataView(r.file(a).asArrayBuffer())}var o=THREE.LoaderUtils.decodeText(t),i=(new DOMParser).parseFromString(o,"application/xml");return"amf"!==i.documentElement.nodeName.toLowerCase()?(console.log("THREE.AMFLoader: Error loading AMF - no AMF document found."),null):i}(e),f="",d="",u=function(e){var t=1,r="millimeter";void 0!==e.documentElement.attributes.unit&&(r=e.documentElement.attributes.unit.value.toLowerCase());var n={millimeter:1,inch:25.4,feet:304.8,meter:1e3,micron:.001};return void 0!==n[r]&&(t=n[r]),console.log("THREE.AMFLoader: Unit scale: "+t),t}(c),p={},h={},v=c.documentElement.childNodes;for(s=0;s<v.length;s++){var m=v[s];if("metadata"===m.nodeName)void 0!==m.attributes.type&&("name"===m.attributes.type.value?f=m.textContent:"author"===m.attributes.type.value&&(d=m.textContent));else if("material"===m.nodeName){var x=t(m);p[x.id]=x.material}else if("object"===m.nodeName){var g=i(m);h[g.id]=g.obj}}var y=new THREE.Group,E=new THREE.MeshPhongMaterial({color:11184895,flatShading:!0});for(var w in y.name=f,y.userData.author=d,y.userData.loader="AMF",h){var b=h[w],T=b.meshes,_=new THREE.Group;for(_.name=b.name||"",s=0;s<T.length;s++){var S=E,R=T[s],A=new THREE.Float32BufferAttribute(R.vertices,3),M=null;if(R.normals.length&&(M=new THREE.Float32BufferAttribute(R.normals,3)),R.color){var C=R.color;(S=E.clone()).color=new THREE.Color(C.r,C.g,C.b),1!==C.a&&(S.transparent=!0,S.opacity=C.a)}var L=R.volumes;for(l=0;l<L.length;l++){var H=L[l],P=new THREE.BufferGeometry,z=S;P.setIndex(H.triangles),P.setAttribute("position",A.clone()),M&&P.setAttribute("normal",M.clone()),void 0!==p[H.materialId]&&(z=p[H.materialId]),P.scale(u,u,u),_.add(new THREE.Mesh(P,z.clone()))}}y.add(_)}return y}})},function(e,t,r){"use strict";(function(e){var n=r(34),a=r(35),o=r(36);function i(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(e,t){if(i()<t)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=l.prototype:(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,r){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return d(this,e)}return c(this,e,t,r)}function c(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);l.TYPED_ARRAY_SUPPORT?(e=t).__proto__=l.prototype:e=u(e,t);return e}(e,t,r,n):"string"==typeof t?function(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!l.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|h(t,r),a=(e=s(e,n)).write(t,r);a!==n&&(e=e.slice(0,a));return e}(e,t,r):function(e,t){if(l.isBuffer(t)){var r=0|p(t.length);return 0===(e=s(e,r)).length||t.copy(e,0,0,r),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(n=t.length)!=n?s(e,0):u(e,t);if("Buffer"===t.type&&o(t.data))return u(e,t.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function f(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function d(e,t){if(f(t),e=s(e,t<0?0:0|p(t)),!l.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function u(e,t){var r=t.length<0?0:0|p(t.length);e=s(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function p(e){if(e>=i())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i().toString(16)+" bytes");return 0|e}function h(e,t){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return U(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return G(e).length;default:if(n)return U(e).length;t=(""+t).toLowerCase(),n=!0}}function v(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return C(this,t,r);case"utf8":case"utf-8":return R(this,t,r);case"ascii":return A(this,t,r);case"latin1":case"binary":return M(this,t,r);case"base64":return S(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return L(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}function m(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function x(e,t,r,n,a){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=a?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(a)return-1;r=e.length-1}else if(r<0){if(!a)return-1;r=0}if("string"==typeof t&&(t=l.from(t,n)),l.isBuffer(t))return 0===t.length?-1:g(e,t,r,n,a);if("number"==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):g(e,[t],r,n,a);throw new TypeError("val must be string, number or Buffer")}function g(e,t,r,n,a){var o,i=1,s=e.length,l=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;i=2,s/=2,l/=2,r/=2}function c(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(a){var f=-1;for(o=r;o<s;o++)if(c(e,o)===c(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===l)return f*i}else-1!==f&&(o-=o-f),f=-1}else for(r+l>s&&(r=s-l),o=r;o>=0;o--){for(var d=!0,u=0;u<l;u++)if(c(e,o+u)!==c(t,u)){d=!1;break}if(d)return o}return-1}function y(e,t,r,n){r=Number(r)||0;var a=e.length-r;n?(n=Number(n))>a&&(n=a):n=a;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var i=0;i<n;++i){var s=parseInt(t.substr(2*i,2),16);if(isNaN(s))return i;e[r+i]=s}return i}function E(e,t,r,n){return B(U(t,e.length-r),e,r,n)}function w(e,t,r,n){return B(function(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function b(e,t,r,n){return w(e,t,r,n)}function T(e,t,r,n){return B(G(t),e,r,n)}function _(e,t,r,n){return B(function(e,t){for(var r,n,a,o=[],i=0;i<e.length&&!((t-=2)<0);++i)r=e.charCodeAt(i),n=r>>8,a=r%256,o.push(a),o.push(n);return o}(t,e.length-r),e,r,n)}function S(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function R(e,t,r){r=Math.min(e.length,r);for(var n=[],a=t;a<r;){var o,i,s,l,c=e[a],f=null,d=c>239?4:c>223?3:c>191?2:1;if(a+d<=r)switch(d){case 1:c<128&&(f=c);break;case 2:128==(192&(o=e[a+1]))&&(l=(31&c)<<6|63&o)>127&&(f=l);break;case 3:o=e[a+1],i=e[a+2],128==(192&o)&&128==(192&i)&&(l=(15&c)<<12|(63&o)<<6|63&i)>2047&&(l<55296||l>57343)&&(f=l);break;case 4:o=e[a+1],i=e[a+2],s=e[a+3],128==(192&o)&&128==(192&i)&&128==(192&s)&&(l=(15&c)<<18|(63&o)<<12|(63&i)<<6|63&s)>65535&&l<1114112&&(f=l)}null===f?(f=65533,d=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),a+=d}return function(e){var t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=4096));return r}(n)}t.Buffer=l,t.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},t.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=i(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,r){return c(null,e,t,r)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,r){return function(e,t,r,n){return f(t),t<=0?s(e,t):void 0!==r?"string"==typeof n?s(e,t).fill(r,n):s(e,t).fill(r):s(e,t)}(null,e,t,r)},l.allocUnsafe=function(e){return d(null,e)},l.allocUnsafeSlow=function(e){return d(null,e)},l.isBuffer=function(e){return!(null==e||!e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,a=0,o=Math.min(r,n);a<o;++a)if(e[a]!==t[a]){r=e[a],n=t[a];break}return r<n?-1:n<r?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=l.allocUnsafe(t),a=0;for(r=0;r<e.length;++r){var i=e[r];if(!l.isBuffer(i))throw new TypeError('"list" argument must be an Array of Buffers');i.copy(n,a),a+=i.length}return n},l.byteLength=h,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)m(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)m(this,t,t+3),m(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)m(this,t,t+7),m(this,t+1,t+6),m(this,t+2,t+5),m(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?R(this,0,e):v.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,t,r,n,a){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===a&&(a=this.length),t<0||r>e.length||n<0||a>this.length)throw new RangeError("out of range index");if(n>=a&&t>=r)return 0;if(n>=a)return-1;if(t>=r)return 1;if(this===e)return 0;for(var o=(a>>>=0)-(n>>>=0),i=(r>>>=0)-(t>>>=0),s=Math.min(o,i),c=this.slice(n,a),f=e.slice(t,r),d=0;d<s;++d)if(c[d]!==f[d]){o=c[d],i=f[d];break}return o<i?-1:i<o?1:0},l.prototype.includes=function(e,t,r){return-1!==this.indexOf(e,t,r)},l.prototype.indexOf=function(e,t,r){return x(this,e,t,r,!0)},l.prototype.lastIndexOf=function(e,t,r){return x(this,e,t,r,!1)},l.prototype.write=function(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var a=this.length-t;if((void 0===r||r>a)&&(r=a),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return y(this,e,t,r);case"utf8":case"utf-8":return E(this,e,t,r);case"ascii":return w(this,e,t,r);case"latin1":case"binary":return b(this,e,t,r);case"base64":return T(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return _(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function A(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(127&e[a]);return n}function M(e,t,r){var n="";r=Math.min(e.length,r);for(var a=t;a<r;++a)n+=String.fromCharCode(e[a]);return n}function C(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var a="",o=t;o<r;++o)a+=O(e[o]);return a}function L(e,t,r){for(var n=e.slice(t,r),a="",o=0;o<n.length;o+=2)a+=String.fromCharCode(n[o]+256*n[o+1]);return a}function H(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function P(e,t,r,n,a,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>a||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function z(e,t,r,n){t<0&&(t=65535+t+1);for(var a=0,o=Math.min(e.length-r,2);a<o;++a)e[r+a]=(t&255<<8*(n?a:1-a))>>>8*(n?a:1-a)}function k(e,t,r,n){t<0&&(t=4294967295+t+1);for(var a=0,o=Math.min(e.length-r,4);a<o;++a)e[r+a]=t>>>8*(n?a:3-a)&255}function N(e,t,r,n,a,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function D(e,t,r,n,o){return o||N(e,0,r,4),a.write(e,t,r,n,23,4),r+4}function F(e,t,r,n,o){return o||N(e,0,r,8),a.write(e,t,r,n,52,8),r+8}l.prototype.slice=function(e,t){var r,n=this.length;if((e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),l.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=l.prototype;else{var a=t-e;r=new l(a,void 0);for(var o=0;o<a;++o)r[o]=this[o+e]}return r},l.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],a=1,o=0;++o<t&&(a*=256);)n+=this[e+o]*a;return n},l.prototype.readUIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e+--t],a=1;t>0&&(a*=256);)n+=this[e+--t]*a;return n},l.prototype.readUInt8=function(e,t){return t||H(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||H(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||H(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||H(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||H(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=this[e],a=1,o=0;++o<t&&(a*=256);)n+=this[e+o]*a;return n>=(a*=128)&&(n-=Math.pow(2,8*t)),n},l.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||H(e,t,this.length);for(var n=t,a=1,o=this[e+--n];n>0&&(a*=256);)o+=this[e+--n]*a;return o>=(a*=128)&&(o-=Math.pow(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||H(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||H(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},l.prototype.readInt16BE=function(e,t){t||H(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},l.prototype.readInt32LE=function(e,t){return t||H(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||H(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||H(e,4,this.length),a.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||H(e,4,this.length),a.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||H(e,8,this.length),a.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||H(e,8,this.length),a.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||P(this,e,t,r,Math.pow(2,8*r)-1,0);var a=1,o=0;for(this[t]=255&e;++o<r&&(a*=256);)this[t+o]=e/a&255;return t+r},l.prototype.writeUIntBE=function(e,t,r,n){(e=+e,t|=0,r|=0,n)||P(this,e,t,r,Math.pow(2,8*r)-1,0);var a=r-1,o=1;for(this[t+a]=255&e;--a>=0&&(o*=256);)this[t+a]=e/o&255;return t+r},l.prototype.writeUInt8=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):k(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):k(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t|=0,!n){var a=Math.pow(2,8*r-1);P(this,e,t,r,a-1,-a)}var o=0,i=1,s=0;for(this[t]=255&e;++o<r&&(i*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+r},l.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t|=0,!n){var a=Math.pow(2,8*r-1);P(this,e,t,r,a-1,-a)}var o=r-1,i=1,s=0;for(this[t+o]=255&e;--o>=0&&(i*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+r},l.prototype.writeInt8=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):z(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):z(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):k(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,r){return e=+e,t|=0,r||P(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):k(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,r){return D(this,e,t,!0,r)},l.prototype.writeFloatBE=function(e,t,r){return D(this,e,t,!1,r)},l.prototype.writeDoubleLE=function(e,t,r){return F(this,e,t,!0,r)},l.prototype.writeDoubleBE=function(e,t,r){return F(this,e,t,!1,r)},l.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var a,o=n-r;if(this===e&&r<t&&t<n)for(a=o-1;a>=0;--a)e[a+t]=this[a+r];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(a=0;a<o;++a)e[a+t]=this[a+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},l.prototype.fill=function(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var a=e.charCodeAt(0);a<256&&(e=a)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!l.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var i=l.isBuffer(e)?e:U(new l(e,n).toString()),s=i.length;for(o=0;o<r-t;++o)this[o+t]=i[o%s]}return this};var I=/[^+\/0-9A-Za-z-_]/g;function O(e){return e<16?"0"+e.toString(16):e.toString(16)}function U(e,t){var r;t=t||1/0;for(var n=e.length,a=null,o=[],i=0;i<n;++i){if((r=e.charCodeAt(i))>55295&&r<57344){if(!a){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(i+1===n){(t-=3)>-1&&o.push(239,191,189);continue}a=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),a=r;continue}r=65536+(a-55296<<10|r-56320)}else a&&(t-=3)>-1&&o.push(239,191,189);if(a=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function G(e){return n.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(I,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function B(e,t,r,n){for(var a=0;a<n&&!(a+r>=t.length||a>=e.length);++a)t[a+r]=e[a];return a}}).call(this,r(4))},function(e,t,r){"use strict";t.byteLength=function(e){var t=c(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function(e){var t,r,n=c(e),i=n[0],s=n[1],l=new o(function(e,t,r){return 3*(t+r)/4-r}(0,i,s)),f=0,d=s>0?i-4:i;for(r=0;r<d;r+=4)t=a[e.charCodeAt(r)]<<18|a[e.charCodeAt(r+1)]<<12|a[e.charCodeAt(r+2)]<<6|a[e.charCodeAt(r+3)],l[f++]=t>>16&255,l[f++]=t>>8&255,l[f++]=255&t;2===s&&(t=a[e.charCodeAt(r)]<<2|a[e.charCodeAt(r+1)]>>4,l[f++]=255&t);1===s&&(t=a[e.charCodeAt(r)]<<10|a[e.charCodeAt(r+1)]<<4|a[e.charCodeAt(r+2)]>>2,l[f++]=t>>8&255,l[f++]=255&t);return l},t.fromByteArray=function(e){for(var t,r=e.length,a=r%3,o=[],i=0,s=r-a;i<s;i+=16383)o.push(f(e,i,i+16383>s?s:i+16383));1===a?(t=e[r-1],o.push(n[t>>2]+n[t<<4&63]+"==")):2===a&&(t=(e[r-2]<<8)+e[r-1],o.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return o.join("")};for(var n=[],a=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,l=i.length;s<l;++s)n[s]=i[s],a[i.charCodeAt(s)]=s;function c(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function f(e,t,r){for(var a,o,i=[],s=t;s<r;s+=3)a=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),i.push(n[(o=a)>>18&63]+n[o>>12&63]+n[o>>6&63]+n[63&o]);return i.join("")}a["-".charCodeAt(0)]=62,a["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,r,n,a){var o,i,s=8*a-n-1,l=(1<<s)-1,c=l>>1,f=-7,d=r?a-1:0,u=r?-1:1,p=e[t+d];for(d+=u,o=p&(1<<-f)-1,p>>=-f,f+=s;f>0;o=256*o+e[t+d],d+=u,f-=8);for(i=o&(1<<-f)-1,o>>=-f,f+=n;f>0;i=256*i+e[t+d],d+=u,f-=8);if(0===o)o=1-c;else{if(o===l)return i?NaN:1/0*(p?-1:1);i+=Math.pow(2,n),o-=c}return(p?-1:1)*i*Math.pow(2,o-n)},t.write=function(e,t,r,n,a,o){var i,s,l,c=8*o-a-1,f=(1<<c)-1,d=f>>1,u=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,h=n?1:-1,v=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,i=f):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),(t+=i+d>=1?u/l:u*Math.pow(2,1-d))*l>=2&&(i++,l/=2),i+d>=f?(s=0,i=f):i+d>=1?(s=(t*l-1)*Math.pow(2,a),i+=d):(s=t*Math.pow(2,d-1)*Math.pow(2,a),i=0));a>=8;e[r+p]=255&s,p+=h,s/=256,a-=8);for(i=i<<a|s,c+=a;c>0;e[r+p]=255&i,p+=h,i/=256,c-=8);e[r+p-h]|=128*v}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){"use strict";r.r(t);var n=r(0);THREE.ThreeMFLoader=function(e){THREE.Loader.call(this,e),this.availableExtensions=[]},THREE.ThreeMFLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.ThreeMFLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t=this,r=new THREE.TextureLoader(this.manager);function a(e){for(var t=[],r=(new DOMParser).parseFromString(e,"application/xml").querySelectorAll("Relationship"),n=0;n<r.length;n++){var a=r[n],o={target:a.getAttribute("Target"),id:a.getAttribute("Id"),type:a.getAttribute("Type")};t.push(o)}return t}function o(e){for(var t={id:e.getAttribute("id"),basematerials:[]},r=e.querySelectorAll("base"),n=0;n<r.length;n++){var a=c(r[n]);a.index=n,t.basematerials.push(a)}return t}function i(e){for(var t={id:e.getAttribute("id"),texid:e.getAttribute("texid"),displaypropertiesid:e.getAttribute("displaypropertiesid")},r=e.querySelectorAll("tex2coord"),n=[],a=0;a<r.length;a++){var o=r[a],i=o.getAttribute("u"),s=o.getAttribute("v");n.push(parseFloat(i),parseFloat(s))}return t.uvs=new Float32Array(n),t}function s(e){for(var t={id:e.getAttribute("id"),displaypropertiesid:e.getAttribute("displaypropertiesid")},r=e.querySelectorAll("color"),n=[],a=new THREE.Color,o=0;o<r.length;o++){var i=r[o].getAttribute("color");a.setStyle(i.substring(0,7)),a.convertSRGBToLinear(),n.push(a.r,a.g,a.b)}return t.colors=new Float32Array(n),t}function l(e){for(var t={id:e.getAttribute("id")},r=e.querySelectorAll("pbmetallic"),n=[],a=0;a<r.length;a++){var o=r[a];n.push({name:o.getAttribute("name"),metallicness:parseFloat(o.getAttribute("metallicness")),roughness:parseFloat(o.getAttribute("roughness"))})}return t.data=n,t}function c(e){var t={};return t.name=e.getAttribute("name"),t.displaycolor=e.getAttribute("displaycolor"),t.displaypropertiesid=e.getAttribute("displaypropertiesid"),t}function f(e){var t={};t.objectId=e.getAttribute("objectid");var r=e.getAttribute("transform");return r&&(t.transform=d(r)),t}function d(e){var t=[];e.split(" ").forEach((function(e){t.push(parseFloat(e))}));var r=new THREE.Matrix4;return r.set(t[0],t[3],t[6],t[9],t[1],t[4],t[7],t[10],t[2],t[5],t[8],t[11],0,0,0,1),r}function u(e){var t={type:e.getAttribute("type")},r=e.getAttribute("id");r&&(t.id=r);var n=e.getAttribute("pid");n&&(t.pid=n);var a=e.getAttribute("pindex");a&&(t.pindex=a);var o=e.getAttribute("thumbnail");o&&(t.thumbnail=o);var i=e.getAttribute("partnumber");i&&(t.partnumber=i);var s=e.getAttribute("name");s&&(t.name=s);var l=e.querySelector("mesh");l&&(t.mesh=function(e){for(var t={},r=[],n=e.querySelectorAll("vertices vertex"),a=0;a<n.length;a++){var o=n[a],i=o.getAttribute("x"),s=o.getAttribute("y"),l=o.getAttribute("z");r.push(parseFloat(i),parseFloat(s),parseFloat(l))}t.vertices=new Float32Array(r);var c=[],f=[],d=e.querySelectorAll("triangles triangle");for(a=0;a<d.length;a++){var u=d[a],p=u.getAttribute("v1"),h=u.getAttribute("v2"),v=u.getAttribute("v3"),m=u.getAttribute("p1"),x=u.getAttribute("p2"),g=u.getAttribute("p3"),y=u.getAttribute("pid"),E={};E.v1=parseInt(p,10),E.v2=parseInt(h,10),E.v3=parseInt(v,10),f.push(E.v1,E.v2,E.v3),m&&(E.p1=parseInt(m,10)),x&&(E.p2=parseInt(x,10)),g&&(E.p3=parseInt(g,10)),y&&(E.pid=y),0<Object.keys(E).length&&c.push(E)}return t.triangleProperties=c,t.triangles=new Uint32Array(f),t}(l));var c=e.querySelector("components");return c&&(t.components=function(e){for(var t=[],r=e.querySelectorAll("component"),n=0;n<r.length;n++){var a=f(r[n]);t.push(a)}return t}(c)),t}function p(e){var t={unit:e.getAttribute("unit")||"millimeter"},r=e.querySelectorAll("metadata");r&&(t.metadata=function(e){for(var t={},r=0;r<e.length;r++){var n=e[r],a=n.getAttribute("name");0<=["Title","Designer","Description","Copyright","LicenseTerms","Rating","CreationDate","ModificationDate"].indexOf(a)&&(t[a]=n.textContent)}return t}(r));var n=e.querySelector("resources");n&&(t.resources=function(e){for(var t={basematerials:{}},r=e.querySelectorAll("basematerials"),n=0;n<r.length;n++){var a=o(r[n]);t.basematerials[a.id]=a}t.texture2d={};var c,f=e.querySelectorAll("texture2d");for(n=0;n<f.length;n++){var d=f[n],p={id:(c=d).getAttribute("id"),path:c.getAttribute("path"),contenttype:c.getAttribute("contenttype"),tilestyleu:c.getAttribute("tilestyleu"),tilestylev:c.getAttribute("tilestylev"),filter:c.getAttribute("filter")};t.texture2d[p.id]=p}t.colorgroup={};var h=e.querySelectorAll("colorgroup");for(n=0;n<h.length;n++){var v=s(h[n]);t.colorgroup[v.id]=v}t.pbmetallicdisplayproperties={};var m=e.querySelectorAll("pbmetallicdisplayproperties");for(n=0;n<m.length;n++){var x=l(m[n]);t.pbmetallicdisplayproperties[x.id]=x}t.texture2dgroup={};var g=e.querySelectorAll("texture2dgroup");for(n=0;n<g.length;n++){var y=i(g[n]);t.texture2dgroup[y.id]=y}t.object={};var E=e.querySelectorAll("object");for(n=0;n<E.length;n++){var w=u(E[n]);t.object[w.id]=w}return t}(n));var a=e.querySelector("build");return a&&(t.build=function(e){for(var t=[],r=e.querySelectorAll("item"),n=0;n<r.length;n++){var a=r[n],o={objectId:a.getAttribute("objectid")},i=a.getAttribute("transform");i&&(o.transform=d(i)),t.push(o)}return t}(a)),t}function h(e,t,n,a){var o=e.texid,i=n.resources.texture2d[o];if(i){var s=a[i.path],l=i.contenttype,c=new Blob([s],{type:l}),f=URL.createObjectURL(c),d=r.load(f,(function(){URL.revokeObjectURL(f)}));switch(d.encoding=THREE.sRGBEncoding,i.tilestyleu){case"wrap":d.wrapS=THREE.RepeatWrapping;break;case"mirror":d.wrapS=THREE.MirroredRepeatWrapping;break;case"none":case"clamp":d.wrapS=THREE.ClampToEdgeWrapping;break;default:d.wrapS=THREE.RepeatWrapping}switch(i.tilestylev){case"wrap":d.wrapT=THREE.RepeatWrapping;break;case"mirror":d.wrapT=THREE.MirroredRepeatWrapping;break;case"none":case"clamp":d.wrapT=THREE.ClampToEdgeWrapping;break;default:d.wrapT=THREE.RepeatWrapping}switch(i.filter){case"auto":d.magFilter=THREE.LinearFilter,d.minFilter=THREE.LinearMipmapLinearFilter;break;case"linear":d.magFilter=THREE.LinearFilter,d.minFilter=THREE.LinearFilter;break;case"nearest":d.magFilter=THREE.NearestFilter,d.minFilter=THREE.NearestFilter;break;default:d.magFilter=THREE.LinearFilter,d.minFilter=THREE.LinearMipmapLinearFilter}return d}return null}function v(e,t,r,n,a,o){for(var i=o.pindex,s={},l=0,c=t.length;l<c;l++){var f=void 0!==(T=t[l]).p1?T.p1:i;void 0===s[f]&&(s[f]=[]),s[f].push(T)}var d=Object.keys(s),u=[];for(l=0,c=d.length;l<c;l++){for(var p=d[l],h=s[p],v=w(e.basematerials[p],R,r,a,o,b),m=new THREE.BufferGeometry,x=[],g=n.vertices,y=0,E=h.length;y<E;y++){var T=h[y];x.push(g[3*T.v1+0]),x.push(g[3*T.v1+1]),x.push(g[3*T.v1+2]),x.push(g[3*T.v2+0]),x.push(g[3*T.v2+1]),x.push(g[3*T.v2+2]),x.push(g[3*T.v3+0]),x.push(g[3*T.v3+1]),x.push(g[3*T.v3+2])}m.setAttribute("position",new THREE.Float32BufferAttribute(x,3));var _=new THREE.Mesh(m,v);u.push(_)}return u}function m(e,t,r,n,a,o){for(var i=new THREE.BufferGeometry,s=[],l=[],c=n.vertices,f=e.uvs,d=0,u=t.length;d<u;d++){var p=t[d];s.push(c[3*p.v1+0]),s.push(c[3*p.v1+1]),s.push(c[3*p.v1+2]),s.push(c[3*p.v2+0]),s.push(c[3*p.v2+1]),s.push(c[3*p.v2+2]),s.push(c[3*p.v3+0]),s.push(c[3*p.v3+1]),s.push(c[3*p.v3+2]),l.push(f[2*p.p1+0]),l.push(f[2*p.p1+1]),l.push(f[2*p.p2+0]),l.push(f[2*p.p2+1]),l.push(f[2*p.p3+0]),l.push(f[2*p.p3+1])}i.setAttribute("position",new THREE.Float32BufferAttribute(s,3)),i.setAttribute("uv",new THREE.Float32BufferAttribute(l,2));var v=w(e,R,r,a,o,h),m=new THREE.MeshPhongMaterial({map:v,flatShading:!0});return new THREE.Mesh(i,m)}function x(e,t,r,n,a){for(var o=new THREE.BufferGeometry,i=[],s=[],l=n.vertices,c=e.colors,f=0,d=t.length;f<d;f++){var u=t[f],p=u.v1,h=u.v2,v=u.v3;i.push(l[3*p+0]),i.push(l[3*p+1]),i.push(l[3*p+2]),i.push(l[3*h+0]),i.push(l[3*h+1]),i.push(l[3*h+2]),i.push(l[3*v+0]),i.push(l[3*v+1]),i.push(l[3*v+2]);var m=void 0!==u.p1?u.p1:a.pindex,x=void 0!==u.p2?u.p2:m,g=void 0!==u.p3?u.p3:m;s.push(c[3*m+0]),s.push(c[3*m+1]),s.push(c[3*m+2]),s.push(c[3*x+0]),s.push(c[3*x+1]),s.push(c[3*x+2]),s.push(c[3*g+0]),s.push(c[3*g+1]),s.push(c[3*g+2])}o.setAttribute("position",new THREE.Float32BufferAttribute(i,3)),o.setAttribute("color",new THREE.Float32BufferAttribute(s,3));var y=new THREE.MeshPhongMaterial({vertexColors:!0,flatShading:!0});return new THREE.Mesh(o,y)}function g(e){var t=new THREE.BufferGeometry;t.setIndex(new THREE.BufferAttribute(e.triangles,1)),t.setAttribute("position",new THREE.BufferAttribute(e.vertices,3));var r=new THREE.MeshPhongMaterial({color:11184895,flatShading:!0});return new THREE.Mesh(t,r)}function y(e,t){return void 0!==t.resources.texture2dgroup[e]?"texture":void 0!==t.resources.basematerials[e]?"material":void 0!==t.resources.colorgroup[e]?"vertexColors":"default"===e?"default":void 0}function E(e,t,r,n,a){for(var o=new THREE.Group,i=function(e,t,r,n,a){for(var o=Object.keys(e),i=[],s=0,l=o.length;s<l;s++){var c=o[s],f=e[c];switch(y(c,t)){case"material":for(var d=v(t.resources.basematerials[c],f,t,r,n,a),u=0,p=d.length;u<p;u++)i.push(d[u]);break;case"texture":var h=t.resources.texture2dgroup[c];i.push(m(h,f,t,r,n,a));break;case"vertexColors":var E=t.resources.colorgroup[c];i.push(x(E,f,0,r,a));break;case"default":i.push(g(r));break;default:console.error("THREE.3MFLoader: Unsupported resource type.")}}return i}(function(e,t,r){for(var n={},a=t.triangleProperties,o=r.pid,i=0,s=a.length;i<s;i++){var l=a[i],c=void 0!==l.pid?l.pid:o;void 0===c&&(c="default"),void 0===n[c]&&(n[c]=[]),n[c].push(l)}return n}(0,e,a),r,e,n,a),s=0,l=i.length;s<l;s++)o.add(i[s]);return o}function w(e,t,r,n,a,o){return void 0!==e.build||(e.build=o(e,t,r,n,a)),e.build}function b(e,t,r){var n,a=e.displaypropertiesid,o=r.resources.pbmetallicdisplayproperties;if(null!==a&&void 0!==o[a]){var i=o[a].data[e.index];n=new THREE.MeshStandardMaterial({flatShading:!0,roughness:i.roughness,metalness:i.metallicness})}else n=new THREE.MeshPhongMaterial({flatShading:!0});n.name=e.name;var s=e.displaycolor,l=s.substring(0,7);return n.color.setStyle(l),n.color.convertSRGBToLinear(),9===s.length&&(n.opacity=parseInt(s.charAt(7)+s.charAt(8),16)/255),n}function T(e,t,r,n){for(var a=new THREE.Group,o=0;o<e.length;o++){var i=e[o],s=t[i.objectId];void 0===s&&(_(i.objectId,t,r,n),s=t[i.objectId]);var l=s.clone(),c=i.transform;c&&l.applyMatrix4(c),a.add(l)}return a}function _(e,r,n,a){var o=n.resources.object[e];if(o.mesh){var i=o.mesh;!function(e,r,n){if(e){for(var a=[],o=Object.keys(e),i=0;i<o.length;i++)for(var s=o[i],l=0;l<t.availableExtensions.length;l++){(c=t.availableExtensions[l]).ns===s&&a.push(c)}for(i=0;i<a.length;i++){var c;(c=a[i]).apply(n,e[c.ns],r)}}}(n.extensions,i,n.xml),r[o.id]=w(i,r,n,a,o,E)}else{var s=o.components;r[o.id]=w(s,r,n,a,o,T)}}var S=function(e){var t,r,o,i,s=null,l=null,c=[],f=[],d=[],u=[],h={},v={};try{s=new n(e)}catch(e){if(e instanceof ReferenceError)return console.error("THREE.3MFLoader: jszip missing and file is compressed."),null}for(l in s.files)l.match(/\_rels\/.rels$/)?t=l:l.match(/3D\/_rels\/.*\.model\.rels$/)?r=l:l.match(/^3D\/.*\.model$/)?c.push(l):l.match(/^3D\/Metadata\/.*\.xml$/)?f.push(l):l.match(/^3D\/Textures?\/.*/)?d.push(l):l.match(/^3D\/Other\/.*/)&&u.push(l);var m=new Uint8Array(s.file(t).asArrayBuffer());if(o=a(THREE.LoaderUtils.decodeText(m)),r){m=new Uint8Array(s.file(r).asArrayBuffer());i=a(THREE.LoaderUtils.decodeText(m))}for(var x=0;x<c.length;x++){var g=c[x],y=new Uint8Array(s.file(g).asArrayBuffer()),E=THREE.LoaderUtils.decodeText(y),w=(new DOMParser).parseFromString(E,"application/xml");"model"!==w.documentElement.nodeName.toLowerCase()&&console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ",g);var b=w.querySelector("model"),T={};for(x=0;x<b.attributes.length;x++){var _=b.attributes[x];_.name.match(/^xmlns:(.+)$/)&&(T[_.value]=RegExp.$1)}var S=p(b);S.xml=b,0<Object.keys(T).length&&(S.extensions=T),h[g]=S}for(x=0;x<d.length;x++){var R=d[x];v[R]=s.file(R).asArrayBuffer()}return{rels:o,modelRels:i,model:h,printTicket:{},texture:v,other:{}}}(e),R=function(e){var t=e.model,r=e.modelRels,n={},a=Object.keys(t),o={};if(r)for(var i=0,s=r.length;i<s;i++){var l=r[i],c=l.target.substring(1);e.texture[c]&&(o[l.target]=e.texture[c])}for(i=0;i<a.length;i++)for(var f=t[a[i]],d=Object.keys(f.resources.object),u=0;u<d.length;u++){_(d[u],n,f,o)}return n}(S);return function(e,t){for(var r=new THREE.Group,n=t.rels[0],a=t.model[n.target.substring(1)].build,o=0;o<a.length;o++){var i=a[o],s=e[i.objectId],l=i.transform;l&&s.applyMatrix4(l),r.add(s)}return r}(R,S)},addExtension:function(e){this.availableExtensions.push(e)}}),THREE.ThreeMFLoader.MaterialsAndPropertiesExtension={ns:"http://schemas.microsoft.com/3dmanufacturing/material/2015/02",apply:function(e,t,r){for(var n=e.querySelectorAll("colorgroup"),a=0;a<n.length;a++){var o=n[a];if(o.prefix===t){for(var i=o.getAttribute("id"),s=o.querySelectorAll("color"),l=[],c=0;c<s.length;c++){var f=s[c].getAttribute("color");f.match(/#[0-9a-fA-F]{8}/)?l.push(new THREE.Color(f.substring(0,7))):l.push(new THREE.Color(f))}for(var d=[],u=0;u<r.triangleProperties.length;u++){var p=r.triangleProperties[u];if(p.pid===i){var h=l[p.p1],v=l[p.p2||p.p1],m=l[p.p3||p.p1];d.push(h.r,h.g,h.b),d.push(v.r,v.g,v.b),d.push(m.r,m.g,m.b)}}r.colors=new Float32Array(d.length);for(var x=0;x<d.length;x++)r.colors[x]=d[x]}}}}},function(e,t,r){"use strict";r.r(t);var n=r(1),a=r.n(n);THREE.VRMLLoader=function(){if(void 0===a.a)throw Error("THREE.VRMLLoader: External library chevrotain.min.js required.");function e(e){THREE.Loader.call(this,e)}function t(e){this.lexer=new a.a.Lexer(e)}function r(e){a.a.Parser.call(this,e);var t=this,r=e.Version,n=e.LCurly,o=e.RCurly,i=e.LSquare,s=e.RSquare,l=e.Identifier,c=e.RouteIdentifier,f=e.StringLiteral,d=e.HexLiteral,u=e.NumberLiteral,p=e.TrueLiteral,h=e.FalseLiteral,v=e.NullLiteral,m=e.DEF,x=e.USE,g=e.ROUTE,y=e.TO,E=e.NodeName;t.RULE("vrml",(function(){t.SUBRULE(t.version),t.AT_LEAST_ONE((function(){t.SUBRULE(t.node)})),t.MANY((function(){t.SUBRULE(t.route)}))})),t.RULE("version",(function(){t.CONSUME(r)})),t.RULE("node",(function(){t.OPTION((function(){t.SUBRULE(t.def)})),t.CONSUME(E),t.CONSUME(n),t.MANY((function(){t.SUBRULE(t.field)})),t.CONSUME(o)})),t.RULE("field",(function(){t.CONSUME(l),t.OR2([{ALT:function(){t.SUBRULE(t.singleFieldValue)}},{ALT:function(){t.SUBRULE(t.multiFieldValue)}}])})),t.RULE("def",(function(){t.CONSUME(m),t.OR([{ALT:function(){t.CONSUME(l)}},{ALT:function(){t.CONSUME(E)}}])})),t.RULE("use",(function(){t.CONSUME(x),t.OR([{ALT:function(){t.CONSUME(l)}},{ALT:function(){t.CONSUME(E)}}])})),t.RULE("singleFieldValue",(function(){t.AT_LEAST_ONE((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(d)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(p)}},{ALT:function(){t.CONSUME(h)}},{ALT:function(){t.CONSUME(v)}}])}))})),t.RULE("multiFieldValue",(function(){t.CONSUME(i),t.MANY((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(d)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(v)}}])})),t.CONSUME(s)})),t.RULE("route",(function(){t.CONSUME(g),t.CONSUME(c),t.CONSUME(y),t.CONSUME2(c)})),this.performSelfAnalysis()}function n(e,t,r){this.a=e,this.b=t,this.c=r,this.normal=new THREE.Vector3}e.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:e,load:function(e,t,r,n){var a=this,o=""===a.path?THREE.LoaderUtils.extractUrlBase(e):a.path,i=new THREE.FileLoader(a.manager);i.setPath(a.path),i.setRequestHeader(a.requestHeader),i.load(e,(function(r){try{t(a.parse(r,o))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e,i){var s={};function l(e){e.DEF&&(s[e.DEF]=e);for(var t=e.fields,r=0,n=t.length;r<n;r++){var a=t[r];if("node"===a.type)for(var o=a.values,i=0,c=o.length;i<c;i++)l(o[i])}}function c(e){return e.USE?(t=e.USE,(r=c(s[t])).isObject3D||r.isMaterial?r.clone():r):(void 0!==e.build||(e.build=function(e){var t,r=e.name;switch(r){case"Group":case"Transform":case"Collision":t=function(e){for(var t=new THREE.Group,r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"bboxCenter":case"bboxSize":case"center":break;case"children":u(s,t);break;case"collide":break;case"rotation":var l=new THREE.Vector3(s[0],s[1],s[2]),c=s[3];t.quaternion.setFromAxisAngle(l,c);break;case"scale":t.scale.set(s[0],s[1],s[2]);break;case"scaleOrientation":break;case"translation":t.position.set(s[0],s[1],s[2]);break;case"proxy":break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return t}(e);break;case"Background":t=function(e){for(var t,r,n,a,o=new THREE.Group,i=e.fields,s=0,l=i.length;s<l;s++){var c=i[s],f=c.name,d=c.values;switch(f){case"groundAngle":t=d;break;case"groundColor":r=d;break;case"backUrl":case"bottomUrl":case"frontUrl":case"leftUrl":case"rightUrl":case"topUrl":break;case"skyAngle":n=d;break;case"skyColor":a=d;break;default:console.warn("THREE.VRMLLoader: Unknown field:",f)}}if(a){var u=new THREE.SphereBufferGeometry(1e4,32,16),p=new THREE.MeshBasicMaterial({fog:!1,side:THREE.BackSide,depthWrite:!1,depthTest:!1});a.length>3?(z(u,1e4,n,P(a),!0),p.vertexColors=!0):p.color.setRGB(a[0],a[1],a[2]);var h=new THREE.Mesh(u,p);o.add(h)}if(r&&r.length>0){var v=new THREE.SphereBufferGeometry(1e4,32,16,0,2*Math.PI,.5*Math.PI,1.5*Math.PI),m=new THREE.MeshBasicMaterial({fog:!1,side:THREE.BackSide,vertexColors:!0,depthWrite:!1,depthTest:!1});z(v,1e4,t,P(r),!1);var x=new THREE.Mesh(v,m);o.add(x)}return o.renderOrder=-1/0,o}(e);break;case"Shape":t=function(e){for(var t,r,n=e.fields,a=new THREE.MeshBasicMaterial({color:0}),o=0,i=n.length;o<i;o++){var s=n[o],l=s.name,f=s.values;switch(l){case"appearance":null!==f[0]&&(a=c(f[0]));break;case"geometry":null!==f[0]&&(t=c(f[0]));break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}if(t&&t.attributes.position){var d=t._type;if("points"===d){var u=new THREE.PointsMaterial({color:16777215});void 0!==t.attributes.color?u.vertexColors=!0:a.isMeshPhongMaterial&&u.color.copy(a.emissive),r=new THREE.Points(t,u)}else if("line"===d){var p=new THREE.LineBasicMaterial({color:16777215});void 0!==t.attributes.color?p.vertexColors=!0:a.isMeshPhongMaterial&&p.color.copy(a.emissive),r=new THREE.LineSegments(t,p)}else void 0!==t._solid&&(a.side=t._solid?THREE.FrontSide:THREE.DoubleSide),void 0!==t.attributes.color&&(a.vertexColors=!0),r=new THREE.Mesh(t,a)}else(r=new THREE.Object3D).visible=!1;return r}(e);break;case"Appearance":t=function(e){for(var t,r=new THREE.MeshPhongMaterial,n=e.fields,a=0,i=n.length;a<i;a++){var s=n[a],l=s.name,f=s.values;switch(l){case"material":if(null!==f[0]){var d=c(f[0]);d.diffuseColor&&r.color.copy(d.diffuseColor),d.emissiveColor&&r.emissive.copy(d.emissiveColor),d.shininess&&(r.shininess=d.shininess),d.specularColor&&r.specular.copy(d.specularColor),d.transparency&&(r.opacity=1-d.transparency),d.transparency>0&&(r.transparent=!0)}else r=new THREE.MeshBasicMaterial({color:0});break;case"texture":var u=f[0];null!==u&&("ImageTexture"!==u.name&&"PixelTexture"!==u.name||(r.map=c(u)));break;case"textureTransform":null!==f[0]&&(t=c(f[0]));break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}if(r.map){if(r.map.__type){switch(r.map.__type){case o.INTENSITY_ALPHA:r.opacity=1;break;case o.RGB:r.color.set(16777215);break;case o.RGBA:r.color.set(16777215),r.opacity=1}delete r.map.__type}t&&(r.map.center.copy(t.center),r.map.rotation=t.rotation,r.map.repeat.copy(t.scale),r.map.offset.copy(t.translation))}return r}(e);break;case"Material":t=function(e){for(var t={},r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"ambientIntensity":break;case"diffuseColor":t.diffuseColor=new THREE.Color(s[0],s[1],s[2]);break;case"emissiveColor":t.emissiveColor=new THREE.Color(s[0],s[1],s[2]);break;case"shininess":t.shininess=s[0];break;case"specularColor":t.emissiveColor=new THREE.Color(s[0],s[1],s[2]);break;case"transparency":t.transparency=s[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return t}(e);break;case"ImageTexture":t=function(e){for(var t,r=THREE.RepeatWrapping,n=THREE.RepeatWrapping,a=e.fields,o=0,i=a.length;o<i;o++){var s=a[o],l=s.name,c=s.values;switch(l){case"url":var f=c[0];f&&(t=k.load(f));break;case"repeatS":!1===c[0]&&(r=THREE.ClampToEdgeWrapping);break;case"repeatT":!1===c[0]&&(n=THREE.ClampToEdgeWrapping);break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}t&&(t.wrapS=r,t.wrapT=n);return t}(e);break;case"PixelTexture":t=function(e){for(var t,r=THREE.RepeatWrapping,n=THREE.RepeatWrapping,a=e.fields,o=0,i=a.length;o<i;o++){var s=a[o],l=s.name,c=s.values;switch(l){case"image":for(var u=c[0],p=c[1],h=c[2],v=2===h||4===h,m=d(h),x=new Uint8Array(u*p*(!0===v?4:3)),g={r:0,g:0,b:0,a:0},y=3,E=0,w=c.length;y<w;y++,E++){var b;if(f(c[y],m,g),!0===v)x[(b=4*E)+0]=g.r,x[b+1]=g.g,x[b+2]=g.b,x[b+3]=g.a;else x[(b=3*E)+0]=g.r,x[b+1]=g.g,x[b+2]=g.b}(t=new THREE.DataTexture(x,u,p,!0===v?THREE.RGBAFormat:THREE.RGBFormat)).__type=m;break;case"repeatS":!1===c[0]&&(r=THREE.ClampToEdgeWrapping);break;case"repeatT":!1===c[0]&&(n=THREE.ClampToEdgeWrapping);break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}t&&(t.wrapS=r,t.wrapT=n);return t}(e);break;case"TextureTransform":t=function(e){for(var t={center:new THREE.Vector2,rotation:new THREE.Vector2,scale:new THREE.Vector2,translation:new THREE.Vector2},r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"center":t.center.set(s[0],s[1]);break;case"rotation":t.rotation=s[0];break;case"scale":t.scale.set(s[0],s[1]);break;case"translation":t.translation.set(s[0],s[1]);break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return t}(e);break;case"IndexedFaceSet":t=function(e){for(var t,r,n,a,o,i,s,l,f=!0,d=!0,u=0,m=!0,x=!0,g=e.fields,y=0,E=g.length;y<E;y++){var w=g[y],b=w.name,T=w.values;switch(b){case"color":var R=T[0];null!==R&&(t=c(R));break;case"coord":var M=T[0];null!==M&&(r=c(M));break;case"normal":var C=T[0];null!==C&&(n=c(C));break;case"texCoord":var H=T[0];null!==H&&(a=c(H));break;case"ccw":f=T[0];break;case"colorIndex":o=T;break;case"colorPerVertex":m=T[0];break;case"convex":break;case"coordIndex":i=T;break;case"creaseAngle":u=T[0];break;case"normalIndex":s=T;break;case"normalPerVertex":x=T[0];break;case"solid":d=T[0];break;case"texCoordIndex":l=T;break;default:console.warn("THREE.VRMLLoader: Unknown field:",b)}}if(void 0===i)return console.warn("THREE.VRMLLoader: Missing coordIndex."),new THREE.BufferGeometry;var P,z,k,N,D=p(i,f);if(t)if(!0===m)if(o&&o.length>0){var F=p(o,f);z=_(D,F,t,3)}else z=A(D,new THREE.Float32BufferAttribute(t,3));else if(o&&o.length>0){var I=h(v(t,o),i);z=S(D,I)}else{I=h(t,i);z=S(D,I)}if(n)if(!0===x)if(s&&s.length>0){var O=p(s,f);k=_(D,O,n,3)}else k=A(D,new THREE.Float32BufferAttribute(n,3));else if(s&&s.length>0){var U=h(v(n,s),i);k=S(D,U)}else{U=h(n,i);k=S(D,U)}else k=L(D,r,u);if(a)if(l&&l.length>0){var G=p(l,f);N=_(D,G,a,2)}else N=A(D,new THREE.Float32BufferAttribute(a,2));var B=new THREE.BufferGeometry;P=A(D,new THREE.Float32BufferAttribute(r,3)),B.setAttribute("position",P),B.setAttribute("normal",k),z&&B.setAttribute("color",z);N&&B.setAttribute("uv",N);return B._solid=d,B._type="mesh",B}(e);break;case"IndexedLineSet":t=function(e){for(var t,r,n,a,o,i=!0,s=e.fields,l=0,f=s.length;l<f;l++){var d=s[l],u=d.name,p=d.values;switch(u){case"color":var h=p[0];null!==h&&(t=c(h));break;case"coord":var g=p[0];null!==g&&(r=c(g));break;case"colorIndex":n=p;break;case"colorPerVertex":i=p[0];break;case"coordIndex":a=p;break;default:console.warn("THREE.VRMLLoader: Unknown field:",u)}}var y=m(a);if(t)if(!0===i)if(n.length>0){var E=m(n);o=_(y,E,t,3)}else o=A(y,new THREE.Float32BufferAttribute(t,3));else if(n.length>0){var w=x(v(t,n),a);o=R(y,w)}else{w=x(t,a);o=R(y,w)}var b=new THREE.BufferGeometry,T=A(y,new THREE.Float32BufferAttribute(r,3));b.setAttribute("position",T),o&&b.setAttribute("color",o);return b._type="line",b}(e);break;case"PointSet":t=function(e){for(var t,r,n=e.fields,a=0,o=n.length;a<o;a++){var i=n[a],s=i.name,l=i.values;switch(s){case"color":var f=l[0];null!==f&&(t=c(f));break;case"coord":var d=l[0];null!==d&&(r=c(d));break;default:console.warn("THREE.VRMLLoader: Unknown field:",s)}}var u;(u=new THREE.BufferGeometry).setAttribute("position",new THREE.Float32BufferAttribute(r,3)),t&&u.setAttribute("color",new THREE.Float32BufferAttribute(t,3));return u._type="points",u}(e);break;case"Box":t=function(e){for(var t=new THREE.Vector3(2,2,2),r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"size":t.x=s[0],t.y=s[1],t.z=s[2];break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return new THREE.BoxBufferGeometry(t.x,t.y,t.z)}(e);break;case"Cone":t=function(e){for(var t=1,r=2,n=!1,a=e.fields,o=0,i=a.length;o<i;o++){var s=a[o],l=s.name,c=s.values;switch(l){case"bottom":n=!c[0];break;case"bottomRadius":t=c[0];break;case"height":r=c[0];break;case"side":break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}return new THREE.ConeBufferGeometry(t,r,16,1,n)}(e);break;case"Cylinder":t=function(e){for(var t=1,r=2,n=e.fields,a=0,o=n.length;a<o;a++){var i=n[a],s=i.name,l=i.values;switch(s){case"bottom":break;case"radius":t=l[0];break;case"height":r=l[0];break;case"side":case"top":break;default:console.warn("THREE.VRMLLoader: Unknown field:",s)}}return new THREE.CylinderBufferGeometry(t,t,r,16,1)}(e);break;case"Sphere":t=function(e){for(var t=1,r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"radius":t=s[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return new THREE.SphereBufferGeometry(t,16,16)}(e);break;case"ElevationGrid":t=function(e){for(var t,r,n,a,o=!0,i=!0,s=!0,l=!0,f=0,d=2,u=2,p=1,h=1,v=e.fields,m=0,x=v.length;m<x;m++){var g=v[m],y=g.name,E=g.values;switch(y){case"color":var w=E[0];null!==w&&(t=c(w));break;case"normal":var b=E[0];null!==b&&(r=c(b));break;case"texCoord":var T=E[0];null!==T&&(n=c(T));break;case"height":a=E;break;case"ccw":l=E[0];break;case"colorPerVertex":o=E[0];break;case"creaseAngle":f=E[0];break;case"normalPerVertex":i=E[0];break;case"solid":s=E[0];break;case"xDimension":d=E[0];break;case"xSpacing":p=E[0];break;case"zDimension":u=E[0];break;case"zSpacing":h=E[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",y)}}var _=[],S=[],R=[],M=[];for(m=0;m<u;m++)for(var C=0;C<d;C++){var H=p*m,P=a[Q=m*d+C],z=h*C;if(_.push(H,P,z),t&&!0===o){var k=t[3*Q+0],N=t[3*Q+1],D=t[3*Q+2];R.push(k,N,D)}if(r&&!0===i){var F=r[3*Q+0],I=r[3*Q+1],O=r[3*Q+2];S.push(F,I,O)}if(n){var U=n[2*Q+0],G=n[2*Q+1];M.push(U,G)}else M.push(m/(d-1),C/(u-1))}var B=[];for(m=0;m<d-1;m++)for(C=0;C<u-1;C++){var V=m+C*d,j=(D=m+(C+1)*d,m+1+(C+1)*d),W=m+1+C*d;!0===l?(B.push(V,j,D),B.push(j,V,W)):(B.push(V,D,j),B.push(j,W,V))}var q,X,Y=A(B,new THREE.Float32BufferAttribute(_,3)),Z=A(B,new THREE.Float32BufferAttribute(M,2));if(t)if(!1===o){for(m=0;m<d-1;m++)for(C=0;C<u-1;C++){k=t[3*(Q=m+C*(d-1))+0],N=t[3*Q+1],D=t[3*Q+2];R.push(k,N,D),R.push(k,N,D),R.push(k,N,D),R.push(k,N,D),R.push(k,N,D),R.push(k,N,D)}q=new THREE.Float32BufferAttribute(R,3)}else q=A(B,new THREE.Float32BufferAttribute(R,3));if(r)if(!1===i){for(m=0;m<d-1;m++)for(C=0;C<u-1;C++){var Q;F=r[3*(Q=m+C*(d-1))+0],I=r[3*Q+1],O=r[3*Q+2];S.push(F,I,O),S.push(F,I,O),S.push(F,I,O),S.push(F,I,O),S.push(F,I,O),S.push(F,I,O)}X=new THREE.Float32BufferAttribute(S,3)}else X=A(B,new THREE.Float32BufferAttribute(S,3));else X=L(B,_,f);var K=new THREE.BufferGeometry;K.setAttribute("position",Y),K.setAttribute("normal",X),K.setAttribute("uv",Z),q&&K.setAttribute("color",q);return K._solid=s,K._type="mesh",K}(e);break;case"Extrusion":t=function(e){for(var t,r,n=[1,1,1,-1,-1,-1,-1,1,1,1],a=[0,0,0,0,1,0],o=!0,i=!0,s=0,l=!0,c=!0,f=e.fields,d=0,u=f.length;d<u;d++){var p=f[d],h=p.name,v=p.values;switch(h){case"beginCap":o=v[0];break;case"ccw":i=v[0];break;case"convex":break;case"creaseAngle":s=v[0];break;case"crossSection":n=v;break;case"endCap":l=v[0];break;case"orientation":r=v;break;case"scale":t=v;break;case"solid":c=v[0];break;case"spine":a=v;break;default:console.warn("THREE.VRMLLoader: Unknown field:",h)}}for(var m=n[0]===n[n.length-2]&&n[1]===n[n.length-1],x=[],g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Vector3,w=new THREE.Vector3,b=new THREE.Quaternion,T=(d=0,0),_=0,S=a.length;d<S;d+=3,T+=2,_+=4){g.fromArray(a,d),y.x=t?t[T+0]:1,y.y=1,y.z=t?t[T+1]:1,E.x=r?r[_+0]:0,E.y=r?r[_+1]:0,E.z=r?r[_+2]:1;for(var R=r?r[_+3]:0,M=0,C=n.length;M<C;M+=2)w.x=n[M+0],w.y=0,w.z=n[M+1],w.multiply(y),b.setFromAxisAngle(E,R),w.applyQuaternion(b),w.add(g),x.push(w.x,w.y,w.z)}var H=[],P=a.length/3,z=n.length/2;for(d=0;d<P-1;d++)for(T=0;T<z-1;T++){var k=T+d*z,N=T+1+d*z,D=T+(d+1)*z,F=T+1+(d+1)*z;T===z-2&&!0===m&&(N=d*z,F=(d+1)*z),!0===i?(H.push(k,N,D),H.push(D,N,F)):(H.push(k,D,N),H.push(D,F,N))}if(!0===o||!0===l){var I=[];for(d=0,u=n.length;d<u;d+=2)I.push(new THREE.Vector2(n[d],n[d+1]));var O=THREE.ShapeUtils.triangulateShape(I,[]),U=[];for(d=0,u=O.length;d<u;d++){var G=O[d];U.push(G[0],G[1],G[2])}if(!0===o)for(d=0,u=U.length;d<u;d+=3)!0===i?H.push(U[d+0],U[d+1],U[d+2]):H.push(U[d+0],U[d+2],U[d+1]);if(!0===l){var B=z*(P-1);for(d=0,u=U.length;d<u;d+=3)!0===i?H.push(B+U[d+0],B+U[d+2],B+U[d+1]):H.push(B+U[d+0],B+U[d+1],B+U[d+2])}}var V=A(H,new THREE.Float32BufferAttribute(x,3)),j=L(H,x,s),W=new THREE.BufferGeometry;return W.setAttribute("position",V),W.setAttribute("normal",j),W._solid=c,W._type="mesh",W}(e);break;case"Color":case"Coordinate":case"Normal":case"TextureCoordinate":t=function(e){return e.fields[0].values}(e);break;case"WorldInfo":t=function(e){for(var t={},r=e.fields,n=0,a=r.length;n<a;n++){var o=r[n],i=o.name,s=o.values;switch(i){case"title":t.title=s[0];break;case"info":t.info=s;break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return t}(e);break;case"Anchor":case"Billboard":case"Inline":case"LOD":case"Switch":case"AudioClip":case"DirectionalLight":case"PointLight":case"Script":case"Sound":case"SpotLight":case"CylinderSensor":case"PlaneSensor":case"ProximitySensor":case"SphereSensor":case"TimeSensor":case"TouchSensor":case"VisibilitySensor":case"Text":case"FontStyle":case"MovieTexture":case"ColorInterpolator":case"CoordinateInterpolator":case"NormalInterpolator":case"OrientationInterpolator":case"PositionInterpolator":case"ScalarInterpolator":case"Fog":case"NavigationInfo":case"Viewpoint":break;default:console.warn("THREE.VRMLLoader: Unknown node:",r)}return t}(e)),e.build);var t,r}function f(e,t,r){switch(t){case o.INTENSITY:var n=parseInt(e);r.r=n,r.g=n,r.b=n;break;case o.INTENSITY_ALPHA:n=parseInt("0x"+e.substring(2,4));r.r=n,r.g=n,r.b=n,r.a=parseInt("0x"+e.substring(4,6));break;case o.RGB:r.r=parseInt("0x"+e.substring(2,4)),r.g=parseInt("0x"+e.substring(4,6)),r.b=parseInt("0x"+e.substring(6,8));break;case o.RGBA:r.r=parseInt("0x"+e.substring(2,4)),r.g=parseInt("0x"+e.substring(4,6)),r.b=parseInt("0x"+e.substring(6,8)),r.a=parseInt("0x"+e.substring(8,10))}}function d(e){var t;switch(e){case 1:t=o.INTENSITY;break;case 2:t=o.INTENSITY_ALPHA;break;case 3:t=o.RGB;break;case 4:t=o.RGBA}return t}function u(e,t){for(var r=0,n=e.length;r<n;r++){var a=c(e[r]);a instanceof THREE.Object3D&&t.add(a)}}function p(e,t){for(var r=[],n=0,a=0,o=e.length;a<o;a++){var i=e[n],s=e[a+(t?1:2)],l=e[a+(t?2:1)];r.push(i,s,l),(-1===e[a+3]||a+3>=o)&&(n=(a+=3)+1)}return r}function h(e,t){for(var r=[],n=0,a=0,o=t.length;a<o;a++){var i=3*n,s=e[i],l=e[i+1],c=e[i+2];r.push(s,l,c),(-1===t[a+3]||a+3>=o)&&(a+=3,n++)}return r}function v(e,t){for(var r=[],n=0,a=t.length;n<a;n++){var o=3*t[n],i=e[o],s=e[o+1],l=e[o+2];r.push(i,s,l)}return r}function m(e){for(var t=[],r=0,n=e.length;r<n;r++){var a=e[r],o=e[r+1];t.push(a,o),(-1===e[r+2]||r+2>=n)&&(r+=2)}return t}function x(e,t){for(var r=[],n=0,a=0,o=t.length;a<o;a++){var i=3*n,s=e[i],l=e[i+1],c=e[i+2];r.push(s,l,c),(-1===t[a+2]||a+2>=o)&&(a+=2,n++)}return r}var g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Vector3,w=new THREE.Vector2,b=new THREE.Vector2,T=new THREE.Vector2;function _(e,t,r,n){for(var a=[],o=0,i=e.length;o<i;o+=3){var s=t[o],l=t[o+1],c=t[o+2];2===n?(w.fromArray(r,s*n),b.fromArray(r,l*n),T.fromArray(r,c*n),a.push(w.x,w.y),a.push(b.x,b.y),a.push(T.x,T.y)):(g.fromArray(r,s*n),y.fromArray(r,l*n),E.fromArray(r,c*n),a.push(g.x,g.y,g.z),a.push(y.x,y.y,y.z),a.push(E.x,E.y,E.z))}return new THREE.Float32BufferAttribute(a,n)}function S(e,t){for(var r=[],n=0,a=0,o=e.length;n<o;n+=3,a++)g.fromArray(t,3*a),r.push(g.x,g.y,g.z),r.push(g.x,g.y,g.z),r.push(g.x,g.y,g.z);return new THREE.Float32BufferAttribute(r,3)}function R(e,t){for(var r=[],n=0,a=0,o=e.length;n<o;n+=2,a++)g.fromArray(t,3*a),r.push(g.x,g.y,g.z),r.push(g.x,g.y,g.z);return new THREE.Float32BufferAttribute(r,3)}function A(e,t){for(var r=t.array,n=t.itemSize,a=new r.constructor(e.length*n),o=0,i=0,s=0,l=e.length;s<l;s++){o=e[s]*n;for(var c=0;c<n;c++)a[i++]=r[o++]}return new THREE.Float32BufferAttribute(a,n)}var M=new THREE.Vector3,C=new THREE.Vector3;function L(e,t,r){for(var a=[],o={},i=0,s=e.length;i<s;i+=3){var l=e[i],c=e[i+1],f=e[i+2],d=new n(l,c,f);g.fromArray(t,3*l),y.fromArray(t,3*c),E.fromArray(t,3*f),C.subVectors(E,y),M.subVectors(g,y),C.cross(M),C.normalize(),d.normal.copy(C),void 0===o[l]&&(o[l]=[]),void 0===o[c]&&(o[c]=[]),void 0===o[f]&&(o[f]=[]),o[l].push(d.normal),o[c].push(d.normal),o[f].push(d.normal),a.push(d)}var u=[];for(i=0,s=a.length;i<s;i++){var p=H(o[(d=a[i]).a],d.normal,r),h=H(o[d.b],d.normal,r),v=H(o[d.c],d.normal,r);g.fromArray(t,3*d.a),y.fromArray(t,3*d.b),E.fromArray(t,3*d.c),u.push(p.x,p.y,p.z),u.push(h.x,h.y,h.z),u.push(v.x,v.y,v.z)}return new THREE.Float32BufferAttribute(u,3)}function H(e,t,r){var n=new THREE.Vector3;if(0===r)n.copy(t);else for(var a=0,o=e.length;a<o;a++)e[a].angleTo(t)<r&&n.add(e[a]);return n.normalize()}function P(e){for(var t=[],r=0,n=e.length;r<n;r+=3)t.push(new THREE.Color(e[r],e[r+1],e[r+2]));return t}function z(e,t,r,n,a){for(var o=[],i=!0===a?0:Math.PI,s=0,l=n.length;s<l;s++){var c=0===s?0:r[s-1];c=!0===a?c:i-c;var f=new THREE.Vector3;f.setFromSphericalCoords(t,c,0),o.push(f)}var d=e.index,u=e.attributes.position,p=new THREE.BufferAttribute(new Float32Array(3*e.attributes.position.count),3),h=new THREE.Vector3,v=new THREE.Color;for(s=0;s<d.count;s++){var m,x,g=d.getX(s);h.fromBufferAttribute(u,g);for(var y=1,E=1;E<o.length;E++){x=E;var w=o[m=E-1],b=o[x];if(!0===a){if(h.y<=w.y&&h.y>b.y){y=Math.abs(w.y-h.y)/Math.abs(w.y-b.y);break}}else if(h.y>=w.y&&h.y<b.y){y=Math.abs(w.y-h.y)/Math.abs(w.y-b.y);break}}var T=n[m],_=n[x];v.copy(T).lerp(_,y),p.setXYZ(g,v.r,v.g,v.b)}e.setAttribute("color",p)}var k=new THREE.TextureLoader(this.manager);if(k.setPath(this.resourcePath||i).setCrossOrigin(this.crossOrigin),-1===e.indexOf("#VRML V2.0"))throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");return function(e){for(var t=e.nodes,r=new THREE.Scene,n=0,a=t.length;n<a;n++){l(o=t[n])}for(n=0,a=t.length;n<a;n++){var o,i=c(o=t[n]);i instanceof THREE.Object3D&&r.add(i),"WorldInfo"===o.name&&(r.userData.worldInfo=i)}return r}(function(e){var n=function(){for(var e=a.a.createToken,t=e({name:"RouteIdentifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/}),r=e({name:"Identifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,longer_alt:t}),n=e({name:"Version",pattern:/#VRML.*/,longer_alt:r}),o=e({name:"NodeName",pattern:new RegExp(["Anchor","Billboard","Collision","Group","Transform","Inline","LOD","Switch","AudioClip","DirectionalLight","PointLight","Script","Shape","Sound","SpotLight","WorldInfo","CylinderSensor","PlaneSensor","ProximitySensor","SphereSensor","TimeSensor","TouchSensor","VisibilitySensor","Box","Cone","Cylinder","ElevationGrid","Extrusion","IndexedFaceSet","IndexedLineSet","PointSet","Sphere","Color","Coordinate","Normal","TextureCoordinate","Appearance","FontStyle","ImageTexture","Material","MovieTexture","PixelTexture","TextureTransform","ColorInterpolator","CoordinateInterpolator","NormalInterpolator","OrientationInterpolator","PositionInterpolator","ScalarInterpolator","Background","Fog","NavigationInfo","Viewpoint","Text"].join("|")),longer_alt:r}),i=e({name:"DEF",pattern:/DEF/,longer_alt:r}),s=e({name:"USE",pattern:/USE/,longer_alt:r}),l=e({name:"ROUTE",pattern:/ROUTE/,longer_alt:r}),c=e({name:"TO",pattern:/TO/,longer_alt:r}),f=e({name:"StringLiteral",pattern:/"(:?[^\\"\n\r]+|\\(:?[bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/}),d=e({name:"HexLiteral",pattern:/0[xX][0-9a-fA-F]+/}),u=e({name:"NumberLiteral",pattern:/[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/}),p=e({name:"TrueLiteral",pattern:/TRUE/}),h=e({name:"FalseLiteral",pattern:/FALSE/}),v=e({name:"NullLiteral",pattern:/NULL/}),m=e({name:"LSquare",pattern:/\[/}),x=e({name:"RSquare",pattern:/]/}),g=e({name:"LCurly",pattern:/{/}),y=e({name:"RCurly",pattern:/}/}),E=e({name:"Comment",pattern:/#.*/,group:a.a.Lexer.SKIPPED}),w=[e({name:"WhiteSpace",pattern:/[ ,\s]/,group:a.a.Lexer.SKIPPED}),o,i,s,l,c,p,h,v,n,r,t,f,d,u,m,x,g,y,E],b={},T=0,_=w.length;T<_;T++){var S=w[T];b[S.name]=S}return{tokens:w,tokenVocabulary:b}}(),o=new t(n.tokens),i=new r(n.tokenVocabulary),s=function(e){function t(){e.call(this),this.validateVisitor()}function r(e,t){var r={type:null,values:[]};if(t.node){r.type="node";for(var n=0,a=t.node.length;n<a;n++){var o=t.node[n];r.values.push(e.visit(o))}}if(t.use){r.type="use";for(n=0,a=t.use.length;n<a;n++){var i=t.use[n];r.values.push(e.visit(i))}}if(t.StringLiteral){r.type="string";for(n=0,a=t.StringLiteral.length;n<a;n++){var s=t.StringLiteral[n];r.values.push(s.image.replace(/'|"/g,""))}}if(t.NumberLiteral){r.type="number";for(n=0,a=t.NumberLiteral.length;n<a;n++){var l=t.NumberLiteral[n];r.values.push(parseFloat(l.image))}}if(t.HexLiteral){r.type="hex";for(n=0,a=t.HexLiteral.length;n<a;n++){var c=t.HexLiteral[n];r.values.push(c.image)}}if(t.TrueLiteral){r.type="boolean";for(n=0,a=t.TrueLiteral.length;n<a;n++){"TRUE"===t.TrueLiteral[n].image&&r.values.push(!0)}}if(t.FalseLiteral){r.type="boolean";for(n=0,a=t.FalseLiteral.length;n<a;n++){"FALSE"===t.FalseLiteral[n].image&&r.values.push(!1)}}return t.NullLiteral&&(r.type="null",t.NullLiteral.forEach((function(){r.values.push(null)}))),r}return t.prototype=Object.assign(Object.create(e.prototype),{constructor:t,vrml:function(e){for(var t={version:this.visit(e.version),nodes:[],routes:[]},r=0,n=e.node.length;r<n;r++){var a=e.node[r];t.nodes.push(this.visit(a))}if(e.route)for(r=0,n=e.route.length;r<n;r++){var o=e.route[r];t.routes.push(this.visit(o))}return t},version:function(e){return e.Version[0].image},node:function(e){var t={name:e.NodeName[0].image,fields:[]};if(e.field)for(var r=0,n=e.field.length;r<n;r++){var a=e.field[r];t.fields.push(this.visit(a))}return e.def&&(t.DEF=this.visit(e.def[0])),t},field:function(e){var t,r={name:e.Identifier[0].image,type:null,values:null};return e.singleFieldValue&&(t=this.visit(e.singleFieldValue[0])),e.multiFieldValue&&(t=this.visit(e.multiFieldValue[0])),r.type=t.type,r.values=t.values,r},def:function(e){return(e.Identifier||e.NodeName)[0].image},use:function(e){return{USE:(e.Identifier||e.NodeName)[0].image}},singleFieldValue:function(e){return r(this,e)},multiFieldValue:function(e){return r(this,e)},route:function(e){return{FROM:e.RouteIdentifier[0].image,TO:e.RouteIdentifier[1].image}}}),new t}(i.getBaseCstVisitorConstructor()),l=o.lex(e);i.input=l.tokens;var c=i.vrml();if(i.errors.length>0)throw console.error(i.errors),Error("THREE.VRMLLoader: Parsing errors detected.");return s.visit(c)}(e))}}),t.prototype={constructor:t,lex:function(e){var t=this.lexer.tokenize(e);if(t.errors.length>0)throw console.error(t.errors),Error("THREE.VRMLLexer: Lexing errors detected.");return t}},r.prototype=Object.create(a.a.Parser.prototype),r.prototype.constructor=r;var o={INTENSITY:1,INTENSITY_ALPHA:2,RGB:3,RGBA:4};return e}()},function(e,t,r){"use strict";r.r(t);var n=r(2);THREE.FBXLoader=function(){var e,t,r;function a(e){THREE.Loader.call(this,e)}function o(e,t){this.textureLoader=e,this.manager=t}function i(){}function s(){}function l(){}function c(){}function f(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}function d(){}function u(e){var t=e.match(/FBXVersion: (\d+)/);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function p(e){return e/46186158e3}a.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:a,load:function(e,t,r,n){var a=this,o=""===a.path?THREE.LoaderUtils.extractUrlBase(e):a.path,i=new THREE.FileLoader(this.manager);i.setPath(a.path),i.setResponseType("arraybuffer"),i.setRequestHeader(a.requestHeader),i.load(e,(function(r){try{t(a.parse(r,o))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(t,r){if(i="Kaydara FBX Binary  \0",(a=t).byteLength>=i.length&&i===w(a,0,i.length))e=(new c).parse(t);else{var n=w(t);if(!function(e){var t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"],r=0;for(var n=0;n<t.length;++n){if((o=void 0,o=e[(a=1)-1],e=e.slice(r+a),r++,o)===t[n])return!1}var a,o;return!0}(n))throw new Error("THREE.FBXLoader: Unknown format.");if(u(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+u(n));e=(new l).parse(n)}var a,i;return new o(new THREE.TextureLoader(this.manager).setPath(this.resourcePath||r).setCrossOrigin(this.crossOrigin),this.manager).parse(e)}}),o.prototype={constructor:o,parse:function(){t=this.parseConnections();var e=this.parseImages(),n=this.parseTextures(e),a=this.parseMaterials(n),o=this.parseDeformers(),s=(new i).parse(o);return this.parseScene(o,s,a),r},parseConnections:function(){var t=new Map;"Connections"in e&&e.Connections.connections.forEach((function(e){var r=e[0],n=e[1],a=e[2];t.has(r)||t.set(r,{parents:[],children:[]});var o={ID:n,relationship:a};t.get(r).parents.push(o),t.has(n)||t.set(n,{parents:[],children:[]});var i={ID:r,relationship:a};t.get(n).children.push(i)}));return t},parseImages:function(){var t={},r={};if("Video"in e.Objects){var n=e.Objects.Video;for(var a in n){var o=n[a];if(t[c=parseInt(a)]=o.RelativeFilename||o.Filename,"Content"in o){var i=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,s="string"==typeof o.Content&&""!==o.Content;if(i||s){var l=this.parseImage(n[a]);r[o.RelativeFilename||o.Filename]=l}}}}for(var c in t){var f=t[c];void 0!==r[f]?t[c]=r[f]:t[c]=t[c].split("\\").pop()}return t},parseImage:function(e){var t,r=e.Content,n=e.RelativeFilename||e.Filename,a=n.slice(n.lastIndexOf(".")+1).toLowerCase();switch(a){case"bmp":t="image/bmp";break;case"jpg":case"jpeg":t="image/jpeg";break;case"png":t="image/png";break;case"tif":t="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",n),t="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+a+'" is not supported.')}if("string"==typeof r)return"data:"+t+";base64,"+r;var o=new Uint8Array(r);return window.URL.createObjectURL(new Blob([o],{type:t}))},parseTextures:function(t){var r=new Map;if("Texture"in e.Objects){var n=e.Objects.Texture;for(var a in n){var o=this.parseTexture(n[a],t);r.set(parseInt(a),o)}}return r},parseTexture:function(e,t){var r=this.loadTexture(e,t);r.ID=e.id,r.name=e.attrName;var n=e.WrapModeU,a=e.WrapModeV,o=void 0!==n?n.value:0,i=void 0!==a?a.value:0;if(r.wrapS=0===o?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,r.wrapT=0===i?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,"Scaling"in e){var s=e.Scaling.value;r.repeat.x=s[0],r.repeat.y=s[1]}return r},loadTexture:function(e,r){var n,a,o=this.textureLoader.path,i=t.get(e.id).children;void 0!==i&&i.length>0&&void 0!==r[i[0].ID]&&(0!==(n=r[i[0].ID]).indexOf("blob:")&&0!==n.indexOf("data:")||this.textureLoader.setPath(void 0));var s=e.FileName.slice(-3).toLowerCase();if("tga"===s){var l=this.manager.getHandler(".tga");null===l?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),a=new THREE.Texture):a=l.load(n)}else"psd"===s?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),a=new THREE.Texture):a=this.textureLoader.load(n);return this.textureLoader.setPath(o),a},parseMaterials:function(t){var r=new Map;if("Material"in e.Objects){var n=e.Objects.Material;for(var a in n){var o=this.parseMaterial(n[a],t);null!==o&&r.set(parseInt(a),o)}}return r},parseMaterial:function(e,r){var n=e.id,a=e.attrName,o=e.ShadingModel;if("object"==typeof o&&(o=o.value),!t.has(n))return null;var i,s=this.parseParameters(e,r,n);switch(o.toLowerCase()){case"phong":i=new THREE.MeshPhongMaterial;break;case"lambert":i=new THREE.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',o),i=new THREE.MeshPhongMaterial}return i.setValues(s),i.name=a,i},parseParameters:function(e,r,n){var a={};e.BumpFactor&&(a.bumpScale=e.BumpFactor.value),e.Diffuse?a.color=(new THREE.Color).fromArray(e.Diffuse.value):e.DiffuseColor&&"Color"===e.DiffuseColor.type&&(a.color=(new THREE.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(a.displacementScale=e.DisplacementFactor.value),e.Emissive?a.emissive=(new THREE.Color).fromArray(e.Emissive.value):e.EmissiveColor&&"Color"===e.EmissiveColor.type&&(a.emissive=(new THREE.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(a.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(a.opacity=parseFloat(e.Opacity.value)),a.opacity<1&&(a.transparent=!0),e.ReflectionFactor&&(a.reflectivity=e.ReflectionFactor.value),e.Shininess&&(a.shininess=e.Shininess.value),e.Specular?a.specular=(new THREE.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(a.specular=(new THREE.Color).fromArray(e.SpecularColor.value));var o=this;return t.get(n).children.forEach((function(e){var t=e.relationship;switch(t){case"Bump":a.bumpMap=o.getTexture(r,e.ID);break;case"Maya|TEX_ao_map":a.aoMap=o.getTexture(r,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":a.map=o.getTexture(r,e.ID),a.map.encoding=THREE.sRGBEncoding;break;case"DisplacementColor":a.displacementMap=o.getTexture(r,e.ID);break;case"EmissiveColor":a.emissiveMap=o.getTexture(r,e.ID),a.emissiveMap.encoding=THREE.sRGBEncoding;break;case"NormalMap":case"Maya|TEX_normal_map":a.normalMap=o.getTexture(r,e.ID);break;case"ReflectionColor":a.envMap=o.getTexture(r,e.ID),a.envMap.mapping=THREE.EquirectangularReflectionMapping,a.envMap.encoding=THREE.sRGBEncoding;break;case"SpecularColor":a.specularMap=o.getTexture(r,e.ID),a.specularMap.encoding=THREE.sRGBEncoding;break;case"TransparentColor":case"TransparencyFactor":a.alphaMap=o.getTexture(r,e.ID),a.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}})),a},getTexture:function(r,n){return"LayeredTexture"in e.Objects&&n in e.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),n=t.get(n).children[0].ID),r.get(n)},parseDeformers:function(){var r={},n={};if("Deformer"in e.Objects){var a=e.Objects.Deformer;for(var o in a){var i=a[o],s=t.get(parseInt(o));if("Skin"===i.attrType){var l=this.parseSkeleton(s,a);l.ID=o,s.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),l.geometryID=s.parents[0].ID,r[o]=l}else if("BlendShape"===i.attrType){var c={id:o};c.rawTargets=this.parseMorphTargets(s,a),c.id=o,s.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),n[o]=c}}}return{skeletons:r,morphTargets:n}},parseSkeleton:function(e,t){var r=[];return e.children.forEach((function(e){var n=t[e.ID];if("Cluster"===n.attrType){var a={ID:e.ID,indices:[],weights:[],transformLink:(new THREE.Matrix4).fromArray(n.TransformLink.a)};"Indexes"in n&&(a.indices=n.Indexes.a,a.weights=n.Weights.a),r.push(a)}})),{rawBones:r,bones:[]}},parseMorphTargets:function(e,r){for(var n=[],a=0;a<e.children.length;a++){var o=e.children[a],i=r[o.ID],s={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if("BlendShapeChannel"!==i.attrType)return;s.geoID=t.get(parseInt(o.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,n.push(s)}return n},parseScene:function(n,a,o){r=new THREE.Group;var i=this.parseModels(n.skeletons,a,o),l=e.Objects.Model,c=this;i.forEach((function(e){var n=l[e.ID];c.setLookAtProperties(e,n),t.get(e.ID).parents.forEach((function(t){var r=i.get(t.ID);void 0!==r&&r.add(e)})),null===e.parent&&r.add(e)})),this.bindSkeleton(n.skeletons,a,i),this.createAmbientLight(),this.setupMorphMaterials(),r.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrixWorld=e.parent.matrix);var t=g(e.userData.transformData);e.applyMatrix4(t)}}));var f=(new s).parse();1===r.children.length&&r.children[0].isGroup&&(r.children[0].animations=f,r=r.children[0]),r.animations=f},parseModels:function(r,n,a){var o=new Map,i=e.Objects.Model;for(var s in i){var l=parseInt(s),c=i[s],f=t.get(l),d=this.buildSkeleton(f,r,l,c.attrName);if(!d){switch(c.attrType){case"Camera":d=this.createCamera(f);break;case"Light":d=this.createLight(f);break;case"Mesh":d=this.createMesh(f,n,a);break;case"NurbsCurve":d=this.createCurve(f,n);break;case"LimbNode":case"Root":d=new THREE.Bone;break;case"Null":default:d=new THREE.Group}d.name=c.attrName?THREE.PropertyBinding.sanitizeNodeName(c.attrName):"",d.ID=l}this.getTransformData(d,c),o.set(l,d)}return o},buildSkeleton:function(e,t,r,n){var a=null;return e.parents.forEach((function(e){for(var o in t){var i=t[o];i.rawBones.forEach((function(t,o){if(t.ID===e.ID){var s=a;(a=new THREE.Bone).matrixWorld.copy(t.transformLink),a.name=n?THREE.PropertyBinding.sanitizeNodeName(n):"",a.ID=r,i.bones[o]=a,null!==s&&a.add(s)}}))}})),a},createCamera:function(t){var r,n;if(t.children.forEach((function(t){var r=e.Objects.NodeAttribute[t.ID];void 0!==r&&(n=r)})),void 0===n)r=new THREE.Object3D;else{var a=0;void 0!==n.CameraProjectionType&&1===n.CameraProjectionType.value&&(a=1);var o=1;void 0!==n.NearPlane&&(o=n.NearPlane.value/1e3);var i=1e3;void 0!==n.FarPlane&&(i=n.FarPlane.value/1e3);var s=window.innerWidth,l=window.innerHeight;void 0!==n.AspectWidth&&void 0!==n.AspectHeight&&(s=n.AspectWidth.value,l=n.AspectHeight.value);var c=s/l,f=45;void 0!==n.FieldOfView&&(f=n.FieldOfView.value);var d=n.FocalLength?n.FocalLength.value:null;switch(a){case 0:r=new THREE.PerspectiveCamera(f,c,o,i),null!==d&&r.setFocalLength(d);break;case 1:r=new THREE.OrthographicCamera(-s/2,s/2,l/2,-l/2,o,i);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+a+"."),r=new THREE.Object3D}}return r},createLight:function(t){var r,n;if(t.children.forEach((function(t){var r=e.Objects.NodeAttribute[t.ID];void 0!==r&&(n=r)})),void 0===n)r=new THREE.Object3D;else{var a;a=void 0===n.LightType?0:n.LightType.value;var o=16777215;void 0!==n.Color&&(o=(new THREE.Color).fromArray(n.Color.value));var i=void 0===n.Intensity?1:n.Intensity.value/100;void 0!==n.CastLightOnObject&&0===n.CastLightOnObject.value&&(i=0);var s=0;void 0!==n.FarAttenuationEnd&&(s=void 0!==n.EnableFarAttenuation&&0===n.EnableFarAttenuation.value?0:n.FarAttenuationEnd.value);switch(a){case 0:r=new THREE.PointLight(o,i,s,1);break;case 1:r=new THREE.DirectionalLight(o,i);break;case 2:var l=Math.PI/3;void 0!==n.InnerAngle&&(l=THREE.MathUtils.degToRad(n.InnerAngle.value));var c=0;void 0!==n.OuterAngle&&(c=THREE.MathUtils.degToRad(n.OuterAngle.value),c=Math.max(c,1)),r=new THREE.SpotLight(o,i,s,l,c,1);break;default:console.warn("THREE.FBXLoader: Unknown light type "+n.LightType.value+", defaulting to a THREE.PointLight."),r=new THREE.PointLight(o,i)}void 0!==n.CastShadows&&1===n.CastShadows.value&&(r.castShadow=!0)}return r},createMesh:function(e,t,r){var n,a=null,o=null,i=[];return e.children.forEach((function(e){t.has(e.ID)&&(a=t.get(e.ID)),r.has(e.ID)&&i.push(r.get(e.ID))})),i.length>1?o=i:i.length>0?o=i[0]:(o=new THREE.MeshPhongMaterial({color:13421772}),i.push(o)),"color"in a.attributes&&i.forEach((function(e){e.vertexColors=!0})),a.FBX_Deformer?(i.forEach((function(e){e.skinning=!0})),(n=new THREE.SkinnedMesh(a,o)).normalizeSkinWeights()):n=new THREE.Mesh(a,o),n},createCurve:function(e,t){var r=e.children.reduce((function(e,r){return t.has(r.ID)&&(e=t.get(r.ID)),e}),null),n=new THREE.LineBasicMaterial({color:3342591,linewidth:1});return new THREE.Line(r,n)},getTransformData:function(e,t){var r={};"InheritType"in t&&(r.inheritType=parseInt(t.InheritType.value)),r.eulerOrder="RotationOrder"in t?y(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(r.translation=t.Lcl_Translation.value),"PreRotation"in t&&(r.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(r.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(r.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(r.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(r.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(r.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(r.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(r.rotationPivot=t.RotationPivot.value),e.userData.transformData=r},setLookAtProperties:function(n,a){"LookAtProperty"in a&&t.get(n.ID).children.forEach((function(t){if("LookAtProperty"===t.relationship){var a=e.Objects.Model[t.ID];if("Lcl_Translation"in a){var o=a.Lcl_Translation.value;void 0!==n.target?(n.target.position.fromArray(o),r.add(n.target)):n.lookAt((new THREE.Vector3).fromArray(o))}}}))},bindSkeleton:function(e,r,n){var a=this.parsePoseNodes();for(var o in e){var i=e[o];t.get(parseInt(i.ID)).parents.forEach((function(e){if(r.has(e.ID)){var o=e.ID;t.get(o).parents.forEach((function(e){n.has(e.ID)&&n.get(e.ID).bind(new THREE.Skeleton(i.bones),a[e.ID])}))}}))}},parsePoseNodes:function(){var t={};if("Pose"in e.Objects){var r=e.Objects.Pose;for(var n in r)if("BindPose"===r[n].attrType){var a=r[n].PoseNode;Array.isArray(a)?a.forEach((function(e){t[e.Node]=(new THREE.Matrix4).fromArray(e.Matrix.a)})):t[a.Node]=(new THREE.Matrix4).fromArray(a.Matrix.a)}}return t},createAmbientLight:function(){if("GlobalSettings"in e&&"AmbientColor"in e.GlobalSettings){var t=e.GlobalSettings.AmbientColor.value,n=t[0],a=t[1],o=t[2];if(0!==n||0!==a||0!==o){var i=new THREE.Color(n,a,o);r.add(new THREE.AmbientLight(i,1))}}},setupMorphMaterials:function(){var e=this;r.traverse((function(t){t.isMesh&&t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length&&(Array.isArray(t.material)?t.material.forEach((function(r,n){e.setupMorphMaterial(t,r,n)})):e.setupMorphMaterial(t,t.material))}))},setupMorphMaterial:function(e,t,n){var a=e.uuid,o=t.uuid,i=!1;if(r.traverse((function(e){e.isMesh&&(Array.isArray(e.material)?e.material.forEach((function(t){t.uuid===o&&e.uuid!==a&&(i=!0)})):e.material.uuid===o&&e.uuid!==a&&(i=!0))})),!0===i){var s=t.clone();s.morphTargets=!0,void 0===n?e.material=s:e.material[n]=s}else t.morphTargets=!0}},i.prototype={constructor:i,parse:function(r){var n=new Map;if("Geometry"in e.Objects){var a=e.Objects.Geometry;for(var o in a){var i=t.get(parseInt(o)),s=this.parseGeometry(i,a[o],r);n.set(parseInt(o),s)}}return n},parseGeometry:function(e,t,r){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,r);case"NurbsCurve":return this.parseNurbsGeometry(t)}},parseMeshGeometry:function(t,r,n){var a=n.skeletons,o=[],i=t.parents.map((function(t){return e.Objects.Model[t.ID]}));if(0!==i.length){var s=t.children.reduce((function(e,t){return void 0!==a[t.ID]&&(e=a[t.ID]),e}),null);t.children.forEach((function(e){void 0!==n.morphTargets[e.ID]&&o.push(n.morphTargets[e.ID])}));var l=i[0],c={};"RotationOrder"in l&&(c.eulerOrder=y(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);var f=g(c);return this.genGeometry(r,s,o,f)}},genGeometry:function(e,t,r,n){var a=new THREE.BufferGeometry;e.attrName&&(a.name=e.attrName);var o=this.parseGeoNode(e,t),i=this.genBuffers(o),s=new THREE.Float32BufferAttribute(i.vertex,3);if(s.applyMatrix4(n),a.setAttribute("position",s),i.colors.length>0&&a.setAttribute("color",new THREE.Float32BufferAttribute(i.colors,3)),t&&(a.setAttribute("skinIndex",new THREE.Uint16BufferAttribute(i.weightsIndices,4)),a.setAttribute("skinWeight",new THREE.Float32BufferAttribute(i.vertexWeights,4)),a.FBX_Deformer=t),i.normal.length>0){var l=(new THREE.Matrix3).getNormalMatrix(n),c=new THREE.Float32BufferAttribute(i.normal,3);c.applyNormalMatrix(l),a.setAttribute("normal",c)}if(i.uvs.forEach((function(e,t){var r="uv"+(t+1).toString();0===t&&(r="uv"),a.setAttribute(r,new THREE.Float32BufferAttribute(i.uvs[t],2))})),o.material&&"AllSame"!==o.material.mappingType){var f=i.materialIndex[0],d=0;if(i.materialIndex.forEach((function(e,t){e!==f&&(a.addGroup(d,t-d,f),f=e,d=t)})),a.groups.length>0){var u=a.groups[a.groups.length-1],p=u.start+u.count;p!==i.materialIndex.length&&a.addGroup(p,i.materialIndex.length-p,f)}0===a.groups.length&&a.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(a,e,r,n),a},parseGeoNode:function(e,t){var r={};if(r.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],r.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(r.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(r.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(r.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){r.uv=[];for(var n=0;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&r.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return r.weightTable={},null!==t&&(r.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(n,a){void 0===r.weightTable[n]&&(r.weightTable[n]=[]),r.weightTable[n].push({id:t,weight:e.weights[a]})}))}))),r},genBuffers:function(e){var t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]},r=0,n=0,a=!1,o=[],i=[],s=[],l=[],c=[],f=[],d=this;return e.vertexIndices.forEach((function(u,p){var h=!1;u<0&&(u^=-1,h=!0);var m=[],x=[];if(o.push(3*u,3*u+1,3*u+2),e.color){var g=v(p,r,u,e.color);s.push(g[0],g[1],g[2])}if(e.skeleton){if(void 0!==e.weightTable[u]&&e.weightTable[u].forEach((function(e){x.push(e.weight),m.push(e.id)})),x.length>4){a||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),a=!0);var y=[0,0,0,0],E=[0,0,0,0];x.forEach((function(e,t){var r=e,n=m[t];E.forEach((function(e,t,a){if(r>e){a[t]=r,r=e;var o=y[t];y[t]=n,n=o}}))})),m=y,x=E}for(;x.length<4;)x.push(0),m.push(0);for(var w=0;w<4;++w)c.push(x[w]),f.push(m[w])}if(e.normal){g=v(p,r,u,e.normal);i.push(g[0],g[1],g[2])}if(e.material&&"AllSame"!==e.material.mappingType)var b=v(p,r,u,e.material)[0];e.uv&&e.uv.forEach((function(e,t){var n=v(p,r,u,e);void 0===l[t]&&(l[t]=[]),l[t].push(n[0]),l[t].push(n[1])})),n++,h&&(d.genFace(t,e,o,b,i,s,l,c,f,n),r++,n=0,o=[],i=[],s=[],l=[],c=[],f=[])})),t},genFace:function(e,t,r,n,a,o,i,s,l,c){for(var f=2;f<c;f++)e.vertex.push(t.vertexPositions[r[0]]),e.vertex.push(t.vertexPositions[r[1]]),e.vertex.push(t.vertexPositions[r[2]]),e.vertex.push(t.vertexPositions[r[3*(f-1)]]),e.vertex.push(t.vertexPositions[r[3*(f-1)+1]]),e.vertex.push(t.vertexPositions[r[3*(f-1)+2]]),e.vertex.push(t.vertexPositions[r[3*f]]),e.vertex.push(t.vertexPositions[r[3*f+1]]),e.vertex.push(t.vertexPositions[r[3*f+2]]),t.skeleton&&(e.vertexWeights.push(s[0]),e.vertexWeights.push(s[1]),e.vertexWeights.push(s[2]),e.vertexWeights.push(s[3]),e.vertexWeights.push(s[4*(f-1)]),e.vertexWeights.push(s[4*(f-1)+1]),e.vertexWeights.push(s[4*(f-1)+2]),e.vertexWeights.push(s[4*(f-1)+3]),e.vertexWeights.push(s[4*f]),e.vertexWeights.push(s[4*f+1]),e.vertexWeights.push(s[4*f+2]),e.vertexWeights.push(s[4*f+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(f-1)]),e.weightsIndices.push(l[4*(f-1)+1]),e.weightsIndices.push(l[4*(f-1)+2]),e.weightsIndices.push(l[4*(f-1)+3]),e.weightsIndices.push(l[4*f]),e.weightsIndices.push(l[4*f+1]),e.weightsIndices.push(l[4*f+2]),e.weightsIndices.push(l[4*f+3])),t.color&&(e.colors.push(o[0]),e.colors.push(o[1]),e.colors.push(o[2]),e.colors.push(o[3*(f-1)]),e.colors.push(o[3*(f-1)+1]),e.colors.push(o[3*(f-1)+2]),e.colors.push(o[3*f]),e.colors.push(o[3*f+1]),e.colors.push(o[3*f+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(a[0]),e.normal.push(a[1]),e.normal.push(a[2]),e.normal.push(a[3*(f-1)]),e.normal.push(a[3*(f-1)+1]),e.normal.push(a[3*(f-1)+2]),e.normal.push(a[3*f]),e.normal.push(a[3*f+1]),e.normal.push(a[3*f+2])),t.uv&&t.uv.forEach((function(t,r){void 0===e.uvs[r]&&(e.uvs[r]=[]),e.uvs[r].push(i[r][0]),e.uvs[r].push(i[r][1]),e.uvs[r].push(i[r][2*(f-1)]),e.uvs[r].push(i[r][2*(f-1)+1]),e.uvs[r].push(i[r][2*f]),e.uvs[r].push(i[r][2*f+1])}))},addMorphTargets:function(t,r,n,a){if(0!==n.length){t.morphTargetsRelative=!0,t.morphAttributes.position=[];var o=this;n.forEach((function(n){n.rawTargets.forEach((function(n){var i=e.Objects.Geometry[n.geoID];void 0!==i&&o.genMorphGeometry(t,r,i,a,n.name)}))}))}},genMorphGeometry:function(e,t,r,n,a){for(var o=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],i=void 0!==r.Vertices?r.Vertices.a:[],s=void 0!==r.Indexes?r.Indexes.a:[],l=3*e.attributes.position.count,c=new Float32Array(l),f=0;f<s.length;f++){var d=3*s[f];c[d]=i[3*f],c[d+1]=i[3*f+1],c[d+2]=i[3*f+2]}var u={vertexIndices:o,vertexPositions:c},p=this.genBuffers(u),h=new THREE.Float32BufferAttribute(p.vertex,3);h.name=a||r.attrName,h.applyMatrix4(n),e.morphAttributes.position.push(h)},parseNormals:function(e){var t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Normals.a,a=[];return"IndexToDirect"===r&&("NormalIndex"in e?a=e.NormalIndex.a:"NormalsIndex"in e&&(a=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:a,mappingType:t,referenceType:r}},parseUVs:function(e){var t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.UV.a,a=[];return"IndexToDirect"===r&&(a=e.UVIndex.a),{dataSize:2,buffer:n,indices:a,mappingType:t,referenceType:r}},parseVertexColors:function(e){var t=e.MappingInformationType,r=e.ReferenceInformationType,n=e.Colors.a,a=[];return"IndexToDirect"===r&&(a=e.ColorIndex.a),{dataSize:4,buffer:n,indices:a,mappingType:t,referenceType:r}},parseMaterialIndices:function(e){var t=e.MappingInformationType,r=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:r};for(var n=e.Materials.a,a=[],o=0;o<n.length;++o)a.push(o);return{dataSize:1,buffer:n,indices:a,mappingType:t,referenceType:r}},parseNurbsGeometry:function(e){if(void 0===THREE.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new THREE.BufferGeometry;var t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new THREE.BufferGeometry;for(var r,n,a=t-1,o=e.KnotVector.a,i=[],s=e.Points.a,l=0,c=s.length;l<c;l+=4)i.push((new THREE.Vector4).fromArray(s,l));if("Closed"===e.Form)i.push(i[0]);else if("Periodic"===e.Form){r=a,n=o.length-1-r;for(l=0;l<a;++l)i.push(i[l])}var f=new THREE.NURBSCurve(a,o,i,r,n).getPoints(7*i.length),d=new Float32Array(3*f.length);f.forEach((function(e,t){e.toArray(d,3*t)}));var u=new THREE.BufferGeometry;return u.setAttribute("position",new THREE.BufferAttribute(d,3)),u}},s.prototype={constructor:s,parse:function(){var e=[],t=this.parseClips();if(void 0!==t)for(var r in t){var n=t[r],a=this.addClip(n);e.push(a)}return e},parseClips:function(){if(void 0!==e.Objects.AnimationCurve){var t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);var r=this.parseAnimationLayers(t);return this.parseAnimStacks(r)}},parseAnimationCurveNodes:function(){var t=e.Objects.AnimationCurveNode,r=new Map;for(var n in t){var a=t[n];if(null!==a.attrName.match(/S|R|T|DeformPercent/)){var o={id:a.id,attr:a.attrName,curves:{}};r.set(o.id,o)}}return r},parseAnimationCurves:function(r){var n=e.Objects.AnimationCurve;for(var a in n){var o={id:n[a].id,times:n[a].KeyTime.a.map(p),values:n[a].KeyValueFloat.a},i=t.get(o.id);if(void 0!==i){var s=i.parents[0].ID,l=i.parents[0].relationship;l.match(/X/)?r.get(s).curves.x=o:l.match(/Y/)?r.get(s).curves.y=o:l.match(/Z/)?r.get(s).curves.z=o:l.match(/d|DeformPercent/)&&r.has(s)&&(r.get(s).curves.morph=o)}}},parseAnimationLayers:function(n){var a=e.Objects.AnimationLayer,o=new Map;for(var i in a){var s=[],l=t.get(parseInt(i));if(void 0!==l)l.children.forEach((function(a,o){if(n.has(a.ID)){var i=n.get(a.ID);if(void 0!==i.curves.x||void 0!==i.curves.y||void 0!==i.curves.z){if(void 0===s[o])if(void 0!==(p=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID)){if(void 0===(c=e.Objects.Model[p.toString()]))return void console.warn("THREE.FBXLoader: Encountered a unused curve.",a);var l={modelName:c.attrName?THREE.PropertyBinding.sanitizeNodeName(c.attrName):"",ID:c.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};r.traverse((function(e){e.ID===c.id&&(l.transform=e.matrix,e.userData.transformData&&(l.eulerOrder=e.userData.transformData.eulerOrder))})),l.transform||(l.transform=new THREE.Matrix4),"PreRotation"in c&&(l.preRotation=c.PreRotation.value),"PostRotation"in c&&(l.postRotation=c.PostRotation.value),s[o]=l}s[o]&&(s[o][i.attr]=i)}else if(void 0!==i.curves.morph){if(void 0===s[o]){var c,f=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,d=t.get(f).parents[0].ID,u=t.get(d).parents[0].ID,p=t.get(u).parents[0].ID;l={modelName:(c=e.Objects.Model[p]).attrName?THREE.PropertyBinding.sanitizeNodeName(c.attrName):"",morphName:e.Objects.Deformer[f].attrName};s[o]=l}s[o][i.attr]=i}}})),o.set(parseInt(i),s)}return o},parseAnimStacks:function(r){var n=e.Objects.AnimationStack,a={};for(var o in n){var i=t.get(parseInt(o)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");var s=r.get(i[0].ID);a[o]={name:n[o].attrName,layer:s}}return a},addClip:function(e){var t=[],r=this;return e.layer.forEach((function(e){t=t.concat(r.generateTracks(e))})),new THREE.AnimationClip(e.name,-1,t)},generateTracks:function(e){var t=[],r=new THREE.Vector3,n=new THREE.Quaternion,a=new THREE.Vector3;if(e.transform&&e.transform.decompose(r,n,a),r=r.toArray(),n=(new THREE.Euler).setFromQuaternion(n,e.eulerOrder).toArray(),a=a.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){var o=this.generateVectorTrack(e.modelName,e.T.curves,r,"position");void 0!==o&&t.push(o)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){var i=this.generateRotationTrack(e.modelName,e.R.curves,n,e.preRotation,e.postRotation,e.eulerOrder);void 0!==i&&t.push(i)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){var s=this.generateVectorTrack(e.modelName,e.S.curves,a,"scale");void 0!==s&&t.push(s)}if(void 0!==e.DeformPercent){var l=this.generateMorphTrack(e);void 0!==l&&t.push(l)}return t},generateVectorTrack:function(e,t,r,n){var a=this.getTimesForAllAxes(t),o=this.getKeyframeTrackValues(a,t,r);return new THREE.VectorKeyframeTrack(e+"."+n,a,o)},generateRotationTrack:function(e,t,r,n,a,o){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(THREE.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(THREE.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(THREE.MathUtils.degToRad));var i=this.getTimesForAllAxes(t),s=this.getKeyframeTrackValues(i,t,r);void 0!==n&&((n=n.map(THREE.MathUtils.degToRad)).push(o),n=(new THREE.Euler).fromArray(n),n=(new THREE.Quaternion).setFromEuler(n)),void 0!==a&&((a=a.map(THREE.MathUtils.degToRad)).push(o),a=(new THREE.Euler).fromArray(a),a=(new THREE.Quaternion).setFromEuler(a).inverse());for(var l=new THREE.Quaternion,c=new THREE.Euler,f=[],d=0;d<s.length;d+=3)c.set(s[d],s[d+1],s[d+2],o),l.setFromEuler(c),void 0!==n&&l.premultiply(n),void 0!==a&&l.multiply(a),l.toArray(f,d/3*4);return new THREE.QuaternionKeyframeTrack(e+".quaternion",i,f)},generateMorphTrack:function(e){var t=e.DeformPercent.curves.morph,n=t.values.map((function(e){return e/100})),a=r.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new THREE.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+a+"]",t.times,n)},getTimesForAllAxes:function(e){var t=[];return void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})).filter((function(e,t,r){return r.indexOf(e)==t}))},getKeyframeTrackValues:function(e,t,r){var n=r,a=[],o=-1,i=-1,s=-1;return e.forEach((function(e){if(t.x&&(o=t.x.times.indexOf(e)),t.y&&(i=t.y.times.indexOf(e)),t.z&&(s=t.z.times.indexOf(e)),-1!==o){var r=t.x.values[o];a.push(r),n[0]=r}else a.push(n[0]);if(-1!==i){var l=t.y.values[i];a.push(l),n[1]=l}else a.push(n[1]);if(-1!==s){var c=t.z.values[s];a.push(c),n[2]=c}else a.push(n[2])})),a},interpolateRotations:function(e){for(var t=1;t<e.values.length;t++){var r=e.values[t-1],n=e.values[t]-r,a=Math.abs(n);if(a>=180){for(var o=a/180,i=n/o,s=r+i,l=e.times[t-1],c=(e.times[t]-l)/o,f=l+c,d=[],u=[];f<e.times[t];)d.push(f),f+=c,u.push(s),s+=i;e.times=b(e.times,t,d),e.values=b(e.values,t,u)}}}},l.prototype={constructor:l,getPrevNode:function(){return this.nodeStack[this.currentIndent-2]},getCurrentNode:function(){return this.nodeStack[this.currentIndent-1]},getCurrentProp:function(){return this.currentProp},pushStack:function(e){this.nodeStack.push(e),this.currentIndent+=1},popStack:function(){this.nodeStack.pop(),this.currentIndent-=1},setCurrentProp:function(e,t){this.currentProp=e,this.currentPropName=t},parse:function(e){this.currentIndent=0,this.allNodes=new d,this.nodeStack=[],this.currentProp=[],this.currentPropName="";var t=this,r=e.split(/[\r\n]+/);return r.forEach((function(e,n){var a=e.match(/^[\s\t]*;/),o=e.match(/^[\s\t]*$/);if(!a&&!o){var i=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),s=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");i?t.parseNodeBegin(e,i):s?t.parseNodeProperty(e,s,r[++n]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)}})),this.allNodes},parseNodeBegin:function(e,t){var r=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),a={name:r},o=this.parseNodeAttr(n),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(r,a):r in i?("PoseNode"===r?i.PoseNode.push(a):void 0!==i[r].id&&(i[r]={},i[r][i[r].id]=i[r]),""!==o.id&&(i[r][o.id]=a)):"number"==typeof o.id?(i[r]={},i[r][o.id]=a):"Properties70"!==r&&(i[r]="PoseNode"===r?[a]:a),"number"==typeof o.id&&(a.id=o.id),""!==o.name&&(a.attrName=o.name),""!==o.type&&(a.attrType=o.type),this.pushStack(a)},parseNodeAttr:function(e){var t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));var r="",n="";return e.length>1&&(r=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:r,type:n}},parseNodeProperty:function(e,t,r){var n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),a=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===n&&","===a&&(a=r.replace(/"/g,"").replace(/,$/,"").trim());var o=this.getCurrentNode();if("Properties70"!==o.name){if("C"===n){var i=a.split(",").slice(1),s=parseInt(i[0]),l=parseInt(i[1]),c=a.split(",").slice(3);n="connections",function(e,t){for(var r=0,n=e.length,a=t.length;r<a;r++,n++)e[n]=t[r]}(a=[s,l],c=c.map((function(e){return e.trim().replace(/^"/,"")}))),void 0===o[n]&&(o[n]=[])}"Node"===n&&(o.id=a),n in o&&Array.isArray(o[n])?o[n].push(a):"a"!==n?o[n]=a:o.a=a,this.setCurrentProp(o,n),"a"===n&&","!==a.slice(-1)&&(o.a=E(a))}else this.parseNodeSpecialProperty(e,n,a)},parseNodePropertyContinued:function(e){var t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=E(t.a))},parseNodeSpecialProperty:function(e,t,r){var n=r.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),a=n[0],o=n[1],i=n[2],s=n[3],l=n[4];switch(o){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=E(l)}this.getPrevNode()[a]={type:o,type2:i,flag:s,value:l},this.setCurrentProp(this.getPrevNode(),a)}},c.prototype={constructor:c,parse:function(e){var t=new f(e);t.skip(23);var r=t.getUint32();if(r<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+r);for(var n=new d;!this.endOfContent(t);){var a=this.parseNode(t,r);null!==a&&n.add(a.name,a)}return n},endOfContent:function(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()},parseNode:function(e,t){var r={},n=t>=7500?e.getUint64():e.getUint32(),a=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();var o=e.getUint8(),i=e.getString(o);if(0===n)return null;for(var s=[],l=0;l<a;l++)s.push(this.parseProperty(e));var c=s.length>0?s[0]:"",f=s.length>1?s[1]:"",d=s.length>2?s[2]:"";for(r.singleProperty=1===a&&e.getOffset()===n;n>e.getOffset();){var u=this.parseNode(e,t);null!==u&&this.parseSubNode(i,r,u)}return r.propertyList=s,"number"==typeof c&&(r.id=c),""!==f&&(r.attrName=f),""!==d&&(r.attrType=d),""!==i&&(r.name=i),r},parseSubNode:function(e,t,r){if(!0===r.singleProperty){var n=r.propertyList[0];Array.isArray(n)?(t[r.name]=r,r.a=n):t[r.name]=n}else if("Connections"===e&&"C"===r.name){var a=[];r.propertyList.forEach((function(e,t){0!==t&&a.push(e)})),void 0===t.connections&&(t.connections=[]),t.connections.push(a)}else if("Properties70"===r.name){Object.keys(r).forEach((function(e){t[e]=r[e]}))}else if("Properties70"===e&&"P"===r.name){var o,i=r.propertyList[0],s=r.propertyList[1],l=r.propertyList[2],c=r.propertyList[3];0===i.indexOf("Lcl ")&&(i=i.replace("Lcl ","Lcl_")),0===s.indexOf("Lcl ")&&(s=s.replace("Lcl ","Lcl_")),o="Color"===s||"ColorRGB"===s||"Vector"===s||"Vector3D"===s||0===s.indexOf("Lcl_")?[r.propertyList[4],r.propertyList[5],r.propertyList[6]]:r.propertyList[4],t[i]={type:s,type2:l,flag:c,value:o}}else void 0===t[r.name]?"number"==typeof r.id?(t[r.name]={},t[r.name][r.id]=r):t[r.name]=r:"PoseNode"===r.name?(Array.isArray(t[r.name])||(t[r.name]=[t[r.name]]),t[r.name].push(r)):void 0===t[r.name][r.id]&&(t[r.name][r.id]=r)},parseProperty:function(e){var t=e.getString(1);switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":var r=e.getUint32();return e.getArrayBuffer(r);case"S":r=e.getUint32();return e.getString(r);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":var a=e.getUint32(),o=e.getUint32(),i=e.getUint32();if(0===o)switch(t){case"b":case"c":return e.getBooleanArray(a);case"d":return e.getFloat64Array(a);case"f":return e.getFloat32Array(a);case"i":return e.getInt32Array(a);case"l":return e.getInt64Array(a)}void 0===n.Zlib&&console.error("THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js");var s=new f(new n.Zlib.Inflate(new Uint8Array(e.getArrayBuffer(i))).decompress().buffer);switch(t){case"b":case"c":return s.getBooleanArray(a);case"d":return s.getFloat64Array(a);case"f":return s.getFloat32Array(a);case"i":return s.getInt32Array(a);case"l":return s.getInt64Array(a)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}},f.prototype={constructor:f,getOffset:function(){return this.offset},size:function(){return this.dv.buffer.byteLength},skip:function(e){this.offset+=e},getBoolean:function(){return 1==(1&this.getUint8())},getBooleanArray:function(e){for(var t=[],r=0;r<e;r++)t.push(this.getBoolean());return t},getUint8:function(){var e=this.dv.getUint8(this.offset);return this.offset+=1,e},getInt16:function(){var e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e},getInt32:function(){var e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e},getInt32Array:function(e){for(var t=[],r=0;r<e;r++)t.push(this.getInt32());return t},getUint32:function(){var e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e},getInt64:function(){var e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,4294967295===(e=4294967295&~e)&&(t=t+1&4294967295),-(4294967296*t+(e=e+1&4294967295))):4294967296*t+e},getInt64Array:function(e){for(var t=[],r=0;r<e;r++)t.push(this.getInt64());return t},getUint64:function(){var e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e},getFloat32:function(){var e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e},getFloat32Array:function(e){for(var t=[],r=0;r<e;r++)t.push(this.getFloat32());return t},getFloat64:function(){var e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e},getFloat64Array:function(e){for(var t=[],r=0;r<e;r++)t.push(this.getFloat64());return t},getArrayBuffer:function(e){var t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t},getString:function(e){for(var t=[],r=0;r<e;r++)t[r]=this.getUint8();var n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),THREE.LoaderUtils.decodeText(new Uint8Array(t))}},d.prototype={constructor:d,add:function(e,t){this[e]=t}};var h=[];function v(e,t,r,n){var a;switch(n.mappingType){case"ByPolygonVertex":a=e;break;case"ByPolygon":a=t;break;case"ByVertice":a=r;break;case"AllSame":a=n.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+n.mappingType)}"IndexToDirect"===n.referenceType&&(a=n.indices[a]);var o=a*n.dataSize,i=o+n.dataSize;return function(e,t,r,n){for(var a=r,o=0;a<n;a++,o++)e[o]=t[a];return e}(h,n.buffer,o,i)}var m=new THREE.Euler,x=new THREE.Vector3;function g(e){var t,r=new THREE.Matrix4,n=new THREE.Matrix4,a=new THREE.Matrix4,o=new THREE.Matrix4,i=new THREE.Matrix4,s=new THREE.Matrix4,l=new THREE.Matrix4,c=new THREE.Matrix4,f=new THREE.Matrix4,d=new THREE.Matrix4,u=new THREE.Matrix4,p=e.inheritType?e.inheritType:0;(e.translation&&r.setPosition(x.fromArray(e.translation)),e.preRotation)&&((t=e.preRotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder),n.makeRotationFromEuler(m.fromArray(t)));e.rotation&&((t=e.rotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder),a.makeRotationFromEuler(m.fromArray(t)));e.postRotation&&((t=e.postRotation.map(THREE.MathUtils.degToRad)).push(e.eulerOrder),o.makeRotationFromEuler(m.fromArray(t)));e.scale&&i.scale(x.fromArray(e.scale)),e.scalingOffset&&l.setPosition(x.fromArray(e.scalingOffset)),e.scalingPivot&&s.setPosition(x.fromArray(e.scalingPivot)),e.rotationOffset&&c.setPosition(x.fromArray(e.rotationOffset)),e.rotationPivot&&f.setPosition(x.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(d=e.parentMatrixWorld);var h=n.multiply(a).multiply(o),v=new THREE.Matrix4;d.extractRotation(v),(new THREE.Matrix4).copyPosition(d);var g=new THREE.Matrix4;g.getInverse(v).multiply(d);var y=new THREE.Matrix4;if(0===p)y.copy(v).multiply(h).multiply(g).multiply(i);else if(1===p)y.copy(v).multiply(g).multiply(h).multiply(i);else{var E=(new THREE.Matrix4).getInverse(i),w=(new THREE.Matrix4).multiply(g).multiply(E);y.copy(v).multiply(h).multiply(w).multiply(i)}var b=(new THREE.Matrix4).getInverse(f),T=(new THREE.Matrix4).getInverse(s),_=new THREE.Matrix4;_.copy(r).multiply(c).multiply(f).multiply(n).multiply(a).multiply(o).multiply(b).multiply(l).multiply(s).multiply(i).multiply(T);var S=(new THREE.Matrix4).copyPosition(_),R=(new THREE.Matrix4).copy(d).multiply(S);return u.copyPosition(R),_=(new THREE.Matrix4).multiply(u).multiply(y)}function y(e){var t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function E(e){return e.split(",").map((function(e){return parseFloat(e)}))}function w(e,t,r){return void 0===t&&(t=0),void 0===r&&(r=e.byteLength),THREE.LoaderUtils.decodeText(new Uint8Array(e,t,r))}function b(e,t,r){return e.slice(0,t).concat(r).concat(e.slice(t))}return a}()},function(e,t,r){"use strict";r.r(t);var n=r(5);THREE.NRRDLoader=function(e){THREE.Loader.call(this,e)},THREE.NRRDLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.NRRDLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t=e,r=0,a=new Int8Array(new Int16Array([1]).buffer)[0]>0,o={};var i=function(e,n){null==n&&(n=1);var o=1,i=Uint8Array;switch(e){case"uchar":break;case"schar":i=Int8Array;break;case"ushort":i=Uint16Array,o=2;break;case"sshort":i=Int16Array,o=2;break;case"uint":i=Uint32Array,o=4;break;case"sint":i=Int32Array,o=4;break;case"float":i=Float32Array,o=4;break;case"complex":case"double":i=Float64Array,o=8}var s=new i(t.slice(r,r+=n*o));return 1!=a&&(s=function(e,t){for(var r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),n=0;n<e.byteLength;n+=t)for(var a=n+t-1,o=n;a>o;a--,o++){var i=r[o];r[o]=r[a],r[a]=i}return e}(s,o)),1==n?s[0]:s}("uchar",e.byteLength),s=i.length,l=null,c=0;for(u=1;u<s;u++)if(10==i[u-1]&&10==i[u]){l=this.parseChars(i,0,u-2),c=u+1;break}!function(e){var t,r,n,a,i,s,l,c,f;for(c=0,f=(s=e.split(/\r?\n/)).length;c<f;c++)(i=s[c]).match(/NRRD\d+/)?o.isNrrd=!0:i.match(/^#/)||(l=i.match(/(.*):(.*)/))&&(r=l[1].trim(),t=l[2].trim(),(n=THREE.NRRDLoader.prototype.fieldFunctions[r])?n.call(o,t):o[r]=t);if(!o.isNrrd)throw new Error("Not an NRRD file");if("bz2"===o.encoding||"bzip2"===o.encoding)throw new Error("Bzip is not supported");if(!o.vectors&&(o.vectors=[new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1)],o.spacings))for(a=0;a<=2;a++)isNaN(o.spacings[a])||o.vectors[a].multiplyScalar(o.spacings[a])}(l);t=i.subarray(c);if("gzip"===o.encoding||"gz"===o.encoding){var f=new n.Zlib.Gunzip(new Uint8Array(t));t=f.decompress()}else if("ascii"===o.encoding||"text"===o.encoding||"txt"===o.encoding||"hex"===o.encoding)t=function(e,t,r){var n,a="";t=t||0,r=r||e.length;var i=o.sizes.reduce((function(e,t){return e*t}),1),s=10;"hex"===o.encoding&&(s=16);var l=new o.__array(i),c=0,f=parseInt;o.__array!==Float32Array&&o.__array!==Float64Array||(f=parseFloat);for(var d=t;d<r;d++)((n=e[d])<9||n>13)&&32!==n?a+=String.fromCharCode(n):(""!==a&&(l[c]=f(a,s),c++),a="");return""!==a&&(l[c]=f(a,s),c++),l}(t);else if("raw"===o.encoding){for(var d=new Uint8Array(t.length),u=0;u<t.length;u++)d[u]=t[u];t=d}t=t.buffer;var p=new THREE.Volume;p.header=o,p.data=new o.__array(t);var h=p.computeMinMax(),v=h[0],m=h[1];p.windowLow=v,p.windowHigh=m,p.dimensions=[o.sizes[0],o.sizes[1],o.sizes[2]],p.xLength=p.dimensions[0],p.yLength=p.dimensions[1],p.zLength=p.dimensions[2];var x=new THREE.Vector3(o.vectors[0][0],o.vectors[0][1],o.vectors[0][2]).length(),g=new THREE.Vector3(o.vectors[1][0],o.vectors[1][1],o.vectors[1][2]).length(),y=new THREE.Vector3(o.vectors[2][0],o.vectors[2][1],o.vectors[2][2]).length();p.spacing=[x,g,y],p.matrix=new THREE.Matrix4;var E=1,w=1;if("left-posterior-superior"==o.space?(E=-1,w=-1):"left-anterior-superior"===o.space&&(E=-1),o.vectors){var b=o.vectors;p.matrix.set(E*b[0][0],E*b[1][0],E*b[2][0],0,w*b[0][1],w*b[1][1],w*b[2][1],0,1*b[0][2],1*b[1][2],1*b[2][2],0,0,0,0,1)}else p.matrix.set(E,0,0,0,0,w,0,0,0,0,1,0,0,0,0,1);return p.inverseMatrix=new THREE.Matrix4,p.inverseMatrix.getInverse(p.matrix),p.RASDimensions=new THREE.Vector3(p.xLength,p.yLength,p.zLength).applyMatrix4(p.matrix).round().toArray().map(Math.abs),p.lowerThreshold===-1/0&&(p.lowerThreshold=v),p.upperThreshold===1/0&&(p.upperThreshold=m),p},parseChars:function(e,t,r){void 0===t&&(t=0),void 0===r&&(r=e.length);var n="",a=0;for(a=t;a<r;++a)n+=String.fromCharCode(e[a]);return n},fieldFunctions:{type:function(e){switch(e){case"uchar":case"unsigned char":case"uint8":case"uint8_t":this.__array=Uint8Array;break;case"signed char":case"int8":case"int8_t":this.__array=Int8Array;break;case"short":case"short int":case"signed short":case"signed short int":case"int16":case"int16_t":this.__array=Int16Array;break;case"ushort":case"unsigned short":case"unsigned short int":case"uint16":case"uint16_t":this.__array=Uint16Array;break;case"int":case"signed int":case"int32":case"int32_t":this.__array=Int32Array;break;case"uint":case"unsigned int":case"uint32":case"uint32_t":this.__array=Uint32Array;break;case"float":this.__array=Float32Array;break;case"double":this.__array=Float64Array;break;default:throw new Error("Unsupported NRRD data type: "+e)}return this.type=e},endian:function(e){return this.endian=e},encoding:function(e){return this.encoding=e},dimension:function(e){return this.dim=parseInt(e,10)},sizes:function(e){var t;return this.sizes=function(){var r,n,a,o;for(o=[],r=0,n=(a=e.split(/\s+/)).length;r<n;r++)t=a[r],o.push(parseInt(t,10));return o}()},space:function(e){return this.space=e},"space origin":function(e){return this.space_origin=e.split("(")[1].split(")")[0].split(",")},"space directions":function(e){var t,r,n;return r=e.match(/\(.*?\)/g),this.vectors=function(){var e,a,o;for(o=[],e=0,a=r.length;e<a;e++)n=r[e],o.push(function(){var e,r,a,o;for(o=[],e=0,r=(a=n.slice(1,-1).split(/,/)).length;e<r;e++)t=a[e],o.push(parseFloat(t));return o}());return o}()},spacings:function(e){var t,r;return r=e.split(/\s+/),this.spacings=function(){var e,n,a=[];for(e=0,n=r.length;e<n;e++)t=r[e],a.push(parseFloat(t));return a}()}}})},function(e,t,r){"use strict";r.r(t);var n=r(0);THREE.KMZLoader=function(e){THREE.Loader.call(this,e)},THREE.KMZLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.KMZLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t=new THREE.LoadingManager;t.setURLModifier((function(e){var t=function(e){for(var t in r.files)if(t.substr(-e.length)===e)return r.files[t]}(e);if(t){console.log("Loading",e);var n=new Blob([t.asArrayBuffer()],{type:"application/octet-stream"});return URL.createObjectURL(n)}return e}));var r=new n(e);if(r.files["doc.kml"]){var a=(new DOMParser).parseFromString(r.files["doc.kml"].asText(),"application/xml").querySelector("Placemark Model Link href");if(a)return new THREE.ColladaLoader(t).parse(r.files[a.textContent].asText())}else for(var o in console.warn("KMZLoader: Missing doc.kml file."),r.files){if("dae"===o.split(".").pop().toLowerCase())return new THREE.ColladaLoader(t).parse(r.files[o].asText())}return console.error("KMZLoader: Couldn't find .dae file."),{scene:new THREE.Group}}})},function(e,t){var r;THREE.MD2Loader=function(e){THREE.Loader.call(this,e)},THREE.MD2Loader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.MD2Loader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:(r=[[-.525731,0,.850651],[-.442863,.238856,.864188],[-.295242,0,.955423],[-.309017,.5,.809017],[-.16246,.262866,.951056],[0,0,1],[0,.850651,.525731],[-.147621,.716567,.681718],[.147621,.716567,.681718],[0,.525731,.850651],[.309017,.5,.809017],[.525731,0,.850651],[.295242,0,.955423],[.442863,.238856,.864188],[.16246,.262866,.951056],[-.681718,.147621,.716567],[-.809017,.309017,.5],[-.587785,.425325,.688191],[-.850651,.525731,0],[-.864188,.442863,.238856],[-.716567,.681718,.147621],[-.688191,.587785,.425325],[-.5,.809017,.309017],[-.238856,.864188,.442863],[-.425325,.688191,.587785],[-.716567,.681718,-.147621],[-.5,.809017,-.309017],[-.525731,.850651,0],[0,.850651,-.525731],[-.238856,.864188,-.442863],[0,.955423,-.295242],[-.262866,.951056,-.16246],[0,1,0],[0,.955423,.295242],[-.262866,.951056,.16246],[.238856,.864188,.442863],[.262866,.951056,.16246],[.5,.809017,.309017],[.238856,.864188,-.442863],[.262866,.951056,-.16246],[.5,.809017,-.309017],[.850651,.525731,0],[.716567,.681718,.147621],[.716567,.681718,-.147621],[.525731,.850651,0],[.425325,.688191,.587785],[.864188,.442863,.238856],[.688191,.587785,.425325],[.809017,.309017,.5],[.681718,.147621,.716567],[.587785,.425325,.688191],[.955423,.295242,0],[1,0,0],[.951056,.16246,.262866],[.850651,-.525731,0],[.955423,-.295242,0],[.864188,-.442863,.238856],[.951056,-.16246,.262866],[.809017,-.309017,.5],[.681718,-.147621,.716567],[.850651,0,.525731],[.864188,.442863,-.238856],[.809017,.309017,-.5],[.951056,.16246,-.262866],[.525731,0,-.850651],[.681718,.147621,-.716567],[.681718,-.147621,-.716567],[.850651,0,-.525731],[.809017,-.309017,-.5],[.864188,-.442863,-.238856],[.951056,-.16246,-.262866],[.147621,.716567,-.681718],[.309017,.5,-.809017],[.425325,.688191,-.587785],[.442863,.238856,-.864188],[.587785,.425325,-.688191],[.688191,.587785,-.425325],[-.147621,.716567,-.681718],[-.309017,.5,-.809017],[0,.525731,-.850651],[-.525731,0,-.850651],[-.442863,.238856,-.864188],[-.295242,0,-.955423],[-.16246,.262866,-.951056],[0,0,-1],[.295242,0,-.955423],[.16246,.262866,-.951056],[-.442863,-.238856,-.864188],[-.309017,-.5,-.809017],[-.16246,-.262866,-.951056],[0,-.850651,-.525731],[-.147621,-.716567,-.681718],[.147621,-.716567,-.681718],[0,-.525731,-.850651],[.309017,-.5,-.809017],[.442863,-.238856,-.864188],[.16246,-.262866,-.951056],[.238856,-.864188,-.442863],[.5,-.809017,-.309017],[.425325,-.688191,-.587785],[.716567,-.681718,-.147621],[.688191,-.587785,-.425325],[.587785,-.425325,-.688191],[0,-.955423,-.295242],[0,-1,0],[.262866,-.951056,-.16246],[0,-.850651,.525731],[0,-.955423,.295242],[.238856,-.864188,.442863],[.262866,-.951056,.16246],[.5,-.809017,.309017],[.716567,-.681718,.147621],[.525731,-.850651,0],[-.238856,-.864188,-.442863],[-.5,-.809017,-.309017],[-.262866,-.951056,-.16246],[-.850651,-.525731,0],[-.716567,-.681718,-.147621],[-.716567,-.681718,.147621],[-.525731,-.850651,0],[-.5,-.809017,.309017],[-.238856,-.864188,.442863],[-.262866,-.951056,.16246],[-.864188,-.442863,.238856],[-.809017,-.309017,.5],[-.688191,-.587785,.425325],[-.681718,-.147621,.716567],[-.442863,-.238856,.864188],[-.587785,-.425325,.688191],[-.309017,-.5,.809017],[-.147621,-.716567,.681718],[-.425325,-.688191,.587785],[-.16246,-.262866,.951056],[.442863,-.238856,.864188],[.16246,-.262866,.951056],[.309017,-.5,.809017],[.147621,-.716567,.681718],[0,-.525731,.850651],[.425325,-.688191,.587785],[.587785,-.425325,.688191],[.688191,-.587785,.425325],[-.955423,.295242,0],[-.951056,.16246,.262866],[-1,0,0],[-.850651,0,.525731],[-.955423,-.295242,0],[-.951056,-.16246,.262866],[-.864188,.442863,-.238856],[-.951056,.16246,-.262866],[-.809017,.309017,-.5],[-.864188,-.442863,-.238856],[-.951056,-.16246,-.262866],[-.809017,-.309017,-.5],[-.681718,.147621,-.716567],[-.681718,-.147621,-.716567],[-.850651,0,-.525731],[-.688191,.587785,-.425325],[-.587785,.425325,-.688191],[-.425325,.688191,-.587785],[-.425325,-.688191,-.587785],[-.587785,-.425325,-.688191],[-.688191,-.587785,-.425325]],function(e){for(var t=new DataView(e),n={},a=["ident","version","skinwidth","skinheight","framesize","num_skins","num_vertices","num_st","num_tris","num_glcmds","num_frames","offset_skins","offset_st","offset_tris","offset_frames","offset_glcmds","offset_end"],o=0;o<a.length;o++)n[a[o]]=t.getInt32(4*o,!0);if(844121161===n.ident&&8===n.version){if(n.offset_end===t.byteLength){for(var i=new THREE.BufferGeometry,s=[],l=n.offset_st,c=(o=0,n.num_st);o<c;o++){var f=t.getInt16(l+0,!0),d=t.getInt16(l+2,!0);s.push(f/n.skinwidth,1-d/n.skinheight),l+=4}l=n.offset_tris;var u=[],p=[];for(o=0,c=n.num_tris;o<c;o++)u.push(t.getUint16(l+0,!0),t.getUint16(l+2,!0),t.getUint16(l+4,!0)),p.push(t.getUint16(l+6,!0),t.getUint16(l+8,!0),t.getUint16(l+10,!0)),l+=12;var h=new THREE.Vector3,v=new THREE.Vector3,m=[],x=[];for(l=n.offset_frames,o=0,c=n.num_frames;o<c;o++){v.set(t.getFloat32(l+0,!0),t.getFloat32(l+4,!0),t.getFloat32(l+8,!0)),h.set(t.getFloat32(l+12,!0),t.getFloat32(l+16,!0),t.getFloat32(l+20,!0)),l+=24;for(var g=0;g<16;g++){var y=t.getUint8(l+g,!0);if(0===y)break;m[g]=y}var E={name:String.fromCharCode.apply(null,m),vertices:[],normals:[]};for(l+=16,g=0;g<n.num_vertices;g++){var w=t.getUint8(l++,!0),b=t.getUint8(l++,!0),T=t.getUint8(l++,!0),_=r[t.getUint8(l++,!0)];w=w*v.x+h.x,b=b*v.y+h.y,T=T*v.z+h.z,E.vertices.push(w,T,b),E.normals.push(_[0],_[2],_[1])}x.push(E)}var S=[],R=[],A=[],M=x[0].vertices,C=x[0].normals;for(o=0,c=u.length;o<c;o++){w=M[F=3*u[o]],b=M[F+1],T=M[F+2],S.push(w,b,T);var L=C[F],H=C[F+1],P=C[F+2];R.push(L,H,P),f=s[F=2*p[o]],d=s[F+1],A.push(f,d)}i.setAttribute("position",new THREE.Float32BufferAttribute(S,3)),i.setAttribute("normal",new THREE.Float32BufferAttribute(R,3)),i.setAttribute("uv",new THREE.Float32BufferAttribute(A,2));var z=[],k=[];for(o=0,c=x.length;o<c;o++){var N=(E=x[o]).name;if(E.vertices.length>0){S=[],g=0;for(var D=u.length;g<D;g++){var F=3*u[g];w=E.vertices[F],b=E.vertices[F+1],T=E.vertices[F+2],S.push(w,b,T)}var I=new THREE.Float32BufferAttribute(S,3);I.name=N,z.push(I)}if(E.normals.length>0){for(R=[],g=0,D=u.length;g<D;g++)F=3*u[g],L=E.normals[F],H=E.normals[F+1],P=E.normals[F+2],R.push(L,H,P);var O=new THREE.Float32BufferAttribute(R,3);O.name=N,k.push(O)}}return i.morphAttributes.position=z,i.morphAttributes.normal=k,i.morphTargetsRelative=!1,i.animations=THREE.AnimationClip.CreateClipsFromMorphTargetSequences(x,10),i}console.error("Corrupted MD2 file")}else console.error("Not a valid MD2 file")})})},function(e,t){var r,n,a,o,i,s,l,c,f,d,u,p,h,v,m,x,g;THREE.SVGLoader=function(e){THREE.Loader.call(this,e),this.defaultDPI=90,this.defaultUnit="px"},THREE.SVGLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.SVGLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){var t=this;function r(e,t,r,a,o,i,s,l){a=a*Math.PI/180,t=Math.abs(t),r=Math.abs(r);var c=(s.x-l.x)/2,f=(s.y-l.y)/2,d=Math.cos(a)*c+Math.sin(a)*f,u=-Math.sin(a)*c+Math.cos(a)*f,p=t*t,h=r*r,v=d*d,m=u*u,x=v/p+m/h;if(x>1){var g=Math.sqrt(x);p=(t*=g)*t,h=(r*=g)*r}var y=p*m+h*v,E=(p*h-y)/y,w=Math.sqrt(Math.max(0,E));o===i&&(w=-w);var b=w*t*u/r,T=-w*r*d/t,_=Math.cos(a)*b-Math.sin(a)*T+(s.x+l.x)/2,S=Math.sin(a)*b+Math.cos(a)*T+(s.y+l.y)/2,R=n(1,0,(d-b)/t,(u-T)/r),A=n((d-b)/t,(u-T)/r,(-d-b)/t,(-u-T)/r)%(2*Math.PI);e.currentPath.absellipse(_,S,t,r,R,R+A,0===i,a)}function n(e,t,r,n){var a=e*r+t*n,o=Math.sqrt(e*e+t*t)*Math.sqrt(r*r+n*n),i=Math.acos(Math.max(-1,Math.min(1,a/o)));return e*n-t*r<0&&(i=-i),i}function a(e,t){t=Object.assign({},t);var r={};if(e.hasAttribute("class"))for(var n=e.getAttribute("class").split(/\s/).filter(Boolean).map(e=>e.trim()),a=0;a<n.length;a++)r=Object.assign(r,p["."+n[a]]);function o(n,a,o){void 0===o&&(o=function(e){return e}),e.hasAttribute(n)&&(t[a]=o(e.getAttribute(n))),r[n]&&(t[a]=o(r[n])),e.style&&""!==e.style[n]&&(t[a]=o(e.style[n]))}function i(e){return Math.max(0,Math.min(1,c(e)))}function s(e){return Math.max(0,c(e))}return e.hasAttribute("id")&&(r=Object.assign(r,p["#"+e.getAttribute("id")])),o("fill","fill"),o("fill-opacity","fillOpacity",i),o("opacity","opacity",i),o("stroke","stroke"),o("stroke-opacity","strokeOpacity",i),o("stroke-width","strokeWidth",s),o("stroke-linejoin","strokeLineJoin"),o("stroke-linecap","strokeLineCap"),o("stroke-miterlimit","strokeMiterLimit",s),o("visibility","visibility"),t}function o(e,t){return e-(t-e)}function i(e){for(var t=e.split(/[\s,]+|(?=\s?[+\-])/),r=0;r<t.length;r++){var n=t[r];if(n.indexOf(".")!==n.lastIndexOf("."))for(var a=n.split("."),o=2;o<a.length;o++)t.splice(r+o-1,0,"0."+a[o]);t[r]=c(n)}return t}var s=["mm","cm","in","pt","pc","px"],l={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function c(e){var r="px";if("string"==typeof e||e instanceof String)for(var n=0,a=s.length;n<a;n++){var o=s[n];if(e.endsWith(o)){r=o,e=e.substring(0,e.length-o.length);break}}var i=void 0;return"px"===r&&"px"!==t.defaultUnit?i=l.in[t.defaultUnit]/t.defaultDPI:(i=l[r][t.defaultUnit])<0&&(i=l[r].in*t.defaultDPI),i*parseFloat(e)}function f(e){var t=e.elements;return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function d(e){var t=e.elements;return Math.sqrt(t[3]*t[3]+t[4]*t[4])}var u=[],p={},h=[],v=new THREE.Matrix3,m=new THREE.Matrix3,x=new THREE.Matrix3,g=new THREE.Matrix3,y=new THREE.Vector2,E=new THREE.Vector3,w=new THREE.Matrix3,b=(new DOMParser).parseFromString(e,"image/svg+xml");return function e(t,n){if(1===t.nodeType){var s=function(e){if(!e.hasAttribute("transform"))return null;var t=function(e){for(var t=new THREE.Matrix3,r=v,n=e.getAttribute("transform").split(")"),a=n.length-1;a>=0;a--){var o=n[a].trim();if(""!==o){var s=o.indexOf("("),l=o.length;if(s>0&&s<l){var c=o.substr(0,s),f=i(o.substr(s+1,l-s-1));switch(r.identity(),c){case"translate":if(f.length>=1){var d=f[0],u=d;f.length>=2&&(u=f[1]),r.translate(d,u)}break;case"rotate":if(f.length>=1){var p,h=0,y=0;p=-f[0]*Math.PI/180,f.length>=3&&(h=f[1],y=f[2]),m.identity().translate(-h,-y),x.identity().rotate(p),g.multiplyMatrices(x,m),m.identity().translate(h,y),r.multiplyMatrices(m,g)}break;case"scale":if(f.length>=1){var E=f[0],w=E;f.length>=2&&(w=f[1]),r.scale(E,w)}break;case"skewX":1===f.length&&r.set(1,Math.tan(f[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===f.length&&r.set(1,0,0,Math.tan(f[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===f.length&&r.set(f[0],f[2],f[4],f[1],f[3],f[5],0,0,1)}}t.premultiply(r)}}return t}(e);h.length>0&&t.premultiply(h[h.length-1]);return w.copy(t),h.push(t),t}(t),l=null;switch(t.nodeName){case"svg":break;case"style":!function(e){if(!e.sheet||!e.sheet.cssRules||!e.sheet.cssRules.length)return;for(var t=0;t<e.sheet.cssRules.length;t++){var r=e.sheet.cssRules[t];if(1===r.type)for(var n=r.selectorText.split(/,/gm).filter(Boolean).map(e=>e.trim()),a=0;a<n.length;a++)p[n[a]]=Object.assign(p[n[a]]||{},r.style)}}(t);break;case"g":n=a(t,n);break;case"path":n=a(t,n),t.hasAttribute("d")&&(l=function(e){for(var t=new THREE.ShapePath,n=new THREE.Vector2,a=new THREE.Vector2,s=new THREE.Vector2,l=!0,c=!1,f=e.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi),d=0,u=f.length;d<u;d++){var p=f[d],h=p.charAt(0),v=p.substr(1).trim();switch(!0===l&&(c=!0,l=!1),h){case"M":for(var m=i(v),x=0,g=m.length;x<g;x+=2)n.x=m[x+0],n.y=m[x+1],a.x=n.x,a.y=n.y,0===x?t.moveTo(n.x,n.y):t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"H":for(m=i(v),x=0,g=m.length;x<g;x++)n.x=m[x],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"V":for(m=i(v),x=0,g=m.length;x<g;x++)n.y=m[x],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"L":for(m=i(v),x=0,g=m.length;x<g;x+=2)n.x=m[x+0],n.y=m[x+1],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"C":for(m=i(v),x=0,g=m.length;x<g;x+=6)t.bezierCurveTo(m[x+0],m[x+1],m[x+2],m[x+3],m[x+4],m[x+5]),a.x=m[x+2],a.y=m[x+3],n.x=m[x+4],n.y=m[x+5],0===x&&!0===c&&s.copy(n);break;case"S":for(m=i(v),x=0,g=m.length;x<g;x+=4)t.bezierCurveTo(o(n.x,a.x),o(n.y,a.y),m[x+0],m[x+1],m[x+2],m[x+3]),a.x=m[x+0],a.y=m[x+1],n.x=m[x+2],n.y=m[x+3],0===x&&!0===c&&s.copy(n);break;case"Q":for(m=i(v),x=0,g=m.length;x<g;x+=4)t.quadraticCurveTo(m[x+0],m[x+1],m[x+2],m[x+3]),a.x=m[x+0],a.y=m[x+1],n.x=m[x+2],n.y=m[x+3],0===x&&!0===c&&s.copy(n);break;case"T":for(m=i(v),x=0,g=m.length;x<g;x+=2){var y=o(n.x,a.x),E=o(n.y,a.y);t.quadraticCurveTo(y,E,m[x+0],m[x+1]),a.x=y,a.y=E,n.x=m[x+0],n.y=m[x+1],0===x&&!0===c&&s.copy(n)}break;case"A":for(m=i(v),x=0,g=m.length;x<g;x+=7){var w=n.clone();n.x=m[x+5],n.y=m[x+6],a.x=n.x,a.y=n.y,r(t,m[x],m[x+1],m[x+2],m[x+3],m[x+4],w,n),0===x&&!0===c&&s.copy(n)}break;case"m":for(m=i(v),x=0,g=m.length;x<g;x+=2)n.x+=m[x+0],n.y+=m[x+1],a.x=n.x,a.y=n.y,0===x?t.moveTo(n.x,n.y):t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"h":for(m=i(v),x=0,g=m.length;x<g;x++)n.x+=m[x],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"v":for(m=i(v),x=0,g=m.length;x<g;x++)n.y+=m[x],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"l":for(m=i(v),x=0,g=m.length;x<g;x+=2)n.x+=m[x+0],n.y+=m[x+1],a.x=n.x,a.y=n.y,t.lineTo(n.x,n.y),0===x&&!0===c&&s.copy(n);break;case"c":for(m=i(v),x=0,g=m.length;x<g;x+=6)t.bezierCurveTo(n.x+m[x+0],n.y+m[x+1],n.x+m[x+2],n.y+m[x+3],n.x+m[x+4],n.y+m[x+5]),a.x=n.x+m[x+2],a.y=n.y+m[x+3],n.x+=m[x+4],n.y+=m[x+5],0===x&&!0===c&&s.copy(n);break;case"s":for(m=i(v),x=0,g=m.length;x<g;x+=4)t.bezierCurveTo(o(n.x,a.x),o(n.y,a.y),n.x+m[x+0],n.y+m[x+1],n.x+m[x+2],n.y+m[x+3]),a.x=n.x+m[x+0],a.y=n.y+m[x+1],n.x+=m[x+2],n.y+=m[x+3],0===x&&!0===c&&s.copy(n);break;case"q":for(m=i(v),x=0,g=m.length;x<g;x+=4)t.quadraticCurveTo(n.x+m[x+0],n.y+m[x+1],n.x+m[x+2],n.y+m[x+3]),a.x=n.x+m[x+0],a.y=n.y+m[x+1],n.x+=m[x+2],n.y+=m[x+3],0===x&&!0===c&&s.copy(n);break;case"t":for(m=i(v),x=0,g=m.length;x<g;x+=2){y=o(n.x,a.x),E=o(n.y,a.y);t.quadraticCurveTo(y,E,n.x+m[x+0],n.y+m[x+1]),a.x=y,a.y=E,n.x=n.x+m[x+0],n.y=n.y+m[x+1],0===x&&!0===c&&s.copy(n)}break;case"a":for(m=i(v),x=0,g=m.length;x<g;x+=7){w=n.clone();n.x+=m[x+5],n.y+=m[x+6],a.x=n.x,a.y=n.y,r(t,m[x],m[x+1],m[x+2],m[x+3],m[x+4],w,n),0===x&&!0===c&&s.copy(n)}break;case"Z":case"z":t.currentPath.autoClose=!0,t.currentPath.curves.length>0&&(n.copy(s),t.currentPath.currentPoint.copy(n),l=!0);break;default:console.warn(p)}c=!1}return t}(t));break;case"rect":n=a(t,n),l=function(e){var t=c(e.getAttribute("x")||0),r=c(e.getAttribute("y")||0),n=c(e.getAttribute("rx")||0),a=c(e.getAttribute("ry")||0),o=c(e.getAttribute("width")),i=c(e.getAttribute("height")),s=new THREE.ShapePath;s.moveTo(t+2*n,r),s.lineTo(t+o-2*n,r),(0!==n||0!==a)&&s.bezierCurveTo(t+o,r,t+o,r,t+o,r+2*a);s.lineTo(t+o,r+i-2*a),(0!==n||0!==a)&&s.bezierCurveTo(t+o,r+i,t+o,r+i,t+o-2*n,r+i);s.lineTo(t+2*n,r+i),(0!==n||0!==a)&&s.bezierCurveTo(t,r+i,t,r+i,t,r+i-2*a);s.lineTo(t,r+2*a),(0!==n||0!==a)&&s.bezierCurveTo(t,r,t,r,t+2*n,r);return s}(t);break;case"polygon":n=a(t,n),l=function(e){function t(e,t,a){var o=c(t),i=c(a);0===n?r.moveTo(o,i):r.lineTo(o,i),n++}var r=new THREE.ShapePath,n=0;return e.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,t),r.currentPath.autoClose=!0,r}(t);break;case"polyline":n=a(t,n),l=function(e){function t(e,t,a){var o=c(t),i=c(a);0===n?r.moveTo(o,i):r.lineTo(o,i),n++}var r=new THREE.ShapePath,n=0;return e.getAttribute("points").replace(/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,t),r.currentPath.autoClose=!1,r}(t);break;case"circle":n=a(t,n),l=function(e){var t=c(e.getAttribute("cx")),r=c(e.getAttribute("cy")),n=c(e.getAttribute("r")),a=new THREE.Path;a.absarc(t,r,n,0,2*Math.PI);var o=new THREE.ShapePath;return o.subPaths.push(a),o}(t);break;case"ellipse":n=a(t,n),l=function(e){var t=c(e.getAttribute("cx")),r=c(e.getAttribute("cy")),n=c(e.getAttribute("rx")),a=c(e.getAttribute("ry")),o=new THREE.Path;o.absellipse(t,r,n,a,0,2*Math.PI);var i=new THREE.ShapePath;return i.subPaths.push(o),i}(t);break;case"line":n=a(t,n),l=function(e){var t=c(e.getAttribute("x1")),r=c(e.getAttribute("y1")),n=c(e.getAttribute("x2")),a=c(e.getAttribute("y2")),o=new THREE.ShapePath;return o.moveTo(t,r),o.lineTo(n,a),o.currentPath.autoClose=!1,o}(t)}l&&(void 0!==n.fill&&"none"!==n.fill&&l.color.setStyle(n.fill),function(e,t){function r(e){E.set(e.x,e.y,1).applyMatrix3(t),e.set(E.x,E.y)}for(var n=function(e){return 0!==e.elements[1]||0!==e.elements[3]}(t),a=e.subPaths,o=0,i=a.length;o<i;o++)for(var s=a[o].curves,l=0;l<s.length;l++){var c=s[l];c.isLineCurve?(r(c.v1),r(c.v2)):c.isCubicBezierCurve?(r(c.v0),r(c.v1),r(c.v2),r(c.v3)):c.isQuadraticBezierCurve?(r(c.v0),r(c.v1),r(c.v2)):c.isEllipseCurve&&(n&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),y.set(c.aX,c.aY),r(y),c.aX=y.x,c.aY=y.y,c.xRadius*=f(t),c.yRadius*=d(t))}}(l,w),u.push(l),l.userData={node:t,style:n});for(var b=t.childNodes,T=0;T<b.length;T++)e(b[T],n);s&&(h.pop(),h.length>0?w.copy(h[h.length-1]):w.identity())}}(b.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:u,xml:b.documentElement}}}),THREE.SVGLoader.getStrokeStyle=function(e,t,r,n,a){return{strokeColor:t=void 0!==t?t:"#000",strokeWidth:e=void 0!==e?e:1,strokeLineJoin:r=void 0!==r?r:"miter",strokeLineCap:n=void 0!==n?n:"butt",strokeMiterLimit:a=void 0!==a?a:4}},THREE.SVGLoader.pointsToStroke=function(e,t,r,n){var a=[],o=[],i=[];if(0===THREE.SVGLoader.pointsToStrokeWithBuffers(e,t,r,n,a,o,i))return null;var s=new THREE.BufferGeometry;return s.setAttribute("position",new THREE.Float32BufferAttribute(a,3)),s.setAttribute("normal",new THREE.Float32BufferAttribute(o,3)),s.setAttribute("uv",new THREE.Float32BufferAttribute(i,2)),s},THREE.SVGLoader.pointsToStrokeWithBuffers=(r=new THREE.Vector2,n=new THREE.Vector2,a=new THREE.Vector2,o=new THREE.Vector2,i=new THREE.Vector2,s=new THREE.Vector2,l=new THREE.Vector2,c=new THREE.Vector2,f=new THREE.Vector2,d=new THREE.Vector2,u=new THREE.Vector2,p=new THREE.Vector2,h=new THREE.Vector2,v=new THREE.Vector2,m=new THREE.Vector2,x=new THREE.Vector2,g=new THREE.Vector2,function(e,t,y,E,w,b,T,_){y=void 0!==y?y:12,E=void 0!==E?E:.001,_=void 0!==_?_:0;var S=(e=function(e){for(var t=!1,r=1,n=e.length-1;r<n;r++)if(e[r].distanceTo(e[r+1])<E){t=!0;break}if(!t)return e;var a=[];for(a.push(e[0]),r=1,n=e.length-1;r<n;r++)e[r].distanceTo(e[r+1])>=E&&a.push(e[r]);return a.push(e[e.length-1]),a}(e)).length;if(S<2)return 0;var R,A,M,C,L,H=e[0].equals(e[S-1]),P=e[0],z=t.strokeWidth/2,k=1/(S-1),N=0,D=!1,F=0,I=3*_,O=2*_;K(e[0],e[1],r).multiplyScalar(z),c.copy(e[0]).sub(r),f.copy(e[0]).add(r),d.copy(c),u.copy(f);for(var U=1;U<S;U++){R=e[U],A=U===S-1?H?e[1]:void 0:e[U+1];var G=r;K(P,R,G),a.copy(G).multiplyScalar(z),p.copy(R).sub(a),h.copy(R).add(a);var B=N+k;if(M=!1,void 0!==A){K(R,A,n),a.copy(n).multiplyScalar(z),v.copy(R).sub(a),m.copy(R).add(a),C=!0,a.subVectors(A,P),G.dot(a)<0&&(C=!1),1===U&&(D=C),a.subVectors(A,R),a.normalize();var V=Math.abs(G.dot(a));if(0!==V){var j=z/V;a.multiplyScalar(-j),o.subVectors(R,P),i.copy(o).setLength(j).add(a),x.copy(i).negate();var W=i.length(),q=o.length();o.divideScalar(q),s.subVectors(A,R);var X=s.length();switch(s.divideScalar(X),o.dot(x)<q&&s.dot(x)<X&&(M=!0),g.copy(i).add(R),x.add(R),L=!1,M?C?(m.copy(x),h.copy(x)):(v.copy(x),p.copy(x)):ee(),t.strokeLineJoin){case"bevel":te(C,M,B);break;case"round":re(C,M),C?$(R,p,v,B,0):$(R,m,h,B,1);break;case"miter":case"miter-clip":default:var Y=z*t.strokeMiterLimit/W;if(Y<1){if("miter-clip"!==t.strokeLineJoin){te(C,M,B);break}re(C,M),C?(s.subVectors(g,p).multiplyScalar(Y).add(p),l.subVectors(g,v).multiplyScalar(Y).add(v),J(p,B,0),J(s,B,0),J(R,B,.5),J(R,B,.5),J(s,B,0),J(l,B,0),J(R,B,.5),J(l,B,0),J(v,B,0)):(s.subVectors(g,h).multiplyScalar(Y).add(h),l.subVectors(g,m).multiplyScalar(Y).add(m),J(h,B,1),J(s,B,1),J(R,B,.5),J(R,B,.5),J(s,B,1),J(l,B,1),J(R,B,.5),J(l,B,1),J(m,B,1))}else M?(C?(J(f,N,1),J(c,N,0),J(g,B,0),J(f,N,1),J(g,B,0),J(x,B,1)):(J(f,N,1),J(c,N,0),J(g,B,1),J(c,N,0),J(x,B,0),J(g,B,1)),C?v.copy(g):m.copy(g)):C?(J(p,B,0),J(g,B,0),J(R,B,.5),J(R,B,.5),J(g,B,0),J(v,B,0)):(J(h,B,1),J(g,B,1),J(R,B,.5),J(R,B,.5),J(g,B,1),J(m,B,1)),L=!0}}else ee()}else ee();H||U!==S-1||ne(e[0],d,u,C,!0,N),N=B,P=R,c.copy(v),f.copy(m)}if(H){if(M&&w){var Z=g,Q=x;D!==C&&(Z=x,Q=g),C?(L||D)&&(Q.toArray(w,0),Q.toArray(w,9),L&&Z.toArray(w,3)):!L&&D||(Q.toArray(w,3),Q.toArray(w,9),L&&Z.toArray(w,0))}}else ne(R,p,h,C,!1,B);return F;function K(e,t,r){return r.subVectors(t,e),r.set(-r.y,r.x).normalize()}function J(e,t,r){w&&(w[I]=e.x,w[I+1]=e.y,w[I+2]=0,b&&(b[I]=0,b[I+1]=0,b[I+2]=1),I+=3,T&&(T[O]=t,T[O+1]=r,O+=2)),F+=3}function $(e,t,i,s,l){r.copy(t).sub(e).normalize(),n.copy(i).sub(e).normalize();var c=Math.PI,f=r.dot(n);Math.abs(f)<1&&(c=Math.abs(Math.acos(f))),c/=y,a.copy(t);for(var d=0,u=y-1;d<u;d++)o.copy(a).rotateAround(e,c),J(a,s,l),J(o,s,l),J(e,s,.5),a.copy(o);J(o,s,l),J(i,s,l),J(e,s,.5)}function ee(){J(f,N,1),J(c,N,0),J(p,B,0),J(f,N,1),J(p,B,1),J(h,B,0)}function te(e,t,r){t?e?(J(f,N,1),J(c,N,0),J(p,B,0),J(f,N,1),J(p,B,0),J(x,B,1),J(p,r,0),J(v,r,0),J(x,r,.5)):(J(f,N,1),J(c,N,0),J(h,B,1),J(c,N,0),J(x,B,0),J(h,B,1),J(h,r,1),J(m,r,0),J(x,r,.5)):e?(J(p,r,0),J(v,r,0),J(R,r,.5)):(J(h,r,1),J(m,r,0),J(R,r,.5))}function re(e,t){t&&(e?(J(f,N,1),J(c,N,0),J(p,B,0),J(f,N,1),J(p,B,0),J(x,B,1),J(p,N,0),J(R,B,.5),J(x,B,1),J(R,B,.5),J(v,N,0),J(x,B,1)):(J(f,N,1),J(c,N,0),J(h,B,1),J(c,N,0),J(x,B,0),J(h,B,1),J(h,N,1),J(x,B,0),J(R,B,.5),J(R,B,.5),J(x,B,0),J(m,N,1)))}function ne(e,i,s,l,c,f){switch(t.strokeLineCap){case"round":c?$(e,s,i,f,.5):$(e,i,s,f,.5);break;case"square":if(c)r.subVectors(i,e),n.set(r.y,-r.x),a.addVectors(r,n).add(e),o.subVectors(n,r).add(e),l?(a.toArray(w,3),o.toArray(w,0),o.toArray(w,9)):(a.toArray(w,3),a.toArray(w,9),o.toArray(w,0));else{r.subVectors(s,e),n.set(r.y,-r.x),a.addVectors(r,n).add(e),o.subVectors(n,r).add(e);var d=w.length;l?(a.toArray(w,d-3),o.toArray(w,d-6),o.toArray(w,d-12)):(a.toArray(w,d-6),o.toArray(w,d-3),o.toArray(w,d-12))}}}})},function(e,t){THREE.TDSLoader=function(e){THREE.Loader.call(this,e),this.debug=!1,this.group=null,this.position=0,this.materials=[],this.meshes=[]},THREE.TDSLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.TDSLoader,load:function(e,t,r,n){var a=this,o=""===a.path?THREE.LoaderUtils.extractUrlBase(e):a.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.load(e,(function(r){try{t(a.parse(r,o))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e,t){this.group=new THREE.Group,this.position=0,this.materials=[],this.meshes=[],this.readFile(e,t);for(var r=0;r<this.meshes.length;r++)this.group.add(this.meshes[r]);return this.group},readFile:function(e,t){var i=new DataView(e),s=this.readChunk(i);if(s.id===n||s.id===a||s.id===r)for(var l=this.nextChunk(i,s);0!==l;){if(l===o){var c=this.readDWord(i);this.debugMessage("3DS file version: "+c)}else l===f?(this.resetPosition(i),this.readMeshData(i,t)):this.debugMessage("Unknown main chunk: "+l.toString(16));l=this.nextChunk(i,s)}this.debugMessage("Parsed "+this.meshes.length+" meshes")},readMeshData:function(e,t){for(var r=this.readChunk(e),n=this.nextChunk(e,r);0!==n;){if(n===d){var a=+this.readDWord(e);this.debugMessage("Mesh Version: "+a)}else if(n===u){var o=this.readFloat(e);this.debugMessage("Master scale: "+o),this.group.scale.set(o,o,o)}else n===z?(this.debugMessage("Named Object"),this.resetPosition(e),this.readNamedObject(e)):n===p?(this.debugMessage("Material"),this.resetPosition(e),this.readMaterialEntry(e,t)):this.debugMessage("Unknown MDATA chunk: "+n.toString(16));n=this.nextChunk(e,r)}},readNamedObject:function(e){var t=this.readChunk(e),r=this.readString(e,64);t.cur=this.position;for(var n=this.nextChunk(e,t);0!==n;){if(n===k){this.resetPosition(e);var a=this.readMesh(e);a.name=r,this.meshes.push(a)}else this.debugMessage("Unknown named object chunk: "+n.toString(16));n=this.nextChunk(e,t)}this.endChunk(t)},readMaterialEntry:function(e,t){for(var r=this.readChunk(e),n=this.nextChunk(e,r),a=new THREE.MeshPhongMaterial;0!==n;){if(n===h)a.name=this.readString(e,64),this.debugMessage("   Name: "+a.name);else if(n===b)this.debugMessage("   Wireframe"),a.wireframe=!0;else if(n===T){var o=this.readByte(e);a.wireframeLinewidth=o,this.debugMessage("   Wireframe Thickness: "+o)}else if(n===E)a.side=THREE.DoubleSide,this.debugMessage("   DoubleSided");else if(n===w)this.debugMessage("   Additive Blending"),a.blending=THREE.AdditiveBlending;else if(n===m)this.debugMessage("   Diffuse Color"),a.color=this.readColor(e);else if(n===x)this.debugMessage("   Specular Color"),a.specular=this.readColor(e);else if(n===v)this.debugMessage("   Ambient color"),a.color=this.readColor(e);else if(n===g){var i=this.readWord(e);a.shininess=i,this.debugMessage("   Shininess : "+i)}else if(n===y){var s=this.readWord(e);a.opacity=.01*s,this.debugMessage("  Opacity : "+s),a.transparent=s<100}else n===_?(this.debugMessage("   ColorMap"),this.resetPosition(e),a.map=this.readMap(e,t)):n===R?(this.debugMessage("   BumpMap"),this.resetPosition(e),a.bumpMap=this.readMap(e,t)):n===S?(this.debugMessage("   OpacityMap"),this.resetPosition(e),a.alphaMap=this.readMap(e,t)):n===A?(this.debugMessage("   SpecularMap"),this.resetPosition(e),a.specularMap=this.readMap(e,t)):this.debugMessage("   Unknown material chunk: "+n.toString(16));n=this.nextChunk(e,r)}this.endChunk(r),this.materials[a.name]=a},readMesh:function(e){var t=this.readChunk(e),r=this.nextChunk(e,t),n=new THREE.BufferGeometry,a=[],o=new THREE.MeshPhongMaterial,i=new THREE.Mesh(n,o);for(i.name="mesh";0!==r;){if(r===N){var s=this.readWord(e);this.debugMessage("   Vertex: "+s);for(var l=[],c=0;c<s;c++)l.push(this.readFloat(e)),l.push(this.readFloat(e)),l.push(this.readFloat(e));n.setAttribute("position",new THREE.Float32BufferAttribute(l,3))}else if(r===D)this.resetPosition(e),this.readFaceArray(e,i);else if(r===I){var f=this.readWord(e);this.debugMessage("   UV: "+f);for(a=[],c=0;c<f;c++)a.push(this.readFloat(e)),a.push(this.readFloat(e));n.setAttribute("uv",new THREE.Float32BufferAttribute(a,2))}else if(r===O){this.debugMessage("   Tranformation Matrix (TODO)");var d=[];for(c=0;c<12;c++)d[c]=this.readFloat(e);var u=new THREE.Matrix4;u.elements[0]=d[0],u.elements[1]=d[6],u.elements[2]=d[3],u.elements[3]=d[9],u.elements[4]=d[2],u.elements[5]=d[8],u.elements[6]=d[5],u.elements[7]=d[11],u.elements[8]=d[1],u.elements[9]=d[7],u.elements[10]=d[4],u.elements[11]=d[10],u.elements[12]=0,u.elements[13]=0,u.elements[14]=0,u.elements[15]=1,u.transpose();var p=new THREE.Matrix4;p.getInverse(u),n.applyMatrix4(p),u.decompose(i.position,i.quaternion,i.scale)}else this.debugMessage("   Unknown mesh chunk: "+r.toString(16));r=this.nextChunk(e,t)}return this.endChunk(t),n.computeVertexNormals(),i},readFaceArray:function(e,t){var r=this.readChunk(e),n=this.readWord(e);this.debugMessage("   Faces: "+n);for(var a=[],o=0;o<n;++o)a.push(this.readWord(e),this.readWord(e),this.readWord(e)),this.readWord(e);for(t.geometry.setIndex(a);this.position<r.end;){if((r=this.readChunk(e)).id===F){this.debugMessage("      Material Group"),this.resetPosition(e);var i=this.readMaterialGroup(e),s=this.materials[i.name];void 0!==s&&(t.material=s,""===s.name&&(s.name=t.name))}else this.debugMessage("      Unknown face array chunk: "+r.toString(16));this.endChunk(r)}this.endChunk(r)},readMap:function(e,t){var r=this.readChunk(e),n=this.nextChunk(e,r),a={},o=new THREE.TextureLoader(this.manager);for(o.setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);0!==n;){if(n===M){var i=this.readString(e,128);a=o.load(i),this.debugMessage("      File: "+t+i)}else n===H?(a.offset.x=this.readFloat(e),this.debugMessage("      OffsetX: "+a.offset.x)):n===P?(a.offset.y=this.readFloat(e),this.debugMessage("      OffsetY: "+a.offset.y)):n===C?(a.repeat.x=this.readFloat(e),this.debugMessage("      RepeatX: "+a.repeat.x)):n===L?(a.repeat.y=this.readFloat(e),this.debugMessage("      RepeatY: "+a.repeat.y)):this.debugMessage("      Unknown map chunk: "+n.toString(16));n=this.nextChunk(e,r)}return this.endChunk(r),a},readMaterialGroup:function(e){this.readChunk(e);var t=this.readString(e,64),r=this.readWord(e);this.debugMessage("         Name: "+t),this.debugMessage("         Faces: "+r);for(var n=[],a=0;a<r;++a)n.push(this.readWord(e));return{name:t,index:n}},readColor:function(e){var t=this.readChunk(e),r=new THREE.Color;if(t.id===s||t.id===l){var n=this.readByte(e),a=this.readByte(e),o=this.readByte(e);r.setRGB(n/255,a/255,o/255),this.debugMessage("      Color: "+r.r+", "+r.g+", "+r.b)}else if(t.id===i||t.id===c){n=this.readFloat(e),a=this.readFloat(e),o=this.readFloat(e);r.setRGB(n,a,o),this.debugMessage("      Color: "+r.r+", "+r.g+", "+r.b)}else this.debugMessage("      Unknown color chunk: "+t.toString(16));return this.endChunk(t),r},readChunk:function(e){var t={};return t.cur=this.position,t.id=this.readWord(e),t.size=this.readDWord(e),t.end=t.cur+t.size,t.cur+=6,t},endChunk:function(e){this.position=e.end},nextChunk:function(e,t){if(t.cur>=t.end)return 0;this.position=t.cur;try{var r=this.readChunk(e);return t.cur+=r.size,r.id}catch(e){return this.debugMessage("Unable to read chunk at "+this.position),0}},resetPosition:function(){this.position-=6},readByte:function(e){var t=e.getUint8(this.position,!0);return this.position+=1,t},readFloat:function(e){try{var t=e.getFloat32(this.position,!0);return this.position+=4,t}catch(t){this.debugMessage(t+" "+this.position+" "+e.byteLength)}},readInt:function(e){var t=e.getInt32(this.position,!0);return this.position+=4,t},readShort:function(e){var t=e.getInt16(this.position,!0);return this.position+=2,t},readDWord:function(e){var t=e.getUint32(this.position,!0);return this.position+=4,t},readWord:function(e){var t=e.getUint16(this.position,!0);return this.position+=2,t},readString:function(e,t){for(var r="",n=0;n<t;n++){var a=this.readByte(e);if(!a)break;r+=String.fromCharCode(a)}return r},debugMessage:function(e){this.debug&&console.log(e)}});var r=19789,n=15786,a=49725,o=2,i=16,s=17,l=18,c=19,f=15677,d=15678,u=256,p=45055,h=40960,v=40976,m=40992,x=41008,g=41024,y=41040,E=41089,w=41091,b=41093,T=41095,_=41472,S=41488,R=41520,A=41476,M=41728,C=41812,L=41814,H=41816,P=41818,z=16384,k=16640,N=16656,D=16672,F=16688,I=16704,O=16736},function(e,t,r){"use strict";r.r(t);var n=r(2);THREE.VTKLoader=function(e){THREE.Loader.call(this,e)},THREE.VTKLoader.prototype=Object.assign(Object.create(THREE.Loader.prototype),{constructor:THREE.VTKLoader,load:function(e,t,r,n){var a=this,o=new THREE.FileLoader(a.manager);o.setPath(a.path),o.setResponseType("arraybuffer"),o.setRequestHeader(a.requestHeader),o.load(e,(function(r){try{t(a.parse(r))}catch(t){n?n(t):console.error(t),a.manager.itemError(e)}}),r,n)},parse:function(e){function t(e,t){var r=e.length,n=new Int32Array(r+t.length);return n.set(e),n.set(t,r),n}function r(e){for(var t="",r=new Uint8Array(e),n=0,a=r.length;a--;)t+=String.fromCharCode(r[n++]);return t}var a=THREE.LoaderUtils.decodeText(new Uint8Array(e,0,250)).split("\n");return-1!==a[0].indexOf("xml")?function(e){function r(e){var t,r,n,a,o,i,s="undefined"!=typeof Uint8Array?Uint8Array:Array,l=[],c=[],f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",d=f.length;for(t=0;t<d;t++)l[t]=f[t];for(t=0;t<d;++t)c[f.charCodeAt(t)]=t;if(c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63,(d=e.length)%4>0)throw new Error("Invalid string. Length must be a multiple of 4");i=new s(3*d/4-(o="="===e[d-2]?2:"="===e[d-1]?1:0)),n=o>0?d-4:d;var u=0;for(t=0,r=0;t<n;t+=4,r+=3)a=c[e.charCodeAt(t)]<<18|c[e.charCodeAt(t+1)]<<12|c[e.charCodeAt(t+2)]<<6|c[e.charCodeAt(t+3)],i[u++]=(16711680&a)>>16,i[u++]=(65280&a)>>8,i[u++]=255&a;return 2===o?(a=c[e.charCodeAt(t)]<<2|c[e.charCodeAt(t+1)]>>4,i[u++]=255&a):1===o&&(a=c[e.charCodeAt(t)]<<10|c[e.charCodeAt(t+1)]<<4|c[e.charCodeAt(t+2)]>>2,i[u++]=a>>8&255,i[u++]=255&a),i}function a(e,a){var o,s,l,c,f=0;if("UInt64"===i.attributes.header_type?f=8:"UInt32"===i.attributes.header_type&&(f=4),"binary"===e.attributes.format&&a){var d,u,p,h,v,m;if("Float32"===e.attributes.type)var x=new Float32Array;else if("Int64"===e.attributes.type)x=new Int32Array;u=(d=r(e["#text"]))[0];for(var g=1;g<f-1;g++)u|=d[g]<<g*f;h=(u+3)*f,m=h+=h%3>0?3-h%3:0,(v=[]).push(m),p=3*f;for(g=0;g<u;g++){for(var y=d[g*f+p],E=1;E<f-1;E++)y|=d[g*f+p+E]<<8*E;m+=y,v.push(m)}for(g=0;g<v.length-1;g++){w=(w=new n.Zlib.Inflate(d.slice(v[g],v[g+1]),{resize:!0,verify:!0}).decompress()).buffer,"Float32"===e.attributes.type?(w=new Float32Array(w),s=w,l=void 0,c=void 0,l=(o=x).length,(c=new Float32Array(l+s.length)).set(o),c.set(s,l),x=c):"Int64"===e.attributes.type&&(x=t(x,w=new Int32Array(w)))}delete e["#text"],"Int64"===e.attributes.type&&"binary"===e.attributes.format&&(x=x.filter((function(e,t){if(t%2!=1)return!0})))}else{if("binary"!==e.attributes.format||a)if(e["#text"])var w=e["#text"].split(/\s+/).filter((function(e){if(""!==e)return e}));else w=new Int32Array(0).buffer;else w=(w=r(e["#text"])).slice(f).buffer;if(delete e["#text"],"Float32"===e.attributes.type)x=new Float32Array(w);else if("Int32"===e.attributes.type)x=new Int32Array(w);else if("Int64"===e.attributes.type){x=new Int32Array(w);"binary"===e.attributes.format&&(x=x.filter((function(e,t){if(t%2!=1)return!0})))}}return x}var o=null;if(window.DOMParser)try{o=(new DOMParser).parseFromString(e,"text/xml")}catch(e){o=null}else{if(!window.ActiveXObject)throw new Error("Cannot parse xml string!");try{if((o=new ActiveXObject("Microsoft.XMLDOM")).async=!1,!o.loadXML())throw new Error(o.parseError.reason+o.parseError.srcText)}catch(e){o=null}}var i=function e(t){var r={};if(1===t.nodeType){if(t.attributes&&t.attributes.length>0){r.attributes={};for(var n=0;n<t.attributes.length;n++){var a=t.attributes.item(n);r.attributes[a.nodeName]=a.nodeValue.trim()}}}else 3===t.nodeType&&(r=t.nodeValue.trim());if(t.hasChildNodes())for(var o=0;o<t.childNodes.length;o++){var i=t.childNodes.item(o),s=i.nodeName;if(void 0===r[s]){""!==(c=e(i))&&(r[s]=c)}else{if(void 0===r[s].push){var l=r[s];r[s]=[l]}var c;""!==(c=e(i))&&r[s].push(c)}}return r}(o.documentElement),s=[],l=[],c=[];if(i.PolyData){for(var f=i.PolyData.Piece,d=i.attributes.hasOwnProperty("compressor"),u=["PointData","Points","Strips","Polys"],p=0,h=u.length;p<h;){var v=f[u[p]];if(v&&v.DataArray){if("[object Array]"===Object.prototype.toString.call(v.DataArray))var m=v.DataArray;else m=[v.DataArray];for(var x=0,g=m.length;x<g;)"#text"in m[x]&&m[x]["#text"].length>0&&(m[x].text=a(m[x],d)),x++;switch(u[p]){case"PointData":var y=parseInt(f.attributes.NumberOfPoints),E=v.attributes.Normals;if(y>0)for(var w=0,b=m.length;w<b;w++)if(E===m[w].attributes.Name){var T=m[w].attributes.NumberOfComponents;(l=new Float32Array(y*T)).set(m[w].text,0)}break;case"Points":if((y=parseInt(f.attributes.NumberOfPoints))>0){T=v.DataArray.attributes.NumberOfComponents;(s=new Float32Array(y*T)).set(v.DataArray.text,0)}break;case"Strips":var _=parseInt(f.attributes.NumberOfStrips);if(_>0){var S=new Int32Array(v.DataArray[0].text.length),R=new Int32Array(v.DataArray[1].text.length);S.set(v.DataArray[0].text,0),R.set(v.DataArray[1].text,0);var A=_+S.length;c=new Uint32Array(3*A-9*_);var M=0;for(w=0,b=_;w<b;w++){for(var C=[],L=0,H=R[w],P=0;L<H-P;L++)C.push(S[L]),w>0&&(P=R[w-1]);var z=0;for(H=R[w],P=0;z<H-P-2;z++)z%2?(c[M++]=C[z],c[M++]=C[z+2],c[M++]=C[z+1]):(c[M++]=C[z],c[M++]=C[z+1],c[M++]=C[z+2]),w>0&&(P=R[w-1])}}break;case"Polys":var k=parseInt(f.attributes.NumberOfPolys);if(k>0){S=new Int32Array(v.DataArray[0].text.length),R=new Int32Array(v.DataArray[1].text.length);S.set(v.DataArray[0].text,0),R.set(v.DataArray[1].text,0);A=k+S.length;c=new Uint32Array(3*A-9*k);M=0;var N=0;for(w=0,b=k,P=0;w<b;){var D=[];for(L=0,H=R[w];L<H-P;)D.push(S[N++]),L++;for(z=1;z<H-P-1;)c[M++]=D[0],c[M++]=D[z],c[M++]=D[z+1],z++;P=R[++w-1]}}}}p++}var F=new THREE.BufferGeometry;return F.setIndex(new THREE.BufferAttribute(c,1)),F.setAttribute("position",new THREE.BufferAttribute(s,3)),l.length===s.length&&F.setAttribute("normal",new THREE.BufferAttribute(l,3)),F}throw new Error("Unsupported DATASET type")}(r(e)):a[2].includes("ASCII")?function(e){for(var t,r=[],n=[],a=[],o=[],i=/^[^\d.\s-]+/,s=/(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g,l=/^(\d+)\s+([\s\d]*)/,c=/^POINTS /,f=/^POLYGONS /,d=/^TRIANGLE_STRIPS /,u=/^POINT_DATA[ ]+(\d+)/,p=/^CELL_DATA[ ]+(\d+)/,h=/^COLOR_SCALARS[ ]+(\w+)[ ]+3/,v=/^NORMALS[ ]+(\w+)[ ]+(\w+)/,m=!1,x=!1,g=!1,y=!1,E=!1,w=!1,b=!1,T=e.split("\n"),_=0,S=T.length;_<S;_++){var R=T[_].trim();if(0===R.indexOf("DATASET")){var A=R.split(" ")[1];if("POLYDATA"!==A)throw new Error("Unsupported DATASET type: "+A)}else if(m)for(;null!==(t=s.exec(R))&&null===i.exec(R);){var M=parseFloat(t[1]),C=parseFloat(t[2]),L=parseFloat(t[3]);n.push(M,C,L)}else if(x){if(null!==(t=l.exec(R))){var H=parseInt(t[1]),P=t[2].split(/\s+/);if(H>=3)for(var z=parseInt(P[0]),k=1,N=0;N<H-2;++N)D=parseInt(P[k]),F=parseInt(P[k+1]),r.push(z,D,F),k++}}else if(g){if(null!==(t=l.exec(R))){H=parseInt(t[1]),P=t[2].split(/\s+/);if(H>=3){var D,F;for(N=0;N<H-2;N++)N%2==1?(z=parseInt(P[N]),D=parseInt(P[N+2]),F=parseInt(P[N+1]),r.push(z,D,F)):(z=parseInt(P[N]),D=parseInt(P[N+1]),F=parseInt(P[N+2]),r.push(z,D,F))}}}else if(y||E)if(w)for(;null!==(t=s.exec(R))&&null===i.exec(R);){var I=parseFloat(t[1]),O=parseFloat(t[2]),U=parseFloat(t[3]);a.push(I,O,U)}else if(b)for(;null!==(t=s.exec(R))&&null===i.exec(R);){var G=parseFloat(t[1]),B=parseFloat(t[2]),V=parseFloat(t[3]);o.push(G,B,V)}null!==f.exec(R)?(x=!0,m=!1,g=!1):null!==c.exec(R)?(x=!1,m=!0,g=!1):null!==d.exec(R)?(x=!1,m=!1,g=!0):null!==u.exec(R)?(y=!0,m=!1,x=!1,g=!1):null!==p.exec(R)?(E=!0,m=!1,x=!1,g=!1):null!==h.exec(R)?(w=!0,b=!1,m=!1,x=!1,g=!1):null!==v.exec(R)&&(b=!0,w=!1,m=!1,x=!1,g=!1)}var j=new THREE.BufferGeometry;if(j.setIndex(r),j.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),o.length===n.length&&j.setAttribute("normal",new THREE.Float32BufferAttribute(o,3)),a.length!==r.length)a.length===n.length&&j.setAttribute("color",new THREE.Float32BufferAttribute(a,3));else{var W=(j=j.toNonIndexed()).attributes.position.count/3;if(a.length===3*W){var q=[];for(_=0;_<W;_++){I=a[3*_+0],O=a[3*_+1],U=a[3*_+2];q.push(I,O,U),q.push(I,O,U),q.push(I,O,U)}j.setAttribute("color",new THREE.Float32BufferAttribute(q,3))}}return j}(r(e)):function(e){var t,r,n,a,o,i,s,l=new Uint8Array(e),c=new DataView(e),f=[],d=[],u=[],p=[],h=0;function v(e,t){for(var r=t,n=e[r],a=[];10!==n;)a.push(String.fromCharCode(n)),n=e[++r];return{start:t,end:r,next:r+1,parsedString:a.join("")}}for(;;){if(0===(s=(i=v(l,h)).parsedString).indexOf("DATASET")){var m=s.split(" ")[1];if("POLYDATA"!==m)throw new Error("Unsupported DATASET type: "+m)}else if(0===s.indexOf("POINTS")){for(p.push(s),t=4*(a=parseInt(s.split(" ")[1],10))*3,f=new Float32Array(3*a),r=i.next,n=0;n<a;n++)f[3*n]=c.getFloat32(r,!1),f[3*n+1]=c.getFloat32(r+4,!1),f[3*n+2]=c.getFloat32(r+8,!1),r+=12;i.next=i.next+t+1}else if(0===s.indexOf("TRIANGLE_STRIPS")){var x=parseInt(s.split(" ")[1],10);t=4*(b=parseInt(s.split(" ")[2],10)),u=new Uint32Array(3*b-9*x);var g=0;for(r=i.next,n=0;n<x;n++){var y=c.getInt32(r,!1),E=[];for(r+=4,o=0;o<y;o++)E.push(c.getInt32(r,!1)),r+=4;for(var w=0;w<y-2;w++)w%2?(u[g++]=E[w],u[g++]=E[w+2],u[g++]=E[w+1]):(u[g++]=E[w],u[g++]=E[w+1],u[g++]=E[w+2])}i.next=i.next+t+1}else if(0===s.indexOf("POLYGONS")){var b;x=parseInt(s.split(" ")[1],10);t=4*(b=parseInt(s.split(" ")[2],10)),u=new Uint32Array(3*b-9*x);g=0;for(r=i.next,n=0;n<x;n++){y=c.getInt32(r,!1),E=[];for(r+=4,o=0;o<y;o++)E.push(c.getInt32(r,!1)),r+=4;for(w=1;w<y-1;w++)u[g++]=E[0],u[g++]=E[w],u[g++]=E[w+1]}i.next=i.next+t+1}else if(0===s.indexOf("POINT_DATA")){for(a=parseInt(s.split(" ")[1],10),i=v(l,i.next),t=4*a*3,d=new Float32Array(3*a),r=i.next,n=0;n<a;n++)d[3*n]=c.getFloat32(r,!1),d[3*n+1]=c.getFloat32(r+4,!1),d[3*n+2]=c.getFloat32(r+8,!1),r+=12;i.next=i.next+t}if((h=i.next)>=l.byteLength)break}var T=new THREE.BufferGeometry;return T.setIndex(new THREE.BufferAttribute(u,1)),T.setAttribute("position",new THREE.BufferAttribute(f,3)),d.length===f.length&&T.setAttribute("normal",new THREE.BufferAttribute(d,3)),T}(e)}})},function(e,t){THREE.UnpackDepthRGBAShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","#include <packing>","void main() {","\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );","\tgl_FragColor = vec4( vec3( depth ), opacity );","}"].join("\n")}},function(e,t){var r,n,a;THREE.EffectComposer=function(e,t){if(this.renderer=e,void 0===t){var r={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1},n=e.getSize(new THREE.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=n.width,this._height=n.height,(t=new THREE.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,r)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),void 0===THREE.ShaderPass&&console.error("THREE.EffectComposer relies on THREE.ShaderPass"),this.copyPass=new THREE.ShaderPass(THREE.CopyShader),this.clock=new THREE.Clock},Object.assign(THREE.EffectComposer.prototype,{swapBuffers:function(){var e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e},addPass:function(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)},insertPass:function(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)},isLastEnabledPass:function(e){for(var t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0},render:function(e){void 0===e&&(e=this.clock.getDelta());var t,r,n=this.renderer.getRenderTarget(),a=!1,o=this.passes.length;for(r=0;r<o;r++)if(!1!==(t=this.passes[r]).enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(r),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,a),t.needsSwap){if(a){var i=this.renderer.getContext(),s=this.renderer.state.buffers.stencil;s.setFunc(i.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),s.setFunc(i.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==THREE.MaskPass&&(t instanceof THREE.MaskPass?a=!0:t instanceof THREE.ClearMaskPass&&(a=!1))}this.renderer.setRenderTarget(n)},reset:function(e){if(void 0===e){var t=this.renderer.getSize(new THREE.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(e,t){this._width=e,this._height=t;var r=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget1.setSize(r,n),this.renderTarget2.setSize(r,n);for(var a=0;a<this.passes.length;a++)this.passes[a].setSize(r,n)},setPixelRatio:function(e){this._pixelRatio=e,this.setSize(this._width,this._height)}}),THREE.Pass=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1},Object.assign(THREE.Pass.prototype,{setSize:function(){},render:function(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}),THREE.Pass.FullScreenQuad=(r=new THREE.OrthographicCamera(-1,1,1,-1,0,1),n=new THREE.PlaneBufferGeometry(2,2),a=function(e){this._mesh=new THREE.Mesh(n,e)},Object.defineProperty(a.prototype,"material",{get:function(){return this._mesh.material},set:function(e){this._mesh.material=e}}),Object.assign(a.prototype,{dispose:function(){this._mesh.geometry.dispose()},render:function(e){e.render(this._mesh,r)}}),a)},function(e,t){THREE.RenderPass=function(e,t,r,n,a){THREE.Pass.call(this),this.scene=e,this.camera=t,this.overrideMaterial=r,this.clearColor=n,this.clearAlpha=void 0!==a?a:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1},THREE.RenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.RenderPass,render:function(e,t,r){var n,a,o,i=e.autoClear;e.autoClear=!1,void 0!==this.overrideMaterial&&(o=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(n=e.getClearColor().getHex(),a=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:r),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(n,a),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=o),e.autoClear=i}})},function(e,t){THREE.MaskPass=function(e,t){THREE.Pass.call(this),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1},THREE.MaskPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.MaskPass,render:function(e,t,r){var n,a,o=e.getContext(),i=e.state;i.buffers.color.setMask(!1),i.buffers.depth.setMask(!1),i.buffers.color.setLocked(!0),i.buffers.depth.setLocked(!0),this.inverse?(n=0,a=1):(n=1,a=0),i.buffers.stencil.setTest(!0),i.buffers.stencil.setOp(o.REPLACE,o.REPLACE,o.REPLACE),i.buffers.stencil.setFunc(o.ALWAYS,n,4294967295),i.buffers.stencil.setClear(a),i.buffers.stencil.setLocked(!0),e.setRenderTarget(r),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),i.buffers.color.setLocked(!1),i.buffers.depth.setLocked(!1),i.buffers.stencil.setLocked(!1),i.buffers.stencil.setFunc(o.EQUAL,1,4294967295),i.buffers.stencil.setOp(o.KEEP,o.KEEP,o.KEEP),i.buffers.stencil.setLocked(!0)}}),THREE.ClearMaskPass=function(){THREE.Pass.call(this),this.needsSwap=!1},THREE.ClearMaskPass.prototype=Object.create(THREE.Pass.prototype),Object.assign(THREE.ClearMaskPass.prototype,{render:function(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}})},function(e,t){THREE.OutlinePass=function(e,t,r,n){this.renderScene=t,this.renderCamera=r,this.selectedObjects=void 0!==n?n:[],this.visibleEdgeColor=new THREE.Color(1,1,1),this.hiddenEdgeColor=new THREE.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,THREE.Pass.call(this),this.resolution=void 0!==e?new THREE.Vector2(e.x,e.y):new THREE.Vector2(256,256);var a={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},o=Math.round(this.resolution.x/this.downSampleRatio),i=Math.round(this.resolution.y/this.downSampleRatio);this.maskBufferMaterial=new THREE.MeshBasicMaterial({color:16777215}),this.maskBufferMaterial.side=THREE.DoubleSide,this.renderTargetMaskBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,a),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new THREE.MeshDepthMaterial,this.depthMaterial.side=THREE.DoubleSide,this.depthMaterial.depthPacking=THREE.RGBADepthPacking,this.depthMaterial.blending=THREE.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=THREE.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(e,t){var r=t.isPerspectiveCamera?"perspective":"orthographic";return e.replace(/DEPTH_TO_VIEW_Z/g,r+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,a),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new THREE.WebGLRenderTarget(o,i,a),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new THREE.WebGLRenderTarget(o,i,a),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new THREE.WebGLRenderTarget(Math.round(o/2),Math.round(i/2),a),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new THREE.WebGLRenderTarget(o,i,a),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new THREE.WebGLRenderTarget(Math.round(o/2),Math.round(i/2),a),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(o,i),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(o/2),Math.round(i/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===THREE.CopyShader&&console.error("THREE.OutlinePass relies on THREE.CopyShader");var s=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(s.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,blending:THREE.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.fsQuad=new THREE.Pass.FullScreenQuad(null),this.tempPulseColor1=new THREE.Color,this.tempPulseColor2=new THREE.Color,this.textureMatrix=new THREE.Matrix4},THREE.OutlinePass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.OutlinePass,dispose:function(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()},setSize:function(e,t){this.renderTargetMaskBuffer.setSize(e,t);var r=Math.round(e/this.downSampleRatio),n=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(r,n),this.renderTargetBlurBuffer1.setSize(r,n),this.renderTargetEdgeBuffer1.setSize(r,n),this.separableBlurMaterial1.uniforms.texSize.value.set(r,n),r=Math.round(r/2),n=Math.round(n/2),this.renderTargetBlurBuffer2.setSize(r,n),this.renderTargetEdgeBuffer2.setSize(r,n),this.separableBlurMaterial2.uniforms.texSize.value.set(r,n)},changeVisibilityOfSelectedObjects:function(e){function t(t){t.isMesh&&(e?(t.visible=t.userData.oldVisible,delete t.userData.oldVisible):(t.userData.oldVisible=t.visible,t.visible=e))}for(var r=0;r<this.selectedObjects.length;r++){this.selectedObjects[r].traverse(t)}},changeVisibilityOfNonSelectedObjects:function(e){var t=[];function r(e){e.isMesh&&t.push(e)}for(var n=0;n<this.selectedObjects.length;n++){this.selectedObjects[n].traverse(r)}this.renderScene.traverse((function(r){if(r.isMesh||r.isLine||r.isSprite){for(var n=!1,a=0;a<t.length;a++){if(t[a].id===r.id){n=!0;break}}if(!n){var o=r.visible;e&&!r.bVisible||(r.visible=e),r.bVisible=o}}}))},updateTextureMatrix:function(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)},render:function(e,t,r,n,a){if(this.selectedObjects.length>0){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();var o=e.autoClear;e.autoClear=!1,a&&e.state.buffers.stencil.setTest(!1),e.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);var i=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,e.setRenderTarget(this.renderTargetDepthBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,e.setRenderTarget(this.renderTargetMaskBuffer),e.clear(),e.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this.renderScene.background=i,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),e.clear(),this.fsQuad.render(e),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){var s=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(s),this.tempPulseColor2.multiplyScalar(s)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,e.setRenderTarget(this.renderTargetBlurBuffer1),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer1),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=THREE.OutlinePass.BlurDirectionX,e.setRenderTarget(this.renderTargetBlurBuffer2),e.clear(),this.fsQuad.render(e),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=THREE.OutlinePass.BlurDirectionY,e.setRenderTarget(this.renderTargetEdgeBuffer2),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,a&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(r),this.fsQuad.render(e),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=o}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,e.setRenderTarget(null),this.fsQuad.render(e))},getPrepareMaskMaterial:function(){return new THREE.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new THREE.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:["#include <morphtarget_pars_vertex>","#include <skinning_pars_vertex>","varying vec4 projTexCoord;","varying vec4 vPosition;","uniform mat4 textureMatrix;","void main() {","\t#include <skinbase_vertex>","\t#include <begin_vertex>","\t#include <morphtarget_vertex>","\t#include <skinning_vertex>","\t#include <project_vertex>","\tvPosition = mvPosition;","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tprojTexCoord = textureMatrix * worldPosition;","}"].join("\n"),fragmentShader:["#include <packing>","varying vec4 vPosition;","varying vec4 projTexCoord;","uniform sampler2D depthTexture;","uniform vec2 cameraNearFar;","void main() {","\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));","\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );","\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;","\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);","}"].join("\n")})},getEdgeDetectionMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},visibleEdgeColor:{value:new THREE.Vector3(1,1,1)},hiddenEdgeColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec3 visibleEdgeColor;\t\t\t\tuniform vec3 hiddenEdgeColor;\t\t\t\t\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\t\t\t\t}"})},getSeperableBlurMaterial:function(e){return new THREE.ShaderMaterial({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\t\t\t\tuniform sampler2D colorTexture;\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\tuniform float kernelRadius;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\t\t\t\t\tvec2 uvOffset = delta;\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\t\t\t\t\t\tweightSum += (2.0 * w);\t\t\t\t\t\tuvOffset += delta;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\t\t\t\t}"})},getOverlayMaterial:function(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D maskTexture;\t\t\t\tuniform sampler2D edgeTexture1;\t\t\t\tuniform sampler2D edgeTexture2;\t\t\t\tuniform sampler2D patternTexture;\t\t\t\tuniform float edgeStrength;\t\t\t\tuniform float edgeGlow;\t\t\t\tuniform bool usePatternTexture;\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\t\t\t\t\tif(usePatternTexture)\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\t\t\t\t\tgl_FragColor = finalColor;\t\t\t\t}",blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}),THREE.OutlinePass.BlurDirectionX=new THREE.Vector2(1,0),THREE.OutlinePass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){THREE.ShaderPass=function(e,t){THREE.Pass.call(this),this.textureID=void 0!==t?t:"tDiffuse",e instanceof THREE.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=THREE.UniformsUtils.clone(e.uniforms),this.material=new THREE.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new THREE.Pass.FullScreenQuad(this.material)},THREE.ShaderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.ShaderPass,render:function(e,t,r){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=r.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}})},function(e,t){THREE.UnrealBloomPass=function(e,t,r,n){THREE.Pass.call(this),this.strength=void 0!==t?t:1,this.radius=r,this.threshold=n,this.resolution=void 0!==e?new THREE.Vector2(e.x,e.y):new THREE.Vector2(256,256),this.clearColor=new THREE.Color(0,0,0);var a={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;var o=Math.round(this.resolution.x/2),i=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(o,i,a),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(var s=0;s<this.nMips;s++){var l=new THREE.WebGLRenderTarget(o,i,a);l.texture.name="UnrealBloomPass.h"+s,l.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(l);var c=new THREE.WebGLRenderTarget(o,i,a);c.texture.name="UnrealBloomPass.v"+s,c.texture.generateMipmaps=!1,this.renderTargetsVertical.push(c),o=Math.round(o/2),i=Math.round(i/2)}void 0===THREE.LuminosityHighPassShader&&console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");var f=THREE.LuminosityHighPassShader;this.highPassUniforms=THREE.UniformsUtils.clone(f.uniforms),this.highPassUniforms.luminosityThreshold.value=n,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new THREE.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:f.vertexShader,fragmentShader:f.fragmentShader,defines:{}}),this.separableBlurMaterials=[];var d=[3,5,7,9,11];for(o=Math.round(this.resolution.x/2),i=Math.round(this.resolution.y/2),s=0;s<this.nMips;s++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(d[s])),this.separableBlurMaterials[s].uniforms.texSize.value=new THREE.Vector2(o,i),o=Math.round(o/2),i=Math.round(i/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,void 0===THREE.CopyShader&&console.error("THREE.UnrealBloomPass relies on THREE.CopyShader");var u=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(u.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.basic=new THREE.MeshBasicMaterial,this.fsQuad=new THREE.Pass.FullScreenQuad(null)},THREE.UnrealBloomPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.UnrealBloomPass,dispose:function(){for(var e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()},setSize:function(e,t){var r=Math.round(e/2),n=Math.round(t/2);this.renderTargetBright.setSize(r,n);for(var a=0;a<this.nMips;a++)this.renderTargetsHorizontal[a].setSize(r,n),this.renderTargetsVertical[a].setSize(r,n),this.separableBlurMaterials[a].uniforms.texSize.value=new THREE.Vector2(r,n),r=Math.round(r/2),n=Math.round(n/2)},render:function(e,t,r,n,a){this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha();var o=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),a&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=r.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=r.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);for(var i=this.renderTargetBright,s=0;s<this.nMips;s++)this.fsQuad.material=this.separableBlurMaterials[s],this.separableBlurMaterials[s].uniforms.colorTexture.value=i.texture,this.separableBlurMaterials[s].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[s]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[s].uniforms.colorTexture.value=this.renderTargetsHorizontal[s].texture,this.separableBlurMaterials[s].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[s]),e.clear(),this.fsQuad.render(e),i=this.renderTargetsVertical[s];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,a&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(r),this.fsQuad.render(e)),e.setClearColor(this.oldClearColor,this.oldClearAlpha),e.autoClear=o},getSeperableBlurMaterial:function(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})},getCompositeMaterial:function(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}}),THREE.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),THREE.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1)},function(e,t){THREE.GlitchPass=function(e){THREE.Pass.call(this),void 0===THREE.DigitalGlitch&&console.error("THREE.GlitchPass relies on THREE.DigitalGlitch");var t=THREE.DigitalGlitch;this.uniforms=THREE.UniformsUtils.clone(t.uniforms),null==e&&(e=64),this.uniforms.tDisp.value=this.generateHeightmap(e),this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader}),this.fsQuad=new THREE.Pass.FullScreenQuad(this.material),this.goWild=!1,this.curF=0,this.generateTrigger()},THREE.GlitchPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.GlitchPass,render:function(e,t,r){this.uniforms.tDiffuse.value=r.texture,this.uniforms.seed.value=Math.random(),this.uniforms.byp.value=0,this.curF%this.randX==0||1==this.goWild?(this.uniforms.amount.value=Math.random()/30,this.uniforms.angle.value=THREE.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.seed_x.value=THREE.MathUtils.randFloat(-1,1),this.uniforms.seed_y.value=THREE.MathUtils.randFloat(-1,1),this.uniforms.distortion_x.value=THREE.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=THREE.MathUtils.randFloat(0,1),this.curF=0,this.generateTrigger()):this.curF%this.randX<this.randX/5?(this.uniforms.amount.value=Math.random()/90,this.uniforms.angle.value=THREE.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.distortion_x.value=THREE.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=THREE.MathUtils.randFloat(0,1),this.uniforms.seed_x.value=THREE.MathUtils.randFloat(-.3,.3),this.uniforms.seed_y.value=THREE.MathUtils.randFloat(-.3,.3)):0==this.goWild&&(this.uniforms.byp.value=1),this.curF++,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this.fsQuad.render(e))},generateTrigger:function(){this.randX=THREE.MathUtils.randInt(120,240)},generateHeightmap:function(e){for(var t=new Float32Array(e*e*3),r=e*e,n=0;n<r;n++){var a=THREE.MathUtils.randFloat(0,1);t[3*n+0]=a,t[3*n+1]=a,t[3*n+2]=a}return new THREE.DataTexture(t,e,e,THREE.RGBFormat,THREE.FloatType)}})},function(e,t){THREE.SSAOPass=function(e,t,r,n){THREE.Pass.call(this),this.width=void 0!==r?r:512,this.height=void 0!==n?n:512,this.clear=!0,this.camera=t,this.scene=e,this.kernelRadius=8,this.kernelSize=32,this.kernel=[],this.noiseTexture=null,this.output=0,this.minDistance=.005,this.maxDistance=.1,this.generateSampleKernel(),this.generateRandomKernelRotations();var a=new THREE.DepthTexture;a.type=THREE.UnsignedShortType,a.minFilter=THREE.NearestFilter,a.maxFilter=THREE.NearestFilter,this.beautyRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,depthTexture:a,depthBuffer:!0}),this.normalRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat}),this.ssaoRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.blurRenderTarget=this.ssaoRenderTarget.clone(),void 0===THREE.SSAOShader&&console.error("THREE.SSAOPass: The pass relies on THREE.SSAOShader."),this.ssaoMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAOShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAOShader.uniforms),vertexShader:THREE.SSAOShader.vertexShader,fragmentShader:THREE.SSAOShader.fragmentShader,blending:THREE.NoBlending}),this.ssaoMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.ssaoMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.ssaoMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.ssaoMaterial.uniforms.tNoise.value=this.noiseTexture,this.ssaoMaterial.uniforms.kernel.value=this.kernel,this.ssaoMaterial.uniforms.cameraNear.value=this.camera.near,this.ssaoMaterial.uniforms.cameraFar.value=this.camera.far,this.ssaoMaterial.uniforms.resolution.value.set(this.width,this.height),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(this.camera.projectionMatrix),this.normalMaterial=new THREE.MeshNormalMaterial,this.normalMaterial.blending=THREE.NoBlending,this.blurMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAOBlurShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAOBlurShader.uniforms),vertexShader:THREE.SSAOBlurShader.vertexShader,fragmentShader:THREE.SSAOBlurShader.fragmentShader}),this.blurMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.blurMaterial.uniforms.resolution.value.set(this.width,this.height),this.depthRenderMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAODepthShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAODepthShader.uniforms),vertexShader:THREE.SSAODepthShader.vertexShader,fragmentShader:THREE.SSAODepthShader.fragmentShader,blending:THREE.NoBlending}),this.depthRenderMaterial.uniforms.tDepth.value=this.beautyRenderTarget.depthTexture,this.depthRenderMaterial.uniforms.cameraNear.value=this.camera.near,this.depthRenderMaterial.uniforms.cameraFar.value=this.camera.far,this.copyMaterial=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.CopyShader.uniforms),vertexShader:THREE.CopyShader.vertexShader,fragmentShader:THREE.CopyShader.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:THREE.DstColorFactor,blendDst:THREE.ZeroFactor,blendEquation:THREE.AddEquation,blendSrcAlpha:THREE.DstAlphaFactor,blendDstAlpha:THREE.ZeroFactor,blendEquationAlpha:THREE.AddEquation}),this.fsQuad=new THREE.Pass.FullScreenQuad(null),this.originalClearColor=new THREE.Color},THREE.SSAOPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.SSAOPass,dispose:function(){this.beautyRenderTarget.dispose(),this.normalRenderTarget.dispose(),this.ssaoRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.normalMaterial.dispose(),this.blurMaterial.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this.fsQuad.dispose()},render:function(e,t){switch(e.setRenderTarget(this.beautyRenderTarget),e.clear(),e.render(this.scene,this.camera),this.renderOverride(e,this.normalMaterial,this.normalRenderTarget,7829503,1),this.ssaoMaterial.uniforms.kernelRadius.value=this.kernelRadius,this.ssaoMaterial.uniforms.minDistance.value=this.minDistance,this.ssaoMaterial.uniforms.maxDistance.value=this.maxDistance,this.renderPass(e,this.ssaoMaterial,this.ssaoRenderTarget),this.renderPass(e,this.blurMaterial,this.blurRenderTarget),this.output){case THREE.SSAOPass.OUTPUT.SSAO:this.copyMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t);break;case THREE.SSAOPass.OUTPUT.Blur:this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t);break;case THREE.SSAOPass.OUTPUT.Beauty:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t);break;case THREE.SSAOPass.OUTPUT.Depth:this.renderPass(e,this.depthRenderMaterial,this.renderToScreen?null:t);break;case THREE.SSAOPass.OUTPUT.Normal:this.copyMaterial.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t);break;case THREE.SSAOPass.OUTPUT.Default:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t),this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=THREE.CustomBlending,this.renderPass(e,this.copyMaterial,this.renderToScreen?null:t);break;default:console.warn("THREE.SSAOPass: Unknown output type.")}},renderPass:function(e,t,r,n,a){this.originalClearColor.copy(e.getClearColor());var o=e.getClearAlpha(),i=e.autoClear;e.setRenderTarget(r),e.autoClear=!1,null!=n&&(e.setClearColor(n),e.setClearAlpha(a||0),e.clear()),this.fsQuad.material=t,this.fsQuad.render(e),e.autoClear=i,e.setClearColor(this.originalClearColor),e.setClearAlpha(o)},renderOverride:function(e,t,r,n,a){this.originalClearColor.copy(e.getClearColor());var o=e.getClearAlpha(),i=e.autoClear;e.setRenderTarget(r),e.autoClear=!1,n=t.clearColor||n,a=t.clearAlpha||a,null!=n&&(e.setClearColor(n),e.setClearAlpha(a||0),e.clear()),this.scene.overrideMaterial=t,e.render(this.scene,this.camera),this.scene.overrideMaterial=null,e.autoClear=i,e.setClearColor(this.originalClearColor),e.setClearAlpha(o)},setSize:function(e,t){this.width=e,this.height=t,this.beautyRenderTarget.setSize(e,t),this.ssaoRenderTarget.setSize(e,t),this.normalRenderTarget.setSize(e,t),this.blurRenderTarget.setSize(e,t),this.ssaoMaterial.uniforms.resolution.value.set(e,t),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.getInverse(this.camera.projectionMatrix),this.blurMaterial.uniforms.resolution.value.set(e,t)},generateSampleKernel:function(){for(var e=this.kernelSize,t=this.kernel,r=0;r<e;r++){var n=new THREE.Vector3;n.x=2*Math.random()-1,n.y=2*Math.random()-1,n.z=Math.random(),n.normalize();var a=r/e;a=THREE.MathUtils.lerp(.1,1,a*a),n.multiplyScalar(a),t.push(n)}},generateRandomKernelRotations:function(){void 0===THREE.SimplexNoise&&console.error("THREE.SSAOPass: The pass relies on THREE.SimplexNoise.");for(var e=new THREE.SimplexNoise,t=new Float32Array(64),r=0;r<16;r++){var n=4*r,a=2*Math.random()-1,o=2*Math.random()-1,i=e.noise3d(a,o,0);t[n]=i,t[n+1]=i,t[n+2]=i,t[n+3]=1}this.noiseTexture=new THREE.DataTexture(t,4,4,THREE.RGBAFormat,THREE.FloatType),this.noiseTexture.wrapS=THREE.RepeatWrapping,this.noiseTexture.wrapT=THREE.RepeatWrapping}}),THREE.SSAOPass.OUTPUT={Default:0,SSAO:1,Blur:2,Beauty:3,Depth:4,Normal:5}},function(e,t){THREE.BokehPass=function(e,t,r){THREE.Pass.call(this);var n=r.width||window.innerWidth||1,a=r.height||window.innerHeight||1,o=r.vignetting||0;this.scene=e,this.camera=t,this.mouse=new THREE.Vector2,this.width=n,this.height=a;var i=THREE.BokehDepthShader,s=THREE.UniformsUtils.clone(i.uniforms);this.materialDepth=new THREE.ShaderMaterial({uniforms:s,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader}),s.mNear.value=t.near,s.mFar.value=t.far,this.scene2=new THREE.Scene,this.camera2=new THREE.OrthographicCamera(n/-2,n/2,a/2,a/-2,-1e4,1e4),this.camera2.position.z=100,this.scene2.add(this.camera2);var l={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this.rtTextureDepth=new THREE.WebGLRenderTarget(n,a,l),this.rtTextureColor=new THREE.WebGLRenderTarget(n,a,l);var c=3,f=4,d=THREE.BokehShader,u=THREE.UniformsUtils.clone(d.uniforms);u.textureWidth.value=n,u.textureHeight.value=a,u.shaderFocus.value=1,u.vignetting.value=o,this.materialBokeh=new THREE.ShaderMaterial({uniforms:u,vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,defines:{RINGS:c,SAMPLES:f}}),this.materialBokeh.uniforms.tColor.value=this.rtTextureColor.texture,this.materialBokeh.uniforms.tDepth.value=this.rtTextureDepth.texture;var p=new THREE.Mesh(new THREE.PlaneBufferGeometry(n,a),this.materialBokeh);p.position.z=-500,this.scene2.add(p)},THREE.BokehPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.BokehPass,render:function(e,t,r,n,a){var o=this.scene,i=this.camera,s=this.materialBokeh.uniforms,l=this.materialDepth.uniforms,c=.5,f=.5;c=.5*this.mouse.x+.5,f=.5*this.mouse.y+.5,s.focusCoords.value.set(c,f),s.znear.value=i.near,s.zfar.value=i.far,l.mNear.value=i.near,l.mFar.value=i.far,e.setRenderTarget(this.rtTextureColor),e.clear(),e.render(o,i),o.overrideMaterial=this.materialDepth,e.setRenderTarget(this.rtTextureDepth),e.clear(),e.render(o,i),o.overrideMaterial=null,this.renderToScreen||(e.setRenderTarget(t),this.clear&&e.clear()),e.render(this.scene2,this.camera2)}})},function(e,t){THREE.BokehShader={uniforms:{textureWidth:{value:1},textureHeight:{value:1},focalDepth:{value:1},focalLength:{value:24},fstop:{value:.9},tColor:{value:null},tDepth:{value:null},maxblur:{value:1},showFocus:{value:0},manualdof:{value:1},vignetting:{value:0},depthblur:{value:0},threshold:{value:.5},gain:{value:2},bias:{value:.5},fringe:{value:.7},znear:{value:.1},zfar:{value:100},noise:{value:1},dithering:{value:1e-4},pentagon:{value:0},shaderFocus:{value:1},focusCoords:{value:new THREE.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#include <common>","varying vec2 vUv;","uniform sampler2D tColor;","uniform sampler2D tDepth;","uniform float textureWidth;","uniform float textureHeight;","uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below","uniform float focalLength; //focal length in mm","uniform float fstop; //f-stop value","uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)","/*","make sure that these two values are the same for your camera, otherwise distances will be wrong.","*/","uniform float znear; // camera clipping start","uniform float zfar; // camera clipping end","//------------------------------------------","//user variables","const int samples = SAMPLES; //samples on the first ring","const int rings = RINGS; //ring count","const int maxringsamples = rings * samples;","uniform bool manualdof; // manual dof calculation","float ndofstart = 1.0; // near dof blur start","float ndofdist = 2.0; // near dof blur falloff distance","float fdofstart = 1.0; // far dof blur start","float fdofdist = 3.0; // far dof blur falloff distance","float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)","uniform bool vignetting; // use optical lens vignetting","float vignout = 1.3; // vignetting outer border","float vignin = 0.0; // vignetting inner border","float vignfade = 22.0; // f-stops till vignete fades","uniform bool shaderFocus;","// disable if you use external focalDepth value","uniform vec2 focusCoords;","// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)","// if center of screen use vec2(0.5, 0.5);","uniform float maxblur;","//clamp value of max blur (0.0 = no blur, 1.0 default)","uniform float threshold; // highlight threshold;","uniform float gain; // highlight gain;","uniform float bias; // bokeh edge bias","uniform float fringe; // bokeh chromatic aberration / fringing","uniform bool noise; //use noise instead of pattern for sample dithering","uniform float dithering;","uniform bool depthblur; // blur the depth buffer","float dbsize = 1.25; // depth blur size","/*","next part is experimental","not looking good with small sample and ring count","looks okay starting from samples = 4, rings = 4","*/","uniform bool pentagon; //use pentagon as bokeh shape?","float feather = 0.4; //pentagon shape feather","//------------------------------------------","float penta(vec2 coords) {","\t//pentagonal shape","\tfloat scale = float(rings) - 1.3;","\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);","\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);","\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);","\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);","\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);","\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);","\tvec4  one = vec4( 1.0 );","\tvec4 P = vec4((coords),vec2(scale, scale));","\tvec4 dist = vec4(0.0);","\tfloat inorout = -4.0;","\tdist.x = dot( P, HS0 );","\tdist.y = dot( P, HS1 );","\tdist.z = dot( P, HS2 );","\tdist.w = dot( P, HS3 );","\tdist = smoothstep( -feather, feather, dist );","\tinorout += dot( dist, one );","\tdist.x = dot( P, HS4 );","\tdist.y = HS5.w - abs( P.z );","\tdist = smoothstep( -feather, feather, dist );","\tinorout += dist.x;","\treturn clamp( inorout, 0.0, 1.0 );","}","float bdepth(vec2 coords) {","\t// Depth buffer blur","\tfloat d = 0.0;","\tfloat kernel[9];","\tvec2 offset[9];","\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;","\toffset[0] = vec2(-wh.x,-wh.y);","\toffset[1] = vec2( 0.0, -wh.y);","\toffset[2] = vec2( wh.x -wh.y);","\toffset[3] = vec2(-wh.x,  0.0);","\toffset[4] = vec2( 0.0,   0.0);","\toffset[5] = vec2( wh.x,  0.0);","\toffset[6] = vec2(-wh.x, wh.y);","\toffset[7] = vec2( 0.0,  wh.y);","\toffset[8] = vec2( wh.x, wh.y);","\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;","\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;","\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;","\tfor( int i=0; i<9; i++ ) {","\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;","\t\td += tmp * kernel[i];","\t}","\treturn d;","}","vec3 color(vec2 coords,float blur) {","\t//processing the sample","\tvec3 col = vec3(0.0);","\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);","\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;","\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;","\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;","\tvec3 lumcoeff = vec3(0.299,0.587,0.114);","\tfloat lum = dot(col.rgb, lumcoeff);","\tfloat thresh = max((lum-threshold)*gain, 0.0);","\treturn col+mix(vec3(0.0),col,thresh*blur);","}","vec3 debugFocus(vec3 col, float blur, float depth) {","\tfloat edge = 0.002*depth; //distance based edge smoothing","\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);","\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);","\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);","\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);","\treturn col;","}","float linearize(float depth) {","\treturn -zfar * znear / (depth * (zfar - znear) - zfar);","}","float vignette() {","\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));","\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);","\treturn clamp(dist,0.0,1.0);","}","float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {","\tfloat rings2 = float(rings);","\tfloat step = PI*2.0 / float(ringsamples);","\tfloat pw = cos(j*step)*i;","\tfloat ph = sin(j*step)*i;","\tfloat p = 1.0;","\tif (pentagon) {","\t\tp = penta(vec2(pw,ph));","\t}","\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;","\treturn 1.0 * mix(1.0, i /rings2, bias) * p;","}","void main() {","\t//scene depth calculation","\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);","\t// Blur depth?","\tif ( depthblur ) {","\t\tdepth = linearize(bdepth(vUv.xy));","\t}","\t//focal plane calculation","\tfloat fDepth = focalDepth;","\tif (shaderFocus) {","\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);","\t}","\t// dof blur factor calculation","\tfloat blur = 0.0;","\tif (manualdof) {","\t\tfloat a = depth-fDepth; // Focal plane","\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF","\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof","\t\tblur = (a>0.0) ? b : c;","\t} else {","\t\tfloat f = focalLength; // focal length in mm","\t\tfloat d = fDepth*1000.0; // focal plane in mm","\t\tfloat o = depth*1000.0; // depth in mm","\t\tfloat a = (o*f)/(o-f);","\t\tfloat b = (d*f)/(d-f);","\t\tfloat c = (d-f)/(d*fstop*CoC);","\t\tblur = abs(a-b)*c;","\t}","\tblur = clamp(blur,0.0,1.0);","\t// calculation of pattern for dithering","\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;","\t// getting blur x and y step factor","\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;","\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;","\t// calculation of final color","\tvec3 col = vec3(0.0);","\tif(blur < 0.05) {","\t\t//some optimization thingy","\t\tcol = texture2D(tColor, vUv.xy).rgb;","\t} else {","\t\tcol = texture2D(tColor, vUv.xy).rgb;","\t\tfloat s = 1.0;","\t\tint ringsamples;","\t\tfor (int i = 1; i <= rings; i++) {","\t\t\t/*unboxstart*/","\t\t\tringsamples = i * samples;","\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {","\t\t\t\tif (j >= ringsamples) break;","\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);","\t\t\t}","\t\t\t/*unboxend*/","\t\t}","\t\tcol /= s; //divide by sample count","\t}","\tif (showFocus) {","\t\tcol = debugFocus(col, blur, depth);","\t}","\tif (vignetting) {","\t\tcol *= vignette();","\t}","\tgl_FragColor.rgb = col;","\tgl_FragColor.a = 1.0;","} "].join("\n")},THREE.BokehDepthShader={uniforms:{mNear:{value:1},mFar:{value:1e3}},vertexShader:["varying float vViewZDepth;","void main() {","\t#include <begin_vertex>","\t#include <project_vertex>","\tvViewZDepth = - mvPosition.z;","}"].join("\n"),fragmentShader:["uniform float mNear;","uniform float mFar;","varying float vViewZDepth;","void main() {","\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );","\tgl_FragColor = vec4( vec3( color ), 1.0 );","} "].join("\n")}},function(e,t){THREE.BleachBypassShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 base = texture2D( tDiffuse, vUv );","\tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );","\tfloat lum = dot( lumCoeff, base.rgb );","\tvec3 blend = vec3( lum );","\tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );","\tvec3 result1 = 2.0 * base.rgb * blend;","\tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );","\tvec3 newColor = mix( result1, result2, L );","\tfloat A2 = opacity * base.a;","\tvec3 mixRGB = A2 * newColor.rgb;","\tmixRGB += ( ( 1.0 - A2 ) * base.rgb );","\tgl_FragColor = vec4( mixRGB, base.a );","}"].join("\n")}},function(e,t){THREE.CopyShader={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 texel = texture2D( tDiffuse, vUv );","\tgl_FragColor = opacity * texel;","}"].join("\n")}},function(e,t){THREE.DotScreenShader={uniforms:{tDiffuse:{value:null},tSize:{value:new THREE.Vector2(256,256)},center:{value:new THREE.Vector2(.5,.5)},angle:{value:1.57},scale:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 center;","uniform float angle;","uniform float scale;","uniform vec2 tSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","float pattern() {","\tfloat s = sin( angle ), c = cos( angle );","\tvec2 tex = vUv * tSize - center;","\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;","\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;","}","void main() {","\tvec4 color = texture2D( tDiffuse, vUv );","\tfloat average = ( color.r + color.g + color.b ) / 3.0;","\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );","}"].join("\n")}},function(e,t){THREE.FXAAShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["precision highp float;","","uniform sampler2D tDiffuse;","","uniform vec2 resolution;","","varying vec2 vUv;","","// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)","","//----------------------------------------------------------------------------------","// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag","// SDK Version: v3.00","// Email:       gameworks@nvidia.com","// Site:        http://developer.nvidia.com/","//","// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.","//","// Redistribution and use in source and binary forms, with or without","// modification, are permitted provided that the following conditions","// are met:","//  * Redistributions of source code must retain the above copyright","//    notice, this list of conditions and the following disclaimer.","//  * Redistributions in binary form must reproduce the above copyright","//    notice, this list of conditions and the following disclaimer in the","//    documentation and/or other materials provided with the distribution.","//  * Neither the name of NVIDIA CORPORATION nor the names of its","//    contributors may be used to endorse or promote products derived","//    from this software without specific prior written permission.","//","// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY","// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE","// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR","// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR","// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,","// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,","// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR","// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY","// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT","// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE","// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","//","//----------------------------------------------------------------------------------","","#define FXAA_PC 1","#define FXAA_GLSL_100 1","#define FXAA_QUALITY_PRESET 12","","#define FXAA_GREEN_AS_LUMA 1","","/*--------------------------------------------------------------------------*/","#ifndef FXAA_PC_CONSOLE","    //","    // The console algorithm for PC is included","    // for developers targeting really low spec machines.","    // Likely better to just run FXAA_PC, and use a really low preset.","    //","    #define FXAA_PC_CONSOLE 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_GLSL_120","    #define FXAA_GLSL_120 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_GLSL_130","    #define FXAA_GLSL_130 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_HLSL_3","    #define FXAA_HLSL_3 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_HLSL_4","    #define FXAA_HLSL_4 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_HLSL_5","    #define FXAA_HLSL_5 0","#endif","/*==========================================================================*/","#ifndef FXAA_GREEN_AS_LUMA","    //","    // For those using non-linear color,","    // and either not able to get luma in alpha, or not wanting to,","    // this enables FXAA to run using green as a proxy for luma.","    // So with this enabled, no need to pack luma in alpha.","    //","    // This will turn off AA on anything which lacks some amount of green.","    // Pure red and blue or combination of only R and B, will get no AA.","    //","    // Might want to lower the settings for both,","    //    fxaaConsoleEdgeThresholdMin","    //    fxaaQualityEdgeThresholdMin","    // In order to insure AA does not get turned off on colors","    // which contain a minor amount of green.","    //","    // 1 = On.","    // 0 = Off.","    //","    #define FXAA_GREEN_AS_LUMA 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_EARLY_EXIT","    //","    // Controls algorithm's early exit path.","    // On PS3 turning this ON adds 2 cycles to the shader.","    // On 360 turning this OFF adds 10ths of a millisecond to the shader.","    // Turning this off on console will result in a more blurry image.","    // So this defaults to on.","    //","    // 1 = On.","    // 0 = Off.","    //","    #define FXAA_EARLY_EXIT 1","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_DISCARD","    //","    // Only valid for PC OpenGL currently.","    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.","    //","    // 1 = Use discard on pixels which don't need AA.","    //     For APIs which enable concurrent TEX+ROP from same surface.","    // 0 = Return unchanged color on pixels which don't need AA.","    //","    #define FXAA_DISCARD 0","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_FAST_PIXEL_OFFSET","    //","    // Used for GLSL 120 only.","    //","    // 1 = GL API supports fast pixel offsets","    // 0 = do not use fast pixel offsets","    //","    #ifdef GL_EXT_gpu_shader4","        #define FXAA_FAST_PIXEL_OFFSET 1","    #endif","    #ifdef GL_NV_gpu_shader5","        #define FXAA_FAST_PIXEL_OFFSET 1","    #endif","    #ifdef GL_ARB_gpu_shader5","        #define FXAA_FAST_PIXEL_OFFSET 1","    #endif","    #ifndef FXAA_FAST_PIXEL_OFFSET","        #define FXAA_FAST_PIXEL_OFFSET 0","    #endif","#endif","/*--------------------------------------------------------------------------*/","#ifndef FXAA_GATHER4_ALPHA","    //","    // 1 = API supports gather4 on alpha channel.","    // 0 = API does not support gather4 on alpha channel.","    //","    #if (FXAA_HLSL_5 == 1)","        #define FXAA_GATHER4_ALPHA 1","    #endif","    #ifdef GL_ARB_gpu_shader5","        #define FXAA_GATHER4_ALPHA 1","    #endif","    #ifdef GL_NV_gpu_shader5","        #define FXAA_GATHER4_ALPHA 1","    #endif","    #ifndef FXAA_GATHER4_ALPHA","        #define FXAA_GATHER4_ALPHA 0","    #endif","#endif","","","/*============================================================================","                        FXAA QUALITY - TUNING KNOBS","------------------------------------------------------------------------------","NOTE the other tuning knobs are now in the shader function inputs!","============================================================================*/","#ifndef FXAA_QUALITY_PRESET","    //","    // Choose the quality preset.","    // This needs to be compiled into the shader as it effects code.","    // Best option to include multiple presets is to","    // in each shader define the preset, then include this file.","    //","    // OPTIONS","    // -----------------------------------------------------------------------","    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)","    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)","    // 39       - no dither, very expensive","    //","    // NOTES","    // -----------------------------------------------------------------------","    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)","    // 13 = about same speed as FXAA 3.9 and better than 12","    // 23 = closest to FXAA 3.9 visually and performance wise","    //  _ = the lowest digit is directly related to performance","    // _  = the highest digit is directly related to style","    //","    #define FXAA_QUALITY_PRESET 12","#endif","","","/*============================================================================","","                           FXAA QUALITY - PRESETS","","============================================================================*/","","/*============================================================================","                     FXAA QUALITY - MEDIUM DITHER PRESETS","============================================================================*/","#if (FXAA_QUALITY_PRESET == 10)","    #define FXAA_QUALITY_PS 3","    #define FXAA_QUALITY_P0 1.5","    #define FXAA_QUALITY_P1 3.0","    #define FXAA_QUALITY_P2 12.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 11)","    #define FXAA_QUALITY_PS 4","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 3.0","    #define FXAA_QUALITY_P3 12.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 12)","    #define FXAA_QUALITY_PS 5","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 4.0","    #define FXAA_QUALITY_P4 12.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 13)","    #define FXAA_QUALITY_PS 6","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 4.0","    #define FXAA_QUALITY_P5 12.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 14)","    #define FXAA_QUALITY_PS 7","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 4.0","    #define FXAA_QUALITY_P6 12.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 15)","    #define FXAA_QUALITY_PS 8","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 4.0","    #define FXAA_QUALITY_P7 12.0","#endif","","/*============================================================================","                     FXAA QUALITY - LOW DITHER PRESETS","============================================================================*/","#if (FXAA_QUALITY_PRESET == 20)","    #define FXAA_QUALITY_PS 3","    #define FXAA_QUALITY_P0 1.5","    #define FXAA_QUALITY_P1 2.0","    #define FXAA_QUALITY_P2 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 21)","    #define FXAA_QUALITY_PS 4","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 22)","    #define FXAA_QUALITY_PS 5","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 23)","    #define FXAA_QUALITY_PS 6","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 24)","    #define FXAA_QUALITY_PS 7","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 3.0","    #define FXAA_QUALITY_P6 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 25)","    #define FXAA_QUALITY_PS 8","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 4.0","    #define FXAA_QUALITY_P7 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 26)","    #define FXAA_QUALITY_PS 9","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 2.0","    #define FXAA_QUALITY_P7 4.0","    #define FXAA_QUALITY_P8 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 27)","    #define FXAA_QUALITY_PS 10","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 2.0","    #define FXAA_QUALITY_P7 2.0","    #define FXAA_QUALITY_P8 4.0","    #define FXAA_QUALITY_P9 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 28)","    #define FXAA_QUALITY_PS 11","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 2.0","    #define FXAA_QUALITY_P7 2.0","    #define FXAA_QUALITY_P8 2.0","    #define FXAA_QUALITY_P9 4.0","    #define FXAA_QUALITY_P10 8.0","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_QUALITY_PRESET == 29)","    #define FXAA_QUALITY_PS 12","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.5","    #define FXAA_QUALITY_P2 2.0","    #define FXAA_QUALITY_P3 2.0","    #define FXAA_QUALITY_P4 2.0","    #define FXAA_QUALITY_P5 2.0","    #define FXAA_QUALITY_P6 2.0","    #define FXAA_QUALITY_P7 2.0","    #define FXAA_QUALITY_P8 2.0","    #define FXAA_QUALITY_P9 2.0","    #define FXAA_QUALITY_P10 4.0","    #define FXAA_QUALITY_P11 8.0","#endif","","/*============================================================================","                     FXAA QUALITY - EXTREME QUALITY","============================================================================*/","#if (FXAA_QUALITY_PRESET == 39)","    #define FXAA_QUALITY_PS 12","    #define FXAA_QUALITY_P0 1.0","    #define FXAA_QUALITY_P1 1.0","    #define FXAA_QUALITY_P2 1.0","    #define FXAA_QUALITY_P3 1.0","    #define FXAA_QUALITY_P4 1.0","    #define FXAA_QUALITY_P5 1.5","    #define FXAA_QUALITY_P6 2.0","    #define FXAA_QUALITY_P7 2.0","    #define FXAA_QUALITY_P8 2.0","    #define FXAA_QUALITY_P9 2.0","    #define FXAA_QUALITY_P10 4.0","    #define FXAA_QUALITY_P11 8.0","#endif","","","","/*============================================================================","","                                API PORTING","","============================================================================*/","#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)","    #define FxaaBool bool","    #define FxaaDiscard discard","    #define FxaaFloat float","    #define FxaaFloat2 vec2","    #define FxaaFloat3 vec3","    #define FxaaFloat4 vec4","    #define FxaaHalf float","    #define FxaaHalf2 vec2","    #define FxaaHalf3 vec3","    #define FxaaHalf4 vec4","    #define FxaaInt2 ivec2","    #define FxaaSat(x) clamp(x, 0.0, 1.0)","    #define FxaaTex sampler2D","#else","    #define FxaaBool bool","    #define FxaaDiscard clip(-1)","    #define FxaaFloat float","    #define FxaaFloat2 float2","    #define FxaaFloat3 float3","    #define FxaaFloat4 float4","    #define FxaaHalf half","    #define FxaaHalf2 half2","    #define FxaaHalf3 half3","    #define FxaaHalf4 half4","    #define FxaaSat(x) saturate(x)","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_GLSL_100 == 1)","  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)","  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_GLSL_120 == 1)","    // Requires,","    //  #version 120","    // And at least,","    //  #extension GL_EXT_gpu_shader4 : enable","    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)","    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)","    #if (FXAA_FAST_PIXEL_OFFSET == 1)","        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)","    #else","        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)","    #endif","    #if (FXAA_GATHER4_ALPHA == 1)","        // use #extension GL_ARB_gpu_shader5 : enable","        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)","        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)","        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)","        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)","    #endif","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_GLSL_130 == 1)",'    // Requires "#version 130" or better',"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)","    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)","    #if (FXAA_GATHER4_ALPHA == 1)","        // use #extension GL_ARB_gpu_shader5 : enable","        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)","        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)","        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)","        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)","    #endif","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_HLSL_3 == 1)","    #define FxaaInt2 float2","    #define FxaaTex sampler2D","    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))","    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_HLSL_4 == 1)","    #define FxaaInt2 int2","    struct FxaaTex { SamplerState smpl; Texture2D tex; };","    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)","    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)","#endif","/*--------------------------------------------------------------------------*/","#if (FXAA_HLSL_5 == 1)","    #define FxaaInt2 int2","    struct FxaaTex { SamplerState smpl; Texture2D tex; };","    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)","    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)","    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)","    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)","    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)","    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)","#endif","","","/*============================================================================","                   GREEN AS LUMA OPTION SUPPORT FUNCTION","============================================================================*/","#if (FXAA_GREEN_AS_LUMA == 0)","    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }","#else","    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }","#endif","","","","","/*============================================================================","","                             FXAA3 QUALITY - PC","","============================================================================*/","#if (FXAA_PC == 1)","/*--------------------------------------------------------------------------*/","FxaaFloat4 FxaaPixelShader(","    //","    // Use noperspective interpolation here (turn off perspective interpolation).","    // {xy} = center of pixel","    FxaaFloat2 pos,","    //","    // Used only for FXAA Console, and not used on the 360 version.","    // Use noperspective interpolation here (turn off perspective interpolation).","    // {xy_} = upper left of pixel","    // {_zw} = lower right of pixel","    FxaaFloat4 fxaaConsolePosPos,","    //","    // Input color texture.","    // {rgb_} = color in linear or perceptual color space","    // if (FXAA_GREEN_AS_LUMA == 0)","    //     {__a} = luma in perceptual color space (not linear)","    FxaaTex tex,","    //","    // Only used on the optimized 360 version of FXAA Console.",'    // For everything but 360, just use the same input here as for "tex".',"    // For 360, same texture, just alias with a 2nd sampler.","    // This sampler needs to have an exponent bias of -1.","    FxaaTex fxaaConsole360TexExpBiasNegOne,","    //","    // Only used on the optimized 360 version of FXAA Console.",'    // For everything but 360, just use the same input here as for "tex".',"    // For 360, same texture, just alias with a 3nd sampler.","    // This sampler needs to have an exponent bias of -2.","    FxaaTex fxaaConsole360TexExpBiasNegTwo,","    //","    // Only used on FXAA Quality.","    // This must be from a constant/uniform.","    // {x_} = 1.0/screenWidthInPixels","    // {_y} = 1.0/screenHeightInPixels","    FxaaFloat2 fxaaQualityRcpFrame,","    //","    // Only used on FXAA Console.","    // This must be from a constant/uniform.","    // This effects sub-pixel AA quality and inversely sharpness.","    //   Where N ranges between,","    //     N = 0.50 (default)","    //     N = 0.33 (sharper)","    // {x__} = -N/screenWidthInPixels","    // {_y_} = -N/screenHeightInPixels","    // {_z_} =  N/screenWidthInPixels","    // {__w} =  N/screenHeightInPixels","    FxaaFloat4 fxaaConsoleRcpFrameOpt,","    //","    // Only used on FXAA Console.","    // Not used on 360, but used on PS3 and PC.","    // This must be from a constant/uniform.","    // {x__} = -2.0/screenWidthInPixels","    // {_y_} = -2.0/screenHeightInPixels","    // {_z_} =  2.0/screenWidthInPixels","    // {__w} =  2.0/screenHeightInPixels","    FxaaFloat4 fxaaConsoleRcpFrameOpt2,","    //","    // Only used on FXAA Console.","    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.","    // This must be from a constant/uniform.","    // {x__} =  8.0/screenWidthInPixels","    // {_y_} =  8.0/screenHeightInPixels","    // {_z_} = -4.0/screenWidthInPixels","    // {__w} = -4.0/screenHeightInPixels","    FxaaFloat4 fxaaConsole360RcpFrameOpt2,","    //","    // Only used on FXAA Quality.","    // This used to be the FXAA_QUALITY_SUBPIX define.","    // It is here now to allow easier tuning.","    // Choose the amount of sub-pixel aliasing removal.","    // This can effect sharpness.","    //   1.00 - upper limit (softer)","    //   0.75 - default amount of filtering","    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)","    //   0.25 - almost off","    //   0.00 - completely off","    FxaaFloat fxaaQualitySubpix,","    //","    // Only used on FXAA Quality.","    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.","    // It is here now to allow easier tuning.","    // The minimum amount of local contrast required to apply algorithm.","    //   0.333 - too little (faster)","    //   0.250 - low quality","    //   0.166 - default","    //   0.125 - high quality","    //   0.063 - overkill (slower)","    FxaaFloat fxaaQualityEdgeThreshold,","    //","    // Only used on FXAA Quality.","    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.","    // It is here now to allow easier tuning.","    // Trims the algorithm from processing darks.","    //   0.0833 - upper limit (default, the start of visible unfiltered edges)","    //   0.0625 - high quality (faster)","    //   0.0312 - visible limit (slower)","    // Special notes when using FXAA_GREEN_AS_LUMA,","    //   Likely want to set this to zero.","    //   As colors that are mostly not-green","    //   will appear very dark in the green channel!","    //   Tune by looking at mostly non-green content,","    //   then start at zero and increase until aliasing is a problem.","    FxaaFloat fxaaQualityEdgeThresholdMin,","    //","    // Only used on FXAA Console.","    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.","    // It is here now to allow easier tuning.","    // This does not effect PS3, as this needs to be compiled in.","    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.","    //   Due to the PS3 being ALU bound,","    //   there are only three safe values here: 2 and 4 and 8.","    //   These options use the shaders ability to a free *|/ by 2|4|8.","    // For all other platforms can be a non-power of two.","    //   8.0 is sharper (default!!!)","    //   4.0 is softer","    //   2.0 is really soft (good only for vector graphics inputs)","    FxaaFloat fxaaConsoleEdgeSharpness,","    //","    // Only used on FXAA Console.","    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.","    // It is here now to allow easier tuning.","    // This does not effect PS3, as this needs to be compiled in.","    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.","    //   Due to the PS3 being ALU bound,","    //   there are only two safe values here: 1/4 and 1/8.","    //   These options use the shaders ability to a free *|/ by 2|4|8.","    // The console setting has a different mapping than the quality setting.","    // Other platforms can use other values.","    //   0.125 leaves less aliasing, but is softer (default!!!)","    //   0.25 leaves more aliasing, and is sharper","    FxaaFloat fxaaConsoleEdgeThreshold,","    //","    // Only used on FXAA Console.","    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.","    // It is here now to allow easier tuning.","    // Trims the algorithm from processing darks.","    // The console setting has a different mapping than the quality setting.","    // This only applies when FXAA_EARLY_EXIT is 1.","    // This does not apply to PS3,","    // PS3 was simplified to avoid more shader instructions.","    //   0.06 - faster but more aliasing in darks","    //   0.05 - default","    //   0.04 - slower and less aliasing in darks","    // Special notes when using FXAA_GREEN_AS_LUMA,","    //   Likely want to set this to zero.","    //   As colors that are mostly not-green","    //   will appear very dark in the green channel!","    //   Tune by looking at mostly non-green content,","    //   then start at zero and increase until aliasing is a problem.","    FxaaFloat fxaaConsoleEdgeThresholdMin,","    //","    // Extra constants for 360 FXAA Console only.","    // Use zeros or anything else for other platforms.","    // These must be in physical constant registers and NOT immediates.","    // Immediates will result in compiler un-optimizing.","    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)","    FxaaFloat4 fxaaConsole360ConstDir",") {","/*--------------------------------------------------------------------------*/","    FxaaFloat2 posM;","    posM.x = pos.x;","    posM.y = pos.y;","    #if (FXAA_GATHER4_ALPHA == 1)","        #if (FXAA_DISCARD == 0)","            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);","            #if (FXAA_GREEN_AS_LUMA == 0)","                #define lumaM rgbyM.w","            #else","                #define lumaM rgbyM.y","            #endif","        #endif","        #if (FXAA_GREEN_AS_LUMA == 0)","            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);","            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));","        #else","            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);","            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));","        #endif","        #if (FXAA_DISCARD == 1)","            #define lumaM luma4A.w","        #endif","        #define lumaE luma4A.z","        #define lumaS luma4A.x","        #define lumaSE luma4A.y","        #define lumaNW luma4B.w","        #define lumaN luma4B.z","        #define lumaW luma4B.x","    #else","        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);","        #if (FXAA_GREEN_AS_LUMA == 0)","            #define lumaM rgbyM.w","        #else","            #define lumaM rgbyM.y","        #endif","        #if (FXAA_GLSL_100 == 1)","          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));","        #else","          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));","        #endif","    #endif","/*--------------------------------------------------------------------------*/","    FxaaFloat maxSM = max(lumaS, lumaM);","    FxaaFloat minSM = min(lumaS, lumaM);","    FxaaFloat maxESM = max(lumaE, maxSM);","    FxaaFloat minESM = min(lumaE, minSM);","    FxaaFloat maxWN = max(lumaN, lumaW);","    FxaaFloat minWN = min(lumaN, lumaW);","    FxaaFloat rangeMax = max(maxWN, maxESM);","    FxaaFloat rangeMin = min(minWN, minESM);","    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;","    FxaaFloat range = rangeMax - rangeMin;","    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);","    FxaaBool earlyExit = range < rangeMaxClamped;","/*--------------------------------------------------------------------------*/","    if(earlyExit)","        #if (FXAA_DISCARD == 1)","            FxaaDiscard;","        #else","            return rgbyM;","        #endif","/*--------------------------------------------------------------------------*/","    #if (FXAA_GATHER4_ALPHA == 0)","        #if (FXAA_GLSL_100 == 1)","          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));","        #else","          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));","          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));","        #endif","    #else","        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));","        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));","    #endif","/*--------------------------------------------------------------------------*/","    FxaaFloat lumaNS = lumaN + lumaS;","    FxaaFloat lumaWE = lumaW + lumaE;","    FxaaFloat subpixRcpRange = 1.0/range;","    FxaaFloat subpixNSWE = lumaNS + lumaWE;","    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;","    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;","/*--------------------------------------------------------------------------*/","    FxaaFloat lumaNESE = lumaNE + lumaSE;","    FxaaFloat lumaNWNE = lumaNW + lumaNE;","    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;","    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;","/*--------------------------------------------------------------------------*/","    FxaaFloat lumaNWSW = lumaNW + lumaSW;","    FxaaFloat lumaSWSE = lumaSW + lumaSE;","    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);","    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);","    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;","    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;","    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;","    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;","/*--------------------------------------------------------------------------*/","    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;","    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;","    FxaaBool horzSpan = edgeHorz >= edgeVert;","    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;","/*--------------------------------------------------------------------------*/","    if(!horzSpan) lumaN = lumaW;","    if(!horzSpan) lumaS = lumaE;","    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;","    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;","/*--------------------------------------------------------------------------*/","    FxaaFloat gradientN = lumaN - lumaM;","    FxaaFloat gradientS = lumaS - lumaM;","    FxaaFloat lumaNN = lumaN + lumaM;","    FxaaFloat lumaSS = lumaS + lumaM;","    FxaaBool pairN = abs(gradientN) >= abs(gradientS);","    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));","    if(pairN) lengthSign = -lengthSign;","    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);","/*--------------------------------------------------------------------------*/","    FxaaFloat2 posB;","    posB.x = posM.x;","    posB.y = posM.y;","    FxaaFloat2 offNP;","    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;","    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;","    if(!horzSpan) posB.x += lengthSign * 0.5;","    if( horzSpan) posB.y += lengthSign * 0.5;","/*--------------------------------------------------------------------------*/","    FxaaFloat2 posN;","    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;","    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;","    FxaaFloat2 posP;","    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;","    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;","    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;","    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));","    FxaaFloat subpixE = subpixC * subpixC;","    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));","/*--------------------------------------------------------------------------*/","    if(!pairN) lumaNN = lumaSS;","    FxaaFloat gradientScaled = gradient * 1.0/4.0;","    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;","    FxaaFloat subpixF = subpixD * subpixE;","    FxaaBool lumaMLTZero = lumaMM < 0.0;","/*--------------------------------------------------------------------------*/","    lumaEndN -= lumaNN * 0.5;","    lumaEndP -= lumaNN * 0.5;","    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;","    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;","    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;","    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;","    FxaaBool doneNP = (!doneN) || (!doneP);","    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;","    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;","/*--------------------------------------------------------------------------*/","    if(doneNP) {","        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","        doneN = abs(lumaEndN) >= gradientScaled;","        doneP = abs(lumaEndP) >= gradientScaled;","        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;","        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;","        doneNP = (!doneN) || (!doneP);","        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;","        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;","/*--------------------------------------------------------------------------*/","        #if (FXAA_QUALITY_PS > 3)","        if(doneNP) {","            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","            doneN = abs(lumaEndN) >= gradientScaled;","            doneP = abs(lumaEndP) >= gradientScaled;","            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;","            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;","            doneNP = (!doneN) || (!doneP);","            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;","            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;","/*--------------------------------------------------------------------------*/","            #if (FXAA_QUALITY_PS > 4)","            if(doneNP) {","                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                doneN = abs(lumaEndN) >= gradientScaled;","                doneP = abs(lumaEndP) >= gradientScaled;","                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;","                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;","                doneNP = (!doneN) || (!doneP);","                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;","                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;","/*--------------------------------------------------------------------------*/","                #if (FXAA_QUALITY_PS > 5)","                if(doneNP) {","                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                    doneN = abs(lumaEndN) >= gradientScaled;","                    doneP = abs(lumaEndP) >= gradientScaled;","                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;","                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;","                    doneNP = (!doneN) || (!doneP);","                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;","                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;","/*--------------------------------------------------------------------------*/","                    #if (FXAA_QUALITY_PS > 6)","                    if(doneNP) {","                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                        doneN = abs(lumaEndN) >= gradientScaled;","                        doneP = abs(lumaEndP) >= gradientScaled;","                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;","                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;","                        doneNP = (!doneN) || (!doneP);","                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;","                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;","/*--------------------------------------------------------------------------*/","                        #if (FXAA_QUALITY_PS > 7)","                        if(doneNP) {","                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                            doneN = abs(lumaEndN) >= gradientScaled;","                            doneP = abs(lumaEndP) >= gradientScaled;","                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;","                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;","                            doneNP = (!doneN) || (!doneP);","                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;","                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;","/*--------------------------------------------------------------------------*/","    #if (FXAA_QUALITY_PS > 8)","    if(doneNP) {","        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","        doneN = abs(lumaEndN) >= gradientScaled;","        doneP = abs(lumaEndP) >= gradientScaled;","        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;","        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;","        doneNP = (!doneN) || (!doneP);","        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;","        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;","/*--------------------------------------------------------------------------*/","        #if (FXAA_QUALITY_PS > 9)","        if(doneNP) {","            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","            doneN = abs(lumaEndN) >= gradientScaled;","            doneP = abs(lumaEndP) >= gradientScaled;","            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;","            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;","            doneNP = (!doneN) || (!doneP);","            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;","            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;","/*--------------------------------------------------------------------------*/","            #if (FXAA_QUALITY_PS > 10)","            if(doneNP) {","                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                doneN = abs(lumaEndN) >= gradientScaled;","                doneP = abs(lumaEndP) >= gradientScaled;","                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;","                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;","                doneNP = (!doneN) || (!doneP);","                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;","                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;","/*--------------------------------------------------------------------------*/","                #if (FXAA_QUALITY_PS > 11)","                if(doneNP) {","                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                    doneN = abs(lumaEndN) >= gradientScaled;","                    doneP = abs(lumaEndP) >= gradientScaled;","                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;","                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;","                    doneNP = (!doneN) || (!doneP);","                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;","                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;","/*--------------------------------------------------------------------------*/","                    #if (FXAA_QUALITY_PS > 12)","                    if(doneNP) {","                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));","                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));","                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;","                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;","                        doneN = abs(lumaEndN) >= gradientScaled;","                        doneP = abs(lumaEndP) >= gradientScaled;","                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;","                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;","                        doneNP = (!doneN) || (!doneP);","                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;","                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;","/*--------------------------------------------------------------------------*/","                    }","                    #endif","/*--------------------------------------------------------------------------*/","                }","                #endif","/*--------------------------------------------------------------------------*/","            }","            #endif","/*--------------------------------------------------------------------------*/","        }","        #endif","/*--------------------------------------------------------------------------*/","    }","    #endif","/*--------------------------------------------------------------------------*/","                        }","                        #endif","/*--------------------------------------------------------------------------*/","                    }","                    #endif","/*--------------------------------------------------------------------------*/","                }","                #endif","/*--------------------------------------------------------------------------*/","            }","            #endif","/*--------------------------------------------------------------------------*/","        }","        #endif","/*--------------------------------------------------------------------------*/","    }","/*--------------------------------------------------------------------------*/","    FxaaFloat dstN = posM.x - posN.x;","    FxaaFloat dstP = posP.x - posM.x;","    if(!horzSpan) dstN = posM.y - posN.y;","    if(!horzSpan) dstP = posP.y - posM.y;","/*--------------------------------------------------------------------------*/","    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;","    FxaaFloat spanLength = (dstP + dstN);","    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;","    FxaaFloat spanLengthRcp = 1.0/spanLength;","/*--------------------------------------------------------------------------*/","    FxaaBool directionN = dstN < dstP;","    FxaaFloat dst = min(dstN, dstP);","    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;","    FxaaFloat subpixG = subpixF * subpixF;","    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;","    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;","/*--------------------------------------------------------------------------*/","    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;","    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);","    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;","    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;","    #if (FXAA_DISCARD == 1)","        return FxaaTexTop(tex, posM);","    #else","        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);","    #endif","}","/*==========================================================================*/","#endif","","void main() {","  gl_FragColor = FxaaPixelShader(","    vUv,","    vec4(0.0),","    tDiffuse,","    tDiffuse,","    tDiffuse,","    resolution,","    vec4(0.0),","    vec4(0.0),","    vec4(0.0),","    0.75,","    0.166,","    0.0833,","    0.0,","    0.0,","    0.0,","    vec4(0.0)","  );","","  // TODO avoid querying texture twice for same texel","  gl_FragColor.a = texture2D(tDiffuse, vUv).a;","}"].join("\n")}},function(e,t){THREE.GammaCorrectionShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 tex = texture2D( tDiffuse, vUv );","\tgl_FragColor = LinearTosRGB( tex );","}"].join("\n")}},function(e,t){THREE.ConvolutionShader={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new THREE.Vector2(.001953125,0)},cKernel:{value:[]}},vertexShader:["uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float cKernel[ KERNEL_SIZE_INT ];","uniform sampler2D tDiffuse;","uniform vec2 uImageIncrement;","varying vec2 vUv;","void main() {","\tvec2 imageCoord = vUv;","\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );","\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {","\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];","\t\timageCoord += uImageIncrement;","\t}","\tgl_FragColor = sum;","}"].join("\n"),buildKernel:function(e){function t(e,t){return Math.exp(-e*e/(2*t*t))}var r,n,a,o,i=2*Math.ceil(3*e)+1;for(i>25&&(i=25),o=.5*(i-1),n=new Array(i),a=0,r=0;r<i;++r)n[r]=t(r-o,e),a+=n[r];for(r=0;r<i;++r)n[r]/=a;return n}}},function(e,t){THREE.LuminosityHighPassShader={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new THREE.Color(0)},defaultOpacity:{value:0}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec3 defaultColor;","uniform float defaultOpacity;","uniform float luminosityThreshold;","uniform float smoothWidth;","varying vec2 vUv;","void main() {","\tvec4 texel = texture2D( tDiffuse, vUv );","\tvec3 luma = vec3( 0.299, 0.587, 0.114 );","\tfloat v = dot( texel.xyz, luma );","\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );","\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );","\tgl_FragColor = mix( outputColor, texel, alpha );","}"].join("\n")}},function(e,t){THREE.SepiaShader={uniforms:{tDiffuse:{value:null},amount:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float amount;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 color = texture2D( tDiffuse, vUv );","\tvec3 c = color.rgb;","\tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );","\tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );","\tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );","\tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );","}"].join("\n")}},function(e,t){THREE.DigitalGlitch={uniforms:{tDiffuse:{value:null},tDisp:{value:null},byp:{value:0},amount:{value:.08},angle:{value:.02},seed:{value:.02},seed_x:{value:.02},seed_y:{value:.02},distortion_x:{value:.5},distortion_y:{value:.6},col_s:{value:.05}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform int byp;","uniform sampler2D tDiffuse;","uniform sampler2D tDisp;","uniform float amount;","uniform float angle;","uniform float seed;","uniform float seed_x;","uniform float seed_y;","uniform float distortion_x;","uniform float distortion_y;","uniform float col_s;","varying vec2 vUv;","float rand(vec2 co){","\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);","}","void main() {","\tif(byp<1) {","\t\tvec2 p = vUv;","\t\tfloat xs = floor(gl_FragCoord.x / 0.5);","\t\tfloat ys = floor(gl_FragCoord.y / 0.5);","\t\tvec4 normal = texture2D (tDisp, p*seed*seed);","\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {","\t\t\tif(seed_x>0.){","\t\t\t\tp.y = 1. - (p.y + distortion_y);","\t\t\t}","\t\t\telse {","\t\t\t\tp.y = distortion_y;","\t\t\t}","\t\t}","\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {","\t\t\tif(seed_y>0.){","\t\t\t\tp.x=distortion_x;","\t\t\t}","\t\t\telse {","\t\t\t\tp.x = 1. - (p.x + distortion_x);","\t\t\t}","\t\t}","\t\tp.x+=normal.x*seed_x*(seed/5.);","\t\tp.y+=normal.y*seed_y*(seed/5.);","\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));","\t\tvec4 cr = texture2D(tDiffuse, p + offset);","\t\tvec4 cga = texture2D(tDiffuse, p);","\t\tvec4 cb = texture2D(tDiffuse, p - offset);","\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);","\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);","\t\tgl_FragColor = gl_FragColor+ snow;","\t}","\telse {","\t\tgl_FragColor=texture2D (tDiffuse, vUv);","\t}","}"].join("\n")}},function(e,t){THREE.SSAOShader={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SIZE:32},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},kernel:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new THREE.Vector2},cameraProjectionMatrix:{value:new THREE.Matrix4},cameraInverseProjectionMatrix:{value:new THREE.Matrix4},kernelRadius:{value:8},minDistance:{value:.005},maxDistance:{value:.05}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tNormal;","uniform sampler2D tDepth;","uniform sampler2D tNoise;","uniform vec3 kernel[ KERNEL_SIZE ];","uniform vec2 resolution;","uniform float cameraNear;","uniform float cameraFar;","uniform mat4 cameraProjectionMatrix;","uniform mat4 cameraInverseProjectionMatrix;","uniform float kernelRadius;","uniform float minDistance;","uniform float maxDistance;","varying vec2 vUv;","#include <packing>","float getDepth( const in vec2 screenPosition ) {","\treturn texture2D( tDepth, screenPosition ).x;","}","float getLinearDepth( const in vec2 screenPosition ) {","\t#if PERSPECTIVE_CAMERA == 1","\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;","\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );","\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );","\t#else","\t\treturn texture2D( depthSampler, coord ).x;","\t#endif","}","float getViewZ( const in float depth ) {","\t#if PERSPECTIVE_CAMERA == 1","\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );","\t#else","\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );","\t#endif","}","vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {","\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];","\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );","\tclipPosition *= clipW; // unprojection.","\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;","}","vec3 getViewNormal( const in vec2 screenPosition ) {","\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );","}","void main() {","\tfloat depth = getDepth( vUv );","\tfloat viewZ = getViewZ( depth );","\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );","\tvec3 viewNormal = getViewNormal( vUv );"," vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );","\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;","\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );","\tvec3 bitangent = cross( viewNormal, tangent );","\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );"," float occlusion = 0.0;"," for ( int i = 0; i < KERNEL_SIZE; i ++ ) {","\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];","\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );","\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );","\t\tsamplePointNDC /= samplePointNDC.w;","\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;","\t\tfloat realDepth = getLinearDepth( samplePointUv );","\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );","\t\tfloat delta = sampleDepth - realDepth;","\t\tif ( delta > minDistance && delta < maxDistance ) {","\t\t\tocclusion += 1.0;","\t\t}","\t}","\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );","\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );","}"].join("\n")},THREE.SSAODepthShader={defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDepth;","uniform float cameraNear;","uniform float cameraFar;","varying vec2 vUv;","#include <packing>","float getLinearDepth( const in vec2 screenPosition ) {","\t#if PERSPECTIVE_CAMERA == 1","\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;","\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );","\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );","\t#else","\t\treturn texture2D( depthSampler, coord ).x;","\t#endif","}","void main() {","\tfloat depth = getLinearDepth( vUv );","\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );","}"].join("\n")},THREE.SSAOBlurShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","void main() {","\tvec2 texelSize = ( 1.0 / resolution );","\tfloat result = 0.0;","\tfor ( int i = - 2; i <= 2; i ++ ) {","\t\tfor ( int j = - 2; j <= 2; j ++ ) {","\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;","\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;","\t\t}","\t}","\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );","}"].join("\n")}},function(e,t){THREE.VignetteShader={uniforms:{tDiffuse:{value:null},offset:{value:1},darkness:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float offset;","uniform float darkness;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","\tvec4 texel = texture2D( tDiffuse, vUv );","\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );","\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );","}"].join("\n")}},function(e,t){THREE.GodRaysDepthMaskShader={uniforms:{tInput:{value:null}},vertexShader:["varying vec2 vUv;","void main() {"," vUv = uv;"," gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tInput;","void main() {","\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );","}"].join("\n")},THREE.GodRaysGenerateShader={uniforms:{tInput:{value:null},fStepSize:{value:1},vSunPositionScreenSpace:{value:new THREE.Vector3}},vertexShader:["varying vec2 vUv;","void main() {"," vUv = uv;"," gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["#define TAPS_PER_PASS 6.0","varying vec2 vUv;","uniform sampler2D tInput;","uniform vec3 vSunPositionScreenSpace;","uniform float fStepSize;","void main() {","\tvec2 delta = vSunPositionScreenSpace.xy - vUv;","\tfloat dist = length( delta );","\tvec2 stepv = fStepSize * delta / dist;","\tfloat iters = dist/fStepSize;","\tvec2 uv = vUv.xy;","\tfloat col = 0.0;","\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );","\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;","\tuv += stepv;","\tgl_FragColor = vec4( col/TAPS_PER_PASS );","\tgl_FragColor.a = 1.0;","}"].join("\n")},THREE.GodRaysCombineShader={uniforms:{tColors:{value:null},tGodRays:{value:null},fGodRayIntensity:{value:.69}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform sampler2D tColors;","uniform sampler2D tGodRays;","uniform float fGodRayIntensity;","void main() {","\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );","\tgl_FragColor.a = 1.0;","}"].join("\n")},THREE.GodRaysFakeSunShader={uniforms:{vSunPositionScreenSpace:{value:new THREE.Vector3},fAspect:{value:1},sunColor:{value:new THREE.Color(16772608)},bgColor:{value:new THREE.Color(0)}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = uv;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["varying vec2 vUv;","uniform vec3 vSunPositionScreenSpace;","uniform float fAspect;","uniform vec3 sunColor;","uniform vec3 bgColor;","void main() {","\tvec2 diff = vUv - vSunPositionScreenSpace.xy;","\tdiff.x *= fAspect;","\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );","\tprop = 0.35 * pow( 1.0 - prop, 3.0 );","\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;","\tgl_FragColor.w = 1.0;","}"].join("\n")}},function(e,t){THREE.AnaglyphEffect=function(e,t,r){this.colorMatrixLeft=(new THREE.Matrix3).fromArray([1.0671679973602295,-.0016435992438346148,.0001777536963345483,-.028107794001698494,-.00019593400065787137,-.0002875397040043026,-.04279090091586113,15809757314855233e-21,-.00024287120322696865]),this.colorMatrixRight=(new THREE.Matrix3).fromArray([-.0355340838432312,-.06440307199954987,.018319187685847282,-.10269022732973099,.8079727292060852,-.04835830628871918,.0001224992738571018,-.009558862075209618,.567823588848114]);var n=new THREE.OrthographicCamera(-1,1,1,-1,0,1),a=new THREE.Scene,o=new THREE.StereoCamera,i={minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat};void 0===t&&(t=512),void 0===r&&(r=512);var s=new THREE.WebGLRenderTarget(t,r,i),l=new THREE.WebGLRenderTarget(t,r,i),c=new THREE.ShaderMaterial({uniforms:{mapLeft:{value:s.texture},mapRight:{value:l.texture},colorMatrixLeft:{value:this.colorMatrixLeft},colorMatrixRight:{value:this.colorMatrixRight}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = vec2( uv.x, uv.y );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D mapLeft;","uniform sampler2D mapRight;","varying vec2 vUv;","uniform mat3 colorMatrixLeft;","uniform mat3 colorMatrixRight;","float lin( float c ) {","\treturn c <= 0.04045 ? c * 0.0773993808 :","\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );","}","vec4 lin( vec4 c ) {","\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );","}","float dev( float c ) {","\treturn c <= 0.0031308 ? c * 12.92","\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;","}","void main() {","\tvec2 uv = vUv;","\tvec4 colorL = lin( texture2D( mapLeft, uv ) );","\tvec4 colorR = lin( texture2D( mapRight, uv ) );","\tvec3 color = clamp(","\t\t\tcolorMatrixLeft * colorL.rgb +","\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );","\tgl_FragColor = vec4(","\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),","\t\t\tmax( colorL.a, colorR.a ) );","}"].join("\n")}),f=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),c);a.add(f),this.setSize=function(t,r){e.setSize(t,r);var n=e.getPixelRatio();s.setSize(t*n,r*n),l.setSize(t*n,r*n)},this.render=function(t,r){var i=e.getRenderTarget();t.updateMatrixWorld(),null===r.parent&&r.updateMatrixWorld(),o.update(r),e.setRenderTarget(s),e.clear(),e.render(t,o.cameraL),e.setRenderTarget(l),e.clear(),e.render(t,o.cameraR),e.setRenderTarget(null),e.render(a,n),e.setRenderTarget(i)},this.dispose=function(){s&&s.dispose(),l&&l.dispose(),f&&f.geometry.dispose(),c&&c.dispose()}}},function(e,t){THREE.StereoEffect=function(e){var t=new THREE.StereoCamera;t.aspect=.5;var r=new THREE.Vector2;this.setEyeSeparation=function(e){t.eyeSep=e},this.setSize=function(t,r){e.setSize(t,r)},this.render=function(n,a){n.updateMatrixWorld(),null===a.parent&&a.updateMatrixWorld(),t.update(a),e.getSize(r),e.autoClear&&e.clear(),e.setScissorTest(!0),e.setScissor(0,0,r.width/2,r.height),e.setViewport(0,0,r.width/2,r.height),e.render(n,t.cameraL),e.setScissor(r.width/2,0,r.width/2,r.height),e.setViewport(r.width/2,0,r.width/2,r.height),e.render(n,t.cameraR),e.setScissorTest(!1)}}},function(e,t){THREE.ParallaxBarrierEffect=function(e){var t=new THREE.OrthographicCamera(-1,1,1,-1,0,1),r=new THREE.Scene,n=new THREE.StereoCamera,a={minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat},o=new THREE.WebGLRenderTarget(512,512,a),i=new THREE.WebGLRenderTarget(512,512,a),s=new THREE.ShaderMaterial({uniforms:{mapLeft:{value:o.texture},mapRight:{value:i.texture}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = vec2( uv.x, uv.y );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D mapLeft;","uniform sampler2D mapRight;","varying vec2 vUv;","void main() {","\tvec2 uv = vUv;","\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {","\t\tgl_FragColor = texture2D( mapLeft, uv );","\t} else {","\t\tgl_FragColor = texture2D( mapRight, uv );","\t}","}"].join("\n")}),l=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),s);r.add(l),this.setSize=function(t,r){e.setSize(t,r);var n=e.getPixelRatio();o.setSize(t*n,r*n),i.setSize(t*n,r*n)},this.render=function(a,s){a.updateMatrixWorld(),null===s.parent&&s.updateMatrixWorld(),n.update(s),e.setRenderTarget(o),e.clear(),e.render(a,n.cameraL),e.setRenderTarget(i),e.clear(),e.render(a,n.cameraR),e.setRenderTarget(null),e.render(r,t)}}},function(e,t){THREE.TypedArrayUtils={},THREE.TypedArrayUtils.quicksortIP=function(e,t,r){for(var n,a,o=[],i=-1,s=0,l=e.length/t-1,c=0,f=0,d=0,u=function(r,n){for(r*=t,n*=t,d=0;d<t;d++)c=e[r+d],e[r+d]=e[n+d],e[n+d]=c},p=new Float32Array(t),h=new Float32Array(t);;)if(l-s<=25){for(a=s+1;a<=l;a++){for(f=0;f<t;f++)p[f]=e[a*t+f];for(n=a-1;n>=s&&e[n*t+r]>p[r];){for(f=0;f<t;f++)e[(n+1)*t+f]=e[n*t+f];n--}for(f=0;f<t;f++)e[(n+1)*t+f]=p[f]}if(-1==i)break;l=o[i--],s=o[i--]}else{for(a=l,u(s+l>>1,n=s+1),e[s*t+r]>e[l*t+r]&&u(s,l),e[n*t+r]>e[l*t+r]&&u(n,l),e[s*t+r]>e[n*t+r]&&u(s,n),f=0;f<t;f++)h[f]=e[n*t+f];for(;;){do{n++}while(e[n*t+r]<h[r]);do{a--}while(e[a*t+r]>h[r]);if(a<n)break;u(n,a)}for(f=0;f<t;f++)e[(s+1)*t+f]=e[a*t+f],e[a*t+f]=h[f];l-n+1>=a-s?(o[++i]=n,o[++i]=l,l=a-1):(o[++i]=s,o[++i]=a-1,s=n)}return e},THREE.TypedArrayUtils.Kdtree=function(e,t,r){var n=this,a=0,o=function(e,t){return e.subarray(t*r,t*r+r)};this.root=function e(t,i,s,l){var c,f,d=i%r,u=t.length/r;return i>a&&(a=i),0===u?null:1===u?new n.Node(o(t,0),i,s,l):(THREE.TypedArrayUtils.quicksortIP(t,r,d),c=Math.floor(u/2),(f=new n.Node(o(t,c),i,s,c+l)).left=e(t.subarray(0,c*r),i+1,f,l),f.right=e(t.subarray((c+1)*r,t.length),i+1,f,l+c+1),f)}(e,0,null,0),this.getMaxDepth=function(){return a},this.nearest=function(e,a,o){var i,s,l;if(l=new THREE.TypedArrayUtils.Kdtree.BinaryHeap((function(e){return-e[1]})),o)for(i=0;i<a;i+=1)l.push([null,o]);for(function n(o){var i,s,c,f,d=o.depth%r,u=t(e,o.obj),p=[];function h(e,t){l.push([e,t]),l.size()>a&&l.pop()}for(f=0;f<r;f+=1)f===o.depth%r?p[f]=e[f]:p[f]=o.obj[f];s=t(p,o.obj),null!==o.right||null!==o.left?(n(i=null===o.right?o.left:null===o.left?o.right:e[d]<o.obj[d]?o.left:o.right),(l.size()<a||u<l.peek()[1])&&h(o,u),(l.size()<a||Math.abs(s)<l.peek()[1])&&null!==(c=i===o.left?o.right:o.left)&&n(c)):(l.size()<a||u<l.peek()[1])&&h(o,u)}(n.root),s=[],i=0;i<a;i+=1)l.content[i][0]&&s.push([l.content[i][0],l.content[i][1]]);return s}},THREE.TypedArrayUtils.Kdtree.prototype.Node=function(e,t,r,n){this.obj=e,this.left=null,this.right=null,this.parent=r,this.depth=t,this.pos=n},THREE.TypedArrayUtils.Kdtree.BinaryHeap=function(e){this.content=[],this.scoreFunction=e},THREE.TypedArrayUtils.Kdtree.BinaryHeap.prototype={push:function(e){this.content.push(e),this.bubbleUp(this.content.length-1)},pop:function(){var e=this.content[0],t=this.content.pop();return this.content.length>0&&(this.content[0]=t,this.sinkDown(0)),e},peek:function(){return this.content[0]},remove:function(e){for(var t=this.content.length,r=0;r<t;r++)if(this.content[r]==e){var n=this.content.pop();return void(r!=t-1&&(this.content[r]=n,this.scoreFunction(n)<this.scoreFunction(e)?this.bubbleUp(r):this.sinkDown(r)))}throw new Error("Node not found.")},size:function(){return this.content.length},bubbleUp:function(e){for(var t=this.content[e];e>0;){var r=Math.floor((e+1)/2)-1,n=this.content[r];if(!(this.scoreFunction(t)<this.scoreFunction(n)))break;this.content[r]=t,this.content[e]=n,e=r}},sinkDown:function(e){for(var t=this.content.length,r=this.content[e],n=this.scoreFunction(r);;){var a=2*(e+1),o=a-1,i=null;if(o<t){var s=this.content[o],l=this.scoreFunction(s);l<n&&(i=o)}if(a<t){var c=this.content[a];this.scoreFunction(c)<(null===i?n:l)&&(i=a)}if(null===i)break;this.content[e]=this.content[i],this.content[i]=r,e=i}}}},function(e,t){THREE.BufferGeometryUtils={computeTangents:function(e){var t=e.index,r=e.attributes;if(null!==t&&void 0!==r.position&&void 0!==r.normal&&void 0!==r.uv){var n=t.array,a=r.position.array,o=r.normal.array,i=r.uv.array,s=a.length/3;void 0===r.tangent&&e.setAttribute("tangent",new THREE.BufferAttribute(new Float32Array(4*s),4));for(var l=r.tangent.array,c=[],f=[],d=0;d<s;d++)c[d]=new THREE.Vector3,f[d]=new THREE.Vector3;var u=new THREE.Vector3,p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector2,m=new THREE.Vector2,x=new THREE.Vector2,g=new THREE.Vector3,y=new THREE.Vector3,E=e.groups;0===E.length&&(E=[{start:0,count:n.length}]);d=0;for(var w=E.length;d<w;++d)for(var b=P=(H=E[d]).start,T=P+H.count;b<T;b+=3)z(n[b+0],n[b+1],n[b+2]);var _,S,R,A=new THREE.Vector3,M=new THREE.Vector3,C=new THREE.Vector3,L=new THREE.Vector3;for(d=0,w=E.length;d<w;++d){var H,P;for(b=P=(H=E[d]).start,T=P+H.count;b<T;b+=3)k(n[b+0]),k(n[b+1]),k(n[b+2])}}else console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function z(e,t,r){u.fromArray(a,3*e),p.fromArray(a,3*t),h.fromArray(a,3*r),v.fromArray(i,2*e),m.fromArray(i,2*t),x.fromArray(i,2*r),p.sub(u),h.sub(u),m.sub(v),x.sub(v);var n=1/(m.x*x.y-x.x*m.y);isFinite(n)&&(g.copy(p).multiplyScalar(x.y).addScaledVector(h,-m.y).multiplyScalar(n),y.copy(h).multiplyScalar(m.x).addScaledVector(p,-x.x).multiplyScalar(n),c[e].add(g),c[t].add(g),c[r].add(g),f[e].add(y),f[t].add(y),f[r].add(y))}function k(e){C.fromArray(o,3*e),L.copy(C),S=c[e],A.copy(S),A.sub(C.multiplyScalar(C.dot(S))).normalize(),M.crossVectors(L,S),R=M.dot(f[e]),_=R<0?-1:1,l[4*e]=A.x,l[4*e+1]=A.y,l[4*e+2]=A.z,l[4*e+3]=_}},mergeBufferGeometries:function(e,t){for(var r=null!==e[0].index,n=new Set(Object.keys(e[0].attributes)),a=new Set(Object.keys(e[0].morphAttributes)),o={},i={},s=e[0].morphTargetsRelative,l=new THREE.BufferGeometry,c=0,f=0;f<e.length;++f){var d=e[f],u=0;if(r!==(null!==d.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var p in d.attributes){if(!n.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;void 0===o[p]&&(o[p]=[]),o[p].push(d.attributes[p]),u++}if(u!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(s!==d.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var p in d.morphAttributes){if(!a.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===i[p]&&(i[p]=[]),i[p].push(d.morphAttributes[p])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(d.userData),t){var h;if(r)h=d.index.count;else{if(void 0===d.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;h=d.attributes.position.count}l.addGroup(c,h,f),c+=h}}if(r){var v=0,m=[];for(f=0;f<e.length;++f){for(var x=e[f].index,g=0;g<x.count;++g)m.push(x.getX(g)+v);v+=e[f].attributes.position.count}l.setIndex(m)}for(var p in o){var y=this.mergeBufferAttributes(o[p]);if(!y)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+p+" attribute."),null;l.setAttribute(p,y)}for(var p in i){var E=i[p][0].length;if(0===E)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[p]=[];for(f=0;f<E;++f){var w=[];for(g=0;g<i[p].length;++g)w.push(i[p][g][f]);var b=this.mergeBufferAttributes(w);if(!b)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+p+" morphAttribute."),null;l.morphAttributes[p].push(b)}}return l},mergeBufferAttributes:function(e){for(var t,r,n,a=0,o=0;o<e.length;++o){var i=e[o];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=i.itemSize),r!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=i.normalized),n!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;a+=i.array.length}var s=new t(a),l=0;for(o=0;o<e.length;++o)s.set(e[o].array,l),l+=e[o].array.length;return new THREE.BufferAttribute(s,r,n)},interleaveAttributes:function(e){for(var t,r=0,n=0,a=0,o=e.length;a<o;++a){var i=e[a];if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,n+=i.itemSize}var s=new THREE.InterleavedBuffer(new t(r),n),l=0,c=[],f=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"],u=0;for(o=e.length;u<o;u++){var p=(i=e[u]).itemSize,h=i.count,v=new THREE.InterleavedBufferAttribute(s,p,l,i.normalized);c.push(v),l+=p;for(var m=0;m<h;m++)for(var x=0;x<p;x++)v[d[x]](m,i[f[x]](m))}return c},estimateBytesUsed:function(e){var t=0;for(var r in e.attributes){var n=e.getAttribute(r);t+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}var a=e.getIndex();return t+=a?a.count*a.itemSize*a.array.BYTES_PER_ELEMENT:0},mergeVertices:function(e,t=1e-4){t=Math.max(t,Number.EPSILON);for(var r={},n=e.getIndex(),a=e.getAttribute("position"),o=n?n.count:a.count,i=0,s=Object.keys(e.attributes),l={},c={},f=[],d=["getX","getY","getZ","getW"],u=0,p=s.length;u<p;u++){l[y=s[u]]=[],(T=e.morphAttributes[y])&&(c[y]=new Array(T.length).fill().map(()=>[]))}var h=Math.log10(1/t),v=Math.pow(10,h);for(u=0;u<o;u++){var m=n?n.getX(u):u,x="",g=0;for(p=s.length;g<p;g++)for(var y=s[g],E=(b=e.getAttribute(y)).itemSize,w=0;w<E;w++)x+=~~(b[d[w]](m)*v)+",";if(x in r)f.push(r[x]);else{for(g=0,p=s.length;g<p;g++){y=s[g];var b=e.getAttribute(y),T=e.morphAttributes[y],_=(E=b.itemSize,l[y]),S=c[y];for(w=0;w<E;w++){var R=d[w];if(_.push(b[R](m)),T)for(var A=0,M=T.length;A<M;A++)S[A].push(T[A][R](m))}}r[x]=i,f.push(i),i++}}const C=e.clone();for(u=0,p=s.length;u<p;u++){y=s[u];var L=e.getAttribute(y),H=new L.array.constructor(l[y]);b=new THREE.BufferAttribute(H,L.itemSize,L.normalized);if(C.setAttribute(y,b),y in c)for(g=0;g<c[y].length;g++){var P=e.morphAttributes[y][g],z=(H=new P.array.constructor(c[y][g]),new THREE.BufferAttribute(H,P.itemSize,P.normalized));C.morphAttributes[y][g]=z}}return C.setIndex(f),C},toTrianglesDrawMode:function(e,t){if(t===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===THREE.TriangleFanDrawMode||t===THREE.TriangleStripDrawMode){var r=e.getIndex();if(null===r){var n=[],a=e.getAttribute("position");if(void 0===a)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var o=0;o<a.count;o++)n.push(o);e.setIndex(n),r=e.getIndex()}var i=r.count-2,s=[];if(t===THREE.TriangleFanDrawMode)for(o=1;o<=i;o++)s.push(r.getX(0)),s.push(r.getX(o)),s.push(r.getX(o+1));else for(o=0;o<i;o++)o%2==0?(s.push(r.getX(o)),s.push(r.getX(o+1)),s.push(r.getX(o+2))):(s.push(r.getX(o+2)),s.push(r.getX(o+1)),s.push(r.getX(o)));s.length/3!==i&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var l=e.clone();return l.setIndex(s),l.clearGroups(),l}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}}},function(e,t){THREE.Volume=function(e,t,r,n,a){if(arguments.length>0){switch(this.xLength=Number(e)||1,this.yLength=Number(t)||1,this.zLength=Number(r)||1,n){case"Uint8":case"uint8":case"uchar":case"unsigned char":case"uint8_t":this.data=new Uint8Array(a);break;case"Int8":case"int8":case"signed char":case"int8_t":this.data=new Int8Array(a);break;case"Int16":case"int16":case"short":case"short int":case"signed short":case"signed short int":case"int16_t":this.data=new Int16Array(a);break;case"Uint16":case"uint16":case"ushort":case"unsigned short":case"unsigned short int":case"uint16_t":this.data=new Uint16Array(a);break;case"Int32":case"int32":case"int":case"signed int":case"int32_t":this.data=new Int32Array(a);break;case"Uint32":case"uint32":case"uint":case"unsigned int":case"uint32_t":this.data=new Uint32Array(a);break;case"longlong":case"long long":case"long long int":case"signed long long":case"signed long long int":case"int64":case"int64_t":case"ulonglong":case"unsigned long long":case"unsigned long long int":case"uint64":case"uint64_t":throw"Error in THREE.Volume constructor : this type is not supported in JavaScript";case"Float32":case"float32":case"float":this.data=new Float32Array(a);break;case"Float64":case"float64":case"double":this.data=new Float64Array(a);break;default:this.data=new Uint8Array(a)}if(this.data.length!==this.xLength*this.yLength*this.zLength)throw"Error in THREE.Volume constructor, lengths are not matching arrayBuffer size"}this.spacing=[1,1,1],this.offset=[0,0,0],this.matrix=new THREE.Matrix3,this.matrix.identity();var o=-1/0;Object.defineProperty(this,"lowerThreshold",{get:function(){return o},set:function(e){o=e,this.sliceList.forEach((function(e){e.geometryNeedsUpdate=!0}))}});var i=1/0;Object.defineProperty(this,"upperThreshold",{get:function(){return i},set:function(e){i=e,this.sliceList.forEach((function(e){e.geometryNeedsUpdate=!0}))}}),this.sliceList=[]},THREE.Volume.prototype={constructor:THREE.Volume,getData:function(e,t,r){return this.data[r*this.xLength*this.yLength+t*this.xLength+e]},access:function(e,t,r){return r*this.xLength*this.yLength+t*this.xLength+e},reverseAccess:function(e){var t=Math.floor(e/(this.yLength*this.xLength)),r=Math.floor((e-t*this.yLength*this.xLength)/this.xLength);return[e-t*this.yLength*this.xLength-r*this.xLength,r,t]},map:function(e,t){var r=this.data.length;t=t||this;for(var n=0;n<r;n++)this.data[n]=e.call(t,this.data[n],n,this.data);return this},extractPerpendicularPlane:function(e,t){var r,n,a,o,i,s,l,c,f=(new THREE.Matrix4).identity(),d=this,u=new THREE.Vector3,p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector3(this.xLength,this.yLength,this.zLength);switch(e){case"x":u.set(1,0,0),p.set(0,0,-1),h.set(0,-1,0),i=this.spacing[2],s=this.spacing[1],c=new THREE.Vector3(t,0,0),f.multiply((new THREE.Matrix4).makeRotationY(Math.PI/2)),l=(d.RASDimensions[0]-1)/2,f.setPosition(new THREE.Vector3(t-l,0,0));break;case"y":u.set(0,1,0),p.set(1,0,0),h.set(0,0,1),i=this.spacing[0],s=this.spacing[2],c=new THREE.Vector3(0,t,0),f.multiply((new THREE.Matrix4).makeRotationX(-Math.PI/2)),l=(d.RASDimensions[1]-1)/2,f.setPosition(new THREE.Vector3(0,t-l,0));break;case"z":default:u.set(0,0,1),p.set(1,0,0),h.set(0,-1,0),i=this.spacing[0],s=this.spacing[1],c=new THREE.Vector3(0,0,t),l=(d.RASDimensions[2]-1)/2,f.setPosition(new THREE.Vector3(0,0,t-l))}p.applyMatrix4(d.inverseMatrix).normalize(),p.argVar="i",h.applyMatrix4(d.inverseMatrix).normalize(),h.argVar="j",u.applyMatrix4(d.inverseMatrix).normalize(),r=Math.floor(Math.abs(p.dot(v))),n=Math.floor(Math.abs(h.dot(v))),a=Math.abs(r*i),o=Math.abs(n*s),c=Math.abs(Math.round(c.applyMatrix4(d.inverseMatrix).dot(u)));var m=[new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1)],x=[p,h,u].find((function(e){return Math.abs(e.dot(m[0]))>.9})),g=[p,h,u].find((function(e){return Math.abs(e.dot(m[1]))>.9})),y=[p,h,u].find((function(e){return Math.abs(e.dot(m[2]))>.9}));return{iLength:r,jLength:n,sliceAccess:function(e,t){var r=x===u?c:"i"===x.argVar?e:t,n=g===u?c:"i"===g.argVar?e:t,a=y===u?c:"i"===y.argVar?e:t,o=x.dot(m[0])>0?r:d.xLength-1-r,i=g.dot(m[1])>0?n:d.yLength-1-n,s=y.dot(m[2])>0?a:d.zLength-1-a;return d.access(o,i,s)},matrix:f,planeWidth:a,planeHeight:o}},extractSlice:function(e,t){var r=new THREE.VolumeSlice(this,t,e);return this.sliceList.push(r),r},repaintAllSlices:function(){return this.sliceList.forEach((function(e){e.repaint()})),this},computeMinMax:function(){var e=1/0,t=-1/0,r=this.data.length,n=0;for(n=0;n<r;n++)if(!isNaN(this.data[n])){var a=this.data[n];e=Math.min(e,a),t=Math.max(t,a)}return this.min=e,this.max=t,[e,t]}}},function(e,t){THREE.VolumeSlice=function(e,t,r){var n=this;this.volume=e,t=t||0,Object.defineProperty(this,"index",{get:function(){return t},set:function(e){return t=e,n.geometryNeedsUpdate=!0,t}}),this.axis=r||"z",this.canvas=document.createElement("canvas"),this.canvasBuffer=document.createElement("canvas"),this.updateGeometry();var a=new THREE.Texture(this.canvas);a.minFilter=THREE.LinearFilter,a.wrapS=a.wrapT=THREE.ClampToEdgeWrapping;var o=new THREE.MeshBasicMaterial({map:a,side:THREE.DoubleSide,transparent:!0});this.mesh=new THREE.Mesh(this.geometry,o),this.mesh.matrixAutoUpdate=!1,this.geometryNeedsUpdate=!0,this.repaint()},THREE.VolumeSlice.prototype={constructor:THREE.VolumeSlice,repaint:function(){this.geometryNeedsUpdate&&this.updateGeometry();var e=this.iLength,t=this.jLength,r=this.sliceAccess,n=this.volume,a=this.canvasBuffer,o=this.ctxBuffer,i=o.getImageData(0,0,e,t),s=i.data,l=n.data,c=n.upperThreshold,f=n.lowerThreshold,d=n.windowLow,u=n.windowHigh,p=0;if("label"===n.dataType)for(var h=0;h<t;h++)for(var v=0;v<e;v++){var m=l[r(v,h)];m=m>=this.colorMap.length?m%this.colorMap.length+1:m;var x=this.colorMap[m];s[4*p]=x>>24&255,s[4*p+1]=x>>16&255,s[4*p+2]=x>>8&255,s[4*p+3]=255&x,p++}else for(h=0;h<t;h++)for(v=0;v<e;v++){var g=l[r(v,h)],y=255;y=c>=g&&f<=g?y:0,g=(g=Math.floor(255*(g-d)/(u-d)))>255?255:g<0?0:0|g,s[4*p]=g,s[4*p+1]=g,s[4*p+2]=g,s[4*p+3]=y,p++}o.putImageData(i,0,0),this.ctx.drawImage(a,0,0,e,t,0,0,this.canvas.width,this.canvas.height),this.mesh.material.map.needsUpdate=!0},updateGeometry:function(){var e=this.volume.extractPerpendicularPlane(this.axis,this.index);this.sliceAccess=e.sliceAccess,this.jLength=e.jLength,this.iLength=e.iLength,this.matrix=e.matrix,this.canvas.width=e.planeWidth,this.canvas.height=e.planeHeight,this.canvasBuffer.width=this.iLength,this.canvasBuffer.height=this.jLength,this.ctx=this.canvas.getContext("2d"),this.ctxBuffer=this.canvasBuffer.getContext("2d"),this.geometry&&this.geometry.dispose(),this.geometry=new THREE.PlaneBufferGeometry(e.planeWidth,e.planeHeight),this.mesh&&(this.mesh.geometry=this.geometry,this.mesh.matrix.identity(),this.mesh.applyMatrix4(this.matrix)),this.geometryNeedsUpdate=!1}}},function(e,t){THREE.VolumeRenderShader1={uniforms:{u_size:{value:new THREE.Vector3(1,1,1)},u_renderstyle:{value:0},u_renderthreshold:{value:.5},u_clim:{value:new THREE.Vector2(1,1)},u_data:{value:null},u_cmdata:{value:null}},vertexShader:["\t\tvarying vec4 v_nearpos;","\t\tvarying vec4 v_farpos;","\t\tvarying vec3 v_position;","\t\tvoid main() {","\t\t\t\tmat4 viewtransformf = modelViewMatrix;","\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);","\t\t\t\tvec4 position4 = vec4(position, 1.0);","\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;","\t\t\t\tpos_in_cam.z = -pos_in_cam.w;","\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;","\t\t\t\tpos_in_cam.z = pos_in_cam.w;","\t\t\t\tv_farpos = viewtransformi * pos_in_cam;","\t\t\t\tv_position = position;","\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;","\t\t}"].join("\n"),fragmentShader:["\t\tprecision highp float;","\t\tprecision mediump sampler3D;","\t\tuniform vec3 u_size;","\t\tuniform int u_renderstyle;","\t\tuniform float u_renderthreshold;","\t\tuniform vec2 u_clim;","\t\tuniform sampler3D u_data;","\t\tuniform sampler2D u_cmdata;","\t\tvarying vec3 v_position;","\t\tvarying vec4 v_nearpos;","\t\tvarying vec4 v_farpos;","\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3","\t\tconst int REFINEMENT_STEPS = 4;","\t\tconst float relative_step_size = 1.0;","\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);","\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);","\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);","\t\tconst float shininess = 40.0;","\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);","\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);","\t\tfloat sample1(vec3 texcoords);","\t\tvec4 apply_colormap(float val);","\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);","\t\tvoid main() {","\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;","\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;","\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);","\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);","\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));","\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));","\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,","\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));","\t\t\t\tvec3 front = v_position + view_ray * distance;","\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);","\t\t\t\tif ( nsteps < 1 )","\t\t\t\t\t\tdiscard;","\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);","\t\t\t\tvec3 start_loc = front / u_size;","\t\t\t\tif (u_renderstyle == 0)","\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);","\t\t\t\telse if (u_renderstyle == 1)","\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);","\t\t\t\tif (gl_FragColor.a < 0.05)","\t\t\t\t\t\tdiscard;","\t\t}","\t\tfloat sample1(vec3 texcoords) {","\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */","\t\t\t\treturn texture(u_data, texcoords.xyz).r;","\t\t}","\t\tvec4 apply_colormap(float val) {","\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);","\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));","\t\t}","\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {","\t\t\t\tfloat max_val = -1e6;","\t\t\t\tint max_i = 100;","\t\t\t\tvec3 loc = start_loc;","\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {","\t\t\t\t\t\tif (iter >= nsteps)","\t\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\tfloat val = sample1(loc);","\t\t\t\t\t\tif (val > max_val) {","\t\t\t\t\t\t\t\tmax_val = val;","\t\t\t\t\t\t\t\tmax_i = iter;","\t\t\t\t\t\t}","\t\t\t\t\t\tloc += step;","\t\t\t\t}","\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);","\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);","\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {","\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));","\t\t\t\t\t\tiloc += istep;","\t\t\t\t}","\t\t\t\tgl_FragColor = apply_colormap(max_val);","\t\t}","\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {","\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent","\t\t\t\tvec4 color3 = vec4(0.0);\t// final color","\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative","\t\t\t\tvec3 loc = start_loc;","\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);","\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {","\t\t\t\t\t\tif (iter >= nsteps)","\t\t\t\t\t\t\t\tbreak;","\t\t\t\t\t\tfloat val = sample1(loc);","\t\t\t\t\t\tif (val > low_threshold) {","\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;","\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);","\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {","\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);","\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {","\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);","\t\t\t\t\t\t\t\t\t\t\t\treturn;","\t\t\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\t\t\tiloc += istep;","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\tloc += step;","\t\t\t\t}","\t\t}","\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)","\t\t{","\t\t\t\tvec3 V = normalize(view_ray);","\t\t\t\tvec3 N;","\t\t\t\tfloat val1, val2;","\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));","\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));","\t\t\t\tN[0] = val1 - val2;","\t\t\t\tval = max(max(val1, val2), val);","\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));","\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));","\t\t\t\tN[1] = val1 - val2;","\t\t\t\tval = max(max(val1, val2), val);","\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));","\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));","\t\t\t\tN[2] = val1 - val2;","\t\t\t\tval = max(max(val1, val2), val);","\t\t\t\tfloat gm = length(N); // gradient magnitude","\t\t\t\tN = normalize(N);","\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);","\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;","\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);","\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);","\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);","\t\t\t\tfor (int i=0; i<1; i++)","\t\t\t\t{","\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];","\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );","\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));","\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);","\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector","\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);","\t\t\t\t\t\tfloat mask1 = lightEnabled;","\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;","\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;","\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;","\t\t\t\t}","\t\t\t\tvec4 final_color;","\t\t\t\tvec4 color = apply_colormap(val);","\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;","\t\t\t\tfinal_color.a = color.a;","\t\t\t\treturn final_color;","\t\t}"].join("\n")}},function(e,t){THREE.DragControls=function(e,t,r){var n=new THREE.Plane,a=new THREE.Raycaster,o=new THREE.Vector2,i=new THREE.Vector3,s=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Matrix4,f=[],d=null,u=null,p=this;function h(){r.addEventListener("mousemove",m,!1),r.addEventListener("mousedown",x,!1),r.addEventListener("mouseup",g,!1),r.addEventListener("mouseleave",g,!1),r.addEventListener("touchmove",y,!1),r.addEventListener("touchstart",E,!1),r.addEventListener("touchend",w,!1)}function v(){r.removeEventListener("mousemove",m,!1),r.removeEventListener("mousedown",x,!1),r.removeEventListener("mouseup",g,!1),r.removeEventListener("mouseleave",g,!1),r.removeEventListener("touchmove",y,!1),r.removeEventListener("touchstart",E,!1),r.removeEventListener("touchend",w,!1),r.style.cursor=""}function m(h){if(!1!==p.enabled){h.preventDefault();var v=r.getBoundingClientRect();if(o.x=(h.clientX-v.left)/v.width*2-1,o.y=-(h.clientY-v.top)/v.height*2+1,a.setFromCamera(o,t),d&&p.enabled)return a.ray.intersectPlane(n,s)&&d.position.copy(s.sub(i).applyMatrix4(c)),void p.dispatchEvent({type:"drag",object:d});if(f.length=0,a.setFromCamera(o,t),a.intersectObjects(e,!0,f),f.length>0){var m=f[0].object;n.setFromNormalAndCoplanarPoint(t.getWorldDirection(n.normal),l.setFromMatrixPosition(m.matrixWorld)),u!==m&&(p.dispatchEvent({type:"hoveron",object:m}),r.style.cursor="pointer",u=m)}else null!==u&&(p.dispatchEvent({type:"hoveroff",object:u}),r.style.cursor="auto",u=null)}}function x(u){!1!==p.enabled&&(u.preventDefault(),f.length=0,a.setFromCamera(o,t),a.intersectObjects(e,!0,f),f.length>0&&(d=!0===p.transformGroup?e[0]:f[0].object,a.ray.intersectPlane(n,s)&&(c.getInverse(d.parent.matrixWorld),i.copy(s).sub(l.setFromMatrixPosition(d.matrixWorld))),r.style.cursor="move",p.dispatchEvent({type:"dragstart",object:d})))}function g(e){!1!==p.enabled&&(e.preventDefault(),d&&(p.dispatchEvent({type:"dragend",object:d}),d=null),r.style.cursor=u?"pointer":"auto")}function y(e){if(!1!==p.enabled){e.preventDefault(),e=e.changedTouches[0];var l=r.getBoundingClientRect();return o.x=(e.clientX-l.left)/l.width*2-1,o.y=-(e.clientY-l.top)/l.height*2+1,a.setFromCamera(o,t),d&&p.enabled?(a.ray.intersectPlane(n,s)&&d.position.copy(s.sub(i).applyMatrix4(c)),void p.dispatchEvent({type:"drag",object:d})):void 0}}function E(u){if(!1!==p.enabled){u.preventDefault(),u=u.changedTouches[0];var h=r.getBoundingClientRect();o.x=(u.clientX-h.left)/h.width*2-1,o.y=-(u.clientY-h.top)/h.height*2+1,f.length=0,a.setFromCamera(o,t),a.intersectObjects(e,!0,f),f.length>0&&(d=!0===p.transformGroup?e[0]:f[0].object,n.setFromNormalAndCoplanarPoint(t.getWorldDirection(n.normal),l.setFromMatrixPosition(d.matrixWorld)),a.ray.intersectPlane(n,s)&&(c.getInverse(d.parent.matrixWorld),i.copy(s).sub(l.setFromMatrixPosition(d.matrixWorld))),r.style.cursor="move",p.dispatchEvent({type:"dragstart",object:d}))}}function w(e){!1!==p.enabled&&(e.preventDefault(),d&&(p.dispatchEvent({type:"dragend",object:d}),d=null),r.style.cursor="auto")}h(),this.enabled=!0,this.transformGroup=!1,this.activate=h,this.deactivate=v,this.dispose=function(){v()},this.getObjects=function(){return e}},THREE.DragControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.DragControls.prototype.constructor=THREE.DragControls},function(e,t){THREE.TransformControls=function(e,t){void 0===t&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),THREE.Object3D.call(this),this.visible=!1,this.domElement=t;var r=new THREE.TransformControlsGizmo;this.add(r);var n=new THREE.TransformControlsPlane;this.add(n);var a=this;U("camera",e),U("object",void 0),U("enabled",!0),U("axis",null),U("mode","translate"),U("translationSnap",null),U("rotationSnap",null),U("scaleSnap",null),U("space","world"),U("size",1),U("dragging",!1),U("showX",!0),U("showY",!0),U("showZ",!0);var o={type:"change"},i={type:"mouseDown"},s={type:"mouseUp",mode:a.mode},l={type:"objectChange"},c=new THREE.Raycaster;function f(e,t,r){for(var n=t.intersectObject(e,!0),a=0;a<n.length;a++)if(n[a].object.visible||r)return n[a];return!1}var d=new THREE.Vector3,u=new THREE.Vector3,p=new THREE.Quaternion,h={X:new THREE.Vector3(1,0,0),Y:new THREE.Vector3(0,1,0),Z:new THREE.Vector3(0,0,1)},v=new THREE.Vector3,m=new THREE.Vector3,x=new THREE.Vector3,g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Vector3,w=0,b=new THREE.Vector3,T=new THREE.Quaternion,_=new THREE.Vector3,S=new THREE.Vector3,R=new THREE.Quaternion,A=new THREE.Quaternion,M=new THREE.Vector3,C=new THREE.Vector3,L=new THREE.Quaternion,H=new THREE.Vector3,P=new THREE.Vector3,z=new THREE.Quaternion,k=new THREE.Quaternion,N=new THREE.Vector3,D=new THREE.Vector3,F=new THREE.Vector3,I=new THREE.Quaternion,O=new THREE.Vector3;function U(e,t){var i=t;Object.defineProperty(a,e,{get:function(){return void 0!==i?i:t},set:function(t){i!==t&&(i=t,n[e]=t,r[e]=t,a.dispatchEvent({type:e+"-changed",value:t}),a.dispatchEvent(o))}}),a[e]=t,n[e]=t,r[e]=t}function G(e){if(a.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:e.button};var r=e.changedTouches?e.changedTouches[0]:e,n=t.getBoundingClientRect();return{x:(r.clientX-n.left)/n.width*2-1,y:-(r.clientY-n.top)/n.height*2+1,button:e.button}}function B(e){a.enabled&&a.pointerHover(G(e))}function V(e){a.enabled&&(a.domElement.ownerDocument.addEventListener("mousemove",j,!1),a.pointerHover(G(e)),a.pointerDown(G(e)))}function j(e){a.enabled&&a.pointerMove(G(e))}function W(e){a.enabled&&(a.domElement.ownerDocument.removeEventListener("mousemove",j,!1),a.pointerUp(G(e)))}U("worldPosition",P),U("worldPositionStart",C),U("worldQuaternion",z),U("worldQuaternionStart",L),U("cameraPosition",b),U("cameraQuaternion",T),U("pointStart",v),U("pointEnd",m),U("rotationAxis",g),U("rotationAngle",w),U("eye",D),t.addEventListener("mousedown",V,!1),t.addEventListener("touchstart",V,!1),t.addEventListener("mousemove",B,!1),t.addEventListener("touchmove",B,!1),t.addEventListener("touchmove",j,!1),a.domElement.ownerDocument.addEventListener("mouseup",W,!1),t.addEventListener("touchend",W,!1),t.addEventListener("touchcancel",W,!1),t.addEventListener("touchleave",W,!1),this.dispose=function(){t.removeEventListener("mousedown",V),t.removeEventListener("touchstart",V),t.removeEventListener("mousemove",B),a.domElement.ownerDocument.removeEventListener("mousemove",j),t.removeEventListener("touchmove",B),t.removeEventListener("touchmove",j),a.domElement.ownerDocument.removeEventListener("mouseup",W),t.removeEventListener("touchend",W),t.removeEventListener("touchcancel",W),t.removeEventListener("touchleave",W),this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))},this.attach=function(e){return this.object=e,this.visible=!0,this},this.detach=function(){return this.object=void 0,this.visible=!1,this.axis=null,this},this.updateMatrixWorld=function(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(S,R,M),this.object.matrixWorld.decompose(P,z,N),A.copy(R).inverse(),k.copy(z).inverse()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(b,T,_),D.copy(b).sub(P).normalize(),THREE.Object3D.prototype.updateMatrixWorld.call(this)},this.pointerHover=function(e){if(void 0!==this.object&&!0!==this.dragging&&(void 0===e.button||0===e.button)){c.setFromCamera(e,this.camera);var t=f(r.picker[this.mode],c);this.axis=t?t.object.name:null}},this.pointerDown=function(e){if(!(void 0===this.object||!0===this.dragging||void 0!==e.button&&0!==e.button||0!==e.button&&void 0!==e.button||null===this.axis)){c.setFromCamera(e,this.camera);var t=f(n,c,!0);if(t){var r=this.space;if("scale"===this.mode?r="local":"E"!==this.axis&&"XYZE"!==this.axis&&"XYZ"!==this.axis||(r="world"),"local"===r&&"rotate"===this.mode){var a=this.rotationSnap;"X"===this.axis&&a&&(this.object.rotation.x=Math.round(this.object.rotation.x/a)*a),"Y"===this.axis&&a&&(this.object.rotation.y=Math.round(this.object.rotation.y/a)*a),"Z"===this.axis&&a&&(this.object.rotation.z=Math.round(this.object.rotation.z/a)*a)}this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),F.copy(this.object.position),I.copy(this.object.quaternion),O.copy(this.object.scale),this.object.matrixWorld.decompose(C,L,H),v.copy(t.point).sub(C)}this.dragging=!0,i.mode=this.mode,this.dispatchEvent(i)}},this.pointerMove=function(e){var t=this.axis,r=this.mode,a=this.object,i=this.space;if("scale"===r?i="local":"E"!==t&&"XYZE"!==t&&"XYZ"!==t||(i="world"),void 0!==a&&null!==t&&!1!==this.dragging&&(void 0===e.button||0===e.button)){c.setFromCamera(e,this.camera);var s=f(n,c,!0);if(s){if(m.copy(s.point).sub(C),"translate"===r)x.copy(m).sub(v),"local"===i&&"XYZ"!==t&&x.applyQuaternion(k),-1===t.indexOf("X")&&(x.x=0),-1===t.indexOf("Y")&&(x.y=0),-1===t.indexOf("Z")&&(x.z=0),"local"===i&&"XYZ"!==t?x.applyQuaternion(I).divide(M):x.applyQuaternion(A).divide(M),a.position.copy(x).add(F),this.translationSnap&&("local"===i&&(a.position.applyQuaternion(p.copy(I).inverse()),-1!==t.search("X")&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.position.applyQuaternion(I)),"world"===i&&(a.parent&&a.position.add(d.setFromMatrixPosition(a.parent.matrixWorld)),-1!==t.search("X")&&(a.position.x=Math.round(a.position.x/this.translationSnap)*this.translationSnap),-1!==t.search("Y")&&(a.position.y=Math.round(a.position.y/this.translationSnap)*this.translationSnap),-1!==t.search("Z")&&(a.position.z=Math.round(a.position.z/this.translationSnap)*this.translationSnap),a.parent&&a.position.sub(d.setFromMatrixPosition(a.parent.matrixWorld))));else if("scale"===r){if(-1!==t.search("XYZ")){var b=m.length()/v.length();m.dot(v)<0&&(b*=-1),u.set(b,b,b)}else d.copy(v),u.copy(m),d.applyQuaternion(k),u.applyQuaternion(k),u.divide(d),-1===t.search("X")&&(u.x=1),-1===t.search("Y")&&(u.y=1),-1===t.search("Z")&&(u.z=1);a.scale.copy(O).multiply(u),this.scaleSnap&&(-1!==t.search("X")&&(a.scale.x=Math.round(a.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Y")&&(a.scale.y=Math.round(a.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==t.search("Z")&&(a.scale.z=Math.round(a.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===r){x.copy(m).sub(v);var T=20/P.distanceTo(d.setFromMatrixPosition(this.camera.matrixWorld));"E"===t?(g.copy(D),w=m.angleTo(v),y.copy(v).normalize(),E.copy(m).normalize(),w*=E.cross(y).dot(D)<0?1:-1):"XYZE"===t?(g.copy(x).cross(D).normalize(),w=x.dot(d.copy(g).cross(this.eye))*T):"X"!==t&&"Y"!==t&&"Z"!==t||(g.copy(h[t]),d.copy(h[t]),"local"===i&&d.applyQuaternion(z),w=x.dot(d.cross(D).normalize())*T),this.rotationSnap&&(w=Math.round(w/this.rotationSnap)*this.rotationSnap),this.rotationAngle=w,"local"===i&&"E"!==t&&"XYZE"!==t?(a.quaternion.copy(I),a.quaternion.multiply(p.setFromAxisAngle(g,w)).normalize()):(g.applyQuaternion(A),a.quaternion.copy(p.setFromAxisAngle(g,w)),a.quaternion.multiply(I).normalize())}this.dispatchEvent(o),this.dispatchEvent(l)}}},this.pointerUp=function(e){void 0!==e.button&&0!==e.button||(this.dragging&&null!==this.axis&&(s.mode=this.mode,this.dispatchEvent(s)),this.dragging=!1,void 0===e.button&&(this.axis=null))},this.getMode=function(){return a.mode},this.setMode=function(e){a.mode=e},this.setTranslationSnap=function(e){a.translationSnap=e},this.setRotationSnap=function(e){a.rotationSnap=e},this.setScaleSnap=function(e){a.scaleSnap=e},this.setSize=function(e){a.size=e},this.setSpace=function(e){a.space=e},this.update=function(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}},THREE.TransformControls.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.TransformControls,isTransformControls:!0}),THREE.TransformControlsGizmo=function(){"use strict";THREE.Object3D.call(this),this.type="TransformControlsGizmo";var e=new THREE.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:THREE.DoubleSide,fog:!1,toneMapped:!1}),t=new THREE.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),r=e.clone();r.opacity=.15;var n=e.clone();n.opacity=.33;var a=e.clone();a.color.set(16711680);var o=e.clone();o.color.set(65280);var i=e.clone();i.color.set(255);var s=e.clone();s.opacity=.25;var l=s.clone();l.color.set(16776960);var c=s.clone();c.color.set(65535);var f=s.clone();f.color.set(16711935),e.clone().color.set(16776960);var d=t.clone();d.color.set(16711680);var u=t.clone();u.color.set(65280);var p=t.clone();p.color.set(255);var h=t.clone();h.color.set(65535);var v=t.clone();v.color.set(16711935);var m=t.clone();m.color.set(16776960);var x=t.clone();x.color.set(7895160);var g=m.clone();g.opacity=.25;var y=new THREE.CylinderBufferGeometry(0,.05,.2,12,1,!1),E=new THREE.BoxBufferGeometry(.125,.125,.125),w=new THREE.BufferGeometry;w.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,0,0],3));var b,T=function(e,t){for(var r=new THREE.BufferGeometry,n=[],a=0;a<=64*t;++a)n.push(0,Math.cos(a/32*Math.PI)*e,Math.sin(a/32*Math.PI)*e);return r.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),r},_={X:[[new THREE.Mesh(y,a),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new THREE.Mesh(y,a),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new THREE.Line(w,d)]],Y:[[new THREE.Mesh(y,o),[0,1,0],null,null,"fwd"],[new THREE.Mesh(y,o),[0,1,0],[Math.PI,0,0],null,"bwd"],[new THREE.Line(w,u),null,[0,0,Math.PI/2]]],Z:[[new THREE.Mesh(y,i),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new THREE.Mesh(y,i),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new THREE.Line(w,p),null,[0,-Math.PI/2,0]]],XYZ:[[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.1,0),s.clone()),[0,0,0],[0,0,0]]],XY:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.295,.295),l.clone()),[.15,.15,0]],[new THREE.Line(w,m),[.18,.3,0],null,[.125,1,1]],[new THREE.Line(w,m),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.295,.295),c.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new THREE.Line(w,h),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new THREE.Line(w,h),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.295,.295),f.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new THREE.Line(w,v),[.18,0,.3],null,[.125,1,1]],[new THREE.Line(w,v),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},S={X:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,1,4,1,!1),r),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,1,4,1,!1),r),[0,.6,0]]],Z:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,1,4,1,!1),r),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.2,0),r)]],XY:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,.4),r),[.2,.2,0]]],YZ:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,.4),r),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new THREE.Mesh(new THREE.PlaneBufferGeometry(.4,.4),r),[.2,0,.2],[-Math.PI/2,0,0]]]},R={START:[[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.01,2),n),null,null,null,"helper"]],END:[[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.01,2),n),null,null,null,"helper"]],DELTA:[[new THREE.Line((b=new THREE.BufferGeometry,b.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,1,1],3)),b),n),null,null,null,"helper"]],X:[[new THREE.Line(w,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new THREE.Line(w,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new THREE.Line(w,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},A={X:[[new THREE.Line(T(1,.5),d)],[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.04,0),a),[0,0,.99],null,[1,3,1]]],Y:[[new THREE.Line(T(1,.5),u),null,[0,0,-Math.PI/2]],[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.04,0),o),[0,0,.99],null,[3,1,1]]],Z:[[new THREE.Line(T(1,.5),p),null,[0,Math.PI/2,0]],[new THREE.Mesh(new THREE.OctahedronBufferGeometry(.04,0),i),[.99,0,0],null,[1,3,1]]],E:[[new THREE.Line(T(1.25,1),g),null,[0,Math.PI/2,0]],[new THREE.Mesh(new THREE.CylinderBufferGeometry(.03,0,.15,4,1,!1),g),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderBufferGeometry(.03,0,.15,4,1,!1),g),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderBufferGeometry(.03,0,.15,4,1,!1),g),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderBufferGeometry(.03,0,.15,4,1,!1),g),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new THREE.Line(T(1,1),x),null,[0,Math.PI/2,0]]]},M={AXIS:[[new THREE.Line(w,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},C={X:[[new THREE.Mesh(new THREE.TorusBufferGeometry(1,.1,4,24),r),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.TorusBufferGeometry(1,.1,4,24),r),[0,0,0],[Math.PI/2,0,0]]],Z:[[new THREE.Mesh(new THREE.TorusBufferGeometry(1,.1,4,24),r),[0,0,0],[0,0,-Math.PI/2]]],E:[[new THREE.Mesh(new THREE.TorusBufferGeometry(1.25,.1,2,24),r)]],XYZE:[[new THREE.Mesh(new THREE.SphereBufferGeometry(.7,10,8),r)]]},L={X:[[new THREE.Mesh(E,a),[.8,0,0],[0,0,-Math.PI/2]],[new THREE.Line(w,d),null,null,[.8,1,1]]],Y:[[new THREE.Mesh(E,o),[0,.8,0]],[new THREE.Line(w,u),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new THREE.Mesh(E,i),[0,0,.8],[Math.PI/2,0,0]],[new THREE.Line(w,p),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new THREE.Mesh(E,l),[.85,.85,0],null,[2,2,.2]],[new THREE.Line(w,m),[.855,.98,0],null,[.125,1,1]],[new THREE.Line(w,m),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new THREE.Mesh(E,c),[0,.85,.85],null,[.2,2,2]],[new THREE.Line(w,h),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new THREE.Line(w,h),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new THREE.Mesh(E,f),[.85,0,.85],null,[2,.2,2]],[new THREE.Line(w,v),[.855,0,.98],null,[.125,1,1]],[new THREE.Line(w,v),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.125,.125,.125),s.clone()),[1.1,0,0]]],XYZY:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.125,.125,.125),s.clone()),[0,1.1,0]]],XYZZ:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.125,.125,.125),s.clone()),[0,0,1.1]]]},H={X:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,.8,4,1,!1),r),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,.8,4,1,!1),r),[0,.5,0]]],Z:[[new THREE.Mesh(new THREE.CylinderBufferGeometry(.2,0,.8,4,1,!1),r),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new THREE.Mesh(E,r),[.85,.85,0],null,[3,3,.2]]],YZ:[[new THREE.Mesh(E,r),[0,.85,.85],null,[.2,3,3]]],XZ:[[new THREE.Mesh(E,r),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.2,.2,.2),r),[1.1,0,0]]],XYZY:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.2,.2,.2),r),[0,1.1,0]]],XYZZ:[[new THREE.Mesh(new THREE.BoxBufferGeometry(.2,.2,.2),r),[0,0,1.1]]]},P={X:[[new THREE.Line(w,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new THREE.Line(w,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new THREE.Line(w,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},z=function(e){var t=new THREE.Object3D;for(var r in e)for(var n=e[r].length;n--;){var a=e[r][n][0].clone(),o=e[r][n][1],i=e[r][n][2],s=e[r][n][3],l=e[r][n][4];a.name=r,a.tag=l,o&&a.position.set(o[0],o[1],o[2]),i&&a.rotation.set(i[0],i[1],i[2]),s&&a.scale.set(s[0],s[1],s[2]),a.updateMatrix();var c=a.geometry.clone();c.applyMatrix4(a.matrix),a.geometry=c,a.renderOrder=1/0,a.position.set(0,0,0),a.rotation.set(0,0,0),a.scale.set(1,1,1),t.add(a)}return t},k=new THREE.Vector3(0,0,0),N=new THREE.Euler,D=new THREE.Vector3(0,1,0),F=new THREE.Vector3(0,0,0),I=new THREE.Matrix4,O=new THREE.Quaternion,U=new THREE.Quaternion,G=new THREE.Quaternion,B=new THREE.Vector3(1,0,0),V=new THREE.Vector3(0,1,0),j=new THREE.Vector3(0,0,1);this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=z(_)),this.add(this.gizmo.rotate=z(A)),this.add(this.gizmo.scale=z(L)),this.add(this.picker.translate=z(S)),this.add(this.picker.rotate=z(C)),this.add(this.picker.scale=z(H)),this.add(this.helper.translate=z(R)),this.add(this.helper.rotate=z(M)),this.add(this.helper.scale=z(P)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1,this.updateMatrixWorld=function(){var e=this.space;"scale"===this.mode&&(e="local");var t="local"===e?this.worldQuaternion:G;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;var r=[];r=(r=(r=r.concat(this.picker[this.mode].children)).concat(this.gizmo[this.mode].children)).concat(this.helper[this.mode].children);for(var n=0;n<r.length;n++){var a,o=r[n];if(o.visible=!0,o.rotation.set(0,0,0),o.position.copy(this.worldPosition),a=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),o.scale.set(1,1,1).multiplyScalar(a*this.size/7),"helper"!==o.tag){if(o.quaternion.copy(t),"translate"===this.mode||"scale"===this.mode){"X"!==o.name&&"XYZX"!==o.name||Math.abs(D.copy(B).applyQuaternion(t).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),"Y"!==o.name&&"XYZY"!==o.name||Math.abs(D.copy(V).applyQuaternion(t).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),"Z"!==o.name&&"XYZZ"!==o.name||Math.abs(D.copy(j).applyQuaternion(t).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),"XY"===o.name&&Math.abs(D.copy(j).applyQuaternion(t).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),"YZ"===o.name&&Math.abs(D.copy(B).applyQuaternion(t).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),"XZ"===o.name&&Math.abs(D.copy(V).applyQuaternion(t).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),-1!==o.name.search("X")&&(D.copy(B).applyQuaternion(t).dot(this.eye)<0?"fwd"===o.tag?o.visible=!1:o.scale.x*=-1:"bwd"===o.tag&&(o.visible=!1)),-1!==o.name.search("Y")&&(D.copy(V).applyQuaternion(t).dot(this.eye)<0?"fwd"===o.tag?o.visible=!1:o.scale.y*=-1:"bwd"===o.tag&&(o.visible=!1)),-1!==o.name.search("Z")&&(D.copy(j).applyQuaternion(t).dot(this.eye)<0?"fwd"===o.tag?o.visible=!1:o.scale.z*=-1:"bwd"===o.tag&&(o.visible=!1))}else"rotate"===this.mode&&(U.copy(t),D.copy(this.eye).applyQuaternion(O.copy(t).inverse()),-1!==o.name.search("E")&&o.quaternion.setFromRotationMatrix(I.lookAt(this.eye,F,V)),"X"===o.name&&(O.setFromAxisAngle(B,Math.atan2(-D.y,D.z)),O.multiplyQuaternions(U,O),o.quaternion.copy(O)),"Y"===o.name&&(O.setFromAxisAngle(V,Math.atan2(D.x,D.z)),O.multiplyQuaternions(U,O),o.quaternion.copy(O)),"Z"===o.name&&(O.setFromAxisAngle(j,Math.atan2(D.y,D.x)),O.multiplyQuaternions(U,O),o.quaternion.copy(O)));o.visible=o.visible&&(-1===o.name.indexOf("X")||this.showX),o.visible=o.visible&&(-1===o.name.indexOf("Y")||this.showY),o.visible=o.visible&&(-1===o.name.indexOf("Z")||this.showZ),o.visible=o.visible&&(-1===o.name.indexOf("E")||this.showX&&this.showY&&this.showZ),o.material._opacity=o.material._opacity||o.material.opacity,o.material._color=o.material._color||o.material.color.clone(),o.material.color.copy(o.material._color),o.material.opacity=o.material._opacity,this.enabled?this.axis&&(o.name===this.axis||this.axis.split("").some((function(e){return o.name===e}))?(o.material.opacity=1,o.material.color.lerp(new THREE.Color(1,1,1),.5)):(o.material.opacity*=.25,o.material.color.lerp(new THREE.Color(1,1,1),.5))):(o.material.opacity*=.5,o.material.color.lerp(new THREE.Color(1,1,1),.5))}else o.visible=!1,"AXIS"===o.name?(o.position.copy(this.worldPositionStart),o.visible=!!this.axis,"X"===this.axis&&(O.setFromEuler(N.set(0,0,0)),o.quaternion.copy(t).multiply(O),Math.abs(D.copy(B).applyQuaternion(t).dot(this.eye))>.9&&(o.visible=!1)),"Y"===this.axis&&(O.setFromEuler(N.set(0,0,Math.PI/2)),o.quaternion.copy(t).multiply(O),Math.abs(D.copy(V).applyQuaternion(t).dot(this.eye))>.9&&(o.visible=!1)),"Z"===this.axis&&(O.setFromEuler(N.set(0,Math.PI/2,0)),o.quaternion.copy(t).multiply(O),Math.abs(D.copy(j).applyQuaternion(t).dot(this.eye))>.9&&(o.visible=!1)),"XYZE"===this.axis&&(O.setFromEuler(N.set(0,Math.PI/2,0)),D.copy(this.rotationAxis),o.quaternion.setFromRotationMatrix(I.lookAt(F,D,V)),o.quaternion.multiply(O),o.visible=this.dragging),"E"===this.axis&&(o.visible=!1)):"START"===o.name?(o.position.copy(this.worldPositionStart),o.visible=this.dragging):"END"===o.name?(o.position.copy(this.worldPosition),o.visible=this.dragging):"DELTA"===o.name?(o.position.copy(this.worldPositionStart),o.quaternion.copy(this.worldQuaternionStart),k.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),k.applyQuaternion(this.worldQuaternionStart.clone().inverse()),o.scale.copy(k),o.visible=this.dragging):(o.quaternion.copy(t),this.dragging?o.position.copy(this.worldPositionStart):o.position.copy(this.worldPosition),this.axis&&(o.visible=-1!==this.axis.search(o.name)))}THREE.Object3D.prototype.updateMatrixWorld.call(this)}},THREE.TransformControlsGizmo.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.TransformControlsGizmo,isTransformControlsGizmo:!0}),THREE.TransformControlsPlane=function(){"use strict";THREE.Mesh.call(this,new THREE.PlaneBufferGeometry(1e5,1e5,2,2),new THREE.MeshBasicMaterial({visible:!1,wireframe:!0,side:THREE.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane";var e=new THREE.Vector3(1,0,0),t=new THREE.Vector3(0,1,0),r=new THREE.Vector3(0,0,1),n=new THREE.Vector3,a=new THREE.Vector3,o=new THREE.Vector3,i=new THREE.Matrix4,s=new THREE.Quaternion;this.updateMatrixWorld=function(){var l=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(l="local"),e.set(1,0,0).applyQuaternion("local"===l?this.worldQuaternion:s),t.set(0,1,0).applyQuaternion("local"===l?this.worldQuaternion:s),r.set(0,0,1).applyQuaternion("local"===l?this.worldQuaternion:s),o.copy(t),this.mode){case"translate":case"scale":switch(this.axis){case"X":o.copy(this.eye).cross(e),a.copy(e).cross(o);break;case"Y":o.copy(this.eye).cross(t),a.copy(t).cross(o);break;case"Z":o.copy(this.eye).cross(r),a.copy(r).cross(o);break;case"XY":a.copy(r);break;case"YZ":a.copy(e);break;case"XZ":o.copy(r),a.copy(t);break;case"XYZ":case"E":a.set(0,0,0)}break;case"rotate":default:a.set(0,0,0)}0===a.length()?this.quaternion.copy(this.cameraQuaternion):(i.lookAt(n.set(0,0,0),a,o),this.quaternion.setFromRotationMatrix(i)),THREE.Object3D.prototype.updateMatrixWorld.call(this)}},THREE.TransformControlsPlane.prototype=Object.assign(Object.create(THREE.Mesh.prototype),{constructor:THREE.TransformControlsPlane,isTransformControlsPlane:!0})},function(e,t){THREE.GPUComputationRenderer=function(e,t,r){this.variables=[],this.currentTextureIndex=0;var n=THREE.FloatType,a=new THREE.Scene,o=new THREE.Camera;o.position.z=1;var i={passThruTexture:{value:null}},s=f("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n",i),l=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),s);function c(r){r.defines.resolution="vec2( "+e.toFixed(1)+", "+t.toFixed(1)+" )"}function f(e,t){t=t||{};var r=new THREE.ShaderMaterial({uniforms:t,vertexShader:"void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:e});return c(r),r}a.add(l),this.setDataType=function(e){return n=e,this},this.addVariable=function(e,t,r){var n={name:e,initialValueTexture:r,material:this.createShaderMaterial(t),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};return this.variables.push(n),n},this.setVariableDependencies=function(e,t){e.dependencies=t},this.init=function(){if(!r.capabilities.isWebGL2&&!r.extensions.get("OES_texture_float"))return"No OES_texture_float support for float textures.";if(0===r.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(var n=0;n<this.variables.length;n++){var a=this.variables[n];a.renderTargets[0]=this.createRenderTarget(e,t,a.wrapS,a.wrapT,a.minFilter,a.magFilter),a.renderTargets[1]=this.createRenderTarget(e,t,a.wrapS,a.wrapT,a.minFilter,a.magFilter),this.renderTexture(a.initialValueTexture,a.renderTargets[0]),this.renderTexture(a.initialValueTexture,a.renderTargets[1]);var o=a.material,i=o.uniforms;if(null!==a.dependencies)for(var s=0;s<a.dependencies.length;s++){var l=a.dependencies[s];if(l.name!==a.name){for(var c=!1,f=0;f<this.variables.length;f++)if(l.name===this.variables[f].name){c=!0;break}if(!c)return"Variable dependency not found. Variable="+a.name+", dependency="+l.name}i[l.name]={value:null},o.fragmentShader="\nuniform sampler2D "+l.name+";\n"+o.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){for(var e=this.currentTextureIndex,t=0===this.currentTextureIndex?1:0,r=0,n=this.variables.length;r<n;r++){var a=this.variables[r];if(null!==a.dependencies)for(var o=a.material.uniforms,i=0,s=a.dependencies.length;i<s;i++){var l=a.dependencies[i];o[l.name].value=l.renderTargets[e].texture}this.doRenderTarget(a.material,a.renderTargets[t])}this.currentTextureIndex=t},this.getCurrentRenderTarget=function(e){return e.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(e){return e.renderTargets[0===this.currentTextureIndex?1:0]},this.addResolutionDefine=c,this.createShaderMaterial=f,this.createRenderTarget=function(r,a,o,i,s,l){return r=r||e,a=a||t,o=o||THREE.ClampToEdgeWrapping,i=i||THREE.ClampToEdgeWrapping,s=s||THREE.NearestFilter,l=l||THREE.NearestFilter,new THREE.WebGLRenderTarget(r,a,{wrapS:o,wrapT:i,minFilter:s,magFilter:l,format:THREE.RGBAFormat,type:n,stencilBuffer:!1,depthBuffer:!1})},this.createTexture=function(){var r=new Float32Array(e*t*4);return new THREE.DataTexture(r,e,t,THREE.RGBAFormat,THREE.FloatType)},this.renderTexture=function(e,t){i.passThruTexture.value=e,this.doRenderTarget(s,t),i.passThruTexture.value=null},this.doRenderTarget=function(e,t){var n=r.getRenderTarget();l.material=e,r.setRenderTarget(t),r.render(a,o),l.material=s,r.setRenderTarget(n)}}},function(e,t){THREE.ImprovedNoise=function(){for(var e=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],t=0;t<256;t++)e[256+t]=e[t];function r(e){return e*e*e*(e*(6*e-15)+10)}function n(e,t,r){return t+e*(r-t)}function a(e,t,r,n){var a=15&e,o=a<8?t:r,i=a<4?r:12==a||14==a?t:n;return(0==(1&a)?o:-o)+(0==(2&a)?i:-i)}return{noise:function(t,o,i){var s=Math.floor(t),l=Math.floor(o),c=Math.floor(i),f=255&s,d=255&l,u=255&c,p=(t-=s)-1,h=(o-=l)-1,v=(i-=c)-1,m=r(t),x=r(o),g=r(i),y=e[f]+d,E=e[y]+u,w=e[y+1]+u,b=e[f+1]+d,T=e[b]+u,_=e[b+1]+u;return n(g,n(x,n(m,a(e[E],t,o,i),a(e[T],p,o,i)),n(m,a(e[w],t,h,i),a(e[_],p,h,i))),n(x,n(m,a(e[E+1],t,o,v),a(e[T+1],p,o,i-1)),n(m,a(e[w+1],t,h,v),a(e[_+1],p,h,v))))}}}},function(e,t){THREE.SimplexNoise=function(e){null==e&&(e=Math),this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(var t=0;t<256;t++)this.p[t]=Math.floor(256*e.random());this.perm=[];for(t=0;t<512;t++)this.perm[t]=this.p[255&t];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]},THREE.SimplexNoise.prototype.dot=function(e,t,r){return e[0]*t+e[1]*r},THREE.SimplexNoise.prototype.dot3=function(e,t,r,n){return e[0]*t+e[1]*r+e[2]*n},THREE.SimplexNoise.prototype.dot4=function(e,t,r,n,a){return e[0]*t+e[1]*r+e[2]*n+e[3]*a},THREE.SimplexNoise.prototype.noise=function(e,t){var r,n,a=(e+t)*(.5*(Math.sqrt(3)-1)),o=Math.floor(e+a),i=Math.floor(t+a),s=(3-Math.sqrt(3))/6,l=(o+i)*s,c=e-(o-l),f=t-(i-l);c>f?(r=1,n=0):(r=0,n=1);var d=c-r+s,u=f-n+s,p=c-1+2*s,h=f-1+2*s,v=255&o,m=255&i,x=this.perm[v+this.perm[m]]%12,g=this.perm[v+r+this.perm[m+n]]%12,y=this.perm[v+1+this.perm[m+1]]%12,E=.5-c*c-f*f,w=.5-d*d-u*u,b=.5-p*p-h*h;return 70*((E<0?0:(E*=E)*E*this.dot(this.grad3[x],c,f))+(w<0?0:(w*=w)*w*this.dot(this.grad3[g],d,u))+(b<0?0:(b*=b)*b*this.dot(this.grad3[y],p,h)))},THREE.SimplexNoise.prototype.noise3d=function(e,t,r){var n,a,o,i,s,l,c=(e+t+r)*(1/3),f=Math.floor(e+c),d=Math.floor(t+c),u=Math.floor(r+c),p=1/6,h=(f+d+u)*p,v=e-(f-h),m=t-(d-h),x=r-(u-h);v>=m?m>=x?(n=1,a=0,o=0,i=1,s=1,l=0):v>=x?(n=1,a=0,o=0,i=1,s=0,l=1):(n=0,a=0,o=1,i=1,s=0,l=1):m<x?(n=0,a=0,o=1,i=0,s=1,l=1):v<x?(n=0,a=1,o=0,i=0,s=1,l=1):(n=0,a=1,o=0,i=1,s=1,l=0);var g=v-n+p,y=m-a+p,E=x-o+p,w=v-i+2*p,b=m-s+2*p,T=x-l+2*p,_=v-1+.5,S=m-1+.5,R=x-1+.5,A=255&f,M=255&d,C=255&u,L=this.perm[A+this.perm[M+this.perm[C]]]%12,H=this.perm[A+n+this.perm[M+a+this.perm[C+o]]]%12,P=this.perm[A+i+this.perm[M+s+this.perm[C+l]]]%12,z=this.perm[A+1+this.perm[M+1+this.perm[C+1]]]%12,k=.6-v*v-m*m-x*x,N=.6-g*g-y*y-E*E,D=.6-w*w-b*b-T*T,F=.6-_*_-S*S-R*R;return 32*((k<0?0:(k*=k)*k*this.dot3(this.grad3[L],v,m,x))+(N<0?0:(N*=N)*N*this.dot3(this.grad3[H],g,y,E))+(D<0?0:(D*=D)*D*this.dot3(this.grad3[P],w,b,T))+(F<0?0:(F*=F)*F*this.dot3(this.grad3[z],_,S,R)))},THREE.SimplexNoise.prototype.noise4d=function(e,t,r,n){var a,o,i,s,l,c,f,d,u,p,h,v,m=this.grad4,x=this.simplex,g=this.perm,y=(Math.sqrt(5)-1)/4,E=(5-Math.sqrt(5))/20,w=(e+t+r+n)*y,b=Math.floor(e+w),T=Math.floor(t+w),_=Math.floor(r+w),S=Math.floor(n+w),R=(b+T+_+S)*E,A=e-(b-R),M=t-(T-R),C=r-(_-R),L=n-(S-R),H=(A>M?32:0)+(A>C?16:0)+(M>C?8:0)+(A>L?4:0)+(M>L?2:0)+(C>L?1:0),P=A-(a=x[H][0]>=3?1:0)+E,z=M-(o=x[H][1]>=3?1:0)+E,k=C-(i=x[H][2]>=3?1:0)+E,N=L-(s=x[H][3]>=3?1:0)+E,D=A-(l=x[H][0]>=2?1:0)+2*E,F=M-(c=x[H][1]>=2?1:0)+2*E,I=C-(f=x[H][2]>=2?1:0)+2*E,O=L-(d=x[H][3]>=2?1:0)+2*E,U=A-(u=x[H][0]>=1?1:0)+3*E,G=M-(p=x[H][1]>=1?1:0)+3*E,B=C-(h=x[H][2]>=1?1:0)+3*E,V=L-(v=x[H][3]>=1?1:0)+3*E,j=A-1+4*E,W=M-1+4*E,q=C-1+4*E,X=L-1+4*E,Y=255&b,Z=255&T,Q=255&_,K=255&S,J=g[Y+g[Z+g[Q+g[K]]]]%32,$=g[Y+a+g[Z+o+g[Q+i+g[K+s]]]]%32,ee=g[Y+l+g[Z+c+g[Q+f+g[K+d]]]]%32,te=g[Y+u+g[Z+p+g[Q+h+g[K+v]]]]%32,re=g[Y+1+g[Z+1+g[Q+1+g[K+1]]]]%32,ne=.6-A*A-M*M-C*C-L*L,ae=.6-P*P-z*z-k*k-N*N,oe=.6-D*D-F*F-I*I-O*O,ie=.6-U*U-G*G-B*B-V*V,se=.6-j*j-W*W-q*q-X*X;return 27*((ne<0?0:(ne*=ne)*ne*this.dot4(m[J],A,M,C,L))+(ae<0?0:(ae*=ae)*ae*this.dot4(m[$],P,z,k,N))+(oe<0?0:(oe*=oe)*oe*this.dot4(m[ee],D,F,I,O))+(ie<0?0:(ie*=ie)*ie*this.dot4(m[te],U,G,B,V))+(se<0?0:(se*=se)*se*this.dot4(m[re],j,W,q,X)))}},function(e,t){THREE.Lut=function(e,t){return this.lut=[],this.setColorMap(e,t),this},THREE.Lut.prototype={constructor:THREE.Lut,lut:[],map:[],n:256,minV:0,maxV:1,set:function(e){return e instanceof THREE.Lut&&this.copy(e),this},setMin:function(e){return this.minV=e,this},setMax:function(e){return this.maxV=e,this},setColorMap:function(e,t){this.map=THREE.ColorMapKeywords[e]||THREE.ColorMapKeywords.rainbow,this.n=t||32;var r=1/this.n;this.lut.length=0;for(var n=0;n<=1;n+=r)for(var a=0;a<this.map.length-1;a++)if(n>=this.map[a][0]&&n<this.map[a+1][0]){var o=this.map[a][0],i=this.map[a+1][0],s=new THREE.Color(this.map[a][1]),l=new THREE.Color(this.map[a+1][1]),c=s.lerp(l,(n-o)/(i-o));this.lut.push(c)}return this},copy:function(e){return this.lut=e.lut,this.map=e.map,this.n=e.n,this.minV=e.minV,this.maxV=e.maxV,this},getColor:function(e){e<=this.minV?e=this.minV:e>=this.maxV&&(e=this.maxV),e=(e-this.minV)/(this.maxV-this.minV);var t=Math.round(e*this.n);return t==this.n&&(t-=1),this.lut[t]},addColorMap:function(e,t){THREE.ColorMapKeywords[e]=t},createCanvas:function(){var e=document.createElement("canvas");return e.width=1,e.height=this.n,this.updateCanvas(e),e},updateCanvas:function(e){for(var t=e.getContext("2d",{alpha:!1}),r=t.getImageData(0,0,1,this.n),n=r.data,a=0,o=1/this.n,i=1;i>=0;i-=o)for(var s=this.map.length-1;s>=0;s--)if(i<this.map[s][0]&&i>=this.map[s-1][0]){var l=this.map[s-1][0],c=this.map[s][0],f=new THREE.Color(this.map[s-1][1]),d=new THREE.Color(this.map[s][1]),u=f.lerp(d,(i-l)/(c-l));n[4*a]=Math.round(255*u.r),n[4*a+1]=Math.round(255*u.g),n[4*a+2]=Math.round(255*u.b),n[4*a+3]=255,a+=1}return t.putImageData(r,0,0),e}},THREE.ColorMapKeywords={rainbow:[[0,255],[.2,65535],[.5,65280],[.8,16776960],[1,16711680]],cooltowarm:[[0,3952322],[.2,10206463],[.5,14474460],[.8,16163717],[1,11797542]],blackbody:[[0,0],[.2,7864320],[.5,15086080],[.8,16776960],[1,16777215]],grayscale:[[0,0],[.2,4210752],[.5,8355712],[.8,12566463],[1,16777215]]}},function(e,t){THREE.SimplifyModifier=function(){},function(){var e=new THREE.Vector3,t=new THREE.Vector3;function r(e,t){var r=e.indexOf(t);r>-1&&e.splice(r,1)}function n(e,t){var r,n,a,o=t.position.distanceTo(e.position),i=0,s=[],l=e.faces.length;for(r=0;r<l;r++)(n=e.faces[r]).hasVertex(t)&&s.push(n);for(r=0;r<l;r++){var c=1;n=e.faces[r];for(var f=0;f<s.length;f++){a=s[f];var d=n.normal.dot(a.normal);c=Math.min(c,(1.001-d)/2)}i=Math.max(i,c)}return s.length<2&&(i=1),o*i+0}function a(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(var t=0;t<e.neighbors.length;t++){var r=n(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=r,e.minCost=r,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=r,r<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=r)}e.collapseCost=e.totalCost/e.costCount}function o(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;){r(e.neighbors.pop().neighbors,e)}r(t,e)}function i(e,t){r(t,e),e.v1&&r(e.v1.faces,e),e.v2&&r(e.v2.faces,e),e.v3&&r(e.v3.faces,e);for(var n,a,o=[e.v1,e.v2,e.v3],i=0;i<3;i++)a=o[(i+1)%3],(n=o[i])&&a&&(n.removeIfNonNeighbor(a),a.removeIfNonNeighbor(n))}function s(e,t,r,n){if(n){var s,l=[];for(s=0;s<r.neighbors.length;s++)l.push(r.neighbors[s]);for(s=r.faces.length-1;s>=0;s--)r.faces[s].hasVertex(n)&&i(r.faces[s],t);for(s=r.faces.length-1;s>=0;s--)r.faces[s].replaceVertex(r,n);for(o(r,e),s=0;s<l.length;s++)a(l[s])}else o(r,e)}function l(e){for(var t=e[0],r=0;r<e.length;r++)e[r].collapseCost<t.collapseCost&&(t=e[r]);return t}function c(e,t,r,n,a,o){this.a=n,this.b=a,this.c=o,this.v1=e,this.v2=t,this.v3=r,this.normal=new THREE.Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(r),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(r),r.faces.push(this),r.addUniqueNeighbor(e),r.addUniqueNeighbor(t)}function f(e,t){this.position=e,this.id=t,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}c.prototype.computeNormal=function(){var r=this.v1.position,n=this.v2.position,a=this.v3.position;e.subVectors(a,n),t.subVectors(r,n),e.cross(t).normalize(),this.normal.copy(e)},c.prototype.hasVertex=function(e){return e===this.v1||e===this.v2||e===this.v3},c.prototype.replaceVertex=function(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),r(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()},f.prototype.addUniqueNeighbor=function(e){var t,r;t=this.neighbors,r=e,-1===t.indexOf(r)&&t.push(r)},f.prototype.removeIfNonNeighbor=function(e){var t=this.neighbors,r=this.faces,n=t.indexOf(e);if(-1!==n){for(var a=0;a<r.length;a++)if(r[a].hasVertex(e))return;t.splice(n,1)}},THREE.SimplifyModifier.prototype.modify=function(e,t){e.isBufferGeometry&&(e=(new THREE.Geometry).fromBufferGeometry(e)),e.mergeVertices();var r,n,o,i=e.vertices,d=e.faces,u=[],p=[];for(r=0,n=i.length;r<n;r++){var h=new f(i[r],r);u.push(h)}for(r=0,n=d.length;r<n;r++){var v=(T=d[r]).a,m=T.b,x=T.c,g=new c(u[v],u[m],u[x],v,m,x);p.push(g)}for(r=0,n=u.length;r<n;r++)a(u[r]);for(var y=t;y--;){if(!(o=l(u))){console.log("THREE.SimplifyModifier: No next vertex");break}s(u,p,o,o.collapseNeighbor)}var E=new THREE.BufferGeometry,w=[],b=[];for(r=0;r<u.length;r++){h=u[r].position;w.push(h.x,h.y,h.z)}for(r=0;r<p.length;r++){var T=p[r];v=u.indexOf(T.v1),m=u.indexOf(T.v2),x=u.indexOf(T.v3);b.push(v,m,x)}return E.setAttribute("position",new THREE.Float32BufferAttribute(w,3)),E.setIndex(b),E}}()},function(e,t){THREE.SubdivisionModifier=function(e){this.subdivisions=void 0===e?1:e},THREE.SubdivisionModifier.prototype.modify=function(e){(e=e.isBufferGeometry?(new THREE.Geometry).fromBufferGeometry(e):e.clone()).mergeVertices();for(var t=this.subdivisions;t-- >0;)this.smooth(e);return e.computeFaceNormals(),e.computeVertexNormals(),e},function(){var e=["a","b","c"];function t(e,t,r){return r[Math.min(e,t)+"_"+Math.max(e,t)]}function r(e,t,r,n,a,o){var i,s=Math.min(e,t),l=Math.max(e,t),c=s+"_"+l;c in n?i=n[c]:(i={a:r[s],b:r[l],newEdge:null,faces:[]},n[c]=i);i.faces.push(a),o[e].edges.push(i),o[t].edges.push(i)}function n(e,t,r,n,a){e.push(new THREE.Face3(t,r,n,void 0,void 0,a))}function a(e,t){return Math.abs(t-e)/2+Math.min(e,t)}function o(e,t,r,n){e.push([t.clone(),r.clone(),n.clone()])}THREE.SubdivisionModifier.prototype.smooth=function(i){var s,l,c,f,d,u,p,h,v,m,x,g,y,E=new THREE.Vector3,w=[];s=i.vertices,l=i.faces;var b,T,_,S,R,A,M,C,L,H,P,z,k,N,D=void 0!==(c=i.faceVertexUvs)[0]&&c[0].length>0;if(D)for(var F=0;F<c.length;F++)w.push([]);for(p in function(e,t,n,a){var o,i,s;for(o=0,i=e.length;o<i;o++)n[o]={edges:[]};for(o=0,i=t.length;o<i;o++)r((s=t[o]).a,s.b,e,a,s,n),r(s.b,s.c,e,a,s,n),r(s.c,s.a,e,a,s,n)}(s,l,m=new Array(s.length),x={}),g=[],x){for(T=x[p],_=new THREE.Vector3,R=3/8,A=1/8,2!=(M=T.faces.length)&&(R=.5,A=0),_.addVectors(T.a,T.b).multiplyScalar(R),E.set(0,0,0),F=0;F<M;F++){for(S=T.faces[F],v=0;v<3&&((b=s[S[e[v]]])===T.a||b===T.b);v++);E.add(b)}E.multiplyScalar(A),_.add(E),T.newEdge=g.length,g.push(_)}for(y=[],p=0,h=s.length;p<h;p++){for(k=s[p],3==(u=(z=m[p].edges).length)?C=3/16:u>3&&(C=3/(8*u)),L=1-u*C,H=C,u<=2&&2==u&&(L=3/4,H=1/8),N=k.clone().multiplyScalar(L),E.set(0,0,0),F=0;F<u;F++)b=(P=z[F]).a!==k?P.a:P.b,E.add(b);E.multiplyScalar(H),N.add(E),y.push(N)}f=y.concat(g);var I,O,U,G,B,V,j,W=y.length;d=[];var q=new THREE.Vector2,X=new THREE.Vector2,Y=new THREE.Vector2;for(p=0,h=l.length;p<h;p++)if(n(d,I=t((S=l[p]).a,S.b,x).newEdge+W,O=t(S.b,S.c,x).newEdge+W,U=t(S.c,S.a,x).newEdge+W,S.materialIndex),n(d,S.a,I,U,S.materialIndex),n(d,S.b,O,I,S.materialIndex),n(d,S.c,U,O,S.materialIndex),D)for(F=0;F<c.length;F++)B=(G=c[F][p])[0],V=G[1],j=G[2],q.set(a(B.x,V.x),a(B.y,V.y)),X.set(a(V.x,j.x),a(V.y,j.y)),Y.set(a(B.x,j.x),a(B.y,j.y)),o(w[F],q,X,Y),o(w[F],B,q,Y),o(w[F],V,X,q),o(w[F],j,Y,X);i.vertices=f,i.faces=d,D&&(i.faceVertexUvs=w)}}()},function(e,t){THREE.ConvexHull=function(){var e,t,r,n,a=new THREE.Vector3;function o(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new c,this.unassigned=new c,this.vertices=[]}function i(){this.normal=new THREE.Vector3,this.midpoint=new THREE.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}function s(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}function l(e){this.point=e,this.prev=null,this.next=null,this.face=null}function c(){this.head=null,this.tail=null}return Object.assign(o.prototype,{setFromPoints:function(e){!0!==Array.isArray(e)&&console.error("THREE.ConvexHull: Points parameter is not an array."),e.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(var t=0,r=e.length;t<r;t++)this.vertices.push(new l(e[t]));return this.compute(),this},setFromObject:function(e){var t=[];return e.updateMatrixWorld(!0),e.traverse((function(e){var r,n,a,o=e.geometry;if(void 0!==o)if(o.isGeometry){var i=o.vertices;for(r=0,n=i.length;r<n;r++)(a=i[r].clone()).applyMatrix4(e.matrixWorld),t.push(a)}else if(o.isBufferGeometry){var s=o.attributes.position;if(void 0!==s)for(r=0,n=s.count;r<n;r++)(a=new THREE.Vector3).fromBufferAttribute(s,r).applyMatrix4(e.matrixWorld),t.push(a)}})),this.setFromPoints(t)},containsPoint:function(e){for(var t=this.faces,r=0,n=t.length;r<n;r++){if(t[r].distanceToPoint(e)>this.tolerance)return!1}return!0},intersectRay:function(e,t){for(var r=this.faces,n=-1/0,a=1/0,o=0,i=r.length;o<i;o++){var s=r[o],l=s.distanceToPoint(e.origin),c=s.normal.dot(e.direction);if(l>0&&c>=0)return null;var f=0!==c?-l/c:0;if(!(f<=0)&&(c>0?a=Math.min(f,a):n=Math.max(f,n),n>a))return null}return n!==-1/0?e.at(n,t):e.at(a,t),t},intersectsRay:function(e){return null!==this.intersectRay(e,a)},makeEmpty:function(){return this.faces=[],this.vertices=[],this},addVertexToFace:function(e,t){return e.face=t,null===t.outside?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this},removeVertexFromFace:function(e,t){return e===t.outside&&(null!==e.next&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this},removeAllVerticesFromFace:function(e){if(null!==e.outside){for(var t=e.outside,r=e.outside;null!==r.next&&r.next.face===e;)r=r.next;return this.assigned.removeSubList(t,r),t.prev=r.next=null,e.outside=null,t}},deleteFaceVertices:function(e,t){var r=this.removeAllVerticesFromFace(e);if(void 0!==r)if(void 0===t)this.unassigned.appendChain(r);else{var n=r;do{var a=n.next;t.distanceToPoint(n.point)>this.tolerance?this.addVertexToFace(n,t):this.unassigned.append(n),n=a}while(null!==n)}return this},resolveUnassignedPoints:function(e){if(!1===this.unassigned.isEmpty()){var t=this.unassigned.first();do{for(var r=t.next,n=this.tolerance,a=null,o=0;o<e.length;o++){var i=e[o];if(0===i.mark){var s=i.distanceToPoint(t.point);if(s>n&&(n=s,a=i),n>1e3*this.tolerance)break}}null!==a&&this.addVertexToFace(t,a),t=r}while(null!==t)}return this},computeExtremes:function(){var e,t,r,n=new THREE.Vector3,a=new THREE.Vector3,o=[],i=[];for(e=0;e<3;e++)o[e]=i[e]=this.vertices[0];for(n.copy(this.vertices[0].point),a.copy(this.vertices[0].point),e=0,t=this.vertices.length;e<t;e++){var s=this.vertices[e],l=s.point;for(r=0;r<3;r++)l.getComponent(r)<n.getComponent(r)&&(n.setComponent(r,l.getComponent(r)),o[r]=s);for(r=0;r<3;r++)l.getComponent(r)>a.getComponent(r)&&(a.setComponent(r,l.getComponent(r)),i[r]=s)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(n.x),Math.abs(a.x))+Math.max(Math.abs(n.y),Math.abs(a.y))+Math.max(Math.abs(n.z),Math.abs(a.z))),{min:o,max:i}},computeInitialHull:function(){void 0===e&&(e=new THREE.Line3,t=new THREE.Plane,r=new THREE.Vector3);var n,a,o,s,l,c,f,d,u,p=this.vertices,h=this.computeExtremes(),v=h.min,m=h.max,x=0,g=0;for(c=0;c<3;c++)(u=m[c].point.getComponent(c)-v[c].point.getComponent(c))>x&&(x=u,g=c);for(a=v[g],o=m[g],x=0,e.set(a.point,o.point),c=0,f=this.vertices.length;c<f;c++)(n=p[c])!==a&&n!==o&&(e.closestPointToPoint(n.point,!0,r),(u=r.distanceToSquared(n.point))>x&&(x=u,s=n));for(x=-1,t.setFromCoplanarPoints(a.point,o.point,s.point),c=0,f=this.vertices.length;c<f;c++)(n=p[c])!==a&&n!==o&&n!==s&&(u=Math.abs(t.distanceToPoint(n.point)))>x&&(x=u,l=n);var y=[];if(t.distanceToPoint(l.point)<0)for(y.push(i.create(a,o,s),i.create(l,o,a),i.create(l,s,o),i.create(l,a,s)),c=0;c<3;c++)d=(c+1)%3,y[c+1].getEdge(2).setTwin(y[0].getEdge(d)),y[c+1].getEdge(1).setTwin(y[d+1].getEdge(0));else for(y.push(i.create(a,s,o),i.create(l,a,o),i.create(l,o,s),i.create(l,s,a)),c=0;c<3;c++)d=(c+1)%3,y[c+1].getEdge(2).setTwin(y[0].getEdge((3-c)%3)),y[c+1].getEdge(0).setTwin(y[d+1].getEdge(1));for(c=0;c<4;c++)this.faces.push(y[c]);for(c=0,f=p.length;c<f;c++)if((n=p[c])!==a&&n!==o&&n!==s&&n!==l){x=this.tolerance;var E=null;for(d=0;d<4;d++)(u=this.faces[d].distanceToPoint(n.point))>x&&(x=u,E=this.faces[d]);null!==E&&this.addVertexToFace(n,E)}return this},reindexFaces:function(){for(var e=[],t=0;t<this.faces.length;t++){var r=this.faces[t];0===r.mark&&e.push(r)}return this.faces=e,this},nextVertexToAdd:function(){if(!1===this.assigned.isEmpty()){var e,t=0,r=this.assigned.first().face,n=r.outside;do{var a=r.distanceToPoint(n.point);a>t&&(t=a,e=n),n=n.next}while(null!==n&&n.face===r);return e}},computeHorizon:function(e,t,r,n){var a;this.deleteFaceVertices(r),r.mark=1,a=null===t?t=r.getEdge(0):t.next;do{var o=a.twin,i=o.face;0===i.mark&&(i.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,o,i,n):n.push(a)),a=a.next}while(a!==t);return this},addAdjoiningFace:function(e,t){var r=i.create(e,t.tail(),t.head());return this.faces.push(r),r.getEdge(-1).setTwin(t.twin),r.getEdge(0)},addNewFaces:function(e,t){this.newFaces=[];for(var r=null,n=null,a=0;a<t.length;a++){var o=t[a],i=this.addAdjoiningFace(e,o);null===r?r=i:i.next.setTwin(n),this.newFaces.push(i.face),n=i}return r.next.setTwin(n),this},addVertexToHull:function(e){var t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this},cleanup:function(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this},compute:function(){var e;for(this.computeInitialHull();void 0!==(e=this.nextVertexToAdd());)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}),Object.assign(i,{create:function(e,t,r){var n=new i,a=new s(e,n),o=new s(t,n),l=new s(r,n);return a.next=l.prev=o,o.next=a.prev=l,l.next=o.prev=a,n.edge=a,n.compute()}}),Object.assign(i.prototype,{getEdge:function(e){for(var t=this.edge;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t},compute:function(){void 0===n&&(n=new THREE.Triangle);var e=this.edge.tail(),t=this.edge.head(),r=this.edge.next.head();return n.set(e.point,t.point,r.point),n.getNormal(this.normal),n.getMidpoint(this.midpoint),this.area=n.getArea(),this.constant=this.normal.dot(this.midpoint),this},distanceToPoint:function(e){return this.normal.dot(e)-this.constant}}),Object.assign(s.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var e=this.head(),t=this.tail();return null!==t?t.point.distanceTo(e.point):-1},lengthSquared:function(){var e=this.head(),t=this.tail();return null!==t?t.point.distanceToSquared(e.point):-1},setTwin:function(e){return this.twin=e,e.twin=this,this}}),Object.assign(c.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){return this.head=this.tail=null,this},insertBefore:function(e,t){return t.prev=e.prev,t.next=e,null===t.prev?this.head=t:t.prev.next=t,e.prev=t,this},insertAfter:function(e,t){return t.prev=e,t.next=e.next,null===t.next?this.tail=t:t.next.prev=t,e.next=t,this},append:function(e){return null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this},appendChain:function(e){for(null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail;null!==e.next;)e=e.next;return this.tail=e,this},remove:function(e){return null===e.prev?this.head=e.next:e.prev.next=e.next,null===e.next?this.tail=e.prev:e.next.prev=e.prev,this},removeSubList:function(e,t){return null===e.prev?this.head=t.next:e.prev.next=t.next,null===t.next?this.tail=e.prev:t.next.prev=e.prev,this},isEmpty:function(){return null===this.head}}),o}()},function(e,t){THREE.ConvexGeometry=function(e){THREE.Geometry.call(this),this.fromBufferGeometry(new THREE.ConvexBufferGeometry(e)),this.mergeVertices()},THREE.ConvexGeometry.prototype=Object.create(THREE.Geometry.prototype),THREE.ConvexGeometry.prototype.constructor=THREE.ConvexGeometry,THREE.ConvexBufferGeometry=function(e){THREE.BufferGeometry.call(this);var t=[],r=[];void 0===THREE.ConvexHull&&console.error("THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.ConvexHull");for(var n=(new THREE.ConvexHull).setFromPoints(e).faces,a=0;a<n.length;a++){var o=n[a],i=o.edge;do{var s=i.head().point;t.push(s.x,s.y,s.z),r.push(o.normal.x,o.normal.y,o.normal.z),i=i.next}while(i!==o.edge)}this.setAttribute("position",new THREE.Float32BufferAttribute(t,3)),this.setAttribute("normal",new THREE.Float32BufferAttribute(r,3))},THREE.ConvexBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype),THREE.ConvexBufferGeometry.prototype.constructor=THREE.ConvexBufferGeometry},function(e,t){function r(){}var n,a,o,i;r.Handlers={handlers:[],add:function(e,t){this.handlers.push(e,t)},get:function(e){for(var t=this.handlers,r=0,n=t.length;r<n;r+=2){var a=t[r],o=t[r+1];if(a.test(e))return o}return null}},Object.assign(r.prototype,{crossOrigin:"anonymous",onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(e,t,r){for(var n=[],a=0;a<e.length;++a)n[a]=this.createMaterial(e[a],t,r);return n},createMaterial:(n={NoBlending:THREE.NoBlending,NormalBlending:THREE.NormalBlending,AdditiveBlending:THREE.AdditiveBlending,SubtractiveBlending:THREE.SubtractiveBlending,MultiplyBlending:THREE.MultiplyBlending,CustomBlending:THREE.CustomBlending},a=new THREE.Color,o=new THREE.TextureLoader,i=new THREE.MaterialLoader,function(e,t,s){var l={};function c(e,n,a,i,c){var f,d=t+e,u=r.Handlers.get(d);null!==u?f=u.load(d):(o.setCrossOrigin(s),f=o.load(d)),void 0!==n&&(f.repeat.fromArray(n),1!==n[0]&&(f.wrapS=THREE.RepeatWrapping),1!==n[1]&&(f.wrapT=THREE.RepeatWrapping)),void 0!==a&&f.offset.fromArray(a),void 0!==i&&("repeat"===i[0]&&(f.wrapS=THREE.RepeatWrapping),"mirror"===i[0]&&(f.wrapS=THREE.MirroredRepeatWrapping),"repeat"===i[1]&&(f.wrapT=THREE.RepeatWrapping),"mirror"===i[1]&&(f.wrapT=THREE.MirroredRepeatWrapping)),void 0!==c&&(f.anisotropy=c);var p=THREE.MathUtils.generateUUID();return l[p]=f,p}var f={uuid:THREE.MathUtils.generateUUID(),type:"MeshLambertMaterial"};for(var d in e){var u=e[d];switch(d){case"DbgColor":case"DbgIndex":case"opticalDensity":case"illumination":break;case"DbgName":f.name=u;break;case"blending":f.blending=n[u];break;case"colorAmbient":case"mapAmbient":console.warn("THREE_Loader.createMaterial:",d,"is no longer supported.");break;case"colorDiffuse":f.color=a.fromArray(u).getHex();break;case"colorSpecular":f.specular=a.fromArray(u).getHex();break;case"colorEmissive":f.emissive=a.fromArray(u).getHex();break;case"specularCoef":f.shininess=u;break;case"shading":"basic"===u.toLowerCase()&&(f.type="MeshBasicMaterial"),"phong"===u.toLowerCase()&&(f.type="MeshPhongMaterial"),"standard"===u.toLowerCase()&&(f.type="MeshStandardMaterial");break;case"mapDiffuse":f.map=c(u,e.mapDiffuseRepeat,e.mapDiffuseOffset,e.mapDiffuseWrap,e.mapDiffuseAnisotropy);break;case"mapDiffuseRepeat":case"mapDiffuseOffset":case"mapDiffuseWrap":case"mapDiffuseAnisotropy":break;case"mapEmissive":f.emissiveMap=c(u,e.mapEmissiveRepeat,e.mapEmissiveOffset,e.mapEmissiveWrap,e.mapEmissiveAnisotropy);break;case"mapEmissiveRepeat":case"mapEmissiveOffset":case"mapEmissiveWrap":case"mapEmissiveAnisotropy":break;case"mapLight":f.lightMap=c(u,e.mapLightRepeat,e.mapLightOffset,e.mapLightWrap,e.mapLightAnisotropy);break;case"mapLightRepeat":case"mapLightOffset":case"mapLightWrap":case"mapLightAnisotropy":break;case"mapAO":f.aoMap=c(u,e.mapAORepeat,e.mapAOOffset,e.mapAOWrap,e.mapAOAnisotropy);break;case"mapAORepeat":case"mapAOOffset":case"mapAOWrap":case"mapAOAnisotropy":break;case"mapBump":f.bumpMap=c(u,e.mapBumpRepeat,e.mapBumpOffset,e.mapBumpWrap,e.mapBumpAnisotropy);break;case"mapBumpScale":f.bumpScale=u;break;case"mapBumpRepeat":case"mapBumpOffset":case"mapBumpWrap":case"mapBumpAnisotropy":break;case"mapNormal":f.normalMap=c(u,e.mapNormalRepeat,e.mapNormalOffset,e.mapNormalWrap,e.mapNormalAnisotropy);break;case"mapNormalFactor":f.normalScale=u;break;case"mapNormalRepeat":case"mapNormalOffset":case"mapNormalWrap":case"mapNormalAnisotropy":break;case"mapSpecular":f.specularMap=c(u,e.mapSpecularRepeat,e.mapSpecularOffset,e.mapSpecularWrap,e.mapSpecularAnisotropy);break;case"mapSpecularRepeat":case"mapSpecularOffset":case"mapSpecularWrap":case"mapSpecularAnisotropy":break;case"mapMetalness":f.metalnessMap=c(u,e.mapMetalnessRepeat,e.mapMetalnessOffset,e.mapMetalnessWrap,e.mapMetalnessAnisotropy);break;case"mapMetalnessRepeat":case"mapMetalnessOffset":case"mapMetalnessWrap":case"mapMetalnessAnisotropy":break;case"mapRoughness":f.roughnessMap=c(u,e.mapRoughnessRepeat,e.mapRoughnessOffset,e.mapRoughnessWrap,e.mapRoughnessAnisotropy);break;case"mapRoughnessRepeat":case"mapRoughnessOffset":case"mapRoughnessWrap":case"mapRoughnessAnisotropy":break;case"mapAlpha":f.alphaMap=c(u,e.mapAlphaRepeat,e.mapAlphaOffset,e.mapAlphaWrap,e.mapAlphaAnisotropy);break;case"mapAlphaRepeat":case"mapAlphaOffset":case"mapAlphaWrap":case"mapAlphaAnisotropy":break;case"flipSided":f.side=THREE.BackSide;break;case"doubleSided":f.side=THREE.DoubleSide;break;case"transparency":console.warn("THREE_Loader.createMaterial: transparency has been renamed to opacity"),f.opacity=u;break;case"depthTest":case"depthWrite":case"colorWrite":case"opacity":case"reflectivity":case"transparent":case"visible":case"wireframe":f[d]=u;break;case"vertexColors":!0===u&&(f.vertexColors=THREE.VertexColors),"face"===u&&(f.vertexColors=THREE.FaceColors);break;default:console.error("THREE_Loader.createMaterial: Unsupported",d,u)}}return"MeshBasicMaterial"===f.type&&delete f.emissive,"MeshPhongMaterial"!==f.type&&delete f.specular,f.opacity<1&&(f.transparent=!0),i.setTextures(l),i.parse(f)})}),THREE.LegacyJSONLoader=function(){function e(e){"boolean"==typeof e&&(console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),e=void 0),this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.withCredentials=!1}return Object.assign(e.prototype,{crossOrigin:"anonymous",load:function(e,t,r,n){var a=this,o=void 0===this.path?THREE.LoaderUtils.extractUrlBase(e):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setWithCredentials(this.withCredentials),i.load(e,(function(r){var n=JSON.parse(r),i=n.metadata;if(void 0!==i){var s=i.type;if(void 0!==s&&"object"===s.toLowerCase())return void console.error("THREE.JSONLoader: "+e+" should be loaded with THREE.ObjectLoader instead.")}var l=a.parse(n,o);t(l.geometry,l.materials)}),r,n)},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setCrossOrigin:function(e){return this.crossOrigin=e,this},parse:function(e,t){void 0!==e.data&&(e=e.data),void 0!==e.scale?e.scale=1/e.scale:e.scale=1;var n=new THREE.Geometry;return function(e,t){function r(e,t){return e&1<<t}var n,a,o,i,s,l,c,f,d,u,p,h,v,m,x,g,y,E,w,b,T,_,S,R,A,M,C,L=e.faces,H=e.vertices,P=e.normals,z=e.colors,k=e.scale,N=0;if(void 0!==e.uvs){for(n=0;n<e.uvs.length;n++)e.uvs[n].length&&N++;for(n=0;n<N;n++)t.faceVertexUvs[n]=[]}for(i=0,s=H.length;i<s;)(E=new THREE.Vector3).x=H[i++]*k,E.y=H[i++]*k,E.z=H[i++]*k,t.vertices.push(E);for(i=0,s=L.length;i<s;)if(p=r(u=L[i++],0),h=r(u,1),v=r(u,3),m=r(u,4),x=r(u,5),g=r(u,6),y=r(u,7),p){if((b=new THREE.Face3).a=L[i],b.b=L[i+1],b.c=L[i+3],(T=new THREE.Face3).a=L[i+1],T.b=L[i+2],T.c=L[i+3],i+=4,h&&(d=L[i++],b.materialIndex=d,T.materialIndex=d),o=t.faces.length,v)for(n=0;n<N;n++)for(R=e.uvs[n],t.faceVertexUvs[n][o]=[],t.faceVertexUvs[n][o+1]=[],a=0;a<4;a++)M=R[2*(f=L[i++])],C=R[2*f+1],A=new THREE.Vector2(M,C),2!==a&&t.faceVertexUvs[n][o].push(A),0!==a&&t.faceVertexUvs[n][o+1].push(A);if(m&&(c=3*L[i++],b.normal.set(P[c++],P[c++],P[c]),T.normal.copy(b.normal)),x)for(n=0;n<4;n++)c=3*L[i++],S=new THREE.Vector3(P[c++],P[c++],P[c]),2!==n&&b.vertexNormals.push(S),0!==n&&T.vertexNormals.push(S);if(g&&(_=z[l=L[i++]],b.color.setHex(_),T.color.setHex(_)),y)for(n=0;n<4;n++)_=z[l=L[i++]],2!==n&&b.vertexColors.push(new THREE.Color(_)),0!==n&&T.vertexColors.push(new THREE.Color(_));t.faces.push(b),t.faces.push(T)}else{if((w=new THREE.Face3).a=L[i++],w.b=L[i++],w.c=L[i++],h&&(d=L[i++],w.materialIndex=d),o=t.faces.length,v)for(n=0;n<N;n++)for(R=e.uvs[n],t.faceVertexUvs[n][o]=[],a=0;a<3;a++)M=R[2*(f=L[i++])],C=R[2*f+1],A=new THREE.Vector2(M,C),t.faceVertexUvs[n][o].push(A);if(m&&(c=3*L[i++],w.normal.set(P[c++],P[c++],P[c])),x)for(n=0;n<3;n++)c=3*L[i++],S=new THREE.Vector3(P[c++],P[c++],P[c]),w.vertexNormals.push(S);if(g&&(l=L[i++],w.color.setHex(z[l])),y)for(n=0;n<3;n++)l=L[i++],w.vertexColors.push(new THREE.Color(z[l]));t.faces.push(w)}}(e,n),function(e,t){var r=void 0!==e.influencesPerVertex?e.influencesPerVertex:2;if(e.skinWeights)for(var n=0,a=e.skinWeights.length;n<a;n+=r){var o=e.skinWeights[n],i=r>1?e.skinWeights[n+1]:0,s=r>2?e.skinWeights[n+2]:0,l=r>3?e.skinWeights[n+3]:0;t.skinWeights.push(new THREE.Vector4(o,i,s,l))}if(e.skinIndices)for(n=0,a=e.skinIndices.length;n<a;n+=r){var c=e.skinIndices[n],f=r>1?e.skinIndices[n+1]:0,d=r>2?e.skinIndices[n+2]:0,u=r>3?e.skinIndices[n+3]:0;t.skinIndices.push(new THREE.Vector4(c,f,d,u))}t.bones=e.bones,t.bones&&t.bones.length>0&&(t.skinWeights.length!==t.skinIndices.length||t.skinIndices.length!==t.vertices.length)&&console.warn("When skinning, number of vertices ("+t.vertices.length+"), skinIndices ("+t.skinIndices.length+"), and skinWeights ("+t.skinWeights.length+") should match.")}(e,n),function(e,t){var r=e.scale;if(void 0!==e.morphTargets)for(var n=0,a=e.morphTargets.length;n<a;n++){t.morphTargets[n]={},t.morphTargets[n].name=e.morphTargets[n].name,t.morphTargets[n].vertices=[];for(var o=t.morphTargets[n].vertices,i=e.morphTargets[n].vertices,s=0,l=i.length;s<l;s+=3){var c=new THREE.Vector3;c.x=i[s]*r,c.y=i[s+1]*r,c.z=i[s+2]*r,o.push(c)}}if(void 0!==e.morphColors&&e.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var f=t.faces,d=e.morphColors[0].colors;for(n=0,a=f.length;n<a;n++)f[n].color.fromArray(d,3*n)}}(e,n),function(e,t){var r=[],n=[];void 0!==e.animation&&n.push(e.animation),void 0!==e.animations&&(e.animations.length?n=n.concat(e.animations):n.push(e.animations));for(var a=0;a<n.length;a++){var o=THREE.AnimationClip.parseAnimation(n[a],t.bones);o&&r.push(o)}if(t.morphTargets){var i=THREE.AnimationClip.CreateClipsFromMorphTargetSequences(t.morphTargets,10);r=r.concat(i)}r.length>0&&(t.animations=r)}(e,n),n.computeFaceNormals(),n.computeBoundingSphere(),void 0===e.materials||0===e.materials.length?{geometry:n}:{geometry:n,materials:r.prototype.initMaterials(e.materials,this.resourcePath||t,this.crossOrigin)}}}),e}()},function(e,t){THREE.LensFlare=function(){THREE.Group.call(this),this.type="LensFlare",this.positionScreen=new THREE.Vector3,this.flareVisible=!1;var e=new THREE.DataTexture(new Uint8Array(768),16,16,THREE.RGBFormat);e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.needsUpdate=!0;var t=new THREE.DataTexture(new Uint8Array(1024),16,16,THREE.RGBAFormat);t.minFilter=THREE.NearestFilter,t.magFilter=THREE.NearestFilter,t.needsUpdate=!0;var r=THREE.LensFlare.Shader,n=new THREE.RawShaderMaterial({uniforms:r.uniforms,vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,depthWrite:!1}),a=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),n);a.frustumCulled=!1;var o=new THREE.Vector2,i=new THREE.Vector2,s=new THREE.Box2,l=0;this.update=function(r,n,f){if(r instanceof THREE.WebGLRenderer){var d=r.info.render.frame;if(l!==d){l=d;var u=f.w/f.z,p=.5*f.z,h=.5*f.w,v=16/f.w;o.set(v*u,v),s.min.set(f.x,f.y),s.max.set(f.x+(f.z-16),f.y+(f.w-16)),this.positionScreen.setFromMatrixPosition(this.matrixWorld),this.positionScreen.applyMatrix4(n.matrixWorldInverse),this.positionScreen.applyMatrix4(n.projectionMatrix),i.x=f.x+this.positionScreen.x*p+p-8,i.y=f.y+this.positionScreen.y*h+h-8,!0===s.containsPoint(i)?(this.flareVisible=!0,r.copyFramebufferToTexture(i,e),a.material.uniforms.renderType.value=0,a.material.uniforms.scale.value=o,a.material.uniforms.screenPosition.value=this.positionScreen,a.material.depthTest=!0,r.render(a,n),r.copyFramebufferToTexture(i,t),a.material.uniforms.renderType.value=1,a.material.uniforms.map.value=e,a.material.depthTest=!1,r.render(a,n),function(){for(var e=2*-c.positionScreen.x,t=2*-c.positionScreen.y,r=0,n=c.children.length;r<n;r++){var a=c.children[r];a.flarePosition.x=c.positionScreen.x+e*a.flareDistance,a.flarePosition.y=c.positionScreen.y+t*a.flareDistance}}()):this.flareVisible=!1}}};var c=this;this.getOcclusionMap=function(){return t},this.dispose=function(){a.material.dispose(),e.dispose(),t.dispose()}},THREE.LensFlare.prototype=Object.create(THREE.Group.prototype),THREE.LensFlare.prototype.constructor=THREE.LensFlare,THREE.LensFlare.prototype.isLensFlare=!0,THREE.LensFlare.Shader={uniforms:{renderType:{value:0},map:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:["precision highp float;","uniform vec3 screenPosition;","uniform vec2 scale;","attribute vec3 position;","attribute vec2 uv;","varying vec2 vUV;","void main() {","\tvUV = uv;","\tvec2 pos = position.xy;","\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["precision highp float;","uniform lowp int renderType;","uniform sampler2D map;","varying vec2 vUV;","void main() {","\tif ( renderType == 0 ) {","\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );","\t} else {","\t\tgl_FragColor = texture2D( map, vUV );","\t}","}"].join("\n")},THREE.LensFlareElement=function(e,t,r,n,a,o){THREE.Mesh.call(this),this.type="LensFlareElement",this.frustumCulled=!1,this.renderOrder=1/0,this.flareTexture=e,this.flareSize=t||1,this.flareDistance=r||0,this.flareBlending=a||THREE.AdditiveBlending,this.flareColor=n||new THREE.Color(16777215),this.flareOpacity=o||1,this.flarePosition=new THREE.Vector3,this.flareRotation=0,this.geometry=new THREE.PlaneBufferGeometry(2,2);var i=THREE.LensFlareElement.Shader;this.material=new THREE.RawShaderMaterial({uniforms:i.uniforms,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,blending:this.flareBlending,transparent:!0,depthWrite:!1});var s=new THREE.Vector2,l=new THREE.Vector4;this.onBeforeRender=function(e,t,r,n,a,o){var i=this.parent;if(null!==i){e.getCurrentViewport(l),i.update(e,r,l);var c=this.flareSize/l.w,f=l.w/l.z;s.set(c*f,c),this.material.uniforms.map.value=this.flareTexture,this.material.uniforms.occlusionMap.value=i.getOcclusionMap(),this.material.uniforms.opacity.value=this.flareOpacity,this.material.uniforms.color.value=this.flareColor,this.material.uniforms.scale.value=s,this.material.uniforms.rotation.value=this.flareRotation,this.material.uniforms.screenPosition.value=this.flarePosition,!1===i.flareVisible&&(this.material.uniforms.opacity.value=0)}else console.error("THREE.LensFlareElement: LensFlareElement not assigned to a LensFlare. Rendering not possible.")},this.dispose=function(){this.material.dispose()}},THREE.LensFlareElement.prototype=Object.create(THREE.Mesh.prototype),THREE.LensFlareElement.prototype.constructor=THREE.LensFlareElement,THREE.LensFlareElement.prototype.isLensFlareElement=!0,THREE.LensFlareElement.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},opacity:{value:1},color:{value:null},scale:{value:null},rotation:{value:0},screenPosition:{value:null}},vertexShader:["precision highp float;","uniform vec3 screenPosition;","uniform vec2 scale;","uniform float rotation;","uniform sampler2D occlusionMap;","attribute vec3 position;","attribute vec2 uv;","varying vec2 vUV;","varying float vVisibility;","void main() {","\tvUV = uv;","\tvec2 pos = position.xy;","\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );"," visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );","\tvVisibility =        visibility.r / 9.0;","\tvVisibility *= 1.0 - visibility.g / 9.0;","\tvVisibility *=       visibility.b / 9.0;","\tvVisibility *= 1.0 - visibility.a / 9.0;","\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;","\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;","\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["precision highp float;","uniform sampler2D map;","uniform float opacity;","uniform vec3 color;","varying vec2 vUV;","varying float vVisibility;","void main() {","\tvec4 texture = texture2D( map, vUV );","\ttexture.a *= opacity * vVisibility;","\tgl_FragColor = texture;","\tgl_FragColor.rgb *= color;","}"].join("\n")}},function(e,t){THREE.PhysicsRenderer=function(e,t,r){this.checkCompatibility(r),this.renderer=r,this.size=e||128,this.resolution=new THREE.Vector2(this.size,this.size),this.rt_1=new THREE.WebGLRenderTarget(this.size,this.size,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,stencilBuffer:!1}),this.rt_2=this.rt_1.clone(),this.rt_3=this.rt_1.clone(),this.counter=0,this.texturePass=this.createTexturePassProgram(),this.simulatePass=this.createSimulatePassProgram(t),this.boundTextures=[],this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.mesh=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2)),this.scene.add(this.mesh)},THREE.PhysicsRenderer.prototype.checkCompatibility=function(e){var t=e.getContext();null!==t.getExtension("OES_texture_float")?0!==t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)||this.onError("Vertex Shader Textures don't work"):this.onError("No Float Textures")},THREE.PhysicsRenderer.prototype.onError=function(e){console.log(e)},THREE.PhysicsRenderer.prototype.createDebugScene=function(){var e=new THREE.Object3D;e.position.z=0;var t,r=new THREE.PlaneBufferGeometry(100,100);return(t=new THREE.Mesh(r,new THREE.MeshBasicMaterial({map:this.rt_1}))).position.set(-105,0,0),e.add(t),(t=new THREE.Mesh(r,new THREE.MeshBasicMaterial({map:this.rt_2}))).position.set(0,0,0),e.add(t),(t=new THREE.Mesh(r,new THREE.MeshBasicMaterial({map:this.rt_3}))).position.set(105,0,0),e.add(t),e},THREE.PhysicsRenderer.prototype.removeDebugScene=function(e){e.remove(this.debugScene)},THREE.PhysicsRenderer.prototype.addDebugScene=function(e){e.add(this.debugScene)},THREE.PhysicsRenderer.prototype.createTexturePassProgram=function(){return new THREE.ShaderMaterial({uniforms:{texture:{type:"t",value:null}},vertexShader:this.VSPass,fragmentShader:this.FSPass})},THREE.PhysicsRenderer.prototype.createSimulatePassProgram=function(e){var t={t_oPos:{type:"t",value:null},t_pos:{type:"t",value:null},resolution:{type:"v2",value:this.resolution}};return new THREE.ShaderMaterial({uniforms:t,vertexShader:this.VSPass,fragmentShader:e})},THREE.PhysicsRenderer.prototype.update=function(){var e=this.counter%3;0==e?(this.simulatePass.uniforms.t_oPos.value=this.rt_1.texture,this.simulatePass.uniforms.t_pos.value=this.rt_2.texture,this.pass(this.simulatePass,this.rt_3),this.ooOutput=this.rt_1.texture,this.oOutput=this.rt_2.texture,this.output=this.rt_3.texture):1==e?(this.simulatePass.uniforms.t_oPos.value=this.rt_2.texture,this.simulatePass.uniforms.t_pos.value=this.rt_3.texture,this.pass(this.simulatePass,this.rt_1),this.ooOutput=this.rt_2.texture,this.oOutput=this.rt_3.texture,this.output=this.rt_1.texture):2==e&&(this.simulatePass.uniforms.t_oPos.value=this.rt_3.texture,this.simulatePass.uniforms.t_pos.value=this.rt_1.texture,this.pass(this.simulatePass,this.rt_2),this.ooOutput=this.rt_3.texture,this.oOutput=this.rt_1.texture,this.output=this.rt_2.texture),this.counter++,this.bindTextures()},THREE.PhysicsRenderer.prototype.render=function(e,t,r){this.renderer.setRenderTarget(r),this.renderer.render(e,t)},THREE.PhysicsRenderer.prototype.pass=function(e,t){this.mesh.material=e,this.renderer.setRenderTarget(t),this.renderer.render(this.scene,this.camera)},THREE.PhysicsRenderer.prototype.out=function(e){this.mesh.material=e.material,this.renderer.render(this.scene,this.camera)},THREE.PhysicsRenderer.prototype.setUniforms=function(e){for(var t in e)this.simulatePass.uniforms[t]=e[t];this.simulatePass.uniforms.t_pos={type:"t",value:null},this.simulatePass.uniforms.t_oPos={type:"t",value:null},this.simulatePass.uniforms.resolution={type:"v2",value:this.resolution}},THREE.PhysicsRenderer.prototype.setUniform=function(e,t){this.simulatePass.uniforms[e]=t},THREE.PhysicsRenderer.prototype.reset=function(e){this.texture=e,this.texturePass.uniforms.texture.value=e,this.pass(this.texturePass,this.rt_1),this.pass(this.texturePass,this.rt_2),this.pass(this.texturePass,this.rt_3)},THREE.PhysicsRenderer.prototype.passTexture=function(e,t){this.texturePass.uniforms.texture.value=e,this.pass(this.texturePass,t)},THREE.PhysicsRenderer.prototype.resetRand=function(e,t,r,n){e=e||100,t=t||0,r=r||0,n=n||0;for(var a=new Float32Array(this.size*this.size*4),o=0;o<a.length;o+=4)a[o+0]=t+(Math.random()-.5)*e,a[o+1]=r+(Math.random()-.5)*e,a[o+2]=n+(Math.random()-.5)*e,a[o+3]=100;var i=new THREE.DataTexture(a,this.size,this.size,THREE.RGBAFormat,THREE.FloatType);i.minFilter=THREE.NearestFilter,i.magFilter=THREE.NearestFilter,i.needsUpdate=!0,this.reset(i)},THREE.PhysicsRenderer.prototype.addBoundTexture=function(e,t){this.boundTextures.push([e,t])},THREE.PhysicsRenderer.prototype.bindTextures=function(){for(var e=0;e<this.boundTextures.length;e++){var t=this.boundTextures[e][0],r=this.boundTextures[e][1];t.value=this[r]}},THREE.PhysicsRenderer.prototype.VSPass=["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = vec4( position, 1.0 );","}"].join("\n"),THREE.PhysicsRenderer.prototype.FSPass=["uniform sampler2D texture;","varying vec2 vUv;","void main() {","  vec4 c = texture2D( texture , vUv );","  gl_FragColor = c;","}"].join("\n")},function(e,t){THREE.MirrorRenderer=function(e,t,r,n){function a(e,t){return void 0!==e?e:t}THREE.Object3D.call(this),this.name="mirror_"+this.id,n=n||{},this.matrixNeedsUpdate=!0;var o=a(n.textureWidth,512),i=a(n.textureHeight,512);this.clipBias=a(n.clipBias,0),this.renderer=e,this.scene=r,this.mirrorPlane=new THREE.Plane,this.normal=new THREE.Vector3(0,0,1),this.cameraWorldPosition=new THREE.Vector3,this.rotationMatrix=new THREE.Matrix4,this.lookAtPosition=new THREE.Vector3(0,0,-1),this.clipPlane=new THREE.Vector4,t instanceof THREE.PerspectiveCamera?this.camera=t:(this.camera=new THREE.PerspectiveCamera,console.log(this.name+": camera is not a Perspective Camera!")),this.textureMatrix=new THREE.Matrix4,this.mirrorCamera=this.camera.clone(),this.mesh=new THREE.Object3D,this.texture=new THREE.WebGLRenderTarget(o,i),this.tempTexture=new THREE.WebGLRenderTarget(o,i),THREE.Math.isPowerOfTwo(o)&&THREE.Math.isPowerOfTwo(i)||(this.texture.texture.generateMipmaps=!1,this.tempTexture.texture.generateMipmaps=!1),this.updateTextureMatrix(),this.render()},THREE.MirrorRenderer.prototype=Object.create(THREE.Object3D.prototype),THREE.MirrorRenderer.prototype.renderWithMirror=function(e){this.updateTextureMatrix(),this.matrixNeedsUpdate=!1;var t=e.camera;e.camera=this.mirrorCamera,e.render(!0),e.material.uniforms.mirrorSampler.value=e.tempTexture.texture,this.render(),this.matrixNeedsUpdate=!0,e.material.uniforms.mirrorSampler.value=e.texture.texture,e.camera=t,e.updateTextureMatrix()},THREE.MirrorRenderer.prototype.updateTextureMatrix=function(){function e(e){return e?e<0?-1:1:0}null!=this.parent&&(this.mesh=this.parent),this.updateMatrixWorld(),this.camera.updateMatrixWorld(),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.matrixWorld),this.normal=new THREE.Vector3(0,1,0).applyEuler(this.mesh.rotation);var t=new THREE.Vector3(0,0,1).applyEuler(this.camera.rotation);if(this.normal.dot(t)<0){var r=new THREE.Vector3(0,0,1).applyEuler(this.mesh.rotation);this.normal.reflect(r)}var n=this.mesh.position.clone().sub(this.cameraWorldPosition);n.reflect(this.normal).negate(),n.add(this.mesh.position),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition);var a=this.mesh.position.clone().sub(this.lookAtPosition);a.reflect(this.normal).negate(),a.add(this.mesh.position),this.up.set(0,-1,0),this.up.applyMatrix4(this.rotationMatrix),this.up.reflect(this.normal).negate(),this.mirrorCamera.position.copy(n),this.mirrorCamera.up=this.up,this.mirrorCamera.lookAt(a),this.mirrorCamera.aspect=this.camera.aspect,this.mirrorCamera.updateProjectionMatrix(),this.mirrorCamera.updateMatrixWorld(),this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix),this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse),this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal,this.mesh.position),this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse),this.clipPlane.set(this.mirrorPlane.normal.x,this.mirrorPlane.normal.y,this.mirrorPlane.normal.z,this.mirrorPlane.constant);var o=new THREE.Vector4,i=this.mirrorCamera.projectionMatrix;o.x=(e(this.clipPlane.x)+i.elements[8])/i.elements[0],o.y=(e(this.clipPlane.y)+i.elements[9])/i.elements[5],o.z=-1,o.w=(1+i.elements[10])/i.elements[14];var s=new THREE.Vector4;s=this.clipPlane.multiplyScalar(2/this.clipPlane.dot(o)),i.elements[2]=s.x,i.elements[6]=s.y,i.elements[10]=s.z+1-this.clipBias,i.elements[14]=s.w;var l=new THREE.Vector3;l.setFromMatrixPosition(this.camera.matrixWorld),this.eye=l},THREE.MirrorRenderer.prototype.render=function(e){if(this.matrixNeedsUpdate&&this.updateTextureMatrix(),this.matrixNeedsUpdate=!0,void 0!==this.scene&&this.scene instanceof THREE.Scene){var t=void 0!==e&&e?this.tempTexture:this.texture;this.renderer.setRenderTarget(t),this.renderer.clear(),this.renderer.render(this.scene,this.mirrorCamera)}}},function(e,t){THREE.ShaderLib.ocean_sim_vertex={vertexShader:["varying vec2 vUV;","void main (void) {","vUV = position.xy * 0.5 + 0.5;","gl_Position = vec4(position, 1.0);","}"].join("\n")},THREE.ShaderLib.ocean_subtransform={uniforms:{u_input:{value:null},u_transformSize:{value:512},u_subtransformSize:{value:250}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","uniform sampler2D u_input;","uniform float u_transformSize;","uniform float u_subtransformSize;","varying vec2 vUV;","vec2 multiplyComplex (vec2 a, vec2 b) {","return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);","}","void main (void) {","#ifdef HORIZONTAL","float index = vUV.x * u_transformSize - 0.5;","#else","float index = vUV.y * u_transformSize - 0.5;","#endif","float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);","#ifdef HORIZONTAL","vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;","vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;","#else","vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;","vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;","#endif","float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);","vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));","vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);","vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);","gl_FragColor = vec4(outputA, outputB);","}"].join("\n")},THREE.ShaderLib.ocean_initial_spectrum={uniforms:{u_wind:{value:new THREE.Vector2(10,10)},u_resolution:{value:512},u_size:{value:250}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","const float CM = 0.23;","uniform vec2 u_wind;","uniform float u_resolution;","uniform float u_size;","float square (float x) {","return x * x;","}","float omega (float k) {","return sqrt(G * k * (1.0 + square(k / KM)));","}","float tanh_ (float x) {","return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));","}","void main (void) {","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 K = (2.0 * PI * vec2(n, m)) / u_size;","float k = length(K);","float l_wind = length(u_wind);","float Omega = 0.84;","float kp = G * square(Omega / l_wind);","float c = omega(k) / k;","float cp = omega(kp) / kp;","float Lpm = exp(-1.25 * square(kp / k));","float gamma = 1.7;","float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));","float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));","float Jp = pow(gamma, Gamma);","float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));","float alphap = 0.006 * sqrt(Omega);","float Bl = 0.5 * alphap * cp / c * Fp;","float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);","float uStar = 0.41 * l_wind / log(10.0 / z0);","float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));","float Fm = exp(-0.25 * square(k / KM - 1.0));","float Bh = 0.5 * alpham * CM / c * Fm * Lpm;","float a0 = log(2.0) / 4.0;","float am = 0.13 * uStar / CM;","float Delta = tanh_(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));","float cosPhi = dot(normalize(u_wind), normalize(K));","float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));","float dk = 2.0 * PI / u_size;","float h = sqrt(S / 2.0) * dk;","if (K.x == 0.0 && K.y == 0.0) {","h = 0.0;","}","gl_FragColor = vec4(h, 0.0, 0.0, 0.0);","}"].join("\n")},THREE.ShaderLib.ocean_phase={uniforms:{u_phases:{value:null},u_deltaTime:{value:null},u_resolution:{value:null},u_size:{value:null}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","varying vec2 vUV;","uniform sampler2D u_phases;","uniform float u_deltaTime;","uniform float u_resolution;","uniform float u_size;","float omega (float k) {","return sqrt(G * k * (1.0 + k * k / KM * KM));","}","void main (void) {","float deltaTime = 1.0 / 60.0;","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;","float phase = texture2D(u_phases, vUV).r;","float deltaPhase = omega(length(waveVector)) * u_deltaTime;","phase = mod(phase + deltaPhase, 2.0 * PI);","gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);","}"].join("\n")},THREE.ShaderLib.ocean_spectrum={uniforms:{u_size:{value:null},u_resolution:{value:null},u_choppiness:{value:null},u_phases:{value:null},u_initialSpectrum:{value:null}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","varying vec2 vUV;","uniform float u_size;","uniform float u_resolution;","uniform float u_choppiness;","uniform sampler2D u_phases;","uniform sampler2D u_initialSpectrum;","vec2 multiplyComplex (vec2 a, vec2 b) {","return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);","}","vec2 multiplyByI (vec2 z) {","return vec2(-z[1], z[0]);","}","float omega (float k) {","return sqrt(G * k * (1.0 + k * k / KM * KM));","}","void main (void) {","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;","float phase = texture2D(u_phases, vUV).r;","vec2 phaseVector = vec2(cos(phase), sin(phase));","vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;","vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;","h0Star.y *= -1.0;","vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));","vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;","vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;","if (waveVector.x == 0.0 && waveVector.y == 0.0) {","h = vec2(0.0);","hX = vec2(0.0);","hZ = vec2(0.0);","}","gl_FragColor = vec4(hX + multiplyByI(h), hZ);","}"].join("\n")},THREE.ShaderLib.ocean_normals={uniforms:{u_displacementMap:{value:null},u_resolution:{value:null},u_size:{value:null}},fragmentShader:["precision highp float;","varying vec2 vUV;","uniform sampler2D u_displacementMap;","uniform float u_resolution;","uniform float u_size;","void main (void) {","float texel = 1.0 / u_resolution;","float texelSize = u_size / u_resolution;","vec3 center = texture2D(u_displacementMap, vUV).rgb;","vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;","vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;","vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;","vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;","vec3 topRight = cross(right, top);","vec3 topLeft = cross(top, left);","vec3 bottomLeft = cross(left, bottom);","vec3 bottomRight = cross(bottom, right);","gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);","}"].join("\n")},THREE.ShaderChunk.screenplane_pars_vertex=["const float infinite = 150000.0;","const float screenScale = 1.2;","const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );","varying vec3 vCamPosition;","vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )","{","\tfloat distance = ( - height - dot( normal, source ) ) / dot( normal, dir );","\tif( distance < 0.0 )","\t\treturn source + dir * distance;","\telse ","\t\treturn - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );","}","mat3 getRotation()","{","\treturn mat3( ","\t\tviewMatrix[0].xyz,","\t\tviewMatrix[1].xyz,","\t\tviewMatrix[2].xyz","\t);","}","vec3 getCameraPos( in mat3 rotation )","{","\treturn - viewMatrix[3].xyz * rotation;","}","vec2 getImagePlan()","{","\tfloat focal = projectionMatrix[0].x;","\tfloat aspect = projectionMatrix[1].y;","\treturn vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );","}","vec3 getCamRay( in mat3 rotation, in vec2 screenUV )","{","\treturn vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;","}","vec3 computeProjectedPosition()","{","\tmat3 cameraRotation = getRotation();","\tvec3 camPosition = getCameraPos( cameraRotation );","\tvCamPosition = camPosition;","\tvec2 screenUV = getImagePlan();","\tvec3 ray = getCamRay( cameraRotation, screenUV );","\tvec3 finalPos = interceptPlane( camPosition, ray, groundNormal, -u_groundHeight );","\tfloat distance = length( finalPos );","\tif( distance > infinite )","\t\tfinalPos *= infinite / distance;","\treturn finalPos;","}"].join("\n"),THREE.ShaderChunk.screenplane_vertex=["vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );"].join("\n"),THREE.ShaderChunk.screenplane_pars_fragment=["varying vec3 vCamPosition;"].join("\n"),THREE.ShaderChunk.oceanfft_pars_vertex=["uniform sampler2D u_displacementMap;","uniform float u_geometrySize;","uniform float u_size;"].join("\n"),THREE.ShaderChunk.oceanfft_vertex=["vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );","vec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );"].join("\n"),THREE.ShaderLib.ocean_main={uniforms:{u_displacementMap:{value:null},u_reflection:{value:null},u_normalMap:{value:null},u_geometrySize:{value:null},u_size:{value:null},u_mirrorMatrix:{value:null},u_oceanColor:{value:null},u_sunDirection:{value:null},u_exposure:{value:null},u_groundHeight:{value:null}},vertexShader:["precision highp float;","varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform mat4 u_mirrorMatrix;","uniform float u_groundHeight;",THREE.ShaderChunk.screenplane_pars_vertex,THREE.ShaderChunk.oceanfft_pars_vertex,"void main (void) {",THREE.ShaderChunk.screenplane_vertex,"vec4 worldPosition = screenPlaneWorldPosition;",THREE.ShaderChunk.oceanfft_vertex,"vWorldPosition = oceanfftWorldPosition.xyz;","vReflectCoordinates = u_mirrorMatrix * oceanfftWorldPosition;","gl_Position = projectionMatrix * viewMatrix * oceanfftWorldPosition;","}"].join("\n"),vertexShaderNoTexLookup:["precision highp float;","varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform mat4 u_mirrorMatrix;","uniform float u_groundHeight;",THREE.ShaderChunk.screenplane_pars_vertex,THREE.ShaderChunk.oceanfft_pars_vertex,"void main (void) {",THREE.ShaderChunk.screenplane_vertex,"vWorldPosition = screenPlaneWorldPosition.xyz;","vReflectCoordinates = u_mirrorMatrix * screenPlaneWorldPosition;","gl_Position = projectionMatrix * viewMatrix * screenPlaneWorldPosition;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform sampler2D u_reflection;","uniform sampler2D u_normalMap;","uniform vec3 u_oceanColor;","uniform vec3 u_sunDirection;","uniform float u_exposure;","vec3 hdr (vec3 color, float exposure) {","return 1.0 - exp(-color * exposure);","}",THREE.ShaderChunk.screenplane_pars_fragment,"void main (void) {","vec3 normal = texture2D( u_normalMap, vWorldPosition.xz * 0.002 ).rgb;","vec3 view = normalize( vCamPosition - vWorldPosition );","vec3 reflection = normalize( reflect( -u_sunDirection, normal ) );","float specularFactor = pow( max( 0.0, dot( view, reflection ) ), 500.0 ) * 20.0;","vec3 distortion = 200.0 * normal * vec3( 1.0, 0.0, 0.1 );","vec3 reflectionColor = texture2DProj( u_reflection, vReflectCoordinates.xyz + distortion ).xyz;","float distanceRatio = min( 1.0, log( 1.0 / length( vCamPosition - vWorldPosition ) * 3000.0 + 1.0 ) );","distanceRatio *= distanceRatio;","distanceRatio = distanceRatio * 0.7 + 0.3;","normal = ( distanceRatio * normal + vec3( 0.0, 1.0 - distanceRatio, 0.0 ) ) * 0.5;","normal /= length( normal );","float fresnel = pow( 1.0 - dot( normal, view ), 2.0 );","float skyFactor = ( fresnel + 0.2 ) * 10.0;","vec3 waterColor = ( 1.0 - fresnel ) * u_oceanColor;","vec3 color = ( skyFactor + specularFactor + waterColor ) * reflectionColor + waterColor * 0.5 ;","color = hdr( color, u_exposure );","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")}},function(e,t,r){"use strict";var n;window.ThreeBSP=((n=function(e){this.matrix=new THREE.Matrix4,this.create(e)}).prototype.subtract=function(e){var t=this.tree.clone(),r=e.tree.clone();return t.invert(),t.clipTo(r),r.clipTo(t),r.invert(),r.clipTo(t),r.invert(),t.build(r.allPolygons()),t.invert(),(t=new n(t)).matrix=this.matrix,t},n.prototype.union=function(e){var t=this.tree.clone(),r=e.tree.clone();return t.clipTo(r),r.clipTo(t),r.invert(),r.clipTo(t),r.invert(),t.build(r.allPolygons()),(t=new n(t)).matrix=this.matrix,t},n.prototype.intersect=function(e){var t=this.tree.clone(),r=e.tree.clone();return t.invert(),r.clipTo(t),r.invert(),t.clipTo(r),r.clipTo(t),t.build(r.allPolygons()),t.invert(),(t=new n(t)).matrix=this.matrix,t},n.prototype.create=function(e){if(e instanceof THREE.Geometry)this.fromGeometry(e);else if(e instanceof THREE.BufferGeometry)this.fromBufferGeometry(e);else{if(!(e instanceof THREE.Mesh)){if(e instanceof n.Node)return this.tree=e,this;throw new Error("ThreeBSP: is unable to create a BSP for the given input")}this.fromMesh(e)}},n.prototype.fromGeometry=function(e){var t,r,a,o,i,s,l,c=[];for(t=0,r=e.faces.length;t<r;t++)a=e.faces[t],i=e.faceVertexUvs[0][t],l=new n.Polygon,o=e.vertices[a.a],s=i?new THREE.Vector2(i[0].x,i[0].y):null,(o=new n.Vertex(o.x,o.y,o.z,a.vertexNormals[0],s)).applyMatrix4(this.matrix),l.vertices.push(o),o=e.vertices[a.b],s=i?new THREE.Vector2(i[1].x,i[1].y):null,(o=new n.Vertex(o.x,o.y,o.z,a.vertexNormals[1],s)).applyMatrix4(this.matrix),l.vertices.push(o),o=e.vertices[a.c],s=i?new THREE.Vector2(i[2].x,i[2].y):null,(o=new n.Vertex(o.x,o.y,o.z,a.vertexNormals[2],s)).applyMatrix4(this.matrix),l.vertices.push(o),l.calculateProperties(),c.push(l);this.tree=new n.Node(c)},n.prototype.fromIndexedBufferGeometry=function(e){var t,r,a,o,i,s,l,c,f,d,u,p,h,v=e.index.array,m=e.attributes.position.array,x=e.attributes.normal.array,g=e.attributes.uv.array,y=[];for(t=0,r=v.length;t<r;t+=3){for(i=new n.Polygon,s=0;s<3;s++)c=1+(l=3*(a=v[t+s])),f=l+2,u=1+(d=2*a),p=x?new THREE.Vector3(x[l],x[c],x[f]):null,h=g?new THREE.Vector2(g[d],g[u]):null,(o=new n.Vertex(m[l],m[c],m[f],p,h)).applyMatrix4(this.matrix),i.vertices.push(o);i.calculateProperties(),y.push(i)}this.tree=new n.Node(y)},n.prototype.fromNonIndexedBufferGeometry=function(e){var t,r,a,o,i,s,l=e.attributes.position.array,c=e.attributes.normal.array,f=e.attributes.uv.array,d=[];for(t=0,r=l.length;t<r;t+=9)o=new n.Polygon,i=c?new THREE.Vector3(c[t],c[t+1],c[t+2]):null,s=f?new THREE.Vector2(f[t],f[t+1]):null,(a=new n.Vertex(l[t],l[t+1],l[t+2],i,s)).applyMatrix4(this.matrix),o.vertices.push(a),i=c?new THREE.Vector3(c[t+3],c[t+4],c[t+5]):null,s=f?new THREE.Vector2(f[t+2],f[t+3]):null,(a=new n.Vertex(l[t+3],l[t+4],l[t+5],i,s)).applyMatrix4(this.matrix),o.vertices.push(a),i=c?new THREE.Vector3(c[t+6],c[t+7],c[t+8]):null,s=f?new THREE.Vector2(f[t+4],f[t+5]):null,(a=new n.Vertex(l[t+6],l[t+7],l[t+8])).applyMatrix4(this.matrix),o.vertices.push(a),o.calculateProperties(),d.push(o);this.tree=new n.Node(d)},n.prototype.fromBufferGeometry=function(e){null===e.index?this.fromNonIndexedBufferGeometry(e):this.fromIndexedBufferGeometry(e)},n.prototype.fromMesh=function(e){var t=e.geometry;e.updateMatrix(),this.matrix=e.matrix.clone(),this.create(t)},n.prototype.toGeometry=function(){var e,t,r,n,a,o,i,s,l,c,f=(new THREE.Matrix4).getInverse(this.matrix),d=new THREE.Geometry,u=this.tree.allPolygons(),p=u.length,h={};for(e=0;e<p;e++)for(n=(r=u[e]).vertices.length,t=2;t<n;t++)c=[],s=r.vertices[0],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?a=h[s.x+","+s.y+","+s.z]:(d.vertices.push(s),a=h[s.x+","+s.y+","+s.z]=d.vertices.length-1),s=r.vertices[t-1],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?o=h[s.x+","+s.y+","+s.z]:(d.vertices.push(s),o=h[s.x+","+s.y+","+s.z]=d.vertices.length-1),s=r.vertices[t],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?i=h[s.x+","+s.y+","+s.z]:(d.vertices.push(s),i=h[s.x+","+s.y+","+s.z]=d.vertices.length-1),l=new THREE.Face3(a,o,i,new THREE.Vector3(r.normal.x,r.normal.y,r.normal.z)),d.faces.push(l),d.faceVertexUvs[0].push(c);return d},n.prototype.toBufferGeometry=function(){var e,t,r,n,a,o,i,s,l=(new THREE.Matrix4).getInverse(this.matrix),c=new THREE.BufferGeometry,f=[],d=[],u=[],p=[],h=this.tree.allPolygons(),v=h.length,m={},x=0;for(e=0;e<v;e++)for(n=(r=h[e]).vertices.length,t=2;t<n;t++)(s=r.vertices[0]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?a=m[s.x+","+s.y+","+s.z]:(d.push(s.x,s.y,s.z),a=x,u.push(r.normal.x,r.normal.y,r.normal.z),x++),(s=r.vertices[t-1]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?o=m[s.x+","+s.y+","+s.z]:(d.push(s.x,s.y,s.z),o=x,u.push(r.normal.x,r.normal.y,r.normal.z),x++),(s=r.vertices[t]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?i=m[s.x+","+s.y+","+s.z]:(d.push(s.x,s.y,s.z),i=x,u.push(r.normal.x,r.normal.y,r.normal.z),x++),f.push(a,o,i);return c.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(p),2)),c.setAttribute("position",new THREE.BufferAttribute(new Float32Array(d),3)),c.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(u),3)),c.setIndex(new THREE.BufferAttribute(new Uint32Array(f),1)),c},n.prototype.toMesh=function(e){var t=this.toGeometry(),r=new THREE.Mesh(t,e);return r.position.setFromMatrixPosition(this.matrix),r.rotation.setFromRotationMatrix(this.matrix),r},(n.Polygon=function(e,t,r){e instanceof Array||(e=[]),this.vertices=e,e.length>0?this.calculateProperties():this.normal=this.w=void 0}).prototype.calculateProperties=function(){var e=this.vertices[0],t=this.vertices[1],r=this.vertices[2];return this.normal=t.clone().subtract(e).cross(r.clone().subtract(e)).normalize(),this.w=this.normal.clone().dot(e),this},n.Polygon.prototype.clone=function(){var e,t,r=new n.Polygon;for(e=0,t=this.vertices.length;e<t;e++)r.vertices.push(this.vertices[e].clone());return r.calculateProperties(),r},n.Polygon.prototype.flip=function(){var e,t=[];for(this.normal.multiplyScalar(-1),this.w*=-1,e=this.vertices.length-1;e>=0;e--)t.push(this.vertices[e]);return this.vertices=t,this},n.Polygon.prototype.classifyVertex=function(e){var t=this.normal.dot(e)-this.w;return t<-1e-5?2:t>1e-5?1:0},n.Polygon.prototype.classifySide=function(e){var t,r,n,a=0,o=0,i=e.vertices.length;for(t=0;t<i;t++)r=e.vertices[t],1===(n=this.classifyVertex(r))?a++:2===n&&o++;return a>0&&0===o?1:0===a&&o>0?2:0===a&&0===o?0:3},n.Polygon.prototype.splitPolygon=function(e,t,r,a,o){var i=this.classifySide(e);if(0===i)(this.normal.dot(e.normal)>0?t:r).push(e);else if(1===i)a.push(e);else if(2===i)o.push(e);else{var s,l,c,f,d,u,p,h,v,m=[],x=[];for(l=0,s=e.vertices.length;l<s;l++)c=(l+1)%s,u=e.vertices[l],p=e.vertices[c],f=this.classifyVertex(u),d=this.classifyVertex(p),2!=f&&m.push(u),1!=f&&x.push(u),3==(f|d)&&(h=(this.w-this.normal.dot(u))/this.normal.dot(p.clone().subtract(u)),v=u.interpolate(p,h),m.push(v),x.push(v));m.length>=3&&a.push(new n.Polygon(m).calculateProperties()),x.length>=3&&o.push(new n.Polygon(x).calculateProperties())}},(n.Vertex=function(e,t,r,n,a){this.x=e,this.y=t,this.z=r,this.normal=n||new THREE.Vector3,this.uv=a||new THREE.Vector2}).prototype.clone=function(){return new n.Vertex(this.x,this.y,this.z,this.normal.clone(),this.uv.clone())},n.Vertex.prototype.add=function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this},n.Vertex.prototype.subtract=function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this},n.Vertex.prototype.multiplyScalar=function(e){return this.x*=e,this.y*=e,this.z*=e,this},n.Vertex.prototype.cross=function(e){var t=this.x,r=this.y,n=this.z;return this.x=r*e.z-n*e.y,this.y=n*e.x-t*e.z,this.z=t*e.y-r*e.x,this},n.Vertex.prototype.normalize=function(){var e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return this.x/=e,this.y/=e,this.z/=e,this},n.Vertex.prototype.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z},n.Vertex.prototype.lerp=function(e,t){return this.add(e.clone().subtract(this).multiplyScalar(t)),this.normal.add(e.normal.clone().sub(this.normal).multiplyScalar(t)),this.uv.add(e.uv.clone().sub(this.uv).multiplyScalar(t)),this},n.Vertex.prototype.interpolate=function(e,t){return this.clone().lerp(e,t)},n.Vertex.prototype.applyMatrix4=function(e){var t=this.x,r=this.y,n=this.z,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*n+a[12],this.y=a[1]*t+a[5]*r+a[9]*n+a[13],this.z=a[2]*t+a[6]*r+a[10]*n+a[14],this},(n.Node=function(e){var t,r,a=[],o=[];if(this.polygons=[],this.front=this.back=void 0,e instanceof Array&&0!==e.length){for(this.divider=e[0].clone(),t=0,r=e.length;t<r;t++)this.divider.splitPolygon(e[t],this.polygons,this.polygons,a,o);a.length>0&&(this.front=new n.Node(a)),o.length>0&&(this.back=new n.Node(o))}}).isConvex=function(e){var t,r;for(t=0;t<e.length;t++)for(r=0;r<e.length;r++)if(t!==r&&2!==e[t].classifySide(e[r]))return!1;return!0},n.Node.prototype.build=function(e){var t,r,a=[],o=[];for(this.divider||(this.divider=e[0].clone()),t=0,r=e.length;t<r;t++)this.divider.splitPolygon(e[t],this.polygons,this.polygons,a,o);a.length>0&&(this.front||(this.front=new n.Node),this.front.build(a)),o.length>0&&(this.back||(this.back=new n.Node),this.back.build(o))},n.Node.prototype.allPolygons=function(){var e=this.polygons.slice();return this.front&&(e=e.concat(this.front.allPolygons())),this.back&&(e=e.concat(this.back.allPolygons())),e},n.Node.prototype.clone=function(){var e=new n.Node;return e.divider=this.divider.clone(),e.polygons=this.polygons.map((function(e){return e.clone()})),e.front=this.front&&this.front.clone(),e.back=this.back&&this.back.clone(),e},n.Node.prototype.invert=function(){var e,t,r;for(e=0,t=this.polygons.length;e<t;e++)this.polygons[e].flip();return this.divider.flip(),this.front&&this.front.invert(),this.back&&this.back.invert(),r=this.front,this.front=this.back,this.back=r,this},n.Node.prototype.clipPolygons=function(e){var t,r,n,a;if(!this.divider)return e.slice();for(n=[],a=[],t=0,r=e.length;t<r;t++)this.divider.splitPolygon(e[t],n,a,n,a);return this.front&&(n=this.front.clipPolygons(n)),a=this.back?this.back.clipPolygons(a):[],n.concat(a)},n.Node.prototype.clipTo=function(e){this.polygons=e.clipPolygons(this.polygons),this.front&&this.front.clipTo(e),this.back&&this.back.clipTo(e)},n)},function(e,t){const r=/\bvoid\s+main\s*\(\s*\)\s*{/g;function n(e){return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,(function(e,t){let r=THREE.ShaderChunk[t];return r?n(r):e}))}const a=Object.assign||function(){let e=arguments[0];for(let t=1,r=arguments.length;t<r;t++){let r=arguments[t];if(r)for(let t in r)r.hasOwnProperty(t)&&(e[t]=r[t])}return e};let o=0;const i=Date.now(),s=new WeakMap;function l(e,t){return"uniforms"===e?void 0:t}THREE.createDerivedMaterial=function(e,t){const c=function(e){return JSON.stringify(e,l)}(t);let f=s.get(e);if(f||(f=Object.create(null),s.set(e,f)),f[c])return f[c].clone();const d=++o,u="_derivedShaders"+d,p="_onBeforeCompile"+d;let h,v;function m(o){e.onBeforeCompile.call(this,o);const{vertex:s,fragment:l}=this[u]||(this[u]={vertex:{},fragment:{}});if(s.source!==o.vertexShader||l.source!==o.fragmentShader){const e=function({vertexShader:e,fragmentShader:t},a,o){let{vertexDefs:i,vertexTransform:s,vertexMainIntro:l,fragmentDefs:c,fragmentDiffuseTransform:f,fragmentMainIntro:d,fragmentColorTransform:u,timeUniform:p}=a;if(p){const e=`\nuniform float ${p};\n`;i=(i||"")+e,c=(c||"")+e}(i||s||l)&&(s&&(e=n(e),i=`\n        ${i||""}\n        void vertexTransform_${o}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n          ${s}\n        }\n      `,e=e.replace(/\b(position|normal|uv)\b/g,(e,t,r,n)=>/\battribute\s+vec3\s+$/.test(n.substr(0,r))?t:`_${t}_${o}`),l=`\n        vec3 _position_${o} = vec3(position);\n        vec3 _normal_${o} = vec3(normal);\n        vec2 _uv_${o} = vec2(uv);\n        vertexTransform_${o}(_position_${o}, _normal_${o}, _uv_${o});\n        ${l||""}\n      `),e=e.replace(r,`${i||""}\n\n$&\n\n${l||""}`));(c||f||d||u)&&(t=n(t),f&&(c=`\n        ${c||""}\n        void fragmentDiffuseTransform_${o}(inout vec3 diffuse) {\n          ${f}\n        }\n      `,t=t.replace(/\b(diffuse)\b/g,(e,t,r,n)=>/\buniform\s+vec3\s+$/.test(n.substr(0,r))?t:`_${t}_${o}`),d=`\n        vec3 _diffuse_${o} = diffuse;\n        fragmentDiffuseTransform_${o}(_diffuse_${o});\n        ${d||""}\n      `),t=t.replace(r,`\n      ${c||""}\n      void threejsMain_${o}() {\n      ${d||""}\n    `),t+=`\n      void main() {\n        threejsMain_${o}();\n        ${u||""}\n      }\n    `);return{vertexShader:e,fragmentShader:t}}(o,t,d);s.source=o.vertexShader,s.result=e.vertexShader,l.source=o.fragmentShader,l.result=e.fragmentShader}o.vertexShader=s.result,o.fragmentShader=l.result,a(o.uniforms,this.uniforms),t.timeUniform&&(o.uniforms[t.timeUniform]={get value(){return Date.now()-i}}),this[p]&&this[p](o)}function x(){e.constructor.apply(this,arguments),this._listeners=void 0}x.prototype=Object.create(e,{constructor:{value:x},isDerivedMaterial:{value:!0},baseMaterial:{value:e},onBeforeCompile:{get:()=>m,set(e){this[p]=e}},copy:{value:function(t){return e.copy.call(this,t),e.isShaderMaterial||e.isDerivedMaterial||(this.extensions=t.extensions,this.defines=a({},t.defines),this.uniforms=THREE.UniformsUtils.clone(t.uniforms)),this}},getDepthMaterial:{value:function(){let r=this._depthMaterial;return r||(v||(v=createDerivedMaterial(e.isDerivedMaterial?e.getDepthMaterial():new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking}),t),v.defines.IS_DEPTH_MATERIAL=""),r=this._depthMaterial=v.clone()),r}},getDistanceMaterial:{value:function(){let r=this._distanceMaterial;return r||(h||(h=createDerivedMaterial(e.isDerivedMaterial?e.getDistanceMaterial():new THREE.MeshDistanceMaterial,t),h.defines.IS_DISTANCE_MATERIAL=""),r=this._distanceMaterial=h.clone()),r}},dispose:{value(){const{_depthMaterial:t,_distanceMaterial:r}=this;t&&t.dispose(),r&&r.dispose(),e.dispose.call(this)}}});const g=new x;return g.copy(e),g.uniforms=a(THREE.UniformsUtils.clone(e.uniforms||{}),t.uniforms),g.defines=a({},e.defines,t.defines),g.defines.DERIVED_MATERIAL=d,g.extensions=a({},e.extensions,t.extensions),f[c]=g,g.clone()};const c={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};THREE.getShadersForMaterial=function(e){let t=c[e.type];return t?THREE.ShaderLib[t]:e},THREE.getShaderUniformTypes=function(e){let t,r=/\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g,n=Object.create(null);for(;null!==(t=r.exec(e));)n[t[2]]=t[1];return n}},function(e,t){THREE.OrthographicTrackballControls=function(e,t){var r=this,n=-1,a=0,o=1,i=2,s=3,l=4;this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.radius=0,this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.noRoll=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.keys=[65,83,68],this.target=new THREE.Vector3;var c=!0,f=n,d=n,u=new THREE.Vector3,p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector2,m=new THREE.Vector2,x=0,g=0,y=new THREE.Vector2,E=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom;var w={type:"change"},b={type:"start"},T={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}this.radius=.5*Math.min(this.screen.width,this.screen.height),this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom},this.handleEvent=function(e){"function"==typeof this[e.type]&&this[e.type](e)};var _,S,R,A,M,C,L=(_=new THREE.Vector2,function(e,t){return _.set((e-r.screen.left)/r.screen.width,(t-r.screen.top)/r.screen.height),_}),H=function(){var e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(a,o){n.set((a-.5*r.screen.width-r.screen.left)/r.radius,(.5*r.screen.height+r.screen.top-o)/r.radius,0);var i=n.length();return r.noRoll?i<Math.SQRT1_2?n.z=Math.sqrt(1-i*i):n.z=.5/i:i>1?n.normalize():n.z=Math.sqrt(1-i*i),u.copy(r.object.position).sub(r.target),e.copy(r.object.up).setLength(n.y),e.add(t.copy(r.object.up).cross(u).setLength(n.x)),e.add(u.setLength(n.z)),e}}();function P(e){!1!==r.enabled&&(window.removeEventListener("keydown",P),d=f,f===n&&(e.keyCode!==r.keys[a]||r.noRotate?e.keyCode!==r.keys[o]||r.noZoom?e.keyCode!==r.keys[i]||r.noPan||(f=i):f=o:f=a))}function z(e){!1!==r.enabled&&(f=d,window.addEventListener("keydown",P,!1))}function k(e){!1!==r.enabled&&(e.preventDefault(),e.stopPropagation(),f===n&&(f=e.button),f!==a||r.noRotate?f!==o||r.noZoom?f!==i||r.noPan||(y.copy(L(e.pageX,e.pageY)),E.copy(y)):(v.copy(L(e.pageX,e.pageY)),m.copy(v)):(p.copy(H(e.pageX,e.pageY)),h.copy(p)),document.addEventListener("mousemove",N,!1),document.addEventListener("mouseup",D,!1),r.dispatchEvent(b))}function N(e){!1!==r.enabled&&(e.preventDefault(),e.stopPropagation(),f!==a||r.noRotate?f!==o||r.noZoom?f!==i||r.noPan||E.copy(L(e.pageX,e.pageY)):m.copy(L(e.pageX,e.pageY)):h.copy(H(e.pageX,e.pageY)))}function D(e){!1!==r.enabled&&(e.preventDefault(),e.stopPropagation(),f=n,document.removeEventListener("mousemove",N),document.removeEventListener("mouseup",D),r.dispatchEvent(T))}function F(e){if(!1!==r.enabled){e.preventDefault(),e.stopPropagation();var t=0;e.wheelDelta?t=e.wheelDelta/40:e.detail&&(t=-e.detail/3),v.y+=.01*t,r.dispatchEvent(b),r.dispatchEvent(T)}}function I(e){if(!1!==r.enabled){switch(e.touches.length){case 1:f=s,p.copy(H(e.touches[0].pageX,e.touches[0].pageY)),h.copy(p);break;case 2:f=l;var t=e.touches[0].pageX-e.touches[1].pageX,a=e.touches[0].pageY-e.touches[1].pageY;g=x=Math.sqrt(t*t+a*a);var o=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;y.copy(L(o,i)),E.copy(y);break;default:f=n}r.dispatchEvent(b)}}function O(e){if(!1!==r.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:h.copy(H(e.touches[0].pageX,e.touches[0].pageY));break;case 2:var t=e.touches[0].pageX-e.touches[1].pageX,a=e.touches[0].pageY-e.touches[1].pageY;g=Math.sqrt(t*t+a*a);var o=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;E.copy(L(o,i));break;default:f=n}}function U(e){if(!1!==r.enabled){switch(e.touches.length){case 1:h.copy(H(e.touches[0].pageX,e.touches[0].pageY)),p.copy(h);break;case 2:x=g=0;var t=(e.touches[0].pageX+e.touches[1].pageX)/2,a=(e.touches[0].pageY+e.touches[1].pageY)/2;E.copy(L(t,a)),y.copy(E)}f=n,r.dispatchEvent(T)}}function G(e){e.preventDefault()}this.rotateCamera=(S=new THREE.Vector3,R=new THREE.Quaternion,function(){var e=Math.acos(p.dot(h)/p.length()/h.length());e&&(S.crossVectors(p,h).normalize(),e*=r.rotateSpeed,R.setFromAxisAngle(S,-e),u.applyQuaternion(R),r.object.up.applyQuaternion(R),h.applyQuaternion(R),r.staticMoving?p.copy(h):(R.setFromAxisAngle(S,e*(r.dynamicDampingFactor-1)),p.applyQuaternion(R)),c=!0)}),this.zoomCamera=function(){if(f===l){var e=g/x;x=g,r.object.zoom*=e,c=!0}else{e=1+(m.y-v.y)*r.zoomSpeed;Math.abs(e-1)>1e-6&&e>0&&(r.object.zoom/=e,r.staticMoving?v.copy(m):v.y+=(m.y-v.y)*this.dynamicDampingFactor,c=!0)}},this.panCamera=(A=new THREE.Vector2,M=new THREE.Vector3,C=new THREE.Vector3,function(){if(A.copy(E).sub(y),A.lengthSq()){var e=(r.object.right-r.object.left)/r.object.zoom,t=(r.object.top-r.object.bottom)/r.object.zoom;A.x*=e*r.panSpeed,A.y*=t*r.panSpeed,C.copy(u).cross(r.object.up).setLength(A.x),C.add(M.copy(r.object.up).setLength(A.y)),r.object.position.add(C),r.target.add(C),r.staticMoving?y.copy(E):y.add(A.subVectors(E,y).multiplyScalar(r.dynamicDampingFactor)),c=!0}}),this.update=function(){u.subVectors(r.object.position,r.target),r.noRotate||r.rotateCamera(),r.noZoom||(r.zoomCamera(),c&&r.object.updateProjectionMatrix()),r.noPan||r.panCamera(),r.object.position.addVectors(r.target,u),r.object.lookAt(r.target),c&&(r.dispatchEvent(w),c=!1)},this.reset=function(){f=n,d=n,r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.up.copy(r.up0),u.subVectors(r.object.position,r.target),r.object.left=r.left0,r.object.right=r.right0,r.object.top=r.top0,r.object.bottom=r.bottom0,r.object.lookAt(r.target),r.dispatchEvent(w),c=!1},this.disableEvents=function(){this.domElement.removeEventListener("contextmenu",G,!1),this.domElement.removeEventListener("mousedown",k,!1),this.domElement.removeEventListener("wheel",F,!1),this.domElement.removeEventListener("MozMousePixelScroll",F,!1),this.domElement.removeEventListener("touchstart",I,!1),this.domElement.removeEventListener("touchend",U,!1),this.domElement.removeEventListener("touchmove",O,!1),document.removeEventListener("mousemove",N,!1),document.removeEventListener("mouseup",D,!1),window.removeEventListener("keydown",P,!1),window.removeEventListener("keyup",z,!1)},this.dispose=this.disableEvents,this.enableEvents=function(){this.domElement.addEventListener("contextmenu",G,!1),this.domElement.addEventListener("mousedown",k,!1),this.domElement.addEventListener("wheel",F,!1),this.domElement.addEventListener("MozMousePixelScroll",F,!1),this.domElement.addEventListener("touchstart",I,!1),this.domElement.addEventListener("touchend",U,!1),this.domElement.addEventListener("touchmove",O,!1),window.addEventListener("keydown",P,!1),window.addEventListener("keyup",z,!1)},this.enableEvents(),this.handleResize(),this.update()},THREE.OrthographicTrackballControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.OrthographicTrackballControls.prototype.constructor=THREE.OrthographicTrackballControls},function(e,t){e.exports="uniform sampler2D t_pos;\n\nvoid main()\n{\n  vec4 pos = texture2D( t_pos, position.xy );\n  float dist = length(cameraPosition - pos.xyz);\n\n  //gl_PointSize = clamp( 500.0 / dist, 10.0, 50.0 );\n  //gl_PointSize = max( 50.0 * exp(-0.005 * dist), 10.0 );\n  gl_PointSize = max( 20.0 - 0.1 * dist, 5.0 );\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos.xyz, 1.0 );\n}"},function(e,t){e.exports="uniform sampler2D t_particle;\nuniform float curTime;\n\nvoid main()\n{\n  //vec4 col = vec4( 1.0, 0.3, 0.2, 1.0 );    // red flames\n  //vec4 col = vec4( 0.07, 0.09, 0.52, 1.0 );   // blue flames\n  vec4 col = vec4( 1.0 );\n  vec4 tex = texture2D( t_particle, gl_PointCoord );\n  gl_FragColor = vec4( col.rgb*tex.a, col.a*tex.a );\n}\n\n\n// vec4 getFlameColor(vec2 fragCoord)\n// {\n// \tfloat shift = 0.02;\n// \tvec2 speed = vec2(1.5);\n\n// \tconst vec3 c1 = vec3(0.0470588235, 0.0471698113, 0.278431373);\n// \tconst vec3 c2 = vec3(0.854901961, 0.862745098, 0.0150993377);\n// \tconst vec3 c3 = vec3(0.2, 0.0, 0.0);\n// \tconst vec3 c4 = vec3(0.635294118, 0.00392156863, 0.00460732984);\n// \tconst vec3 c5 = vec3(3.1);\n// \tconst vec3 c6 = vec3(1.151);\n\n//   // screen size\n//   // large monitor(4K): 2775 1500\n//   // small monitor(2K): 2066 1101\n//   vec2 screenSize = vec2(2066.0, 1101.0);\n\n// \tvec2 p = fragCoord.xy * 8.0 / screenSize.xx;\n// \tfloat q = fbm(p - curTime * 0.1);\n// \tvec2 r = vec2(fbm(p + q + curTime * speed.x - p.x - p.y), fbm(p + q - curTime * speed.y));\n// \tvec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n// \tfloat grad = fragCoord.y / screenSize.y;\n// \tvec4 color = vec4(c * cos(shift * fragCoord.y / screenSize.y), 1.0);\n// \tcolor.xyz *= 1.0-grad;\n// \treturn color;\n// }\n// void main()\n// {\n//   vec4 texColor = texture( t_particle, gl_PointCoord );//gl_PointCoord\n// \tif( texColor.a < 0.5 ) discard;\n//   //texColor.r += 0.5;\n\n// \tvec3 fragColor = vec3(0.75, 0.5, 0.5);\n//   vec4 flameColor = getFlameColor(gl_FragCoord.xy);//gl_FragCoord.xy\n//   fragColor = mix(fragColor.xyz, flameColor.xyz, 0.8);\n\n//   gl_FragColor = vec4( fragColor, 1.0 );\n// }"},function(e,t){e.exports="uniform sampler2D t_oPos;\nuniform sampler2D t_pos;\nuniform vec2 resolution;\n\nuniform float dTime;\nuniform float curTime;\nuniform vec3 emitPos;       // emitter position (x,y,z)\nuniform vec3 emitVec;       // emit direction and its length (not needed for radialCurl)\nuniform float curlType;     // 0=radialCurl, 1=directionalCurl\nuniform float curlShape;    // shape of curl (0 ~ 1) ==> 0.0(rocketJet), 0.5(smoking), 1.0(floating)\nuniform float curlSpeed;    // moving speed of particles (0 ~ 1)\nuniform float curlSpread;   // level of spread of particles (0 ~ 1)\n\n// in vec2 vUv;\nvarying vec2 vUv;\n\n#ifndef RAYMARCH_SIMPLEX\n#define RAYMARCH_SIMPLEX\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626, // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i = floor(v + dot(v, C.yy) );\n  vec2 x0 = v - i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n}\n\nfloat snoise(vec4 v)\n{\n  const vec4 C = vec4( 0.138196601125011, // (5 - sqrt(5))/20 G4\n                        0.276393202250021, // 2 * G4\n                        0.414589803375032, // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\n// First corner\n  vec4 i = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n// i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxxx\n  // x1 = x0 - i1 + 1.0 * C.xxxx\n  // x2 = x0 - i2 + 2.0 * C.xxxx\n  // x3 = x0 - i3 + 3.0 * C.xxxx\n  // x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0, ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n#endif // RAYMARCH_SIMPLEX\n#ifndef RAYMARCH_CURL\n#define RAYMARCH_CURL\n\nvec3 snoiseVec3( vec3 x )\n{\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p )\n{\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\nvec4 snoiseVec4( vec4 x )\n{\n  float s  = snoise(vec4( x ));\n  float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.w + 47.2 , x.x + 12.2 ));\n  float s2 = snoise(vec4( x.z + 74.2 , x.w - 124.5 , x.x + 99.4 , x.y - 123.2 ));\n  float s3 = snoise(vec4( x.w + 21.2 , x.x - 52.5 , x.y + 60.4 , x.z + 42.2 ));\n  vec4 c = vec4( s , s1 , s2 , s3 );\n  return c;\n}\n\nvec4 curlNoise( vec4 p )\n{\n  const float e = 0.1;\n  vec4 dx = vec4( e   , 0.0 , 0.0 , 0.0 );\n  vec4 dy = vec4( 0.0 , e   , 0.0 , 0.0 );\n  vec4 dz = vec4( 0.0 , 0.0 , e   , 0.0 );\n  vec4 dw = vec4( 0.0 , 0.0 , 0.0 , e  );\n  vec4 p_x0 = snoiseVec4( p - dx );\n  vec4 p_x1 = snoiseVec4( p + dx );\n  vec4 p_y0 = snoiseVec4( p - dy );\n  vec4 p_y1 = snoiseVec4( p + dy );\n  vec4 p_z0 = snoiseVec4( p - dz );\n  vec4 p_z1 = snoiseVec4( p + dz );\n  vec4 p_w0 = snoiseVec4( p - dw );\n  vec4 p_w1 = snoiseVec4( p + dw );\n  float x = p_y1.z - p_y0.z - p_z1.w + p_z0.w + p_w0.y - p_w1.y;\n  float y = p_z1.w - p_z0.w - p_w1.x + p_w0.x + p_x0.z - p_x1.z;\n  float z = p_w1.x - p_w0.x - p_x1.y + p_x0.y + p_y0.w - p_y1.w;\n  float w = p_x1.y - p_x0.y - p_y1.z + p_y0.z + p_z0.x - p_y1.x;\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec4( x , y , z, w ) * divisor );\n}\n\n#endif // RAYMARCH_CURL\n\nfloat rand(vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid radialCurl()\n{\n  //vec3 emitPos = vec3(0.0);\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  //vec4 oPos = texture2D( t_oPos, uv );\n  vec4 pos  = texture2D( t_pos, uv );\n\n  float shape = mix(0.04, 0.01, curlShape);\n  vec3 curl = curlNoise(vec4(pos.xyz * shape, curTime * 1.1 * 2.5)).xyz;\n  float speed = mix(0.5, 2.5, curlSpeed);\n  vec3 vel = curl * speed;\n\n  vec4 newPos;\n  newPos.xyz = pos.xyz + vel;\n  newPos.w = pos.w + dTime; // pos.w = particle's time of life (age)\n\n  if( newPos.w > 10.0 ) // died at 10(secs) old\n  {\n    newPos.xyz = emitPos;\n    float spread = mix(0.1, 200.0, curlSpread);\n    newPos.x += spread*(rand(uv*curTime+0.7)-0.5);\n    newPos.y += spread*(rand(uv*curTime+1.3)-0.5);\n    newPos.z += spread*(rand(uv*curTime+2.7)-0.5);\n    newPos.w = 10.0*rand(uv*curTime+3.9);\n  }\n\n  gl_FragColor = vec4( newPos.xyz, newPos.w );\n}\n\nvoid directionalCurl()\n{\n  float emitLength = length(emitVec);\n  vec3 emitDir = emitVec / emitLength;\n\n  //vec3 curlParams = vec3(0.5, 0.4, 0.0);// <== default\n  float shape = 0.5 * exp( -curlShape * 4.6 );\n  float speed = 0.5 + 5.0 * curlSpeed;\n  float spread = 0.1 + 2.0 * curlSpread;\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  //vec4 oPos = texture2D( t_oPos, uv );\n  vec4 pos  = texture2D( t_pos, uv );\n\n  vec3 curl = curlNoise(vec4(pos.xyz * shape, curTime * 0.5 * speed)).xyz;\n  vec3 vel = curl*0.1;\n\n  float t = dot(emitDir, pos.xyz - emitPos);\n  float v = pow(smoothstep(0.0, emitLength, t), 2.0);\n  v = 0.05 + v * (0.2 + rand(uv) * 0.2);\n  v = clamp(v, 0.01, 5.0);\n  vel += emitDir * v;\n  vel *= speed;\n  vec3 newPos = pos.xyz + vel * dTime*400.0;\n\n  t = dot(emitDir, newPos - emitPos);\n  if( t > emitLength ) {\n    newPos = emitPos;\n    newPos.x += emitLength*spread*(rand(uv + vec2(21.3, 63.21))-0.5);\n    newPos.y += emitLength*spread*(rand(uv + vec2(32.3, 734.21))-0.5);\n    newPos.z += emitLength*spread*(rand(uv + vec2(127.3, 31.21))-0.5);\n\n    t = dot(emitDir, newPos - emitPos);\n    if( t < 0.0 ) { newPos = newPos - t*emitDir; t = 0.0; }\n    vec3 tpos = emitPos + t*emitDir;\n    vec3 rvec = newPos - tpos;\n    float r = (1.0 - cos(smoothstep(0.0, 0.2*emitLength, t) * 3.141592654)) * 0.5;\n    newPos = newPos + (r-1.0) * rvec;\n  }\n\n  gl_FragColor = vec4( newPos, 1.0 );\n}\n\nvoid main()\n{\n  if( curlType < 0.5 )\n    radialCurl();       // curlType = 0.0\n  else\n    directionalCurl();  // curlType = 1.0\n}"},function(e,t){e.exports="precision highp int;\nprecision highp float;\n\nvoid main()\n{\n\tgl_Position = vec4(position, 1.0);\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\n\n//==============================================================================\n// Enables\n//==============================================================================\n\n//#define ENABLE_TEST_RENDER\n\n// Choose...\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n// ENABLE_SPECULAR(o) && ENABLE_REFLECTIONS(o) ==> glossy, mirror\n// ENABLE_SPECULAR(o) && ENABLE_REFLECTIONS(x) ==> glossy only\n// ENABLE_SPECULAR(x) && ENABLE_REFLECTIONS(o) ==> no glossy, no mirror\n// ENABLE_SPECULAR(x) && ENABLE_REFLECTIONS(x) ==> no glossy, no mirror\n#define ENABLE_TRANSPARENCY\n#define ENABLE_DOUBLE_TRANSPARENCY\n#define ENABLE_FOG\n#define ENABLE_BUMP_MAPPING\n//#define ENABLE_SUBSURFACE\t\t// <=== not complete...\n\n// Choose...\n#define ENABLE_SHADOW\n#define ENABLE_AO\n\n// Choose...\n#define ENABLE_SUNDIR_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n//#define ENABLE_POINT_LIGHT_FLARE\n\n// Choose...\n//#define DEMO_REPEAT_SPHERES\n//#define DEMO_PRIMITIVES\n#define DEMO_TEST\n\n#ifdef DEMO_PRIMITIVES\n\t#undef ENABLE_TRANSPARENCY\n\t#undef ENABLE_DOUBLE_TRANSPARENCY\n\t#undef ENABLE_FOG\n\t#undef ENABLE_REFLECTIONS\n\t#undef ENABLE_SPECULAR\n#endif\n\n//==============================================================================\n// constants\n//==============================================================================\n\nconst vec3 SUN_LIGHT = normalize(vec3(0.4, 0.4, -0.48));\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.83);\n\nconst float FAR = 100.0;\nconst float airIOR = 1.0003;\nconst float fogDensity = 0.001;//0.05\n\nconst float kMaterialSky = 0.0;\nconst float kMaterialChecker = 1.0;\nconst float kMaterialGround = 2.0;\nconst float kMaterialGold = 3.0;\nconst float kMaterialSilver = 4.0;\nconst float kMaterialTile = 5.0;\nconst float kMaterialPipe = 6.0;\nconst float kMaterialWater = 7.0;\nconst float kMaterialTexture0 = 11.0;\t// textureMaps[0]\nconst float kMaterialTexture1 = 12.0;\t// textureMaps[1]\nconst float kMaterialTexture2 = 13.0;\t// textureMaps[1]\nconst float kMaterialTexture3 = 14.0;\t// textureMaps[1]\n\nconst vec3 cGold = vec3(1.000, 0.766, 0.336);\nconst vec3 cSilver = vec3(0.972, 0.960, 0.915);\nconst vec3 cCopper = vec3(0.955, 0.637, 0.538);\nconst vec3 cIron = vec3(0.56, 0.57, 0.58);\nconst vec3 cAluminium = vec3(0.913, 0.921, 0.925);\nconst vec3 cChromium = vec3(0.550, 0.556, 0.554);\nconst vec3 cNickel = vec3(0.660, 0.609, 0.526);\nconst vec3 cTitanium = vec3(0.542, 0.497, 0.449);\nconst vec3 cCobalt = vec3(0.662, 0.655, 0.634);\nconst vec3 cPlatinum = vec3(0.672, 0.637, 0.585);\n\n//==============================================================================\n// Data structures\n//==============================================================================\n\nstruct CRay\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat tmin;\n\tfloat tmax;\t// maximum distance of ray\n};\nstruct CHit\n{\n\tvec3 p;\t\t// p = ro + rd * dist\n\tvec3 n;\t\t// surface normal\n\tfloat t;\n\tfloat m;\n\tvec3 refCol; // reflected color\n\tvec3 trmCol; // transmitted color (refraction)\n};\nstruct CMaterial\n{\n\tvec3 albedo;\t\t// diffuse reflectivity\n\tfloat ior;\t\t\t// F0 = ((1-ior)/(1+ior))^2 (where ior = Index of Refraction)\n\tfloat smoothness;\t// Fresnel = F0 + (1.0 - F0) * (1 - cosTheta)^5 * smoothness\n\tfloat transparency; // diffuse*(1-fTransparency) + cTransmission*fTransparency\n};\nstruct CShading\n{\n\tvec3 diffuse;\n\tvec3 specular;\n};\nstruct CPointLight\n{\n\tvec3 pos;\n\tvec3 col;\n};\nstruct CDirLight\n{\n\tvec3 dir;\n\tvec3 col;\n};\n\n//==============================================================================\n// Scene Description\n//==============================================================================\n\n#ifdef DEMO_REPEAT_SPHERES\nvec2 demoRepeatSpheres( in vec3 p )\n{\n\tvec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\n\tvec3 p1 = sRepeat( p, vec3(10.0, 10.0, 10.0) );\n\td = dUnion( d, vec2( fSphere(p1, 2.5), kMaterialSilver ) );//kMaterialTexture0\n\n\treturn d;\n}\n#endif\n\n#ifdef DEMO_PRIMITIVES\nvec2 demoPrimitives(vec3 p)\n{\n    // 21 objects + 1 floor\n    float m = 0.0;\n    vec2 res = dUnion( vec2( fPlane(     p), kMaterialChecker ),\n\t                   vec2( fSphere(    p-vec3( 0.0,0.25, 0.0), 0.25 ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fBox(       p-vec3( 1.0,0.25, 0.0), vec3(0.25) ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( uRoundBox(  p-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus(     p-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), m ) );  m += 1.0;\n    res = dUnion( res, vec2( fCapsule(   p,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTriPrism(  p-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCylinder(  p-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCone(      p-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus82(   p-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus88(   p-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCylinder6( p-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), m ) );  m += 1.0;\n\tres = dUnion( res, vec2( fHexPrism(  p-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fPryamid4(  p-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ), m ) );  m += 1.0;\n    res = dUnion( res, dSubtract( vec2(  uRoundBox(p-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05), m),\n\t                              vec2(  fSphere(p-vec3(-2.0,0.2, 1.0), 0.25), m+1.0) ) ); m += 2.0;\n    res = dUnion( res, dSubtract( vec2(  fTorus82(p-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), m),\n\t                              vec2(  fCylinder(sRepeat(vec3(atan(p.x+2.0,p.z)/6.2831, p.y, 0.02+0.5*length(p-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6)), m+1.0) )); m += 2.0;\n\tres = dUnion( res, vec2( 0.5*fSphere( p-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*p.x)*sin(50.0*p.y)*sin(50.0*p.z), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( 0.5*fTorus(  sTwist(p-vec3(-2.0,0.25,2.0), 10.0), vec2(0.20,0.05)), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fConeSection(p-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fEllipsoid(  p-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), m ) ); m += 1.0;\n    return res;\n}\n#endif\n\n#ifdef DEMO_TEST\nvec2 demoTest( in vec3 p )\n{\n\t// // case 1: static sphere\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// d = dUnion( d, vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialWater ) );\n\n\t// // case 2: smooth union/subtract\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// vec3 tp = sTranslate( p, vec3(0.0, 2.0, 0.0) );\n\t// vec2 dcy1 = vec2( fCylinder(tp, vec2(1.0, 2.0)), kMaterialTexture0);\n\t// vec2 dcy2 = vec2( fCylinder(tp.yzx, vec2(0.5, 2.0)), kMaterialTexture1 );\n\t// d = dUnion( d, dSmoothUnion( dcy1, dcy2, 0.1 ) );\n    // //d = dUnion( d, dSmoothSubtract( dcy1, dcy2, 0.1 ) );\n\n\t// case 3: wriggling ice\n\tvec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\tvec2 sph = vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialTexture3 );\n\tp = rotM3*p*0.12; sph.x += 0.13*sinusoidBumps( p, time*1.1 );\n\tp = rotM3*p*0.57; sph.x -= 0.19*sinusoidBumps( p, time*2.1 );\n\td = dUnion( d, sph );\n\n\t// // case 4: heart\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// vec2 sph = vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialTexture2 );\n\t// p = rotM3*p*0.15; sph.x += 0.23*sinusoidBumps( p, time*0.1 );\n\t// p = rotM3*p*0.15; sph.x -= 0.05*sinusoidBumps( p, time*3.1 );\n\t// d = dUnion( d, sph );\n\n\treturn d;\n}\n#endif\n\nvec2 sceneMap( in vec3 p )\n{\n#if defined (DEMO_REPEAT_SPHERES)\n\treturn demoRepeatSpheres( p );\n\n#elif defined (DEMO_PRIMITIVES)\n\treturn demoPrimitives( p );\n\n#elif defined (DEMO_TEST)\n\treturn demoTest( p );\n\n#endif\n}\n\n//==============================================================================\n// Materials\n//==============================================================================\n\nCMaterial getMaterial( in CHit hit )\n{\n\t// IOR tables\n\t// Acetone 1.36\n\t// Actinolite 1.618\n\t// Agalmatoite 1.550\n\t// Agate 1.544\n\t// Agate, Moss 1.540\n\t// Air 1.0002926 (= 1.0003)\n\t// Alcohol 1.329\n\t// Amber 1.546\n\t// Amethyst 1.544\n\t// Crystal 2.00\n\t// Diamond 2.417\n\t// Emerald 1.576\n\t// Ethanol 1.36\n\t// Ethyl Alcohol 1.36\n\t// Glass 1.51714\n\t// Glass, Albite 1.4890\n\t// Glass, Crown 1.520\n\t// Glass, Crown, Zinc 1.517\n\t// Glass, Flint, Dense 1.66\n\t// Glass, Flint, Heaviest 1.89\n\t// Glass, Flint, Heavy 1.65548\n\t// Glass, Flint, Lanthanum 1.80\n\t// Glass, Flint, Light 1.58038\n\t// Glass, Flint, Medium 1.62725\n\t// Gold 0.47\n\t// Ice 1.309\n\t// Ivory 1.540\n\t// Jade, Nephrite 1.610\n\t// Jadeite 1.665\n\t// Lead 2.01\n\t// Malachite 1.655\n\t// Methanol 1.329\n\t// Moonstone, Albite 1.535\n\t// Nylon 1.53\n\t// Onyx 1.486\n\t// Opal 1.450\n\t// Oxygen (gas) 1.000276\n\t// Oxygen (liq) 1.221\n\t// Pearl 1.530\n\t// Plastic 1.460\n\t// Plexiglas 1.50\n\t// Polystyrene 1.55\n\t// Quartz 1.544\n\t// Quartz, Fused 1.45843\n\t// Rock Salt 1.544\n\t// Rubber, Natural 1.5191\n\t// Ruby 1.760\n\t// Sapphire 1.760\n\t// Silicon 4.24\n\t// Steel 2.50\n\t// Tiger eye 1.544\n\t// Topaz 1.620\n\t// Tourmaline 1.624\n\t// Turpentine 1.472\n\t// Turquoise 1.610\n\t// Water (gas) 1.000261\n\t// Water 35'C (Room temp) 1.33157\n\t// Zirconia, Cubic 2.170\n\n\t// Silver 0.180\n\t// Iron 2.950\n\t// Milk 1.350\n\t// Copper 1.100\n\t// Bronze1.180\n\t// Asphalt 1.635\n\t// Eye,Lens 1.410\n\t// Leather, Stone(Pebbles), Wood, Plaster 1.52\n\n\tCMaterial m;\n\tif(hit.m == kMaterialTexture0)\t\t// textureMaps[0]\n\t{\n\t\tm.albedo = texCube( textureMaps[0], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.52;//Pebbles\n\t\tm.smoothness = 0.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture1)\t\t// textureMaps[1]\n\t{\n\t\tm.albedo = texCube( textureMaps[1], hit.p, hit.n ).rgb;\n\t\tm.ior = 2.50;//Steel\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture2)\t\t// textureMaps[2]\n\t{\n\t\tm.albedo = texCube( textureMaps[2], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.760;//Ruby\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture3)\t\t// textureMaps[3]\n\t{\n\t\tm.albedo = texCube( textureMaps[3], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.309;//Ice\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 1.0;\n\t}\n\telse if(hit.m == kMaterialChecker)\n\t{\n\t\tfloat f = checkerGradBox( 1.0*hit.p.xz );\n\t\tm.albedo = 0.1 + f*vec3(0.8);\n\t\t//m.ior = 1.309;//Ice\n\t\tm.ior = 1.0;//No_reflection\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialGround)\n\t{\n\t\tfloat f = checkerGradBox( 1.0*hit.p.xz );\n\t\tm.albedo = cCopper + 0.1*f*vec3(1.0);\n\t\tm.ior = 1.0;//No_reflection\n\t\tm.smoothness = 0.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialGold)\n\t{\n\t\tm.albedo = cGold;\n\t\tm.ior = 0.47;//Gold\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialSilver)\n\t{\n\t\tm.albedo = cSilver;\n\t\tm.ior = 0.180;//Silver\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTile)\n\t{\n\t\t// Textureless version\n\t\tvec2 vTile = step(vec2(0.15), fract(hit.p.xz));\n\t\tfloat fTile = vTile.x * vTile.y;\n\t\tm.albedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n\t\tm.ior = 2.01;//Lead\n\t\tm.smoothness = m.albedo.r;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialPipe)\n\t{\n\t\tm.albedo = vec3(0.5);\n\t\tm.ior = 2.50;//Steel\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialWater)\n\t{\n\t\tm.ior = 1.3330; // Water at 20'C\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 1.0;\n\t\tfloat fExtinctionScale = 2.0;\n\t\t//vec3 vExtinction = vec3(0.3,0.7,0.9);\n\t\tvec3 vExtinction = vec3(1.0);\n\t\tm.albedo = (vec3(1.0) - vExtinction) * fExtinctionScale;\n\t}\n\telse\n\t{\n\t\tm.albedo = hsl2rgb( vec3(hit.m/7.0, 1.0, 0.5) );\n\t\tm.ior = 1.410;//Eye,Lens\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\treturn m;\n}\n\n//==============================================================================\n// Lights\n//==============================================================================\n\nCPointLight getPointLight()\n{\n\tCPointLight res;\n\tres.pos = vec3(2.0, 4.0, -2.0);\n\tres.col = vec3(1.0, 0.0, 0.0);\n\treturn res;\n}\n\nCDirLight getDirLight()\n{\n\tCDirLight res;\n\tres.dir = vec3(1.0);\n\tres.col = vec3(1.0);\n\treturn res;\n}\n\nCDirLight getSunLight()\n{\n\tCDirLight res;\n\tres.dir = SUN_LIGHT;\n\tres.col = SUN_COLOR;\n\treturn res;\n}\n\nvec3 getSkyGradient( in vec3 rd )\n{\n#if 1\n\tfloat sunAmount = max(dot(rd, SUN_LIGHT), 0.0);\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\n\tvec3 sky = v * SUN_COLOR*vec3(0.4) + vec3(0.18,0.22,0.4);\n\t// wide glare effect...\n\tsky = sky + SUN_COLOR * min(pow(sunAmount, 60.5)*0.32, 0.3);\n\tsky = sky+ SUN_COLOR * min(pow(sunAmount, 1150.0), 0.3)*0.65;\n\treturn sky;\n#else\n\treturn vec3(0.1);\n#endif\n}\n\nvec3 getAmbientLight( in vec3 n )\n{\n\treturn getSkyGradient( n );\n}\n\n//==============================================================================\n// Raymarching\n//==============================================================================\n\nvoid rayMarching( in CRay r, out CHit hit )\n{\n\tvec2 tm = rayMarching( r.o, r.d, r.tmin, FAR );\n\thit.t = tm.x;\n\thit.p = r.o + r.d * hit.t;\n\thit.m = (tm.y == -1.0)? kMaterialSky : tm.y;\n}\n\n//==============================================================================\n// Lighting & Shadow\n//==============================================================================\n\nvoid applyAtmosphere( inout vec3 col, in CRay r, in CHit hit )\n{\n#ifdef ENABLE_FOG\n    float fogAmount = exp(hit.t * -fogDensity);\n    vec3 fogCol = getSkyGradient(r.d);\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n        CDirLight dirLight = getDirLight();\n        float dirDot = clamp(dot(-dirLight.dir, r.d), 0.0, 1.0);\n        fogCol += dirLight.col * pow(dirDot, 10.0);\n    #endif\n    col = mix(fogCol, col, fogAmount);\n#endif\n\n#ifdef ENABLE_POINT_LIGHT_FLARE\n    CPointLight pointLight = getPointLight();\n    vec3 toLight = pointLight.pos - r.o;\n    float pointDot = dot(toLight, r.d);\n    pointDot = clamp(pointDot, 0.0, hit.t);\n    vec3 PointClosest = r.o + r.d * pointDot;\n    float dist = length(PointClosest - pointLight.pos);\n    col += pointLight.col * 0.01/ (dist * dist);\n#endif\n}\n\nfloat Schlick( in vec3 h, in vec3 v, in float ior, in float smoothFactor )\n{\n\tfloat F0 = pow( (airIOR - ior)/(airIOR + ior), 2.0 ); // airIOR = 1.0003\n\tfloat dotHV = dot(h, v); // H o V\n    return F0 + (1.0 - F0) * pow(saturate(1.0 - dotHV), 5.0) * smoothFactor;// fresnel = F0 + (1.0 - F0) * (1 - cosTheta)^5 * smoothFactor\n}\n\nvec3 getFresnelColor( in vec3 diffuse, in vec3 specular, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = reflect(rd, n); // R = reflect(-V, N)\n\tvec3 h = normalize(ld - rd); // H = L + V\n\t//float F = Schlick(h, -rd, m.ior, m.smoothness * 0.9 + 0.1);\n\tfloat F = Schlick(h, -rd, m.ior, m.smoothness);\n\treturn mix(diffuse, specular, F); // return (Ld*Md) * (1-F) + Ls * (F)\n}\n\nfloat getSpecularIntensity( in vec3 rd, in vec3 ld, in vec3 n, in float smoothness )\n// ld = surface to light position\n{          \n\tvec3 h = normalize(ld - rd);  // H = L + V\n\tfloat dotNH = max(0.0, dot(n, h));      // NoH = N o H\n\tfloat specPower = exp2(4.0 + 6.0 * smoothness);   // smoothness ==> specPower (= shininess)\n\tfloat specIntensity = (specPower + 2.0) * 0.125; // specPower ==> specIntensity (= specIntensity)\n\treturn pow(dotNH, specPower) * specIntensity;   // specWt = specIntensity * NoH^(shininess)\n}\n\nCShading getPointLighting( in CPointLight light, in vec3 p, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = normalize(light.pos - p);\n\tfloat tmin = 0.01 / abs(dot(ld, n));\n\tfloat tmax = length(light.pos - p);\n\t#ifdef ENABLE_SHADOW\n\t\tfloat shadow = sceneShadow( p, ld, tmin, tmax, 32.0 );\n\t#else\n\t\tfloat shadow = 1.0;\n\t#endif\n\n\tCShading shading;\n\tfloat atten = 1.0 / (tmax * tmax); // atten = 1/(d*d)\n\n\tvec3 inLight = light.col * (shadow*atten) * max(0.0, dot(ld, n)); // Ld = shadow * atten * Lc * NoL\n\tshading.diffuse = inLight;\n\tshading.specular = getSpecularIntensity( rd, ld, n, m.smoothness ) * inLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nCShading getDirectionalLighting( in CDirLight light, in vec3 p, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = light.dir;\n\tfloat tmin = 0.01 / abs(dot(ld, n));\n\tfloat tmax = FAR*0.5;\n\t#ifdef ENABLE_SHADOW\n\t\tfloat shadow = sceneShadow( p, ld, tmin, tmax, 32.0 );\n\t#else\n\t\tfloat shadow = 1.0;\n\t#endif\n\n\tCShading shading;\n\tvec3 inLight = light.col * (shadow) * max(0.0, dot(ld, n)); // Ld = shadow * Lc * NoL\n\tshading.diffuse = inLight;\n\tshading.specular = getSpecularIntensity( rd, ld, n, m.smoothness ) * inLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nfloat getSubSurfScattering( in vec3 p, in vec3 rd )\n// subsurface scattering\n{\n\tfloat SSS_K = 1.5;\n\tfloat SSS_DELTA = 0.3;\n\tconst int SSS_N = 5;\n\tfloat sum = 0.0;\n\tfloat weight = -0.5;\n\tfloat delta = SSS_DELTA;\n\tfor(int i = 0; i < SSS_N; i++)\n\t{\n\t\tsum += weight * min( 0.0, sceneMap(p + delta*rd).x );\n\t\tdelta += delta;\n\t\tweight *= 0.5;\n\t}\n\treturn clamp( float(SSS_K)*sum, 0.0, 1.0 );\n}\n\nvec3 getPhongShading( in CRay r, in CHit hit, in CMaterial m )\n// r = 1st ray (incident)\n{\n\t#ifdef ENABLE_BUMP_MAPPING\n\t\tif( hit.m == kMaterialTexture0 )\n\t\t\thit.n = getBumpNormal(textureMaps[0], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture1 )\n\t\t\thit.n = getBumpNormal(textureMaps[1], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture2 )\n\t\t\thit.n = getBumpNormal(textureMaps[2], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture3 )\n\t\t\thit.n = getBumpNormal(textureMaps[3], hit.p, hit.n, 0.075);\n\t#endif\n\n\tvec3 sceneCol;\n\tCShading shading;\n\tshading.diffuse = vec3(0.0);  // totalLd = 0.0\n\tshading.specular = vec3(0.0); // totalLs = 0.0\n\n\t#ifdef ENABLE_AO\n\t\tfloat ao = sceneAO(hit.p, hit.n);\n\t#else\n\t\tfloat ao = 1.0;\n\t#endif\n\n\t// reflection color added to specular term\n\tvec3 ambientLight = getAmbientLight(hit.n);\n\tshading.diffuse += ambientLight * ao;\n\tshading.specular += hit.refCol;\n\n\t#ifdef ENABLE_SUNDIR_LIGHT\n\t\tCDirLight sunLight = getSunLight();\n\t\tCShading sunShading = getDirectionalLighting(sunLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += sunShading.diffuse * ao;\n\t\tshading.specular += sunShading.specular;\n\t#endif\n\n\t#ifdef ENABLE_DIRECTIONAL_LIGHT\n\t\tCDirLight dirLight = getDirLight();\n\t\tCShading dirShading = getDirectionalLighting(dirLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += dirShading.diffuse * ao;\n\t\tshading.specular += dirShading.specular;\n\t#endif\n\n\t#ifdef ENABLE_POINT_LIGHT\n\t\tCPointLight pointLight = getPointLight();\n\t\tCShading pointShading = getPointLighting(pointLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += pointShading.diffuse * ao;\n\t\tshading.specular += pointShading.specular;\n\t#endif\n\n\tvec3 diffuseReflected = shading.diffuse * m.albedo;\n\tdiffuseReflected = mix(diffuseReflected, hit.trmCol, m.transparency);\n\t#ifdef ENABLE_SPECULAR\n\t\tsceneCol = getFresnelColor(diffuseReflected, shading.specular, hit.n, r.d, m);\n\t#else\n\t\tsceneCol = diffuseReflected;\n\t#endif\n\n\t#ifdef ENABLE_SUBSURFACE\n\t\tfloat sss = getSubSurfScattering( hit.p, r.d );\n\t\tsceneCol *= (1.0 - sss);\n\t#endif\n\n\treturn sceneCol;\n}\n\nvec3 getSceneColor2( in CRay r );\n\nvec3 getReflection( in CRay r, in CHit hit )\n// r = 1st ray (incident)\n{\n#if defined (ENABLE_SPECULAR) && defined (ENABLE_REFLECTIONS)\n    float separation = 0.01;\n    CRay re; // 2nd ray (reflected)\n    re.d = reflect(r.d, hit.n);\n    re.o = hit.p;\n\tre.tmin = separation / abs(dot(re.d, hit.n));\n    re.tmax = FAR*0.5;\n    return getSceneColor2(re);\n#else\n    return getSkyGradient(reflect(r.d, hit.n));                              \n#endif\n}\n\nvec3 getTransmission( in CRay r, in CHit hit, in CMaterial m )\n// r = 1st ray (incident)\n{\n\t#ifdef ENABLE_TRANSPARENCY\n\t{\n\t\t// Trace until outside transparent object\n\t\tfloat separation = 0.01;\n\t\tCRay ra;\n\t\tra.d = refract(r.d, hit.n, airIOR/m.ior);\n\t\tra.o = hit.p;\n\t\tra.tmin = separation / abs(dot(ra.d, hit.n));\n\t\tra.tmax = FAR*0.5;\n\n\t\t#ifdef ENABLE_DOUBLE_TRANSPARENCY\n\t\t\tCHit hit2;\n\t\t\trayMarching(ra, hit2);\n\t\t\tvec3 n = sceneNormal(hit2.p);\n\n\t\t\tCRay ra2;\n\t\t\tra2.d = refract(ra.d, n, m.ior/airIOR);\n\t\t\tra2.o = hit2.p;\n\t\t\tra2.tmin = separation / abs(dot(ra2.d, n));\n\t\t\tra2.tmax = FAR*0.5;\n\t\t\t\n\t\t\tfloat extinctionDist = hit2.t;\n\t\t\tvec3 sceneCol = getSceneColor2(ra2);\n\t\t#else\n\t\t\tfloat extinctionDist = 0.5;\n\t\t\tvec3 sceneCol = getSceneColor2(ra);\n\t\t#endif\n\n\t\tvec3 extinctionCol = m.albedo;\n\t\t// extinction should really be exp(-) but this is a nice hack to get RGB\n\t\textinctionCol = (1.0 / (1.0 + (extinctionCol * extinctionDist)));\n\t\treturn sceneCol * extinctionCol;\n\t}\n\t#else\n        return getSkyGradient(reflect(r.d, hit.n));\n    #endif\n}\n\nvec3 getSceneColor2( in CRay r )\n// no reflections, no transparency\n// r = secondary rays\n{\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\tsceneCol = getSkyGradient(r.d);\n\t}\n\telse\n\t{\n\t\thit.n = sceneNormal(hit.p);\n\t\tCMaterial m = getMaterial(hit);\n\n\t\t// use sky gradient instead of reflection\n\t\thit.refCol = getSkyGradient(reflect(r.d, hit.n));\n\t\tm.transparency = 0.0;\n\n\t\tsceneCol = getPhongShading(r, hit, m);\n\t}\n\n\tapplyAtmosphere(sceneCol, r, hit);\n\treturn sceneCol;\n}\n\nvec3 getSceneColourTestVersion( in CRay r )\n{\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\tsceneCol = getSkyGradient(r.d);\n\t}\n\telse\n    {\n\t\thit.n = sceneNormal(hit.p);\n\n\t\t#ifdef ENABLE_AO\n\t\t\tfloat ao = sceneAO(hit.p, hit.n);\n\t\t#else\n\t\t\tfloat ao = 1.0;\n\t\t#endif\n\n\t\t#ifdef ENABLE_SHADOW\n\t\t\tfloat shadow = sceneShadow(hit.p, SUN_LIGHT);\n\t\t#else\n\t\t\tfloat shadow = 1.0;\n\t\t#endif\n\n\t\t//vec3 ambientLight = getAmbientLight(hit.n);\n\n\t\tCMaterial m = getMaterial(hit);\n\t\tsceneCol = getPhongShading( m.albedo, 32.0, SUN_LIGHT, SUN_COLOR, hit.p, hit.n, r.d );\n\t\tsceneCol *= (shadow * ao);\n    }\n\treturn sceneCol;\n}\n\nvec3 getSceneColor( in CRay r )\n{\n#ifdef ENABLE_TEST_RENDER\n\treturn getSceneColourTestVersion( r );\n#endif\n\n\t// step 1: geometric intersection\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\t// no hit\n\t\tsceneCol = getSkyGradient(r.d);\n\t\tgl_FragDepth = 0.99;\n\t}\n\telse\n\t{\n\t\t// step 2: normal\n\t\thit.n = sceneNormal(hit.p);\n\n\t\t// step 3: material\n\t\tCMaterial m = getMaterial(hit);\n\n\t\t// step 4.1: 2nd ray (reflected)\n\t\thit.refCol = getReflection(r, hit);\n\n\t\t// step 4.2: 2nd ray (transmitted)\n\t\thit.trmCol = (m.transparency > 0.0)? getTransmission(r, hit, m) : vec3(0.0);\n\n\t\t// step 4.3: 1st ray (incident)\n\t\tsceneCol = getPhongShading(r, hit, m);\n\n\t\tgl_FragDepth = getFragDepth( hit.p );\n\t}\n\n\t// step 5: fog...\n\tapplyAtmosphere(sceneCol, r, hit);\n\treturn sceneCol;\n}\n\nvoid applyPostEffects( inout vec3 col )\n{\n\t// tonemap\n\tcol = (1.0 - exp(-col * 1.5)) * 1.0024; // fExposure = 1.5\n\n\t// gamma correction\n\tcol = pow( col, vec3(0.4545) );\n}\n\n//==============================================================================\n// Main\n//==============================================================================\n\nvoid main()\n{\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\n\n\tCRay r;\n\tr.o = ro;\n\tr.d = rd;\n\n#if defined (DEMO_REPEAT_SPHERES)\n\tr.tmin = 0.0;\n\tr.tmax = FAR;\n#elif defined (DEMO_PRIMITIVES)\n\tr.tmin = 0.0;\n\tr.tmax = 20.0;\n#endif\n\n\tvec3 col = getSceneColor( r );\n\tapplyPostEffects( col );\n\tgl_FragColor = vec4( col, 1.0 );\n}"},function(e,t){e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n#define texChannel0 textureMaps[0]\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_SCENE_REPEAT\r\n#define ENABLE_REFLECT_PASS\r\n\r\n// Choose...\r\n#define ENABLE_PHONG_SHADING\r\n//#define ENABLE_COOK_SHADING\r\n\r\nconst vec3 lightCol = vec3(1.0, 0.97, 0.92) * 5.0;\r\n\r\nvec2 sceneMap( vec3 p )\r\n{\r\n#ifdef ENABLE_SCENE_REPEAT\r\n    p = mod(p, 1.0) - 0.5;\r\n#endif\r\n\r\n    //float d0 = fRoundBox(p, vec3(0.225,0.225,0.225), 0.1);// 0.1=radius (0.0=box, 0.5=sphere)\r\n    //float d0 = fSphere(p, 0.25);\r\n    float d0 = fBox(p, vec3(0.22, 0.22, 0.22));\r\n\r\n    // float displace = 0.015*texture(texChannel0,(p.xy*p.xz)*2.0).x;\r\n    // d0 -= displace;\r\n\r\n    d0 = d0 - 0.2*fSinusoidalPlasma(p*2.0) + 0.1*fSinusoidalPlasma(p*4.0) - 0.05*fSinusoidalPlasma(p*8.0);\r\n    \r\n    return vec2(d0, 0.0);\r\n}\r\n\r\nvec3 getLighting( vec3 p, vec3 n, vec3 ld, vec3 rd, int reflectPass )\r\n{\r\n    // base color\r\n    vec3 col = vec3(1.0);\r\n    #ifdef ENABLE_SCENE_REPEAT\r\n        vec3 voxPos = mod( p*0.5, 1.0 );\r\n        vec3 spectumColor = vec3( sin(voxPos.x*7.0), 0.8*sin(voxPos.y*8.), 0.4*sin(voxPos.z*4.0) );\r\n        if( (voxPos.x < 0.5) && (voxPos.z < 0.5) ) col = vec3(1.0, 0.85, 0.5) * (0.85 + 0.3*spectumColor);\r\n        else if( (voxPos.x >= 0.5) && (voxPos.z >= 0.5) ) col = vec3(1.0, 0.85, 0.5) * (0.85 + 0.3*spectumColor);\r\n    #endif\r\n\r\n    // texture color\r\n    col *= texCube(texChannel0, p, n, 4.0).xyz;\r\n\r\n    // bump normal\r\n    if( reflectPass == 0 ) n = getBumpNormal(texChannel0, p, n, 0.0075);\r\n\r\n    // shadow & ao\r\n    float shadow = (reflectPass == 0)? sceneShadow( p, ld ) : 1.0;\r\n    float ao = sceneAO(p, n);\r\n\r\n    // shading...\r\n    #if defined (ENABLE_PHONG_SHADING)\r\n        float shininess = 64.0;\r\n        return getPhongShading( col, shininess, ld, lightCol, p, n, rd ) * (shadow * ao);\r\n\r\n    #elif defined (ENABLE_COOK_SHADING)\r\n        float metallic = 0.1;\r\n        float roughness = 0.1;\r\n        return getCookShading( col, metallic, roughness, ld, lightCol*2.0, n, rd ) * (shadow * ao);\r\n\r\n    #endif\r\n}\r\n\r\nvec4 getSceneColor( vec3 ro, vec3 rd, float tmin, float tmax )\r\n{\r\n    //----------------------------------------------------\r\n    // step 1: primary scene color: direct lighting pass\r\n    //----------------------------------------------------\r\n\r\n    gl_FragDepth = 0.99;\r\n\r\n    // intersection\r\n\tfloat t = rayTracing( ro, rd, tmin, tmax, 0.75 );\r\n\tif( t > tmax ) return vec4(vec3(0.0), 1.0);\r\n\r\n    // hitted\r\n\tvec3 p = ro + rd * t;\r\n    vec3 n = sceneNormal( p, 0.2 );\r\n\r\n    // light\r\n    vec3 lp = vec3(ro.x, ro.y + 1.0, ro.z);\r\n    vec3 ld = normalize(lp - p);\r\n\r\n\tvec3 sceneColor = getLighting( p, n, ld, rd, 0 ); // 0 = reflectPass ==> shadow will be computed\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    //----------------------------------------------------\r\n    // step 2: secondary scene color: reflection pass\r\n    //----------------------------------------------------\r\n    #ifdef ENABLE_REFLECT_PASS\r\n        vec3 r = reflect(rd, n);\r\n        t = rayTracing(p, r, 0.005, tmax, 0.75 ); // 0.005 (recommended: distance per one pixel)\r\n        if( t < tmax ) {\r\n            float refCoef = 0.35;\r\n            p += r * t;\r\n            n = sceneNormal( p, 0.2 );\r\n            sceneColor += getLighting( p, n, ld, r, 1 ) * refCoef; // 1 = reflectPass ==> shadow will be computed\r\n        }\r\n    #endif\r\n\r\n\treturn vec4( saturate(sceneColor), 1.0 );\r\n}\r\n\r\nmat2 rotMatrix( float angle )\r\n{\r\n\tfloat c = cos( angle );\r\n\tfloat s = sin( angle );\t\r\n\treturn mat2( c, s, -s, c );\r\n}\r\nvoid setCamera( out vec3 ro, out vec3 rd )\r\n{\r\n    vec2 aspect = vec2(resolution.x/ resolution.y, 1.0);\r\n\tvec2 screenPos = (2.0*gl_FragCoord.xy / resolution.xy - 1.0) * aspect;\r\n\r\n\tfloat rad = 0.5;\r\n\tvec3 lookAt = vec3( 0.5,                       5.8*rad*cos(time*0.125), time       );\r\n\tvec3 camPos = vec3( 0.5+1.4*rad*sin(time*0.5), 5.8*rad*cos(time*0.125), -1.0 + time);\r\n\r\n    vec3 forward = normalize(lookAt - camPos);\r\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\r\n    vec3 up = normalize(cross(forward, right));\r\n    float FOV = 0.5;\r\n    ro = camPos;\r\n    rd = normalize(forward + FOV*screenPos.x*right + FOV*screenPos.y*up);\r\n\r\n    //rd.xz *= rotMatrix( PI*sin(-time*0.125)/2.0  ); // rotY ==> yawing sinusoidally (not frequently)\r\n\trd.yz *= rotMatrix( PI*sin(-time*0.125)/6.0 ); // rotX ==> pitching (like nodding) sinusoidally\r\n\trd.xy *= rotMatrix( PI*sin(-time*0.5)/4.0 );   // rotZ ==> rolling (like car wipers) sinusoidally\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    setCamera( ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n\tfloat NEAR = 0.0;\r\n\tfloat FAR = 16.0;\r\n    gl_FragColor = getSceneColor( ro, rd, NEAR, FAR );\r\n}'},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\nconst float eps = 0.01;\r\nconst float OFFSET = eps * 2.0;//100.0;\r\nconst int STEPS = 64;\r\n\r\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\r\n\r\nfloat random(vec2 p) { return fract(sin(mod(dot(p.xy, vec2(12.9898, 78.233)), 3.14))*43758.5453123); }\r\n\r\n// distance functions\r\nvec3 opRep( vec3 p, float interval )\r\n{\r\n    vec2 q = mod( p.xz, interval ) - interval * 0.5;\r\n    return vec3( q.x, p.y, q.y );\r\n\r\n    // vec3 r = vec3(interval);\r\n    // return mod( p, r ) - 0.5 * r;\r\n}\r\n\r\nfloat sphereDist( vec3 p, float r )\r\n{\r\n    return length( opRep( p, 3.5*r ) ) - r;\r\n}\r\n\r\nfloat floorDist( vec3 p )\r\n// floor.y = -1.0\r\n{\r\n    return dot(p, vec3( 0.0, 1.0, 0.0 ) ) + 1.0;\r\n}\r\n\r\nvec4 minVec4( vec4 a, vec4 b )\r\n{\r\n    return ( a.a < b.a ) ? a : b;\r\n}\r\n\r\nfloat checkerPattern( vec3 p )\r\n{\r\n    float u = 1.0 - floor( mod( p.x, 2.0 ) );\r\n    float v = 1.0 - floor( mod( p.z, 2.0 ) );\r\n\r\n    if ( ( u == 1.0 && v < 1.0 ) || ( u < 1.0 && v == 1.0 ) )\r\n        return 0.5;\r\n    else\r\n        return 1.0;\r\n}\r\n\r\nvec3 hsv2rgb( vec3 c )\r\n{\r\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\r\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\r\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\r\n}\r\n\r\nfloat sceneDist( vec3 p )\r\n{\r\n    float radius = 1.0;// + 0.2*sin(time*0.8);\r\n\r\n    vec3 p1 = p;\r\n    p1.y += cos(p.z + time*1.2) * sin(p.x + time*1.5);\r\n\r\n    vec3 p2 = p;\r\n    p2.y += cos(time) * sin(time);\r\n\r\n    return min( sphereDist( p1, radius ), floorDist( p2 ) );\r\n}\r\n\r\nvec3 sceneColor( vec3 p )\r\n{\r\n    float radius = 1.0;\r\n    vec3 sphereColor = hsv2rgb( vec3( (p.z + p.x)/9.0, 1.0, 1.0) );\r\n    vec3 checkerColor = vec3(0.5) * checkerPattern( p );\r\n\r\n    float d1 = sphereDist( p, radius );\r\n    float d2 = floorDist( p );\r\n    return mix( sphereColor, checkerColor, float(d1 > d2) );\r\n\r\n    // return minVec4(\r\n    //     // 3 * 6 / 2 = 9\r\n    //     vec4( sphereColor, sphereDist( p, radius ) ),\r\n    //     vec4( checkerColor, floorDist( p ) )\r\n    // );\r\n}\r\n\r\n// vec3 getNormal( vec3 p )\r\n// {\r\n//     return normalize(vec3(\r\n//         sceneDist(p + vec3( eps, 0.0, 0.0 ) ) - sceneDist(p + vec3( -eps, 0.0, 0.0 ) ),\r\n//         sceneDist(p + vec3( 0.0, eps, 0.0 ) ) - sceneDist(p + vec3( 0.0, -eps, 0.0 ) ),\r\n//         sceneDist(p + vec3( 0.0, 0.0, eps ) ) - sceneDist(p + vec3( 0.0, 0.0, -eps ) )\r\n//     ));\r\n// }\r\nvec3 getNormal( vec3 pos, float eps )\r\n{\r\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\r\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\r\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\r\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\r\n    return normalize( v1 * sceneDist( pos + v1*eps ) +\r\n        v2 * sceneDist( pos + v2*eps ) +\r\n        v3 * sceneDist( pos + v3*eps ) +\r\n        v4 * sceneDist( pos + v4*eps ) );\r\n}\r\nvec3 getNormal(vec3 pos)\r\n{\r\n    return getNormal(pos, 0.002);\r\n}\r\n\r\nfloat getShadow( vec3 ro, vec3 rd )\r\n{\r\n    float h = 0.0;\r\n    float c = 0.0;\r\n    float r = 1.0;\r\n    float shadowCoef = 0.5;\r\n\r\n    for ( float t = 0.0; t < 50.0; t++ )\r\n    {\r\n        h = sceneDist( ro + rd * c );\r\n        if ( h < eps ) return shadowCoef;\r\n\r\n        r = min( r, h * 16.0 / c );\r\n        c += h;\r\n    }\r\n\r\n    return 1.0 - shadowCoef + r * shadowCoef;\r\n}\r\n\r\nvec3 getRayColor( vec3 ro, vec3 rd, out vec3 pos, out vec3 normal, out bool hit )\r\n{\r\n    // marching loop\r\n    float dist;\r\n    float depth = 0.0;\r\n    pos = ro;\r\n\r\n    for ( int i = 0; i < STEPS; i++ )\r\n    {\r\n        dist = sceneDist( pos );\r\n        depth += dist;\r\n        pos = ro + depth * rd;\r\n        if ( abs(dist) < eps ) break;\r\n    }\r\n\r\n    // hit check and calc color\r\n    vec3 color = vec3( 0.0 );\r\n    if ( abs(dist) < eps )\r\n    {\r\n        normal = getNormal( pos );\r\n        float diffuse = clamp( dot( lightDir, normal ), 0.1, 1.0 );\r\n        float specular = pow( clamp( dot( reflect( lightDir, normal ), rd ), 0.0, 1.0 ), 10.0 );\r\n        float shadow = getShadow( pos + normal * OFFSET, lightDir );\r\n        color = ( sceneColor( pos ) * diffuse + vec3( 0.8 ) * specular ) * max( 0.5, shadow );\r\n        hit = true;\r\n    }\r\n\r\n    // attenuation\r\n    //return color - pow( clamp( 0.05 * depth, 0.0, 0.6 ), 2.0 );\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    vec3 color = vec3( 0.0 );\r\n    vec3 pos, normal;\r\n    bool hit;\r\n    float alpha = 1.0;\r\n\r\n    for( int i = 0; i < 3; i++ )\r\n    {\r\n        color += alpha * getRayColor( ro, rd, pos, normal, hit );\r\n\r\n        // compute fragDepth at the 1st hit...\r\n        if( i == 0 && hit ) gl_FragDepth = getFragDepth( pos );\r\n\r\n        // create a new ray for another hit...\r\n        alpha *= 0.3;\r\n        rd = normalize( reflect( rd, normal ) );\r\n        ro = pos + normal * OFFSET; // if OFFSET = 0.0, ray does not start...\r\n\r\n        if( !hit ) {\r\n            gl_FragDepth = 1.0; // fragment will be killed\r\n            break;\r\n        }\r\n    }\r\n\r\n    gl_FragColor = vec4( color, 1.0 );\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\n\n//#define ENABLE_TEST_RENDER\n\n#ifdef LOW_QUALITY\n\t#define kRaymarchMaxIter 16\n#else\n\t#define kRaymarchMaxIter 32\n\t#define ENABLE_AMBIENT_OCCLUSION\n\t#define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#ifdef ENABLE_HARD_SHADOWS\n\t#undef ENABLE_SOFT_SHADOWS\n#else\n\t#define ENABLE_SOFT_SHADOWS\n#endif\n\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n#define ENABLE_TRANSPARENCY\n#define ENABLE_FOG\n#define ENABLE_TEXTURE\t\t\t//psk: now not working\n\n#define ENABLE_DIRECTIONAL_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_POINT_LIGHT_FLARE\n\nconst float kFarClip = 100.0;\nconst float kRaymarchEpsilon = 0.001;\t//0.01\nconst float kFogDensity = 0.005;\t\t//0.05\nconst float kPI = 3.141592654;\nconst float kTwoPI = kPI * 2.0;\nconst float kTranspNo = -1.0;\nconst float kTranspYes = 1.0;\nconst float kTranspInverse = 0.0;\n\nconst float kMaterialGround = 1.0;\t\t// sky=0.0\nconst float kMaterialGold = 2.0;\nconst float kMaterialSilver = 3.0;\nconst float kMaterialWall = 4.0;\nconst float kMaterialPipe = 5.0;\nconst float kMaterialWater = 6.0;\nconst float kMaterialTexture0 = 7.0;\t// textureMaps[0]\nconst float kMaterialTexture1 = 8.0;\t// textureMaps[1]\n\nstruct CRay\n{\n\tvec3 vOrigin;\n\tvec3 vDir;\n\tfloat fStartDist;\n\tfloat fLength;\t// maximum distance of ray\n};\nstruct CHitInfo\n{\n\tvec3 vPos;\t\t// vPos = ro + rd * fDist\n\tfloat fDist;\n\tvec3 vObjectID;\t// x=ID, yz=??(tex_uv)\n}; \nstruct CSurface\n{\n\tvec3 vNormal;\n\tvec3 cReflection;\t// reflected color\n\tvec3 cTransmission;\t// transmitted color (refraction)\n};\nstruct CMaterial\n{\n\tvec3 cAlbedo;\t\t// diffuse reflectivity (= cTexture * cTexture)\n\tfloat fR0;\t\t\t// reflection coeff for light incoming parallel to the normal (= [(n1-n2)/(n1+n2)]^2 )\n\tfloat fSmoothness;\t// related to alpha for (n*h)^alpha\n\tvec2 vParam;\n\tfloat fTransparency;\n\tfloat fRefractIndex;\t// defined as n1/n2 (where n1=come, n2=go)\n\t// cf: n(Air) = 1.0003, n(Water)=1.333, n(common Glass)=1.52, n(Diamond)=2.42\n\t// n(Aluminium/Al)=1.0972, n(Copper/Cu)=0.46090, n(Iron/Fe)=2.9304\n\t// n(Gold/Au)=0.27049, n(Silver/Ag)=0.15016, n(Titanium/Ti)=2.6112, n(Lead/Pb)=2.6\n};\nstruct CShading\n{\n\tvec3 cDiffuse;\n\tvec3 cSpecular;\n};\nstruct CPointLight\n{\n\tvec3 vPos;\n\tvec3 cCol;\n};\nstruct CDirectionalLight\n{\n\tvec3 vDir;\n\tvec3 cCol;\n};\n\n//----------------------------------------------------------------------------\n// primitives\n//----------------------------------------------------------------------------\nfloat fSphere( vec3 p, float r )\n// r = radius\n{\n\treturn length(p) - r;\n}\nfloat fEllipsoid( in vec3 p, in vec3 r )\n{\n\treturn (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat fBox( vec3 p, vec3 b )\n// b.x =half of width (along x-axis)\n// b.y = halft of height (along y-axis)\n// b.z = half of depth (along z-axis)\n{\n\tvec3 d = abs(p) - b;\n\treturn min( max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\nfloat fTorus( vec3 p, vec2 t )\t\t// t=(major radius, minor radius)\n// p.xyz : rotating the circle around the y-axis\n// p.yzx : rotating the circle around the z-axis\n// p.zxy : rotating the circle around the x-axis\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\t// zaxis = major axis of rotation\n\treturn length(q) - t.y;\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat fTorus82( vec3 p, vec2 t )\t// similar to fTorus\n{\n\tvec2 q = vec2(length2(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\nfloat fTorus88( vec3 p, vec2 t )\t// similar to fTorus\n{\n\tvec2 q = vec2(length8(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\nfloat fCylinder( vec3 p, vec2 h )\n// p = pos relative to center point\n// h.x = radius, h.y = half of height\n{\n\tvec2 d = abs( vec2( length(p.xz), p.y ) ) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat fCone( in vec3 p, in vec3 c )\n// p = pos relative to apex\n// c.xy = normal to cone surface (cf: if c.x>c.y, more steeper cone)\n// c.z = height downward from apex\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -q.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), q.y );\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\nfloat fConeSection( in vec3 p, in float h, in float r1, in float r2 )\t// h=height, r1=base_radius, r2=top_radius\n// p = pos relative to base center\n// h = half of height\n// r1 = base radius, r2 = top radius\n{\n\tfloat d1 = -p.y - h;\n\tfloat q = p.y - h;\n\tfloat si = 0.5*(r1-r2)/h;\n\tfloat d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\nfloat fTriPrism( vec3 p, vec2 h )\n// rect-face is parallel to ground & tri-face is normal to ground\n// h.x = side length of triangle\n// h.y = height of prism (along z-axis)\n{\n\tvec3 q = abs(p);\n\treturn max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat fHexPrism( vec3 p, vec2 h )\n// h.x = radius of the inscribed circle of hex\n// h.y = half of height (along z-axis)\n{\n\tvec3 q = abs(p);\n#if 0\n\treturn max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n\tfloat d1 = q.z-h.y;\n\tfloat d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n#endif\n}\n\nfloat fCapsule( vec3 p, vec3 a, vec3 b, float r )\n// a = start point, b = end point\n// r = radius of both ends\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat fPlane( vec3 p, vec3 n )\n// p = pos relative to (0,0,0)\n// n = unit normal\n{\n\treturn dot(n, p);\n}\n\n//----------------------------------------------------------------------------\n// (function-level) operations (real-valued function: f=(dist to surface))\n//----------------------------------------------------------------------------\nfloat fUnion( const in float f1, const in float f2 )\n{\n\treturn mix(f1, f2, step(f2, f1));\n}\nfloat fIntersect( const in float f1, const in float f2 )\n{\n\treturn mix(f2, f1, step(f2, f1));\n}\nfloat fSubtract( const in float f1, const in float f2 )\n{\n\treturn fIntersect(f1, -f2);\n}\nfloat fDisplace( const in float f1, const in float ds )\n{\n\treturn f1+ds;\n}\nfloat fSmoothPoly( const in float a, const in float b, const in float k ) // polynomial smooth min (k = 0.1)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat fSmoothExp( const in float a, const in float b, const in float k ) // exponential smooth min (k = 32)\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n\treturn -log( res )/k;\n}\nfloat fSmoothPow( const in float a, const in float b, const in float k ) // power smooth min (k = 8)\n{\n\tfloat aa = pow( a, k );\n\tfloat bb = pow( b, k );\n\treturn pow( (aa*bb) / (aa+bb), 1.0/k );\n}\nfloat fNoise( const in vec2 p )\n{\n\tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\n\treturn dot(s, vec2(0.125)) + 0.5;\n}\n\n//----------------------------------------------------------------------------\n// (object-level) operations (vector-valued object: d.xyzw=(dist, matID, texU, texV))\n//----------------------------------------------------------------------------\nvec4 dUnion( const in vec4 d1, const in vec4 d2 )\n{\n\treturn mix(d1, d2, step(d2.x, d1.x));\n}\nvec4 dUnionTransp( const in vec4 d1, const in vec4 d2, const in float fTranspScale )\n{\n\t// Negate the distance to the transparency object if transparent scale is 0.0\n\t// This allows us to retrace out of transparency\n\tvec4 vScaled = vec4(d2.x * (fTranspScale * 2.0 - 1.0), d2.yzw);\n\n\t// The condition allows us to ignore transparency for secondary rays\n\treturn mix(d1, vScaled, step(vScaled.x, d1.x) * step(0.0, fTranspScale));\n}\nvec4 dIntersect( const in vec4 d1, const in vec4 d2 )\n{\n\treturn mix(d2, d1, step(d2.x,d1.x));\n}\nvec4 dSubtract( const in vec4 d1, const in vec4 d2 )\n{\n\treturn dIntersect(d1, vec4(-d2.x, d2.yzw));\n}\nvec4 dDisplace( const in vec4 d1, const in float ds )\n// ds = displacement to apply to d1\n// for example:\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\n// vec4 new_sphere = dDisplace( vec4(fSphere(p,r), gold), ds(p) );\n{\n\treturn vec4( d1.x+ds, d1.yzw );\n}\nvec4 dBlend( const in vec4 d1, const in vec4 d2, const in float k )\n// using polynomial smooth min (often k = 0.1)\n{\n\tfloat fdist = fSmoothPoly( d1.x, d2.x, k );\n\tvec3 vmat = mix( d1.yzw, d2.yzw, step(d2.x, d1.x) );\n\treturn vec4( fdist, vmat );\n}\n\n//----------------------------------------------------------------------------\n// (space-level) operations (vector-valued space: p=(x,y,z))\n//----------------------------------------------------------------------------\nvec3 sRepeat( const in vec3 p, const in vec3 spacing )\n// The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\n// if spacing.y=0, then infinite column is repeated along x-axis & z-axis\n{\n\t//return mod(p, spacing) - 0.5*spacing;\n\tvec3 q = p - 0.5*spacing;\n\treturn mod(q, spacing) - 0.5*spacing;\n}\nvec3 sTwist( const in vec3 p, const in float angle )\n// twist by angle per unit-length along y-axis with the right-hand rule\n{\n\tfloat c = cos( angle*p.y );\n\tfloat s = sin( angle*p.y );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 twist = m*p.zx;\n\treturn vec3( twist.y, p.y, twist.x );\n}\nvec3 sTwistY( const in vec3 p, const in float angle )\t// twist along y-axis\n{\n\treturn sTwist( p, angle );\n}\nvec3 sTwistZ( const in vec3 p, const in float angle )\t// twist along z-axis\n{\n\tvec3 q = p.yzx;\n\tq = sTwist( q, angle );\n\treturn q.zxy;\n}\nvec3 sTwistX( const in vec3 p, const in float angle )\t// twist along x-axis\n{\n\tvec3 q = p.zxy;\n\tq = sTwist( q, angle );\n\treturn q.yzx;\n}\nvec3 sTranslate( const in vec3 p, const in vec3 t )\n{\n\treturn p - t;\n}\nvec3 sRotateX( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\n}\nvec3 sRotateY( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\n}\nvec3 sRotateZ( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\n}\n// Scale\n// e.g., float fScaled = fSphere( p/s, r ) * s\n// only possible to scale uniformly\nvec3 sCheapBendY( const in vec3 p, float angle )\n// bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.x );\n\tfloat s = sin( angle*p.x );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.zx;\n\treturn vec3( b.y, p.y, b.x );\n}\nvec3 sCheapBendZ( const in vec3 p, float angle )\n// bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.y );\n\tfloat s = sin( angle*p.y );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.xy;\n\treturn vec3( b.x, b.y, p.z );\n}\nvec3 sCheapBendX( const in vec3 p, float angle )\n// bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.z );\n\tfloat s = sin( angle*p.z );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.yz;\n\treturn vec3( p.x, b.x, b.y );\n}\n\n//----------------------------------------------------------------------------\n// Scene Description\n//----------------------------------------------------------------------------\nvec4 dCheckerBoard( const in vec3 vPos )\n{\n\treturn vec4( fPlane( vPos-vec3(0.0), vec3(0.0, 1.0, 0.0) ), kMaterialGround, vPos.xy );\n}\nvec4 SimpleScene( const in vec3 vPos, const in float fTranspScale )\n{\n\tvec3 tex0 = vec3(kMaterialTexture0, vPos.z, vPos.x);\n\tvec3 tex1 = vec3(kMaterialTexture1, vPos.x, vPos.y);\n\tvec3 gold = vec3(kMaterialGold, vPos.z, vPos.x);\n\tvec3 silver = vec3(kMaterialSilver, vPos.z, vPos.x);\n\tvec4 res = dCheckerBoard( vPos );\n#if 0\n\tres = dUnion( res, vec4( fBox(vPos-vec3(0.5,0.5,0.5), vec3(0.5)), silver ) );\n#endif\n\n#if 0\n\tres = dUnion( res, vec4( fBox(vPos-vec3(0.5,0.5,0.5), vec3(0.25)), tex0 ) );\n\tres = dUnion( res, vec4( fCylinder(vPos-vec3(1,0.3,0), vec2(0.2, 0.3)), tex1 ) );\n\tres = dUnion( res, vec4( fCone(vPos-vec3( 0.0,0.9, 1.0), vec3(0.8, 0.1, 0.6) ), gold ) );\n#endif\n\n#if 1\n\tvec3 p = sRepeat( vPos, vec3(10.0, 10.0, 10.0) );\n\tres = dUnion( res, vec4( fSphere(p, 2.5), tex0 ) );\n#endif\n\n#if 0\n\tvec3 p = sCheapBendX( vPos, kPI/4.0 );\n\tres = dUnion( res, vec4( fBox(p, vec3(1, 0.2, 1)), gold ) );\n#endif\n\n#if 0\n\tfloat a = 2.0;\tfloat r = 0.5;\n\tvec3 p = sTranslate( vPos, vec3(0,0,0) );\n\tfloat dfmValue = sin(a*p.x)*sin(a*p.y)*sin(a*p.z);\n\tvec4 dsphere = vec4( fSphere(p, r), gold );\n\tvec4 dsphere1 = dDisplace( dsphere, dfmValue );\n\tres = dUnion( res, dsphere1 );\t//psk : some portion is clipped out (need to debug)\n#endif\n\n#if 0\n\tfloat k = 0.1;\n\tvec3 p = sTranslate( vPos, vec3(0,2,0) );\n\tvec4 dcy1 = vec4( fCylinder(p, vec2(1.0,2.0)), gold );\n\tvec4 dcy2 = vec4( fCylinder(p.yzx, vec2(0.5, 2.0)), silver );\n\tres = dUnion( res, dBlend( dcy1, dcy2, k ) );\n#endif\n\n\treturn res;\n}\nvec4 PrimitiveScene( const in vec3 pos, const in float fTranspScale )\n{\n\t//vec3 gold = vec3(kMaterialGold, 0, 0);\n\tvec3 gold = vec3(kMaterialGold, pos.x, pos.y);\t//psk : texUV=(pos.x, pos.y)\n\t\n\tvec4 res = dCheckerBoard( pos );\n\tres = dUnion( res, vec4( fSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), gold ) );\n\tres = dUnion( res, vec4( fBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), gold ) );\n\tres = dUnion( res, vec4( fTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), gold ) );\n\tres = dUnion( res, vec4( fTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), gold ) );\n\tres = dUnion( res, vec4( fCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), gold ) );\n\tres = dUnion( res, vec4( fTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCylinder(  pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), gold ) );\n\tres = dUnion( res, vec4( fHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fSubtract(  fBox( pos-vec3(-2.0,0.2, 1.0), vec3(0.2)), fSphere( pos-vec3(-2.0,0.2, 1.0), 0.25)), gold ) );\n\tres = dUnion( res, vec4( fSubtract( fTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), fCylinder( sRepeat( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2,0.0)) ), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), gold ) );\n\tres = dUnion( res, vec4( 0.7*fSphere( pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), gold ) );\n\tres = dUnion( res, vec4( 0.5*fTorus( sTwist(pos-vec3(-2.0,0.25, 2.0), 20.0), vec2(0.20,0.05)), gold ) );\n\tres = dUnion( res, vec4( fConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), gold ) );\n\tres = dUnion( res, vec4( fEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), gold ) );\n\treturn res;\n}\nvec4 SpoutScene( const in vec3 vPos, const in float fTranspScale )\n{\n    const float kPipeRadius = 0.4;\n    const float kPipeThickness = 0.15;\n    const float kWaterNoiseScale = 0.025;\n    const float kWaterVelocity = 1.0;\n    const float kWaterAccel = -1.0;\n    const float kWaterAnimSpeed = 80.0;\n    const float kTrenchWaterAnimSpeed = 20.0;\n\n    //float kPipeHeight = 2.0;\n\tfloat kPipeHeight = 2.0 + sin(time);\n    float kRipplePos = sqrt(abs(2.0 * kPipeHeight / kWaterAccel)) * kWaterVelocity;\n\n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n\tfloat fDistFloor = vPos.y;\n\tfloat fDistBrick = fDistFloor;\n\tfloat fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;\n\tfDistBrick = max(fDistBrick, -(fDistTrench));\n\tfloat fDistWall = vPos.x + 1.0;\n\tfDistBrick = min(fDistBrick, fDistWall);\n\tvec4 vDistFloor = vec4(fDistBrick, kMaterialWall, vPos.xz + vec2(vPos.y, 0.0));\n\tvResult = dUnion(vResult, vDistFloor);\n\tvec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);\n\n\tfloat t = max(vWaterDomain.x / kWaterVelocity, 0.0);\n\n\t// Equations of motion\n\tfloat s = 0.5 * kWaterAccel * t * t;\n\tfloat v = -kWaterAccel * t;\n\n\tvWaterDomain.y -= s;\n\tfloat fDistWater = (length(vWaterDomain.yz) - kPipeRadius);\n\tfloat fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);\n\tfDistPipe = max(fDistPipe, -fDistWater); // subtract the water from the pipe to make the hole\n\tvec4 vDistPipe = vec4(fDistPipe, kMaterialPipe, vPos.xy);\n\n\tvResult = dUnion(vResult, vDistPipe);\n\n\t// compensate for domain distortion of water, otherwise ray sometimes misses\n\tfDistWater /= (1.0 + v * 0.5);\n\tvec2 vNoiseDomain = vPos.xz;\n\n\t// modify noise for water in trench\n\tfloat fInTrench = step(vPos.y, (-0.1 + 0.05));\n\tvec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);\n\tvNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);\n\tfloat fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;\n\tfloat fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);\n\n\tvNoiseDomain *= 30.0;\n\tvNoiseDomain.x += -time * fWaterSpeed;\n\n\tfloat fTrenchWaterDist = vPos.y + 0.1;\n\tfDistWater = min(fDistWater, fTrenchWaterDist);\n\tfDistWater += fNoise(vNoiseDomain) * fNoiseScale;\n\tvec4 vDistWater = vec4(fDistWater, kMaterialWater, vPos.xy);\n\tvResult = dUnionTransp(vResult, vDistWater, fTranspScale);\n\treturn vResult;\n}\n\n//----------------------------------------------------------------------------\n\nvec4 GetDistanceScene( const in vec3 vPos, const in float fTranspScale )\n// return vec4.x = scene_distance\n//        vec4.y = material (or object) id\n//        vec4.zw = material specific parameters (maybe uv coordinates)\n{\n\treturn SpoutScene( vPos, fTranspScale );\t\t// scene example 1\n\t//return SimpleScene( vPos, fTranspScale );\n\t//return PrimitiveScene( vPos, fTranspScale );\n}\n\nCMaterial GetObjectMaterial( const in CHitInfo hitInfo )\n{\n#if 0\t\t// reflectance of a material\nmat.cAlbedo = vec3(0.93, 0.88, 0.38);\t// Gold\nmat.cAlbedo = vec3(0.26, 0.28, 0.26);\t// Iridium\nmat.cAlbedo = vec3(0.44, 0.435, 0.43);\t// Iron\nmat.cAlbedo = vec3(0.50, 0.47, 0.36);\t// Nickel\nmat.cAlbedo = vec3(0.93, 0.80, 0.46);\t// Copper\nmat.cAlbedo = vec3(0.63, 0.62, 0.57);\t// Platinum\nmat.cAlbedo = vec3(0.97, 0.97, 0.96);\t// Silver\n#endif\n\tCMaterial mat;\n\tif(hitInfo.vObjectID.x == kMaterialTexture0)\t\t// textureMaps[0]\n\t{\n\t\tmat.cAlbedo = texture( textureMaps[0], hitInfo.vObjectID.yz ).rgb;\n\t\tmat.fR0 = (1.0003-0.27049)/(1.0003+0.27049);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialTexture1)\t\t// textureMaps[1]\n\t{\n\t\tmat.cAlbedo = texture( textureMaps[1], hitInfo.vObjectID.yz ).rgb;\n\t\tmat.fR0 = 0.2;//2.0;\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialGround)\n\t{\n\t\tfloat ncell = 2.0;//5.0;\t// ncell = no. cell per unit length (e.g. if ncell=2, then cellsize=0.5)\n\t\tfloat f = mod( floor(ncell*hitInfo.vPos.z) + floor(ncell*hitInfo.vPos.x), 2.0 );\n\t\tmat.cAlbedo = 0.4 + 0.1*f*vec3(1.0);\n\t\tmat.fR0 = 4.0;//0.8;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialGold)\n\t{\n\t\tmat.cAlbedo = vec3(1.0, 0.84, 0.0);\n\t\tmat.fR0 = (1.0003-0.27049)/(1.0003+0.27049);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialSilver)\n\t{\n\t\tmat.cAlbedo = vec3(0.75, 0.75, 0.75);\n\t\tmat.fR0 = (1.0003-0.15016)/(1.0003+0.15016);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialWall)\n\t{\n\t\t// floor\n\t\tmat.fR0 = 0.02;\n\t#ifdef ENABLE_TEXTURE\n\t\t//hitInfo.vObjectID.yz = fragTexCoord;\n\t\tvec3 cTexture = texture(textureMaps[0], hitInfo.vObjectID.yz * 0.25).rgb;\n\n\t\tmat.cAlbedo = cTexture * cTexture;\n\t\tmat.fSmoothness = mat.cAlbedo.r;\n\t\tmat.fTransparency = 0.0;\n\t#else\n\t\t// Textureless version\n\t\tvec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectID.yz));\n\t\tfloat fTile = vTile.x * vTile.y;\n\t\tmat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n\t\tmat.fSmoothness = 1.0;\n\t#endif\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialPipe)\n\t{\n\t\tmat.fR0 = 0.8;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.cAlbedo = vec3(0.5);\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialWater)\n\t{\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 1.0;\n\t\tmat.fRefractIndex = 1.0 / 1.3330;\t// n1(air) / n2(water)\n\t\tconst float fExtinctionScale = 2.0;\n\t\tconst vec3 vExtinction = vec3(0.3, 0.7, 0.9);\n\t\tmat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; // becomes extinction for transparency\n\t}\n\telse\n\t{\n\t\t// red color not to define a material\n\t\tmat.cAlbedo = vec3(1,0,0);\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\treturn mat;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tconst vec3 cColourTop = vec3(0.7, 0.8, 1.0);    // cSky\n\tconst vec3 cColourHorizon = cColourTop * 0.5;   // cGround\n\tfloat fBlend = clamp(vDir.y, 0.0, 1.0);         // w = clamp(vDir.y, 0.0, 1.0)\n\treturn mix(cColourHorizon, cColourTop, fBlend); // skyGradient = cGround*(1-w) + cSky * w\n}\n\nCPointLight GetPointLight()\n{\n\tCPointLight result;\n\tresult.vPos = vec3(0.5, 1.0, -2.0);\n    //result.cCol = vec3(32.0, 6.0, 1.0) * 10.0;\n\tresult.cCol = vec3(32.0, 6.0, 1.0) * 2.0;\n\treturn result;\n}\n\nCDirectionalLight GetDirectionalLight()\n{\n\tCDirectionalLight result;\n\tresult.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n    //result.cCol = vec3(8.0, 7.5, 7.0);\n\tresult.cCol = vec3(2.0, 1.5, 1.0);\n\treturn result;\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n\treturn GetSkyGradient(vNormal); // Lc = skyGradient\n}\n\n//----------------------------------------------------------------------------\n// Raymarching\n//----------------------------------------------------------------------------\nvec3 GetSceneNormal( const in vec3 vPos, const in float fTranspScale )\n{\n\tvec3 eps = vec3( kRaymarchEpsilon, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tGetDistanceScene(vPos+eps.xyy, fTranspScale).x - GetDistanceScene(vPos-eps.xyy, fTranspScale).x,\n\t\tGetDistanceScene(vPos+eps.yxy, fTranspScale).x - GetDistanceScene(vPos-eps.yxy, fTranspScale).x,\n\t\tGetDistanceScene(vPos+eps.yyx, fTranspScale).x - GetDistanceScene(vPos-eps.yyx, fTranspScale).x );\n\treturn normalize(nor);\n}\nvoid Raymarch( const in CRay ray, out CHitInfo result, const int maxIter, const float fTranspScale )\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n    result.fDist = ray.fStartDist;\n    result.vObjectID.x = 0.0;\n    for(int i=0;i<=kRaymarchMaxIter; i++)\n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDist;\n        vec4 vSceneDist = GetDistanceScene( result.vPos, fTranspScale );\n        result.vObjectID = vSceneDist.yzw;\n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if( (abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDist >= ray.fLength) || (i > maxIter) ) break;\n        result.fDist = result.fDist + vSceneDist.x;\n    }\n    if(result.fDist >= ray.fLength)\n    {\n        result.fDist = kFarClip;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDist;\n        result.vObjectID.x = 0.0; // maybe sky\n    }\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )\n{\n#if defined(ENABLE_HARD_SHADOWS)\t\t// #ifdef ENABLE_HARD_SHADOWS\n    CRay shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n    const float fShadowBias = 0.05;\n    shadowRay.fStartDist = fShadowBias / abs(dot(vLightDir, vNormal));\n    shadowRay.fLength = fLightDistance - shadowRay.fStartDist;\n    CHitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, 32, kTranspNo);\n    float fShadow = step(0.0, shadowIntersect.fDist) * step(fLightDistance, shadowIntersect.fDist );\n    return fShadow;\n#elif defined(ENABLE_SOFT_SHADOWS)\n    const float fShadowBias = 0.05;\n    float fDist = fShadowBias / abs(dot(vLightDir, vNormal));\n    float fDistMax = fLightDistance - fDist;\n    float fResult = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        float fSceneDist = GetDistanceScene( vPos + vLightDir*fDist, kTranspNo ).x;\n        fResult = min( fResult, 8.0*fSceneDist/fDist );\n        fDist += clamp( fSceneDist, 0.02, 0.10 );\t\t\t//psk\n        if( fSceneDist<0.001 || fDist>fDistMax ) break;\n    }\n    return clamp( fResult, 0.0, 1.0 );\n#else\n    return 1.0;\n#endif\n}\n\nfloat GetAmbientOcclusion(const in CHitInfo intersection, const in CSurface surface)\n{\n#ifdef ENABLE_AMBIENT_OCCLUSION\n    float fScaleOcc = 0.2;\t\t//psk\n    vec3 vPos = intersection.vPos;\n    vec3 vNormal = surface.vNormal;\n    float fAmbientOcclusion = 1.0;\n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n        fDist += 0.1;\n        vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kTranspNo);\n        fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * fScaleOcc / fDist );\n    }\n    return fAmbientOcclusion;\n#else\n    return 1.0;\n#endif\n}\n\n//----------------------------------------------------------------------------\n// Lighting and Shading\n//----------------------------------------------------------------------------\nvoid ApplyAtmosphere(inout vec3 col, const in CRay ray, const in CHitInfo hitInfo)\n{\n#ifdef ENABLE_FOG\n    float fFogAmount = exp(hitInfo.fDist * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n        CDirectionalLight directionalLight = GetDirectionalLight();\n        float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);\n        cFog += directionalLight.cCol * pow(fDirDot, 10.0);\n    #endif\n    col = mix(cFog, col, fFogAmount);\n#endif\n#ifdef ENABLE_POINT_LIGHT_FLARE\n    CPointLight pointLight = GetPointLight();\n    vec3 vToLight = pointLight.vPos - ray.vOrigin;\n    float fPointDot = dot(vToLight, ray.vDir);\n    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDist);\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n    float fDist = length(vClosestPoint - pointLight.vPos);\n    col += pointLight.cCol * 0.01/ (fDist * fDist);\n#endif\n}\n\nfloat Schlick( const in vec3 vHalf, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vHalf, -vView); // H o V\n\tfDot = clamp((1.0 - fDot), 0.0, 1.0); // 1 - H o V\n\tfloat fDotPow = pow(fDot, 5.0); // (1 - H o V)^5\n\treturn fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor; // fresnel = fR0 + (1.0 - fR0) * (1 - H o V)^5 * smoothFactor\n}\n\nvec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in CMaterial material)\n// vView = ray.vDir\n{\n\tvec3 vReflect = reflect(vView, vNormal); // R = reflect(-V, N)\n\tvec3 vHalf = normalize(vReflect + -vView); // H = R + V\n\tfloat fFresnel = Schlick(vHalf, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);\n\treturn mix(vDiffuse, vSpecular, fFresnel); // return (Ld*Md) * (1-fresnel) + Ls * (fresnel)\n}\n\nfloat GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)\n// vIncidentDir = ray.vDir = eyePos to surfPos\n// vLightDir = surfPos to lightPos\n{          \n\tvec3 vHalf = normalize(vLightDir - vIncidentDir);  // H = L + V\n\tfloat fNdotH = max(0.0, dot(vHalf, vNormal));      // NoH = N o H\n\tfloat fSpecPower = exp2(4.0 + 6.0 * fSmoothness);  // fSmoothness ==> fSpecPower (= shininess)\n\tfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125; // fSpecPower ==> fSpecIntensity (= specIntensity)\n\treturn pow(fNdotH, fSpecPower) * fSpecIntensity;   // specWt = specIntensity * NoH^(shininess)\n}\n\nCShading ApplyPointLight( const in CPointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in CMaterial material )\n// vIncidentDir = ray.vDir = eyePos to surfPos\n{\n\tCShading shading;\n\tvec3 vToLight = light.vPos - vSurfacePos; // L\n\tvec3 vLightDir = normalize(vToLight); // L = L/|L|\n\tfloat fLightDistance = length(vToLight); // d = |L|\n\tfloat fAttenuation = 1.0 / (fLightDistance * fLightDistance); // atten = 1/(d*d)\n\tfloat fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance ); // shadow\n\tvec3 vIncidentLight = light.cCol * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal)); // Ld = shadow * atten * Lc * NoL\n\tshading.cDiffuse = vIncidentLight; // Ld\n\tshading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nCShading ApplyDirectionalLight( const in CDirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in CMaterial material )\n// vIncidentDir = ray.vDir = eyePos to surfPos\n{\n\tCShading shading;\n\tconst float kShadowRayLength = 10.0;\n\tvec3 vLightDir = -light.vDir; // L\n\tfloat fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength ); // shadow\n\tvec3 vIncidentLight = light.cCol * fShadowFactor * max(0.0, dot(vLightDir, vNormal)); // Ld = shadow * Lc * NoL\n\tshading.cDiffuse = vIncidentLight; // Ld\n\tshading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nvec3 ShadeSurface(const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface, const in CMaterial material)\n{\n\tvec3 cScene;\n\tCShading shading;\n\tshading.cDiffuse = vec3(0.0);  // totalLd = 0.0\n\tshading.cSpecular = vec3(0.0); // totalLs = 0.0\n\tfloat fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n\tvec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion; // La = Lc(= skyGradient) * AO\n\tshading.cDiffuse += vAmbientLight;        // totalLd += La\n\tshading.cSpecular += surface.cReflection; // totalLs += (Ms)\n\n#ifdef ENABLE_POINT_LIGHT\n    CPointLight pointLight = GetPointLight(); \n    CShading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += pointLighting.cDiffuse;   // totalLd += Ld\n    shading.cSpecular += pointLighting.cSpecular; // totalLs += Ls\n#endif\n\n#ifdef ENABLE_DIRECTIONAL_LIGHT\n    CDirectionalLight directionalLight = GetDirectionalLight();\n    CShading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += directionLighting.cDiffuse;\t  // totalLd += Ld\n    shading.cSpecular += directionLighting.cSpecular; // totalLs += Ls\n#endif\n\n\tvec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo; // totalLd * (Md)\n\tvDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);// totalDiff = (totalLd*Md)*(transp-1) + Mt*transp\n\n#ifdef ENABLE_SPECULAR\n    cScene = ApplyFresnel(vDiffuseReflection, shading.cSpecular, surface.vNormal, ray.vDir, material);// cScene = (totalDiff) * (1-fresnel) + totalLs * (fresnel)\n#else\n    cScene = vDiffuseReflection; // cScene = (totalDiff)\n#endif\n\n\treturn cScene;\n}\n\nvec3 GetSceneColourSecondary( const in CRay ray );\n\nvec3 GetReflection( const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface )\n{\n#ifdef ENABLE_REFLECTIONS    \n{\n\t// get colour from reflected ray\n    const float fSeparation = 0.1;//psk\n    CRay reflectRay;\n    reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n    reflectRay.vOrigin = hitInfo.vPos;\n    reflectRay.fLength = 16.0;//psk\n    reflectRay.fStartDist = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));\n    return GetSceneColourSecondary(reflectRay);\n}\n#else\n    return GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n#endif\n}\n\nvec3 GetTransmission( const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface, const in CMaterial material )\n{\n\t#ifdef ENABLE_TRANSPARENCY\n\t{\n\t\tconst float fSeparation = 0.05;//psk\n\t\t// Trace until outside transparent object\n\t\tCRay refractRay;\n\t\t// we dont handle total internal reflection (in that case refract returns a zero length vector)\n\t\trefractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractIndex);\n\t\trefractRay.vOrigin = hitInfo.vPos;\n\t\trefractRay.fLength = 16.0;//psk\n\t\trefractRay.fStartDist = fSeparation / abs(dot(refractRay.vDir, surface.vNormal));\n\n\t\t#ifdef DOUBLE_SIDED_TRANSPARENCY\n\t\t\tCHitInfo hitInfo2;\n\t\t\tRaymarch(refractRay, hitInfo2, 32, kTranspInverse);\n\t\t\tvec3 vNormal = GetSceneNormal(hitInfo2.vPos, kTranspInverse);\n\t\t\t\n\t\t\t// get colour from rest of scene\n\t\t\tCRay refractRay2;\n\t\t\trefractRay2.vDir = refract(refractRay.vDir, vNormal, 1.0 / material.fRefractIndex);\n\t\t\trefractRay2.vOrigin = hitInfo2.vPos;\n\t\t\trefractRay2.fLength = 16.0;\n\t\t\trefractRay2.fStartDist = 0.0;//fSeparation / abs(dot(refractRay2.vDir, vNormal));\n\t\t\t\n\t\t\tfloat fExtinctionDist = hitInfo2.fDist;\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay2);\n\t\t#else\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay);\n\t\t\tfloat fExtinctionDist = 0.5;//psk\n\t\t#endif\n\n\t\tvec3 cMaterialExtinction = material.cAlbedo;\n\t\t// extinction should really be exp(-) but this is a nice hack to get RGB\n\t\tvec3 cExtinction = (1.0 / (1.0 + (cMaterialExtinction * fExtinctionDist)));\n\t\treturn vSceneColour * cExtinction;\n\t}\n\t#else\n\t\treturn GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n\t#endif\n}\n\nvec3 GetSceneColourSecondary( const in CRay ray )\n// no reflections, no transparency, used for secondary rays\n{\n\tCHitInfo hitInfo;\n\tRaymarch(ray, hitInfo, 32, kTranspNo);\n\tvec3 cScene;\n\tif( hitInfo.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tCSurface surface;\n\t\tsurface.vNormal = GetSceneNormal(hitInfo.vPos, kTranspNo);\n\t\tCMaterial material = GetObjectMaterial(hitInfo);\n\t\t// use sky gradient instead of reflection\n\t\tsurface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n\t\tmaterial.fTransparency = 0.0;\n\t\t// apply lighting\n\t\tcScene = ShadeSurface(ray, hitInfo, surface, material);\n\t}\n\tApplyAtmosphere(cScene, ray, hitInfo);\n\treturn cScene;\n}\n\nvec3 GetSceneColourTestVersion( const in CRay ray )\n{\n\tvec3 cScene;\n\tCHitInfo intersection;\n\tRaymarch(ray, intersection, 256, kTranspNo);\n\tif( intersection.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n    {\n\t\tfloat t = intersection.fDist;\n        vec3 pos = intersection.vPos;\n\t\tCSurface surface;\n\t\tsurface.vNormal = GetSceneNormal(intersection.vPos, kTranspNo);\n\t\tvec3 nor = surface.vNormal;\n        vec3 ref = reflect( ray.vDir, nor );\n\t\t//vec3 col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) ); // material\n\t\tCMaterial material = GetObjectMaterial( intersection );\n\t\tvec3 col = material.cAlbedo;\n\t\tfloat occ = GetAmbientOcclusion( intersection, surface );\n\t\t// lighitng\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor, ray.vDir), 0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\t\tdif *= GetShadow( pos, nor, lig, 2.5 );\t\t// 2.5 = max distance from hitPos to lightPos\n\t\tdom *= GetShadow( pos, nor, ref, 2.5 );\n\t\tvec3 lin = vec3(0.0);\n\t\tfloat scale = 2.0;//1.2;\n        lin += scale*dif*vec3(1.00,0.85,0.55);\n\t\tlin += scale*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t ) ); // fog\n\t\tcol = clamp(col, 0.0, 1.0);\n\t\tcScene = pow( col, vec3(0.4545) ); //psk\n    }\n\treturn cScene;\n}\n\nvec3 GetSceneColourPrimary( const in CRay ray )\n{\n#ifdef ENABLE_TEST_RENDER\n\treturn GetSceneColourTestVersion( ray );\n#else\n\n\tCHitInfo intersection;\n\tRaymarch(ray, intersection, 256, kTranspYes);\n\tvec3 cScene;\n\tif( intersection.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\n\t\t// fragment depth\n\t\tgl_FragDepth = 0.99;\n\t}\n\telse\n\t{\n\t\tCSurface surface;\n\t\t// surface normal\n\t\tsurface.vNormal = GetSceneNormal(intersection.vPos, kTranspYes);\n\t\t// material selection\n\t\tCMaterial material = GetObjectMaterial(intersection);\n\t\t// surface reflection\n\t\tsurface.cReflection = GetReflection(ray, intersection, surface);\n\t\t// surface transmission\n\t\tif(material.fTransparency > 0.0)\n\t\t{\n\t\t\tsurface.cTransmission = GetTransmission(ray, intersection, surface, material);\n\t\t}\n\t\t// apply lighting\n\t\tcScene = ShadeSurface(ray, intersection, surface, material);\n\n\t\t// fragment depth\n\t\tgl_FragDepth = getFragDepth( intersection.vPos );\n\t}\n\tApplyAtmosphere(cScene, ray, intersection);\n\treturn cScene;\n#endif\n}\n\nvec3 Tonemap( const in vec3 cCol )\n{\n\tvec3 vResult = 1.0 -exp2(-cCol);\n\treturn vResult;\n}\n\nvoid main()\n{\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\n\n\tCRay ray;\n\tray.vOrigin = ro;\n\tray.vDir = rd;\n\tray.fStartDist = 0.0;\n\tray.fLength = kFarClip;\n\n\tvec3 cScene = GetSceneColourPrimary( ray );\n\n\tgl_FragColor = vec4( Tonemap(cScene * 1.5), 1.0 ); //fExposure = 1.5\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n//vec3 fragPos;\t\t// output: fragment position\r\n//vec3 fragNrm;\t\t// output: fragment normal\r\n\r\n//------------------------------------------------------------------------------------------\r\n//\t\tTerrain Mountains\r\n//------------------------------------------------------------------------------------------\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREOT\r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\nconst vec3 SUN_LIGHT = normalize( vec3(0.4, 0.4, 0.48) );\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.83);\r\n\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\nfloat Terrain( in vec2 p )\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p )\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, SUN_LIGHT), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3( v*SUN_COLOR.x*0.4+0.18, v*SUN_COLOR.y*0.4+0.22, v*SUN_COLOR.z*0.4+0.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + SUN_COLOR * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ SUN_COLOR * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00001);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(SUN_LIGHT,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * SUN_COLOR * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(SUN_LIGHT, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, SUN_COLOR, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (time)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tvec3 sky = GetSky(nor)*vec3(0.3,0.3,0.5);\r\n\t\tmat = mix( mat, GetClouds( sky, nor )*0.1 + vec3(0.0, 0.02, 0.03), clamp( tx*0.4, 0.6, 1.0) );\r\n\r\n\t\t// Add some extra water glint...\r\n\t#if 1\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(textureMaps[0], watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t#else\r\n\t\tfloat tmpTex = texture(textureMaps[0], watPos.xz*0.1).x;\r\n\t\ttmpTex = 1.0 - pow(tx+0.5, 3.0) * tmpTex;\r\n\t\tmat += vec3(0.1)*clamp(tmpTex, 0.0,1.0);\r\n\t#endif\r\n\r\n\t\tfloat sunAmount = max( dot(nor, SUN_LIGHT), 0.0 );\r\n\t\tmat = mat + SUN_COLOR * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (t.x + t.y) * .5;\r\n\t\tvec3 p = rO + halfwayT*rD;\r\n\t\t//(Map(p) < 0.5) ? t.x = halfwayT: t.y = halfwayT;\r\n\t\tif( Map(p) < 0.5 ) t.x = halfwayT;\r\n\t\telse t.y = halfwayT;\r\n\t}\r\n\treturn t.x;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT)\r\n{\r\n    float t = 1. + Hash12(gl_FragCoord.xy);\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5 )\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(t, oldT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat iMouseX = 0.0;\r\n\tfloat m = 1.0+(iMouseX/resolution.x)*300.0;\r\n\tt = (time*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(gl_FragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( in vec3 ro, in vec3 rd, out vec4 fragColor, out float fragDepth )\r\n{\r\n#if 0\r\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\r\n\tvec2 uv = xy * vec2(resolution.x/resolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(time*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(time*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n#else\r\n\tcameraPos = ro;\r\n\t//rd = rd;\r\n#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t#ifdef STEREO\r\n\tvec3 cu = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\r\n\tcameraPos += 0.45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos, rd, distance) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t\t//fragPos = vec3(1.0e+30);\r\n\t\t//fragNrm = rd;\r\n\t\tfragDepth = 0.99;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t\t//fragPos = pos;\r\n\t\t//fragNrm = nor;\r\n\t\tfragDepth = getFragDepth( pos );\r\n\t}\r\n\r\n\tvec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\r\n\tvec2 uv = xy * vec2(resolution.x/resolution.y,1.0);\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\r\n\t#endif\r\n\t\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------------------\r\n//\t\tMain Function\r\n//------------------------------------------------------------------------------------------\r\nvoid main()\r\n{\r\n\t//--------------------------------------\r\n\t// ray generation\r\n\t// (ro = rayOrigin, rd = rayDirection)\r\n\t//--------------------------------------\r\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n\t//--------------------------------------\r\n\t// distance fields\r\n\t// -input: ro, rd\r\n\t// -output: fragColor, fragDepth\r\n\t//--------------------------------------\r\n\tvec4 fragColor;\r\n\tfloat fragDepth;\r\n\tmainImage( ro, rd, fragColor, fragDepth );\t\t// provided by external sources (e.g.: shadertoy)\r\n\r\n\tgl_FragColor = fragColor;\r\n\tgl_FragDepth = fragDepth;\r\n\r\n// \t//--------------------------------------\r\n// \t// store to g-buffer\r\n// \t//--------------------------------------\r\n// #if 1\r\n// \tvec4 fragPosV = viewMatrix * vec4(fragPos, 1.0);\r\n// \tfloat ze = fragPosV.z/fragPosV.w;\r\n// \tgl_FragDepth = far*(near + ze) / ((far - near) * ze);\r\n// \tdepthOut = gl_FragDepth;\r\n// #else\r\n// \tvec4 viewPos = viewMatrix * vec4(fragPos, 1.0);\r\n// \tvec4 clipPos = projMatrix * viewPos;\r\n// \tfloat zn = clipPos.z/clipPos.w;\r\n// \tgl_FragDepth = zn*0.5 + 0.5;\r\n// \tdepthOut = gl_FragDepth;\r\n// #endif\r\n// \tnormalOut = normalize( vec3(viewMatrix * vec4(fragNrm, 0.0)) );\r\n// \talbedoOut = fragColor.xyz;\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n//#define USE_CLOUDS_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/terrain/rockyTerrainDirt.jpg' (512 x 512)\r\n// textureMaps[1] = 'images/raymarch/organic1.jpg' (1024 x 1024)\r\n// textureMaps[2] = 'images/raymarch/grayNoise256.png' (256 x 256)\r\n// textureMaps[3] = 'images/raymarch/lichen.jpg' (1024 x 1024)\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n#define iChannel2   textureMaps[2]\r\n#define iChannel3   textureMaps[3]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 300.0;//300.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-0.8, 0.4, -0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 100.0;//300.0;\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\n\r\n// terrain land scales...\r\nconst float MYSTERY_LAND_SCALE = 1.65;\r\nconst float GRASS_LAND_SCALE = 1.75;\r\nconst float BUMPY_LAND_SCALE = 1.2;\r\nconst float STONE_LAND_SCALE = 1.9;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nfloat grassLand( vec3 p )\r\n{\r\n    float h = triSmooth12( vec2(0.19, 0.31) + triSmooth12( p.xz/16.0 ) );\r\n    //float h = triSmooth12( vec2(0.11, 0.99) + triSmooth12( p.xz/16.0 ) );\r\n    //float h = triSmooth12( vec2(0.22, 0.88) + triSmooth12( p.xz/16.0 ) );\r\n    h += triNoise13( p * 0.1 );\r\n    return p.y - h * GRASS_LAND_SCALE;\r\n}\r\nfloat bumpyLand( vec3 p )\r\n{\r\n    float h = triNoise13( p * 0.1 );\r\n    return p.y - h * BUMPY_LAND_SCALE;\r\n}\r\nfloat stoneLand( vec3 p )\r\n{\r\n    float h = triNoise13( p * 0.01 )*11.0; // 0.01 0.02 (for more complex stone)\r\n    return p.y - h * STONE_LAND_SCALE;\r\n}\r\nfloat mysteryLand( vec3 p )\r\n{\r\n    float h = 0.0;\r\n    h += triSmooth12( p.xz/16.0 )*0.66 + triSmooth12( p.xz/8.0 )*0.34;\r\n    h += tri12( p.xz/2.0 )*0.23; p.xz = rotM2i * p.xz;\r\n    h += tri12( p.xz*1.0 )*0.11; //p.xz = rotM2i * p.xz;\r\n    h += triNoiseSmooth13( p * 0.01 )*11.5;\r\n    return p.y - h * MYSTERY_LAND_SCALE;\r\n}\r\n\r\nvec2 terrainMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( stoneLand(p), MATERIAL_TEXTURE0 );\r\n    res = dUnion( res, vec2( bumpyLand(sTranslate(p, vec3(0.0, 4.0, 0.0))), MATERIAL_TEXTURE1 ) );\r\n    return res;\r\n}\r\n\r\nfloat terrainL( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainMap( p ).x;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, terrainMap(p) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        applyClouds( col, iChannel2, ro, rd );\r\n\t}\r\n\r\n    else if( tm.y == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // bump normal\r\n        vec3 n = sceneNormal(p);\r\n        //n = getBumpNormal(iChannel0, p*0.1, n, 0.1-0.05*tm.x/tmax );//0.075\r\n        n = getBumpNormal(iChannel0, p*0.1, n, 0.075 );//0.075\r\n\r\n        // cook shading\r\n        vec3 diffuse, specular;\r\n        float fre = pow( saturate(1.0 + dot(n, rd)), 5.0 );\r\n        vec3 albedo = texCube( iChannel0, p, n ).xyz;\r\n        albedo = mix(albedo, vec3(0.2,0.3,0.0), noise(iChannel2, p.xz*0.25));\r\n        getCookShading( albedo, 0.01, 1.0, SUN_LIGHT, SUN_COLOR*3.0, n, rd, diffuse, specular );\r\n        col = mix(diffuse, fre*vec3(1.0), saturate(n.y)) + specular;\r\n\r\n        // curvature\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n    }\r\n    else if( tm.y == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // bump normal\r\n        vec3 n = sceneNormal(p);\r\n        //n = getBumpNormal(iChannel1, p*0.1, n, 0.1-0.05*tm.x/tmax );//0.075\r\n        n = getBumpNormal(iChannel1, p*0.1, n, 0.075 );//0.075\r\n\r\n        // cook shading\r\n        vec3 diffuse, specular;\r\n        float fre = pow( saturate(1.0 + dot(n, rd)), 5.0 );\r\n        vec3 albedo = texCube( iChannel1, p, n ).xyz;\r\n        albedo = mix(albedo, vec3(0.85, 0.4, 0.2), noise(iChannel2, p.xz*0.05));\r\n        getCookShading( albedo, 0.01, 1.0, SUN_LIGHT, SUN_COLOR*3.0, n, rd, diffuse, specular );\r\n        col = mix(diffuse, fre*vec3(0.7), saturate(n.y)) + specular;\r\n\r\n        // curvature\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n    }\r\n\r\n    // water surface...\r\n    if( rd.y < 0.0 )\r\n    {\r\n        float waterHeight = 5.0;\r\n\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro - vec3(0.0, waterHeight, 0.0), rd, vec4(0.0) );//cloudy = 0.0\r\n        if( 0.0 < waterCol.w && waterCol.w < tm.x )\r\n        {\r\n            // foam on water...\r\n            float t = (waterHeight-ro.y)/rd.y;\r\n            vec2 uv = (ro + rd * t).xz;\r\n            #if 0\r\n                float sur = texture( iChannel3, 0.007*time * 0.06*uv ).x;\r\n            #else\r\n                float sur = texture( iChannel3, 0.06*uv ).x;\r\n            #endif\r\n            sur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2, 1.0, texture( iChannel2, 1.0*uv ).x);\r\n            waterCol.rgb = mix( waterCol.rgb, vec3(2.5), 0.5*sur ); // foamCol = vec3(2.5)\r\n\r\n            // sun specular...\r\n            // float sunAmount = saturate( dot(SUN_LIGHT, reflect( rd, vec3(0.0,1.0,0.0) ) ) );\r\n            // waterCol.rgb += 0.2*vec3(1.0,0.95,0.9)*pow(sunAmount,16.0);\r\n            // waterCol.rgb += 0.5*vec3(1.0,0.95,0.9)*pow(sunAmount,96.0);\r\n\r\n            col = mix(col, waterCol.rgb, saturate(1.1+rd.y));\r\n        }\r\n    }\r\n\r\n    if( tm.y != MATERIAL_SKY )\r\n    {\r\n        // height-based fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.4 );//1.2\r\n        // constant fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.005, tm.x );//0.003\r\n    }\r\n\r\n    // post-processing\r\n    col = FilmicToneMapping( col );\r\n    col = col * 1.05 - 0.05;\r\n    //col = col * 1.1 - 0.1;\r\n    //col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 p = vec3( 0.0, 0.0, 80.0 + t );//95.0\r\n\tfloat a = smoothstep(5.0, 20.0, t);\r\n\tp.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tp.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tp.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tp.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\treturn -p;\r\n}\r\n\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 2.0*time;//10.0\r\n#if 0\r\n    ro = vec3(0.0, 0.0, -80.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -90.0-curTime);\r\n#else\r\n    ro = cpath( curTime );\r\n\tvec3 ta = cpath( 10.0 + curTime );\r\n#endif\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 100.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xyz ) + 20.0;//30.0 20.0\r\n    ta.y = ro.y - 5.0;\r\n\r\n    float fl = 1.5;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#define USE_TERRAIN_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n#define iChannel0   textureMaps[0]\r\n\r\n// on the derivatives based noise: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n// on the soft shadow technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n// on the fog calculations: http://iquilezles.org/www/articles/fog/fog.htm\r\n// on the lighting: http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\r\n// on the raymarching: http://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n\r\nconst float FAR = 300.0;//200.0\r\nconst vec3 SUN_LIGHT = normalize(vec3(-0.8, 0.4, -0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 300.0;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( terrainMap( iChannel0, p ), MATERIAL_TERRAIN ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col;\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );//1.0\r\n        applyClouds( col, iChannel0, ro, rd );\r\n\t}\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        col = terrainColor( iChannel0, SUN_COLOR, SUN_LIGHT, p, tm.x, tmax );\r\n        // height-based fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.4 );\r\n        // constant fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.003, tm.x );//0.005\r\n    }\r\n\r\n    // sun scatter\r\n    col += sunScatter( SUN_LIGHT, rd );\r\n\r\n#ifdef ENABLE_DUST_WIND\r\n    float dustAmount = 0.25;//0.25;\r\n    float dustHeight = 75.0*TERRAIN_SCALE;//50.0\r\n    float windTurbulency = 0.5;\r\n    applyDustWind( col, ro, rd, tm.x, dustAmount, dustHeight, windTurbulency );\r\n#endif\r\n\r\n    col = FilmicToneMapping( col );\r\n    //col = col * 1.05 - 0.05;\r\n    col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n    return col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvoid cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 5.5*time;\r\n    ro = vec3( 0.0, 0.0, -95.0-curTime );\r\n    vec3 ta = vec3( 0.0, 0.0, -110.0-curTime );\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 25.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xz ) + 50.0*TERRAIN_SCALE;//75.0\r\n    ta.y = ro.y - 40.0*TERRAIN_SCALE;//-75.0\r\n\r\n    float fl = 1.0;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n    gl_FragColor.rgb = Vignetting( gl_FragColor.rgb, 0.5 );\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#define USE_LENSFLARES_1\r\n#define USE_TERRAIN_3\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = heightTex0 ('images/raymarch/organic2.png')\r\n// textureMaps[1] = heightTex1 ('images/raymarch/abstract1.jpg')\r\n// textureMaps[2] = detailTex  ('images/raymarch/rgbaNoise256.png')\r\n\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n// #define ENABLE_SNOW\r\n#define ENABLE_LENS_FLARES\r\n\r\nconst float FAR = 150.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-1.0,0.19,0.4));\r\n//const vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.05);\r\nconst float SKY_HEIGHT = 500.0;//1000.0;\r\n\r\n// vec3 SUN_COLOUR = vec3(1.1, 0.95, 0.85);\r\n// vec3 FOG_COLOUR = vec3(0.48, 0.49, 0.53);\r\n// vec3 SKY_BLUE_COLOUR = vec3(0.218, 0.325, 0.455);\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n\tvec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n\tres = dUnion( res, vec2( terrainMap(textureMaps[0], textureMaps[1], textureMaps[2], p), MATERIAL_TERRAIN ) );\r\n\treturn res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n\ttmin = 0.1;//1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n        \r\n    vec2 tm = rayMarching( ro, rd, tmin, tmax );\r\n\tif( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n\tvec3 col = vec3(0.0);\r\n\r\n\tif( tm.y == MATERIAL_SKY )\r\n\t{\r\n\t\tgl_FragDepth = 0.99;\r\n\t\tcol = skyColor( SUN_LIGHT, rd );\r\n\t\tapplyClouds( col, ro, rd );\r\n\t}\r\n\telse if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n\t\tgl_FragDepth = getFragDepth( p );\r\n\t\tcol = terrainColor( textureMaps[0], textureMaps[1], textureMaps[2], SUN_LIGHT, rd, p, tm.x );\r\n\r\n\t\t// col *= 1.0 when the sun is in front ===> as it is\r\n\t\t// col *= 0.5 when the sun is on the side ==> it gets dark\r\n\t\tcol *= 1.0 - 0.5 * pow( 1.0-saturate(dot(rd,SUN_LIGHT)), 3.0);//0.25\r\n\r\n\t\tapplyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.2 );\r\n\t\tapplyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.003, tm.x );//0.005\r\n\r\n\t#ifdef ENABLE_DUST_WIND\r\n\t\tfloat dustAmount = 0.2;//0.1;//0.01;\r\n\t\tfloat dustHeight = 10.0;//3.0;\r\n\t\tfloat windTurbulency = 0.3;\r\n\t\tapplyDustWind( col, ro, rd, tm.x, dustAmount, dustHeight, windTurbulency );\r\n\t#endif\r\n\t}\r\n\r\n    // sun glare\r\n\tcol += sunScatter( SUN_LIGHT, rd );\r\n\tcol = saturate(col);\r\n\r\n\t// color grading\r\n#if 0\r\n\tcol *= vec3(1.1, 1.0, 1.0); // almost linear\r\n\tcol = col*col*(3.0-2.0*col); // col = smooth(0,1,col)\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) ); // red = sqr(red)\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 ); // 0.6*col + 0.4*gray_of_col ==> gray-tone added\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col); // almost linear\r\n#endif\r\n\r\n\tcol = col * 1.05 - 0.05;\r\n\t//col = col*col*(3.0-2.0*col);\r\n\tcol = FilmicToneMapping( col );\r\n\tcol = LinearToGamma( vec4(col, 1.0), 1.6 ).rgb;\r\n\r\n#ifdef ENABLE_SNOW\r\n\tcol += snowColor(0.2, 0.5);\r\n#endif\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 p = vec3( 0.0, 0.0, 95.0 + t );\r\n\tfloat a = smoothstep(5.0, 20.0, t);\r\n\tp.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tp.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tp.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tp.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\treturn -p;\r\n}\r\n\r\nmat3 cameraAutoView( in sampler2D heightTex0, out vec3 ro, out vec3 rd )\r\n{\r\n\tfloat curTime = 0.5*(time);//1.0\r\n#if 0\r\n    ro = vec3(0.0, 0.0, -95.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -105.0-curTime);\r\n#else\r\n\tro = cpath( curTime );\r\n\tvec3 ta = cpath( 2.0 + curTime );//10.0\r\n#endif\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 10.0, curTime) );\r\n\tro.y = terrainL( heightTex0, ro.xz ) + 0.1;//5.0\r\n\tta.y = ro.y - 1.5;//5.0\r\n\r\n    float fl = 1.0;//1.2;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n\treturn cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\tvec3 ro, rd;\r\n    mat3 cam = cameraAutoView( textureMaps[0], ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n\r\n#ifdef ENABLE_LENS_FLARES\r\n\tvec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\t#ifdef ENABLE_AUTO_VIEW\r\n\t\tapplyLensFlares( col, cam, xy, SUN_COLOR, SUN_LIGHT, 0.0 );\r\n\t#else\r\n\t\tapplyLensFlares( col, ro, cameraWorldMatrix, cameraProjectionMatrixInverse, xy, SUN_COLOR, SUN_LIGHT, 0.0 );\r\n\t#endif\r\n#endif\r\n\r\n\tcol = Vignetting( col, 0.5 );\r\n\tgl_FragColor = vec4( col, 1.0 );\r\n}"},function(e,t){e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n#define map( pos )  sceneMap( pos ).x\r\n\r\n// textureMaps[0] = \'images/raymarch/pebbles.jpg\'\r\n// textureMaps[1] = \'images/raymarch/organic1.jpg\'\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n\r\n//==============================================================================\r\n// Desert Canyon\r\n// The far plane. I\'d like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n#define ENABLE_PHONG_LIGHTING\r\n\r\n// Choose...\r\n//#define DESERT_CAVE\r\n//#define SMOOTH_CAVE\r\n//#define HELL_CAVE\r\n#define CAVE_CANYON         // similar to DESERT_CAVE (default)\r\n//#define FLOATING_CANYON\r\n\r\n#define FAR 65.0\r\n\r\n// used in path function & used to shape the tunnel and guide the camera.\r\nconst float freqA = 0.15/3.75;\r\nconst float freqB = 0.25/2.75;\r\nconst float ampA = 20.0;\r\nconst float ampB = 4.0;\r\n\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies and amplitudes.\r\nvec2 path( in float z )\r\n{\r\n    return vec2( ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.0*(sin(z*0.025) - 1.0) );\r\n}\r\n\r\n#ifdef DESERT_CAVE\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat desertCanyon(in vec3 p)\r\n{\r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I\'d much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I\'ll really be able to do some damage. :)\r\n\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(0.111));\r\n\r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.0;\r\n  \r\n    // Reusing "h" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you\'re not familiar with the process, this is it.\r\n    // We\'re also adding some detailing to the walls via "h" and the rocky "tx" value.\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I\'ve also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return fsmax(d, tunnel, 2.0) - tx*0.5 + tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef SMOOTH_CAVE\r\nfloat smoothCave(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n\r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*0.2 + h*20.0;\r\n  \r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// winding tunnel (adding details to the walls via "h" and the rocky "tx" value)\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n\t// combine terrain with the tunnel\r\n    //return fsmax(d, tunnel, 2.0) + tx*0.5 + tunnel*0.8;\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 + tunnel*0.8 + tunnel * tx;\r\n}\r\n#endif\r\n\r\n#ifdef HELL_CAVE\r\nfloat hellCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.15;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*3.1 + h*16.0;\r\n\r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 - tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef CAVE_CANYON\r\nfloat caveCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.24;\r\n    float freq = 2.8;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y - h*20.0;\r\n\r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) - tx*0.5 + tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef FLOATING_CANYON\r\nfloat floatingCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*0.2 + h*22.0;\r\n  \r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 - tunnel*0.8;\r\n}\r\n#endif\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n#if defined( DESERT_CAVE )\r\n    return vec2( desertCanyon(p), 0.0 );\r\n\r\n#elif defined( SMOOTH_CAVE )\r\n    return vec2( smoothCave(p), 0.0 );\r\n\r\n#elif defined( HELL_CAVE )\r\n    return vec2( hellCanyon(p), 0.0 );\r\n\r\n#elif defined( CAVE_CANYON )\r\n    return vec2( caveCanyon(p), 0.0 );\r\n\r\n#elif defined( FLOATING_CANYON )\r\n    return vec2( floatingCanyon(p), 0.0 );\r\n\r\n#endif\r\n}\r\n\r\nvoid applyLighting( inout vec3 col, in vec3 p, in vec3 n, in vec3 ld, in vec3 rd )\r\n// ld = light direction from surface to light\r\n{\r\n    float diffuseIntensity = 3.0;\r\n    float specularIntensity = 1.0;//2.25;\r\n    float shininess = 16.0;\r\n    float F0 = 0.2;// F0(dielectric)=0.04, F0(water)=0.0204\r\n\r\n    //float shadow = sceneShadow(p, ld, 0.05, FAR, 8.0);\r\n    float shadow = sceneShadow(p+ld*0.05, ld, 0.05, FAR, 8.0);\r\n    float ao = sceneAO(p, n);\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float diffuse = max( dot(ld, n), 0.0) * diffuseIntensity;\r\n    float specular = pow( max(dot(n, h), 0.0), shininess) * specularIntensity;\r\n    float F = mix(F0, 1.0, pow(1.0 - max(dot(h,v),0.0), 5.0));// schlick approximation\r\n    float ambient = saturate( 0.3 + 0.1*n.y );\r\n    col = mix( col*(diffuse + ambient)*shadow*ao, vec3(specular*shadow), F );\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\t// Screen coordinates\r\n\tvec2 u = (gl_FragCoord.xy - resolution.xy*0.5)/resolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0.0, 0.0, time*8.0);  // "Look At" position.\r\n\tvec3 ro = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and "look at" vectors down the tunnel. The "path" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt-ro);\r\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it\'s synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n    vec2 u = ndc; // ndc = normalized device coordinates [-1, +1]\r\n#endif\r\n\r\n    // light position\r\n    vec3 lp = vec3(FAR*0.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n\r\n    // sky & clouds\r\n#ifdef HELL_CAVE\r\n    vec3 sky = vec3(0.0, -0.0, -0.0);\r\n    applyClouds( sky, ro, rd );\r\n#else\r\n    vec3 sky = skyColor(normalize(lp - ro), rd, 1.0);\r\n    applyClouds( sky, ro, rd );\r\n#endif\r\n\r\n    vec3 col = sky;\r\n\r\n    // ray marching...\r\n    float t = rayTracing( ro, rd, 0.001, FAR, 0.3 );//0.4\r\n\r\n    gl_FragDepth = 0.99;\r\n    \r\n    // If we\'ve hit the ground, color it up.\r\n    if( t < FAR )\r\n    {\r\n#ifdef ENABLE_PHONG_LIGHTING\r\n        vec3 p = ro+t*rd;\r\n        vec3 n = sceneNormal( p, t );\r\n\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // light direction\r\n        vec3 ld = lp - p;\r\n        ld /= max( length(ld), 0.0001 );\r\n\r\n        // 0) bump normal (for details)\r\n        const float texScale = 0.2;\r\n        n = getBumpNormal(iChannel1, p*texScale, n, 0.01/(1.0 + t/FAR));\r\n\r\n        // 1) base color (soil) (see \'skin peeler\' for details)\r\n        col = mix( vec3(0.8, 0.5, 0.3), vec3(0.5, 0.25, 0.125), (p.y + 1.0)*0.15 );\r\n        col = clamp(col, vec3(0.5, 0.25, 0.125), vec3(1.0));\r\n\r\n        // 2) texture\r\n        col = smoothstep(-0.5, 1.0, texCube(iChannel1, p*texScale, n).rgb)*(col + 0.25);\r\n\r\n        // 3) anisotropic filtering (for crisp textures)\r\n        float crisp = 0.45;\r\n        col = saturate(col + noise13(p*48.0)*crisp - 0.15);\r\n\r\n        // 4) color in the crack ==> more darker\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n\r\n        // 5) sky reflection ===> almost ineffective\r\n        //col += skyColor(ld, reflect(rd, n), 1.0) * F * 0.2;\r\n\r\n        // 6) gamma correction\r\n        col = pow(col, vec3(2.2));\r\n\r\n        // 7) lighting\r\n        applyLighting( col, p, n, ld, rd );\r\n#else\r\n        vec3 p = ro+t*rd;\r\n        vec3 n = sceneNormal( p, t );\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        vec3 ld = lp - p;\r\n        ld /= max( length(ld), 0.0001 );\r\n\r\n        const float texScale = 1.0/6.0;\r\n        n = getBumpNormal(iChannel1, p*texScale, n, 0.007/(1.0 + t/FAR));\r\n\r\n        float shd = sceneShadow(p, ld, 0.05, FAR, 8.0);\r\n        float ao = sceneAO(p, n);\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n\r\n        vec3 v = -rd;\r\n        vec3 h = normalize(ld + v);\r\n        float dif = max( dot( ld, n ), 0.0);\r\n        float spe = pow( max(dot( n, h ),0.0), 5.0); // 5.0 = shininess\r\n        float fre = saturate(1.0 - dot(v, n)); // (1 - dotNV) for fresnel term\r\n\t\tfloat schlick = pow(1.0 - max(dot(rd, normalize(rd + ld)), 0.0), 5.0);\r\n\t\tfloat F = mix(0.2, 1.0, schlick);  // F0 (hard clay) = 0.2\r\n        float amb = fre*F + 0.06*ao;\r\n\r\n        col = mix( vec3(0.8, 0.5, 0.3), vec3(0.5, 0.25, 0.125), (p.y + 1.0)*0.15 );\r\n        col = clamp( col, vec3(0.5, 0.25, 0.125), vec3(1.0));\r\n        col = smoothstep(-0.5, 1.0, texCube(iChannel1, p*texScale, n).rgb)*(col + 0.25);\r\n        col = saturate(col + noise13(p*48.0)*0.3 - 0.15);\r\n        col = pow(col, vec3(1.5));\r\n        col *= smoothstep(0.0, 0.7, curv);\r\n        col += skyColor(ld, reflect(rd, n), 1.0)*fre*F*0.5;\r\n        col = (col*(dif + 0.1) + F*spe)*shd*ao + amb*col;\r\n#endif\r\n    }\r\n\r\n    // terrain + sky(with fog) ===> foggy terrain\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15.0, FAR, t)));\r\n\r\n#ifdef ENABLE_DUST_WIND\r\n    #ifdef FLOATING_CANYON\r\n        float dustAmount = 0.005;\r\n    #else\r\n        float dustAmount = 0.01;\r\n    #endif\r\n    float dustHeight = 3.0;\r\n    float windTurbulency = 0.3;\r\n    applyDustWind( col, ro, rd, t, dustAmount, dustHeight, windTurbulency );\r\n#endif\r\n\r\n#ifdef ENABLE_PHONG_LIGHTING\r\n    col = pow(col, vec3(0.95)); // LinearToGamma\r\n#else\r\n    col = pow(max(col, 0.0), vec3(0.75));\r\n#endif\r\n\r\n    // vignetting\r\n#if 0\r\n    u = gl_FragCoord.xy / resolution.xy;\r\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y), 0.0625);\r\n#else\r\n    col = Vignetting( col, 0.5 );\r\n#endif\r\n\r\n\tgl_FragColor = vec4( saturate(col), 1.0 );\r\n}'},function(e,t){e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n#define texChannel0 textureMaps[0]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_CAMERA\r\n\r\n// Choose...\r\n//#define ENABLE_SURF_JAG1      // sharp\r\n#define ENABLE_SURF_JAG2        // default\r\n//#define ENABLE_SURF_JAG3      // flat\r\n//#define ENABLE_SURF_JAG4\r\n//#define ENABLE_SURF_JAG5\r\n//#define ENABLE_SURF_JAG6      // round\r\n\r\n// Choose...\r\n#define ENABLE_ROUND_TUNNEL     // default\r\n//#define ENABLE_SQUARE_TUNNEL\r\n//#define ENABLE_ROUNDED_SQUARE_TUNNEL\r\n//#define ENABLE_MINIMALISTS\r\n\r\n// Choose...\r\n#define ENABLE_GLOW           // default\r\n//#define ENABLE_SHINY\r\n\r\n// Choose...\r\n//#define ENABLE_EDGE_EFFECT\r\n\r\n// Choose the camera speed\r\n#define CAMERA_SPEED    5.0\r\n// 1.0 = slow\r\n// 5.0 = normal (default)\r\n// 10.0 = fast\r\n\r\n// Choose the ground height\r\n#define GROUND_HEIGHT   1.0\r\n// 0.0 = wide flat groud\r\n// 1.0 = narrow flat ground (default)\r\n// 2.0 = bumpy ground (no flat)\r\n// 3.0 = more bumpy ground\r\n\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\n// Non-standard vec3-to-vec3 hash function.\r\nvec3 hash33(vec3 p)\r\n{\r\n    float n = sin(dot(p, vec3(7, 157, 113)));    \r\n    return fract(vec3(2097152, 262144, 32768)*n); \r\n}\r\n\r\n// 2x2 matrix rotation.\r\nmat2 rot2(float a)\r\n{\r\n\tfloat c = cos(a); float s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\r\n    n /= (n.x + n.y + n.z );   \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\r\n// See Xyptonjtroz - Very cool. Anyway, it\'s not really being used to its full potential here.\r\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\r\n\r\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \r\n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \r\n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \r\n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \r\n// are bump mapped.\r\nfloat surfFunc(in vec3 p)\r\n{\r\n    // all have range: [0, 1]\r\n\r\n#if defined(ENABLE_SURF_JAG1)\r\n\treturn dot(tri(p*0.5 + tri(p*0.25 + 0.25).yzx), vec3(0.666));\r\n\r\n#elif defined(ENABLE_SURF_JAG2)\r\n    float n = dot(tri(p*0.5 + tri(p*0.25 + 0.25).yzx), vec3(0.444));\r\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.7071;\r\n    return dot(tri(p*0.75 + tri(p*0.375 + 0.125).yzx), vec3(0.222)) + n; // Range [0, 1]\r\n\r\n#elif defined(ENABLE_SURF_JAG3)\r\n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.333)) + \r\n           sin(p.x*1.5+sin(p.y*2.+sin(p.z*2.5)))*0.25+0.25;\r\n\r\n#elif defined(ENABLE_SURF_JAG4)\r\n    return dot(tri(p*0.6 + tri(p*0.3).yzx), vec3(0.333)) + \r\n           sin(p.x*1.75+sin(p.y*2.+sin(p.z*2.25)))*0.25+0.25; // Range [0, 1]\r\n\r\n#elif defined(ENABLE_SURF_JAG5)\r\n    p *= 0.5;\r\n    float n = dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.66));\r\n    p *= 1.5;\r\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\r\n    n += dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.34));\r\n    return n;\r\n\r\n#elif defined(ENABLE_SURF_JAG6)\r\n    p *= 2.;\r\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\r\n    p *= 1.5773;\r\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\r\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\r\n    p *= 1.5773;\r\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\r\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\r\n    return n*0.4+0.6;\r\n#endif\r\n}\r\n\r\n// Cheap...ish smooth minimum function.\r\nfloat smoothMinP( float a, float b, float smoothing )\r\n{\r\n    float h = clamp((b-a)*0.5/smoothing + 0.5, 0.0, 1.0 );\r\n    return mix(b, a, h) - smoothing*h*(1.0-h);\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/12.); return vec2(s*12., 0.); }\r\n\r\n// Standard tunnel distance function with a bit of perturbation thrown into the mix. A winding \r\n// tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. The walls \r\n// of the tunnels should be perturbed by some kind of 3D surface function... preferably a cheap \r\n// one with decent visual impact.\r\nfloat map(vec3 p)\r\n{\r\n#if defined(ENABLE_ROUND_TUNNEL)\r\n    // Round tunnel with floor using Euclidean distance: length(tun.xy)\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    float n = 1.- length(tun.xy) + (0.5-surfFunc(p)); //max(tun.x, tun.y)\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_SQUARE_TUNNEL)\r\n    // Square tunnel using Chebyshev distance: max(abs(tun.x), abs(tun.y))\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    //tun *= tun;\r\n    float n = 1.- max(tun.x, tun.y) + (0.5-surfFunc(p));\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_ROUNDED_SQUARE_TUNNEL)\r\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    tun = pow(tun, vec2(4.));\r\n    float n =1.-pow(tun.x + tun.y, 1.0/4.) + (0.5-surfFunc(p));\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_MINIMALISTS)\r\n    // For the minimalists. :)\r\n    float n = 0.5-surfFunc(p + 0.25*sign(p.y));\r\n    n = min(GROUND_HEIGHT, 1. - sign(p.y)*n*0.75);\r\n    return min(-p.y + n, p.y + n);\r\n#endif\r\n}\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor )\r\n{\r\n    const float eps = 0.001;\r\n    float ref = getGrey(tex3D(tex,  p , nor));                 \r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x+eps, p.y, p.z), nor))-ref,\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y+eps, p.z), nor))-ref,\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z+eps), nor))-ref )/eps;\r\n    grad -= nor*dot(nor, grad);\r\n    return normalize( nor + grad*bumpfactor );\r\n}\r\n\r\n// Surface normal.\r\nvec3 getNormal(in vec3 p)\r\n{\r\n\tconst float eps = 0.001;\r\n\treturn normalize(vec3(\r\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\r\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\r\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\r\n\t));\r\n}\r\n\r\n// Based on original by IQ.\r\nfloat calculateAO(vec3 p, vec3 n)\r\n{\r\n    const float AO_SAMPLES = 5.0;\r\n    float r = 0.0, w = 1.0, d;\r\n    for (float i = 1.0; i < AO_SAMPLES + 1.1; i++ )\r\n    {\r\n        d = i/AO_SAMPLES;\r\n        r += w*(d - map(p + n*d));\r\n        w *= 0.25; // jamie: 0.5 => 0.25\r\n    }\r\n    return 1.0 - saturate(r);\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n// I think it\'s based on a discrete finite difference approximation to the continuous\r\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \r\n// which is pretty handy. I used it to do a bit of fake shadowing.\r\nfloat curve(in vec3 p, in float w)\r\n{\r\n    vec2 e = vec2(-1., 1.)*w;\r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef ENABLE_AUTO_CAMERA\r\n    //===================\r\n    // original codes\r\n    //===================\r\n\r\n\t// screen coordinates\r\n\tvec2 uv = (fragCoord - resolution.xy*0.5)/resolution.y;\r\n\t\r\n\t// camera setup\r\n    vec3 lookAt = vec3(0.0, 0.0, time * CAMERA_SPEED); // "lookAt" position.\r\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\r\n \r\n    // light positioning. One is a little behind the camera, and the other is further down the tunnel.\r\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, -0.125); // Put it a bit in front of the camera.\r\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 6.0);     // Put it a bit in front of the camera.\r\n\r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// sending the "camera", "lookAt," and two lights down the tunnel.\r\n    // The "path" function is synchronized with the distance function.\r\n    // change to "path2" to traverse the other tunnel.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tcamPos.xy += path(camPos.z);\r\n\tlight_pos.xy += path(light_pos.z);\r\n\tlight_pos2.xy += path(light_pos2.z);\r\n\r\n    // ray direction\r\n    float FOV = PI/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt-camPos);\r\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n#else\r\n    //===================\r\n    // my codes... (to control view)\r\n    //===================\r\n\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\t\r\n\t// screen coordinates\r\n    vec2 uv = screenPos;\r\n\t\r\n\t// camera setup\r\n\tvec3 lookAt = vec3(0.0, 0.0, time * CAMERA_SPEED); // "lookAt" position.\r\n    vec3 camPos = -lookAt + rd; // Camera position, doubling as the ray origin.\r\n \r\n    // light positioning. One is a little behind the camera, and the other is further down the tunnel.\r\n \tvec3 light_pos = camPos - vec3(0.0, 0.125, -0.125);// Put it a bit in front of the camera.\r\n\tvec3 light_pos2 = camPos - vec3(0.0, 0.0, 6.0);// Put it a bit in front of the camera.\r\n\r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// sending the "camera", "lookAt," and two lights down the tunnel.\r\n    // The "path" function is synchronized with the distance function.\r\n    // change to "path2" to traverse the other tunnel.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tcamPos.xy += path(camPos.z);\r\n\tlight_pos.xy += path(light_pos.z);\r\n\tlight_pos2.xy += path(light_pos2.z);\r\n\r\n#endif\r\n\r\n\trd.xy *= rot2( -path(lookAt.z).x / 32.0 );\r\n    // rd.xz *= rot2( path(lookAt.z).x / 32.0 );\r\n\r\n    // standard ray marching routine. I find that some system setups don\'t like anything other than\r\n    // a "break" statement (by itself) to exit. \r\n\tfloat t = 0.0, dt;\r\n\tfor(int i=0; i<128; i++)\r\n    {\r\n\t\tdt = map( camPos + rd * t );\r\n\t\tif( dt < 0.005 || t > 150.0 ){ break; }\r\n        t += dt * 1.1; // jamie: 0.75 => 1.1\r\n\t}\r\n\r\n\tvec3 sceneCol = vec3(0.0);\r\n\r\n\t// The ray has effectively hit the surface, so light it up.\r\n\tif( dt < 0.005 )\r\n    {\r\n\t    // The ray marching loop (above) exits when "dt" is less than a certain threshold, which in this \r\n        // case, is hardcoded to "0.005." However, the distance is still "dt" from the surface? By my logic, \r\n\t    // adding the extra "dt" after breaking would gain a little more accuracy and effectively reduce \r\n\t    // surface popping? Would that be correct? I tend to do this, but could be completely wrong, so if \r\n\t    // someone could set me straight, it\'d be appreciated. \r\n\t    t += dt;\r\n\r\n    \t// Surface position and surface normal.\r\n\t    vec3 sp = t*rd + camPos;\r\n\t    vec3 sn = getNormal(sp);\r\n\r\n        gl_FragDepth = getFragDepth( sp );\r\n\r\n        // Texture scale factor.\r\n        const float tSize0 = 1./2.; \r\n        const float tSize1 = 1./3.; \r\n\r\n    \t// Texture-based bump mapping. Comment this line out to spoil the illusion.\r\n\t    if( sp.y < -(GROUND_HEIGHT - 0.005) )\r\n            sn = doBumpMap( texChannel0, sp*tSize1, sn, 0.0125 );\r\n\t    else\r\n            sn = doBumpMap( texChannel0, sp*tSize0, sn, 0.025 );\r\n\r\n\t    // Ambient occlusion.\r\n\t    float ao = calculateAO(sp, sn);\r\n\r\n    \t// Light direction vectors.\r\n\t    vec3 ld = light_pos - sp;\r\n\t    vec3 ld2 = light_pos2 - sp;\r\n\r\n        // Distance from respective lights to the surface point.\r\n\t    float distlpsp = max(length(ld), 0.001);\r\n\t    float distlpsp2 = max(length(ld2), 0.001);\r\n\r\n    \t// Normalize the light direction vectors.\r\n\t    ld /= distlpsp;\r\n\t    ld2 /= distlpsp2;\r\n\r\n\t    // Light attenuation, based on the distances above.\r\n\t    float atten = min(1./(distlpsp) + 1./(distlpsp2), 1.0);\r\n\r\n    \t// Ambient light.\r\n\t    float ambience = 0.25;\r\n\r\n    \t// Diffuse lighting.\r\n\t    float diff = max( dot(sn, ld), 0.0);\r\n\t    float diff2 = max( dot(sn, ld2), 0.0);\r\n\r\n    \t// Specular lighting.\r\n\t    float spec = pow( max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\r\n\t    float spec2 = pow( max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.0);\r\n\r\n    \t// Curvature.\r\n\t    float crv = saturate(curve(sp, 0.125)*0.5 + 0.5);\r\n\r\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\r\n        float fre = pow( saturate(dot(sn, rd) + 1.0), 1.0);\r\n\r\n        // Obtaining the texel color. \r\n        vec3 texCol;\r\n        if( sp.y < -(GROUND_HEIGHT - 0.005) )\r\n        {\r\n            texCol = tex3D( texChannel0, sp*tSize1, sn );\r\n            texCol = texCol*0.5 + getGrey(texCol)*0.25 + 0.25;\r\n        }\r\n\t    else texCol = tex3D( texChannel0, sp*tSize0, sn ); // Sandstone.\r\n\r\n        // Jitter, if needed.\r\n        //vec3 aniso = (0.5-hash33(sp))*fre*0.35;\r\n\t    //texCol = clamp(texCol + aniso, 0., 1.);\r\n\r\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\r\n\t    float shading = crv * 0.5 + 0.5; \r\n\r\n    \t// Combing the above terms to produce the final color. It was based more on acheiving a\r\n        // certain aesthetic than science.\r\n\r\n#if defined(ENABLE_GLOW)\r\n        sceneCol = getGrey(texCol)*( (diff+diff2)*0.75 + ambience*0.25 ) + (spec + spec2)*texCol*1.5 + fre*crv*texCol.zyx*2.0;\r\n#elif defined(ENABLE_SHINY)\r\n        sceneCol = texCol*((diff+diff2)*vec3(1.0, 0.95, 0.9) + ambience + fre*fre*texCol) + (spec+spec2);\r\n#endif\r\n        // if( sp.y > -0.995 ) sceneCol += (spec + spec2)*texCol*0.5;\r\n\r\n        // Shading\r\n        sceneCol *= atten * shading * ao;\r\n\r\n#ifdef ENABLE_EDGE_EFFECT\r\n        // sceneCol *= saturate(1.0-abs(curve(sp, 0.01))); // add dense edges\r\n        sceneCol *= pow( saturate(1.0-(curve(sp, 0.0125))), 0.5); // add thick edges\r\n#endif\r\n\t}\r\n    else gl_FragDepth = 0.99;\r\n\r\n\t// fragColor = vec4( saturate(sceneCol), 1.0 );\r\n    fragColor = LinearToGamma( vec4( saturate(sceneCol), 1.0), 0.7 ); // jamie\r\n}\r\n\r\nvoid main()\r\n{\r\n    mainImage( gl_FragColor, gl_FragCoord.xy );\r\n}'},function(e,t){e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_SEA_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst vec3 SUN_LIGHT = normalize( vec3(0.4, 0.4, 0.48) );\r\n\r\nvec2 sceneMap( in vec3 p ){ return vec2(0.0); }\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( out vec3 ro, out vec3 rd )\r\n{\r\n    vec3 ta = vec3(0.0, -0.5, 0.0);\r\n    ta.x -= time * 0.75;//0.5\r\n    ro = ta + vec3(1.5);//2.0\r\n    \r\n    float fHeading = time * 0.15;//0.1\r\n    float dist = 1.5 - cos(time * 0.1 + 2.0) * 0.8;\r\n\r\n    ro.x += sin( fHeading ) * dist;\r\n    ro.z += cos( fHeading ) * dist;\r\n    ro.y += 1.0 + dist * dist * 0.01;\r\n\r\n    // camera ray direction\r\n    float fl = 1.0;//1.5 2.0\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    // mixing = sky + sea\r\n    float FAR = 1000.0;\r\n    vec3 sky = skyColor( SUN_LIGHT, rd, 1.0 );\r\n    vec3 sea = seaColor( SUN_LIGHT, ro, rd, FAR );\r\n    vec3 color = mix( sky, sea, pow( smoothstep(0.0, -0.05, rd.y), 0.3) );\r\n\r\n    // post-processing\r\n    gl_FragColor = LinearToGamma( vec4(color, 1.0), 1.2 ); // 2.2 => 1.2\r\n}'},function(e,t){e.exports="//==============================================================================\r\n//\r\n// Microsurface (roughness or glossiness)\r\n// -metalness workflow: setting a metalness value or creating a metalness map(1 for metal, 0 for non-metal)\r\n// -specular workflow: setting a specular value or creating a specular map(color and intensity of the reflected light)\r\n//\r\n// Diffuse(albedo or base color): \r\n// -constant value (= Gold(1.000, 0.766, 0.336), Silver(0.972, 0.960, 0.915), Copper(0.955, 0.637, 0.538)...)\r\n// -diffuse map texture\r\n//\r\n// Metalness:\r\n// -single value (metal (1) or non-metal(0))\r\n// -metalness map (= define specific areas of your material as metal or non-metal)\r\n//\r\n// Glossiness:\r\n// -blurry or sharp the reflections on the material (or how broad or narrow the specular highlights are)\r\n// -single value between (0-100) or a glossiness map\r\n// (*The roughness is the inverse of the glossiness)\r\n//\r\n// Additional properties: Ambient Occulusion, Emissive, Opacity, Normal and Height maps\r\n//\r\n//==============================================================================\r\n\r\n#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n\r\n//#undef STANDARD\r\n#define USE_RAY_SHADOW\r\n#define USE_RAY_AO\r\n\r\n#ifndef RAYMARCH_LIGHTS\r\n#define RAYMARCH_LIGHTS\r\n\r\nuniform samplerCube envMap;\r\n// uniform sampler2D envMap;\r\n\r\n// NOTE: MAX_TEXTURE_IMAGE_UNITS = 16 supported for WebGL1\r\n#define MAX_MATERIALS    4\r\n\r\nuniform int useAlbedoMaps[ MAX_MATERIALS ];\r\n//uniform int useNormalMaps[ MAX_MATERIALS ];\r\nuniform int useMetalnessMaps[ MAX_MATERIALS ];\r\nuniform int useRoughnessMaps[ MAX_MATERIALS ];\r\n//uniform int useAoMaps[ MAX_MATERIALS ];\r\n\r\nuniform sampler2D albedoMaps[ MAX_MATERIALS ];\r\n//uniform sampler2D normalMaps[ MAX_MATERIALS ];\r\nuniform sampler2D metalnessMaps[ MAX_MATERIALS ];\r\nuniform sampler2D roughnessMaps[ MAX_MATERIALS ];\r\n//uniform sampler2D aoMaps[ MAX_MATERIALS ];\r\n\r\nuniform vec3 albedos[ MAX_MATERIALS ];\r\nuniform float metalnesss[ MAX_MATERIALS ];\r\nuniform float roughnesss[ MAX_MATERIALS ];\r\n//uniform float aos[ MAX_MATERIALS ];\r\n\r\n// see distances.glsl for these definitions\r\nfloat sceneShadow( in vec3 ro, in vec3 rd );\r\nfloat sceneAO( vec3 p, vec3 n );\r\n\r\n//==============================================================================\r\n\r\n#define PHYSICAL\r\n#define PHYSICALLY_CORRECT_LIGHTS\r\n#define STANDARD\r\n\r\n#define USE_ENVMAP\r\n#define ENVMAP_TYPE_CUBE        // uniform samplerCube envMap;\r\n// #define ENVMAP_TYPE_CUBE_UV  // uniform sampler2D envMap;\r\n#define ENVMAP_MODE_REFLECTION\r\n\r\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n\tconst float reflectivity = 1.0;\r\n\tconst float envMapIntensity = 1.0;\r\n#endif\r\n\r\n#ifdef USE_ENVMAP\r\n    const float flipEnvMap = 1.0; //-1.0\r\n    const int maxMipLevel = 6;\r\n#endif\r\n\r\nstruct IncidentLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n\tbool visible;\r\n};\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\nstruct GeometricContext {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tvec3 viewDir;\r\n};\r\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n}\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n}\r\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\r\n\treturn - distance * planeNormal + point;\r\n}\r\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\r\n}\r\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\r\n}\r\nmat3 transposeMat3( const in mat3 m ) {\r\n\tmat3 tmp;\r\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\r\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\r\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\r\n\treturn tmp;\r\n}\r\nfloat linearToRelativeLuminance( const in vec3 color ) {\r\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\r\n\treturn dot( weights, color.rgb );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\tif( decayExponent > 0.0 ) {\r\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\r\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\r\n#else\r\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\r\n#endif\r\n\t}\r\n\treturn 1.0;\r\n}\r\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n}\r\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\r\n}\r\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\treturn 1.0 / ( gl * gv );\r\n}\r\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\treturn 0.5 / max( gv + gl, EPSILON );\r\n}\r\nfloat D_GGX( const in float alpha, const in float dotNH ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\r\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\r\n}\r\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\tfloat alpha = pow2( roughness );\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\treturn F * ( G * D );\r\n}\r\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\r\n\tconst float LUT_SIZE  = 64.0;\r\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\r\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\r\n\tfloat dotNV = saturate( dot( N, V ) );\r\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\r\n\tuv = uv * LUT_SCALE + LUT_BIAS;\r\n\treturn uv;\r\n}\r\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\r\n\tfloat l = length( f );\r\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\r\n}\r\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\r\n\tfloat x = dot( v1, v2 );\r\n\tfloat y = abs( x );\r\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\r\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\r\n\tfloat v = a / b;\r\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\r\n\treturn cross( v1, v2 ) * theta_sintheta;\r\n}\r\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\r\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\r\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\r\n\tvec3 lightNormal = cross( v1, v2 );\r\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\r\n\tvec3 T1, T2;\r\n\tT1 = normalize( V - N * dot( V, N ) );\r\n\tT2 = - cross( N, T1 );\r\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\r\n\tvec3 coords[ 4 ];\r\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\r\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\r\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\r\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\r\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\r\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\r\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\r\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\r\n\tvec3 vectorFormFactor = vec3( 0.0 );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\r\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\r\n\treturn vec3( result );\r\n}\r\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\nfloat G_BlinnPhong_Implicit( ) {\r\n\treturn 0.25;\r\n}\r\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n}\r\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\tfloat G = G_BlinnPhong_Implicit( );\r\n\tfloat D = D_BlinnPhong( shininess, dotNH );\r\n\treturn F * ( G * D );\r\n}\r\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\r\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\r\n}\r\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\r\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\r\n}\r\n\r\n// #ifdef ENVMAP_TYPE_CUBE_UV\r\n// #define cubeUV_textureSize (1024.0)\r\n// int getFaceFromDirection(vec3 direction) {\r\n// \tvec3 absDirection = abs(direction);\r\n// \tint face = -1;\r\n// \tif( absDirection.x > absDirection.z ) {\r\n// \t\tif(absDirection.x > absDirection.y )\r\n// \t\t\tface = direction.x > 0.0 ? 0 : 3;\r\n// \t\telse\r\n// \t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n// \t}\r\n// \telse {\r\n// \t\tif(absDirection.z > absDirection.y )\r\n// \t\t\tface = direction.z > 0.0 ? 2 : 5;\r\n// \t\telse\r\n// \t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n// \t}\r\n// \treturn face;\r\n// }\r\n// #define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\r\n// #define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\r\n// vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\r\n// \tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\r\n// \tfloat dxRoughness = dFdx(roughness);\r\n// \tfloat dyRoughness = dFdy(roughness);\r\n// \tvec3 dx = dFdx( vec * scale * dxRoughness );\r\n// \tvec3 dy = dFdy( vec * scale * dyRoughness );\r\n// \tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\r\n// \td = clamp(d, 1.0, cubeUV_rangeClamp);\r\n// \tfloat mipLevel = 0.5 * log2(d);\r\n// \treturn vec2(floor(mipLevel), fract(mipLevel));\r\n// }\r\n// #define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\r\n// #define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\r\n// vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\r\n// \tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\r\n// \tfloat a = 16.0 * cubeUV_rcpTextureSize;\r\n// \tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\r\n// \tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\r\n// \tfloat powScale = exp2_packed.x * exp2_packed.y;\r\n// \tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\r\n// \tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\r\n// \tbool bRes = mipLevel == 0.0;\r\n// \tscale =  bRes && (scale < a) ? a : scale;\r\n// \tvec3 r;\r\n// \tvec2 offset;\r\n// \tint face = getFaceFromDirection(direction);\r\n// \tfloat rcpPowScale = 1.0 / powScale;\r\n// \tif( face == 0) {\r\n// \t\tr = vec3(direction.x, -direction.z, direction.y);\r\n// \t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 1) {\r\n// \t\tr = vec3(direction.y, direction.x, direction.z);\r\n// \t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 2) {\r\n// \t\tr = vec3(direction.z, direction.x, direction.y);\r\n// \t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 3) {\r\n// \t\tr = vec3(direction.x, direction.z, direction.y);\r\n// \t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \telse if( face == 4) {\r\n// \t\tr = vec3(direction.y, direction.x, -direction.z);\r\n// \t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \telse {\r\n// \t\tr = vec3(direction.z, -direction.x, direction.y);\r\n// \t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \tr = normalize(r);\r\n// \tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\r\n// \tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\r\n// \tvec2 base = offset + vec2( texelOffset );\r\n// \treturn base + s * ( scale - 2.0 * texelOffset );\r\n// }\r\n// #define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\r\n// vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\r\n// \tfloat roughnessVal = roughness * cubeUV_maxLods3;\r\n// \tfloat r1 = floor(roughnessVal);\r\n// \tfloat r2 = r1 + 1.0;\r\n// \tfloat t = fract(roughnessVal);\r\n// \tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\r\n// \tfloat s = mipInfo.y;\r\n// \tfloat level0 = mipInfo.x;\r\n// \tfloat level1 = level0 + 1.0;\r\n// \tlevel1 = level1 > 5.0 ? 5.0 : level1;\r\n// \tlevel0 += min( floor( s + 0.5 ), 5.0 );\r\n// \tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\r\n// \tvec4 color10 = envMapTexelToLinear(texture(envMap, uv_10));\r\n// \tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\r\n// \tvec4 color20 = envMapTexelToLinear(texture(envMap, uv_20));\r\n// \tvec4 result = mix(color10, color20, t);\r\n// \treturn vec4(result.rgb, 1.0);\r\n// }\r\n// #endif\r\n#ifdef ENVMAP_TYPE_CUBE_UV\r\n#define cubeUV_maxMipLevel 8.0\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_maxTileSize 256.0\r\n#define cubeUV_minTileSize 16.0\r\n// These shader functions convert between the UV coordinates of a single face of\r\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\r\n// sampling a textureCube (not generally normalized).\r\nfloat getFace(vec3 direction) {\r\n    vec3 absDirection = abs(direction);\r\n    float face = -1.0;\r\n    if (absDirection.x > absDirection.z) {\r\n      if (absDirection.x > absDirection.y)\r\n        face = direction.x > 0.0 ? 0.0 : 3.0;\r\n      else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    } else {\r\n      if (absDirection.z > absDirection.y)\r\n        face = direction.z > 0.0 ? 2.0 : 5.0;\r\n      else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\nvec2 getUV(vec3 direction, float face) {\r\n    vec2 uv;\r\n    if (face == 0.0) {\r\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\r\n    } else if (face == 1.0) {\r\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\r\n    } else if (face == 2.0) {\r\n      uv = direction.xy / abs(direction.z);\r\n    } else if (face == 3.0) {\r\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\r\n    } else if (face == 4.0) {\r\n      uv = direction.xz / abs(direction.y);\r\n    } else {\r\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\r\n    }\r\n    return 0.5 * (uv + 1.0);\r\n}\r\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\r\n  float face = getFace(direction);\r\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\r\n  mipInt = max(mipInt, cubeUV_minMipLevel);\r\n  float faceSize = exp2(mipInt);\r\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\r\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\r\n  vec2 f = fract(uv);\r\n  uv += 0.5 - f;\r\n  if (face > 2.0) {\r\n    uv.y += faceSize;\r\n    face -= 3.0;\r\n  }\r\n  uv.x += face * faceSize;\r\n  if(mipInt < cubeUV_maxMipLevel){\r\n    uv.y += 2.0 * cubeUV_maxTileSize;\r\n  }\r\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\r\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\r\n  uv *= texelSize;\r\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.x += texelSize;\r\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.y += texelSize;\r\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.x -= texelSize;\r\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  vec3 tm = mix(tl, tr, f.x);\r\n  vec3 bm = mix(bl, br, f.x);\r\n  return mix(tm, bm, f.y);\r\n}\r\n// These defines must match with PMREMGenerator\r\n#define r0 1.0\r\n#define v0 0.339\r\n#define m0 -2.0\r\n#define r1 0.8\r\n#define v1 0.276\r\n#define m1 -1.0\r\n#define r4 0.4\r\n#define v4 0.046\r\n#define m4 2.0\r\n#define r5 0.305\r\n#define v5 0.016\r\n#define m5 3.0\r\n#define r6 0.21\r\n#define v6 0.0038\r\n#define m6 4.0\r\nfloat roughnessToMip(float roughness) {\r\n  float mip = 0.0;\r\n  if (roughness >= r1) {\r\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\r\n  } else if (roughness >= r4) {\r\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\r\n  } else if (roughness >= r5) {\r\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\r\n  } else if (roughness >= r6) {\r\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\r\n  } else {\r\n    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\r\n  }\r\n  return mip;\r\n}\r\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\r\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\r\n  float mipF = fract(mip);\r\n  float mipInt = floor(mip);\r\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\r\n  if (mipF == 0.0) {\r\n    return vec4(color0, 1.0);\r\n  } else {\r\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\r\n    return vec4(mix(color0, color1, mipF), 1.0);\r\n  }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n\r\nuniform vec3 ambientLightColor;\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\tvec3 irradiance = ambientLightColor;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\treturn irradiance;\r\n}\r\n#if NUM_DIR_LIGHTS > 0\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t};\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\t}\r\n#endif\r\n#if NUM_POINT_LIGHTS > 0\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t\t// float shadowCameraNear;\r\n\t\t// float shadowCameraFar;\r\n\t};\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\t}\r\n#endif\r\n#if NUM_SPOT_LIGHTS > 0\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t};\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\t\t} else {\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\t\t}\r\n\t}\r\n#endif\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\tuniform sampler2D ltc_1;\r\n    uniform sampler2D ltc_2;\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n#endif\r\n#if NUM_HEMI_LIGHTS > 0\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\t\tirradiance *= PI;\r\n\t\t#endif\r\n\t\treturn irradiance;\r\n\t}\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\r\n\t\t#else\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\t\t#endif\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\t}\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\t}\r\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\t\t#else\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\t\t#endif\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent) );\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#endif\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\t}\r\n#endif\r\n\r\n//==============================================================================\r\n\r\nstruct PhysicalMaterial {\r\n\tvec3\tdiffuseColor;\r\n    float   metalness;      // added\r\n\tfloat\tspecularRoughness;\r\n\tvec3\tspecularColor;\r\n\t// #ifndef STANDARD\r\n\t// \tfloat clearCoat;\r\n\t// \tfloat clearCoatRoughness;\r\n\t// #endif\r\n};\r\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\r\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\r\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\r\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\r\n}\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\t\tvec3 normal = geometry.normal;\r\n\t\tvec3 viewDir = geometry.viewDir;\r\n\t\tvec3 position = geometry.position;\r\n\t\tvec3 lightPos = rectAreaLight.position;\r\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\r\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\r\n\t\tvec3 lightColor = rectAreaLight.color;\r\n\t\tfloat roughness = material.specularRoughness;\r\n\t\tvec3 rectCoords[ 4 ];\r\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\r\n        rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\r\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\r\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\r\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\r\n\t\tvec4 t1 = texture( ltc_1, uv );\r\n\t\tvec4 t2 = texture( ltc_2, uv );\r\n\t\tmat3 mInv = mat3(\r\n\t\t\tvec3( t1.x, 0, t1.y ),\r\n\t\t\tvec3(    0, 1,    0 ),\r\n\t\t\tvec3( t1.z, 0, t1.w )\r\n\t\t);\r\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\r\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\r\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\r\n\t}\r\n#endif\r\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\tvec3 irradiance = dotNL * directLight.color;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\t#ifndef STANDARD\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\r\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\t#ifndef STANDARD\r\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\t#endif\r\n}\r\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n}\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\t#ifndef STANDARD\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\t\tfloat dotNL = dotNV;\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\r\n\t#ifndef STANDARD\r\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\t#endif\r\n}\r\n#define RE_Direct\t\t\t\tRE_Direct_Physical\r\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\r\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\r\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\r\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\r\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\r\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\r\n}\r\n\r\n#ifdef USE_BUMPMAP\r\n\tuniform sampler2D bumpMap;\r\n\tuniform float bumpScale;\r\n\tvec2 dHdxy_fwd() {\r\n\t\tvec2 dSTdx = dFdx( vUv );\r\n\t\tvec2 dSTdy = dFdy( vUv );\r\n\t\tfloat Hll = bumpScale * texture( bumpMap, vUv ).x;\r\n\t\tfloat dBx = bumpScale * texture( bumpMap, vUv + dSTdx ).x - Hll;\r\n\t\tfloat dBy = bumpScale * texture( bumpMap, vUv + dSTdy ).x - Hll;\r\n\t\treturn vec2( dBx, dBy );\r\n\t}\r\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\r\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\r\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\r\n\t\tvec3 vN = surf_norm;\r\n\t\tvec3 R1 = cross( vSigmaY, vN );\r\n\t\tvec3 R2 = cross( vN, vSigmaX );\r\n\t\tfloat fDet = dot( vSigmaX, R1 );\r\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\r\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\r\n\t}\r\n#endif\r\n\r\n#ifdef USE_NORMALMAP\r\n\tuniform sampler2D normalMap;\r\n\tuniform vec2 normalScale;\r\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\r\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n\t\tvec2 st0 = dFdx( vUv.st );\r\n\t\tvec2 st1 = dFdy( vUv.st );\r\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n\t\tvec3 N = normalize( surf_norm );\r\n\t\tvec3 mapN = texture( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n\t\tmapN.xy = normalScale * mapN.xy;\r\n\t\tmat3 tsn = mat3( S, T, N );\r\n\t\treturn normalize( tsn * mapN );\r\n\t}\r\n#endif\r\n\r\n//==============================================================================\r\n// Physical lighting...\r\n//==============================================================================\r\n\r\nvec3 FresnelSchlickRoughness( float cosTheta, vec3 F0, float roughness )\r\n// consider surface roughness when calculating indirect diffuse\r\n{\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\nvec4 getPBRColor( in vec3 p, in vec3 n, in vec3 v, in PhysicalMaterial material )\r\n// p = hitted position\r\n// n = normal at p\r\n// v = view (= -rd) at p\r\n// material = material at p\r\n{\r\n    // Hitted material\r\n    vec3 emissiveRadiance = vec3(0.0);//material.emissiveColor;\r\n    float opacity = 1.0;\r\n    vec4 diffuseColor = vec4( material.diffuseColor, opacity );//material.opacity\r\n\r\n    // Hitted geometry\r\n    GeometricContext geometry;\r\n    geometry.position = p;\r\n    geometry.normal = n;\r\n    geometry.viewDir = v;//normalize(-rd);\r\n\r\n    IncidentLight directLight;\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissiveRadiance;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tPointLight pointLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n        pointLight = pointLights[ i ];\r\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible )  directLight.color *= sceneShadow( geometry.position, pointLight.position-geometry.position );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tSpotLight spotLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n        spotLight = spotLights[ i ];\r\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible ) directLight.color *= sceneShadow( geometry.position, spotLight.position-geometry.position );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tDirectionalLight directionalLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n        directionalLight = directionalLights[ i ];\r\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible ) directLight.color *= sceneShadow( geometry.position, directionalLight.direction );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\tRectAreaLight rectAreaLight;\r\n\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n        rectAreaLight = rectAreaLights[ i ];\r\n        RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n    #if ( NUM_HEMI_LIGHTS > 0 )\r\n        #pragma unroll_loop\r\n        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n        }\r\n    #endif\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearCoatRadiance = vec3( 0.0 );\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\t// #ifdef USE_LIGHTMAP\r\n\t// \tvec3 lightMapIrradiance = texture( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\t// \t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t// \t\tlightMapIrradiance *= PI;\r\n\t// \t#endif\r\n\t// \tirradiance += lightMapIrradiance;\r\n\t// #endif\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\r\n\t#endif\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\r\n\t#ifndef STANDARD\r\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\r\n\t#endif\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\r\n#endif\r\n\r\n#if 1\r\n    // adding surface roughness when calculating indirect diffuse...\r\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n    vec3 F = FresnelSchlickRoughness(dotNV, material.specularColor, material.specularRoughness);\r\n    reflectedLight.indirectDiffuse *= (1.0 - F);\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\r\n#endif\r\n\r\n#ifdef USE_RAY_AO\r\n    //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n    float diffuseAO = sceneAO( geometry.position, geometry.normal );\r\n    float specularAO = saturate( pow(dotNV + diffuseAO, pow2(material.specularRoughness)) - 1.0 + diffuseAO);\r\n    reflectedLight.indirectDiffuse *= diffuseAO;\r\n    reflectedLight.indirectSpecular *= specularAO;\r\n#endif\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\treturn vec4( outgoingLight, diffuseColor.a );\r\n\r\n// #if defined( TONE_MAPPING )\r\n//   gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n// #endif\r\n\r\n//   gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n\r\n// #ifdef USE_FOG\r\n// \t#ifdef FOG_EXP2\r\n// \t\tfloat fogFactor = whiteComplement( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\r\n// \t#else\r\n// \t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\r\n// \t#endif\r\n// \tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\r\n// #endif\r\n\r\n// #ifdef PREMULTIPLIED_ALPHA\r\n// \tgl_FragColor.rgb *= gl_FragColor.a;\r\n// #endif\r\n\r\n// #if defined( DITHERING )\r\n//   gl_FragColor.rgb = dithering( gl_FragColor.rgb );\r\n// #endif\r\n}\r\n\r\n#endif // RAYMARCH_LIGHTS\r\n\r\n//==============================================================================\r\n\r\n// numMaterials: must be <= 4\r\n#define numMaterials    4\r\n\r\n// Choose...\r\n#define ENABLE_BUMP_NORMAL\r\n#define ENABLE_FOG\r\n#define ENABLE_REFLECT_PASS\r\n\r\n// Choose one of these demos...\r\n#define ENABLE_DEMO_ROUGH_METAL\r\n//#define ENABLE_DEMO_PBR_MATERIALS\r\n//#define ENABLE_DEMO_PRIMITIVES\r\n\r\n// floor material\r\n#define MTL_FLOOR       100.0\r\n#define FLOOR_COLOR     checkerColor(p, 5.0, 0.6)\r\n\r\n#ifdef ENABLE_FOG\r\nconst float fogDensity = 0.001;\r\nconst vec3 fogColor = vec3(0.56, 0.64, 0.8);\r\n#endif\r\n\r\n// const vec3 cGold = vec3(1.000, 0.766, 0.336);\r\n// const vec3 cSilver = vec3(0.972, 0.960, 0.915);\r\n// const vec3 cCopper = vec3(0.955, 0.637, 0.538);\r\n// const vec3 cIron = vec3(0.56, 0.57, 0.58);\r\n// const vec3 cAluminium = vec3(0.913, 0.921, 0.925);\r\n// const vec3 Chromium = vec3(0.550, 0.556, 0.554);\r\n// const vec3 Nickel = vec3(0.660, 0.609, 0.526);\r\n// const vec3 Titanium = vec3(0.542, 0.497, 0.449);\r\n// const vec3 Cobalt = vec3(0.662, 0.655, 0.634);\r\n// const vec3 Platinum = vec3(0.672, 0.637, 0.585);\r\n\r\n\r\n//==============================================================================\r\n// Scene Modeling\r\n//==============================================================================\r\n\r\nvec2 simpleScene(vec3 p)\r\n{\r\n    // // one sphere\r\n    // vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    // float r = 0.5;\r\n    // vec3 c = vec3(0.0, r, 0.0);\r\n    // vec2 sph = vec2(fSphere(p - c, r), 0.0);\r\n    // res = dUnion(res, sph);\r\n    // return res;\r\n\r\n    // smooth union\r\n    vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    float k = 0.1;\r\n\tvec3 tp = sTranslate( p, vec3(0.0, 2.0, 0.0) );\r\n\tvec2 dcy1 = vec2( fCylinder(tp, vec2(1.0, 2.0)), 0.0 );\r\n\tvec2 dcy2 = vec2( fCylinder(tp.yzx, vec2(0.5, 2.0)), 1.0 );\r\n\t//res = dUnion( res, dSmoothUnion( dcy1, dcy2, k ) );\r\n    res = dUnion( res, dSmoothSubtract( dcy1, dcy2, k ) );\r\n    return res;\r\n}\r\n\r\n#ifdef ENABLE_DEMO_ROUGH_METAL\r\nvec2 demoRoughMetalScene(vec3 p)\r\n{\r\n    vec2 res = vec2( fPlane(p), MTL_FLOOR ); // floor\r\n\r\n    const int nx = 7, ny = 7;\r\n    float r = 0.25;\r\n    float m = 0.0;\r\n\r\n    float dx = 3.0*r, dy = 3.0*r;\r\n    float x, x0 = -(float(nx)/2.0-0.5)*dx;\r\n    float y, y0 = r;\r\n\r\n    for(int j = 0; j < ny; j++) {\r\n        y = y0 + float(j)*dy;\r\n        for(int i = 0; i < nx; i++) {\r\n            x = x0 + float(i)*dx;\r\n            res = dUnion( res, vec2( fSphere(p-vec3(x, y, 0.0), r), m ) );\r\n            m = m + 1.0;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_DEMO_PBR_MATERIALS\r\nvec2 demoPBRMaterialsScene(vec3 p)\r\n{\r\n    vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    float r = 0.5;\r\n    //float dr = 0.0;\r\n    float dr = 0.2;\r\n    float dx = (r + dr)*2.0;\r\n    float x0 = (float(numMaterials)-1.0) / -2.0;\r\n    for(int i = 0; i < numMaterials; i++) {\r\n        vec3 c = vec3( x0 + float(i)*dx, r, 0.0 );\r\n        vec2 sph = vec2(fSphere(p - c, r), float(i));\r\n        res = dUnion(res, sph);\r\n    }\r\n    return res;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_DEMO_PRIMITIVES\r\nvec2 demoPrimitivesScene(vec3 p)\r\n{\r\n    // 21 objects + 1 floor\r\n    float m = 0.0;\r\n    vec2 res = dUnion( vec2( fPlane(     p), MTL_FLOOR ),\r\n\t                   vec2( fSphere(    p-vec3( 0.0,0.25, 0.0), 0.25 ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fBox(       p-vec3( 1.0,0.25, 0.0), vec3(0.25) ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( uRoundBox(  p-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus(     p-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), m ) );  m += 1.0;\r\n    res = dUnion( res, vec2( fCapsule(   p,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTriPrism(  p-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCylinder(  p-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCone(      p-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus82(   p-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus88(   p-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCylinder6( p-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), m ) );  m += 1.0;\r\n\tres = dUnion( res, vec2( fHexPrism(  p-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fPryamid4(  p-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ), m ) );  m += 1.0;\r\n    res = dUnion( res, dSubtract( vec2(  uRoundBox(p-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05), m),\r\n\t                              vec2(  fSphere(p-vec3(-2.0,0.2, 1.0), 0.25), m+1.0) ) ); m += 2.0;\r\n    res = dUnion( res, dSubtract( vec2(  fTorus82(p-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), m),\r\n\t                              vec2(  fCylinder(sRepeat(vec3(atan(p.x+2.0,p.z)/6.2831, p.y, 0.02+0.5*length(p-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6)), m+1.0) )); m += 2.0;\r\n\tres = dUnion( res, vec2( 0.5*fSphere( p-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*p.x)*sin(50.0*p.y)*sin(50.0*p.z), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( 0.5*fTorus(  sTwist(p-vec3(-2.0,0.25,2.0), 10.0), vec2(0.20,0.05)), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fConeSection(p-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fEllipsoid(  p-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), m ) ); m += 1.0;\r\n    return res;\r\n}\r\n#endif\r\n\r\nvec2 sceneMap(vec3 p)\r\n{\r\n#if defined(ENABLE_DEMO_ROUGH_METAL)\r\n    return demoRoughMetalScene(p);\r\n\r\n#elif defined(ENABLE_DEMO_PBR_MATERIALS)\r\n    return demoPBRMaterialsScene(p);\r\n\r\n#elif defined(ENABLE_DEMO_PRIMITIVES)\r\n    return demoPrimitivesScene(p);\r\n\r\n#else\r\n    return simpleScene(p);\r\n\r\n#endif\r\n}\r\n\r\n//==============================================================================\r\n// Material\r\n//==============================================================================\r\n\r\nvoid getPBRMaterial( in float m, in vec3 p, in vec3 n, out PhysicalMaterial material )\r\n{\r\n    //------------------------------------------------------\r\n    vec3 baseColor = vec3(1.0);         // default baseColor\r\n    float metalness = 0.1;//1.0;           // default metalness\r\n    float roughness = 0.1;//0.04;  // default roughness\r\n    //------------------------------------------------------\r\n\r\n    if( m == MTL_FLOOR )\r\n    {\r\n        baseColor = FLOOR_COLOR;\r\n        metalness = 0.1;\r\n        roughness = 0.1;\r\n    }\r\n    else\r\n    {\r\n//------------------------------------------------------\r\n#if defined(ENABLE_DEMO_ROUGH_METAL)\r\n        baseColor = vec3(1.0, 1.0, 1.0);\r\n        float nx = 7.0, ny = 7.0;\r\n        metalness = floor(m/nx) / (ny-1.0); // metalness = [0,1] along yaxis\r\n        roughness = mod(m,nx) / (nx-1.0);   // roughness = [0,1] along xaxis\r\n\r\n//------------------------------------------------------\r\n#elif defined(ENABLE_DEMO_PRIMITIVES)\r\n        baseColor = hsl2rgb( vec3( m/21.0, 1.0, 0.5) );\r\n        metalness = 0.7;//m/21.0;\r\n        roughness = n.y;\r\n\r\n//------------------------------------------------------\r\n#else\r\n        for(int i = 0; i<numMaterials; i++)\r\n        {\r\n            if( int(m) == i ) {\r\n                vec3 texCol = pow( texCube(albedoMaps[i], p, n).rgb, vec3(2.2) );\r\n                baseColor = mix( albedos[i], texCol, float(useAlbedoMaps[i]) );\r\n                metalness = mix( metalnesss[i],  texCube(metalnessMaps[i], p, n).r, float(useMetalnessMaps[i]) );\r\n                roughness = mix( roughnesss[i], texCube(roughnessMaps[i], p, n).r, float(useRoughnessMaps[i]) );\r\n                break;\r\n            }\r\n        }\r\n#endif\r\n//------------------------------------------------------\r\n    }\r\n\r\n    // material.metalness\r\n    material.metalness = clamp( metalness, 0.0, 1.0 );\r\n\r\n    // material.specularRoughness <== roughness (0.04 ~ 1.0)\r\n    material.specularRoughness = clamp( roughness, 0.04, 1.0 );\r\n\r\n    // material.diffuseColor <== baseColor + metalness\r\n    material.diffuseColor = baseColor.rgb * ( 1.0 - material.metalness );\r\n\r\n    // material.specularColor <== baseColor + metalness\r\n    #ifdef STANDARD\r\n        material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), baseColor.rgb, material.metalness );\r\n    #else\r\n        float reflectivity = 0.5; // maps to F0 = 0.04\r\n        material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), baseColor.rgb, material.metalness );\r\n        material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\r\n        material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\r\n    #endif\r\n}\r\n\r\n//==============================================================================\r\n// Post-Effects\r\n//==============================================================================\r\n\r\n#ifdef ENABLE_BUMP_NORMAL\r\nvec3 getBumpNormal( in float m, in vec3 p, in vec3 n, float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    // cf: array index for samplers must be constant integral expressions\r\n    vec3 normal;\r\n    int i = int( m ); // assume: numMaterials = 4\r\n\r\n    if( i == 0 ) normal = getBumpNormal( albedoMaps[ 0 ], p, n, bumpFactor );\r\n    else if( i == 1 ) normal = getBumpNormal( albedoMaps[ 1 ], p, n, bumpFactor );\r\n    else if( i == 2 ) normal = getBumpNormal( albedoMaps[ 2 ], p, n, bumpFactor );\r\n    else if( i == 3 ) normal = getBumpNormal( albedoMaps[ 3 ], p, n, bumpFactor );\r\n    else normal = n;\r\n\r\n    return normal;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_FOG\r\nvec3 applyFog( in vec3 color, in vec3 fogColor, in float fogDensity, in float fogDepth )\r\n{\r\n    float fogFactor = exp2( -fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );//LOG2 = 1.442695\r\n    fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\r\n\treturn mix( color, fogColor, fogFactor );\r\n}\r\n#endif\r\n\r\nvoid doPostEffects( inout vec4 color, in float fogDepth )\r\n{\r\n    color.rgb = FilmicToneMapping( color.rgb );\r\n\r\n#ifdef ENABLE_FOG\r\n    color.rgb = applyFog( color.rgb, fogColor, fogDensity, fogDepth );\r\n#endif\r\n\r\n    color = LinearToGamma( color, 2.2 ); // gammaFactor = 2.2\r\n\r\n    color.rgb *= color.a;\r\n\r\n    color.rgb = Dithering( color.rgb );\r\n}\r\n\r\n//==============================================================================\r\n// Rendering\r\n//==============================================================================\r\n\r\nvec4 render(in vec3 ro, in vec3 rd, out float t)\r\n{\r\n    vec4 color = vec4(0.0);\r\n\r\n    // hit.xy = (distance, material)\r\n    vec2 hit = rayMarching(ro, rd);\r\n    t = hit.x;\r\n    float m = hit.y;\r\n\r\n    gl_FragDepth = 1.0;\r\n\r\n    // hit something in the scene\r\n    if (m >= 0.0)\r\n    {\r\n        vec3 p = ro + t * rd;\r\n        vec3 n = sceneNormal(p);\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        PhysicalMaterial material;\r\n        getPBRMaterial( m, p, n, material );\r\n\r\n        #ifdef ENABLE_BUMP_NORMAL\r\n            n = getBumpNormal( m, p, n, material.specularRoughness * 0.01 );\r\n        #endif\r\n\r\n        color = getPBRColor( p, n, -rd, material );\r\n\r\n        #ifdef ENABLE_REFLECT_PASS\r\n        if( material.metalness > 0.0 )\r\n        {\r\n            vec3 r = reflect(rd, n);\r\n            vec2 hit2 = rayMarching(p, r);\r\n            m = hit2.y;\r\n            if( m >= 0.0 )\r\n            {\r\n                p += r * hit2.x;\r\n                n = sceneNormal(p);\r\n\r\n                PhysicalMaterial material2;\r\n                getPBRMaterial( m, p, n, material2 );\r\n\r\n                float gloss = material.metalness;\r\n                gloss *= (1.0 - material.specularRoughness);\r\n                gloss *= 0.35 / (1.0 + hit2.x * hit2.x);\r\n                color += getPBRColor( p, n, -r, material2 ) * gloss;\r\n            }\r\n        }\r\n        #endif\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\n//==============================================================================\r\n// Main\r\n//==============================================================================\r\n\r\nvoid main()\r\n{\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    float t;\r\n    vec4 color = render( ro, rd, t );\r\n\r\n    if( gl_FragDepth == 1.0 ) discard;\r\n\r\n    doPostEffects( color, t );\r\n\r\n    gl_FragColor = color;\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n#define iChannel0   textureMaps[0]\r\n\r\n//CBS\r\n//Parallax scrolling fractal galaxy.\r\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\r\n\r\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\r\nfloat field(in vec3 p,float s) {\r\n\tfloat strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.0;\r\n\tfloat prev = 0.0;\r\n\tfloat tw = 0.0;\r\n\tfor (int i = 0; i < 26; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-0.5, -0.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.0);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0.0, 5.0 * accum / tw - 0.7);\r\n}\r\n\r\n// less iterations for second layer\r\nfloat field2(in vec3 p, float s) {\r\n\tfloat strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.0;\r\n\tfloat prev = 0.0;\r\n\tfloat tw = 0.0;\r\n\tfor (int i = 0; i < 18; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-0.5, -0.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.0);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0.0, 5.0 * accum / tw - 0.7);\r\n}\r\n\r\nvec3 nrand3( vec2 co )\r\n{\r\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3( 1.3e5, 4.7e5, 2.9e5 ) );\r\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3( 8.1e5, 1.0e5, 0.1e5 ) );\r\n\tvec3 c = mix(a, b, 0.5);\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.0 * fragCoord.xy / resolution.xy - 1.0;\r\n\tvec2 uvs = uv * resolution.xy / max(resolution.x, resolution.y);\r\n\tvec3 p = vec3(uvs/4.0, 0.0) + vec3(1.0, -1.3, 0.0);\r\n\tp += 0.2 * vec3(sin(time / 16.0), sin(time / 12.0),  sin(time / 128.0));\r\n\r\n\tfloat freqs[4];\r\n\t// sound\r\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat t = field(p, freqs[2]);\r\n\tfloat v = (1.0 - exp((abs(uv.x) - 1.0) * 6.0)) * (1.0 - exp((abs(uv.y) - 1.0) * 6.0));\r\n\r\n    // second Layer\r\n\tvec3 p2 = vec3(uvs / (4.0 + sin(time*0.11)*0.2 + 0.2 + sin(time*0.15)*0.3 + 0.4), 1.5) + vec3(2.0, -1.3, -1.0);\r\n\tp2 += 0.25 * vec3(sin(time/16.0), sin(time/12.0), sin(time/128.0));\r\n\tfloat t2 = field2(p2, freqs[3]);\r\n\tvec4 c2 = mix(0.4, 1.0, v) * vec4(1.3*t2*t2*t2, 1.8*t2*t2, t2*freqs[0], t2);\r\n\r\n\t// let's add some stars\r\n\t// thanks to http://glsl.heroku.com/e#6904.0\r\n\tvec2 seed = p.xy * 2.0;\t\r\n\tseed = floor(seed * resolution.x);\r\n\tvec3 rnd = nrand3( seed );\r\n\tvec4 starcolor = vec4(pow(rnd.y, 27.0)); // 40.0 => 27.0\r\n\r\n\t// second Layer\r\n\tvec2 seed2 = p2.xy * 2.0;\r\n\tseed2 = floor(seed2 * resolution.x);\r\n\tvec3 rnd2 = nrand3( seed2 );\r\n\tstarcolor += vec4(pow(rnd2.y, 27.0)); // 40.0 => 27.0\r\n\r\n\tfragColor = mix(freqs[3]-0.3, 1.0, v) * vec4(1.5*freqs[2]*t*t*t, 1.2*freqs[1]*t*t, freqs[3]*t, 1.0) + c2 + starcolor;\r\n}\r\n\r\nvoid main()\r\n{\r\n    gl_FragDepth = 0.99;\r\n    mainImage( gl_FragColor, gl_FragCoord.xy );\r\n\tgl_FragColor = LinearToGamma( vec4(gl_FragColor.xyz, 1.0), 0.75 ); // jamie\r\n}"},function(e,t){e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n#define USE_CLOUDS_1\r\n#define USE_RAIN_1\r\n#define USE_FLASH_1\r\n#define USE_LENSFLARES_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// rgbaNoise256.png\r\n#define iChannel0   textureMaps[0]\r\n\r\n//==============================================================================\r\n\r\nconst vec3 SUN_LIGHT = normalize(vec3(0.35, 0.14, 0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.7, 0.55);\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\n\r\nvec2 sceneMap( in vec3 p ){ return vec2(0.0); }\r\n\r\nvoid main()\r\n{\r\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    float curTime = time*0.5;\r\n\r\n\tvec4 cloudy;\r\n\tcloudy.x = cos(curTime* 0.25)*0.5 + 0.5;\t\t// cloud amount\r\n    cloudy.yzw = flashColor( cloudy.x, curTime );\t// flash in cloudy weather\r\n\r\n\tvec3 col;\r\n\tif( rd.y > 0.0 )\r\n\t\tcol = skyCloudsColor( SUN_COLOR, SUN_LIGHT, ro, rd, cloudy );\r\n\telse\r\n\t\tcol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro, rd, cloudy ).rgb;\r\n\r\n\tvec2 xy = ndc * vec2(resolution.x/resolution.y, 1.0); // xy = [-1.77, 1.77] x [-1, 1]\r\n\tapplyLensFlares( col, ro, cameraWorldMatrix, cameraProjectionMatrixInverse, xy, SUN_COLOR, SUN_LIGHT, cloudy.x );\r\n\tapplyRain( col, iChannel0, xy, cloudy, curTime );\r\n\r\n\tcol = (col*col*(3.0-2.0*col));\r\n\tcol *= 0.55 + 0.45 * Vignetting( col, 0.8 );\r\n\tgl_FragColor = LinearToGamma( vec4(col, 1.0), 2.2 );\r\n}\r\n'},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n\r\n#define NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 20.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.2;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    //return H * sin( PI2/L * x );\r\n    float W = PI2/L;\r\n    return H*(sin(W*x) + sin(W*x*2.0));\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    //return H * W * cos(W * x);\r\n    return H*W*(cos(W*x) + 2.0*cos(W*x*2.0));\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.5*riverBaseDepth(p*2.0);\r\n    //depth += 0.25*riverBaseDepth(p*4.0);\r\n    return depth;\r\n}\r\n#define USE_WATER_2\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n// textureMaps[1] = 'images/raymarch/lichen.jpg'\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 60.0;//20.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-1.0, 0.7, 0.25));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.85, 0.5) * 5.0;//5.0;\r\nconst vec3 SKY_COLOR = vec3(0.1, 0.5, 1.0);\r\n\r\nfloat terrainHeight( vec3 p )\r\n// p.y not used...\r\n{\r\n    // terrain map\r\n    vec2 q = p.xz * vec2(0.5, 1.0);\r\n    float f = 0.0;\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for(int i=0; i<2; i++)//3\r\n    {\r\n        f += noise( q ) * a;\r\n        q *= 2.0;\r\n        tot += a;\r\n        a *= 0.5;\r\n    }\r\n    float fbm = f / tot;\r\n    float height = fbm * fbm;\r\n\r\n    // add river...\r\n    height -= riverDepth(p);\r\n\r\n    return height;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p ) // mandatory function\r\n{\r\n    return vec2( p.y - terrainHeight( p ), MATERIAL_TEXTURE1 );\r\n}\r\n\r\nvec3 getTerrainColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float t )\r\n{\r\n    // position & normal\r\n    vec3 p = ro + rd * t;\r\n    vec3 n = sceneNormal( p, EPS );\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // material\r\n    vec3 col = texCube( iChannel1, p, n ).xyz;\r\n    vec3 albedo = col*col;\r\n    float wetness = 1.0 - saturate( (p.y + 0.025) * 5.0 );\r\n    float gloss = mix( albedo.r, 1.0, wetness );\r\n    albedo = mix( albedo, albedo * 0.8, wetness );\r\n    vec3 specF0 = vec3(0.001);\r\n\r\n    // sun light ==> diffuseCol + specularCol\r\n    vec3 diffuseCol;\r\n    vec3 specularCol;\r\n    float shadow = sceneShadow( p, SUN_LIGHT, FAR*0.01, FAR*0.1, 16.0 );\r\n    getCookShading( albedo, gloss, SUN_COLOR, SUN_LIGHT, n, rd, diffuseCol, specularCol );\r\n    diffuseCol *= shadow;\r\n\r\n    // reflectCol ==> specularCol\r\n    vec3 reflectRd = reflect( rd, n );\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = 1.0;\r\n\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return result;\r\n}\r\n\r\nvec3 sceneColor( in vec3 ro,  in vec3 rd )\r\n{\r\n    vec2 hit = bisectMarching( ro, rd, 0.01, FAR );\r\n\r\n    float fogDistance;\r\n    vec3 result;\r\n\r\n    // sky\r\n    if( hit.x > FAR )\r\n    {\r\n        result = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        fogDistance = FAR;\r\n        gl_FragDepth = 0.99;\r\n    }\r\n\r\n    // water\r\n    else\r\n    {\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, SKY_COLOR, ro, rd, hit.x, FAR );\r\n        result = waterCol.xyz;\r\n        fogDistance = waterCol.w;\r\n    }\r\n\r\n    // terrain\r\n    if( result == vec3(0.0) )\r\n    {\r\n        result = getTerrainColor( SUN_COLOR, SUN_LIGHT, SKY_COLOR, ro, rd, hit.x );\r\n        fogDistance = hit.x;\r\n    }\r\n\r\n    // fog...\r\n    float fogDensity = 0.025;//0.015\r\n    vec3 fogCol = skyColor( SUN_LIGHT, rd, 0.0 );\r\n    applyFog( result, fogCol, fogDensity, fogDistance );\r\n\r\n    return result;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( out vec3 ro, out vec3 rd )\r\n{\r\n    vec3 ta = vec3(0.0, -0.5, 0.0);\r\n    ta.x -= time * 0.75;//0.5\r\n    ro = ta + vec3(1.5);//2.0\r\n    \r\n    float fHeading = time * 0.15;//0.1\r\n    float dist = 1.5 - cos(time * 0.1 + 2.0) * 0.8;\r\n\r\n    ro.x += sin( fHeading ) * dist;\r\n    ro.z += cos( fHeading ) * dist;\r\n    ro.y += 1.0 + dist * dist * 0.01;\r\n    ta.z += riverCurve( ta.x );\r\n    ro.z += riverCurve( ro.x );\r\n#if 1\r\n    // camera moves above the water\r\n    ro.y = max( ro.y, terrainHeight( ro ) + 0.2 );\r\n#else\r\n    // camera moves up and down the water\r\n    ro.y = min( ro.y, terrainHeight( ro ) + 0.5 );\r\n#endif\r\n\r\n    // camera ray direction\r\n    float fl = 1.5;//2.0\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\tvec3 ro, rd;\r\n    cameraAutoView( ro, rd );\r\n\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n#endif\r\n\r\n    vec3 result = sceneColor(ro, rd);\r\n\tresult = Vignetting( result, 0.5 );\r\n    result = FilmicToneMapping( result );\r\n    result = LinearToGamma( vec4(result, 1.0), 0.9 ).xyz; //2.2\r\n\r\n\tgl_FragColor = vec4(result, 1.0);\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_CLOUDS_2\r\n#define USE_TERRAIN_2\r\n#define USE_TREES_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n#define iChannel0   textureMaps[0]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 500.0;//300.0;\r\nconst vec3 SUN_LIGHT = vec3(-0.624695,0.468521,-0.624695);\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 500.0;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( terrainMap( iChannel0, p ), MATERIAL_TERRAIN ) );\r\n    res = dUnion( res, vec2( treesMap( iChannel0, p ), MATERIAL_TREES ) );\r\n    //res = dUnion( res, vec2( cloudsMap( p ).x, MATERIAL_CLOUDS ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    // raymarch ==> intersection\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        // sky & clouds\r\n        col = skyCloudsColor( iChannel0, SUN_COLOR, SUN_LIGHT, ro, rd );\r\n\r\n        // clouds(volumetric)\r\n        vec4 cloudsCol = cloudsColor( SUN_LIGHT, ro, rd, 0.0, FAR );//1000.0\r\n        #if 0\r\n            col = col*(1.0-cloudsCol.w) + cloudsCol.xyz;\r\n        #else\r\n            col = mix( col, cloudsCol.xyz, cloudsCol.w );\r\n        #endif\r\n\t}\r\n\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n        col = terrainColor( iChannel0, SUN_LIGHT, rd, p, tm.x );\r\n    }\r\n    else if( tm.y == MATERIAL_TREES )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n        col = treesColor( iChannel0, SUN_LIGHT, p, rd, tm.x );\r\n    }\r\n\r\n    // fog\r\n    applyFog( col, FOG_COLOR, 0.003, tm.x*0.5 );\r\n\r\n    // sun glare\r\n    col += sunScatter( SUN_LIGHT, rd );\r\n\r\n    // color grading\r\n#if 0\r\n    col = col*0.15 + 0.85*col*col*(3.0-2.0*col); // contrast\r\n    col = pow( col, vec3(1.0,0.92,1.0) );  // soft green\r\n    col *= vec3(1.02,0.99,0.99);           // tint red\r\n    col.z = (col.z+0.1)/1.1;               // bias blue\r\n    col = mix( col, col.yyy, 0.15 );       // desaturate\r\n    col = saturate( col );\r\n#endif\r\n\r\n    col = FilmicToneMapping( col );\r\n    col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n    return col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 10.0*time;\r\n    ro = vec3(0.0, 0.0, -80.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -90.0-curTime);\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 500.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xz ) + 30.0;//20.0 30.0\r\n    ta.y = ro.y - 2.0;\r\n\r\n    float fl = 1.2;//1.0;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n}"},function(e,t){e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n//#define USE_CLOUDS_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/organic2.jpg' (1024 x 1024)\r\n// textureMaps[1] = 'images/raymarch/abstract1.jpg' (1024 x 1024)\r\n// textureMaps[2] = 'images/raymarch/grayNoise256.png' (256 x 256)\r\n// textureMaps[3] = 'images/raymarch/lichen.jpg' (1024 x 1024)\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n#define iChannel2   textureMaps[2]\r\n#define iChannel3   textureMaps[3]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_FISH_COLORING\r\n\r\nconst float FAR = 300.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(0.9,0.35,-0.2));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 100.0;\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\nconst vec3 UNDER_WATER_COLOR = vec3(0.0, 0.15, 0.25);\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nfloat aquaTerrainH( vec3 p )\r\n{\r\n    float h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th * 1.25;\r\n    h -= 0.24 * rr;\r\n\th *= 0.75;\r\n    return -h;\r\n}\r\n\r\n// float aquaTerrainL( in sampler2D tex, in vec3 p )\r\n// {\r\n//     return aquaTerrainH( p );\r\n// }\r\n\r\nfloat aquaTerrainMap( vec3 p )\r\n{\r\n    // return (p.y - aquaTerrainH(p))*1.0;//0.3\r\n    return p.y - aquaTerrainH(p);\r\n}\r\n\r\nvec3 aquaTerrainColor( in vec3 rd, in vec3 pos, in vec3 nor )\r\n{\r\n    vec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\r\n    vec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n    te = 0.05 + te;\r\n    mate.xyz = 0.6*te;          // material diffuse\r\n    mate.w = 5.0*(0.5+0.5*te.x);// material shininess\r\n\r\n    float th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n    vec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n    mate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n    float rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n    mate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n    mate.xyz *= 1.5;\r\n\r\n    // lighting\r\n    vec3 lig = SUN_LIGHT;\r\n    float sky = saturate(nor.y);\r\n    float bou = saturate(-nor.y);\r\n    float dif = max(dot(nor,lig),0.0);\r\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n    float sha = 0.0; if( dif>0.001 ) sha = sceneShadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n    float fre = pow( saturate( 1.0 + dot(nor,rd) ), 5.0 );\r\n    float spe = max( 0.0, pow( saturate( dot(lig, reflect(rd,nor)) ), mate.w ) ) * mate.w;\r\n    float sss = pow( saturate( 1.0 + dot(nor,rd) ), 3.0 );\r\n    \r\n    // water caustics...\r\n    float cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*time*vec2( 1.0, 0.0) ).x;\r\n          cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*time*vec2( 0.0, 1.0) ).x;\r\n          cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*time*vec2(-1.0,-1.0) ).x;\r\n    cc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n    dif *= 1.0 + 2.0*cc;\r\n\r\n    // lights\r\n    vec3 lin = vec3(0.0);\r\n    lin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n    lin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n    lin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n    lin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n    lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n    lin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\r\n    // surface-light interacion\r\n    vec3 col = mate.xyz * lin;\r\n    return col;\r\n}\r\n\r\n// fish type\r\n#define FISH_WINE_SNAPPER   0\r\n#define FISH_GREEN_SNAPPER  1\r\n#define FISH_RED_SNAPPER    2\r\n#define FISH_GOLD_SNAPPER   3\r\n#define FISH_AMERICAN_SHAD  4\r\n\r\n// (only for internal use)\r\nvec3 fshPos = vec3(0.0);    // global coords\r\nfloat fshTime = 0.0;        // fish motion time\r\nvec2 fshCoord = vec2(0.0);  // fish length coord + fish width coord\r\nvec3 fshSize = vec3(0.5);   // fish (width, height, length)\r\nint fshType = 0;            // fish type ==> FishMaterial*\r\n\r\n// Fish Definition\r\n// 1. geometry (fishPos, fishTime, fishSize)\r\n// 2. material (fishType)\r\n#define FISH_AMOUNT         4\r\n#define FISH_MAX_SIZE       10.0\r\nvec3 fishPos[FISH_AMOUNT];  // fish position in world space\r\nfloat fishTime[FISH_AMOUNT];// fish motion time\r\nvec3 fishSize[FISH_AMOUNT]; // fish (width, height, length)\r\nint fishType[FISH_AMOUNT];  // fish type ==> FishMaterial*\r\n\r\n// fish material(color) <=== fish type\r\nstruct FishMaterial {\r\n    float   shininess;      // 8.0;\r\n    vec3    upperBodyCol;   // vec3(0.24,0.17,0.22);\r\n    vec3    lowerBodyCol;   // vec3(1.0);\r\n    float   upperSideLine;  // 0.4;\r\n    float   lowerSideLine;  // 0.0;\r\n    vec3    tailCombCol;    // vec3(2.0,1.0,0.5);\r\n    vec3    tailPartCol;    // 0.9*vec3(2.6,1.5,1.0);\r\n    vec3    stripeCol;      // vec3(0.5);\r\n    float   bellyPattern;   // 50.0; (freq of belly pattern)\r\n    vec3    topFinCol;      // vec3(0.8,0.2,0.2);\r\n};\r\nFishMaterial getFishMaterial( int type )\r\n{\r\n    FishMaterial fish;\r\n    if( type == FISH_WINE_SNAPPER )\r\n    {\r\n        fish.shininess = 64.0;\r\n    #ifdef ENABLE_FISH_COLORING\r\n        fish.upperBodyCol = mix( vec3(0.3,0.17,0.17), vec3(0.17,0.17,0.17), 0.5+0.5*sin(time) );\r\n    #else\r\n        fish.upperBodyCol = vec3(0.3,0.17,0.17);\r\n    #endif\r\n        fish.lowerBodyCol = vec3(1.0);\r\n        fish.upperSideLine = 0.4;\r\n        fish.lowerSideLine = 0.0;\r\n        fish.tailCombCol = 1.0*vec3(2.0,1.0,0.5);\r\n        fish.tailPartCol = 0.9*vec3(2.6,1.5,1.0);\r\n        fish.stripeCol = vec3(0.5);\r\n        fish.bellyPattern = 50.0; // freq of belly pattern\r\n        fish.topFinCol = vec3(0.8,0.2,0.2);\r\n    }\r\n    else if( type == FISH_GREEN_SNAPPER )\r\n    {\r\n        fish.shininess = 32.0;//8.0;\r\n        fish.upperBodyCol = vec3(0.5,1.0,0.2);\r\n        fish.lowerBodyCol = vec3(0.9,0.7,0.5);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.6;\r\n        fish.tailCombCol = vec3(1.0,1.0,0.0);\r\n        fish.tailPartCol = vec3(1.0,1.0,0.0);\r\n        fish.stripeCol = vec3(1.0,0.0,1.0);\r\n        fish.bellyPattern = 75.0;//50.0;\r\n        fish.topFinCol = vec3(1.5,0.0,0.0);\r\n    }\r\n    else if( type == FISH_RED_SNAPPER )\r\n    {\r\n        fish.shininess = 64.0;//8.0;\r\n    #ifdef ENABLE_FISH_COLORING\r\n        fish.upperBodyCol = mix( vec3(1.5,0.4,0.2), vec3(0.2,1.5,0.4), 0.5+0.5*sin(time) );\r\n    #else\r\n        fish.upperBodyCol = vec3(1.5,0.4,0.2);\r\n    #endif\r\n        fish.lowerBodyCol = vec3(0.9,0.7,0.5);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.6;\r\n        fish.tailCombCol = vec3(1.0,1.0,0.0);\r\n        fish.tailPartCol = vec3(1.0,1.0,0.0);\r\n        fish.stripeCol = vec3(1.5,0.1,0.1);\r\n        fish.bellyPattern = 75.0;//50.0;\r\n        fish.topFinCol = vec3(1.5,0.0,0.0);\r\n    }\r\n    else if( type == FISH_GOLD_SNAPPER ) // Goldfish\r\n    {\r\n        fish.shininess = 8.0;\r\n        fish.upperBodyCol = vec3(0.9, 0.34, 0.07);\r\n        fish.lowerBodyCol = vec3(0.85, 0.84, 0.81);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.5;\r\n        fish.tailCombCol = vec3(0.77, 0.48, 0.11);\r\n        fish.tailPartCol = vec3(0.83, 0.38, 0.1);\r\n        fish.stripeCol = vec3(0.88, 0.31, 0.15);\r\n        fish.bellyPattern = 20.0;//50.0;\r\n        fish.topFinCol = vec3(0.85, 0.13, 0.0);\r\n    }\r\n    else if( type == FISH_AMERICAN_SHAD )\r\n    {\r\n        fish.shininess = 8.0;\r\n        fish.upperBodyCol = vec3(0.22, 0.35, 0.32);\r\n        fish.lowerBodyCol = vec3(0.88, 0.91, 0.89);\r\n        fish.upperSideLine = 0.4;\r\n        fish.lowerSideLine = 0.1;\r\n        fish.tailCombCol = vec3(0.65, 0.71, 0.6);\r\n        fish.tailPartCol = vec3(0.58, 0.62, 0.32);\r\n        fish.stripeCol = vec3(0.22, 0.35, 0.32);\r\n        fish.bellyPattern = 10.0;//50.0;\r\n        fish.topFinCol = vec3(0.42, 0.41, 0.33);\r\n    }\r\n    return fish;\r\n}\r\n\r\nvec2 vSegment( vec3 a, vec3 b, vec3 p )\r\n// segment (has the length from a to b) \r\n// return.x = d * d (d = distance from p to segment)\r\n// return.y = t (where a + t(b-a) = projection of p to segment) (0 < t < 1)\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\nfloat fishMap( in vec3 p )\r\n// return dist from p to fish\r\n// p ==> fishPos[i] ==> i ==> (fshPos, fshTime, fshSize, fshType, fshCoord)\r\n{\r\n    // vec3 spacing = vec3(3.0, 0.0, 7.0);\r\n    // p = sRepeat( p, spacing );\r\n    // p = sRotateY( p, PI*2.0 );\r\n\r\n    //\r\n    // find fishPos[i] which is the closest to p\r\n    //\r\n    float minDist = 1000.0;\r\n    for(int i=0; i<FISH_AMOUNT; i++)\r\n    {\r\n        float dist = length( p - fishPos[i] );\r\n        if( dist < minDist )\r\n        {\r\n            minDist = dist;\r\n            fshPos = fishPos[i];\r\n            fshTime = fishTime[i];\r\n            fshSize = fishSize[i];\r\n            fshType = fishType[i];\r\n        }\r\n    }\r\n\r\n    // res.x = distance from p to fish\r\n    // res.y = fish length coord\r\n    // res.z = fish width coord\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fshPos;\r\n\r\n    if( dot(p,p) > FISH_MAX_SIZE*FISH_MAX_SIZE ) return FISH_MAX_SIZE;\r\n\r\n    float fishW = mapLinear( fshSize.x, 0.0, 1.0, 2.5, 0.8 ); // fish width:  2.5(thin) ~ 0.8(fat)\r\n    float fishH = mapLinear( fshSize.y, 0.0, 1.0, 1.2, 0.5 ); // fish height: 1.2(short) ~ 0.5(tall)\r\n    float fishL = mapLinear( fshSize.z, 0.0, 1.0, 2.0, 0.5 ); // fish length: 3.0(short) ~ 0.5(long)\r\n    p *= vec3(fishW, fishH, fishL);\r\n\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0);\r\n\ta.x -= 0.25*sin(8.0 * 0.2 * fshTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\tconst int NUMI = 7;\r\n\tconst float NUMF = 7.0;\r\n\tvec3 p1 = a; vec3 d1 = vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2 = vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor(int i=0; i<NUMI; i++)\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\tfloat ang = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fshTime);\r\n\t\tfloat ll = 0.26; if( i == (NUMI-1) ) ll = 0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(ang), 0.0, cos(ang))*(16.0/NUMF);\r\n\r\n\t\tvec2 dis = vSegment( a, b, p );\r\n\r\n\t\tif( dis.x < res.x ) {\r\n            res = vec3(dis.x, ih + dis.y / NUMF, 0.0);\r\n            mp = a + (b - a)*dis.y;\r\n        }\r\n\r\n\t\tif( i == 1 ) { p1 = a; d1 = b - a; }\r\n\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-saturate(abs(p.y)/0.075))*(1.0-smoothstep(0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p, mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*( length((p-oa)*vec3(0.5,2.0,1.0)) - 0.12 );\r\n\tres.x = max( -d3, res.x );\r\n\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fshTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, fBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d < res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = fsmin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, fBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d < res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = fsmin( d, res.x, 0.05 );\r\n\r\n    fshCoord = res.yz;\r\n\r\n\treturn res.x;\r\n}\r\n\r\nvec3 fishColor( in vec3 rd, in vec3 pos, in vec3 nor, \r\n    in vec3 fshPos, in float fshTime, in vec2 fshCoord, in vec3 fshSize, in int fshType )\r\n// fshPos, fshTime, fshCoord, fshSize ==> (geometry data)\r\n// fshType ==> FishMaterial ==> (material(color) data)\r\n{\r\n    FishMaterial fish = getFishMaterial( fshType );\r\n\r\n    // whole body\r\n    vec4 mate = vec4(0.0);\r\n    mate.xyz = fish.upperBodyCol; // material diffuse\r\n    mate.w = fish.shininess;      // material shininess\r\n    vec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*fshCoord.x,pos.y) ).xyz;\r\n    mate.xyz *= te;\r\n    \r\n    // belly/backfin\r\n    vec3 tailCol = mix( 1.0+0.5*sin(150.0*pos.y - sign(pos.y)*fshCoord.x*300.0), // <=== pattern of tail comb\r\n                        1.0, smoothstep(0.0,0.1,1.0-fshCoord.x) ) * fish.tailPartCol;  // <=== tail part\r\n    tailCol += (1.0-smoothstep(0.0,0.09,1.0-fshCoord.x)) * fish.tailCombCol;\r\n    float iscola = smoothstep( 0.0, 0.2, 1.0-fshCoord.x );\r\n    mate.xyz = mix( mix( vec3(te.x*0.5 + 1.5), tailCol, 1.0-iscola ) * 0.5, // <=== lower body\r\n                    mate.xyz,                                               // <=== upper body\r\n                    smoothstep(fish.lowerSideLine, fish.upperSideLine, nor.y) // upper if nor.y > upperSideLine, lower if nor.y < lowerSideLine\r\n                );\r\n\r\n    // stripes\r\n    mate.xyz = mix( mate.xyz, \r\n                    (te.x+0.5)*1.0*fish.stripeCol, \r\n                    0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x + fshCoord.x*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n    // escamas\r\n    float ll = saturate( (fshCoord.x-0.2)/(0.8-0.2) );\r\n    float ha = 1.0-4.0*ll*(1.0-ll);\r\n    float pa = smoothstep( -1.0+2.0*ha, 1.0, sin(fish.bellyPattern*(pos.y-fshPos.y) ) ) * smoothstep( -1.0, 0.0, sin( 560.0*fshCoord.x ) );\r\n    pa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n    mate.xyz *= 0.5 + 0.5*fish.lowerBodyCol * (1.0-pa);\r\n\r\n    // eye\r\n    float r = length(vec2(5.0*fshCoord.x,pos.y)-vec2(0.5,0.13+fshPos.y) );\r\n    r /= 1.2;\r\n    mate.xyz = mix( mate.xyz, vec3(1.5)*saturate(1.0-r*4.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n    mate.xyz *= smoothstep(0.03,0.05,r);\r\n    mate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*\r\n        pow( texture( iChannel1, 4.0*vec2(0.2*fshPos.z+4.0*fshCoord.x, pos.y) ).x, 2.0 );\r\n    r = length(vec2(5.0*fshCoord.x,pos.y)-vec2(0.48,0.14) );\r\n    mate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n    \r\n    // mouth\r\n    vec3 oa = fshPos;\r\n    oa.x -= 0.25*sin(8.0*0.2*fshTime);\r\n    mate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n    \r\n    // top fin\r\n    float fh = smoothstep(0.15,0.2,fshCoord.x) - smoothstep(0.25,0.8,fshCoord.x);\r\n    float ra = 0.04 + fshCoord.x*(1.0-fshCoord.x)*(1.0-fshCoord.x)*2.7;\r\n    float vv = saturate( (pos.y-fshPos.y-fshSize.y-ra-0.1) / 0.2 );\r\n    vec3 fincol = mix( 1.0+0.5*sin(520.0*fshCoord.x), 1.0, vv ) * mix( fish.topFinCol, vec3(1.5,1.4,1.5), vv );\r\n    mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-fshPos.y-fshSize.y-ra-0.1) );\r\n    \r\n    // side fins\r\n    float isFin = fshCoord.y;\r\n    fincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n    mate.xyz = mix( mate.xyz, fincol, isFin );\r\n    mate.xyz *= 0.17;\r\n\r\n    // lighting\r\n    vec3 lig = SUN_LIGHT;\r\n    float sky = saturate(nor.y);\r\n    float bou = saturate(-nor.y);\r\n    float dif = max(dot(nor,lig),0.0);\r\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n    float sha = 0.0; if( dif>0.001 ) sha = sceneShadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n    float fre = pow( saturate( 1.0 + dot(nor,rd) ), 5.0 );\r\n    float spe = max( 0.0, pow( saturate( dot(lig, reflect(rd,nor)) ), mate.w ) ) * mate.w;\r\n    float sss = pow( saturate( 1.0 + dot(nor,rd) ), 3.0 );\r\n    \r\n    // lights\r\n    vec3 lin = vec3(0.0);\r\n    float cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*time*vec2( 1.0, 0.0) ).x;\r\n          cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*time*vec2( 0.0, 1.0) ).x;\r\n          cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*time*vec2(-1.0,-1.0) ).x;\r\n    cc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n    dif *= 1.0 + 2.0*cc;\r\n\r\n    lin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n    lin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n    lin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n    lin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n    lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n    lin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\r\n    // material-light interacion\r\n    vec3 col = mate.xyz * lin;\r\n    return col;\r\n}\r\n\r\n//===========================================================\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( aquaTerrainMap(p), MATERIAL_TERRAIN ) );\r\n    res = dUnion( res, vec2( fishMap(p), MATERIAL_FISH ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        applyClouds( col, iChannel2, ro, rd );\r\n\t}\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 pos = ro + rd * tm.x;\r\n        vec3 nor = sceneNormal( pos );\r\n        gl_FragDepth = getFragDepth( pos );\r\n\r\n        col = aquaTerrainColor( rd, pos, nor );\r\n    }\r\n    else if( tm.y == MATERIAL_FISH )\r\n    {\r\n        vec3 pos = ro + rd * tm.x;\r\n        vec3 nor = sceneNormal( pos );\r\n        gl_FragDepth = getFragDepth( pos );\r\n\r\n        col = fishColor( rd, pos, nor, fshPos, fshTime, fshCoord, fshSize, fshType );\r\n    }\r\n\r\n    // fog under the water...\r\n    col *= 0.65;\r\n#ifdef ENABLE_AUTO_VIEW\r\n    float density = 0.005;//0.01;\r\n#else\r\n    float density = 0.025;//0.2;\r\n#endif\r\n    //float t = max(0.0, tm.x-1.3);\r\n    float t = max(0.0, tm.x);\r\n    float h = 1.0-exp(-density*t);\r\n    col = mix( col*(1.0-h), UNDER_WATER_COLOR, h );\r\n\r\n    // water surface...\r\n#if 1\r\n    if( rd.y < 0.0 )\r\n    {\r\n        float waterHeight = 2.0;//2.0\r\n\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro - vec3(0.0, waterHeight, 0.0), rd, vec4(0.0) );//cloudy = 0.0\r\n        if( 0.0 < waterCol.w && waterCol.w < tm.x )\r\n        {\r\n            // foam on water...\r\n            float t = (waterHeight-ro.y)/rd.y;\r\n            vec2 uv = (ro + rd * t).xz;\r\n            float sur = texture( iChannel3, 0.06*uv ).x;\r\n            sur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2, 1.0, texture( iChannel2, 1.0*uv ).x);\r\n            waterCol.rgb = mix( waterCol.rgb, vec3(2.5), 0.5*sur ); // foamCol = vec3(2.5)\r\n\r\n            // sun specular...\r\n            // float sunAmount = saturate( dot(SUN_LIGHT, reflect( rd, vec3(0.0,1.0,0.0) ) ) );\r\n            // waterCol.rgb += 0.2*vec3(1.0,0.95,0.9)*pow(sunAmount,16.0);\r\n            // waterCol.rgb += 0.5*vec3(1.0,0.95,0.9)*pow(sunAmount,96.0);\r\n\r\n            col = mix(col, waterCol.rgb, saturate(1.1+rd.y));\r\n        }\r\n    }\r\n#endif\r\n\r\n    // post-processing\r\n    col = pow( saturate(col), vec3(0.45) );\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n    // col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\tcol *= smoothstep( 0.0, 1.0, time );\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 0.2*time;\r\n\tvec3 ta = fishPos[0] - vec3(2.0, 0.0, -2.0);\r\n    ta.y += 2.0*sin(time);\r\n\r\n    float r = 12.0;//8.0;\r\n\tro = ta + vec3(r*sin(curTime), r, r*cos(curTime));\r\n\r\n    float fl = 2.5;//2.0 1.2\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta );\r\n\trd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    // setup for fish animation...\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\n    float speedScale = 1.0;//0.7;\r\n#else\r\n    float speedScale = 0.0;\r\n#endif\r\n\r\n    fishTime[0] = time + 1.1;\r\n    fishTime[1] = time + 2.2;\r\n    fishTime[2] = time + 0.1;\r\n    fishTime[3] = time + 1.5;\r\n\r\n#ifdef ENABLE_FISH_COLORING\r\n    fishPos[0] = vec3( 0.0, 0.0, -speedScale*fishTime[0] );\r\n    fishPos[1] = vec3( 4.5, 1.0+0.5*sin(time), -speedScale*fishTime[1] );\r\n    fishPos[2] = vec3( -5.0, 0.2, -speedScale*fishTime[2] );\r\n    fishPos[3] = vec3( -9.5, 0.3+0.5*sin(time+0.5), -speedScale*fishTime[3] );\r\n\r\n    fishSize[0] = vec3(0.5+0.3*sin(time), 0.5, 0.65+0.25*sin(time)); // fish (width, height, length)\r\n    fishSize[1] = vec3(0.7, 0.0, 0.7);\r\n    fishSize[2] = vec3(0.3, 0.5+0.3*sin(time), 0.8);\r\n    fishSize[3] = vec3(0.5+0.3*sin(time), 0.5, 0.4+0.25*sin(time));\r\n#else\r\n    fishPos[0] = vec3( 0.0, 0.0, -speedScale*fishTime[0] );\r\n    fishPos[1] = vec3( 4.5, 0.4, -speedScale*fishTime[1] );\r\n    fishPos[2] = vec3( -5.0, 0.2, -speedScale*fishTime[2] );\r\n    fishPos[3] = vec3( -9.5, 0.3, -speedScale*fishTime[3] );\r\n\r\n    fishSize[0] = vec3(0.5, 0.5, 0.9); // fish (width, height, length)\r\n    fishSize[1] = vec3(0.7, 0.0, 0.7);\r\n    fishSize[2] = vec3(0.3, 0.7, 0.6);\r\n    fishSize[3] = vec3(0.8, 0.5, 0.5);\r\n#endif\r\n\r\n    fishType[0] = FISH_WINE_SNAPPER;    // purple(wine)\r\n    fishType[1] = FISH_GREEN_SNAPPER;   // green\r\n    fishType[2] = FISH_RED_SNAPPER;     // red\r\n    fishType[3] = FISH_GOLD_SNAPPER;    // gold\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = LinearToGamma( vec4( col, 1.0 ), 0.35 ); // 0.3 ~ 0.5\r\n}"},function(e,t,r){"use strict";r.r(t);var n=r(3);window.THREE=n,r(10),r(11),r(12),r(13),r(14),r(15),r(16),r(17),r(18),r(19),r(20),r(21),r(22),r(23),r(24),r(25),r(26),r(27),r(28),r(29),r(30),r(31),r(32),r(37),r(38),r(39),r(40),r(41),r(42),r(43),r(44),r(45),r(46),r(47),r(48),r(49),r(50),r(51),r(52),r(53),r(54),r(55),r(56),r(57),r(58),r(59),r(60),r(61),r(62),r(63),r(64),r(65),r(66),r(67),r(68),r(69),r(70),r(71),r(72),r(73),r(74),r(75),r(76),r(77),r(78),r(79),r(80),r(81),r(82),r(83),r(84),r(85),r(86),r(87),r(88),r(89),r(90),r(91),r(92),r(93),r(94);var a={tabIndices:{ViewWorks:"1",GameWorks:"1",NatureWorks:"1",sketcher:"4"},zIndices:{ViewWorks:"0",NatureWorks:"0",sketcher:"2",colorSelector:"3",matcaps:"4"},appWorks:null,shaders:null,sunLight:null,TEXTURE_MAPS:["map","matcap","alphaMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","specularMap","envMap","lightMap","aoMap","emissiveMap","gradientMap"],WORLD_SIZE:1e3,GRID_SPACING:5,GROUND_HEIGHT:0,WATER_HEIGHT:0,WATER_COLOR:7695,OCEAN_COLOR:139053,FOG_COLOR:14014425,SUN_COLOR:16777215};a.Timer={unit:"sec",startTime:0,endTime:0,msg:"",start:function(e){this.msg=e,this.startTime=performance.now()},end:function(){this.endTime=performance.now();var e=this.endTime-this.startTime;"sec"===this.unit&&(e*=.001),console.log(">> time ("+this.msg+") = "+e.toFixed(2)+" ("+this.unit+")")},setUnit:function(e){this.unit=e}};var o,i,s,l,c,f,d,u=r(6);a.clock=new THREE.Clock,a.getDeltaTime=function(){return a.clock.getDelta()},a.getCurrentTime=function(){return a.clock.getElapsedTime()},a.humanFileSize=function(e,t,r,n,a){return(t=Math,r=t.log,1e3,a=r(e)/r(1e3)|0,e/t.pow(1e3,a)).toFixed(2)+" "+(a?"KMGTPEZY"[--a]+"B":"Bytes")},a.isDeviceMobile=function(){var e=!1;return/Mobi|Android|webOS|Tablet|iPad|iPhone|iPod|Windows Phone|BlackBerry|BB10|Opera Mini/i.test(navigator.userAgent)&&(e=!0),e},a.isDeviceLandscape=function(){return 90===window.orientation||-90===window.orientation},a.isDeviceTouch=function(){return"ontouchend"in window},a.isDeviceWindowsOS=function(){return navigator.platform.toUpperCase().indexOf("WIN32")>=0},a.isDeviceMacOS=function(){return navigator.platform.toUpperCase().indexOf("MAC")>=0},a.isDeviceiOS=function(){return/iPad|iPhone|iPod/g.test(navigator.userAgent)&&!window.MSStream},a.isWebGL1Available=function(){var e=document.createElement("canvas");return!(!window.WebGLRenderingContext||!e.getContext("webgl")&&!e.getContext("experimental-webgl"))},a.isWebGL2Available=function(){var e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))},a.isWebGL1=function(){var e=a.appWorks.renderer.getContext();return void 0!==e&&e instanceof window.WebGLRenderingContext},a.isWebGL2=function(){var e=a.appWorks.renderer.getContext();return void 0!==e&&e instanceof window.WebGL2RenderingContext},a.getWebGLInfo=function(){var e=[],t="WebGL1: "+(a.isWebGL1Available()?"available":"unavailable");e.push(t);var r="WebGL2: "+(a.isWebGL2Available()?"available":"unavailable");e.push(r);var n=a.appWorks.renderer.getContext().getSupportedExtensions();return e=e.concat(n)},a.isWebGLExtensionAvailable=function(e){return a.appWorks.renderer.getContext().getSupportedExtensions().indexOf(e)>=0},Number.prototype.format=function(){return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1,")},String.prototype.trunc=function(e,t){if(this.length<=e)return(" "+this).slice(1);var r=this.substr(0,e);return(t?r.substr(0,r.lastIndexOf(" ")+1):r)+"..."},Array.prototype.clone=function(){return this.map(e=>Array.isArray(e)?e.clone():e)},Array.prototype.remove=function(e,t){var r=this.slice((t||e)+1||this.length);return this.length=e<0?this.length+e:e,this.push.apply(this,r)},Array.prototype.sum=function(){return this.reduce((function(e,t){return e+Number(t)}),0)},Array.prototype.average=function(){return this.sum()/(this.length||1)},Array.prototype.mean=function(){return this.sum()/(this.length||1)},Array.prototype.median=function(){var e=this.slice(0).sort((e,t)=>e-t),t=e.length/2;return t%1?e[t-.5]:(e[t-1]+e[t])/2},Array.prototype.variance=function(){var e=this.mean();return this.map(t=>Math.pow(t-e,2)).mean()},Array.prototype.std=function(){return Math.sqrt(this.variance())},Array.prototype.zscores=function(){var e=this.mean(),t=this.std();return this.map(r=>(r-e)/t)},Array.prototype.range=function(){return this.max()-this.min()},Array.prototype.zero=function(e){for(var t=0;t<e;t++)this[t]=0;return this},Array.prototype.scale=function(e){return this.map(t=>t*e)},Array.prototype.add=function(e){return this.map((t,r)=>t+e[r])},Array.prototype.sub=function(e){return this.map((t,r)=>t-e[r])},Array.prototype.mul=function(e){return this.map((t,r)=>t*e[r])},Array.prototype.div=function(e){return this.map((t,r)=>t/e[r])},Array.prototype.dot=function(e){return this.map((t,r)=>t*e[r]).reduce((e,t)=>e+t)},Array.prototype.norm2=function(){return Math.sqrt(this.map((e,t)=>e*e).reduce((e,t)=>e+t))},Array.prototype.transpose=function(){var e=this;return e[0].map((function(t,r){return e.map((function(e,t){return e[r]}))}))},Array.prototype.mmul=function(e){return this.map((function(t,r){return e.transpose().map((function(e,r){return t.dot(e)}))}))},Array.prototype.vmul=function(e){return this.map((function(t,r){return t.dot(e)}))},Array.prototype.sortNumbers=function(e){return"ascending"===(e=e||"ascending")?this.sort((e,t)=>e-t):"descending"===e&&this.sort((e,t)=>t-e),this},Array.prototype.minX=function(){return this.reduce((e,t)=>t.x<e?t.x:e,this[0].x)},Array.prototype.maxX=function(){return this.reduce((e,t)=>t.x>e?t.x:e,this[0].x)},Array.prototype.minY=function(){return this.reduce((e,t)=>t.y<e?t.y:e,this[0].y)},Array.prototype.maxY=function(){return this.reduce((e,t)=>t.y>e?t.y:e,this[0].y)},Array.prototype.minZ=function(){return this.reduce((e,t)=>t.z<e?t.z:e,this[0].z)},Array.prototype.maxZ=function(){return this.reduce((e,t)=>t.z>e?t.z:e,this[0].z)},Array.prototype.min=function(){return this.reduce((e,t)=>t<e?t:e,this[0])},Array.prototype.max=function(){return this.reduce((e,t)=>t>e?t:e,this[0])},Array.prototype.householder=function(){function e(e,t=(e=>e)){return Array.from(Array(e),(e,r)=>t(r))}function t(e,t=(e=>e)){return e.reduce((e,r,n)=>e+t(r,n),0)}const r=Math.sqrt(this.length),n=Array.from(this);console.assert(Number.isInteger(r));const a=(e,t)=>t*r+e;for(let o=0;o<r-2;o++){if(Math.abs(n[a(o,o+1)])<Number.EPSILON)continue;const i=e(r,e=>e<=o?0:n[a(o,e)]),s=Math.sign(i[o+1])*Math.hypot(...i);i[o+1]+=s;const l=Math.sqrt(2*s*i[o+1]),c=i.map(e=>e/l),f=e(r,e=>t(c,(t,r)=>t*n[a(r,e)])),d=e(r,e=>t(c,(t,r)=>t*n[a(e,r)])),u=t(f,(e,t)=>e*c[t]),p=t(d,(e,t)=>e*c[t]),h=f.map((e,t)=>2*(e-u*c[t])),v=d.map((e,t)=>2*(e-p*c[t]));for(let e=0;e<r;e++)for(let t=0;t<r;t++)n[a(t,e)]-=c[e]*v[t]+c[t]*h[e]}return n},Array.prototype.qr=function(){function e(e,t=(e=>e)){return e.reduce((e,r,n)=>e+t(r,n),0)}const t=Math.sqrt(this.length),r=Array.from(this);console.assert(Number.isInteger(t));const n=(e,r)=>r*t+e;let a=t;for(;a>=2;){if(Math.abs(r[n(a-2,a-1)])<Number.EPSILON){a--;continue}const t=r[n(a-1,a-1)],o=r[n(a-2,a-1)],i=r[n(a-1,a-2)],s=r[n(a-2,a-2)],l=t*s,c=t*s-o*i,f=Math.sqrt(l*l-4*c)||0,d=(l+f)/2,u=(l-f)/2,p=t-(Math.abs(d)<Math.abs(u)?d:u);for(let e=0;e<a;e++)r[n(e,e)]-=p;const h=(e,t)=>t*a+e,v=Array(a*a).fill(0);for(let e=0;e<a;e++)v[h(e,e)]=1;for(let e=0;e<a-1;e++){const t=r[n(e,e)],o=r[n(e,e+1)],i=Math.hypot(t,o),s=i<Number.EPSILON?0:t/i,l=i<Number.EPSILON?0:o/i;r[n(e,e)]=i,r[n(e,e+1)]=0;for(let t=e+1;t<a;t++){const a=r[n(t,e)],o=r[n(t,e+1)];r[n(t,e)]=a*s+o*l,r[n(t,e+1)]=o*s-a*l}for(let t=0;t<a;t++){const r=v[h(e,t)],n=v[h(e+1,t)];v[h(e,t)]=r*s+n*l,v[h(e+1,t)]=n*s-r*l}}for(let t=0;t<a;t++){const o=Array.from(Array(a-t),(e,a)=>r[n(t+a,t)]);for(let i=0;i<a;i++)r[n(i,t)]=e(o,(e,r)=>e*v[h(i,r+t)])}for(let e=0;e<a;e++)r[n(e,e)]+=p}return r},Array.prototype.eigenvalues=function(){const e=this.householder().qr(),t=Math.sqrt(e.length);return function(e,t=(e=>e)){return Array.from(Array(e),(e,r)=>t(r))}(t,r=>e[r*t+r])},a.concatTypedArrays=function(e,...t){const r=new e(t.reduce((e,t)=>e+t.length,0));return t.reduce((e,t)=>(r.set(t,e),e+t.length),0),r},a.fromTypedArray=function(e){return[].slice.call(e)},a.fillArray=function(e,t){for(var r=[],n=t;n--;)r[n]=e;return r},a.flattenArray=function(e){return e.reduce((function(e,t){return e.concat(Array.isArray(t)?a.flattenArray(t):t)}),[])},a.flattenVector2s=function(e,t){void 0===t&&(t=[]);for(var r=0,n=e.length;r<n;r++){var a=e[r];t.push(a.x,a.y)}return t},a.flattenVector3s=function(e,t){void 0===t&&(t=[]);for(var r=0,n=e.length;r<n;r++){var a=e[r];t.push(a.x,a.y,a.z)}return t},a.flattenVector4s=function(e,t){void 0===t&&(t=[]);for(var r=0,n=e.length;r<n;r++){var a=e[r];t.push(a.x,a.y,a.z,a.w)}return t},a.mergeArray3=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var r,n={},a=[],o={},i=0,s=e.length;i<s;i++)o.x=e[i][0],o.y=e[i][1],o.z=e[i][2],void 0===n[r=Math.round(o.x*t)+"_"+Math.round(o.y*t)+"_"+Math.round(o.z*t)]&&(n[r]=i,a.push([e[i][0],e[i][1],e[i][2]]));return a.slice(0)},a.mergeArray2=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var r,n={},a=[],o={},i=0,s=e.length;i<s;i++)o.x=e[i][0],o.y=e[i][1],void 0===n[r=Math.round(o.x*t)+"_"+Math.round(o.y*t)]&&(n[r]=i,a.push([e[i][0],e[i][1]]));return a.slice(0)},a.mergeArray=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var r,n={},a=[],o={},i=0,s=e.length;i<s;i++)o.x=e[i],void 0===n[r=Math.round(o.x*t)]&&(n[r]=i,a.push(e[i]));return a.slice(0)},a.mergeVertices=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var r,n,a={},o=0,i=e.length;o<i;o++)r=e[o],void 0===a[n=Math.round(r.x*t)+"_"+Math.round(r.y*t)+"_"+Math.round(r.z*t)]&&(a[n]=o,this.push(e[o]));return e.length-this.length},a.toHexValue=function(e,t){return t?"0x"+a.toHexValue(e).toString(16):new THREE.Color(e).getHex()},a.toHexStyle=function(e){return"#"+new THREE.Color(e).getHexString()},a.clamp=function(e,t,r){return Math.max(t,Math.min(r,e))},a.mix=function(e,t,r){return e*(1-r)+t*r},a.lerp=function(e,t,r){return e*(1-r)+t*r},a.smoothstep=function(e,t,r){return r<=e?0:r>=t?1:(r=(r-e)/(t-e))*r*(3-2*r)},a.randInt=function(e,t){return e+Math.floor(Math.random()*(t-e+1))},a.randFloat=function(e,t){return e+Math.random()*(t-e)},a.randFloatSpread=function(e,t){return e+t*(Math.random()-.5)},a.linearRand=function(e,t){return a.randFloat(e,t)},a.gaussRand=function(e,t){var r,n,o;do{r=(n=a.randFloat(-1,1))*n+(o=a.randFloat(-1,1))*o}while(r>1);return o*t*t*Math.sqrt(-2*Math.log(r)/r)+e},a.diskRand=(o=new THREE.Vector2,function(e){var t;do{o.x=a.randFloat(-e,e),o.y=a.randFloat(-e,e),t=o.length()}while(t>e);return o}),a.ballRand=function(){var e=new THREE.Vector3;return function(t){var r;do{e.x=a.randFloat(-t,t),e.y=a.randFloat(-t,t),e.z=a.randFloat(-t,t),r=e.length()}while(r>t);return e}}(),a.circularRand=function(){var e=new THREE.Vector2;return function(t){var r=a.randFloat(0,6.283185307179586);return e.x=t*Math.cos(r),e.y=t*Math.sin(r),e}}(),a.sphericalRand=function(){var e=new THREE.Vector3;return function(t){var r=a.randFloat(-1,1),n=a.randFloat(0,6.283185307179586),o=Math.sqrt(1-r*r),i=o*Math.cos(n),s=o*Math.sin(n);return e.x=i*t,e.y=s*t,e.z=r*t,e}}(),a.createMathRandom=function(e){var t,r=function(e){for(var t=0,r=1779033703^e.length;t<e.length;t++)r=(r=Math.imul(r^e.charCodeAt(t),3432918353))<<13|r>>>19;return function(){return r=Math.imul(r^r>>>16,2246822507),r=Math.imul(r^r>>>13,3266489909),(r^=r>>>16)>>>0}}(e.toString());return t=r(),()=>((t=Math.imul(741103597,t))>>>0)/2**32},a.createRandFloat=function(e){var t=void 0!==e?a.createMathRandom(e):Math.random;return function(e,r){return e+t()*(r-e)}},a.createFbmNoise=function(e){var t=void 0!==(e=e||{}).octaves?e.octaves:4,r=void 0!==e.persistence?e.persistence:.5;switch(void 0!==e.noiseType?e.noiseType:"simplex3d"){case"perlin3d":var n=(new THREE.ImprovedNoise).noise;break;default:var a=new THREE.SimplexNoise;n=a.noise3d.bind(a)}for(var o=new Array(t),i=new Array(t),s=0,l=0;l<t;l++)o[l]=Math.pow(r,l),i[l]=Math.pow(2,l),s+=o[l];return s=1/s,function(e,r,a){for(var i=0,l=0;l<t;l++){var c=1<<l;i+=o[l]*n(e*c,r*c,a*c)}return i*s}},a.fileExist=function(e,t,r){r=void 0!==r&&r,fetch((!0===r?"https://cors-anywhere.herokuapp.com/":"")+e).then(e=>{t&&t("404"!=e.status)}).catch(e=>{t&&t(!1)})},a.triggerWindowResize=function(){if("function"==typeof Event)window.dispatchEvent(new Event("resize"));else{var e=window.document.createEvent("UIEvents");e.initUIEvent("resize",!0,!1,window,0),window.dispatchEvent(e)}},a.isCtrlKeyDown=function(e){return a.isDeviceMacOS()?e.metaKey:e.ctrlKey},a.escapeHTML=function(e){return e.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")},a.createImageDropZone=function(e,t){return null==e&&((e=document.createElement("img")).style.width="50px",e.style.height="50px",e.style.border="1px solid white"),e.addEventListener("dragover",(function(e){e.preventDefault(),e.stopPropagation(),e.dataTransfer.dropEffect="copy"}),!1),e.addEventListener("drop",(function(e){e.preventDefault(),e.stopPropagation();var r=new FileReader;r.addEventListener("load",(function(e){var r=new Image;r.onload=function(){t(r)},r.src=e.currentTarget.result}),!1),r.readAsDataURL(e.dataTransfer.files[0])}),!1),e},a.setDraggable=function(e){var t=0,r=0,n=0,a=0,o=e.children[0];function i(e){(e=e||window.event).preventDefault(),n=e.clientX,a=e.clientY,document.onmouseup=l,document.onmousemove=s}function s(o){(o=o||window.event).preventDefault(),t=n-o.clientX,r=a-o.clientY,n=o.clientX,a=o.clientY,e.style.top=e.offsetTop-r+"px",e.style.left=e.offsetLeft-t+"px"}function l(){document.onmouseup=null,document.onmousemove=null}o?o.onmousedown=i:e.onmousedown=i},a.removeHTMLElement=function(e){for("string"==typeof e&&(e=document.getElementById(e)),e.parentNode&&e.parentNode.removeChild(e);e.firstChild;)e.removeChild(e.firstChild)},a.createFlashtext=function(e,t){var r,n,a=(t=t||{}).fontSize||"10vw";if(r=document.getElementById("flash-text"))return(n=document.getElementById("flash-style")).innerHTML=n.innerHTML.replace(/font-size:\s\w+\;/,`font-size: ${a};`),r.innerHTML=`\n            <h1 class="flash" data-heading="${e}">${e}</h1>\n        `,void(r.style.display="");(r=document.createElement("div")).id="flash-text",r.innerHTML=`\n        <h1 class="flash" data-heading="${e}">${e}</h1>\n    `,document.body.appendChild(r),(n=document.createElement("style")).id="flash-style",n.innerHTML=`\n        .flash {\n            background: url("images/frozen.jpg");\n            -webkit-background-clip: text;\n            background-size: contain;\n            width: 100%;\n            text-align: center;\n            color: transparent;\n            font-weight: 900;\n\n            top: 50%;\n            left: 50%;\n            -webkit-transform: translate(-50%, -50%);\n                    transform: translate(-50%, -50%);\n            position: absolute;\n            font-size: ${a};\n            margin: 0;\n            font-family: 'frozen', serif;\n        }\n        .flash::before {\n            content: attr(data-heading);\n            position: absolute;\n            left: 0;\n            top: 0;\n            width: 100%;\n            background: linear-gradient(45deg, rgba(255, 255, 255, 0) 45%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 55%, rgba(255, 255, 255, 0) 100%);\n            -webkit-background-clip: text;\n            color: transparent;\n            mix-blend-mode: screen;\n            -webkit-animation: shine 1s infinite;\n                    animation: shine 1s infinite;\n            background-size: 200%;\n            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2), -2px 2px 10px rgba(0, 0, 0, 0.2), -2px -2px 10px rgba(0, 0, 0, 0.2);\n        }\n        @-webkit-keyframes shine {\n            0% {\n                background-position: -100%;\n            }\n            100% {\n                background-position: 100%;\n            }\n        }\n        @keyframes shine {\n            0% {\n                background-position: -100%;\n            }\n            100% {\n                background-position: 100%;\n            }\n        }\n        @font-face {\n            font-family: 'frozen';\n            src: url("fonts/Ice kingdom - Bold - Por Kustren.woff");\n        }\n    `,document.head.appendChild(n)},a.showFlashtext=function(){var e=document.getElementById("flash-text");e&&(e.style.display="")},a.hideFlashtext=function(){var e=document.getElementById("flash-text");e&&(e.style.display="none")},a.removeFlashtext=function(){var e=document.getElementById("flash-text");e&&document.body.removeChild(e);var t=document.getElementById("flash-style");t&&document.head.removeChild(t)},a.createSpincircle=function(){if(e=document.getElementById("spin-circle"))e.style.display="";else{var e;(e=document.createElement("div")).id="spin-circle",e.innerHTML='\n        <div class="spin-wrapper">\n            <div class="spin-text">Computing...</div>\n            <div class="spin"></div>\n        </div>\n    ',document.body.appendChild(e);var t=document.createElement("style");t.id="spin-style",t.innerHTML='\n        .spin-wrapper {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            color: #888;\n        }\n        .spin-text {\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            transform: translate(-50%, -50%);\n            color: #888;\n        }\n        .spin {\n            position: relative;\n            left: 50%;\n            top: 50%;\n            width: 150px;\n            height: 150px;\n            margin: -75px 0 0 -75px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #3498db;\n            -webkit-animation: spin 2s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 2s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        .spin:before {\n            content: "";\n            position: absolute;\n            top: 5px;\n            left: 5px;\n            right: 5px;\n            bottom: 5px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #e74c3c;\n            -webkit-animation: spin 3s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 3s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        .spin:after {\n            content: "";\n            position: absolute;\n            top: 15px;\n            left: 15px;\n            right: 15px;\n            bottom: 15px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #f9c922;\n            -webkit-animation: spin 1.5s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 1.5s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        @-webkit-keyframes spin {\n            0%   {\n                -webkit-transform: rotate(0deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(0deg);  /* IE 9 */\n                transform: rotate(0deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n            100% {\n                -webkit-transform: rotate(360deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(360deg);  /* IE 9 */\n                transform: rotate(360deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n        }\n        @keyframes spin {\n            0%   {\n                -webkit-transform: rotate(0deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(0deg);  /* IE 9 */\n                transform: rotate(0deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n            100% {\n                -webkit-transform: rotate(360deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(360deg);  /* IE 9 */\n                transform: rotate(360deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n        }\n    ',document.head.appendChild(t)}},a.showSpincircle=function(){var e=document.getElementById("spin-circle");e&&(e.style.display="")},a.hideSpincircle=function(){var e=document.getElementById("spin-circle");e&&(e.style.display="none")},a.removeSpincircle=function(){var e=document.getElementById("spin-circle");void 0!==e&&document.body.removeChild(e);var t=document.getElementById("spin-style");void 0!==t&&document.head.removeChild(t)},a.createProgressbar=function(){var e;if(e=document.getElementById("progress-box"))return e.style.display="",void(a.getProgressbar().style.width="0%");(e=document.createElement("div")).id="progress-box",e.innerHTML='\n        <div>\n            <div style="color:#888;">Loading...</div>\n            <div class="progress">\n                <div id="progressbar"></div>\n            </div>\n        </div>\n    ',document.body.appendChild(e);var t=document.createElement("style");t.id="progress-style",t.innerHTML="\n        #progress-box {\n            position: absolute;\n            left: 0;\n            top: 0;\n            width: 100%;\n            height: 100%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            text-align: center;\n            font-size: x-large;\n            font-family: sans-serif;\n        }\n        #progress-box>div>div {\n            padding: 2px;\n        }\n        .progress {\n            width: 50vw;\n            border: 1px solid #888;\n        }\n        #progressbar {\n            width: 0;\n            transition: width ease-out .5s;\n            height: 1em;\n            background-color: #888;\n            background-image: linear-gradient(\n                -45deg, \n                rgba(255, 255, 255, .5) 25%, \n                transparent 25%, \n                transparent 50%, \n                rgba(255, 255, 255, .5) 50%, \n                rgba(255, 255, 255, .5) 75%, \n                transparent 75%, \n                transparent\n            );\n            background-size: 50px 50px;\n            animation: progressanim 2s linear infinite;\n        }\n    ",document.head.appendChild(t)},a.getProgressbar=function(){return document.getElementById("progressbar")},a.updateProgressbar=function(e,t,r){void 0===r&&(r=a.getProgressbar()),r.style.width=(e/t*100|0)+"%"},a.hideProgressbar=function(){var e=document.getElementById("progress-box");e&&(e.style.display="none")},a.showProgressbar=function(){var e=document.getElementById("progress-box");e&&(e.style.display="")},a.errorProgressbar=function(e){console.warn(e)},a.removeProgressbar=function(){var e=document.getElementById("progress-box");void 0!==e&&document.body.removeChild(e);var t=document.getElementById("progress-style");void 0!==t&&document.head.removeChild(t)},a.getDistancePerPixel=function(){var e=a.appWorks.camera;return e.position.length()*Math.tan(e.fov/2*THREE.Math.DEG2RAD)*2*e.aspect/a.appWorks.width},a.getMouseScreenCoords=(i=new THREE.Vector2,function(e){return e.changedTouches?(i.x=e.changedTouches[0].clientX,i.y=e.changedTouches[0].clientY):(i.x=e.clientX,i.y=e.clientY),i}),a.toggleLightHelpers=function(e){a.appWorks.sceneHelpers.children.forEach((function(t){(t instanceof THREE.PointLightHelper||t instanceof THREE.SpotLightHelper||t instanceof THREE.DirectionalLightHelper||t instanceof THREE.HemisphereLightHelper)&&(t.visible=void 0!==e?e:!t.visible)}))},a.createSpritesHUD=function(e,t,r,n,o){var i;i=e.isTexture?new THREE.SpriteMaterial({map:e,transparent:!0,depthTest:!1}):!0===e.isSpriteMaterial?e:new THREE.SpriteMaterial({color:16777215,transparent:!0,depthTest:!1});var s=new THREE.Sprite(i);s.center.set(.5,.5),s.scale.set(n,o,1),s.name="spritesHUD";var l=a.appWorks.cameraHUD;return s.position.x=l.left+n/2+t,s.position.y=l.bottom+o/2+r,s},a.createTextHUD=function(e,t,r,n,o,i){!1===Array.isArray(e)&&(e=[e]);t=t||0,r=r||0;var s,l=-1;e.forEach((e,t)=>{e.length>l&&(l=e.length,s=t)});var c=document.createElement("canvas"),f=c.getContext("2d");f.font="Normal 20px Arial",c.width=f.measureText(e[s]).width,f.font="Normal 20px Arial";var d=1.2*f.measureText("M").width;c.height=d*e.length*1.2;n=n||c.width,o=o||c.height;var u=new THREE.CanvasTexture(f.canvas),p=new THREE.MeshBasicMaterial({map:u,transparent:!0,depthTest:!1}),h=new THREE.PlaneBufferGeometry(n,o),v=new THREE.Mesh(h,p);v.name="textHUD";var m=a.appWorks.cameraHUD;v.position.x=m.left+n/2+t,v.position.y=m.bottom+o/2+r,!0===i&&(v.userData.context2D=f,v.userData.texts=e,v.userData.lineHeight=d),f.font="Normal 20px Arial",f.textAlign="left",f.fillStyle="rgba(255,255,255,1.0)",f.clear();r=d;return e.forEach(e=>{f.fillText(e,0,r),r+=d}),u.needsUpdate=!0,v},a.createRenderTargetHUD=function(e,t,r,n,o,i){t=t||0,r=r||0,n=n||a.appWorks.width,o=o||a.appWorks.height;var s=e.clone(),l=new THREE.Scene;l.add(s),l.add(a.createHemisphereLight()),l.background=a.appWorks.scene.background;var c=a.appWorks.camera.clone();a.fitCameraToObject(s,c);var f=new THREE.WebGLRenderTarget(a.appWorks.width,a.appWorks.height),d=a.appWorks.renderer;d.setRenderTarget(f),d.render(l,c);var u=new THREE.MeshBasicMaterial({map:f.texture}),p=new THREE.PlaneBufferGeometry(n,o),h=new THREE.Mesh(p,u);h.name="renderTargetHUD";var v=a.appWorks.cameraHUD;return h.position.x=v.left+n/2+t,h.position.y=v.bottom+o/2+r,!0===i&&(h.userData.renderTarget=f,h.userData.rtScene=l,h.userData.rtCamera=c),h},a.computeBoundingBox=function(e){return(new THREE.Box3).setFromObject(e)},a.computeBoundingSphere=function(){var e,t,r,n=new THREE.Vector3;function a(a){var o=a.geometry;if(void 0!==o)if(o.isGeometry){var i=o.vertices;for(t=0,r=i.length;t<r;t++)n.copy(i[t]),n.applyMatrix4(a.matrixWorld),e.push(n.clone())}else if(o.isBufferGeometry){var s;if(void 0!==(s=o.attributes.instancePosition?o.attributes.instancePosition:o.attributes.position))for(t=0,r=s.count;t<r;t++)n.fromBufferAttribute(s,t),n.applyMatrix4(a.matrixWorld),e.push(n.clone())}}return function(t){return e=[],t.updateMatrixWorld(!0),t.traverse(a),e.length>0?(new THREE.Sphere).setFromPoints(e):void 0}}(),a.getObjectName=function(e,t){t=void 0!==t?t:"";if(Array.isArray(e)){for(var r=[],n=0;n<e.length;n++)r.push(""===e[n].name?t:e[n].name);return r.join(", ").trunc(20)}return(void 0===e.name?t:e.name).trunc(20)},a.getObjectSize=(s=new THREE.Vector3,function(e){return a.computeBoundingBox(e).getSize(s),Math.max(s.x,s.y,s.z)}),a.resizeObject=function(e,t){if(t){var r=a.getObjectSize(e);e.scale.setScalar(t/r)}},a.transformObject=function(e,t,r,n){t&&e.position.set(t.x,t.y,t.z),r&&e.rotation.set(r.x,r.y,r.z),n&&e.scale.set(n.x,n.y,n.z),e.updateMatrix()},a.copyTransform=function(e,t){var r=t.position,n=t.rotation,o=t.scale;a.transformObject(e,r,n,o)},a.cloneObject=function(e){return void 0!==e.userData.type?new a[e.userData.type](e):e.clone()},a.traverseMaterials=function(e,t){e.traverse(e=>{if(!e.isMesh)return;(Array.isArray(e.material)?e.material:[e.material]).forEach(t)})},a.updateMaterialMapEncoding=function(e,t){t=t||THREE.sRGBEncoding,a.traverseMaterials(e,e=>{e.map&&(e.map.encoding=t),e.emissiveMap&&(e.emissiveMap.encoding=t),(e.map||e.emissiveMap)&&(e.needsUpdate=!0)})},a.underWaterBackground=function(){void 0!==a.appWorks.underWaterPass&&(a.appWorks.underWaterPass.enabled=!0),a.appWorks.createSceneBackground("underWater"),a.appWorks.scene.fog||a.appWorks.createSceneFog({type:"exp2",color:594516,density:.004}),a.appWorks.renderer.toneMappingExposure=.7},a.filmGrainBackground=function(){var e=a.appWorks.width,t=a.appWorks.height,r={aspect:a.appWorks.camera.aspect,aspectCorrection:!0,grainScale:1.5/Math.min(e,t),color1:16777215,color2:3487029,noiseAlpha:.75};(new THREE.TextureLoader).load("images/wallpaper/arctic.jpg",(function(e){a.imageProcessing(e,"FilmGrainShader",r,(function(e){a.appWorks.scene.background=e}))}))},a.redColors=(l=[16752762,16416882,15308410,15761536,13458524,14423100,11674146,16711680,9109504,8388608,16737095,16729344,14381203],function(e){return l[e%l.length]}),a.greenColors=(c=[8190976,8388352,3329330,65280,2263842,32768,25600,11403055,10145074,65407,64154,9498256,10025880,9419919,3978097,2142890,3050327,526336,5597999,7048739],function(e){return c[e%c.length]}),a.blueColors=(f=[4744096,2839678,2832470,1383252,128,1388926,1383309,160,8386,16834,2446535,1403335,2842846,2049532,2844140,3174143,1411583,6723839,3914239],function(e){return f[e%f.length]}),a.randomColors=function(e){if((e=e||{}).colors)return e.colors;var t,r,n,o=void 0!==e.numInstances?Math.floor(e.numInstances):1,i=void 0!==e.colorMode?e.colorMode:"none",s=new THREE.Color,l=[];if("0"===i)for(var c=0;c<o;c++)t=Math.random(),r=Math.random(),n=Math.random(),s.setHSL(t,r,n),l.push(s.r,s.g,s.b);else if("1"===i)for(c=0;c<o;c++)t=Math.random(),r=.5,n=.5,s.setHSL(t,r,n),l.push(s.r,s.g,s.b);else if("2"===i)for(c=0;c<o;c++)t=Math.random(),r=1,n=.5,s.setHSL(t,r,n),l.push(s.r,s.g,s.b);else if("reds"===i)for(c=0;c<o;c++)s.setHex(a.redColors(c)),l.push(s.r,s.g,s.b);else if("greens"===i)for(c=0;c<o;c++)s.setHex(a.greenColors(c)),l.push(s.r,s.g,s.b);else if("blues"===i)for(c=0;c<o;c++)s.setHex(a.blueColors(c)),l.push(s.r,s.g,s.b);return l},a.cameraAutoView=function(e){if((e=e||{}).isWorking)return"stop"!==d;if("circle"===(d=e.viewMode||"circle")){var t=e.radius||20,r=new THREE.CircleBufferGeometry(t,32),n=new THREE.Mesh(r);n.name="cameraPath",n.visible=!1,a.add(n),n.add(a.appWorks.camera),n.update=function(){this.rotation.y+=.003}}else if("stop"===d){var o=a.appWorks.camera.parent;o&&"cameraPath"===o.name&&(o.remove(a.appWorks.camera),a.appWorks.camera.parent=null)}},a.fitCameraToObject=function(e,t,r){if(e){t=void 0!==t?t:a.appWorks.camera,r=void 0===r||r;var n=new THREE.Vector3,o=new THREE.Vector3,i=a.computeBoundingBox(e);i.getSize(o);var s=e.position.clone();!0===r?(i.getCenter(n),s.sub(n),n.set(0,0,0)):n.copy(s);var l=t.fov*THREE.Math.DEG2RAD,c=Math.max(o.x,o.y,o.z),f=Math.abs(c/2/Math.tan(l/2));if(f*=1.25,t===a.appWorks.camera){var d=a.appWorks.controls;d instanceof THREE.OrbitControls?(d.reset(),d.maxDistance=100*f,d.saveState()):d instanceof THREE.TrackballControls&&(d.reset(),d.maxDistance=100*f)}var u=t.position.clone();u.normalize().multiplyScalar(f),t.lookAt(n);var p=f/100,h=100*f;if(a.appWorks.history&&t===a.appWorks.camera){var v=[];r&&v.push(new a.SetPositionCommand(e,s)),v.push(new a.SetPositionCommand(t,u)),v.push(new a.SetValueCommand(t,"near",p)),v.push(new a.SetValueCommand(t,"far",h)),a.appWorks.multiCmds(v)}else r&&e.position.copy(s),t.position.copy(u),t.near=p,t.far=h;t.updateProjectionMatrix()}},a.welcomeObject=function(e){if(e.traverse((function(e){e.isMesh&&(e.frustumCulled=!1,e.castShadow=!0,e.receiveShadow=!0)})),"NatureWorks"===a.appWorks.appName)a.fitCameraToObject(e);else if("ViewWorks"===a.appWorks.appName){a.resizeObject(e,1),a.fitCameraToObject(e),a.appWorks.selectObject=e;var t=a.appWorks.scene.getObjectByName("showroom");void 0===t&&(t=a.createShowroom(e),a.add(t))}},a.nextShowroom=function(e,t){if(t||(t=a.appWorks.scene.getObjectByName("showroom")),"background"===e){(n=t.getObjectByName("raymarch"))&&t.remove(n),o=((o=t.activeBackground)+1)%t.backgrounds.length,t.activeBackground=o;var r=t.backgrounds[o];r.isMesh?(a.appWorks.scene.background=null,t.add(r)):a.appWorks.scene.background=r}if("floor"===e){var n,o;(n=t.getObjectByName("floor"))&&t.remove(n),o=((o=t.activeFloor)+1)%t.floors.length,t.activeFloor=o;var i=t.floors[o];t.add(i)}},a.createShowroom=function(e){var t=new THREE.Object3D;t.name="showroom",t.activeBackground=-1,t.backgrounds=[];var r=["arctic","burlesque","denim","mercury","neo","origin","rouge","slate"];r.forEach(e=>{var r=(new THREE.TextureLoader).load("images/wallpaper/"+e+".jpg");r.encoding=THREE.sRGBEncoding,t.backgrounds.push(a.createBackground(r))}),(r=["blueSky","cloud","galaxy","lake","bridge","park"]).forEach(e=>{t.backgrounds.push(a.createBackground(e))}),(r=["cloudsFS","cellsFS","fogFS","sunsetFS"]).forEach(e=>{var r=a.createBackground(e);r.name="raymarch",t.backgrounds.push(r)}),t.backgrounds.push(a.createBackground(12632256)),t.activeFloor=-1,t.floors=[];var n=new THREE.TextureLoader,o=a.computeBoundingBox(e),i=o.min.y,s=o.getSize(new THREE.Vector3),l=4*(s=Math.max(s.x,s.y,s.z));function c(e,t){t=t||8;e.repeat.set(t,t),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping}(p=a.createAcrylicCircle(l)).rotation.x=-Math.PI/2,p.position.y=i,p.name="floor",t.floors.push(p);var f=[];f.push({map:n.load("images/rock/crackRockDiffuse.jpg",c),normalMap:n.load("images/rock/crackRockNormal.jpg",c),aoMap:n.load("images/rock/crackRockAO.jpg",c)}),f.push({color:11184810,roughness:1,metalness:0,map:n.load("images/pbr/wallA.png",c),normalMap:n.load("images/pbr/wallN.png",c),aoMap:n.load("images/pbr/wallAO.png",c),roughnessMap:n.load("images/pbr/wallR.png",c)}),f.push({roughness:1,metalness:0,map:n.load("images/pbr/bathroomtileA.png",c),normalMap:n.load("images/pbr/bathroomtileN.png",c),aoMap:n.load("images/pbr/bathroomtileAO.png",c),roughnessMap:n.load("images/pbr/bathroomtileR.png",c)}),f.push({roughness:1,metalness:0,map:n.load("images/pbr/charcoalA.png",c),normalMap:n.load("images/pbr/charcoalN.png",c),roughnessMap:n.load("images/pbr/charcoalR.png",c)}),f.push({color:11184810,roughness:1,metalness:0,map:n.load("images/pbr/grassA.png",c),normalMap:n.load("images/pbr/grassN.png",c),aoMap:n.load("images/pbr/grassAO.png",c),roughnessMap:n.load("images/pbr/grassR.png",c)}),f.push({color:8947848,roughness:.5,metalness:.5,map:n.load("images/pbr/rustIronA.png",e=>c(e,2)),normalMap:n.load("images/pbr/rustIronN.png",e=>c(e,2)),aoMap:n.load("images/pbr/rustIronAO.png",e=>c(e,2)),roughnessMap:n.load("images/pbr/rustIronR.png",e=>c(e,2)),metalnessMap:n.load("images/pbr/rustIronM.png",e=>c(e,2))});for(var d=new THREE.CircleBufferGeometry(l,64),u=0;u<f.length;u++){var p,h=new THREE.MeshStandardMaterial(f[u]);(p=new THREE.Mesh(d,h)).receiveShadow=!0,p.rotation.x=-Math.PI/2,p.position.y=i,p.name="floor",t.floors.push(p)}a.nextShowroom("background",t),a.nextShowroom("floor",t),a.add(a.createHemisphereLight());var v=a.createDirectionalLight({shadowCameraSize:.5*l});return v.position.set(0,.75*l,.5*l),a.add(v),t},a.manhatten2D=function(e,t){return Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)},a.manhatten3D=function(e,t){return Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)+Math.pow(e[2]-t[2],2)},a.createKdTree=function(e,t,r){var n=e[0];Array.isArray(n)?e=a.flattenArray(e):n instanceof THREE.Vector2?e=a.flattenVector2s(e):n instanceof THREE.Vector3?e=a.flattenVector3s(e):n instanceof THREE.Vector4&&(e=a.flattenVector4s(e)),e=new Float32Array(e);r=r||2===t?a.manhatten2D:a.manhatten3D;return new THREE.TypedArrayUtils.Kdtree(e,r,t)},a.getKdTreeNearest=function(e,t,r,n){for(var a=e.nearest(t,r,n),o=[],i=0,s=a.length;i<s;i++){var l=a[i],c={};c.position=l[0].obj,c.index=l[0].pos,c.distance=l[1],o.push(c)}return o},a.OctreeHelper=function(e,t){if(!e instanceof u.PointOctree)return null;var r=(t=t||{}).leaves||!1,n=t.color||16777215,o=[],i=[];if(r){i=a.getLeafOctants(e,!0)}else{var s=t.topLevel||0,l=t.bottomLevel||e.getDepth();i=a.getOctantsByLevels(e,s,l)}i.forEach((function(e){var t=new THREE.Box3(e.min,e.max),r=new THREE.Box3Helper(t);r.updateMatrixWorld(!0),r.geometry.applyMatrix4(r.matrixWorld),o.push(r.geometry)}));var c=THREE.BufferGeometryUtils.mergeBufferGeometries(o),f=new THREE.LineBasicMaterial({color:n});THREE.LineSegments.call(this,c,f),this.name="octreeHelper",o.forEach((function(e){e.dispose()}))},a.OctreeHelper.prototype=Object.create(THREE.LineSegments.prototype),a.OctreeHelper.prototype.constructor=a.OctreeHelper,a.getOctantsByLevels=function(e,t,r){for(var n=[];t<=r;){var a=e.findNodesByLevel(t)[Symbol.iterator]();if(a)for(var o=a.next();!o.done;)n.push(o.value),o=a.next();t++}return n},a.getLeafOctants=function(e,t){var r=[],n=e.leaves(),a=n.next();if(t=t||!0)for(;!a.done;)a.value.points&&r.push(a.value),a=n.next();else for(;!a.done;)r.push(a.value),a=n.next();return r},CanvasRenderingContext2D.prototype.clear=function(e){e&&(this.beginPath(),this.save(),this.setTransform(1,0,0,1,0,0)),this.clearRect(0,0,this.canvas.width,this.canvas.height),e&&this.restore()},CanvasRenderingContext2D.prototype.circle=function(e,t,r){return this.beginPath(),this.moveTo(e+r,t),this.arc(e,t,r,0,2*Math.PI),this},CanvasRenderingContext2D.prototype.fillCircle=function(e,t,r,n){return n&&(this.fillStyle=n),this.circle(e,t,r).fill(),this},CanvasRenderingContext2D.prototype.strokeCircle=function(e,t,r,n){return n&&(this.strokeStyle=n),this.circle(e,t,r).stroke(),this},CanvasRenderingContext2D.prototype.roundRect=function(e,t,r,n,a){var o={tl:0,tr:0,bl:0,br:0};if("object"==typeof a)for(var i in a)o[i]=a[i];if("number"==typeof a)for(var i in o)o[i]=a;return this.beginPath(),this.moveTo(e+o.tl,t),this.lineTo(e+r-o.tr,t),this.quadraticCurveTo(e+r,t,e+r,t+o.tr),this.lineTo(e+r,t+n-o.br),this.quadraticCurveTo(e+r,t+n,e+r-o.br,t+n),this.lineTo(e+o.bl,t+n),this.quadraticCurveTo(e,t+n,e,t+n-o.bl),this.lineTo(e,t+o.tl),this.quadraticCurveTo(e,t,e+o.tl,t),this.closePath(),this},CanvasRenderingContext2D.prototype.fillRoundRect=function(e,t,r,n,a,o){return o&&(this.fillStyle=o),this.roundRect(e,t,r,n,a).fill(),this},CanvasRenderingContext2D.prototype.strokeRoundRect=function(e,t,r,n,a,o){return o&&(this.strokeStyle=o),this.roundRect(e,t,r,n,a).stroke(),this},CanvasRenderingContext2D.prototype.polygon=function(e,t){t>0&&(e=function(e,t){function r(e,t,r,n,a,o){var i=Math.sqrt(Math.pow(r-e,2)+Math.pow(n-t,2)),s=o?a/i:(i-a)/i;return[e+s*(r-e),t+s*(n-t)]}var n,a,o,i,s,l,c,f,d=e.length,u=new Array(d);for(a=0;a<d;a++)(n=a-1)<0&&(n=d-1),(o=a+1)==d&&(o=0),i=e[n],s=e[a],l=e[o],c=r(i[0],i[1],s[0],s[1],t,!1),f=r(s[0],s[1],l[0],l[1],t,!0),u[a]=[c[0],c[1],s[0],s[1],f[0],f[1]];return u}(e,t)),this.beginPath();for(var r=0,n=e.length;r<n;r++){var a=e[r];0==r?this.moveTo(a[0],a[1]):this.lineTo(a[0],a[1]),t>0&&this.quadraticCurveTo(a[2],a[3],a[4],a[5])}return this.closePath(),this},CanvasRenderingContext2D.prototype.fillPolygon=function(e,t,r){return r&&(this.fillStyle=r),this.polygon(e,t).fill(),this},CanvasRenderingContext2D.prototype.strokePolygon=function(e,t,r){return r&&(this.strokeStyle=r),this.polygon(e,t).stroke(),this},CanvasRenderingContext2D.prototype.speechBubble=function(e,t,r,n,a,o,i,s){e=e||0,r=r||1,n=n||1,a=a||.2*n,o=o||e+r/2,s=s||a;var l,c,f,d=e+r,u=(t=t||0)+n;return(i=i||t+n+a)<t||i>t+n?(l=Math.min(Math.max(e+a,o-s/2),d-a-s),c=Math.min(Math.max(e+a+s,o+s/2),d-a)):(l=Math.min(Math.max(t+a,i-s/2),u-a-s),c=Math.min(Math.max(t+a+s,i+s/2),u-a)),i<t&&(f=2),i>t&&(f=3),o<e&&i>=t&&i<=u&&(f=0),o>e&&i>=t&&i<=u&&(f=1),o>=e&&o<=d&&i>=t&&i<=u&&(f=-1),this.beginPath(),this.moveTo(e+a,t),2==f?(this.lineTo(l,t),this.lineTo(o,i),this.lineTo(c,t),this.lineTo(d-a,t)):this.lineTo(d-a,t),this.quadraticCurveTo(d,t,d,t+a),1==f?(this.lineTo(d,l),this.lineTo(o,i),this.lineTo(d,c),this.lineTo(d,u-a)):this.lineTo(d,u-a),this.quadraticCurveTo(d,u,d-a,u),3==f?(this.lineTo(c,u),this.lineTo(o,i),this.lineTo(l,u),this.lineTo(e+a,u)):this.lineTo(e+a,u),this.quadraticCurveTo(e,u,e,u-a),0==f?(this.lineTo(e,c),this.lineTo(o,i),this.lineTo(e,l),this.lineTo(e,t+a)):this.lineTo(e,t+a),this.quadraticCurveTo(e,t,e+a,t),this.closePath(),this},CanvasRenderingContext2D.prototype.fillSpeechBubble=function(e,t,r,n,a,o,i,s,l){return l&&(this.fillStyle=l),this.speechBubble(e,t,r,n,a,o,i,s).fill(),this},CanvasRenderingContext2D.prototype.strokeSpeechBubble=function(e,t,r,n,a,o,i,s,l){return l&&(this.strokeStyle=l),this.speechBubble(e,t,r,n,a,o,i,s).stroke(),this},a.createFaceVertexUVs=function(e){!e instanceof THREE.Geometry||(e.faceVertexUvs[0]=[],e.faces.forEach((function(t){var r=["x","y","z"].sort((function(e,r){return Math.abs(t.normal[e])>Math.abs(t.normal[r])})),n=e.vertices[t.a],a=e.vertices[t.b],o=e.vertices[t.c];e.faceVertexUvs[0].push([new THREE.Vector2(n[r[0]],n[r[1]]),new THREE.Vector2(a[r[0]],a[r[1]]),new THREE.Vector2(o[r[0]],o[r[1]])])})),e.uvsNeedUpdate=!0)},a.loadObject3D=function(e){const t=["position","rotation","quaternion","scale"];var r=Array.isArray(e)?e:[e];return r.forEach(e=>{void 0===e.object?e.object={type:"Mesh"}:void 0===e.object.type&&(e.object.type="Mesh")}),function(r){const a=[];return r.forEach(e=>{a.push(function(e){var t=e.object;if(e.url){const t=[n(e.url)];return Promise.all(t).then(t=>(t[0].name=e.url,t[0]))}if("Sprite"===t.type){const t=[i(e.material)];return Promise.all(t).then(e=>new THREE.Sprite(e[0]))}if("Points"===t.type||"Mesh"===t.type||"SkinnedMesh"===t.type||"Line"===t.type||"LineLoop"===t.type||"LineSegments"===t.type){const r=[o(e.geometry),i(e.material)];return Promise.all(r).then(e=>new THREE[t.type](e[0],e[1]))}return Promise.resolve(void 0)}(e))}),Promise.all(a).then(n=>(n.forEach((e,n)=>{var a=r[n].object;Object.keys(a).map(r=>{"type"===r||(-1!==t.indexOf(r)?e[r].fromArray(a[r]):e[r]="userData"===r?JSON.parse(JSON.stringify(a[r])):"customDepthMaterial"===r||"customDistanceMaterial"===r?a[r].clone():a[r])})}),Array.isArray(e)?Promise.resolve(n):Promise.resolve(n[0])))}(r);function n(e){return e?new Promise(t=>{(new THREE.ObjectLoader).load(e,t)}):Promise.resolve(void 0)}function o(e){if(e){if(e instanceof THREE.BufferGeometry||e instanceof THREE.Geometry)return Promise.resolve(e);if(e.parameters)return new Promise(t=>{t(new THREE[e.type](...e.parameters))});if(e.attributes){var t=new THREE.BufferGeometry;return Object.keys(e.attributes).map(r=>{t.setAttribute(r,new THREE.Float32BufferAttribute(e.attributes[r],3))}),e.index&&t.setIndex(e.index),Promise.resolve(t)}return Promise.resolve(void 0)}return Promise.resolve(void 0)}function i(e){if(e){var t;const r={},n=Object.keys(e).map(n=>{if("type"===n)t=e[n];else{if(-1!==a.TEXTURE_MAPS.indexOf(n))return function(e){if(!e)return Promise.resolve(null);return e.isTexture?Promise.resolve(e):"string"==typeof e?new Promise(t=>{(new THREE.TextureLoader).load(e,t)}):Promise.resolve(void 0)}(e[n]).then(e=>{r[n]=e});r[n]=e[n]}});return Promise.all(n).then(()=>new THREE[t](r))}return Promise.resolve(void 0)}},a.loadTextures=function(e,t){var r=new THREE.TextureLoader,n=[];e.forEach(e=>{n.push(function(e,t){return new Promise(r=>{t.load(e,e=>{r(e)})})}(e,r))}),Promise.all(n).then(e=>{t&&t(e)})},a.ShaderChunk={},a.ShaderChunk.mod289="float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }",a.ShaderChunk.permute="float permute(float x) { return mod289(((x*34.0)+1.0)*x); }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }",a.ShaderChunk.snoise2="float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);vec2 i  = floor(v + dot(v, C.yy) );vec2 x0 = v -   i + dot(i, C.xx);vec2 i1;i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);vec4 x12 = x0.xyxy + C.xxzz;x12.xy -= i1;i = mod289(i);vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0) );vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);m = m*m; m = m*m ;vec3 x = 2.0 * fract(p * C.www) - 1.0;vec3 h = abs(x) - 0.5;vec3 ox = floor(x + 0.5);vec3 a0 = x - ox;m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );vec3 g;g.x  = a0.x  * x0.x  + h.x  * x0.y;g.yz = a0.yz * x12.xz + h.yz * x12.yw;return 130.0 * dot(m, g); }",a.ShaderChunk.taylorInvSqrt="float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }",a.ShaderChunk.snoise3="float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0);const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy));vec3 x0 = v - i + dot(i, C.xxx);vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min(g.xyz, l.zxy);vec3 i2 = max(g.xyz, l.zxy);vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i);vec4 p = permute( permute( permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_);vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0)*2.0 + 1.0;vec4 s1 = floor(b1)*2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;vec3 p0 = vec3(a0.xy,h.x);vec3 p1 = vec3(a0.zw,h.y);vec3 p2 = vec3(a1.xy,h.z);vec3 p3 = vec3(a1.zw,h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);m = m * m;return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3))); }",a.ShaderChunk.grad4="vec4 grad4(float j, vec4 ip) { const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p; }",a.ShaderChunk.snoise4="float snoise(vec4 v) { const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)));vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + C.xxxx;vec4 x2 = x0 - i2 + C.yyyy;vec4 x3 = x0 - i3 + C.zzzz;vec4 x4 = x0 + C.wwww;i = mod289(i);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 )) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))); }",a.ShaderChunk.fade2="vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}",a.ShaderChunk.cnoise2="float cnoise(vec2 P){vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);Pi = mod289(Pi);vec4 ix = Pi.xzxz;vec4 iy = Pi.yyww;vec4 fx = Pf.xzxz;vec4 fy = Pf.yyww;vec4 i = permute(permute(ix) + iy);vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;vec4 gy = abs(gx) - 0.5;vec4 tx = floor(gx + 0.5);gx = gx - tx;vec2 g00 = vec2(gx.x,gy.x);vec2 g10 = vec2(gx.y,gy.y);vec2 g01 = vec2(gx.z,gy.z);vec2 g11 = vec2(gx.w,gy.w);vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));g00 *= norm.x;g01 *= norm.y;g10 *= norm.z;g11 *= norm.w;float n00 = dot(g00, vec2(fx.x, fy.x));float n10 = dot(g10, vec2(fx.y, fy.y));float n01 = dot(g01, vec2(fx.z, fy.z));float n11 = dot(g11, vec2(fx.w, fy.w));vec2 fade_xy = fade(Pf.xy);vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);float n_xy = mix(n_x.x, n_x.y, fade_xy.y);return 2.3 * n_xy; }",a.ShaderChunk.fade3="vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }",a.ShaderChunk.cnoise3="float cnoise(vec3 P) { vec3 Pi0 = floor(P);vec3 Pi1 = Pi0 + vec3(1.0);Pi0 = mod289(Pi0);Pi1 = mod289(Pi1);vec3 Pf0 = fract(P);vec3 Pf1 = Pf0 - vec3(1.0);vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);vec4 iy = vec4(Pi0.yy, Pi1.yy);vec4 iz0 = Pi0.zzzz;vec4 iz1 = Pi1.zzzz;vec4 ixy = permute(permute(ix) + iy);vec4 ixy0 = permute(ixy + iz0);vec4 ixy1 = permute(ixy + iz1);vec4 gx0 = ixy0 * (1.0 / 7.0);vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;gx0 = fract(gx0);vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);vec4 sz0 = step(gz0, vec4(0.0));gx0 -= sz0 * (step(0.0, gx0) - 0.5);gy0 -= sz0 * (step(0.0, gy0) - 0.5);vec4 gx1 = ixy1 * (1.0 / 7.0);vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;gx1 = fract(gx1);vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);vec4 sz1 = step(gz1, vec4(0.0));gx1 -= sz1 * (step(0.0, gx1) - 0.5);gy1 -= sz1 * (step(0.0, gy1) - 0.5);vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));g000 *= norm0.x;g010 *= norm0.y;g100 *= norm0.z;g110 *= norm0.w;vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));g001 *= norm1.x;g011 *= norm1.y;g101 *= norm1.z;g111 *= norm1.w;float n000 = dot(g000, Pf0);float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));float n111 = dot(g111, Pf1);vec3 fade_xyz = fade(Pf0);vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);return 2.2 * n_xyz;}",a.ShaderChunk.pnoise3="float pnoise(vec3 P, vec3 rep) { vec3 Pi0 = mod(floor(P), rep);vec3 Pi1 = mod(Pi0 + vec3(1.0), rep);Pi0 = mod289(Pi0);Pi1 = mod289(Pi1);vec3 Pf0 = fract(P);vec3 Pf1 = Pf0 - vec3(1.0);vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);vec4 iy = vec4(Pi0.yy, Pi1.yy);vec4 iz0 = Pi0.zzzz;vec4 iz1 = Pi1.zzzz;vec4 ixy = permute(permute(ix) + iy);vec4 ixy0 = permute(ixy + iz0);vec4 ixy1 = permute(ixy + iz1);vec4 gx0 = ixy0 * (1.0 / 7.0);vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;gx0 = fract(gx0);vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);vec4 sz0 = step(gz0, vec4(0.0));gx0 -= sz0 * (step(0.0, gx0) - 0.5);gy0 -= sz0 * (step(0.0, gy0) - 0.5);vec4 gx1 = ixy1 * (1.0 / 7.0);vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;gx1 = fract(gx1);vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);vec4 sz1 = step(gz1, vec4(0.0));gx1 -= sz1 * (step(0.0, gx1) - 0.5);gy1 -= sz1 * (step(0.0, gy1) - 0.5);vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));g000 *= norm0.x;g010 *= norm0.y;g100 *= norm0.z;g110 *= norm0.w;vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));g001 *= norm1.x;g011 *= norm1.y;g101 *= norm1.z;g111 *= norm1.w;float n000 = dot(g000, Pf0);float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));float n111 = dot(g111, Pf1);vec3 fade_xyz = fade(Pf0);vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);return 2.2 * n_xyz;}",a.ShaderChunk.random="float random(vec2 p) { return fract(sin(mod(dot(p.xy, vec2(12.9898, 78.233)), 3.14))*43758.5453123); }",a.ShaderChunk.hash="float hash(float x) { return fract(sin(x) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }",a.ShaderChunk.noise2="float noise(vec2 p) { vec2 i = floor(p);vec2 f = fract(p);float a = hash(i);float b = hash(i + vec2(1.0, 0.0));float c = hash(i + vec2(0.0, 1.0));float d = hash(i + vec2(1.0, 1.0));vec2 u = f*f*(3.0 - 2.0*f);return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y; }",a.ShaderChunk.noise3="float noise(vec3 x) { const vec3 step = vec3(110, 241, 171);vec3 i = floor(x);vec3 f = fract(x);float n = dot(i, step);vec3 u = f * f * (3.0 - 2.0 * f);return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);}",a.ShaderChunk.fbm2="float fbm(vec2 p) { const int NUM_OCTAVES = 5;float v = 0.0;float a = 0.5;vec2 shift = vec2(100.0);mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));for (int i = 0; i < NUM_OCTAVES; ++i) {v += a * noise(p);p = rot * p * 2.0 + shift;a *= 0.5;}return v; }",a.ShaderChunk.fbm3="float fbm(vec3 x) { const int NUM_OCTAVES = 5;float v = 0.0;float a = 0.5;vec3 shift = vec3(100.0);for (int i = 0; i < NUM_OCTAVES; ++i) {v += a * noise(x);x = x * 2.0 + shift;a *= 0.5;}return v; }",a.ShaderChunk.fbm2IQ="float fbmIQ(vec2 p){ const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);float f = 0.0;f += 0.5000*noise( p ); p = m2*p*2.02;f += 0.2500*noise( p ); p = m2*p*2.03;f += 0.1250*noise( p ); p = m2*p*2.01;f += 0.0625*noise( p );return f/0.9375; }",a.ShaderChunk.clipToScreenPos="\nvec2 clipToScreenPos( vec4 clipPos ) {\n    vec2 ndcPos = clipPos.xy / clipPos.w; // ndc = [-1,1]\n    vec2 screenPos = ndcPos * 0.5 + 0.5;  // screenPos = [0,1]\n    return screenPos;\n}",a.ShaderChunk.caustics="\nvec3 caustics( vec2 uv, float density, vec3 baseColor )\n// density: larger -> higher frequent (1.0 ~ 16.0)\n{\n    const int MAX_ITER = 10;\n    const float inten = 0.005; // light intensity: larger -> brighter (range = 0.015 ~ 0.055)\n    const float speed = 1.5;   // water speed: larger -> slower (range = 0.1 ~ 1.5)\n    const float speed2 = 3.0;  // water speed: larger -> faster (range = 0.0 ~ 10.0)\n    const float freq = 0.8;    // water ripples (range = 0.5 ~ 1.0(= oil))\n    const float xflow = 0.0;   // flow speed in x direction (range = -10 ~ +10)\n    const float zflow = 0.0;   // flow speed in z direction (range = -10 ~ +10)\n    float c = 1.5;             // global brightness: larger -> darker (default = 1.0, range = 0.0 ~ 5.0)\n    vec2 p = mod( uv * PI2*density, PI2*density ) - 250.0;\n    vec2 i = p;\n    for( int n = 0; n < MAX_ITER; n++ ) {\n        float t = time * (1.0 - (3.0 / (float(n) + speed)));\n        i = p + vec2( cos(t - i.x * freq) + sin(t + i.y * freq) + (time * xflow), sin(t - i.y * freq) + cos(t + i.x * freq) + (time * zflow) );\n        c += 1.0 / length( vec2( p.x / (sin(i.x + t * speed2) / inten), p.y / (cos(i.y + t * speed2) / inten) ) );\n    }\n    c /= float( MAX_ITER );\n    c = 1.17 - pow( c, 1.4 );\n    vec3 color = vec3( pow( abs(c), 8.0 ) );\n    color = saturate( baseColor + color );\n    return color;\n}",a.ToonShader={uniforms:{uDirLightPos:{value:new THREE.Vector3},uDirLightColor:{value:new THREE.Color(16777215)},uMaterialColor:{value:new THREE.Color(16777215)},uKd:{value:.97},uBorder:{value:.4}},vertexShader:["varying vec3 vNormal;","varying vec3 vViewPosition;","void main() {","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","vNormal = normalize( normalMatrix * normal );","vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","vViewPosition = -mvPosition.xyz;","}"].join("\n"),fragmentShader:["uniform vec3 uMaterialColor;","uniform vec3 uDirLightPos;","uniform vec3 uDirLightColor;","uniform float uKd;","uniform float uBorder;","varying vec3 vNormal;","varying vec3 vViewPosition;","void main() {","vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );","vec3 lVector = normalize( lDirection.xyz );","vec3 normal = normalize( vNormal );","float diffuse = dot( normal, lVector );","if ( diffuse > 0.6 ) { diffuse = 1.0; }","else if ( diffuse > -0.2 ) { diffuse = 0.7; }","else { diffuse = 0.3; }","gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );","}"].join("\n")},a.SkyShader={uniforms:{turbidity:{value:10},rayleigh:{value:3},mieCoefficient:{value:.005},mieDirectionalG:{value:.7},luminance:{value:1},sunPosition:{value:new THREE.Vector3}},vertexShader:["uniform vec3 sunPosition;","uniform float rayleigh;","uniform float turbidity;","uniform float mieCoefficient;","varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","const vec3 up = vec3( 0.0, 1.0, 0.0 );","const float e = 2.71828182845904523536028747135266249775724709369995957;","const float pi = 3.141592653589793238462643383279502884197169;","const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );","const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );","const float v = 4.0;","const vec3 K = vec3( 0.686, 0.678, 0.666 );","const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );","const float cutoffAngle = 1.6110731556870734;","const float steepness = 1.5;","const float EE = 1000.0;","float sunIntensity( float zenithAngleCos ) {","\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );","\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );","}","vec3 totalMie( float T ) {","\tfloat c = ( 0.2 * T ) * 10E-18;","\treturn 0.434 * c * MieConst;","}","void main() {","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvWorldPosition = worldPosition.xyz;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","\tvSunDirection = normalize( sunPosition );","\tvSunE = sunIntensity( dot( vSunDirection, up ) );","\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );","\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );","\tvBetaR = totalRayleigh * rayleighCoefficient;","\tvBetaM = totalMie( turbidity ) * mieCoefficient;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","uniform float luminance;","uniform float mieDirectionalG;","const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );","const float pi = 3.141592653589793238462643383279502884197169;","const float n = 1.0003;","const float N = 2.545E25;","const float rayleighZenithLength = 8.4E3;","const float mieZenithLength = 1.25E3;","const vec3 up = vec3( 0.0, 1.0, 0.0 );","const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;","const float THREE_OVER_SIXTEENPI = 0.05968310365946075;","const float ONE_OVER_FOURPI = 0.07957747154594767;","float rayleighPhase( float cosTheta ) {","\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );","}","float hgPhase( float cosTheta, float g ) {","\tfloat g2 = pow( g, 2.0 );","\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );","\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );","}","const float A = 0.15;","const float B = 0.50;","const float C = 0.10;","const float D = 0.20;","const float E = 0.02;","const float F = 0.30;","const float whiteScale = 1.0748724675633854;","vec3 Uncharted2Tonemap( vec3 x ) {","\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;","}","void main() {","\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );","\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );","\tfloat sR = rayleighZenithLength * inverse;","\tfloat sM = mieZenithLength * inverse;","\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );","\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );","\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );","\tvec3 betaRTheta = vBetaR * rPhase;","\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );","\tvec3 betaMTheta = vBetaM * mPhase;","\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );","\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );","\tvec3 direction = normalize( vWorldPosition - cameraPos );","\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]","\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]","\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );","\tvec3 L0 = vec3( 0.1 ) * Fex;","\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );","\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;","\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );","\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );","\tvec3 color = curr * whiteScale;","\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );","\tgl_FragColor = vec4( retColor, 1.0 );","}"].join("\n")},a.SkyDomeShader={uniforms:{topColor:{value:new THREE.Color(30719)},bottomColor:{value:new THREE.Color(16777215)},offset:{value:33},exponent:{value:.6}},vertexShader:["varying vec3 vWorldPosition;","void main() {","vec4 worldPosition = modelMatrix * vec4(position, 1.0);","vWorldPosition = worldPosition.xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["uniform vec3 topColor;","uniform vec3 bottomColor;","uniform float offset;","uniform float exponent;","varying vec3 vWorldPosition;","void main() {","float h = normalize(vWorldPosition + offset).y;","gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);","}"].join("\n")},a.CloudDomeShader={uniforms:{noiseTex:{value:null},time:{value:1},sharp:{value:.9},cover:{value:.5},clouds:{value:1},depth:{value:0}},vertexShader:["uniform sampler2D noiseTex;","uniform float time;","varying vec2 vUv;","void main()","{","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float time;","uniform float depth;","uniform float sharp;","uniform float cover;","uniform float clouds;","uniform sampler2D noiseTex;","varying vec2 vUv;","vec3 noise3(vec2 p) {","\treturn texture2D(noiseTex, p).xyz;","}","vec3 fNoise(vec2 uv) {","\tvec3 f = vec3(0.0);","\tfloat scale = 1.;","\tfor (int i=0; i<5; i++) {","\t\tscale *= 2.0;","\t\tf += noise3(uv * scale) / scale;","\t}","\treturn f;","}","void main(void)","{","\tvec2 uv = vUv;","\tvec3 ff1 = fNoise(uv * 0.01 + time * 0.00015 * vec2(-1.0, 1.0));","\tvec3 ff2 = fNoise(uv * 0.1 + time * 0.0005 * vec2(1.0, 1.0));","\tfloat t = ff1.x * 0.9 + ff1.y * 0.15;","\tt = t * 0.99 + ff2.x * 0.01;","\tfloat o = clamp ( length(uv * 2.0 - vec2(1., 1.)), 0.0, 1.0 );","\to =  1.0 - o * o * o * o;","\to -= (1.0 - t) * 0.95;","\tt = max(t - (1.0 - cover), 0.0);","\tt = 1.0 - pow(1.0 - sharp, t);","\tt = min(t * 1.9, 1.0);","\tif (depth > 0.0) {","\t\tif (o < 0.4 && t < 0.8) discard;","\t\tgl_FragColor = vec4(gl_FragCoord.z, 1.0, 1.0, 1.0);","\t}","\telse {","\t\tgl_FragColor = vec4(t, t, t, o);","\t}","}"].join("\n")},a.RainDropShader={uniforms:{time:{value:0}},vertexShader:["precision highp float;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform float time;","attribute vec3 position;","attribute vec3 offset;","void main(void) {","vec3 translate = vec3(position.x, position.y - time, position.z);","gl_Position = projectionMatrix * modelViewMatrix * vec4(translate + offset, 1.0);","}"].join("\n"),fragmentShader:["precision highp float;","uniform float time;","void main(void) {","gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);","}"].join("\n")},a.RainRippleShader={uniforms:{time:{value:0}},vertexShader:["precision highp float;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","attribute vec3 position;","attribute vec3 offset;","varying vec3 vPosition;","varying vec3 vOffset;","void main(void) {","gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + offset.x, 0.0, position.z + offset.z, 1.0);","vPosition = position;","vOffset = offset;","}"].join("\n"),fragmentShader:["precision highp float;","uniform float time;","varying vec3 vPosition;","varying vec3 vOffset;","void main(void) {","float a = abs(0.04 * time * vOffset.y - length(vPosition));","float b = 0.004 / a;","float c = step(0.9, b);","gl_FragColor = vec4(1.0, 1.0, 1.0, c);","}"].join("\n")},a.SmokeShader={uniforms:{time:{value:0},size:{value:3},smokeTex:{value:null},lifetime:{value:10},projection:{value:0}},vertexShader:["attribute float shift;","uniform float time;","uniform float size;","uniform float lifetime;","uniform float projection;","varying float progress;","float cubicOut( float t ) {","float f = t - 1.0;","return f * f * f + 1.0;","}","void main () {","progress = fract( time * 2.0 / lifetime + shift );","float eased = cubicOut( progress );","vec3 pos = vec3( position.x * eased, position.y * eased, position.z * eased  );","gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );","gl_PointSize = ( projection * size ) / gl_Position.w;","}"].join("\n"),fragmentShader:["uniform sampler2D smokeTex;","varying float progress;","void main() {","vec3 color = vec3( 1.0 );","gl_FragColor = texture2D( smokeTex, gl_PointCoord ) * vec4( color, 0.3 * ( 1.0 - progress ) );","}"].join("\n")},a.VolumeFireShader={uniforms:{fireNoise:{value:null},fireProfile:{value:null},time:{value:1}},vertexShader:["attribute vec3 tex;","varying vec3 texOut;","void main ( void ) {","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );","texOut = tex;","}"].join("\n"),fragmentShader:["uniform sampler2D fireNoise;","uniform sampler2D fireProfile;","uniform float time;","varying vec3 texOut;","const float modulus = 61.0;  // Value used in pregenerated noise texture.","const float magnatude = 1.3;","const int octives = 4;","const float lacunarity = 2.0;","const float gain = 0.5;","vec2 mBBS( vec2 val, float modulus ) {","val = mod( val, modulus ); // For numerical consistancy.","return mod(val * val, modulus);","}","float mnoise ( vec3 pos ) {","float intArg = floor( pos.z );","float fracArg = fract( pos.z );","vec2 hash = mBBS( intArg * 3.0 + vec2( 0.0, 3.0 ), modulus );","vec4 g = vec4 (","texture2D( fireNoise, vec2( pos.x, pos.y + hash.x ) / modulus ).xy,","texture2D( fireNoise, vec2( pos.x, pos.y + hash.y ) / modulus ).xy) * 2.0 - 1.0;","return mix(","g.x + g.y * fracArg,","g.z + g.w * ( fracArg - 1.0 ),","smoothstep( 0.0, 1.0, fracArg )",");","}","float turbulence( vec3 pos ) {","float sum  = 0.0;","float freq = 1.0;","float amp  = 1.0;","for ( int i = 0; i < 4; i++ ) {","sum += abs( mnoise( pos * freq ) ) * amp;","freq *= lacunarity;","amp *= gain;","}","return sum;","}","vec4 sampleFire( vec3 loc, vec4 scale ) {","loc.xz = loc.xz * 2.0 - 1.0;","vec2 st = vec2( sqrt( dot( loc.xz, loc.xz ) ), loc.y );","loc.y -= time * scale.w; // Scrolling noise upwards over time.","loc *= scale.xyz; // Scaling noise space.","float offset = sqrt( st.y ) * magnatude * turbulence( loc );","st.y += offset;","if ( st.y > 1.0 ) {","return vec4( 0.0, 0.0, 0.0, 1.0 );","}","vec4 result = texture2D( fireProfile, st );","if ( st.y < 0.1 ) {","result *= st.y / 0.1;","}","return result;","}","void main( void ) {","vec3 color = sampleFire( texOut, vec4( 1.0, 2.0, 1.0, 0.5 ) ).xyz;","gl_FragColor = vec4( color * 1.5, 1.0 );","}"].join("\n")},a.FireParticlesShader={uniforms:{color:{value:null},strength:{value:0},texture:{value:null},time:{value:0},heightOfNearPlane:{value:0}},vertexShader:["attribute float randam;","attribute float sprite;","uniform float time;","uniform float strength;","uniform float heightOfNearPlane;","varying float vSprite;","varying float vOpacity;","float PI = 3.14;","float quadraticIn( float t ) {","float tt = t * t;","return tt * tt;","}","void main() {","float progress = fract( time + ( 2.0 * randam - 1.0 ) );","float progressNeg = 1.0 - progress;","float ease = quadraticIn( progress );","float influence = sin( PI * ease );","vec3 newPosition = position * vec3( 1.0, ease, 1.0 );","gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );","gl_PointSize = ( heightOfNearPlane * strength ) / gl_Position.w;","vOpacity = min( influence * 4.0, 1.0 ) * progressNeg;","vSprite = sprite;","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D texture;","varying float vSprite;","varying float vOpacity;","float ONE_SPRITE_ROW_LENGTH = 0.25;","void main() {","vec2 texCoord = vec2(","gl_PointCoord.x * ONE_SPRITE_ROW_LENGTH + vSprite,","gl_PointCoord.y",");","gl_FragColor = vec4( texture2D( texture, vec2( texCoord ) ).xyz * color * vOpacity, 1.0 );","}"].join("\n")},a.GPUParticlesShader={uniforms:{uTime:{value:0},uScale:{value:1},tNoise:{value:null},tSprite:{value:null}},vertexShader:["uniform float uTime;","uniform float uScale;","uniform sampler2D tNoise;","attribute vec3 positionStart;","attribute float startTime;","attribute vec3 velocity;","attribute float turbulence;","attribute vec3 color;","attribute float size;","attribute float lifeTime;","varying vec4 vColor;","varying float lifeLeft;","void main() {","\tvColor = vec4( color, 1.0 );","\tvec3 newPosition;","\tvec3 v;","\tfloat timeElapsed = uTime - startTime;","\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );","\tgl_PointSize = ( uScale * size ) * lifeLeft;","\tfloat velLength = length( velocity );","\tv.x = ( velocity.x - 0.5 ) * 3.0 * velLength;","\tv.y = ( velocity.y - 0.5 ) * 3.0 * velLength;","\tv.z = ( velocity.z - 0.5 ) * 3.0 * velLength;","\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;","\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;","\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 60.0 * velLength;","\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * turbulence ), ( timeElapsed / lifeTime ) );","\tif( v.y > 0.0 && v.y < 0.05 ) {","\t\tlifeLeft = 0.0;","\t}","\tif( v.x < - 1.45 ) {","\t\tlifeLeft = 0.0;","\t}","\tif( timeElapsed > 0.0 ) {","\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );","\t} else {","\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","\t\tlifeLeft = 0.0;","\t\tgl_PointSize = 0.0;","\t}","}"].join("\n"),fragmentShader:["float scaleLinear( float value, vec2 valueDomain ) {","\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );","}","float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {","\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );","}","varying vec4 vColor;","varying float lifeLeft;","uniform sampler2D tSprite;","void main() {","\tfloat alpha = 0.0;","\tif( lifeLeft > 0.995 ) {","\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );","\t} else {","\t\talpha = lifeLeft * 0.75;","\t}","\tvec4 tex = texture2D( tSprite, gl_PointCoord );","\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );","}"].join("\n")},a.WaterShader={uniforms:{tReflectionMap:{value:null},tRefractionMap:{value:null},tNormalMap:{value:null},textureMatrix:{value:null},time:{value:0},alpha:{value:.7},reflectivity:{value:.02},noiseScale:{value:1},distortionScale:{value:.5},waterColor:{value:null},sunColor:{value:null},sunDirection:{value:null},tHeightMap:{value:null},terrainHeight:{value:0},terrainBottom:{value:0},tFoam:{value:null},tShore:{value:null},foamRanges:{value:new THREE.Vector2},foamIntensity:{value:0},shoreRange:{value:0},shoreColor:{value:new THREE.Color}},vertexShader:"\n\t\t#include <fog_pars_vertex>\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n        varying vec4 vWaterPosition;\n\t\tvoid main() {\n\t\t    vUv = uv;\n\t\t    vCoord = textureMatrix * vec4( position, 1.0 );\n\t\t    vWaterPosition = modelMatrix * vec4( position, 1.0 );\n\t\t    vec4 mvPosition = viewMatrix * vWaterPosition; // used in fog_vertex\n            gl_Position = projectionMatrix * mvPosition;\n\t\t    #include <fog_vertex>\n\t\t}\n\t",fragmentShader:`\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap;\n\t\tuniform float time;\n\t\tuniform float alpha;\n\t\tuniform float reflectivity;\n\t\tuniform float noiseScale;\n\t\tuniform float distortionScale;\n\t\tuniform vec3 waterColor;\n\t\tuniform vec3 sunColor;\n        uniform vec3 sunDirection;\n    #ifdef USE_HEIGHTMAP\n        uniform sampler2D tHeightMap;\n        uniform float terrainHeight; // height size of terrain\n        uniform float terrainBottom; // bottom y coord of terrain\n        uniform sampler2D tFoam;\n        uniform sampler2D tShore;\n        uniform vec2 foamRanges; // x = range for shore foam, y = range for near shore foam\n        uniform float foamIntensity;\n        uniform float shoreRange;\n        uniform vec3 shoreColor;\n    #endif\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n        varying vec4 vWaterPosition;\n        vec4 getNoise( vec2 uv )\n        {\n\t\t    vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t    vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t    vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t    vec4 noise = texture2D( tNormalMap, uv0 ) +\n\t\t    \ttexture2D( tNormalMap, uv1 ) +\n\t\t    \ttexture2D( tNormalMap, uv2 ) +\n\t\t    \ttexture2D( tNormalMap, uv3 );\n\t\t    return noise * 0.5 - 1.0;\n\t\t}\n        void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor )\n        {\n\t\t    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t    specularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n        }\n    #ifdef USE_HEIGHTMAP\n        float getWaterDepth( vec2 uv, float waterY )\n        {\n            float h = texture2D( tHeightMap, uv ).x * terrainHeight;\n            return waterY - (terrainBottom + h);\n        }\n        vec3 depthRefraction( float waterDepth, vec3 waterPos, vec3 refractColor )\n        {\n            // const vec3 deepWaterColor = vec3(0.031, 0.101, 0.349);\n            const vec3 deepWaterColor = vec3(0.0, 0.007, 0.121);\n            const float waterClarity = 0.25;\n            const float visibility = 10.0;\n\n            // (cf) waterExtinction: (r,g,b) die out at water depth = (4.5(m), 75(m), 300(m))\n            // (cf) Assumed max_depth of water (in this scene) = 600 (m)\n            float extinctScale = (waterPos.y - terrainBottom) / 600.0;\n            vec3 waterExtinction = vec3(4.5, 75.0, 300.0) * extinctScale;\n\n            float eyeToWater = length( cameraPosition - waterPos );\n            float eyeToBottom = cameraPosition.y - terrainBottom;\n            float viewWaterDepth = eyeToWater * waterDepth / (eyeToBottom - waterDepth);\n\n            float accDepth = viewWaterDepth * waterClarity; // accumulated water depth\n            float accDepthExp = saturate( accDepth / (2.5 * visibility) );\n            // accDepthExp *= (1.0 - accDepthExp) * accDepthExp * accDepthExp + 1.0; // out cubic\n\n            float shoreRange = max( foamRanges.x, foamRanges.y ) * 2.0;\n            vec3 waterColorS = mix( shoreColor, waterColor, saturate(waterDepth/shoreRange) );\n            vec3 waterColorD = mix( waterColorS, deepWaterColor, saturate(waterDepth/waterExtinction) );\n\n            refractColor = mix( refractColor, waterColorS * waterColorD, saturate(accDepth/visibility) );\n            refractColor = mix( refractColor, deepWaterColor, accDepthExp );\n            refractColor = mix( refractColor, deepWaterColor * waterColorD, saturate(waterDepth/waterExtinction) );\n            return refractColor;\n        }\n        float foamColor( sampler2D tex, vec2 uv, vec2 uv2, vec2 ranges, vec2 factors, float waterDepth, float baseColor )\n        {\n            float f1 = texture2D(tex, uv).r;\n            float f2 = texture2D(tex, uv2).r;\n            return mix( f1*factors.x + f2*factors.y, baseColor, smoothstep(ranges.x, ranges.y, waterDepth) );\n        }\n        float foamValue( float waterDepth, vec3 waterPos )\n        {\n            const float foamSpeed = 10.0;\n            const vec2 foamNoise = vec2(0.37, 0.5); // (shore,outer)\n            const vec2 noiseSpeed = vec2(-0.3, 0.05); // (shore,outer)\n            const vec2 foamTiling = vec2(2.0, 0.5);\n\n            float s = sin(time*0.01 + waterPos.x);\n            vec2 uv = waterPos.xz + foamSpeed + s * 0.05;\n            s = sin(time*0.01 + waterPos.z);\n            vec2 uv2 = (waterPos.xz + foamSpeed*1.5 + s * 0.05) * 0.5;\n            vec2 uv3 = uv * foamTiling.x;\n            vec2 uv4 = (waterPos.xz + foamSpeed*1.5*(-0.3) + s * 0.05) * 0.5 * foamTiling.y;\n            uv *= foamTiling.y;\n            uv2 *= foamTiling.y;\n\n            vec2 ranges = foamRanges;\n            ranges.x += rand( waterPos.xz + noiseSpeed.x ) * foamNoise.x;\n            ranges.y += rand( waterPos.xz + noiseSpeed.y ) * foamNoise.y;\n            ranges = clamp(ranges, 0.0, 10.0);\n\n            float foamEdge = max( ranges.x, ranges.y );\n            float deepFoam = foamColor( tFoam, uv, uv2, vec2(ranges.x, foamEdge), vec2(1.0, 0.5), waterDepth, 0.0 );\n            float foam = foamColor( tShore, uv3*0.25, uv4, vec2(0.0, ranges.x), vec2(0.75, 1.5), waterDepth, deepFoam );\n            return foam;\n        }\n    #endif\n    #ifdef USE_CAUSTICS\n        ${a.ShaderChunk.caustics}\n    #endif\n        void main()\n        {\n\t\t    vec4 noise = getNoise( vWaterPosition.xz * noiseScale );\n            vec3 waterNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n            vec3 waterToEye = cameraPosition - vWaterPosition.xyz;\n            vec3 eyeDirection = normalize( waterToEye );\n\n            // fresnel\n            float dotNV = max( dot( eyeDirection, waterNormal ), 0.0 );\n            // float fresnel = mix( 1.0 - dotNV, 1.0, reflectivity ); // reflectance\n            float fresnel = mix( 0.1*(1.0 - dotNV), 1.0, reflectivity ); // reflectance\n\n            // sun light\n\t\t    vec3 diffuseLight = vec3(0.0);\n            vec3 specularLight = vec3(0.0);\n            sunLight( waterNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n            // diffuse\n            vec3 diffuseColor = saturate( diffuseLight * waterColor );\n\n            // (pure) reflection & refraction\n\t\t    vec3 coord = vCoord.xyz / vCoord.w;\n\t\t    vec2 uv = coord.xy + coord.z * waterNormal.xz * 0.05 * distortionScale;\n            vec3 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) ).rgb;\n            vec3 refractColor = texture2D( tRefractionMap, uv ).rgb;\n\n            // set reflectColor = refractColor when looking up in the water\n            reflectColor = mix( refractColor, reflectColor, step(0.0, eyeDirection.y) );\n\n        #ifdef USE_HEIGHTMAP\n            // water depth\n            float waterDepth = getWaterDepth( vUv, vWaterPosition.y );\n\n            // refract based on water depth\n            vec3 refractColorD = depthRefraction( waterDepth, vWaterPosition.xyz, refractColor );\n\n            // foam\n            float foam = foamValue( waterDepth, vWaterPosition.xyz );\n            foam *= foamIntensity;\n\n            // shoreFade\n            float shoreFade = 0.2;\n            shoreFade = saturate( waterDepth * shoreFade );\n\n            // refraction\n            refractColor = mix( refractColor, reflectColor, fresnel * saturate( waterDepth / (foamRanges.x * 0.4) ) );\n            refractColor = mix( refractColor, shoreColor, 0.30 * shoreFade );\n\n            // final color\n            vec3 color = mix( refractColorD, reflectColor, fresnel );\n            color = saturate( diffuseColor + color + max( specularLight, foam * sunColor ) );\n            color = mix( refractColor + specularLight*shoreFade, color, shoreFade );\n        #else\n            vec3 color = mix( diffuseColor + refractColor, specularLight + reflectColor, fresnel );\n        #endif\n\n        #ifdef USE_CAUSTICS\n            color += caustics( vUv, 8.0, vec3(0.0) ) * 0.5;\n        #endif\n\n            gl_FragColor = vec4( color, alpha );\n\n\t\t    #include <tonemapping_fragment>\n\t\t    #include <fog_fragment>\n\t\t}\n\t`},a.WaterFlowShader={uniforms:{tReflectionMap:{value:null},tRefractionMap:{value:null},tNormalMap0:{value:null},tNormalMap1:{value:null},textureMatrix:{value:null},config:{value:new THREE.Vector3},time:{value:0},alpha:{value:.7},reflectivity:{value:.02},noiseScale:{value:1},distortionScale:{value:.5},waterColor:{value:null},sunColor:{value:null},sunDirection:{value:null}},vertexShader:"\n\t\t#include <fog_pars_vertex>\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vWaterPosition;\n\t\tvoid main() {\n\t\t    vUv = uv;\n\t\t    vCoord = textureMatrix * vec4( position, 1.0 );\n\t\t    vWaterPosition = modelMatrix * vec4( position, 1.0 );\n\t\t    vec4 mvPosition = viewMatrix * vWaterPosition; // used in fog_vertex\n\t\t    gl_Position = projectionMatrix * mvPosition;\n\t\t    #include <fog_vertex>\n\t\t}\n\t",fragmentShader:"\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\t\tuniform vec3 config;\n\t\t#ifdef USE_FLOWMAP\n\t\t    uniform sampler2D tFlowMap;\n\t\t#else\n\t\t    uniform vec2 flowDirection;\n\t\t#endif\n\t\tuniform float time;\n\t\tuniform float alpha;\n\t\tuniform float reflectivity;\n\t\tuniform float noiseScale;\n\t\tuniform float distortionScale;\n\t\tuniform vec3 waterColor;\n\t\tuniform vec3 sunColor;\n\t\tuniform vec3 sunDirection;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vWaterPosition;\n\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t    specularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t}\n\t\tvoid main() {\n\t\t    float flowMapOffset0 = config.x;\n\t\t    float flowMapOffset1 = config.y;\n\t\t    float halfCycle = config.z;\n\t\t    vec3 waterToEye = cameraPosition - vWaterPosition.xyz;\n\t\t    vec3 eyeDirection = normalize( waterToEye );\n\t\t    vec2 flow;\n\t\t    #ifdef USE_FLOWMAP\n\t\t    \tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t    #else\n\t\t    \tflow = flowDirection;\n\t\t    #endif\n\t\t    flow.x *= - 1.0;\n\t\t    vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * noiseScale ) + flow * flowMapOffset0 );\n\t\t    vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * noiseScale ) + flow * flowMapOffset1 );\n\t\t    float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t    vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\t\t    vec3 waterNormal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\t\t    vec3 diffuseLight = vec3(0.0);\n\t\t    vec3 specularLight = vec3(0.0);\n\t\t    sunLight( waterNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\t\t    float dotNV = max( dot( eyeDirection, waterNormal ), 0.0 );\n\t\t    float reflectance = mix( 1.0 - dotNV, 1.0, reflectivity ); // fresnel\n\t\t    vec3 coord = vCoord.xyz / vCoord.w;\n\t\t    vec2 uv = coord.xy + coord.z * waterNormal.xz * 0.05 * distortionScale;\n\t\t    vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t    vec4 refractColor = texture2D( tRefractionMap, uv );\n\t\t    vec3 reflected = reflectColor.rgb + specularLight;\n\t\t    vec3 refracted = refractColor.rgb + diffuseLight * waterColor;\n\t\t    vec3 color = mix( refracted, reflected, reflectance );\n\t\t    gl_FragColor = vec4( color, alpha );\n\t\t    #include <tonemapping_fragment>\n\t\t    #include <fog_fragment>\n\t\t}\n\t"},a.NoiseShader={uniforms:{scale:{value:10}},vertexShader:["varying vec3 vPosition;","varying vec2 vUv;","void main() {","vPosition = normalize(position);","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);","}"].join("\n"),fragmentShader:["varying vec3 vPosition;","varying vec2 vUv;","uniform float scale;",a.ShaderChunk.mod289,a.ShaderChunk.permute,a.ShaderChunk.taylorInvSqrt,a.ShaderChunk.snoise3,"void main() {","float n = snoise(vPosition * scale);","n = n*0.5 + 0.5;","gl_FragColor = vec4(n, n, n, 1.0);","}"].join("\n")},a.TerrainHeightShader={uniforms:{landscape:{value:5},scale:{value:new THREE.Vector2(1.5,1.5)},offset:{value:new THREE.Vector2(0,0)}},vertexShader:["uniform vec2 scale;","uniform vec2 offset;","varying vec2 vUv;","void main( void ) {","vUv = uv * scale + offset;","gl_Position = projectionMatrix * (modelViewMatrix * vec4( position, 1.0 ));","}"].join("\n"),fragmentShader:["uniform int landscape;","varying vec2 vUv;",a.ShaderChunk.hash,a.ShaderChunk.noise2,a.ShaderChunk.mod289,a.ShaderChunk.permute,a.ShaderChunk.snoise2,a.ShaderChunk.fbm2IQ,"#define BADLAND_TERRAIN\t\t0\t// used for bandland terrains","#define MOUNTAIN_TERRAIN\t\t1\t// used for mountainous terrains","#define DOME_TERRAIN\t\t\t2\t// used for dome-shaped terrains","#define RIDGE_TERRAIN\t\t\t3\t// used for sharp-shaped terrains","#define DESIGN_TERRAIN\t\t\t4\t// used for user-defined terrains","#define GIANT_TERRAIN\t\t\t5\t// used for giant terrains","#define TRIANGLE_TERRAIN\t\t6\t// used for triangle terrains","float badlandTerrain(vec2 p){","const int octaves = 5;","float flatten = 1.0;","mat2 m2 = mat2(0.8,-0.6,0.6,0.8);","float a = 0.0;","float b = 0.5;","float d = 0.0;","for(int i=0; i<octaves; i++)","{","float n = snoise(p);","d += n;","a += b*n/(1.0+d*d);","b *= 0.5;","p = m2*(p*2.0);","}","return pow(a, flatten);","}","float mountainTerrain(vec2 p){","const int octaves = 5;","float flatten = 2.0;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","v += a * snoise(p);","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v*0.5 + 0.5, flatten);","}","float domeTerrain(vec2 p){","const int octaves = 2;","float flatten = 1.5;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","v += a * abs( snoise(p) );","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v, flatten);","}","float ridgeTerrain(vec2 p){","const int octaves = 5;","float flatten = 2.0;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","float n = 1.0 - abs( snoise(p) );","v += a * (n*n);","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v, flatten);","}","float designTerrain(vec2 p){","float ridgeTerrain = ridgeTerrain(p*9.0);","float flatTerrain = mountainTerrain(p*2.0);","float ctrlTerrain = domeTerrain(p);","ctrlTerrain += 0.25 * ctrlTerrain;","float e = ctrlTerrain / 100.0;","const float b = 0.5;","const float off = 0.05;","return mix( flatTerrain, ridgeTerrain, smoothstep(b-off, b+off, e) );","}","float giantTerrain(vec2 p){","mat2 m2 = mat2(1.3623, 1.7531, -1.7131, 1.4623);","const int octaves = 5;","float flatten = 2.0;","vec2 pos = p*5.0;","float w = fbmIQ(pos*0.25)*0.75+0.25;","w = 2.0 * w * w;","float f = 0.0;","for(int i = 0; i < octaves; i++){","f += w * fbmIQ(pos);","w = -w * 0.5;","pos = m2 * pos;","}","float ff = fbmIQ(pos*0.002);","f += pow(abs(ff), 10.0);","return pow(f, flatten);","}","float tri(float x){ return abs(fract(x)-0.5); }","float triXY(vec2 p){ return tri(p.x+tri((p.y-0.25)*1.5)) + tri(p.y-tri((p.x+0.5)*1.5)); }","float triSmooth(float x){ return 0.25+0.25*cos((x)*6.2831853); }","float triSmoothXY(vec2 p){ return triSmooth(p.x+triSmooth((p.y-0.25)*1.5)) + triSmooth(p.y-triSmooth((p.x+0.5)*1.5)); }","float smoothCurve(float x) {","x = max((x - 0.3)/0.7, 0.0);","return x*x*(3.0 - 2.0*x);","}","float triangleTerrain(vec2 p){","p *= 2.0;","float h = triSmoothXY( p/2.0 )*0.66 + triSmoothXY( p/1.0 )*0.34;","h = smoothCurve( h )*0.75 + triXY( p/1.0 )*0.15 + triXY( p*4.0 )*0.1;","return h * 0.75;","}","float terrain( int type, vec2 p ){","float h = 0.0;","p *= 3.0;","if( type == BADLAND_TERRAIN ) h = badlandTerrain(p);","else if( type == MOUNTAIN_TERRAIN ) h = mountainTerrain(p);","else if( type == DOME_TERRAIN ) h = domeTerrain(p);","else if( type == RIDGE_TERRAIN ) h = ridgeTerrain(p);","else if( type == DESIGN_TERRAIN ) h = designTerrain(p);","else if( type == GIANT_TERRAIN ) h = giantTerrain(p);","else if( type == TRIANGLE_TERRAIN ) h = triangleTerrain(p);","return h;","}","void main(){","float h = terrain( landscape, vUv );","gl_FragColor = vec4( h, h, h, 1.0 );","}"].join("\n")},a.TerrainNormalShader={uniforms:{tHeight:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tHeight;","varying vec2 vUv;","float terrainHeight( in sampler2D tex, in vec2 uv ) {","return texture2D( tex, uv ).x;","}","vec3 terrainNormal( in sampler2D tex, in vec3 p, in float tol ) {","vec2 eps = vec2( 0.002*tol, 0.0 );","return normalize( vec3(","terrainHeight(tex, p.xz-eps.xy) - terrainHeight(tex, p.xz+eps.xy),","2.0*eps.x,","terrainHeight(tex, p.xz-eps.yx) - terrainHeight(tex, p.xz+eps.yx)));","}","void main() {","vec3 normal = terrainNormal( tHeight, vec3( vUv.x, 0.0, vUv.y ), 1.0 );","gl_FragColor = vec4( 0.5*normal.xzy + 0.5, 1.0 );","}"].join("\n")},a.CurlNoiseParticleShader={uniforms:{time:{value:0},tPosition:{value:null},color1:{value:null},color2:{value:null},opacity:{value:.75},sizeBase:{value:0},sizeExtra:{value:9.9},hardness:{value:.16},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(0,1,0)}},vertexShader:["varying float vColor;","varying float vAlpha;","uniform sampler2D tPosition;","uniform float opacity;","uniform float sizeBase;","uniform float sizeExtra;","uniform vec3 emitPos;","uniform vec3 emitVec;",a.ShaderChunk.random,"void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec3 pos = texture2D( tPosition, uv ).xyz;","float t = dot(emitDir, pos - emitPos);","if( t < 0.0 ) { pos = pos - t*emitDir; t = 0.0; }","vec3 tpos = emitPos + t*emitDir;","vec3 rvec = pos - tpos;","float r = (1.0 - cos(smoothstep(0.0, 0.2*emitLength, t) * 3.141592654)) * 0.5;","pos = pos + (r-1.0) * rvec;","vColor = random(uv + vec2(23.0, 31.22));","gl_Position = projectionMatrix * viewMatrix  * vec4( pos, 1.0 );","vAlpha = smoothstep(0.8*emitLength + 0.2*emitLength*random(uv + 1.0), 0.7*emitLength, t);","vAlpha *= clamp(1000.0 / gl_Position.z, 0.0, 1.0) * opacity;","gl_PointSize = (sizeBase + random(uv) * sizeExtra) * (500.0 / gl_Position.z);","}"].join("\n"),fragmentShader:["varying float vColor;","varying float vAlpha;","uniform vec3 color1;","uniform vec3 color2;","uniform float hardness;","uniform float time;","void main() {","float d = length(gl_PointCoord.xy - .5) * 2.0;","if( d > 1.0 ) discard;","float c = 1.0 - smoothstep(hardness, 1.0, d);","gl_FragColor = vec4(mix(color1, color2, vColor) * c, 1.0) * vAlpha;","}"].join("\n")},a.CurlNoiseCopyShader={uniforms:{resolution:{value:null},texture:{value:null}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D texture;","void main() {","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 color = texture2D( texture, uv ).xyz;","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")},a.CurlNoiseVelocityShader={uniforms:{time:{value:0},tPosition:{value:null},resolution:{value:null},speed:{value:1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tPosition;","uniform float speed;","uniform vec3 emitPos;","uniform vec3 emitVec;",a.ShaderChunk.mod289,a.ShaderChunk.permute,a.ShaderChunk.taylorInvSqrt,a.ShaderChunk.snoise3,a.ShaderChunk.random,"vec3 snoiseVec3( vec3 x ){","float s  = snoise(vec3( x ));","float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));","float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));","vec3 c = vec3( s , s1 , s2 );","return c;","}","vec3 curlNoise( vec3 p ){","const float e = .1;","vec3 dx = vec3( e   , 0.0 , 0.0 );","vec3 dy = vec3( 0.0 , e   , 0.0 );","vec3 dz = vec3( 0.0 , 0.0 , e   );","vec3 p_x0 = snoiseVec3( p - dx );","vec3 p_x1 = snoiseVec3( p + dx );","vec3 p_y0 = snoiseVec3( p - dy );","vec3 p_y1 = snoiseVec3( p + dy );","vec3 p_z0 = snoiseVec3( p - dz );","vec3 p_z1 = snoiseVec3( p + dz );","float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;","float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;","float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;","const float divisor = 1.0 / ( 2.0 * e );","return normalize( vec3( x , y , z ) * divisor );","}","void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = curlNoise(position * 0.02) * 0.1;","float t = dot(emitDir, position - emitPos);","float v = pow(smoothstep(0.0, emitLength, t), 2.0);","v = 0.05 + v * (0.2 + random(uv) * 0.2);","v = clamp(v, 0.01, 5.0);","velocity += emitDir * v;","velocity *= speed;","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},a.CurlNoiseVelocity4dShader={uniforms:{time:{value:0},tPosition:{value:null},resolution:{value:null},speed:{value:1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tPosition;","uniform float time;","uniform float speed;","uniform vec3 emitPos;","uniform vec3 emitVec;",a.ShaderChunk.mod289,a.ShaderChunk.permute,a.ShaderChunk.taylorInvSqrt,a.ShaderChunk.grad4,a.ShaderChunk.snoise4,a.ShaderChunk.random,"vec4 snoiseVec4( vec4 x ){","float s  = snoise(vec4( x ));","float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.w + 47.2 , x.x + 12.2 ));","float s2 = snoise(vec4( x.z + 74.2 , x.w - 124.5 , x.x + 99.4 , x.y - 123.2 ));","float s3 = snoise(vec4( x.w + 21.2 , x.x - 52.5 , x.y + 60.4 , x.z + 42.2 ));","vec4 c = vec4( s , s1 , s2 , s3 );","return c;","}","vec4 curlNoise( vec4 p ){","const float e = .1;","vec4 dx = vec4( e   , 0.0 , 0.0 , 0.0 );","vec4 dy = vec4( 0.0 , e   , 0.0 , 0.0 );","vec4 dz = vec4( 0.0 , 0.0 , e   , 0.0 );","vec4 dw = vec4( 0.0 , 0.0 , 0.0 , e  );","vec4 p_x0 = snoiseVec4( p - dx );","vec4 p_x1 = snoiseVec4( p + dx );","vec4 p_y0 = snoiseVec4( p - dy );","vec4 p_y1 = snoiseVec4( p + dy );","vec4 p_z0 = snoiseVec4( p - dz );","vec4 p_z1 = snoiseVec4( p + dz );","vec4 p_w0 = snoiseVec4( p - dw );","vec4 p_w1 = snoiseVec4( p + dw );","float x = p_y1.z - p_y0.z - p_z1.w + p_z0.w + p_w0.y - p_w1.y;","float y = p_z1.w - p_z0.w - p_w1.x + p_w0.x + p_x0.z - p_x1.z;","float z = p_w1.x - p_w0.x - p_x1.y + p_x0.y + p_y0.w - p_y1.w;","float w = p_x1.y - p_x0.y - p_y1.z + p_y0.z + p_z0.x - p_y1.x;","const float divisor = 1.0 / ( 2.0 * e );","return normalize( vec4( x , y , z, w ) * divisor );","}","void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = curlNoise(vec4(position * 0.02, time * 0.001 * speed)).xyz * 0.1;","float t = dot(emitDir, position - emitPos);","float l = pow(smoothstep(0.0, emitLength, t), 2.0);","l = 0.05 + l * (0.2 + random(uv) * 0.2);","l = clamp(l, 0.01, 5.0);","velocity += emitDir * l;","velocity *= speed;","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},a.CurlNoisePositionShader={uniforms:{delta:{value:0},tPosition:{value:null},tVelocity:{value:null},resolution:{value:null},spread:{value:.1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tVelocity;","uniform sampler2D tPosition;","uniform float delta;","uniform vec3 emitPos;","uniform vec3 emitVec;","uniform float spread;",a.ShaderChunk.random,"void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = texture2D( tVelocity, uv ).xyz;","position += velocity * delta * 1.0;","float t = dot(emitDir, position - emitPos);","if(t > emitLength) {","position = emitPos;","position.x += emitLength*spread*(random(uv + vec2(21.3, 63.21))-0.5);","position.y += emitLength*spread*(random(uv + vec2(32.3, 734.21))-0.5);","position.z += emitLength*spread*(random(uv + vec2(127.3, 31.21))-0.5);","}","gl_FragColor = vec4( position, 1.0 );","}"].join("\n")},a.ShaderChunk.fishAnimation=["#define twoPI 6.28318530718","vec3 fishAnimation( vec3 position )","{","float wave_factor = 0.0001;","float twist_factor = 0.0001;","float bend_factor = 0.1;","float speed_factor = 1.0 + 3.0 * smoothstep( 20.0, 0.1, fishLength );","float curTime = time * speed_factor + fishSpeed;","vec3 new_pos = position;","vec3 tmp_pos = position;","float head_z = fishLength/2.0;","float tail_z = -fishLength/2.0;","float z = position.z;","z = (z - head_z) / (tail_z - head_z);","z = smoothstep( 0.0, 1.0, z );","float wave_ang = cos( (curTime - z) * twoPI ) * wave_factor * z;","new_pos.x += wave_ang;","float twist_ang = cos( (curTime - z) * twoPI ) * twist_factor;","float twist_cos = cos( twist_ang );","float twist_sin = sin( twist_ang );","tmp_pos.x = new_pos.x * twist_cos - new_pos.y * twist_sin;","tmp_pos.y = new_pos.x * twist_sin + new_pos.y * twist_cos;","new_pos = tmp_pos;","float bend_ang = cos( (curTime - z) * twoPI ) * bend_factor * z;","float bend_cos = cos( bend_ang );","float bend_sin = sin( bend_ang );","tmp_pos.x = new_pos.x * bend_cos - new_pos.z * bend_sin;","tmp_pos.z = new_pos.x * bend_sin + new_pos.z * bend_cos;","new_pos = tmp_pos;","return new_pos;","}"].join("\n"),a.BoidsPositionShader={uniforms:{time:{value:0},delta:{value:0},bounds:{value:new THREE.Vector3(1e3,1e3,1e3)},central:{value:new THREE.Vector3(0,0,0)}},fragmentShader:["uniform float time;","uniform float delta;","uniform vec3 bounds;","uniform vec3 central;","void main() {","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec4 tmpPos = texture2D( tPosition, uv );","vec3 position = tmpPos.xyz;","vec3 velocity = texture2D( tVelocity, uv ).xyz;","float phase = tmpPos.w;","phase = mod( ( phase + delta +","length( velocity ) * delta * 6.0 ), 62.83 );","vec3 fragPos = position + velocity * delta * 15.0;","vec3 minBound = central - bounds * 0.5;","vec3 maxBound = central + bounds * 0.5;","fragPos = clamp( fragPos, minBound, maxBound );","gl_FragColor = vec4( fragPos, phase );","}"].join("\n")},a.BoidsVelocityShader={uniforms:{time:{value:0},delta:{value:0},seperationDistance:{value:20},alignmentDistance:{value:20},cohesionDistance:{value:20},bounds:{value:new THREE.Vector3(1e3,1e3,1e3)},central:{value:new THREE.Vector3(0,0,0)},speedLimit:{value:9},predator:{value:new THREE.Vector3}},fragmentShader:["uniform float time;","uniform float delta;","uniform float seperationDistance;","uniform float alignmentDistance;","uniform float cohesionDistance;","uniform vec3 bounds;","uniform vec3 central;","uniform float speedLimit;","uniform vec3 predator;","const float width = resolution.x;","const float height = resolution.y;","const float PI = 3.141592653589793;","const float PI_2 = PI * 2.0;","float zoneRadius = 40.0;","float zoneRadiusSquared = 1600.0;","float separationThresh = 0.45;","float alignmentThresh = 0.65;","float rand(vec2 co){","return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);","}","void main() {","zoneRadius = seperationDistance + alignmentDistance + cohesionDistance;","separationThresh = seperationDistance / zoneRadius;","alignmentThresh = ( seperationDistance + alignmentDistance ) / zoneRadius;","zoneRadiusSquared = zoneRadius * zoneRadius;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 birdPosition, birdVelocity;","vec3 selfPosition = texture2D( tPosition, uv ).xyz;","vec3 selfVelocity = texture2D( tVelocity, uv ).xyz;","float dist;","vec3 dir;","float distSquared;","float seperationSquared = seperationDistance * seperationDistance;","float cohesionSquared = cohesionDistance * cohesionDistance;","float f;","float percent;","vec3 velocity = selfVelocity;","float limit = speedLimit;","dir = predator * bounds - selfPosition;","dist = length( dir );","distSquared = dist * dist;","float preyRadius = 50.0;","float preyRadiusSq = preyRadius * preyRadius;","if (dist < preyRadius) {","f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 10.0;","velocity += normalize( dir ) * f;","limit = min( limit*3.0, limit+5.0 );","}","dir = selfPosition - central;","dist = length( dir );","velocity -= normalize( dir ) * delta * 5.0;","for( float y = 0.0; y < height; y++ )","{","for( float x = 0.0; x < width; x++)","{","vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;","birdPosition = texture2D( tPosition, ref ).xyz;","dir = birdPosition - selfPosition;","dist = length(dir);","if (dist < 0.0001) continue;","distSquared = dist * dist;","if (distSquared > zoneRadiusSquared ) continue;","percent = distSquared / zoneRadiusSquared;","if ( percent < separationThresh ) { // low","f = (separationThresh / percent - 1.0) * delta;","velocity -= normalize(dir) * f;","} else if ( percent < alignmentThresh ) { // high","float threshDelta = alignmentThresh - separationThresh;","float adjustedPercent = ( percent - separationThresh ) / threshDelta;","birdVelocity = texture2D( tVelocity, ref ).xyz;","f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;","velocity += normalize(birdVelocity) * f;","} else {","float threshDelta = 1.0 - alignmentThresh;","float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;","f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;","velocity += normalize(dir) * f;","}","}","}","if ( length( velocity ) > limit ) {","velocity = normalize( velocity ) * limit;","}","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},a.BoidsDrawShader={uniforms:{time:{value:0},boidType:{value:0},boidLength:{value:0},color:{value:new THREE.Color(16777215)},tDiffuse:{value:new THREE.Texture},tSpecular:{value:new THREE.Texture},tPosition:{value:new THREE.Texture},tVelocity:{value:new THREE.Texture}},vertexShader:["#define twoPI 6.28318530718","attribute vec2 boidSite;","attribute vec3 boidColor;","attribute float boidVertex;","uniform int boidType;","uniform float boidLength;","uniform sampler2D tPosition;","uniform sampler2D tVelocity;","uniform float time;","varying vec3 vNormal;","varying vec2 vUv;","varying vec4 vColor;","varying vec3 vViewPosition;","vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {","    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );","}",THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.fog_pars_vertex,a.ShaderChunk.random,"vec3 fishAnimation( vec3 pos )","{","float r = random( boidSite );","float h = r - 0.5;","float wave_factor = 0.4;","float twist_factor = 0.3 * h;","float bend_factor = 0.2 * h;","float speed_factor = length( texture2D( tVelocity, boidSite ).xyz );","speed_factor = log(speed_factor + 1.0) * 3.0;","speed_factor = clamp( speed_factor, 1.0, 3.0 );","float curTime = time * speed_factor;","vec3 new_pos = pos;","vec3 tmp_pos = pos;","float head_z = boidLength/2.0;","float tail_z = -boidLength/2.0;","float z = pos.z;","z = (z - head_z) / (tail_z - head_z);","z = smoothstep( 0.0, 1.0, z );","float wave_ang = sin( (curTime - z) * twoPI ) * wave_factor * z;","new_pos.x += wave_ang;","float twist_ang = sin( (curTime - z) * twoPI ) * twist_factor;","float twist_cos = cos( twist_ang );","float twist_sin = sin( twist_ang );","tmp_pos.x = new_pos.x * twist_cos - new_pos.y * twist_sin;","tmp_pos.y = new_pos.x * twist_sin + new_pos.y * twist_cos;","new_pos = tmp_pos;","float bend_ang = sin( (curTime) * twoPI ) * bend_factor * z;","float bend_cos = cos( bend_ang );","float bend_sin = sin( bend_ang );","tmp_pos.x = new_pos.x * bend_cos - new_pos.z * bend_sin;","tmp_pos.z = new_pos.x * bend_sin + new_pos.z * bend_cos;","new_pos = tmp_pos;","return new_pos;","}","void main() {","vec4 tmpPos = texture2D( tPosition, boidSite );","vec3 pos = tmpPos.xyz;","vec3 velocity = normalize(texture2D( tVelocity, boidSite ).xyz);","vec3 newPosition = position;","if( boidType == 0 ) {","if ( boidVertex == 4.0 || boidVertex == 7.0 ) {","newPosition.y = sin( tmpPos.w ) * 5.0;","}","}","else {","newPosition = fishAnimation( position );","}","newPosition = mat3( modelMatrix ) * newPosition;","velocity.z *= -1.0;","float xz = length( velocity.xz );","float xyz = 1.0;","float x = sqrt( 1.0 - velocity.y * velocity.y );","float cosry = velocity.x / xz;","float sinry = velocity.z / xz;","float cosrz = x / xyz;","float sinrz = velocity.y / xyz;","mat3 maty =  mat3(","cosry, 0.0, -sinry,","0.0  , 1.0, 0.0   ,","sinry, 0.0, cosry ",");","mat3 matz =  mat3(","cosrz , sinrz, 0.0,","-sinrz, cosrz, 0.0,","0.0   , 0.0  , 1.0 ",");","newPosition = maty * matz * newPosition;","newPosition += pos;","vec4 worldPosition = vec4( newPosition, 1.0 );","vec4 mvPosition = viewMatrix  * worldPosition;","gl_Position = projectionMatrix * mvPosition;","vViewPosition = -mvPosition.xyz;","vUv = uv;","vNormal = normalize( normalMatrix * normal );","vColor = vec4( boidColor, 1.0 );",THREE.ShaderChunk.beginnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.shadowmap_vertex,THREE.ShaderChunk.fog_vertex,"}"].join("\n"),fragmentShader:["uniform int boidType;","uniform vec3 color;","uniform sampler2D tDiffuse;","uniform sampler2D tSpecular;","varying vec3 vNormal;","varying vec2 vUv;","varying vec4 vColor;","varying vec3 vViewPosition;",THREE.ShaderChunk.common,THREE.ShaderChunk.packing,THREE.ShaderChunk.bsdfs,THREE.ShaderChunk.lights_pars_begin,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {","if ( decayExponent > 0.0 ) {","return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );","}","return 1.0;","}","void main() {","vec3 fragColor = vec3( 0.0 );","vec3 totalLd = vec3( 0.0 );","vec3 totalLs = vec3( 0.0 );","vec3 N = normalize( vNormal );","vec3 V = normalize( vViewPosition );","float shininess = 32.0;","vec3 specularTex = texture2D( tSpecular, vUv ).rgb;","#if NUM_POINT_LIGHTS > 0","for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {","vec3 L = pointLights[ i ].position + vViewPosition.xyz;","float atten = calcLightAttenuation( length( L ), pointLights[ i ].distance, pointLights[ i ].decay );","L = normalize( L );","vec3 H = normalize( L + V );","float NoH = max( dot( N, H ), 0.0 );","float diffWt = max( dot( N, L ), 0.0 );","float specWt = specularTex.r * max( pow( NoH, shininess ), 0.0 );","totalLd += atten * pointLights[ i ].color * diffWt;","totalLs += atten * pointLights[ i ].color * specWt * diffWt;","}","#endif","#if NUM_DIR_LIGHTS > 0","for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {","vec3 Lc = directionalLights[ i ].color;","vec3 L = directionalLights[ i ].direction;","vec3 H = normalize( L + V );","float NoH = max( dot( N, H ), 0.0 );","float NoL = max( dot( N, L ), 0.0 );","totalLd += Lc * NoL;","totalLs += Lc * NoL * specularTex * max( pow( NoH, shininess ), 0.0 );","}","#endif","#if NUM_HEMI_LIGHTS > 0","for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {","vec3 L = hemisphereLights[ i ].direction;","vec3 gndLc = hemisphereLights[ i ].groundColor;","vec3 skyLc = hemisphereLights[ i ].skyColor;","float NoL = dot( N, L );","float diffWt = 0.5 * NoL + 0.5;","totalLd += mix( gndLc, skyLc, diffWt );","float specWt = 0.0;","vec3 skyH = normalize( L + V );","float skyNoH = 0.5 * dot( N, skyH ) + 0.5;","specWt += specularTex.r * max( pow( skyNoH, shininess ), 0.0 );","vec3 gndH = normalize( -L + V );","float gndNoH = 0.5 * dot( N, gndH ) + 0.5;","specWt += specularTex.r * max( pow( gndNoH, shininess ), 0.0 );","totalLs += mix( gndLc, skyLc, diffWt ) * specWt * diffWt;","}","#endif","vec4 albedo = vec4( 1.0 );","if( boidType == 0 ) {","albedo = vec4( mix( color, vColor.rgb, 0.8 ), 1.0 );","fragColor = albedo.rgb;","}","if( boidType == 1 ) {","albedo.rgb = color * texture2D( tDiffuse, vUv ).rgb;","fragColor = albedo.rgb * ( totalLd + ambientLightColor + totalLs );","}","gl_FragColor = vec4( fragColor, albedo.a );",THREE.ShaderChunk.fog_fragment,"}"].join("\n")},a.UnderWaterShader={uniforms:{tDiffuse:{value:null},time:{value:0},distort_speed:{value:5e-4},distortion:{value:.04},centerX:{value:.5},centerY:{value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float time;","uniform float distort_speed;","uniform float distortion;","uniform float centerX;","uniform float centerY;","varying vec2 vUv;","void main() {","vec2 p = vUv;","vec2 center_coord;","float distance_to_center;","float projected_distance_to_center;","float distort_degree;","center_coord.x = p.x - centerX;","center_coord.y = p.y - centerY;","distance_to_center = sqrt(center_coord.x * center_coord.x + center_coord.y * center_coord.y);","distort_degree = abs( mod(distort_speed* time, distortion) - (distortion / 2.0)) + 1.0;","projected_distance_to_center = pow(1.0, distort_degree - 1.0) * pow(distance_to_center/1.0, distort_degree);","p.x = projected_distance_to_center * center_coord.x/ distance_to_center + centerX;","p.y = projected_distance_to_center * center_coord.y/ distance_to_center + centerY;","vec4 color = texture2D(tDiffuse, p);","gl_FragColor = color;","}"].join("\n")},a.ParticleEngineShader={uniforms:{particleTexture:{value:null}},vertexShader:["attribute vec3  customColor;","attribute float customOpacity;","attribute float customSize;","attribute float customAngle;","attribute float customVisible;","varying vec4  vColor;","varying float vAngle;","void main()","{","if ( customVisible > 0.5 )","vColor = vec4( customColor, customOpacity );","else","vColor = vec4(0.0, 0.0, 0.0, 0.0);","vAngle = customAngle;","vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );","gl_Position = projectionMatrix * mvPosition;","}"].join("\n"),fragmentShader:["uniform sampler2D particleTexture;","varying vec4 vColor;","varying float vAngle;","void main()","{","gl_FragColor = vColor;","float c = cos(vAngle);","float s = sin(vAngle);","vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,","c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);","vec4 rotatedTexture = texture2D( particleTexture, rotatedUV );","gl_FragColor = gl_FragColor * rotatedTexture;","}"].join("\n")},a.TerrainLODShader={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,{diffuse:{value:new THREE.Color(16777215)},specular:{value:new THREE.Color(16777215)},shininess:{value:30},opacity:{value:1},enableDiffuse1:{value:!0},enableDiffuse2:{value:!0},enableSpecular:{value:!1},tDiffuse1:{value:null},tDiffuse2:{value:null},tSpecular:{value:null},uvRepeatOverlay:{value:new THREE.Vector2(1,1)},uvOffset:{value:new THREE.Vector2(0,0)},worldWidth:{value:1024},tileResolution:{value:64},edgeMorph:{value:0},globalOffset:{value:null},tileOffset:{value:null},heightMap:{value:null},tileScale:{value:64},maxHeight:{value:100},winterSnow:{value:!1},summerGreen:{value:!1}}]),vertexShader:["uniform float worldWidth;","uniform float tileResolution;","uniform vec3 globalOffset;","uniform vec2 tileOffset;","uniform sampler2D heightMap;","uniform float tileScale;","uniform float maxHeight;","varying float vMorphFactor;","varying vec3 vPosition;","varying vec2 vUv;","varying vec3 vViewPosition;","vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {","    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );","}",THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.fog_pars_vertex,"float getHeight(vec3 p) {","float lod = 1.0;","vec2 st = p.xy / worldWidth;","float h = 1024.0 * texture2DLodEXT(heightMap, st, lod).r;","h += 64.0 * texture2DLodEXT(heightMap, 16.0 * st, lod).r;","h += 4.0 * texture2DLodEXT(heightMap, 256.0 * st, lod).r;","return h / 1092.0 * maxHeight;","}","#define EGDE_MORPH_TOP    1","#define EGDE_MORPH_LEFT   2","#define EGDE_MORPH_BOTTOM 4","#define EGDE_MORPH_RIGHT  8","#define MORPH_REGION      0.3","uniform int edgeMorph;","bool edgePresent(int edge) {","int e = edgeMorph / edge;","return 2 * ( e / 2 ) != e;","}","float calculateMorph(vec3 p) {","float morphFactor = 0.0;","if( edgePresent(EGDE_MORPH_TOP) && p.y >= 1.0 - MORPH_REGION ) {","float m = 1.0 - clamp((1.0 - p.y) / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_LEFT) && p.x <= MORPH_REGION ) {","float m = 1.0 - clamp(p.x / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_BOTTOM) && p.y <= MORPH_REGION ) {","float m = 1.0 - clamp(p.y / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_RIGHT) && p.x >= 1.0 - MORPH_REGION ) {","float m = 1.0 - clamp((1.0 - p.x) / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","return morphFactor;","}","void main() {","vMorphFactor = calculateMorph(position);","vPosition = tileScale * position + vec3(tileOffset, 0.0) + globalOffset;","float grid = tileScale / tileResolution;","vPosition = floor(vPosition / grid) * grid;","if( vMorphFactor > 0.0 ) {","grid = 2.0 * grid;","vec3 position2 = floor(vPosition / grid) * grid;","vPosition = mix(vPosition, position2, vMorphFactor);","}","vPosition = vPosition + normal * getHeight(vPosition);","vec4 mvPosition =  modelViewMatrix * vec4( vPosition, 1.0 );","gl_Position = projectionMatrix * mvPosition;","vUv = uv;","vPosition.xyz = vPosition.yzx;","vViewPosition.xyz = -mvPosition.yzx;","#if defined (USE_SHADOWMAP)","vec4 worldPosition = modelMatrix * vec4( vPosition, 1.0 );","#endif",THREE.ShaderChunk.beginnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.shadowmap_vertex,THREE.ShaderChunk.fog_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;","uniform vec3 specular;","uniform float shininess;","uniform float opacity;","uniform bool enableDiffuse1;","uniform bool enableDiffuse2;","uniform bool enableSpecular;","uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tSpecular;","uniform vec2 uvRepeatOverlay;","uniform vec2 uvOffset;","uniform float worldWidth;","uniform sampler2D heightMap;","uniform float maxHeight;","uniform bool winterSnow;","uniform bool summerGreen;","varying float vMorphFactor;","varying vec3 vPosition;","varying vec2 vUv;","varying vec3 vViewPosition;",THREE.ShaderChunk.common,THREE.ShaderChunk.packing,THREE.ShaderChunk.bsdfs,THREE.ShaderChunk.lights_pars_begin,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"float getHeight(vec3 p) {","vec2 st = p.zx / worldWidth;","float h = 1024.0 * texture2D(heightMap, st).r;","h += 64.0 * texture2D(heightMap, 16.0 * st).r;","h += 4.0 * texture2D(heightMap, 256.0 * st).r;","return h / 1092.0 * maxHeight;","}","vec3 getNormal() {","float height = getHeight( vPosition );","vec3 p = vec3( vPosition.x, height, vPosition.z );","vec3 dPositiondx = dFdx(p);","vec3 dPositiondy = dFdy(p);","return normalize(cross(dPositiondx, dPositiondy));","}","float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {","if ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {","return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), 2.0 );","}","return 1.0;","}","void main() {","vec4 diffuseColor = vec4( diffuse, opacity );","vec3 specularTex = vec3( 1.0 );","vec2 uvOverlay = uvRepeatOverlay * vUv + uvOffset;","vec3 viewPosition = normalize( vViewPosition );","vec3 normal = getNormal();","vec3 outgoingLight = vec3( 0.0 );","vec3 totalDiffuseLight = vec3( 0.0 );","vec3 totalSpecularLight = vec3( 0.0 );","if( enableDiffuse1 && enableDiffuse2 ) {","vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );","vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );","colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );","colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );","diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - getHeight( vPosition ) / worldWidth );","} else if( enableDiffuse1 ) {","diffuseColor *= texture2D( tDiffuse1, uvOverlay );","} else if( enableDiffuse2 ) {","diffuseColor *= texture2D( tDiffuse2, uvOverlay );","}","if( enableSpecular )","specularTex = texture2D( tSpecular, uvOverlay ).xyz;","if( winterSnow )","{","vec3 snowColor = vec3( 0.93, 0.97, 1.0 );","float snowStick = dot( vec3( 0.0, 1.0, 0.0 ), normal );","snowStick = pow( snowStick, 3.0 );","snowStick = step( 0.2, snowStick );","diffuseColor.xyz = mix( diffuseColor.xyz, snowColor, snowStick );","}","if( summerGreen )","{","vec3 water = vec3( 0.0, 0.12, 0.06 );","vec3 grass = vec3( 0.07, 0.43, 0.08 );","vec3 rock = vec3( 0.31, 0.11, 0.09 );","float grassStick = dot( vec3( 0.0, 1.0, 0.0 ), normal );","float stickExponent = 1.2 + 1.8 * float( winterSnow );","grassStick = pow( grassStick, stickExponent );","float minVal = 0.2 + 0.1 * float( winterSnow );","grassStick = step( minVal, grassStick );","vec3 waterGrass = mix( water, grass, smoothstep( 7.0, 14.0, vPosition.y ) );","vec3 rockWaterGrass = mix( rock, waterGrass, 0.5 );","diffuseColor.xyz = mix( diffuseColor.xyz, rockWaterGrass, grassStick );","}","#if NUM_POINT_LIGHTS > 0","for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {","vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;","float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );","lVector = normalize( lVector );","vec3 pointHalfVector = normalize( lVector + viewPosition );","float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );","float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );","float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );","totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;","totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;","}","#endif","#if NUM_DIR_LIGHTS > 0","vec3 dirDiffuse = vec3( 0.0 );","vec3 dirSpecular = vec3( 0.0 );","for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {","vec3 dirVector = directionalLights[ i ].direction;","vec3 dirHalfVector = normalize( dirVector + viewPosition );","float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );","float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );","totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;","totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;","}","#endif","#if NUM_HEMI_LIGHTS > 0","vec3 hemiDiffuse  = vec3( 0.0 );","vec3 hemiSpecular = vec3( 0.0 );","for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {","vec3 lVector = hemisphereLights[ i ].direction;","float dotProduct = dot( normal, lVector );","float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;","totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );","float hemiSpecularWeight = 0.0;","vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );","float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;","hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );","vec3 lVectorGround = -lVector;","vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );","float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;","hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );","totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;","}","#endif","outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );","float mistAmount = clamp( 1.0 - vPosition.y / 15.0, 0.0, 1.0 );","mistAmount = pow( mistAmount, 5.4 );","vec3 mistColor = vec3( 0.835, 0.843, 0.850 );","outgoingLight = mix( outgoingLight, mistColor, mistAmount );","gl_FragColor = vec4( outgoingLight, diffuseColor.a );",THREE.ShaderChunk.tonemapping_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},a.GrayScaleShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float gray = dot( texel.rgb, vec3(0.299, 0.587, 0.114) );","gl_FragColor = vec4( gray, gray, gray, texel.a );","}"].join("\n")},a.LuminanceShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float luma = dot( texel.rgb, vec3(0.2125, 0.7154, 0.0721) );","gl_FragColor = vec4( luma, luma, luma, texel.a );","}"].join("\n")},a.InvertImageShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor.rgb = vec3(1.0) - texel.rgb;","gl_FragColor.a = texel.a;","}"].join("\n")},a.BrightnessShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec3 black = vec3(0.0);","gl_FragColor.rgb = mix( black, texel.rgb, 2.0 );","gl_FragColor.a = texel.a;","}"].join("\n")},a.SaturationShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float luma = dot( texel.rgb, vec3(0.2125, 0.7154, 0.0721) );","gl_FragColor.rgb = mix( vec3(luma), texel.rgb, 0.5 );","gl_FragColor.a = texel.a;","}"].join("\n")},a.ContrastShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor.rgb = mix( vec3(0.5), texel.rgb, 2.0 );","gl_FragColor.a = texel.a;","}"].join("\n")},a.DitheringShader={uniforms:{tDiffuse:{value:null},tNoise:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tNoise;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float grayscale = length( texel.rgb * vec3(0.2126, 0.7152, 0.0722) );","vec3 ditherPixel = texture2D( tNoise, vec2( mod( gl_FragCoord.xy / vec2(8.0), 1.0) ) ).xyz;","float ditherGrayscale = ( ditherPixel.x + ditherPixel.y + ditherPixel.z ) / 3.0;","ditherGrayscale -= 0.5;","float ditheredResult = grayscale + ditherGrayscale;","float bit = (ditheredResult >= 0.5) ? 1.0 : 0.0;","gl_FragColor.rgb = vec3( bit );","gl_FragColor.a = texel.a;","}"].join("\n")},a.GaussianBlurShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)},strength:{value:3.5},horizontalPass:{value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","uniform float strength;","uniform int horizontalPass;","varying vec2 vUv;","void main() {","const float pi = 3.14159265;","const float numBlurPixelsPerSide = 16.0;","vec2 texOffset = resolution;","vec2 blurMultiplyVec = 0 < horizontalPass ? vec2(1.0, 0.0) : vec2(0.0, 1.0);","vec3 incrementalGaussian;","incrementalGaussian.x = 1.0 / (sqrt(2.0 * pi) * strength);","incrementalGaussian.y = exp(-0.5 / (strength * strength));","incrementalGaussian.z = incrementalGaussian.y * incrementalGaussian.y;","vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);","float coefficientSum = 0.0;","avgValue += texture2D( tDiffuse, vUv ) * incrementalGaussian.x;","coefficientSum += incrementalGaussian.x;","incrementalGaussian.xy *= incrementalGaussian.yz;","for (float i = 1.0; i <= numBlurPixelsPerSide; i++) {","avgValue += texture2D( tDiffuse, vUv - i * texOffset * blurMultiplyVec ) * incrementalGaussian.x;","avgValue += texture2D( tDiffuse, vUv + i * texOffset * blurMultiplyVec ) * incrementalGaussian.x;","coefficientSum += 2.0 * incrementalGaussian.x;","incrementalGaussian.xy *= incrementalGaussian.yz;","}","gl_FragColor = avgValue / coefficientSum;","}"].join("\n")},a.EdgeDetectionShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","mat3 G[9];","const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );","const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );","const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );","const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );","const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );","const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );","const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );","const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );","const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );","void main(void)","{","G[0] = g0,","G[1] = g1,","G[2] = g2,","G[3] = g3,","G[4] = g4,","G[5] = g5,","G[6] = g6,","G[7] = g7,","G[8] = g8;","mat3 I;","float cnv[9];","vec3 sample;","for (float i=0.0; i<3.0; i++) {","for (float j=0.0; j<3.0; j++) {","sample = texture2D(tDiffuse, vUv + resolution * vec2(i-1.0,j-1.0) ).rgb;","I[int(i)][int(j)] = length(sample);","}","}","for (int i=0; i<9; i++) {","float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);","cnv[i] = dp3 * dp3;","}","float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);","float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);","gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);","}"].join("\n")},a.EdgeDetection2Shader={defines:{EDGE_FUNC:"edge"},uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","const mat3 sobelKernelX = mat3(1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0);","const mat3 sobelKernelY = mat3(-1.0, -2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 2.0, 1.0);","float convolve(mat3 kernel, mat3 image) {","float result = 0.0;","for (int i = 0; i < 3; i++) {","for (int j = 0; j < 3; j++) {","result += kernel[i][j]*image[i][j];","}","}","return result;","}","float convolveComponent(mat3 kernelX, mat3 kernelY, mat3 image) {","vec2 result;","result.x = convolve(kernelX, image);","result.y = convolve(kernelY, image);","return clamp(length(result), 0.0, 255.0);","}","vec4 colorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {","vec4 colors[9];","colors[0] = texture2D(tDiffuse,center + vec2(-stepx,stepy));","colors[1] = texture2D(tDiffuse,center + vec2(0,stepy));","colors[2] = texture2D(tDiffuse,center + vec2(stepx,stepy));","colors[3] = texture2D(tDiffuse,center + vec2(-stepx,0));","colors[4] = texture2D(tDiffuse,center);","colors[5] = texture2D(tDiffuse,center + vec2(stepx,0));","colors[6] = texture2D(tDiffuse,center + vec2(-stepx,-stepy));","colors[7] = texture2D(tDiffuse,center + vec2(0,-stepy));","colors[8] = texture2D(tDiffuse,center + vec2(stepx,-stepy));","mat3 imageR, imageG, imageB, imageA;","for (int i = 0; i < 3; i++) {","for (int j = 0; j < 3; j++) {","imageR[i][j] = colors[i*3+j].r;","imageG[i][j] = colors[i*3+j].g;","imageB[i][j] = colors[i*3+j].b;","imageA[i][j] = colors[i*3+j].a;","}","}","vec4 color;","color.r = convolveComponent(kernelX, kernelY, imageR);","color.g = convolveComponent(kernelX, kernelY, imageG);","color.b = convolveComponent(kernelX, kernelY, imageB);","color.a = convolveComponent(kernelX, kernelY, imageA);","return color;","}","vec4 edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){","mat3 image = mat3(length(texture2D(tDiffuse,center + vec2(-stepx,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(0,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(-stepx,0)).rgb),","length(texture2D(tDiffuse,center).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,0)).rgb),","length(texture2D(tDiffuse,center + vec2(-stepx,-stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(0,-stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,-stepy)).rgb));","vec2 result;","result.x = convolve(kernelX, image);","result.y = convolve(kernelY, image);","float color = clamp(length(result), 0.0, 255.0);","return vec4(color);","}","vec4 trueColorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {","vec4 edgeVal = edge(stepx, stepy, center, kernelX, kernelY);","return edgeVal * texture2D(tDiffuse,center);","}","void main(void)","{","vec4 texel = texture2D( tDiffuse, vUv );","vec4 result = EDGE_FUNC( resolution.x, resolution.y, vUv, sobelKernelX, sobelKernelY );","gl_FragColor = vec4( result.rgb, texel.a );","}"].join("\n")},a.VignetteShader={uniforms:{tDiffuse:{value:null},offset:{value:1},darkness:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float offset;","uniform float darkness;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );","gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );","}"].join("\n")},a.FilmGrainShader={uniforms:{tDiffuse:{value:null},aspectCorrection:{value:!1},aspect:{value:1},grainScale:{value:.005},grainTime:{value:0},noiseAlpha:{value:.25},offset:{value:new THREE.Vector2(0,0)},scale:{value:new THREE.Vector2(1,1)},smoothEdge:{value:new THREE.Vector2(0,1)},color1:{value:new THREE.Color(16777215)},color2:{value:new THREE.Color(2635844)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:[a.ShaderChunk.mod289,a.ShaderChunk.permute,a.ShaderChunk.taylorInvSqrt,a.ShaderChunk.snoise3,a.ShaderChunk.fade3,a.ShaderChunk.pnoise3,"float grain(vec2 texCoord, vec2 resolution, float frame, float multiplier) {","vec2 mult = texCoord * resolution;","float offset = snoise(vec3(mult / multiplier, frame));","float n1 = pnoise(vec3(mult, offset), vec3(1.0/texCoord * resolution, 1.0));","return n1 / 2.0 + 0.5;","}","float grain(vec2 texCoord, vec2 resolution, float frame) {","return grain(texCoord, resolution, frame, 2.5);","}","float grain(vec2 texCoord, vec2 resolution) {","return grain(texCoord, resolution, 0.0);","}","vec3 blendSoftLight(vec3 base, vec3 blend) {","return mix(","sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),","2.0 * base * blend + base * base * (1.0 - 2.0 * blend),","step(base, vec3(0.5))",");","}","uniform sampler2D tDiffuse;","uniform vec3 color1;","uniform vec3 color2;","uniform float aspect;","uniform vec2 offset;","uniform vec2 scale;","uniform float noiseAlpha;","uniform bool aspectCorrection;","uniform float grainScale;","uniform float grainTime;","uniform vec2 smoothEdge;","varying vec2 vUv;","void main() {","vec2 q = vec2(vUv - 0.5);","if( aspectCorrection ) {","q.x *= aspect;","}","q /= scale;","q -= offset;","float dst = length(q);","dst = smoothstep(smoothEdge.x, smoothEdge.y, dst);","vec3 color12 = mix(color1, color2, dst);","vec3 color3 = texture2D(tDiffuse, vUv).rgb;","vec3 color = mix(color12, color3, 0.75);","if( noiseAlpha > 0.0 && grainScale > 0.0 ) {","float gSize = 1.0 / grainScale;","float g = grain(vUv, vec2(gSize * aspect, gSize), grainTime);","vec3 noiseColor = blendSoftLight(color, vec3(g));","gl_FragColor.rgb = mix(color, noiseColor, noiseAlpha);","} else {","gl_FragColor.rgb = color;","}","gl_FragColor.a = 1.0;","}"].join("\n")},a.BackgroundShader={uniforms:{devicePixelRatio:{value:window.devicePixelRatio},time:{value:0},resolution:{value:null},textureMaps:{value:[]}},vertexShader:"void main(){ gl_Position = vec4(position, 1.0); }",cloudsFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        #define iChannel0 textureMaps[0]\n        # define T texture2D(iChannel0, fract((s*p.zw + ceil(s*p.x)) / 200.0)).y / (s += s) * 4.0\n        const vec3 skyColor = vec3(0.360, 0.650, 0.792); // 0x5ca6ca\n        const vec3 cloudColor = vec3(0.2, 0.301, 0.501); // 0x334d80\n        const vec3 lightColor = vec3(1.0); // 0xffffff\n        const float speed = 1.0;\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n            vec4 p, d = vec4(0.8, 0, fragCoord / resolution.y - 0.65);\n            vec3 out1 = skyColor - d.w; // sky gradient\n            float s, f, t = 200.0 + sin(dot(fragCoord, fragCoord));\n            const float MAX_ITER = 100.0;\n            for (float i = 1.0; i <= MAX_ITER; i += 1.0) {\n            t -= 2.0; if (t < 0.0) { break; } // march step\n            p = 0.05 * t * d;\n            p.xz += time * 0.50000 * speed; // movement through space\n            p.x += sin(time * 0.25 * speed) * 0.25;\n            s = 2.0;\n            f = p.w + 1.0-T-T-T-T;\n            if (f < 0.0) {\n                vec3 cloudShading = mix(lightColor, cloudColor, -f);\n                out1 = mix(out1, cloudShading, -f * 0.4);\n            }\n            }\n            fragColor = vec4(out1, 1.0);\n        }\n        void main() {\n            gl_FragDepth = 1.0;\n            mainImage( gl_FragColor, gl_FragCoord.xy );\n        }\n    ",cellsFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        const vec3 color1 = vec3(0, 0.549, 0.549);\n        const vec3 color2 = vec3(0.949, 0.905, 0.207);\n        const float size = 1.5;\n        float length2(vec2 p) { return dot(p, p); }\n        float noise(vec2 p){\n            return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n        }\n        float worley(vec2 p) {\n            float d = 1e30;\n            for (int xo = -1; xo <= 1; ++xo) {\n                for (int yo = -1; yo <= 1; ++yo) {\n                    vec2 tp = floor(p) + vec2(xo, yo);\n                    d = min(d, length2(p - tp - vec2(noise(tp))));\n                }\n            }\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            float timeOffset =  0.15 * sin(time * 2.0 + 10.0*(uv.x - uv.y));\n            return 3.0*exp(-4.0*abs(2.0*d - 1.0 + timeOffset));\n        }\n        float fworley(vec2 p) {\n            return sqrt(sqrt(sqrt(\n            1.1 * // light\n            worley(p*5. + .3 + time*.0525) *\n            sqrt(worley(p * 50. / size + 0.3 + time * -0.15)) *\n            sqrt(sqrt(worley(p * -10. + 9.3))))));\n        }\n        void main() {\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            float t = fworley(uv * resolution.xy / 1500.0);\n            t *= exp(-length2(abs(0.7*uv - 1.0)));\n            float tExp = pow(t, 0.5 - t);\n            vec3 c1 = color1 * (1.0 - t);\n            vec3 c2 = color2 * tExp;\n            gl_FragColor = vec4(pow(t, 1.0 - t) * (c1 + c2), 1.0);\n            gl_FragDepth = 1.0;\n        }\n    ",fogFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        const vec3 baseColor = vec3(1.0, 0.921, 0.921);\n        const vec3 lowlightColor = vec3(0.176, 0.0, 1.0);\n        const vec3 midtoneColor = vec3(1.0, 0.121, 0.0);\n        const vec3 highlightColor = vec3(1.0, 0.764, 0.0);\n        const float blurFactor = 0.21;//0.6;\n        const float zoom = 1.0;\n        float random (in vec2 uv) {\n            return fract(sin(dot(uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n        }\n        float noise (in vec2 uv) {\n            vec2 i = floor(uv);\n            vec2 f = fract(uv);\n            // Four corners in 2D of a tile\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n            vec2 u = f * f * (3.0 - 2.0 * f);\n            return mix(a, b, u.x) +\n                    (c - a)* u.y * (1.0 - u.x) +\n                    (d - b) * u.x * u.y;\n        }\n        #define NUM_OCTAVES 6\n        float fbm( in vec2 uv ) {\n            float v = 0.0;\n            float a = blurFactor;\n            vec2 shift = vec2(100.0);\n            // Rotate to reduce axial bias\n            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n            for (int i = 0; i < NUM_OCTAVES; ++i) {\n                v += a * noise(uv);\n                uv = rot * uv * 2.0 + shift;\n                a *= (1. - blurFactor);\n            }\n            return v;\n        }\n        void main() {\n            vec2 st = gl_FragCoord.xy / resolution.xy*3.;\n            st.x *= 0.7 * resolution.x / resolution.y ; // Still keep it more landscape than square\n            st *= zoom;\n            // st += st * abs(sin(time*0.1)*3.0);\n            vec3 color = vec3(0.0);\n            vec2 q = vec2(0.);\n            q.x = fbm( st + 0.00*time);\n            q.y = fbm( st + vec2(1.0));\n            vec2 dir = vec2(0.15,0.126);\n            vec2 r = vec2(0.);\n            r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ dir.x*time );\n            r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ dir.y*time);\n            float f = fbm(st+r);\n            color = mix(baseColor, lowlightColor, clamp((f*f)*4.0,0.0,1.0));\n            color = mix(color, midtoneColor, clamp(length(q),0.0,1.0));\n            color = mix(color, highlightColor, clamp(length(r.x),0.0,1.0));\n            vec3 finalColor = mix(baseColor, color, f*f*f+.6*f*f+.5*f);\n            gl_FragColor = vec4(finalColor,1.0);\n            gl_FragDepth = 1.0;\n        }\n    ",sunsetFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        float rand(float x) { return fract(sin(x) * 71523.5413291); }\n        float rand(vec2 x) { return rand(dot(x, vec2(13.4251, 15.5128))); }\n        float noise(vec2 x)\n        {\n            vec2 i = floor(x);\n            vec2 f = x - i;\n            f *= f*(3.-2.*f);\n            return mix(mix(rand(i), rand(i+vec2(1,0)), f.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n        }\n        float fbm(vec2 x)\n        {\n            float r = 0.0, s = 1.0, w = 1.0;\n            for (int i=0; i<5; i++) {\n                s *= 2.0;\n                w *= 0.5;\n                r += w * noise(s * x);\n            }\n            return r;\n        }\n        float cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n        {\n            return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*time))-(1.0-density)), 1.0-sharpness);\n        }\n        vec3 render(vec2 uv)\n        {\n            // sky\n            vec3 color = mix(vec3(1.0,0.831,0.650), vec3(0.8,0.921,1.0), uv.y);\n            // sun\n            vec2 spos = uv - vec2(0.1, 0.4);\n            float sun = exp(-20.*dot(spos,spos));\n            vec3 scol = vec3(1.0,0.607,0.4) * sun * 0.7;\n            color += scol;\n            // clouds\n            vec3 cl1 = mix(vec3(0.592,0.541,0.6), vec3(0.650,0.749,0.878),uv.y);\n            float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n            color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n            color = mix(color, vec3(0.9), 8.*cloud(uv,14.,18.,0.9,0.75,0.02) * cloud(uv,2.,5.,0.6,0.15,0.01)*uv.y);\n            color = mix(color, vec3(0.8), 5.*cloud(uv,12.,15.,0.9,0.75,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n            // post\n            color *= vec3(1.0,0.93,0.81)*1.04;\n            color = mix(0.75*vec3(1.0,0.803,0.631), color, smoothstep(-0.1,0.3,uv.y));\n            color = pow(color,vec3(1.3));\n            return color;\n        }\n        void main() {\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            uv.x -= 0.5;\n            uv.x *= resolution.x / resolution.y;\n            gl_FragColor = vec4(render(uv), 1.0);\n            gl_FragDepth = 1.0;\n        }\n    "};var p=r(7),h=r(8),v=r(9);a.GraphicWorks=function(e){var t=this;e=e||{};this.appName=e.appName||"GraphicWorks",this.customer=e.customer||"NovaGraphix";var r,[n,o]=S();if(this.width=e.width||n,this.height=e.height||o,this.widthRatio=this.width/n,this.heightRatio=this.height/o,this.dom=document.createElement("div"),this.dom.id=this.appName,this.dom.className="GraphicWorks",this.dom.style.width=this.width+"px",this.dom.style.height=this.height+"px",this.signals=null,!0===e.signals){var i=p.Signal;this.signals={startPlayer:new i,stopPlayer:new i,appWorksCleared:new i,autoSaveStarted:new i,autoSaveFinished:new i,themeChanged:new i,transformModeChanged:new i,snapChanged:new i,spaceChanged:new i,sceneBackgroundChanged:new i,sceneFogChanged:new i,sceneGraphChanged:new i,cameraChanged:new i,geometryChanged:new i,objectSelected:new i,objectFocused:new i,objectsSelected:new i,objectAdded:new i,objectChanged:new i,objectRemoved:new i,helperAdded:new i,helperChanged:new i,helperRemoved:new i,materialChanged:new i,windowResize:new i,axesHelperChanged:new i,gridHelperChanged:new i,initSidebar:new i,historyChanged:new i},(r=t.signals).startPlayer.add((function(){t.history.historyDisabled=!0})),r.stopPlayer.add((function(){t.history.historyDisabled=!1})),r.themeChanged.add((function(){})),r.sceneBackgroundChanged.add((function(e){t.config.setSettings("background",e)})),r.sceneFogChanged.add((function(e){t.createSceneFog(e),_()})),r.gridHelperChanged.add((function(e,r,n){a.dispose(t.gridHelper),t.gridHelper=b(e,r,n),t.sceneHelpers.add(t.gridHelper),_()})),r.geometryChanged.add((function(e){})),r.materialChanged.add((function(e){})),r.objectAdded.add((function(e){var r=t.selectables;e.traverse((function(e){r.push(e)}))})),r.objectRemoved.add((function(e){t.transformControls&&t.transformControls.object===e&&t.transformControls.detach();var r=t.selectables;e.traverse((function(e){r.splice(r.indexOf(e),1)}))})),r.objectChanged.add((function(e){e instanceof THREE.PerspectiveCamera&&e.updateProjectionMatrix(),!e.helper||e.helper instanceof THREE.SkeletonHelper||(e.helper.update(),r.helperChanged.dispatch(e.helper)),_()})),r.objectsSelected.add((function(e){if(Array.isArray(e)){if(1===e.length){var r=e[0];if(null===r.parent)return;var n=t.transformControls.enabled;t.transformControls.detach(),t.transformControls.attach(r),t.transformControls.visible=n,t.transformControls.enabled=n}if(t.outlinePass.enabled){var a=t.outlinePass;a.selectedObjects=[],e.forEach((function(e){e.traverse((function(e){0===e.children.length&&a.selectedObjects.push(e)}))}))}}})),r.objectFocused.add((function(e){var r=new THREE.Vector3;e&&r.copy(e.position),t.controls instanceof THREE.OrbitControls||t.controls instanceof THREE.TrackballControls?(t.controls.target.copy(r),t.controls.update()):t.controls instanceof THREE.FirstPersonControls&&(t.controls.lookAt(r),t.controls.update(a.getDeltaTime()))})),r.helperAdded.add((function(e){var r=e.getObjectByName("picker");t.selectables.push(r)})),r.helperChanged.add((function(e){var t=e.light;t&&(e.visible=t.visible)})),r.helperRemoved.add((function(e){var r=t.selectables,n=e.getObjectByName("picker");r.splice(r.indexOf(n),1)})),r.cameraChanged.add((function(e){e&&(t.config.setSettings("cameraFov",e.fov),t.config.setSettings("cameraNear",e.near),t.config.setSettings("cameraFar",e.far)),_()})),r.historyChanged.add((function(){var e=t.history;e.undos.length,e.redos.length})),r.appWorksCleared.add((function(){t.select(null),t.focus(),_()})),r.autoSaveStarted.add((function(){})),r.autoSaveFinished.add((function(){})),r.transformModeChanged.add((function(e){t.transformControls.setMode(e)})),r.snapChanged.add((function(e){t.transformControls.setTranslationSnap(e)})),r.spaceChanged.add((function(e){t.transformControls.setSpace(e)})),r.windowResize.add((function(){R()}))}this.config=null,!0===e.config&&(this.config=new a.Config(this.appName),this.config.initDatabase((function(){var e;function r(){!1!==t.config.getSettings("autosave")&&(clearTimeout(e),e=setTimeout((function(){t.signals.autoSaveStarted.dispatch(),e=setTimeout((function(){t.config.setDatabase(t.toJSON()),t.signals.autoSaveFinished.dispatch()}),100)}),1e3))}t.config.getDatabase((function(e){void 0!==e&&t.fromJSON(e)}));var n=t.signals;n.geometryChanged.add(r),n.materialChanged.add(r),n.objectAdded.add(r),n.objectChanged.add(r),n.objectRemoved.add(r),n.sceneBackgroundChanged.add(r),n.sceneFogChanged.add(r),n.sceneGraphChanged.add(r),n.historyChanged.add(r)}))),this.history=null,!0===e.history&&(this.history=new a.History(this)),2===e.glVersion&&a.isWebGL2Available()?this.renderer=new THREE.WebGLRenderer({alpha:!0,powerPreference:"high-performance"}):this.renderer=new THREE.WebGL1Renderer({alpha:!0,powerPreference:"high-performance"}),this.renderer.autoClear=!0,this.renderer.setClearColor(0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.width,this.height),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=THREE.PCFSoftShadowMap,this.renderer.outputEncoding=THREE.sRGBEncoding,this.renderer.gammaFactor=2.2,this.renderer.toneMapping=THREE.LinearToneMapping,this.renderer.toneMappingExposure=1,this.dom.appendChild(this.renderer.domElement),this.scene=new THREE.Scene,this.scene.name="scene",this.scene.appName=this.appName,this.createSceneFog=function(e){this.scene.fog=a.createFog(e)},this.createSceneFog(e.fog),this.createSceneBackground=function(e){e=void 0!==e?e:this.config?this.config.getSettings("background"):null;this.scene.background&&this.scene.background.dispose&&this.scene.background.dispose(),this.scene.background=a.createBackground(e)},this.createSceneBackground(e.background);var s,l,c,f,d,u,v,m,x,g=e.cameraFov||this.config?this.config.getSettings("cameraFov"):50,y=e.cameraNear||this.config?this.config.getSettings("cameraNear"):.01,E=e.cameraFar||this.config?this.config.getSettings("cameraFar"):1e4,w=e.cameraPosition||this.config?this.config.getSettings("cameraPosition"):[0,0,50];function b(e,r,n){e=e||t.config?t.config.getSettings("gridHelperSize"):500,r=r||t.config?t.config.getSettings("gridHelperSpacing"):5,n=n||t.config?t.config.getSettings("gridHelperColor"):4210752;e=~~(e/r),e*=r;var o=new THREE.GridHelper(e,e/r,16729156,n);o.position.y=0,o.name="gridHelper";for(var i=.05*r,s=e/2,l=[],c=-s;c<=s;c+=r)l.push(c.toFixed(2));return l.forEach((function(e){var t=a.createTextSprite(e,{textHeight:i,fontWeight:"bold"}),r=t.clone();t.position.set(parseFloat(e),i/2,0),r.position.set(0,i/2,parseFloat(e)),o.add(t),o.add(r)})),o}function T(){t.animateID=window.requestAnimationFrame(T),function(){var e=a.getDeltaTime(),r=a.getCurrentTime();t.stats&&t.stats.update();t.animator.update(e),t.scene.traverse((function(t){t.update&&t.update(e,r)})),t.sceneHUD&&t.sceneHUD.traverse((function(t){t.update&&t.update(e,r)}));var n=t.controls;n.enabled&&(n instanceof THREE.OrbitControls?!0!==n.autoRotate&&!0!==n.enableDamping||n.update():n instanceof THREE.TrackballControls?n.update():(n instanceof THREE.FirstPersonControls||!0===n.isTPSCameraControl)&&n.update(e))}(),_()}function _(){t.effect?(t.renderer.setRenderTarget(null),t.effect.render(t.scene,t.camera)):t.composer?t.composer.render(a.getDeltaTime()):"MedicalWorks"!==t.appName&&t.renderer.render(t.scene,t.camera)}function S(){return[Math.max(document.documentElement.clientWidth||0,window.innerWidth||0),Math.max(document.documentElement.clientHeight||0,window.innerHeight||0)]}function R(){var[e,r]=S();(t.width=t.widthRatio*e,t.height=t.heightRatio*r,t.dom.style.width=t.width+"px",t.dom.style.height=t.height+"px",t.camera.aspect=t.width/t.height,t.camera.updateProjectionMatrix(),function(){if(!t.sceneHUD||!t.cameraHUD)return;var e=t.cameraHUD,r=e.right,n=e.top,a=t.width/2,o=t.height/2;e.left=-a,e.right=a,e.top=o,e.bottom=-o,e.updateProjectionMatrix(),t.sceneHUD.children.forEach(e=>{var t=e.position;t.x*=1+(a-r)/Math.abs(t.x),t.y*=1+(o-n)/Math.abs(t.y)})}(),t.FXAAShader.enabled&&t.FXAAShader.uniforms.resolution.value.set(1/t.width,1/t.height),t.renderer.setSize(t.width,t.height),t.composer&&t.composer.setSize(t.width,t.height),t.effect&&t.effect.setSize(t.width,t.height),t.controls.enabled&&(t.controls instanceof THREE.OrbitControls||t.controls.handleResize()),"NatureWorks"===t.appName)&&t.scene.getObjectsByType("FireParticles").forEach((function(e){e.setNearPlaneHeight()}))}function A(e){var r=t.dom.getBoundingClientRect(),n=a.getMouseScreenCoords(e);return n.x=(n.x-r.left)/r.width*2-1,n.y=-(n.y-r.top)/r.height*2+1,n}function M(e,r){return t.raycaster.setFromCamera(e,t.camera),t.raycaster.intersectObjects(r,!0)}function C(){var e=t.getIntersectObject(t.xinfo);e&&("picker"===e.name?t.select(e.userData.object):event.ctrlKey?t.select(e,"multiple"):event.altKey?t.select(e,"ancestor"):t.select(e),_())}function L(e){t.mouseUpPosition.copy(A(e)),C(),document.removeEventListener("mouseup",L,!1)}function H(e){e.preventDefault(),m&&(clearTimeout(m),x=!1),t.mouseUpPosition.copy(A(e)),C(),document.removeEventListener("touchend",H,!1)}function P(e){t.mouseUpPosition.copy(t.mouseDownPosition),z(e)}function z(e){t.guiContextMenu&&(t.getIntersectObject()&&t.guiContextMenu.toggle(e))}function k(e){switch(t.appName){case"ViewWorks":!function(e){switch(e.stopPropagation(),e.keyCode){case 8:e.preventDefault();case 27:t.controls.enabled=!0;break;case 49:a.nextShowroom("background");break;case 50:a.nextShowroom("floor");break;case 66:a.demoApplication();break;case 79:if(t.animator&&t.selectObject){var r=t.selectObject.activeAction;r.paused=!r.paused}break;case 80:t.animator&&t.selectObject&&t.playNextAction(t.selectObject)}}(e);break;case"GameWorks":!function(e){switch(e.keyCode){case 66:a.demoApplication();break;case 191:a.gamePlay()}}(e);break;case"NatureWorks":!function(e){122!==e.keyCode&&e.preventDefault();e.stopPropagation();var r=a.isCtrlKeyDown(e);if(r&&90===e.keyCode)return void t.undo();if(r&&89===e.keyCode)return void t.redo();switch(e.keyCode){case 8:e.preventDefault();case 46:var n=t.selectObject;n&&n.parent&&t.remove(n);break;case 18:break;case 27:t.controls.enabled=!0;break;case 49:a.filmGrainBackground();break;case 50:break;case 66:a.demoApplication();break;case 67:t.controls instanceof THREE.OrbitControls?t.controls=a.createCameraControls("FirstPersonControls"):t.controls instanceof THREE.FirstPersonControls&&(t.controls=a.createCameraControls("OrbitControls"));break;case 70:a.demoLoadFiles();break;case 72:a.add(a.createHemisphereLight());break;case 73:a.cameraAutoView({isWorking:!0})?a.cameraAutoView({viewMode:"stop"}):a.cameraAutoView({viewMode:"circle"});break;case 76:a.toggleLightHelpers();break;case 77:void 0!==t.sound&&(t.sound.playing()?t.sound.pause():t.sound.play());break;case 78:a.add(a.createSky()),a.add(a.createSunLight());break;case 79:if(t.animator&&t.selectObject){var o=t.selectObject.activeAction;o.paused=!o.paused}break;case 80:t.animator&&t.selectObject&&t.playNextAction(t.selectObject);break;case 86:a.demoRaymarchToPoints();break;case 112:t.appGUI&&t.appGUI.toggle(t.guiSceneGraph.dom);break;case 113:t.appGUI&&t.appGUI.toggle();break;case 114:t.dragControls.enabled=!t.dragControls.enabled;break;case 115:t.transformControls.visible=!t.transformControls.visible,t.transformControls.enabled=!t.transformControls.enabled;break;case 116:t.guiSidebar&&t.guiSidebar.select(t.guiStrings.getKey("menubar/edit/scene"),"inclusive");break;case 117:a.screenCapture();break;case 118:break;case 119:t.selectObject&&t.focus(t.selectObject);break;case 120:t.config.clearSettings(),console.log('>> clear the "window.localStorage"...');break;case 121:t.config.clearDatabase(),console.log('>> clear the "window.indexedDB"...');break;case 123:void 0!==t.dragVertexControls&&(t.dragVertexControls.enabled=!t.dragVertexControls.enabled,t.controls.enabled=!t.dragVertexControls.enabled);break;case 191:a.gamePlay();break;case 81:t.transformControls.setSpace("local"===t.transformControls.space?"world":"local");break;case 17:t.transformControls.setTranslationSnap(t.config.getSettings("translationSnap")),t.transformControls.setRotationSnap(THREE.Math.degToRad(t.config.getSettings("rotationSnap")));break;case 87:t.transformControls.setMode("translate");break;case 69:t.transformControls.setMode("rotate");break;case 82:t.transformControls.setMode("scale");break;case 187:case 107:t.transformControls.setSize(t.transformControls.size+.1);break;case 189:case 109:t.transformControls.setSize(Math.max(t.transformControls.size-.1,.1));break;case 88:t.transformControls.showX=!t.transformControls.showX;break;case 89:t.transformControls.showY=!t.transformControls.showY;break;case 90:t.transformControls.showZ=!t.transformControls.showZ;break;case 32:t.transformControls.visible=!t.transformControls.visible,t.transformControls.enabled=!t.transformControls.enabled}}(e);break;case"MedicalWorks":a.MedicalKeyboard(e)}}this.defaultCamera=new THREE.PerspectiveCamera(g,this.width/this.height,y,E),this.defaultCamera.position.set(w[0],w[1],w[2]),this.defaultCamera.lookAt(this.scene.position),this.defaultCamera.name="camera",this.camera=this.defaultCamera.clone(),this.controls=a.createCameraControls(e.controlsType,this.camera,this.renderer.domElement),this.animator=new a.Animator(this.scene),this.playAction=function(e,t,r){this.animator.playAction(e,t,r)},this.playNextAction=function(e){this.animator.playNextAction(e)},this.stopAction=function(e,t){this.animator.stopAction(e,t)},this.stats=null,!0!==e.stats||a.isDeviceMobile()||(this.stats=new h,this.stats.dom.style.cssText="position:absolute; bottom:0px; right:0px",this.dom.appendChild(this.stats.dom)),this.raycaster=new THREE.Raycaster,this.selectObject=null,this.selectObjects=[],this.selectables=[],this.mouseMovePosition=new THREE.Vector2,this.mouseDownPosition=new THREE.Vector2,this.mouseUpPosition=new THREE.Vector2,this.mouseDoubleClickPosition=new THREE.Vector2,this.playAudio=function(e){this.sound&&this.sound.unload(),this.sound=a.playAudio(e)},this.playAudio(e.audioFiles),this.sceneHelpers=new THREE.Scene,"NatureWorks"===this.appName&&(this.gridHelper=b(),this.gridHelper.visible=e.gridVisible||!1,this.sceneHelpers.add(this.gridHelper)),this.sceneHUD=null,this.cameraHUD=null,!0===e.hud&&(this.sceneHUD=new THREE.Scene,this.cameraHUD=new THREE.OrthographicCamera(-this.width/2,this.width/2,this.height/2,-this.height/2,.1,100.1),this.cameraHUD.position.z=50.1),function(e){e=e||{};t.composer=new THREE.EffectComposer(t.renderer),t.composer.setSize(t.width,t.height),t.renderPass=new THREE.RenderPass(t.scene,t.camera),t.renderPass.clear=!0,t.renderPass.clearDepth=!1,t.composer.addPass(t.renderPass),t.sceneHelpers&&(t.renderPass2=new THREE.RenderPass(t.sceneHelpers,t.camera),t.renderPass2.clear=!1,t.renderPass2.clearDepth=!1,t.composer.addPass(t.renderPass2));t.sceneHUD&&(t.renderPass3=new THREE.RenderPass(t.sceneHUD,t.cameraHUD),t.renderPass3.clear=!1,t.renderPass3.clearDepth=!1,t.composer.addPass(t.renderPass3));void 0!==e.bleachEnabled&&(t.bleachShader=new THREE.ShaderPass(THREE.BleachBypassShader),t.bleachShader.enabled=e.bleachEnabled,t.composer.addPass(t.bleachShader));void 0!==e.bloomEnabled&&(t.bloomPass=new THREE.UnrealBloomPass(new THREE.Vector2(t.width,t.height),2.5,.45,.88),t.bloomPass.enabled=e.bloomEnabled,t.composer.addPass(t.bloomPass));void 0!==e.dotScreenEnabled&&(t.dotScreenShader=new THREE.ShaderPass(THREE.DotScreenShader),t.dotScreenShader.uniforms.scale.value=4,t.dotScreenShader.enabled=e.dotScreenEnabled,t.composer.addPass(t.dotScreenShader));void 0!==e.glitchEnabled&&(t.glitchPass=new THREE.GlitchPass(0),t.glitchPass.enabled=e.glitchEnabled,t.composer.addPass(t.glitchPass));void 0!==e.sepiaEnabled&&(t.sepiaShader=new THREE.ShaderPass(THREE.SepiaShader),t.sepiaShader.enabled=e.sepiaEnabled,t.composer.addPass(t.sepiaShader));if(void 0!==e.outlineEnabled){t.outlinePass=new THREE.OutlinePass(new THREE.Vector2(t.width,t.height),t.scene,t.camera),t.outlinePass.enabled=e.outlineEnabled,t.composer.addPass(t.outlinePass),(new THREE.TextureLoader).load("images/tri_pattern.jpg",(function(e){e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,t.outlinePass.patternTexture=e}))}e.FXAAEnabled=!0,void 0!==e.FXAAEnabled&&(t.FXAAShader=new THREE.ShaderPass(THREE.FXAAShader),t.FXAAShader.uniforms.resolution.value.set(1/t.width,1/t.height),t.FXAAShader.enabled=e.FXAAEnabled,t.composer.addPass(t.FXAAShader));void 0!==e.ssaoEnabled&&(t.ssaoPass=new THREE.SSAOPass(t.scene,t.camera,t.width,t.height),t.ssaoPass.enabled=e.ssaoEnabled,t.composer.addPass(t.ssaoPass));void 0!==e.godRaysEnabled&&(t.godRaysPass=new a.GodRaysPass(t.scene,t.camera,t.width,t.height),t.godRaysPass.enabled=e.godRaysEnabled,t.composer.addPass(t.godRaysPass));void 0!==e.bokehEnabled&&(t.bokehPass=new THREE.BokehPass(t.scene,t.camera,{width:t.width,height:t.height,vignetting:1}),t.bokehPass.enabled=e.bokehEnabled,t.composer.addPass(t.bokehPass));void 0!==e.vignetteEnabled&&(t.vignetteShader=new THREE.ShaderPass(THREE.VignetteShader),t.vignetteShader.enabled=e.vignetteEnabled,t.composer.addPass(t.vignetteShader));t.gammaCorrection=new THREE.ShaderPass(THREE.GammaCorrectionShader),t.composer.addPass(t.gammaCorrection)}(e),this.cameraEffect=function(e){this.effect=a.createCameraEffect(e,this.renderer),this.effect?this.effect.setSize(this.width,this.height):this.renderer.setSize(this.width,this.height)},this.cameraEffect(e.effectType),this.fileExplorer=null,!0===e.fileExplorer&&(this.fileExplorer=new a.FileExplorer(this)),this.dragControls=null,!0===e.dragControls&&(this.dragControls=(s=this.scene.children,l=this.camera,c=this.renderer,f=null,(d=new THREE.DragControls(s,l,c.domElement)).enabled=!1,d.addEventListener("dragstart",(function(e){if(this.enabled){var r=e.object;f=r.position.clone(),t.controls.enabled=!1,t.select(r)}})),d.addEventListener("dragend",(function(e){if(this.enabled){var r=e.object;void 0!==r&&(f.equals(r.position)||t.setPosition(r,r.position,f)),t.controls.enabled=!0}})),d)),this.transformControls=null,!0===e.transformControls&&(this.transformControls=function(e,r){var n=null,a=null,o=null,i=new THREE.TransformControls(e,r.domElement);return i.visible=!0,i.enabled=!0,i.addEventListener("change",(function(){var e=i.object;e&&e.helper&&!e.helper instanceof THREE.SkeletonHelper&&e.helper.update()})),i.addEventListener("mouseDown",(function(){var e=i.object;n=e.position.clone(),a=e.rotation.clone(),o=e.scale.clone(),t.controls.enabled=!1})),i.addEventListener("mouseUp",(function(){var e=i.object;if(void 0!==e)switch(i.getMode()){case"translate":n.equals(e.position)||t.setPosition(e,e.position,n);break;case"rotate":a.equals(e.rotation)||t.setRotation(e,e.rotation,a);break;case"scale":o.equals(e.scale)||t.setScale(e,e.scale,o)}t.controls.enabled=!0})),i}(this.camera,this.renderer),this.transformControls.setSize(.5),this.sceneHelpers.add(this.transformControls)),window.addEventListener("orientationchange",(function(){[t.widthRatio,t.heightRatio]=[t.heightRatio,t.widthRatio]}),!1),window.addEventListener("resize",R,!1),this.dom.addEventListener("click",(function(e){t.dom.focus()}),!1),this.dom.addEventListener("dblclick",(function(e){t.mouseDoubleClickPosition.copy(A(e));var r=t.getIntersectObject("mouseDoubleClick");r&&t.focus(r)}),!1),this.dom.addEventListener("mousemove",(function(e){t.mouseMovePosition.copy(A(e)),t.bokehPass&&t.bokehPass.enabled&&t.bokehPass.mouse.copy(t.mouseMovePosition)}),!1),this.dom.addEventListener("mousedown",(function(e){t.mouseDownPosition.copy(A(e)),document.addEventListener("mouseup",L,!1)}),!1),this.dom.addEventListener("touchmove",(function(e){e.preventDefault(),m&&clearTimeout(m);t.mouseMovePosition.copy(A(e)),t.bokehPass&&t.bokehPass.enabled&&t.bokehPass.mouse.copy(t.mouseMovePosition)}),!0),this.dom.addEventListener("touchstart",(function(e){t.guiContextMenu&&t.guiContextMenu.setDisplay("none");if(e.preventDefault(),x)return;m=setTimeout(P,500,e),x=!0,t.mouseDownPosition.copy(A(e)),document.addEventListener("touchend",H,!1)}),!1),this.dom.addEventListener("keydown",k,!1),this.dom.addEventListener("keyup",(function(e){switch(t.appName){case"NatureWorks":!function(e){switch(e.preventDefault(),e.stopPropagation(),e.keyCode){case 17:t.transformControls.setTranslationSnap(null),t.transformControls.setRotationSnap(null),t.controls.enabled=!0}}(e)}}),!1),this.dom.addEventListener("contextmenu",z,!1),this.renderScene=function(){T()},this.resize=function(e,t){var[r,n]=S();this.widthRatio=(e||r)/r,this.heightRatio=(t||n)/n,R()},this.onKeyDown=function(e){k(e)},this.getBoundingBox=function(){return a.computeBoundingBox(this.scene)},this.getMousePosition=function(e){return A(e)},this.getIntersectObject=function(e){if("string"==typeof e){var t;if("mouseDown"===e)t=this.mouseDownPosition;else if("mouseUp"===e)t=this.mouseUpPosition;else{if("mouseDoubleClick"!==e)return null;t=this.mouseDoubleClickPosition}return(r=M(t,this.selectables)).length>0?r[0].object:null}var r;return this.mouseDownPosition.equals(this.mouseUpPosition)&&(r=M(this.mouseUpPosition,this.selectables)).length>0?(void 0!==e&&(e.object=r[0].object,e.distance=r[0].distance,e.point=r[0].point,e.uv=r[0].uv),r[0].object):null},this.select=function(e,r){if(e){var n=e;if("ancestor"===r)e.traverseAncestors((function(e){e.parent===t.scene&&(n=e)})),this.selectObjects=[n];else if("multiple"===r){var a=this.selectObjects.indexOf(n);-1===a?this.selectObjects.push(n):this.selectObjects.splice(a,1)}else this.selectObjects=[n];this.selectObject=n,this.signals.objectSelected.dispatch(n),this.signals.objectsSelected.dispatch(this.selectObjects)}else this.selectObject=null,this.selectObjects=[],this.signals.objectSelected.dispatch(null),this.signals.objectsSelected.dispatch(this.selectObjects)},this.selectById=function(e,t){e!==this.camera.id?this.select(this.scene.getObjectById(e,!0),t):this.select(this.camera,t)},this.selectByUuid=function(e,t){this.scene.traverse((function(r){r.uuid===e&&this.select(r,t)}))},this.deselect=function(){this.selectObject=null},this.focus=function(e){this.signals&&this.signals.objectFocused.dispatch(e)},this.focusById=function(e){this.focus(this.scene.getObjectById(e,!0))},this.objectByUuid=function(e){return this.scene.getObjectByProperty("uuid",e)},this.addObject=function(e,r,n){e.traverse((function(e){t.addHelper(e)})),void 0===r?this.scene.add(e):(r.children.splice(n,0,e),e.parent=r),this.signals.objectAdded.dispatch(e),this.signals.sceneGraphChanged.dispatch()},this.moveObject=function(e,t,r){if(void 0===t&&(t=this.scene),t.add(e),void 0!==r){var n=t.children.indexOf(r);t.children.splice(n,0,e),t.children.pop()}this.signals.sceneGraphChanged.dispatch()},this.removeObject=function(e){null!==e.parent&&(e.traverse((function(e){t.removeHelper(e)})),e.parent.remove(e),this.signals.objectRemoved.dispatch(e),this.signals.sceneGraphChanged.dispatch())},this.addHelper=(u=new THREE.SphereBufferGeometry(2,4,2),v=new THREE.MeshBasicMaterial({color:16711680,visible:!1}),function(e){if(!a.isDeviceMobile()){var t;if(e instanceof THREE.Camera)(t=new THREE.CameraHelper(e)).name="cameraHelper";else if(e instanceof THREE.PointLight)(t=new THREE.PointLightHelper(e,1)).name="pointLightHelper";else if(e instanceof THREE.DirectionalLight)(t=new THREE.DirectionalLightHelper(e,1)).name="directionalLightHelper","SunLight"===e.userData.type&&(t.visible=!1);else if(e instanceof THREE.SpotLight)(t=new THREE.SpotLightHelper(e)).name="spotLightHelper";else if(e instanceof THREE.HemisphereLight)(t=new THREE.HemisphereLightHelper(e,1)).name="hemisphereLightHelper";else{if(!(e instanceof THREE.SkinnedMesh))return;(t=new THREE.SkeletonHelper(e)).name="skeletonHelper"}var r=new THREE.Mesh(u,v);r.name="picker",r.userData.object=e,t.add(r),e.helper=t,this.sceneHelpers.add(t),this.signals.helperAdded.dispatch(t)}}),this.removeHelper=function(e){var t=e.helper;void 0!==t&&(t.parent.remove(t),this.signals.helperRemoved.dispatch(t))},this.getObjectMaterial=function(e,t){var r=void 0;return e&&(r=e.material,Array.isArray(r)&&void 0!==t&&(r=r[t])),r},this.setObjectMaterial=function(e,t,r){Array.isArray(e.material)&&void 0!==t?e.material[t]=r:e.material=r},this.clear=function(){this.history&&this.history.clear(),this.config&&this.config.clearDatabase(),this.camera.copy(this.defaultCamera);for(var e=this.scene.children;e.length>0;)this.removeObject(e[0]);this.deselect(),this.signals.appWorksCleared.dispatch(),this.signals.windowResize.dispatch()},this.fromJSON=function(e){var r=new THREE.ObjectLoader,n=r.parse(e.camera);this.camera.copy(n),this.camera.aspect=this.defaultCamera.aspect,this.camera.updateProjectionMatrix(),this.history&&this.history.fromJSON(e.history),r.parse(e.scene,(function(e){t.setScene(e)}))},this.toJSON=function(){return{metadata:{},camera:this.camera.toJSON(),scene:this.scene.toJSON(),history:this.history?this.history.toJSON():""}},this.execute=function(e,t){this.history&&this.history.execute(e,t)},this.undo=function(){this.history&&this.history.undo()},this.redo=function(){this.history&&this.history.redo()},this.add=function(e){this.execute(new a.AddObjectCommand(e))},this.remove=function(e){this.execute(new a.RemoveObjectCommand(e))},this.replace=function(e,t){var r=[];r.push(new a.RemoveObjectCommand(e)),r.push(new a.AddObjectCommand(t)),this.multiCmds(r)},this.move=function(e,t,r){e.parent?this.execute(new a.MoveObjectCommand(e,t,r)):Alert("The object cannot be moved to the new parent")},this.moveTo=function(e,t,r){this.add(e),this.move(e,t,r)},this.setPosition=function(e,t,r){this.execute(new a.SetPositionCommand(e,t,r))},this.setRotation=function(e,t,r){this.execute(new a.SetRotationCommand(e,t,r))},this.setScale=function(e,t,r){this.execute(new a.SetScaleCommand(e,t,r))},this.setGeometry=function(e,t){this.execute(new a.SetGeometryCommand(e,t))},this.setGeometryValue=function(e,t,r){this.execute(new a.SetGeometryValueCommand(e,t,r))},this.setMaterial=function(e,t,r){this.execute(new a.SetMaterialCommand(e,t,r))},this.setMaterialValue=function(e,t,r,n){this.execute(new a.SetMaterialValueCommand(e,t,r,n))},this.setMaterialVector=function(e,t,r,n){this.execute(new a.SetMaterialVectorCommand(e,t,r,n))},this.setMaterialColor=function(e,t,r,n){this.execute(new a.SetMaterialColorCommand(e,t,r,n))},this.setMaterialMap=function(e,t,r,n){this.execute(new a.SetMaterialMapCommand(e,t,r,n))},this.setUuid=function(e,t){this.execute(new a.SetUuidCommand(e,t))},this.setValue=function(e,t,r){this.execute(new a.SetValueCommand(e,t,r))},this.setColor=function(e,t,r){this.execute(new a.SetColorCommand(e,t,r))},this.setScene=function(e){this.execute(new a.SetSceneCommand(e))},this.multiCmds=function(e){this.execute(new a.MultiCmdsCommand(e))},a.appWorks=this,"NatureWorks"===this.appName||("ViewWorks"===this.appName?"wordpress.org"!==this.customer&&(a.viewWorksInfo(),a.createFlashtext("ViewWorks",{fontSize:"10vw"}),setTimeout(()=>{a.hideFlashtext()},3e3)):"MedicalWorks"===this.appName&&a.demoMedicalExamples())},a.viewWorksInfo=function(){var e=document.createElement("div");e.id="infoButton",e.innerHTML='        <img src="images/info.png" border="0" />\n    ',e.style.cssText="        position: absolute;\n        left: 0;\n        top: 0;\n        z-index: 2;\n        padding: 8px;\n        margin: 0 0 0 0;\n        text-align: left;\n        display: block;\n    ",e.addEventListener("click",(function(e){var t=document.getElementById("infoPanel").style;t.display="block"==t.display?"none":"block"})),document.getElementById("app-container").parentNode.appendChild(e);var t=document.createElement("div");t.id="infoPanel",t.innerHTML='        <b>ViewWorks - 3D model viewer</b>\n        <p>\n        To view your 3D models,<br>\n        <b>drag & drop the model file(s) onto the browser.</b><br><br>\n        Supported file formats<br>\n        JSON, OBJ(+MTL), STL, PLY, DAE(COLLADA),<br>\n        GLTF, GLB, AMF, 3MF, WRL(VRML), FBX,<br>\n        3DS, DRC, KMZ, MD2, SVG, VTK<br>\n        </p>\n        (C) <a href="https://www.nova-graphix.com/" target="_blank" style="color: #ffa500; text-decoration: none;">NovaGraphix, Co.</a>, 2018.\n    ',t.style.cssText="        position: absolute;\n        left: 0;\n        top: 0;\n        z-index: 1;\n        padding: 32px;\n        margin: 0.5em 0em 0em 0.4em;\n        background: #121212;\n        color: #fff;\n        opacity: 0.8;\n        border-radius: 20px;\n        text-align: left;\n        font-family: 'Karla', sans-serif;\n        font-size: 80%;\n        display: none;\n    ",document.getElementById("app-container").parentNode.appendChild(t)},a.createBackground=function(e){if(!e)return null;if(e.isTexture)return e.encoding=THREE.sRGBEncoding,e;if("number"==typeof e)return new THREE.Color(e);if("string"==typeof e)return"FS"===e.substr(-2,2)?function(e){var t=new THREE.Vector2;a.appWorks.renderer.getSize(t);var r=a.BackgroundShader;(l=THREE.UniformsUtils.clone(r.uniforms)).resolution.value=t;var n=r.vertexShader,o=r[e],i=a.isWebGL1()?{gl_FragDepth:"gl_FragDepthEXT"}:{},s=new THREE.ShaderMaterial({defines:i,uniforms:l,vertexShader:n,fragmentShader:o});if("cloudsFS"===e){var l=s.uniforms,c=(new THREE.TextureLoader).load("images/raymarch/rgbaNoise256.png",(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));l.textureMaps.value.push(c)}s.extensions={derivatives:!0,fragDepth:!0,drawBuffers:!0,shaderTextureLOD:!0};var f=new THREE.PlaneBufferGeometry(2,2);return(e=new THREE.Mesh(f,s)).name="backgroundMesh",e.frustumCulled=!1,e.update=function(e,r){a.appWorks.renderer.getSize(t);var n=this.material.uniforms;n.time.value=r,n.resolution.value=t},e}(e):function(e){var t=".jpg",r="images/background/"+e+"/";switch(e){case"cloud":case"galaxy":case"redSky":case"smallLake":t=".png";break;default:t=".jpg"}var n=["posx"+t,"negx"+t,"posy"+t,"negy"+t,"posz"+t,"negz"+t],a=(new THREE.CubeTextureLoader).setPath(r).load(n);return a.format=THREE.RGBFormat,a.encoding=THREE.sRGBEncoding,a}(e)},a.createFog=function(e){var t=void 0!==(e=e||{}).color?e.color:a.FOG_COLOR;if("linear"===e.type){var r=void 0!==e.near?e.near:this.camera.near,n=void 0!==e.far?e.far:this.camera.far;return new THREE.Fog(t,r,n)}if("exp2"===e.type){var o=void 0!==e.density?e.density:.001;return new THREE.FogExp2(t,o)}return null},a.createCameraControls=function(e,t,r){var n;e=void 0!==e?e:"OrbitControls",t=void 0!==t?t:a.appWorks.camera,r=void 0!==r?r:a.appWorks.renderer.domElement;return a.appWorks&&a.appWorks.controls&&a.appWorks.controls.dispose(),"TrackballControls"===e?((n=new THREE.TrackballControls(t,r)).rotateSpeed=10,n.zoomSpeed=5,n.panSpeed=2,n.staticMoving=!1,n.dynamicDampingFactor=.2,n.enabled=!0):"FirstPersonControls"===e?((n=new THREE.FirstPersonControls(t,r)).movementSpeed=100,n.lookSpeed=.05,n.lookVertical=!0,n.activeLook=!0,n.constrainVertical=!0,n.verticalMin=1.1,n.verticalMax=2.2,n.enabled=!0):((n=new THREE.OrbitControls(t,r)).enablePan=!0,n.enableZoom=!0,n.enableDamping=!0,n.screenSpacePanning=!0,n.dampingFactor=.2,n.panSpeed=1,n.rotateSpeed=1,n.enabled=!0),n},a.playAudio=function(e,t){if(!(Array.isArray(e)&&e.length>0))return null;var r=new v.Howl({src:[e[0]],autoplay:!0,loop:!0,volume:.5,onend:function(){e.shift(),e.length>0&&a.playAudio(e)}});return r.play(),r},a.createCameraEffect=function(e,t){e=void 0!==e?e:"NoEffect",t=void 0!==t?t:a.appWorks.renderer;return"AnaglyphEffect"===e?new THREE.AnaglyphEffect(t):"StereoEffect"===e?new THREE.StereoEffect(t):"ParallaxBarrierEffect"===e?new THREE.ParallaxBarrierEffect(t):null},a.Animator=function(e){e=void 0!==e?e:a.appWorks.scene;this.mixer=new THREE.AnimationMixer(e),this.update=function(e){this.mixer.update(e)},this.addAnimation=function(e,t){t.length>0&&(e.animations=t)},this.createActions=function(e){var t={},r=e.animations;if(void 0!==r){for(var n of r)t[n.name]=this.mixer.clipAction(n,e),e.activeAction||(e.activeAction=t[n.name]);return t}},this.playAction=function(e,t,r){if(e.animations&&0!==e.animations.length){var n=(r=r||{}).duration||1,o=r.loopMode||THREE.LoopRepeat,i=r.repetitions||1/0,s=r.combine||"crossFade";e=void 0!==e?e:a.appWorks.selectObject,t=void 0!==t?t:e.animations[0];if("crossFade"==s){var l=e.activeAction,c=this.mixer.clipAction(t,e);return c?(c.enabled=!0,c.setLoop(o,i),l?(l.enabled=!0,l.crossFadeTo(c,n).play()):c.play(),e.activeAction=c,c):void 0}if("overlap"===s){var f=this.mixer.clipAction(t,e);return f.play(),e.activeAction=f,f}}},this.playNextAction=function(e){var t=(e=void 0!==e?e:a.appWorks.selectObject).animations;if(void 0!==t){var r=-1;if(e.activeAction){var n=e.activeAction.getClip();r=t.indexOf(n)}var o=t[r=~~((r+1)%t.length)];e.activeAction=this.playAction(e,o),console.log('>> playAction: "'+o.name+'"')}},this.stopAction=function(e,t){if(e&&t)(r=this.mixer.clipAction(t,e)).enabled=!0,r.stop();else if(e&&!t){var r;(r=e.activeAction)&&(r.enabled=!0,r.stop())}},this.stopAllActions=function(){this.mixer.stopAllAction()}},a.createAmbientLight=function(e){var t=(e=e||{}).color||16777215,r=e.intensity||.2,n=new THREE.AmbientLight(t,r);return n.name="ambientLight",n},a.createPointLight=function(e){var t=(e=e||{}).color||16777215,r=e.intensity||1,n=e.distance||0,o=e.decay||2,i=e.near||.01,s=e.far||.2*a.appWorks.camera.far,l=new THREE.PointLight(t,r,n,o);return l.castShadow=!0,l.shadow.camera.near=i,l.shadow.camera.far=s,l.shadow.mapSize.width=2048,l.shadow.mapSize.height=2048,l.shadow.radius=1.5,l.name="pointLight",l},a.createSpotLight=function(e){var t=(e=e||{}).color||16777215,r=e.intensity||1,n=e.distance||0,o=e.angle||.1*Math.PI,i=e.penumbra||.05,s=e.decay||2,l=e.near||.01,c=e.far||.2*a.appWorks.camera.far,f=e.target,d=new THREE.SpotLight(t,r,n,o,i,s);return d.castShadow=!0,d.shadow.camera.near=l,d.shadow.camera.far=c,d.shadow.mapSize.width=2048,d.shadow.mapSize.height=2048,d.shadow.radius=1.5,d.name="spotLight",f&&f.isObject3D&&(d.target=f,a.appWorks.scene.getObjectById(f.id)||a.add(f)),d},a.createDirectionalLight=function(e){var t=(e=e||{}).color||16777215,r=e.intensity||1,n=e.target,o=e.shadowCameraSize||.2*a.appWorks.camera.far,i=new THREE.DirectionalLight(t,r);return i.castShadow=!0,i.shadow.camera.top=o,i.shadow.camera.bottom=-o,i.shadow.camera.left=-o,i.shadow.camera.right=o,i.shadow.camera.near=.01,i.shadow.camera.far=2.5*o,i.shadow.mapSize.width=2048,i.shadow.mapSize.height=2048,i.shadow.radius=1.5,i.shadow.bias=1e-4,i.name="directionalLight",n&&n.isObject3D&&(i.target=n,a.appWorks.scene.getObjectById(n.id)||a.add(n)),i},a.createHemisphereLight=function(e){var t=(e=e||{}).skyColor||(new THREE.Color).setHSL(.6,1,.6),r=e.groundColor||(new THREE.Color).setHSL(.095,1,.75),n=e.intensity||1,a=new THREE.HemisphereLight(t,r,n);return a.name="hemisphereLight",a},a.createThreePointLights=function(){var e,t=new THREE.Object3D;return t.name="threePointLights",(e=a.createAmbientLight({color:1052688})).name="ambient_light",t.add(e),(e=a.createDirectionalLight({color:16777215,intensity:.225})).position.set(26,10,30),e.name="back_light",t.add(e),(e=a.createDirectionalLight({color:16777215,intensity:.375})).position.set(-20,-10,0),e.name="key_light",t.add(e),(e=a.createDirectionalLight({color:16777215,intensity:.75})).position.set(30,30,20),e.name="fill_light",t.add(e),t},a.createSunsetLights=function(){var e,t=new THREE.Object3D;return t.name="sunsetLights",(e=a.createAmbientLight({color:526344})).name="ambient_light",t.add(e),(e=a.createDirectionalLight({color:1644912,intensity:1})).name="midnightblue_light",e.position.set(50,10,0),t.add(e),(e=a.createDirectionalLight({color:9109504,intensity:1.5})).name="darkred_light",e.position.set(0,10,0),t.add(e),t},a.createThreeSpotLights=function(e,t){t=t||{},e=void 0!==e?e:100;var r=new THREE.Object3D;r.name="threeSpotLights";var n=2*Math.PI,o=Math.PI/3,i=Math.PI/6,s=Math.cos(i),l=Math.sin(i),c=.6*e,f=a.createSpotLight();f.position.set(0,c,e),r.add(f),t.target&&(f.target=t.target),!0===t.rotate&&(f.update=function(t,r){var a=.1*r%n;f.position.x=e*Math.sin(a),f.position.z=e*Math.cos(a)});var d=a.createSpotLight();d.position.set(-e*s,c,-e*l),r.add(d),t.target&&(d.target=t.target),!0===t.rotate&&(d.update=function(t,r){var a=.1*r%n;d.position.x=e*-Math.sin(a+o),d.position.z=e*-Math.cos(a+o)});var u=a.createSpotLight();return u.position.set(e*s,c,-e*l),r.add(u),t.target&&(u.target=t.target),!0===t.rotate&&(u.update=function(t,r){var a=.1*r%n;u.position.x=e*Math.cos(a+i),u.position.z=e*-Math.sin(a+i)}),r};var m=r(0);a.loadJSON=function(e){function t(t,r){var n,o=new THREE.LegacyJSONLoader(e.manager).parse(t,r),i=o.geometry;if(i instanceof THREE.Geometry&&(i.morphTargets.length>0||i.skinIndices.length>0)){i=a.toNonIndexedBufferGeometry(o.geometry);var s=o.geometry.animations;s&&(i.animations=s)}var l=o.materials;if(function(e,t){var r=THREE.NoColors;if(e instanceof THREE.Geometry){var n=!1,a=!1;e.faces[0].vertexColors.length>0&&(n=!0),e.faces[0].color.equals(new THREE.Color)||(a=!0),r=n?THREE.VertexColors:a?THREE.FaceColors:THREE.NoColors}else e.attributes.color&&(r=THREE.VertexColors);t.forEach((function(e){e.vertexColors=r}))}(i,l),i instanceof THREE.BufferGeometry&&i.attributes.skinIndex){n=new THREE.SkinnedMesh(i,l);for(var c=[],f=t.bones,d=0,u=f.length;d<u;d++){var p=(new THREE.Vector3).fromArray(f[d].pos),h=(new THREE.Quaternion).fromArray(f[d].rotq),v=new THREE.Bone;v.position.copy(p),v.quaternion.copy(h),v.name=f[d].name,c.push(v)}var m=new THREE.Skeleton(c);n.bind(m)}else n=new THREE.Mesh(i,l);return i.animations&&(l.forEach((function(e){e.morphTargets=!0})),i.animations.length>0&&(n.animations=i.animations)),n.castShadow=!0,n.receiveShadow=!0,n.name=e.url,n}function r(r,n){var o;switch(void 0===r.metadata&&(r.metadata={type:"Geometry"}),void 0===r.metadata.type&&(r.metadata.type="Geometry"),void 0!==r.metadata.formatVersion&&(r.metadata.version=r.metadata.formatVersion),r.metadata.type.toLowerCase()){case"buffergeometry":o=function(t){var r=new THREE.BufferGeometryLoader(e.manager).parse(t);return mesh=new THREE.Mesh(r),mesh.castShadow=!0,mesh.receiveShadow=!0,mesh.name=e.url,mesh}(r);break;case"geometry":o=t(r,n);break;case"object":o=function(t,r){var n=new THREE.ObjectLoader(e.manager);n.setPath(r),n.setResourcePath(r);var o=n.parse(t);if(o instanceof THREE.Scene)a.appWorks.setScene(o),o.name=e.url;else{if("natureObject"===o.name){var i=new THREE.Object3D;o.children.forEach((function(t){if(void 0!==e.resourcePath){var r=t.userData.options.textureFiles;void 0!==r&&r.forEach((t,n)=>{r[n]=e.resourcePath+t})}i.add(a.cloneObject(t))})),o=i}o.castShadow=!0,o.receiveShadow=!0,o.name=e.url}return o}(r,n)}e.callback&&e.callback(o)}var n=e.basePath||"models/json/";new THREE.FileLoader(e.manager).load(e.url,(function(e){r(JSON.parse(e),n)}))},a.loadOBJ=function(e){var t=e.obj||null,r=e.mtl||null,n=e.basePath||"";function a(t,r,n){var a=new THREE.OBJLoader(e.manager);a.setPath(t),n&&a.setMaterials(n),a.load(r,(function(n){n.traverse((function(e){e instanceof THREE.Mesh&&(e.castShadow=!0,e.receiveShadow=!0)})),n.name=t+r,e.callback&&e.callback(n)}),(function(e){if(e.lengthComputable){var t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% loaded")}}),(function(e){console.log("OBJLoader: error happened")}))}if(r){var o=new THREE.MTLLoader(e.manager);o.setPath(n),o.load(r,(function(e){e.preload(),a(n,t,e)}))}else a(n,t)},a.loadSTL=function(e){new THREE.STLLoader(e.manager).load(e.url,(function(t){!function(t){var r;a.computeVertexNormals(t),r=t.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial;var n=new THREE.Mesh(t,r);n.castShadow=!0,n.receiveShadow=!0,n.name=e.url,e.callback&&e.callback(n)}(t)}))},a.loadPLY=function(e){new THREE.PLYLoader(e.manager).load(e.url,(function(t){!function(t){a.computeVertexNormals(t);var r=new THREE.Mesh(t,new THREE.MeshStandardMaterial);r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(t)}))},a.loadDAE=function(e){new THREE.ColladaLoader(e.manager).load(e.url,(function(t){!function(t){var r=t.scene;t.animations.length>0&&(r.animations=t.animations),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(t)}))},a.loadGLB=function(e){var t=new THREE.GLTFLoader(e.manager);t.setCrossOrigin("anonymous");var r=new THREE.DRACOLoader(e.manager);r.setDecoderPath("js/draco/"),t.setDRACOLoader(r),t.load(e.url,(function(t){!function(t){var r=t.scene||t.scenes[0],n=t.animations||[],o=a.appWorks.scene.background;o&&o.isCubeTexture&&r.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=o,t.needsUpdate=!0)})),n.length>0&&(r.animations=n),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(t)}),void 0,(function(e){console.error(e)}))},a.loadGLTF=function(e){new THREE.GLTFLoader(e.manager).load(e.url,(function(t){!function(t){var r=t.scene||t.scenes[0],n=t.animations||[],o=a.appWorks.scene.background;o&&o.isCubeTexture&&r.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=o,t.needsUpdate=!0)})),n.length>0&&(r.animations=n),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(t)}),void 0,(function(e){console.error(e)}))},a.loadAMF=function(e){new THREE.AMFLoader(e.manager).load(e.url,(function(t){!function(t){t.castShadow=!0,t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},a.load3MF=function(e){var t=new THREE.ThreeMFLoader(e.manager);t.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension),t.load(e.url,(function(t){!function(t){t.castShadow=!0,t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},a.loadWRL=function(e){new THREE.VRMLLoader(e.manager).load(e.url,(function(t){!function(t){t.traverse((function(e){e instanceof THREE.Mesh&&(e.material.map?(e.material.color.setHex(16777215),e.material.vertexColors=THREE.NoColors):e.geometry.attributes.color&&(e.material.vertexColors=THREE.VertexColors,e.material.color.setHex(16777215)))})),t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},a.loadFBX=function(e){new THREE.FBXLoader(e.manager).load(e.url,(function(t){!function(t){var r=t;r.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(t)}))},a.loadMedical=function(e){var t=new a.MedicalLoader,r=e.basePath||"";t.setPath(r),t.load(e.url,(function(t){!function(t){let r=new a.MedicalVolume(t);Array.isArray(e.url)&&e.url.length>0?r.name=e.url[0]:r.name="medicalVolume";let n=new a.LookupTables;n.lut="default",r.lutTexture=n.texture,r.lut=!0;let o=t.worldCenter();a.appWorks.camera.lookAt(o),a.appWorks.controls.target.copy(o),e.callback&&e.callback(r)}(t)}))},a.loadFiles=function(e){var t=e.url;if(void 0!==t){var r=t.split(".").pop().toLowerCase();switch(r){case"js":case"json":a.loadJSON(e);break;case"obj":var n=e.acrossDomain||!1,o=t.split("/").pop(),i=o.replace(r,"mtl"),s=t.replace(o,"");a.fileExist(s+i,t=>{a.loadOBJ({obj:o,mtl:t?i:null,basePath:s,callback:e.callback})},n);break;case"stl":a.loadSTL(e);break;case"ply":a.loadPLY(e);break;case"dae":a.loadDAE(e);break;case"glb":a.loadGLB(e);break;case"gltf":a.loadGLTF(e);break;case"amf":a.loadAMF(e);break;case"3mf":a.load3MF(e);break;case"wrl":a.loadWRL(e);break;case"fbx":a.loadFBX(e);break;default:e.callback&&e.callback(null)}}else alert("There is no url to the file.")},a.Loader=function(){var e=this;function t(e,t){t.length>0&&(e.animations=t)}function r(e){a.add(e),a.welcomeObject(e)}function n(t){switch(void 0===t.metadata&&(t.metadata={type:"Geometry"}),void 0===t.metadata.type&&(t.metadata.type="Geometry"),void 0!==t.metadata.formatVersion&&(t.metadata.version=t.metadata.formatVersion),t.metadata.type.toLowerCase()){case"buffergeometry":var n=(o=new THREE.BufferGeometryLoader).parse(t);r(new THREE.Mesh(n));break;case"geometry":console.error('Loader: "Geometry" is no longer supported.');break;case"object":var o;(o=new THREE.ObjectLoader).setResourcePath(e.texturePath),o.parse(t,(function(e){var t;e.isScene?(t=e,a.appWorks.setScene(t)):"natureObject"===e.name?e.children.forEach((function(e){a.add(a.cloneObject(e))})):r(e)}));break;case"app":a.appWorks.fromJSON(t)}}this.texturePath="",this.loadItemList=function(t){a.LoaderUtils.getFilesFromItemList(t,(function(t,r){e.loadFiles(t,r)}))},this.loadFiles=function(t,r){if(t.length>0){r=r||a.LoaderUtils.createFilesMap(t);var n=new THREE.LoadingManager;n.onStart=()=>{a.createProgressbar()},n.onProgress=(e,t,r)=>{a.updateProgressbar(t,r)},n.onLoad=()=>{a.hideProgressbar()},n.onError=e=>{a.errorProgressbar("There was an error loading "+e)},n.setURLModifier((function(e){var t=r[e];return t?(console.log("Loading",e),URL.createObjectURL(t)):e}));for(var o=0;o<t.length;o++)e.loadFile(t[o],n)}},this.loadFile=function(e,o){var i=e.name,s=i.split(".").pop().toLowerCase(),l=new FileReader;switch(l.addEventListener("progress",(function(e){var t="("+Math.floor(e.total/1e3).format()+" KB)",r=Math.floor(e.loaded/e.total*100)+"%";console.log("Loading",i,t,r)})),s){case"3ds":l.addEventListener("load",(function(e){var t=new THREE.TDSLoader(o).parse(e.target.result);t.name=i,r(t)}),!1),l.readAsArrayBuffer(e);break;case"3mf":l.addEventListener("load",(function(e){var t=new THREE.ThreeMFLoader;t.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension);var n=t.parse(e.target.result);n.name=i,r(n)}),!1),l.readAsArrayBuffer(e);break;case"amf":l.addEventListener("load",(function(e){var t=(new THREE.AMFLoader).parse(e.target.result);t.name=i,r(t)}),!1),l.readAsArrayBuffer(e);break;case"dae":l.addEventListener("load",(function(e){var n=e.target.result,a=new THREE.ColladaLoader(o).parse(n);a.scene.name=i,t(a.scene,a.animations),r(a.scene)}),!1),l.readAsText(e);break;case"drc":l.addEventListener("load",(function(e){var t=e.target.result,n=new THREE.DRACOLoader;n.setDecoderPath("js/draco/"),n.decodeDracoFile(t,(function(e){e.center(),a.computeVertexNormals(e);var t=new THREE.MeshStandardMaterial,n=new THREE.Mesh(e,t);n.name=i,r(n)}))}),!1),l.readAsArrayBuffer(e);break;case"fbx":l.addEventListener("load",(function(e){var n=e.target.result,a=new THREE.FBXLoader(o).parse(n);a.name=i,t(a,a.animations),r(a)}),!1),l.readAsArrayBuffer(e);break;case"glb":l.addEventListener("load",(function(e){var n=e.target.result,a=new THREE.DRACOLoader;a.setDecoderPath("js/draco/");var o=new THREE.GLTFLoader;o.setDRACOLoader(a),o.parse(n,"",(function(e){var n=e.scene;n.name=i,t(n,e.animations),r(n)}))}),!1),l.readAsArrayBuffer(e);break;case"gltf":l.addEventListener("load",(function(e){var n,a=e.target.result;!function(e){var t;if("string"==typeof e)t=e;else{if("glTF"===THREE.LoaderUtils.decodeText(new Uint8Array(e,0,4)))return new DataView(e).getUint32(4,!0)<2;t=THREE.LoaderUtils.decodeText(new Uint8Array(e))}var r=JSON.parse(t);return null!=r.asset&&r.asset.version[0]<2}(a)?n=new THREE.GLTFLoader(o):alert("Import of glTF asset not possible. Only versions >= 2.0 are supported. Please try to upgrade the file to glTF 2.0 using glTF-Pipeline."),n.parse(a,"",(function(e){var n=e.scene;n.name=i,t(n,e.animations),r(n)}))}),!1),l.readAsArrayBuffer(e);break;case"js":case"json":case"3geo":case"3mat":case"3obj":case"3scn":l.addEventListener("load",(function(e){var t,r=e.target.result;if(-1!==r.indexOf("postMessage")){var a=new Blob([r],{type:"text/javascript"}),o=URL.createObjectURL(a),i=new Worker(o);return i.onmessage=function(e){e.data.metadata={version:2},n(e.data)},void i.postMessage(Date.now())}try{t=JSON.parse(r)}catch(e){return void alert(e)}n(t)}),!1),l.readAsText(e);break;case"kmz":l.addEventListener("load",(function(e){var t=(new THREE.KMZLoader).parse(e.target.result);t.scene.name=i,r(t.scene)}),!1),l.readAsArrayBuffer(e);break;case"md2":l.addEventListener("load",(function(e){var n=e.target.result,a=(new THREE.MD2Loader).parse(n),o=new THREE.MeshStandardMaterial({morphTargets:!0,morphNormals:!0}),s=new THREE.Mesh(a,o);s.mixer=new THREE.AnimationMixer(s),s.name=i,t(s,a.animations),r(s)}),!1),l.readAsArrayBuffer(e);break;case"obj":l.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.OBJLoader).parse(t);n.name=i,r(n)}),!1),l.readAsText(e);break;case"ply":l.addEventListener("load",(function(t){var n=t.target.result,o=(new THREE.PLYLoader).parse(n);o.sourceType="ply",o.sourceFile=e.name,a.computeVertexNormals(o);var s=new THREE.MeshStandardMaterial,l=new THREE.Mesh(o,s);l.name=i,r(l)}),!1),l.readAsArrayBuffer(e);break;case"stl":l.addEventListener("load",(function(t){var n,o=t.target.result,s=(new THREE.STLLoader).parse(o);s.sourceType="stl",s.sourceFile=e.name,a.computeVertexNormals(s),n=s.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial;var l=new THREE.Mesh(s,n);l.name=i,r(l)}),!1),void 0!==l.readAsBinaryString?l.readAsBinaryString(e):l.readAsArrayBuffer(e);break;case"svg":l.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.SVGLoader).parse(t).paths,a=new THREE.Group;a.scale.multiplyScalar(.1),a.scale.y*=-1;for(var o=0;o<n.length;o++)for(var s=n[o],l=new THREE.MeshBasicMaterial({color:s.color,depthWrite:!1}),c=s.toShapes(!0),f=0;f<c.length;f++){var d=c[f],u=new THREE.ShapeBufferGeometry(d),p=new THREE.Mesh(u,l);a.add(p)}a.name=i,r(a)}),!1),l.readAsText(e);break;case"vtk":l.addEventListener("load",(function(t){var n=t.target.result,o=(new THREE.VTKLoader).parse(n);o.sourceType="vtk",o.sourceFile=e.name,a.computeVertexNormals(o);var s=new THREE.MeshStandardMaterial,l=new THREE.Mesh(o,s);l.name=i,r(l)}),!1),l.readAsText(e);break;case"wrl":l.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.VRMLLoader).parse(t);n.traverse((function(e){e.isMesh&&(e.material.map?(e.material.color.setHex(16777215),e.material.vertexColors=THREE.NoColors):e.geometry.attributes.color&&(e.material.vertexColors=THREE.VertexColors,e.material.color.setHex(16777215)))})),n.name=i,r(n)}),!1),l.readAsText(e);break;case"zip":l.addEventListener("load",(function(e){!function(e){var n=new m(e);if(n.files["model.obj"]&&n.files["materials.mtl"]){var o=(new THREE.MTLLoader).parse(n.file("materials.mtl").asText());r((new THREE.OBJLoader).setMaterials(o).parse(n.file("model.obj").asText()))}n.filter((function(e,o){var i=new THREE.LoadingManager;switch(i.onStart=()=>{a.createProgressbar()},i.onProgress=(e,t,r)=>{a.updateProgressbar(t,r)},i.onLoad=()=>{a.hideProgressbar()},i.onError=e=>{a.errorProgressbar("There was an error loading "+e)},i.setURLModifier((function(e){var t=n.files[e];if(t){console.log("Loading",e);var r=new Blob([t.asArrayBuffer()],{type:"application/octet-stream"});return URL.createObjectURL(r)}return e})),o.name.split(".").pop().toLowerCase()){case"fbx":r(new THREE.FBXLoader(i).parse(o.asArrayBuffer()));break;case"glb":(new THREE.GLTFLoader).parse(o.asArrayBuffer(),"",(function(e){var n=e.scene;t(n,e.animations),r(n)}));break;case"gltf":new THREE.GLTFLoader(i).parse(o.asText(),"",(function(e){var n=e.scene;t(n,e.animations),r(n)}))}}))}(e.target.result)}),!1),l.readAsBinaryString(e)}}},a.LoaderUtils={createFilesMap:function(e){for(var t={},r=0;r<e.length;r++){var n=e[r];t[n.name]=n}return t},getFilesFromItemList:function(e,t){var r=0,n=0,a=[],o={};function i(){++r===n&&t(a,o)}function s(e){if(e){if(e.isDirectory)e.createReader().readEntries((function(e){for(var t=0;t<e.length;t++)s(e[t]);i()}));else e.isFile&&e.file((function(t){a.push(t),o[e.fullPath.substr(1)]=t,i()}));n++}}for(var l=0;l<e.length;l++)s(e[l].webkitGetAsEntry())}},a.Loader2=function(){var e=this;this.fromFiles=function(e,t){if(e[0].name.match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i))return void this._loadMedicalFiles(t);const r=new Map;e.forEach(e=>r.set(e.name,e)),this.loadFiles(r)},this.fromEvent=function(t){if(t.dataTransfer.files[0].name.match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i))return void this._loadMedicalFiles(t);let r;if(t.dataTransfer.items)r=[].slice.call(t.dataTransfer.items).map(e=>e.webkitGetAsEntry());else if(1===(t.dataTransfer.files||[]).length){const e=t.dataTransfer.files[0];return"application/zip"===e.type?void alert("zip file: not supported"):void this.loadFiles(new Map([[e.name,e]]))}r||alert("Required drag & drop is not supported in this browser."),1===r.length&&r[0].name.match(/\.zip$/)?alert("zip file: not supported"):function t(r,n){const a=n.pop();if(!a)return void e.loadFiles(r);if(a.isFile)a.file(e=>{r.set(a.fullPath,e),t(r,n)},()=>console.error("Could not load file: %s",a.fullPath));else if(a.isDirectory){const e=a.createReader(),o=a=>{a.length?(n=n.concat(a),e.readEntries(o)):t(r,n)};e.readEntries(o)}else console.warn("Unknown asset type: "+a.fullPath),t(r,n)}(new Map,r)},this.loadFiles=function(t){for(var r of t.values())console.log("Loading:",r.name,"("+a.humanFileSize(r.size)+")");var n;let o,i;var s=[];Array.from(t).forEach(([e,t])=>{t.name.match(/\.(js|json|obj|stl|ply|dae|gltf|glb|amf|3mf|wrl|fbx|md2|vtk)$/i)?(o=t,i=e.replace(t.name,""),n=t.name.split(".").pop().toLowerCase()):t.name.match(/\.(png|jpg|gif)$/i)&&s.push(t)}),o||console.warn("No asset found.");const l="string"==typeof o?o:URL.createObjectURL(o),c=THREE.LoaderUtils.extractUrlBase(l);return new Promise((r,f)=>{const d=[],u=new THREE.LoadingManager;switch(u.onStart=()=>{a.createProgressbar()},u.onProgress=(e,t,r)=>{a.updateProgressbar(t,r)},u.onLoad=()=>{a.hideProgressbar()},u.onError=e=>{a.errorProgressbar("There was an error loading "+e)},u.setURLModifier((e,r)=>{const n=i+e.replace(c,"").replace(/^(\.?\/)/,"");if(t.has(n)){const e=t.get(n),r=URL.createObjectURL(e);return d.push(r),r}return(r||"")+e}),n){case"js":case"json":!function(t,n){function i(e,t,r){var n,o=new THREE.LegacyJSONLoader(t).parse(e,r),i=o.geometry;if(i instanceof THREE.Geometry&&(i.morphTargets.length>0||i.skinIndices.length>0)){i=a.toNonIndexedBufferGeometry(o.geometry);var s=o.geometry.animations;s&&(i.animations=s)}var l=o.materials;if(function(e,t){var r=THREE.NoColors;if(e instanceof THREE.Geometry){var n=!1,a=!1;e.faces[0].vertexColors.length>0&&(n=!0),e.faces[0].color.equals(new THREE.Color)||(a=!0),r=n?THREE.VertexColors:a?THREE.FaceColors:THREE.NoColors}else e.attributes.color&&(r=THREE.VertexColors);t.forEach((function(e){e.vertexColors=r}))}(i,l),i instanceof THREE.BufferGeometry&&i.attributes.skinIndex){n=new THREE.SkinnedMesh(i,l);for(var c=[],f=e.bones,d=0,u=f.length;d<u;d++){var p=(new THREE.Vector3).fromArray(f[d].pos),v=(new THREE.Quaternion).fromArray(f[d].rotq),m=new THREE.Bone;m.position.copy(p),m.quaternion.copy(v),m.name=f[d].name,c.push(m)}var x=new THREE.Skeleton(c);n.bind(x)}else n=new THREE.Mesh(i,l);return i.animations&&(l.forEach((function(e){e.morphTargets=!0})),i.animations.length>0&&(n.animations=i.animations)),h(n),n}function s(e,t,r){switch(void 0===e.metadata&&(e.metadata={type:"Geometry"}),void 0===e.metadata.type&&(e.metadata.type="Geometry"),void 0!==e.metadata.formatVersion&&(e.metadata.version=e.metadata.formatVersion),e.metadata.type.toLowerCase()){case"buffergeometry":(function(e,t){var r=new THREE.BufferGeometryLoader(t).parse(e);return mesh=new THREE.Mesh(r),h(mesh),mesh})(e,t);break;case"geometry":i(e,t,r);break;case"object":(function(e,t,r){var n=new THREE.ObjectLoader(t);n.setPath(r),n.setResourcePath(r);var i=n.parse(e);return i instanceof THREE.Scene?(a.appWorks.setScene(i),i.name=o.name):"natureObject"===i.name?i.children.forEach((function(e){a.add(a.cloneObject(e))})):h(i),i})(e,t,r)}}new THREE.FileLoader(n).load(t,t=>{s(JSON.parse(t),n,e.basePath),d.forEach(URL.revokeObjectURL),r(t)},p,f)}(l,u);break;case"obj":!function(e,n){var a;for(var o of t.values())if(o.name.match(/\.(mtl|MTL)$/)){a=o;break}function i(t){var a=new THREE.OBJLoader(n);t&&a.setMaterials(t),a.load(e,e=>{h(e),d.forEach(URL.revokeObjectURL),r(e)},p,f)}!function(e){if(void 0!==e){const t=URL.createObjectURL(e);new THREE.MTLLoader(n).load(t,e=>{e.preload(),i(e),r(e)},p,f)}else i()}(a)}(l,u);break;case"stl":!function(e,t){new THREE.STLLoader(t).load(e,e=>{var t;t=e.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial,h(new THREE.Mesh(e,t)),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"ply":!function(e,t){new THREE.PLYLoader(t).load(e,e=>{a.computeVertexNormals(e),h(new THREE.Mesh(e,new THREE.MeshStandardMaterial)),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"dae":!function(e,t){new THREE.ColladaLoader(t).load(e,e=>{var t=e.scene;e.animations.length>0&&(t.animations=e.animations),h(t),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"gltf":case"glb":!function(e,t){const n=new THREE.GLTFLoader(t);n.setCrossOrigin("anonymous");const o=new THREE.DRACOLoader(t);o.setDecoderPath("js/draco/"),n.setDRACOLoader(o),n.load(e,e=>{var t=e.scene||e.scenes[0],n=e.animations||[],o=a.appWorks.scene.background;o&&o.isCubeTexture&&t.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=o,t.needsUpdate=!0)})),n.length>0&&(t.animations=n),h(t),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"amf":!function(e,t){new THREE.AMFLoader(t).load(e,e=>{h(e),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"3mf":!function(e,t){var n=new THREE.ThreeMFLoader(t);n.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension),n.load(e,e=>{h(e),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"wrl":!function(e,t){new THREE.VRMLLoader(t).load(e,e=>{e.traverse((function(e){e instanceof THREE.Mesh&&(e.material.map?(e.material.color.setHex(16777215),e.material.vertexColors=THREE.NoColors):e.geometry.attributes.color&&(e.material.vertexColors=THREE.VertexColors,e.material.color.setHex(16777215)))})),h(e),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"fbx":!function(e,t){new THREE.FBXLoader(t).load(e,e=>{e.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),h(e),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"md2":!function(e,t){new THREE.MD2Loader(t).load(e,e=>{var t=null;1===s.length&&(t=(new THREE.TextureLoader).load(URL.createObjectURL(s[0])));var n,a,o=new THREE.MeshStandardMaterial({map:t,morphTargets:!0,morphNormals:!0}),i=new THREE.Mesh(e,o);i.mixer=new THREE.AnimationMixer(i),n=i,(a=e.animations).length>0&&(n.animations=a),h(i),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;case"vtk":!function(e,t){new THREE.VTKLoader(t).load(e,e=>{e.center(),a.computeVertexNormals(e);var t=new THREE.MeshStandardMaterial;h(new THREE.Mesh(e,t)),d.forEach(URL.revokeObjectURL),r(e)},p,f)}(l,u);break;default:r(null)}function p(e){if(e.lengthComputable){var t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% loaded")}}function h(e){e.name=o.name,a.add(e),a.welcomeObject(e)}})},this._loadMedicalFiles=function(e){a.MedicalLoadFiles(e,e=>{a.removeMedicalWorkspace(),a.createMedicalWorkspace(e,"quadWorkspace")})}},a.Saver=function(){var e=document.createElement("a");this.saveFile=function(t){var r,n=t.split(".").pop().toLowerCase();switch("NatureWorks"===appWorks.appName?((r=new THREE.Object3D).name="natureObject",appWorks.scene.children.forEach((function(e){r.add(a.cloneObject(e))}))):r=appWorks.scene,n){case"json":!function(e,t){t=t||"object.json";var r=e.toJSON();try{r=(r=JSON.stringify(r,o,"\t")).replace(/[\n\t]+([\d\.e\-\[\]]+)/g,"$1")}catch(e){r=JSON.stringify(r)}i(r,t)}(r,t);break;case"obj":!function(e,t){t=t||"model.obj";i((new THREE.OBJExporter).parse(e),t)}(r,t);break;case"dae":!function(e,t){t=t||"scene.dae";(new THREE.ColladaExporter).parse(e,(function(e){i(e.data,t)}))}(r,t);break;case"glb":!function(e,t){t=t||"scene.glb";(new THREE.GLTFExporter).parse(e,(function(e){s(e,t)}),{binary:!0,forceIndices:!0,forcePowerOfTwoTextures:!0})}(r,t);break;case"gltf":!function(e,t){t=t||"scene.gltf";(new THREE.GLTFExporter).parse(e,(function(e){i(JSON.stringify(e,null,2),t)}))}(r,t);break;case"stl":!function(e,t,r){t=t||"model.stl";var n=new THREE.STLExporter;!0===r?i(n.parse(e),t):s(n.parse(e,{binary:!0}),t)}(r,t);break;case"ply":!function(e,t){t=t||"model.ply";i((new THREE.PLYExporter).parse(e),t)}(r,t);break;default:alert('The file type "'+n+'" is not supported.')}function o(e,t){return"number"==typeof t?parseFloat(t.toFixed(6)):t}function i(e,t){l(new Blob([e],{type:"text/plain"}),t)}function s(e,t){l(new Blob([e],{type:"application/octet-stream"}),t)}function l(t,r){e.href=URL.createObjectURL(t),e.download=r||"data.json",e.dispatchEvent(new MouseEvent("click"))}}},a.FileExplorer=function(e){e=e||a.appWorks;var t=this;this.basePath="models/",this.openFile=function(){this.fileInput.click()},this.saveAsFile=function(e){this.fileOutput.fileExtension=e,this.fileOutput.click()},this.saver=new a.Saver,this.fileOutput=document.createElement("div"),this.fileOutput.addEventListener("click",(function(){var e=t.fileOutput.fileExtension;t.saver.saveFile("model."+e)})),this.loader=new a.Loader,this.loader2=new a.Loader2;var r=document.createElement("input");r.type="file",r.multiple=!0,r.style.display="none",this.fileInput=r,r.addEventListener("change",(function(e){for(var n,a=[].slice.call(r.files),o=0;o<a.length;o++)if((n=a[o].name).match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i)||n.match(/\.(obj|mtl|md2|vtk)$/i))return void t.loader2.fromFiles(a,e);t.loader.loadFiles(r.files)}));var n=e.dom;n.addEventListener("dragover",(function(e){e.preventDefault(),e.stopPropagation(),n.classList.add("dragover")})),n.addEventListener("dragleave",(function(e){e.preventDefault(),e.stopPropagation(),n.classList.remove("dragover")})),n.addEventListener("drop",(function(e){if(e.preventDefault(),"text/plain"!==e.dataTransfer.types[0]){for(var r,n=e.dataTransfer.files,a=0;a<n.length;a++)if((r=n[a].name).match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i)||r.match(/\.(obj|mtl|md2|vtk)$/i))return void t.loader2.fromEvent(e);e.dataTransfer.items?t.loader.loadItemList(e.dataTransfer.items):t.loader.loadFiles(e.dataTransfer.files)}}),!1)},a.HGTLoader=function(){this.loadTile=function(e,t,r){var n=this,o=new THREE.TextureLoader;o.crossOrigin=!0;o.load("https://maps.googleapis.com/maps/api/staticmap?center="+e+","+t+"&zoom="+r+"&size=512x512&scale=2&maptype=satellite&key=AIzaSyA1qxvvl1sFBFLj5rx4cXHJ_1soxQ_GMpw",(function(o){var i=new THREE.PlaneBufferGeometry(20,20,128,128),s=new THREE.MeshPhongMaterial({map:o,shading:THREE.SmoothShading});n.heightMapping(i,e,t,r);var l=new THREE.Mesh(i,s);l.rotation.x=-Math.PI/2,l.frustumCulled=!1,l.castShadow=!1,l.receiveShadow=!0,l.name="SRTM.hgt",a.add(l)}))},this.heightMapping=function(e,t,r,n){var a=e.attributes.position,o=Math.sqrt(a.count),i=a.array,s=20/(Math.abs(40075160*Math.cos(t*(Math.PI/180)))/Math.pow(2,n-1)),l=360/Math.pow(2,n-1),c=Math.abs(360*Math.cos(t*(Math.PI/180))/Math.pow(2,n-1)),f=t-c/2,d=t+c/2;console.log(f);var u=r-l/2,p=r+l/2;console.log(l),console.log(c);var h=Math.abs(Math.floor(1201*l)),v=Math.abs(Math.floor(1201*c));console.log(h,v);var m=o/h,x=o/v;console.log(x,m);var g,y,E=1200-Math.abs(1200*(d-Math.floor(d))),w=Math.abs(1200*(u-Math.floor(u))),b=1200-Math.abs(1200*(f-Math.floor(f))),T=Math.abs(1200*(p-Math.floor(p)));console.log(E,w);for(var _=Math.floor(d);_>=Math.floor(f);_--)for(var S=Math.floor(u);S<=Math.floor(p);S++){g=_>0?"N"+Math.abs(Math.floor(_)):"S"+Math.abs(Math.floor(_)),y=S>0?S<100?"E0"+Math.abs(Math.floor(S)):"E"+Math.abs(Math.floor(S)):S>=-99?"W0"+Math.abs(Math.floor(S)):"W"+Math.abs(Math.floor(S));var R=0,A=0,M=1200,C=1200;_==Math.floor(f)&&(M=b),_==Math.floor(d)&&(R=E),S==Math.floor(u)&&(A=w),S==Math.floor(p)&&(C=T);var L=Math.floor(d)-_,H=S-Math.floor(u),P=0;L>0&&(P=1201-E+1201*(L-1));var z=0;H>0&&(z=1201-w+1201*(H-1));var k=new XMLHttpRequest;k.start_row=R,k.start_column=A,k.end_row=M,k.end_column=C,k.passed_rows=P,k.passed_columns=z;var N=Math.round(P/v*o),D=Math.round((P+M-R)/v*o);D=Math.min(D,500);var F=Math.round(z/h*o),I=Math.round((z+C-A)/h*o);I=Math.min(I,500),k.filename="models/hgt/"+g+y+".hgt",k.start_i=N,k.end_i=D,k.start_j=F,k.end_j=I,k.open("GET","models/hgt/"+g+y+".hgt",!0),k.responseType="arraybuffer",k.onload=function(t){var r=this.response;if(2884802==r.byteLength){new Int16Array(r);var n=new DataView(r),l=0,c=0;console.log(this.filename),console.log(this.start_row,this.start_column),console.log("Vertex rows:",this.start_i,this.end_i),console.log("Vertex columns:",this.start_j,this.end_j),console.log("Passed rows/columns:",this.passed_rows,this.passed_columns);for(var f=this.start_i;f<=this.end_i;f++){l=f/x;for(var d=this.start_j;d<=this.end_j;d++){c=d/m;var u=0,p=0;l>=this.passed_rows&&(u=(E+l)%1201),c>=this.passed_columns&&(p=(w+c)%1201),p=Math.min(1200,p),u=Math.min(1200,u);var h,v,g,y,b=p-Math.round(p),T=u-Math.round(u);u=Math.round(u),p=Math.round(p),f==this.start_i&&console.log("Start vertex row "+this.start_i+" at file row "+u),d==this.start_j&&console.log("Start vertex column "+this.start_j+" at file column "+p),f==this.end_i&&console.log("End vertex row "+this.end_i+" at file row "+u),d==this.end_j&&console.log("End vertex column "+this.end_j+" at file column "+p),h=Math.floor(1201*u+p),v=p<1200?Math.floor(1201*u+p+1):Math.floor(1201*u+p),g=u<1200?Math.floor(1201*(u+1)+p):Math.floor(1201*u+p),y=u<1200&&p<1200?Math.floor(1201*(u+1)+p+1):Math.floor(1201*u+p);var _=n.getInt16(2*h,!1),S=n.getInt16(2*v,!1),R=(1-b)*(1-T)*_+(1-b)*T*n.getInt16(2*g,!1)+b*(1-T)*S+b*T*n.getInt16(2*y,!1);i[3*(f*o+d)+2]=R*s}}a.needsUpdate=!0,e.computeVertexNormals()}},k.send(null)}}},a.shaders={vs:{},fs:{},ss:{}},a.shaders.vs.curlVS=r(95),a.shaders.fs.curlFS=r(96),a.shaders.ss.curlSS=r(97),a.shaders.vs.quadVS=r(98),a.shaders.fs.iceFS=r(99),a.shaders.fs.boxesFS=r(100),a.shaders.fs.spheresFS=r(101),a.shaders.fs.spoutFS=r(102),a.shaders.fs.mountainsFS=r(103),a.shaders.fs.terrain2FS=r(104),a.shaders.fs.terrainFS=r(105),a.shaders.fs.canyonFS=r(106),a.shaders.fs.cavesFS=r(107),a.shaders.fs.tunnelFS=r(108),a.shaders.fs.seaFS=r(109),a.shaders.fs.pbrFS=r(110),a.shaders.fs.galaxyFS=r(111),a.shaders.fs.weatherFS=r(112),a.shaders.fs.riverFS=r(113),a.shaders.fs.forestFS=r(114),a.shaders.fs.fishFS=r(115),a.Raymarch=function(e,t){void 0!==arguments[0]&&arguments[0].isObject3D?this.fromObject(arguments[0]):this.create(e,t),this.userData.type="Raymarch"},a.Raymarch.prototype=Object.create(THREE.Mesh.prototype),a.Raymarch.prototype.constructor=a.Raymarch,a.Raymarch.prototype.isRaymarch=!0,a.Raymarch.prototype.create=function(e,t){t=void 0!==t?t:{},e=void 0!==e?e:"spheresFS";this.size=new THREE.Vector2,a.appWorks.renderer.getSize(this.size);var r=a.shaders,n={devicePixelRatio:{value:window.devicePixelRatio},time:{value:0},resolution:{value:new THREE.Vector2(this.size.x,this.size.y)},cameraNear:{value:a.appWorks.camera.near},cameraFar:{value:a.appWorks.camera.far},cameraWorldMatrix:{value:a.appWorks.camera.matrixWorld},cameraProjectionMatrixInverse:{value:a.appWorks.camera.projectionMatrixInverse},textureMaps:{value:[]}};if("pbrFS"===e){var o={envMap:{value:null},ambientLightColor:{value:new THREE.Color},directionalLights:{value:[]},pointLights:{value:[]},spotLights:{value:[]},hemisphereLights:{value:[]},useAlbedoMaps:{value:[]},useMetalnessMaps:{value:[]},useRoughnessMaps:{value:[]},albedoMaps:{value:[]},metalnessMaps:{value:[]},roughnessMaps:{value:[]},albedos:{value:[]},metalnesss:{value:[]},roughnesss:{value:[]}};n=THREE.UniformsUtils.merge([n,o])}if(a.isWebGL1()){var i=["#define gl_FragDepth gl_FragDepthEXT","#define texture texture2D","#define textureProj texture2DProj","#define textureLod texture2DLodEXT","#define textureProjLod texture2DProjLodEXT","#define textureGrad texture2DGradEXT","#define textureProjGrad texture2DProjGradEXT","#define textureGrad texture2DGradEXT"].join("\n"),s="";a.isDeviceMobile()&&(s=["highp float glFragDepth;","#define gl_FragDepthEXT glFragDepth"].join("\n"));var l=r.vs.quadVS,c=i+"\n"+s+"\n"+r.fs[e]}else if(a.isWebGL2())l=r.vs.quadVS,c=r.fs[e];var f=new THREE.PlaneBufferGeometry(2,2),d=new THREE.ShaderMaterial({defines:{},uniforms:n,vertexShader:l,fragmentShader:c}),u=(n=d.uniforms,new THREE.TextureLoader);if(t.textureFiles&&t.textureFiles.length>0&&t.textureFiles.forEach((function(e){var t=u.load(e,e=>{e.wrapS=e.wrapT=THREE.RepeatWrapping});n.textureMaps.value.push(t)})),"pbrFS"===e){n.envMap.value=a.appWorks.scene.background;var p=a.WORLD_SIZE;a.appWorks.scene.traverse((function(e){if(e instanceof THREE.AmbientLight)(t={}).color=e.color.clone().multiplyScalar(e.intensity),n.ambientLightColor.value.copy(t.color);else if(e instanceof THREE.DirectionalLight){(t={}).direction=e.position.clone().normalize(),t.color=e.color.clone().multiplyScalar(e.intensity),n.directionalLights.value.push(t)}else if(e instanceof THREE.PointLight){(t={}).position=e.position.clone(),t.color=e.color.clone().multiplyScalar(e.intensity),t.distance=0===e.distance?p:e.distance,t.decay=e.decay,n.pointLights.value.push(t)}else if(e instanceof THREE.SpotLight){(t={}).position=e.position.clone(),t.direction=e.position.clone().normalize(),t.color=e.color.clone().multiplyScalar(e.intensity),t.distance=0===e.distance?p:e.distance,t.decay=e.decay,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.penumbra),n.spotLights.value.push(t)}else if(e instanceof THREE.HemisphereLight){var t;(t={}).direction=new THREE.Vector3(0,1,0),t.skyColor=e.color.clone().multiplyScalar(e.intensity),t.groundColor=e.groundColor.clone(),n.hemisphereLights.value.push(t)}}));var h=new THREE.Color(16777215);t.albedo&&(t.albedo=[]);for(var v=4-t.albedo.length,m=0;m<v;m++)t.albedo.push(null);t.albedo&&t.albedo.forEach((function(e){if("string"==typeof e){var t=u.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));n.albedoMaps.value.push(t),n.albedos.value.push(h),n.useAlbedoMaps.value.push(1)}else n.albedoMaps.value.push(null),n.albedos.value.push(null===e?h:e),n.useAlbedoMaps.value.push(0)})),t.metalness||(t.metalness=[]);for(v=4-t.metalness.length,m=0;m<v;m++)t.metalness.push(null);t.metalness&&t.metalness.forEach((function(e){if("string"==typeof e){var t=u.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));n.metalnessMaps.value.push(t),n.metalnesss.value.push(.1),n.useMetalnessMaps.value.push(1)}else n.metalnessMaps.value.push(null),n.metalnesss.value.push(e),n.useMetalnessMaps.value.push(0)})),t.roughness||(t.roughness=[]);for(v=4-t.roughness.length,m=0;m<v;m++)t.roughness.push(null);t.roughness&&t.roughness.forEach((function(e){if("string"==typeof e){var t=u.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));n.roughnessMaps.value.push(t),n.roughnesss.value.push(.1),n.useRoughnessMaps.value.push(1)}else n.roughnessMaps.value.push(null),n.roughnesss.value.push(e),n.useRoughnessMaps.value.push(0)}))}d.extensions={derivatives:!0,fragDepth:!0,drawBuffers:!0,shaderTextureLOD:!0},THREE.Mesh.call(this,f,d),this.name="raymarch",this.frustumCulled=!1,this.userData.shaderTitle=e,this.userData.options=t},a.Raymarch.prototype.fromObject=function(e){var t=e.userData.shaderTitle,r=e.userData.options;if("pbrFS"===t&&r.albedo)for(var n=r.albedo,a=0,o=n.length;a<o;a++)"number"==typeof n[a]&&(n[a]=new THREE.Color(n[a]));this.create(t,r),this.name=e.name},a.Raymarch.prototype.toJSON=function(e){var t=this.clone();return THREE.Object3D.prototype.toJSON.call(t,e)},a.Raymarch.prototype.clone=function(){return new a.Raymarch(this)},a.Raymarch.prototype.update=function(e,t){a.appWorks.renderer.getSize(this.size);var r=this.material.uniforms;r.time.value=t,r.resolution.value.set(this.size.x,this.size.y),r.cameraNear.value=a.appWorks.camera.near,r.cameraFar.value=a.appWorks.camera.far,r.cameraWorldMatrix.value=a.appWorks.camera.matrixWorld,r.cameraProjectionMatrixInverse.value=a.appWorks.camera.projectionMatrixInverse,"pbrFS"===this.userData.shaderTitle&&(r.envMap.value=a.appWorks.scene.background)},a.Raymarch.prototype.updateVisible=function(e){a.appWorks.setValue(this,"visible",e)},a.Raymarch.prototype.raycast=function(e,t){var r=a.appWorks;if(r.renderer.extensions.get("WEBGL_depth_texture")){if(r.mouseUpPosition.equals(r.mouseDownPosition)&&r.mouseUpPosition.equals(r.mouseMovePosition)){var n=r.mouseUpPosition;this.rayIntersect(n,t)}}else alert("WEBGL_depth_texture: not supported in WebGL2...")},a.createRaymarch=function(e,t){return new a.Raymarch(e,t)},a.raymarchIce=function(){return a.appWorks.playAudio(["audio/boxesFS.mp3"]),a.createRaymarch("iceFS",{textureFiles:["images/raymarch/pebbles.jpg","images/raymarch/steel.jpg","images/raymarch/ruby.jpg","images/raymarch/frozen.jpg"]})},a.raymarchBoxes=function(){return a.appWorks.playAudio(["audio/boxesFS.mp3"]),a.createRaymarch("boxesFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},a.raymarchSpheres=function(){return a.appWorks.playAudio(["audio/spheresFS.mp3"]),a.createRaymarch("spheresFS")},a.raymarchSpout=function(){return a.createRaymarch("spoutFS",{textureFiles:["images/ground/bathroom.jpg"]})},a.raymarchTerrain=function(){return a.appWorks.playAudio(["audio/terrainFS.mp3"]),a.createRaymarch("terrainFS",{textureFiles:["images/raymarch/grayNoise256.png"]})},a.raymarchTerrain2=function(){return a.appWorks.playAudio(["audio/terrain2FS.mp3"]),a.createRaymarch("terrain2FS",{textureFiles:["images/raymarch/lichen.jpg","images/raymarch/organic1.jpg","images/raymarch/grayNoise256.png","images/raymarch/lichen.jpg"]})},a.raymarchTunnels=function(){return a.appWorks.playAudio(["audio/tunnelFS.mp3"]),a.createRaymarch("tunnelFS",{textureFiles:["images/raymarch/lichen.jpg"]})},a.raymarchPBR=function(){return a.appWorks.playAudio(["audio/pbrFS.mp3"]),a.createRaymarch("pbrFS",{albedo:["images/pbr/rustIronA.png","images/pbr/plasticA.png","images/pbr/wallA.png"],metalness:["images/pbr/rustIronM.png",null,null],roughness:["images/pbr/rustIronR.png","images/pbr/plasticR.png","images/pbr/wallR.png"]})},a.raymarchGalaxy=function(){return a.appWorks.playAudio(["audio/galaxyFS.mp3"]),a.createRaymarch("galaxyFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},a.raymarchMountains=function(){return a.appWorks.playAudio(["audio/mountainsFS.mp3"]),a.createRaymarch("mountainsFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},a.raymarchCanyon=function(){return a.appWorks.playAudio(["audio/canyonFS.mp3"]),a.createRaymarch("canyonFS",{textureFiles:["images/raymarch/organic2.jpg","images/raymarch/abstract1.jpg","images/raymarch/rgbaNoise256.png"]})},a.raymarchCaves=function(){return a.appWorks.playAudio(["audio/cavesFS.mp3"]),a.createRaymarch("cavesFS",{textureFiles:["images/raymarch/pebbles.jpg","images/raymarch/organic1.jpg"]})},a.raymarchSea=function(){return a.appWorks.playAudio(["audio/seaFS.mp3"]),a.createRaymarch("seaFS")},a.raymarchWeather=function(){return a.appWorks.playAudio(["audio/thunderRain.mp3"]),a.createRaymarch("weatherFS",{textureFiles:["images/raymarch/rgbaNoise256.png"]})},a.raymarchRiver=function(){return a.appWorks.playAudio(["audio/riverFS.mp3"]),a.createRaymarch("riverFS",{textureFiles:["images/raymarch/grayNoise256.png","images/raymarch/organic1.jpg"]})},a.raymarchForest=function(){return a.appWorks.playAudio(["audio/forestFS.mp3"]),a.createRaymarch("forestFS",{textureFiles:["images/raymarch/grayNoise256.png"]})},a.raymarchFish=function(){return a.appWorks.playAudio(["audio/fishFS.mp3"]),a.createRaymarch("fishFS",{textureFiles:["images/raymarch/organic2.jpg","images/raymarch/abstract1.jpg","images/raymarch/grayNoise256.png","images/raymarch/lichen.jpg"]})},a.createBirdBasic=function(e,t){e=e||10,t=t||4;var r=new THREE.BufferGeometry,n=.4*e,a=.6*e,o=.5*a,i=new Float32Array([0,-0,-n,0,.08*e,-n,0,0,a,0,0,-o,-t,0,0,0,0,o,0,0,o,t,0,0,0,0,-o]);r.setAttribute("position",new THREE.BufferAttribute(i,3));var s=new THREE.MeshBasicMaterial({color:16777215,side:THREE.DoubleSide}),l=new THREE.Mesh(r,s);return l.castShadow=!0,l.receiveShadow=!0,l.name="birdBasic",l},a.createEyeball=function(e){e=e||5;var t=new THREE.Mesh(new THREE.SphereBufferGeometry(e,32,16),new THREE.ShaderMaterial({uniforms:{eyeTex:{value:(new THREE.TextureLoader).load("images/eye.jpg")}},vertexShader:["varying vec3 vNormal;","void main() {","vNormal = normal;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D eyeTex;","varying vec3 vNormal;","void main() {","vec2 uv = normalize( vNormal ).xy * 0.5 + 0.5;","vec3 color = texture2D( eyeTex, uv ).rgb;","if ( vNormal.z < - 0.85 ) color = vec3( 0.777, 0.74, 0.74 ); // back of eye","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")}));return t.castShadow=!0,t.receiveShadow=!0,t.name="eyeball",t},a.createLowPolyTree=function(e,t,r){function n(e,t,r,n,a){for(var o,i,s=new THREE.Vector3,l=e[0].clone(),c=0;c<t;c++)s=e[c+(o=r*t+1)].clone(),l.y=s.y,i=s.sub(l),a?c%2==0?(i.normalize().multiplyScalar(n/6),e[c+o].add(i)):(i.normalize().multiplyScalar(n),e[c+o].add(i),e[c+o].y=e[c+o+t].y+.05):c%2!=0?(i.normalize().multiplyScalar(n/6),e[c+o].add(i)):(i.normalize().multiplyScalar(n),e[c+o].add(i),e[c+o].y=e[c+o+t].y+.05)}function o(e,t,r){for(var n,a,o=new THREE.Vector3,i=e[0].clone(),s=0;s<t;s++)o=e[s+(n=r*t+1)].clone(),i.y=o.y,(a=o.sub(i)).normalize().multiplyScalar(.06),e[s+n].sub(a)}e=e||10,t=t||.4;var i=r=r||16,s=a.randFloat(.05,.2),l=new THREE.ConeGeometry(.5,1,i,6),c=new THREE.MeshStandardMaterial({color:3407667,flatShading:!0});n(l.vertices,i,0,s),o(l.vertices,i,1),n(l.vertices,i,2,1.1*s,!0),o(l.vertices,i,3),n(l.vertices,i,4,1.2*s),o(l.vertices,i,5);var f=new THREE.Mesh(l,c);f.castShadow=!0,f.receiveShadow=!1,f.position.y=.5+t,f.rotation.y=a.randFloat(0,Math.PI);var d=t+.01,u=new THREE.CylinderGeometry(.1,.1,d),p=new THREE.MeshStandardMaterial({color:8939059,flatShading:!0}),h=new THREE.Mesh(u,p);h.position.y=d/2;var v=new THREE.Object3D;return v.add(h),v.add(f),v.scale.setScalar(e/(1+t)),v.castShadow=!0,v.receiveShadow=!1,v.name="lowPolyTree",v},a.createProcCity=function(){(i=new THREE.BoxGeometry(1,1,1)).applyMatrix((new THREE.Matrix4).makeTranslation(0,.5,0));for(var e=new THREE.Mesh(i),t=new THREE.Color(16777215),r=new THREE.Color(3158096),n=new THREE.Geometry,o=0;o<2e4;o++){e.position.x=~~a.randFloat(-1e3,1e3),e.position.z=~~a.randFloat(-1e3,1e3),e.rotation.y=Math.random()*Math.PI*2,e.scale.x=a.randFloat(2,10),e.scale.y=a.randFloat(1.5,5*e.scale.x),e.scale.z=e.scale.x;for(var i,s=1-Math.random(),l=new THREE.Color(s+.1*Math.random(),s,s+.1*Math.random()),c=l.clone().multiply(t),f=l.clone().multiply(r),d=(new THREE.Color(16711680),0),u=(i=e.geometry).faces.length;d<u;d++)0===d||1===d||8===d||9===d?i.faces[d].vertexColors=[c,c,c]:2===d||3===d||10===d||11===d?i.faces[d].vertexColors=[f,f,f]:4===d||5===d?i.faces[d].vertexColors=[l,l,l]:6!==d&&7!==d||(i.faces[d].vertexColors=[l,l,l]);n.mergeMesh(e)}var p=new THREE.Texture(function(){var e=document.createElement("canvas");e.width=32,e.height=64,(a=e.getContext("2d")).fillStyle="#ffffff",a.fillRect(0,0,32,64);for(var t=2;t<64;t+=2)for(var r=0;r<32;r+=2){var n=Math.floor(64*Math.random());a.fillStyle="rgb("+[n,n,n].join(",")+")",a.fillRect(r,t,2,1)}var a,o=document.createElement("canvas");return o.width=512,o.height=1024,(a=o.getContext("2d")).imageSmoothingEnabled=!1,a.webkitImageSmoothingEnabled=!1,a.mozImageSmoothingEnabled=!1,a.drawImage(e,0,0,o.width,o.height),o}());p.anisotropy=a.appWorks.renderer.capabilities.getMaxAnisotropy(),p.needsUpdate=!0;var h=new THREE.MeshLambertMaterial({map:p,vertexColors:THREE.VertexColors});return new THREE.Mesh(n,h)},a.createAcrylicPlane=function(e,t){var r=a.appWorks.scene.background;r instanceof THREE.Texture||(r=null);e=void 0!==e?e:100,t=void 0!==t?t:100;var n=new THREE.Object3D;n.name="planeAcryl";var o=new THREE.PlaneBufferGeometry(e,t),i=new THREE.Mesh(o,new THREE.MeshStandardMaterial({color:12632256,map:r,transparent:!0,opacity:.7}));i.position.z=0,i.receiveShadow=!0,n.add(i);var s=new THREE.Reflector(o,{clipBias:.003,textureWidth:~~(a.appWorks.width*window.devicePixelRatio),textureHeight:~~(a.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1});return s.position.z=-Math.min(.001*e,2),n.add(s),n},a.createAcrylicCircle=function(e){var t=a.appWorks.scene.background;t instanceof THREE.Texture||(t=null);e=void 0!==e?e:50;var r=new THREE.Object3D;r.name="circleAcryl";var n=new THREE.CircleBufferGeometry(e,64),o=new THREE.Mesh(n,new THREE.MeshStandardMaterial({color:12632256,map:t,transparent:!0,opacity:.7}));o.position.z=0,o.receiveShadow=!0,r.add(o);var i=new THREE.Reflector(n,{clipBias:.003,textureWidth:~~(a.appWorks.width*window.devicePixelRatio),textureHeight:~~(a.appWorks.height*window.devicePixelRatio),color:7829367});return i.position.z=-Math.min(.001*e,2),r.add(i),r},a.createMirrorPlane=function(e,t){e=void 0!==e?e:100,t=void 0!==t?t:100;var r=new THREE.PlaneBufferGeometry(e,t);return new THREE.Reflector(r,{clipBias:.003,textureWidth:~~(a.appWorks.width*window.devicePixelRatio),textureHeight:~~(a.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1})},a.createMirrorCircle=function(e){e=void 0!==e?e:50;var t=new THREE.CircleBufferGeometry(e,64);return new THREE.Reflector(t,{clipBias:.003,textureWidth:~~(a.appWorks.width*window.devicePixelRatio),textureHeight:~~(a.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1})},a.createArenaRow=function(e){for(var t=(e=e||{}).radius||.5,r=e.nCluster||30,n=e.conesPerSection||5,a=e.heightMin||.1,o=e.heightMax||.15,i=e.radiusMin||.04,s=e.radiusMax||.04,l=2*Math.PI,c=new THREE.Object3D,f=new THREE.MeshPhongMaterial({color:"teal"}),d=0;d<r;d++)for(var u=d/r*l,p=0;p<n;p++){var h=THREE.Math.randFloatSpread(2/r)*l,v=THREE.Math.randFloat(a,o),m=THREE.Math.randFloat(i,s),x=new THREE.CylinderGeometry(0,m,v),g=new THREE.Mesh(x,f);g.position.y=v/2,g.position.x=t*Math.cos(u+h),g.position.z=t*Math.sin(u+h),c.add(g)}return c},a.createViewWorks=function(e,t){return a.viewWorks=new a.GraphicWorks({appName:"ViewWorks",width:e||window.innerWidth,height:t||window.innerHeight,glVersion:2,background:(new THREE.TextureLoader).load("images/wallpaper/arctic.jpg"),controlsType:"OrbitControls",FXAAEnabled:!0,fileExplorer:!0}),a.viewWorks.renderScene(),a.viewWorks},a.createWPViewWorks=function(e,t){return a.viewWorks=new a.GraphicWorks({appName:"ViewWorks",customer:"wordpress.org",width:e||window.innerWidth,height:t||window.innerHeight,glVersion:2,background:12632256,controlsType:"OrbitControls",FXAAEnabled:!0,fileExplorer:!0}),a.viewWorks.renderScene(),a.viewWorks},a.createGameWorks=function(e,t){return a.gameWorks=new a.GraphicWorks({appName:"GameWorks",width:e||window.innerWidth,height:t||window.innerHeight,glVersion:2,hud:!0}),a.gameWorks.renderScene(),a.gameWorks},a.createNatureWorks=function(e,t){return a.natureWorks=new a.GraphicWorks({appName:"NatureWorks",width:e||window.innerWidth,height:t||window.innerHeight,signals:!0,config:!0,history:!0,glVersion:1,fog:{type:"exp2"},controlsType:"OrbitControls",stats:!0,audioFiles:void 0,gridVisible:!1,hud:!0,bleachEnabled:!1,bloomEnabled:!1,dotScreenEnabled:!1,glitchEnabled:!1,sepiaEnabled:!1,outlineEnabled:!1,FXAAEnabled:!0,ssaoEnabled:!1,godRaysEnabled:!1,bokehEnabled:!1,vignetteEnabled:!1,effectType:void 0,fileExplorer:!0,dragControls:!0,transformControls:!0}),a.natureWorks.renderScene(),a.natureWorks},a.createMedicalWorks=function(e,t){return a.medicalWorks=new a.GraphicWorks({appName:"MedicalWorks",width:e||window.innerWidth,height:t||window.innerHeight,signals:!0,glVersion:2,stats:!0,fileExplorer:!0}),a.medicalWorks.renderScene(),a.medicalWorks},a.add=function(e){a.updateMaterialMapEncoding(e,THREE.sRGBEncoding),a.appWorks.history?a.appWorks.add(e):a.appWorks.scene.add(e)},a.remove=function(e){e&&(a.appWorks.history?a.appWorks.remove(e):e.parent&&e.parent.remove(e))},a.dispose=function(e){e&&(e.parent&&e.parent.remove(e),e.traverse((function(e){var t=e.geometry;t&&t.dispose();var r=e.material;r&&(Array.isArray(r)?r:[r]).forEach((function(e){Object.keys(e).forEach(t=>{e[t]&&"function"==typeof e[t].dispose&&e[t].dispose()}),e.dispose()}))})))},window.URL=window.URL||window.webkitURL,window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,window.JAMIE=a}]);