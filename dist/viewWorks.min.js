(()=>{var __webpack_modules__={2649:(e,t,n)=>{"use strict";n.r(t);var r=n(743);!function(){class e extends THREE.Loader{constructor(e){super(e),this.availableExtensions=[]}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t=this,n=new THREE.TextureLoader(this.manager);function o(e){const t=[],n=(new DOMParser).parseFromString(e,"application/xml").querySelectorAll("Relationship");for(let e=0;e<n.length;e++){const r=n[e],o={target:r.getAttribute("Target"),id:r.getAttribute("Id"),type:r.getAttribute("Type")};t.push(o)}return t}function a(e){const t={id:e.getAttribute("id"),basematerials:[]},n=e.querySelectorAll("base");for(let e=0;e<n.length;e++){const r=c(n[e]);r.index=e,t.basematerials.push(r)}return t}function i(e){const t={id:e.getAttribute("id"),texid:e.getAttribute("texid"),displaypropertiesid:e.getAttribute("displaypropertiesid")},n=e.querySelectorAll("tex2coord"),r=[];for(let e=0;e<n.length;e++){const t=n[e],o=t.getAttribute("u"),a=t.getAttribute("v");r.push(parseFloat(o),parseFloat(a))}return t.uvs=new Float32Array(r),t}function s(e){const t={id:e.getAttribute("id"),displaypropertiesid:e.getAttribute("displaypropertiesid")},n=e.querySelectorAll("color"),r=[],o=new THREE.Color;for(let e=0;e<n.length;e++){const t=n[e].getAttribute("color");o.setStyle(t.substring(0,7)),o.convertSRGBToLinear(),r.push(o.r,o.g,o.b)}return t.colors=new Float32Array(r),t}function l(e){const t={id:e.getAttribute("id")},n=e.querySelectorAll("pbmetallic"),r=[];for(let e=0;e<n.length;e++){const t=n[e];r.push({name:t.getAttribute("name"),metallicness:parseFloat(t.getAttribute("metallicness")),roughness:parseFloat(t.getAttribute("roughness"))})}return t.data=r,t}function c(e){const t={};return t.name=e.getAttribute("name"),t.displaycolor=e.getAttribute("displaycolor"),t.displaypropertiesid=e.getAttribute("displaypropertiesid"),t}function f(e){const t={};t.objectId=e.getAttribute("objectid");const n=e.getAttribute("transform");return n&&(t.transform=u(n)),t}function u(e){const t=[];e.split(" ").forEach((function(e){t.push(parseFloat(e))}));const n=new THREE.Matrix4;return n.set(t[0],t[3],t[6],t[9],t[1],t[4],t[7],t[10],t[2],t[5],t[8],t[11],0,0,0,1),n}function d(e){const t={type:e.getAttribute("type")},n=e.getAttribute("id");n&&(t.id=n);const r=e.getAttribute("pid");r&&(t.pid=r);const o=e.getAttribute("pindex");o&&(t.pindex=o);const a=e.getAttribute("thumbnail");a&&(t.thumbnail=a);const i=e.getAttribute("partnumber");i&&(t.partnumber=i);const s=e.getAttribute("name");s&&(t.name=s);const l=e.querySelector("mesh");l&&(t.mesh=function(e){const t={},n=[],r=e.querySelectorAll("vertices vertex");for(let e=0;e<r.length;e++){const t=r[e],o=t.getAttribute("x"),a=t.getAttribute("y"),i=t.getAttribute("z");n.push(parseFloat(o),parseFloat(a),parseFloat(i))}t.vertices=new Float32Array(n);const o=[],a=[],i=e.querySelectorAll("triangles triangle");for(let e=0;e<i.length;e++){const t=i[e],n=t.getAttribute("v1"),r=t.getAttribute("v2"),s=t.getAttribute("v3"),l=t.getAttribute("p1"),c=t.getAttribute("p2"),f=t.getAttribute("p3"),u=t.getAttribute("pid"),d={};d.v1=parseInt(n,10),d.v2=parseInt(r,10),d.v3=parseInt(s,10),a.push(d.v1,d.v2,d.v3),l&&(d.p1=parseInt(l,10)),c&&(d.p2=parseInt(c,10)),f&&(d.p3=parseInt(f,10)),u&&(d.pid=u),0<Object.keys(d).length&&o.push(d)}return t.triangleProperties=o,t.triangles=new Uint32Array(a),t}(l));const c=e.querySelector("components");return c&&(t.components=function(e){const t=[],n=e.querySelectorAll("component");for(let e=0;e<n.length;e++){const r=f(n[e]);t.push(r)}return t}(c)),t}function p(e){const t={unit:e.getAttribute("unit")||"millimeter"},n=e.querySelectorAll("metadata");n&&(t.metadata=function(e){const t={};for(let n=0;n<e.length;n++){const r=e[n],o=r.getAttribute("name");0<=["Title","Designer","Description","Copyright","LicenseTerms","Rating","CreationDate","ModificationDate"].indexOf(o)&&(t[o]=r.textContent)}return t}(n));const r=e.querySelector("resources");r&&(t.resources=function(e){const t={basematerials:{}},n=e.querySelectorAll("basematerials");for(let e=0;e<n.length;e++){const r=a(n[e]);t.basematerials[r.id]=r}t.texture2d={};const r=e.querySelectorAll("texture2d");for(let e=0;e<r.length;e++){const n={id:(o=r[e]).getAttribute("id"),path:o.getAttribute("path"),contenttype:o.getAttribute("contenttype"),tilestyleu:o.getAttribute("tilestyleu"),tilestylev:o.getAttribute("tilestylev"),filter:o.getAttribute("filter")};t.texture2d[n.id]=n}var o;t.colorgroup={};const c=e.querySelectorAll("colorgroup");for(let e=0;e<c.length;e++){const n=s(c[e]);t.colorgroup[n.id]=n}t.pbmetallicdisplayproperties={};const f=e.querySelectorAll("pbmetallicdisplayproperties");for(let e=0;e<f.length;e++){const n=l(f[e]);t.pbmetallicdisplayproperties[n.id]=n}t.texture2dgroup={};const u=e.querySelectorAll("texture2dgroup");for(let e=0;e<u.length;e++){const n=i(u[e]);t.texture2dgroup[n.id]=n}t.object={};const p=e.querySelectorAll("object");for(let e=0;e<p.length;e++){const n=d(p[e]);t.object[n.id]=n}return t}(r));const o=e.querySelector("build");return o&&(t.build=function(e){const t=[],n=e.querySelectorAll("item");for(let e=0;e<n.length;e++){const r=n[e],o={objectId:r.getAttribute("objectid")},a=r.getAttribute("transform");a&&(o.transform=u(a)),t.push(o)}return t}(o)),t}function h(e,t,r,o){const a=e.texid,i=r.resources.texture2d[a];if(i){const e=o[i.path],t=i.contenttype,r=new Blob([e],{type:t}),a=URL.createObjectURL(r),s=n.load(a,(function(){URL.revokeObjectURL(a)}));switch(s.encoding=THREE.sRGBEncoding,i.tilestyleu){case"wrap":s.wrapS=THREE.RepeatWrapping;break;case"mirror":s.wrapS=THREE.MirroredRepeatWrapping;break;case"none":case"clamp":s.wrapS=THREE.ClampToEdgeWrapping;break;default:s.wrapS=THREE.RepeatWrapping}switch(i.tilestylev){case"wrap":s.wrapT=THREE.RepeatWrapping;break;case"mirror":s.wrapT=THREE.MirroredRepeatWrapping;break;case"none":case"clamp":s.wrapT=THREE.ClampToEdgeWrapping;break;default:s.wrapT=THREE.RepeatWrapping}switch(i.filter){case"auto":s.magFilter=THREE.LinearFilter,s.minFilter=THREE.LinearMipmapLinearFilter;break;case"linear":s.magFilter=THREE.LinearFilter,s.minFilter=THREE.LinearFilter;break;case"nearest":s.magFilter=THREE.NearestFilter,s.minFilter=THREE.NearestFilter;break;default:s.magFilter=THREE.LinearFilter,s.minFilter=THREE.LinearMipmapLinearFilter}return s}return null}function v(e,t,n,r,o,a,i){const s=i.pindex,l={};for(let e=0,n=t.length;e<n;e++){const n=t[e],r=void 0!==n.p1?n.p1:s;void 0===l[r]&&(l[r]=[]),l[r].push(n)}const c=Object.keys(l),f=[];for(let t=0,s=c.length;t<s;t++){const s=c[t],u=l[s],d=w(e.basematerials[s],r,o,a,i,b),p=new THREE.BufferGeometry,h=[],v=n.vertices;for(let e=0,t=u.length;e<t;e++){const t=u[e];h.push(v[3*t.v1+0]),h.push(v[3*t.v1+1]),h.push(v[3*t.v1+2]),h.push(v[3*t.v2+0]),h.push(v[3*t.v2+1]),h.push(v[3*t.v2+2]),h.push(v[3*t.v3+0]),h.push(v[3*t.v3+1]),h.push(v[3*t.v3+2])}p.setAttribute("position",new THREE.Float32BufferAttribute(h,3));const m=new THREE.Mesh(p,d);f.push(m)}return f}function m(e,t,n,r,o,a,i){const s=new THREE.BufferGeometry,l=[],c=[],f=n.vertices,u=e.uvs;for(let e=0,n=t.length;e<n;e++){const n=t[e];l.push(f[3*n.v1+0]),l.push(f[3*n.v1+1]),l.push(f[3*n.v1+2]),l.push(f[3*n.v2+0]),l.push(f[3*n.v2+1]),l.push(f[3*n.v2+2]),l.push(f[3*n.v3+0]),l.push(f[3*n.v3+1]),l.push(f[3*n.v3+2]),c.push(u[2*n.p1+0]),c.push(u[2*n.p1+1]),c.push(u[2*n.p2+0]),c.push(u[2*n.p2+1]),c.push(u[2*n.p3+0]),c.push(u[2*n.p3+1])}s.setAttribute("position",new THREE.Float32BufferAttribute(l,3)),s.setAttribute("uv",new THREE.Float32BufferAttribute(c,2));const d=w(e,r,o,a,i,h),p=new THREE.MeshPhongMaterial({map:d,flatShading:!0});return new THREE.Mesh(s,p)}function x(e,t,n,r,o,a){const i=new THREE.BufferGeometry,s=[],l=[],c=n.vertices,f=e.colors;for(let e=0,n=t.length;e<n;e++){const n=t[e],r=n.v1,o=n.v2,i=n.v3;s.push(c[3*r+0]),s.push(c[3*r+1]),s.push(c[3*r+2]),s.push(c[3*o+0]),s.push(c[3*o+1]),s.push(c[3*o+2]),s.push(c[3*i+0]),s.push(c[3*i+1]),s.push(c[3*i+2]);const u=void 0!==n.p1?n.p1:a.pindex,d=void 0!==n.p2?n.p2:u,p=void 0!==n.p3?n.p3:u;l.push(f[3*u+0]),l.push(f[3*u+1]),l.push(f[3*u+2]),l.push(f[3*d+0]),l.push(f[3*d+1]),l.push(f[3*d+2]),l.push(f[3*p+0]),l.push(f[3*p+1]),l.push(f[3*p+2])}i.setAttribute("position",new THREE.Float32BufferAttribute(s,3)),i.setAttribute("color",new THREE.Float32BufferAttribute(l,3));const u=new THREE.MeshPhongMaterial({vertexColors:!0,flatShading:!0});return new THREE.Mesh(i,u)}function g(e){const t=new THREE.BufferGeometry;t.setIndex(new THREE.BufferAttribute(e.triangles,1)),t.setAttribute("position",new THREE.BufferAttribute(e.vertices,3));const n=new THREE.MeshPhongMaterial({color:11184895,flatShading:!0});return new THREE.Mesh(t,n)}function y(e,t){return void 0!==t.resources.texture2dgroup[e]?"texture":void 0!==t.resources.basematerials[e]?"material":void 0!==t.resources.colorgroup[e]?"vertexColors":"default"===e?"default":void 0}function E(e,t,n,r,o){const a=new THREE.Group,i=function(e,t,n,r,o,a){const i=Object.keys(e),s=[];for(let l=0,c=i.length;l<c;l++){const c=i[l],f=e[c];switch(y(c,r)){case"material":const e=v(r.resources.basematerials[c],f,t,n,r,o,a);for(let t=0,n=e.length;t<n;t++)s.push(e[t]);break;case"texture":const i=r.resources.texture2dgroup[c];s.push(m(i,f,t,n,r,o,a));break;case"vertexColors":const l=r.resources.colorgroup[c];s.push(x(l,f,t,0,0,a));break;case"default":s.push(g(t));break;default:console.error("THREE.3MFLoader: Unsupported resource type.")}}return s}(function(e,t,n){const r={},o=t.triangleProperties,a=n.pid;for(let e=0,t=o.length;e<t;e++){const t=o[e];let n=void 0!==t.pid?t.pid:a;void 0===n&&(n="default"),void 0===r[n]&&(r[n]=[]),r[n].push(t)}return r}(0,e,o),e,t,n,r,o);for(let e=0,t=i.length;e<t;e++)a.add(i[e]);return a}function w(e,t,n,r,o,a){return void 0!==e.build||(e.build=a(e,t,n,r,o)),e.build}function b(e,t,n){let r;const o=e.displaypropertiesid,a=n.resources.pbmetallicdisplayproperties;if(null!==o&&void 0!==a[o]){const t=a[o].data[e.index];r=new THREE.MeshStandardMaterial({flatShading:!0,roughness:t.roughness,metalness:t.metallicness})}else r=new THREE.MeshPhongMaterial({flatShading:!0});r.name=e.name;const i=e.displaycolor,s=i.substring(0,7);return r.color.setStyle(s),r.color.convertSRGBToLinear(),9===i.length&&(r.opacity=parseInt(i.charAt(7)+i.charAt(8),16)/255),r}function _(e,t,n,r){const o=new THREE.Group;for(let a=0;a<e.length;a++){const i=e[a];let s=t[i.objectId];void 0===s&&(T(i.objectId,t,n,r),s=t[i.objectId]);const l=s.clone(),c=i.transform;c&&l.applyMatrix4(c),o.add(l)}return o}function T(e,n,r,o){const a=r.resources.object[e];if(a.mesh){const e=a.mesh;!function(e,n,r){if(!e)return;const o=[],a=Object.keys(e);for(let e=0;e<a.length;e++){const n=a[e];for(let e=0;e<t.availableExtensions.length;e++){const r=t.availableExtensions[e];r.ns===n&&o.push(r)}}for(let t=0;t<o.length;t++){const a=o[t];a.apply(r,e[a.ns],n)}}(r.extensions,e,r.xml),n[a.id]=w(e,n,r,o,a,E)}else{const e=a.components;n[a.id]=w(e,n,r,o,a,_)}}const A=function(e){let t,n,a=null,i=null;const s=[],l=[],c=[],f=[];let u;const d={},h={};try{a=r.unzipSync(new Uint8Array(e))}catch(e){if(e instanceof ReferenceError)return console.error("THREE.3MFLoader: fflate missing and file is compressed."),null}for(i in a)i.match(/\_rels\/.rels$/)?t=i:i.match(/3D\/_rels\/.*\.model\.rels$/)?n=i:i.match(/^3D\/.*\.model$/)?s.push(i):i.match(/^3D\/Metadata\/.*\.xml$/)?l.push(i):i.match(/^3D\/Textures?\/.*/)?c.push(i):i.match(/^3D\/Other\/.*/)&&f.push(i);const v=a[t],m=o(THREE.LoaderUtils.decodeText(v));if(n){const e=a[n];u=o(THREE.LoaderUtils.decodeText(e))}for(let e=0;e<s.length;e++){const t=s[e],n=a[t],r=THREE.LoaderUtils.decodeText(n),o=(new DOMParser).parseFromString(r,"application/xml");"model"!==o.documentElement.nodeName.toLowerCase()&&console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ",t);const i=o.querySelector("model"),l={};for(let e=0;e<i.attributes.length;e++){const t=i.attributes[e];t.name.match(/^xmlns:(.+)$/)&&(l[t.value]=RegExp.$1)}const c=p(i);c.xml=i,0<Object.keys(l).length&&(c.extensions=l),d[t]=c}for(let e=0;e<c.length;e++){const t=c[e];h[t]=a[t].buffer}return{rels:m,modelRels:u,model:d,printTicket:{},texture:h,other:{}}}(e);return function(e,t){const n=new THREE.Group,r=function(e){for(let t=0;t<e.length;t++){const n=e[t];if("model"===n.target.split(".").pop().toLowerCase())return n}}(t.rels),o=t.model[r.target.substring(1)].build;for(let t=0;t<o.length;t++){const r=o[t],a=e[r.objectId],i=r.transform;i&&a.applyMatrix4(i),n.add(a)}return n}(function(e){const t=e.model,n=e.modelRels,r={},o=Object.keys(t),a={};if(n)for(let t=0,r=n.length;t<r;t++){const r=n[t],o=r.target.substring(1);e.texture[o]&&(a[r.target]=e.texture[o])}for(let e=0;e<o.length;e++){const n=t[o[e]],i=Object.keys(n.resources.object);for(let e=0;e<i.length;e++){T(i[e],r,n,a)}}return r}(A),A)}addExtension(e){this.availableExtensions.push(e)}}THREE.ThreeMFLoader=e,THREE.ThreeMFLoader.MaterialsAndPropertiesExtension={ns:"http://schemas.microsoft.com/3dmanufacturing/material/2015/02",apply:function(e,t,n){for(var r=e.querySelectorAll("colorgroup"),o=0;o<r.length;o++){var a=r[o];if(a.prefix===t){for(var i=a.getAttribute("id"),s=a.querySelectorAll("color"),l=[],c=0;c<s.length;c++){var f=s[c].getAttribute("color");f.match(/#[0-9a-fA-F]{8}/)?l.push(new THREE.Color(f.substring(0,7))):l.push(new THREE.Color(f))}for(var u=[],d=0;d<n.triangleProperties.length;d++){var p=n.triangleProperties[d];if(p.pid===i){var h=l[p.p1],v=l[p.p2||p.p1],m=l[p.p3||p.p1];u.push(h.r,h.g,h.b),u.push(v.r,v.g,v.b),u.push(m.r,m.g,m.b)}}n.colors=new Float32Array(u.length);for(var x=0;x<u.length;x++)n.colors[x]=u[x]}}}}}()},3572:(e,t,n)=>{"use strict";n.r(t);var r=n(743);!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){function t(e){let t="AMF Material";const r=e.attributes.id.textContent;let o={r:1,g:1,b:1,a:1},a=null;for(let r=0;r<e.childNodes.length;r++){const a=e.childNodes[r];"metadata"===a.nodeName&&void 0!==a.attributes.type?"name"===a.attributes.type.value&&(t=a.textContent):"color"===a.nodeName&&(o=n(a))}return a=new THREE.MeshPhongMaterial({flatShading:!0,color:new THREE.Color(o.r,o.g,o.b),name:t}),1!==o.a&&(a.transparent=!0,a.opacity=o.a),{id:r,material:a}}function n(e){const t={r:1,g:1,b:1,a:1};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];"r"===r.nodeName?t.r=r.textContent:"g"===r.nodeName?t.g=r.textContent:"b"===r.nodeName?t.b=r.textContent:"a"===r.nodeName&&(t.a=r.textContent)}return t}function o(e){const t={name:"",triangles:[],materialid:null};let n=e.firstElementChild;for(void 0!==e.attributes.materialid&&(t.materialId=e.attributes.materialid.nodeValue);n;){if("metadata"===n.nodeName)void 0!==n.attributes.type&&"name"===n.attributes.type.value&&(t.name=n.textContent);else if("triangle"===n.nodeName){const e=n.getElementsByTagName("v1")[0].textContent,r=n.getElementsByTagName("v2")[0].textContent,o=n.getElementsByTagName("v3")[0].textContent;t.triangles.push(e,r,o)}n=n.nextElementSibling}return t}function a(e){const t=[],n=[];let r=e.firstElementChild;for(;r;){if("vertex"===r.nodeName){let e=r.firstElementChild;for(;e;){if("coordinates"===e.nodeName){const n=e.getElementsByTagName("x")[0].textContent,r=e.getElementsByTagName("y")[0].textContent,o=e.getElementsByTagName("z")[0].textContent;t.push(n,r,o)}else if("normal"===e.nodeName){const t=e.getElementsByTagName("nx")[0].textContent,r=e.getElementsByTagName("ny")[0].textContent,o=e.getElementsByTagName("nz")[0].textContent;n.push(t,r,o)}e=e.nextElementSibling}}r=r.nextElementSibling}return{vertices:t,normals:n}}function i(e){const t=e.attributes.id.textContent,r={name:"amfobject",meshes:[]};let i=null,s=e.firstElementChild;for(;s;){if("metadata"===s.nodeName)void 0!==s.attributes.type&&"name"===s.attributes.type.value&&(r.name=s.textContent);else if("color"===s.nodeName)i=n(s);else if("mesh"===s.nodeName){let e=s.firstElementChild;const t={vertices:[],normals:[],volumes:[],color:i};for(;e;){if("vertices"===e.nodeName){const n=a(e);t.normals=t.normals.concat(n.normals),t.vertices=t.vertices.concat(n.vertices)}else"volume"===e.nodeName&&t.volumes.push(o(e));e=e.nextElementSibling}r.meshes.push(t)}s=s.nextElementSibling}return{id:t,obj:r}}const s=function(e){let t=new DataView(e);if("PK"===String.fromCharCode(t.getUint8(0),t.getUint8(1))){let n=null,o=null;console.log("THREE.AMFLoader: Loading Zip");try{n=r.unzipSync(new Uint8Array(e))}catch(e){if(e instanceof ReferenceError)return console.log("THREE.AMFLoader: fflate missing and file is compressed."),null}for(o in n)if(".amf"===o.toLowerCase().substr(-4))break;console.log("THREE.AMFLoader: Trying to load file asset: "+o),t=new DataView(n[o].buffer)}const n=THREE.LoaderUtils.decodeText(t),o=(new DOMParser).parseFromString(n,"application/xml");return"amf"!==o.documentElement.nodeName.toLowerCase()?(console.log("THREE.AMFLoader: Error loading AMF - no AMF document found."),null):o}(e);let l="",c="";const f=function(e){let t=1,n="millimeter";void 0!==e.documentElement.attributes.unit&&(n=e.documentElement.attributes.unit.value.toLowerCase());const r={millimeter:1,inch:25.4,feet:304.8,meter:1e3,micron:.001};return void 0!==r[n]&&(t=r[n]),console.log("THREE.AMFLoader: Unit scale: "+t),t}(s),u={},d={},p=s.documentElement.childNodes;let h,v;for(h=0;h<p.length;h++){const e=p[h];if("metadata"===e.nodeName)void 0!==e.attributes.type&&("name"===e.attributes.type.value?l=e.textContent:"author"===e.attributes.type.value&&(c=e.textContent));else if("material"===e.nodeName){const n=t(e);u[n.id]=n.material}else if("object"===e.nodeName){const t=i(e);d[t.id]=t.obj}}const m=new THREE.Group,x=new THREE.MeshPhongMaterial({color:11184895,flatShading:!0});m.name=l,m.userData.author=c,m.userData.loader="AMF";for(const e in d){const t=d[e],n=t.meshes,r=new THREE.Group;for(r.name=t.name||"",h=0;h<n.length;h++){let e=x;const t=n[h],o=new THREE.Float32BufferAttribute(t.vertices,3);let a=null;if(t.normals.length&&(a=new THREE.Float32BufferAttribute(t.normals,3)),t.color){const n=t.color;e=x.clone(),e.color=new THREE.Color(n.r,n.g,n.b),1!==n.a&&(e.transparent=!0,e.opacity=n.a)}const i=t.volumes;for(v=0;v<i.length;v++){const t=i[v],n=new THREE.BufferGeometry;let s=e;n.setIndex(t.triangles),n.setAttribute("position",o.clone()),a&&n.setAttribute("normal",a.clone()),void 0!==u[t.materialId]&&(s=u[t.materialId]),n.scale(f,f,f),r.add(new THREE.Mesh(n,s.clone()))}}m.add(r)}return m}}THREE.AMFLoader=e}()},9211:()=>{THREE.AnaglyphEffect=class{constructor(e,t=512,n=512){this.colorMatrixLeft=(new THREE.Matrix3).fromArray([.4561,-.0400822,-.0152161,.500484,-.0378246,-.0205971,.176381,-.0157589,-.00546856]),this.colorMatrixRight=(new THREE.Matrix3).fromArray([-.0434706,.378476,-.0721527,-.0879388,.73364,-.112961,-.00155529,-.0184503,1.2264]);const r=new THREE.OrthographicCamera(-1,1,1,-1,0,1),o=new THREE.Scene,a=new THREE.StereoCamera,i={minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat},s=new THREE.WebGLRenderTarget(t,n,i),l=new THREE.WebGLRenderTarget(t,n,i),c=new THREE.ShaderMaterial({uniforms:{mapLeft:{value:s.texture},mapRight:{value:l.texture},colorMatrixLeft:{value:this.colorMatrixLeft},colorMatrixRight:{value:this.colorMatrixRight}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = vec2( uv.x, uv.y );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D mapLeft;","uniform sampler2D mapRight;","varying vec2 vUv;","uniform mat3 colorMatrixLeft;","uniform mat3 colorMatrixRight;","float lin( float c ) {","\treturn c <= 0.04045 ? c * 0.0773993808 :","\t\t\tpow( c * 0.9478672986 + 0.0521327014, 2.4 );","}","vec4 lin( vec4 c ) {","\treturn vec4( lin( c.r ), lin( c.g ), lin( c.b ), c.a );","}","float dev( float c ) {","\treturn c <= 0.0031308 ? c * 12.92","\t\t\t: pow( c, 0.41666 ) * 1.055 - 0.055;","}","void main() {","\tvec2 uv = vUv;","\tvec4 colorL = lin( texture2D( mapLeft, uv ) );","\tvec4 colorR = lin( texture2D( mapRight, uv ) );","\tvec3 color = clamp(","\t\t\tcolorMatrixLeft * colorL.rgb +","\t\t\tcolorMatrixRight * colorR.rgb, 0., 1. );","\tgl_FragColor = vec4(","\t\t\tdev( color.r ), dev( color.g ), dev( color.b ),","\t\t\tmax( colorL.a, colorR.a ) );","}"].join("\n")}),f=new THREE.Mesh(new THREE.PlaneGeometry(2,2),c);o.add(f),this.setSize=function(t,n){e.setSize(t,n);const r=e.getPixelRatio();s.setSize(t*r,n*r),l.setSize(t*r,n*r)},this.render=function(t,n){const i=e.getRenderTarget();t.updateMatrixWorld(),null===n.parent&&n.updateMatrixWorld(),a.update(n),e.setRenderTarget(s),e.clear(),e.render(t,a.cameraL),e.setRenderTarget(l),e.clear(),e.render(t,a.cameraR),e.setRenderTarget(null),e.render(o,r),e.setRenderTarget(i)},this.dispose=function(){s&&s.dispose(),l&&l.dispose(),f&&f.geometry.dispose(),c&&c.dispose()}}}},385:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\n\t\t\tfloat lum = dot( lumCoeff, base.rgb );\n\t\t\tvec3 blend = vec3( lum );\n\n\t\t\tfloat L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\n\n\t\t\tvec3 result1 = 2.0 * base.rgb * blend;\n\t\t\tvec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\n\n\t\t\tvec3 newColor = mix( result1, result2, L );\n\n\t\t\tfloat A2 = opacity * base.a;\n\t\t\tvec3 mixRGB = A2 * newColor.rgb;\n\t\t\tmixRGB += ( ( 1.0 - A2 ) * base.rgb );\n\n\t\t\tgl_FragColor = vec4( mixRGB, base.a );\n\n\t\t}"};THREE.BleachBypassShader=e}()},5:()=>{class e extends THREE.Pass{constructor(e,t,n){super();var r=n.width||window.innerWidth||1,o=n.height||window.innerHeight||1,a=n.vignetting||0;this.scene=e,this.camera=t,this.mouse=new THREE.Vector2,this.width=r,this.height=o;var i=THREE.BokehDepthShader,s=THREE.UniformsUtils.clone(i.uniforms);this.materialDepth=new THREE.ShaderMaterial({uniforms:s,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader}),s.mNear.value=t.near,s.mFar.value=t.far,this.scene2=new THREE.Scene,this.camera2=new THREE.OrthographicCamera(r/-2,r/2,o/2,o/-2,-1e4,1e4),this.camera2.position.z=100,this.scene2.add(this.camera2);var l={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat};this.rtTextureDepth=new THREE.WebGLRenderTarget(r,o,l),this.rtTextureColor=new THREE.WebGLRenderTarget(r,o,l);var c=3,f=4,u=THREE.BokehShader,d=THREE.UniformsUtils.clone(u.uniforms);d.textureWidth.value=r,d.textureHeight.value=o,d.shaderFocus.value=1,d.vignetting.value=a,this.materialBokeh=new THREE.ShaderMaterial({uniforms:d,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,defines:{RINGS:c,SAMPLES:f}}),this.materialBokeh.uniforms.tColor.value=this.rtTextureColor.texture,this.materialBokeh.uniforms.tDepth.value=this.rtTextureDepth.texture;var p=new THREE.Mesh(new THREE.PlaneBufferGeometry(r,o),this.materialBokeh);p.position.z=-500,this.scene2.add(p)}render(e,t,n,r,o){var a=this.scene,i=this.camera,s=this.materialBokeh.uniforms,l=this.materialDepth.uniforms,c=.5,f=.5;c=.5*this.mouse.x+.5,f=.5*this.mouse.y+.5,s.focusCoords.value.set(c,f),s.znear.value=i.near,s.zfar.value=i.far,l.mNear.value=i.near,l.mFar.value=i.far,e.setRenderTarget(this.rtTextureColor),e.clear(),e.render(a,i),a.overrideMaterial=this.materialDepth,e.setRenderTarget(this.rtTextureDepth),e.clear(),e.render(a,i),a.overrideMaterial=null,this.renderToScreen||(e.setRenderTarget(t),this.clear&&e.clear()),e.render(this.scene2,this.camera2)}}e.prototype.isBokehPass=!0,THREE.BokehPass=e},159:()=>{!function(){const e={uniforms:{textureWidth:{value:1},textureHeight:{value:1},focalDepth:{value:1},focalLength:{value:24},fstop:{value:.9},tColor:{value:null},tDepth:{value:null},maxblur:{value:1},showFocus:{value:0},manualdof:{value:1},vignetting:{value:0},depthblur:{value:0},threshold:{value:.5},gain:{value:2},bias:{value:.5},fringe:{value:.7},znear:{value:.1},zfar:{value:100},noise:{value:1},dithering:{value:1e-4},pentagon:{value:0},shaderFocus:{value:1},focusCoords:{value:new THREE.Vector2}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\t#include <common>\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColor;\n\t\tuniform sampler2D tDepth;\n\t\tuniform float textureWidth;\n\t\tuniform float textureHeight;\n\n\t\tuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\n\t\tuniform float focalLength; //focal length in mm\n\t\tuniform float fstop; //f-stop value\n\t\tuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\n\n\t\t/*\n\t\tmake sure that these two values are the same for your camera, otherwise distances will be wrong.\n\t\t*/\n\n\t\tuniform float znear; // camera clipping start\n\t\tuniform float zfar; // camera clipping end\n\n\t\t//------------------------------------------\n\t\t//user variables\n\n\t\tconst int samples = SAMPLES; //samples on the first ring\n\t\tconst int rings = RINGS; //ring count\n\n\t\tconst int maxringsamples = rings * samples;\n\n\t\tuniform bool manualdof; // manual dof calculation\n\t\tfloat ndofstart = 1.0; // near dof blur start\n\t\tfloat ndofdist = 2.0; // near dof blur falloff distance\n\t\tfloat fdofstart = 1.0; // far dof blur start\n\t\tfloat fdofdist = 3.0; // far dof blur falloff distance\n\n\t\tfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\n\n\t\tuniform bool vignetting; // use optical lens vignetting\n\n\t\tfloat vignout = 1.3; // vignetting outer border\n\t\tfloat vignin = 0.0; // vignetting inner border\n\t\tfloat vignfade = 22.0; // f-stops till vignete fades\n\n\t\tuniform bool shaderFocus;\n\t\t// disable if you use external focalDepth value\n\n\t\tuniform vec2 focusCoords;\n\t\t// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\n\t\t// if center of screen use vec2(0.5, 0.5);\n\n\t\tuniform float maxblur;\n\t\t//clamp value of max blur (0.0 = no blur, 1.0 default)\n\n\t\tuniform float threshold; // highlight threshold;\n\t\tuniform float gain; // highlight gain;\n\n\t\tuniform float bias; // bokeh edge bias\n\t\tuniform float fringe; // bokeh chromatic aberration / fringing\n\n\t\tuniform bool noise; //use noise instead of pattern for sample dithering\n\n\t\tuniform float dithering;\n\n\t\tuniform bool depthblur; // blur the depth buffer\n\t\tfloat dbsize = 1.25; // depth blur size\n\n\t\t/*\n\t\tnext part is experimental\n\t\tnot looking good with small sample and ring count\n\t\tlooks okay starting from samples = 4, rings = 4\n\t\t*/\n\n\t\tuniform bool pentagon; //use pentagon as bokeh shape?\n\t\tfloat feather = 0.4; //pentagon shape feather\n\n\t\t//------------------------------------------\n\n\t\tfloat penta(vec2 coords) {\n\t\t\t//pentagonal shape\n\t\t\tfloat scale = float(rings) - 1.3;\n\t\t\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\n\t\t\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\n\t\t\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\n\t\t\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\n\t\t\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\n\t\t\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\n\n\t\t\tvec4  one = vec4( 1.0 );\n\n\t\t\tvec4 P = vec4((coords),vec2(scale, scale));\n\n\t\t\tvec4 dist = vec4(0.0);\n\t\t\tfloat inorout = -4.0;\n\n\t\t\tdist.x = dot( P, HS0 );\n\t\t\tdist.y = dot( P, HS1 );\n\t\t\tdist.z = dot( P, HS2 );\n\t\t\tdist.w = dot( P, HS3 );\n\n\t\t\tdist = smoothstep( -feather, feather, dist );\n\n\t\t\tinorout += dot( dist, one );\n\n\t\t\tdist.x = dot( P, HS4 );\n\t\t\tdist.y = HS5.w - abs( P.z );\n\n\t\t\tdist = smoothstep( -feather, feather, dist );\n\t\t\tinorout += dist.x;\n\n\t\t\treturn clamp( inorout, 0.0, 1.0 );\n\t\t}\n\n\t\tfloat bdepth(vec2 coords) {\n\t\t\t// Depth buffer blur\n\t\t\tfloat d = 0.0;\n\t\t\tfloat kernel[9];\n\t\t\tvec2 offset[9];\n\n\t\t\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\n\n\t\t\toffset[0] = vec2(-wh.x,-wh.y);\n\t\t\toffset[1] = vec2( 0.0, -wh.y);\n\t\t\toffset[2] = vec2( wh.x -wh.y);\n\n\t\t\toffset[3] = vec2(-wh.x,  0.0);\n\t\t\toffset[4] = vec2( 0.0,   0.0);\n\t\t\toffset[5] = vec2( wh.x,  0.0);\n\n\t\t\toffset[6] = vec2(-wh.x, wh.y);\n\t\t\toffset[7] = vec2( 0.0,  wh.y);\n\t\t\toffset[8] = vec2( wh.x, wh.y);\n\n\t\t\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\n\t\t\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\n\t\t\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\n\n\n\t\t\tfor( int i=0; i<9; i++ ) {\n\t\t\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\n\t\t\t\td += tmp * kernel[i];\n\t\t\t}\n\n\t\t\treturn d;\n\t\t}\n\n\n\t\tvec3 color(vec2 coords,float blur) {\n\t\t\t//processing the sample\n\n\t\t\tvec3 col = vec3(0.0);\n\t\t\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\n\n\t\t\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\n\t\t\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\n\t\t\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\n\n\t\t\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\n\t\t\tfloat lum = dot(col.rgb, lumcoeff);\n\t\t\tfloat thresh = max((lum-threshold)*gain, 0.0);\n\t\t\treturn col+mix(vec3(0.0),col,thresh*blur);\n\t\t}\n\n\t\tvec3 debugFocus(vec3 col, float blur, float depth) {\n\t\t\tfloat edge = 0.002*depth; //distance based edge smoothing\n\t\t\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\n\t\t\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\n\n\t\t\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\n\t\t\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\n\n\t\t\treturn col;\n\t\t}\n\n\t\tfloat linearize(float depth) {\n\t\t\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\n\t\t}\n\n\t\tfloat vignette() {\n\t\t\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\n\t\t\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\n\t\t\treturn clamp(dist,0.0,1.0);\n\t\t}\n\n\t\tfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\n\t\t\tfloat rings2 = float(rings);\n\t\t\tfloat step = PI*2.0 / float(ringsamples);\n\t\t\tfloat pw = cos(j*step)*i;\n\t\t\tfloat ph = sin(j*step)*i;\n\t\t\tfloat p = 1.0;\n\t\t\tif (pentagon) {\n\t\t\t\tp = penta(vec2(pw,ph));\n\t\t\t}\n\t\t\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\n\t\t\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\n\t\t}\n\n\t\tvoid main() {\n\t\t\t//scene depth calculation\n\n\t\t\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\n\n\t\t\t// Blur depth?\n\t\t\tif ( depthblur ) {\n\t\t\t\tdepth = linearize(bdepth(vUv.xy));\n\t\t\t}\n\n\t\t\t//focal plane calculation\n\n\t\t\tfloat fDepth = focalDepth;\n\n\t\t\tif (shaderFocus) {\n\n\t\t\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\n\n\t\t\t}\n\n\t\t\t// dof blur factor calculation\n\n\t\t\tfloat blur = 0.0;\n\n\t\t\tif (manualdof) {\n\t\t\t\tfloat a = depth-fDepth; // Focal plane\n\t\t\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\n\t\t\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\n\t\t\t\tblur = (a>0.0) ? b : c;\n\t\t\t} else {\n\t\t\t\tfloat f = focalLength; // focal length in mm\n\t\t\t\tfloat d = fDepth*1000.0; // focal plane in mm\n\t\t\t\tfloat o = depth*1000.0; // depth in mm\n\n\t\t\t\tfloat a = (o*f)/(o-f);\n\t\t\t\tfloat b = (d*f)/(d-f);\n\t\t\t\tfloat c = (d-f)/(d*fstop*CoC);\n\n\t\t\t\tblur = abs(a-b)*c;\n\t\t\t}\n\n\t\t\tblur = clamp(blur,0.0,1.0);\n\n\t\t\t// calculation of pattern for dithering\n\n\t\t\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\n\n\t\t\t// getting blur x and y step factor\n\n\t\t\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\n\t\t\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\n\n\t\t\t// calculation of final color\n\n\t\t\tvec3 col = vec3(0.0);\n\n\t\t\tif(blur < 0.05) {\n\t\t\t\t//some optimization thingy\n\t\t\t\tcol = texture2D(tColor, vUv.xy).rgb;\n\t\t\t} else {\n\t\t\t\tcol = texture2D(tColor, vUv.xy).rgb;\n\t\t\t\tfloat s = 1.0;\n\t\t\t\tint ringsamples;\n\n\t\t\t\tfor (int i = 1; i <= rings; i++) {\n\t\t\t\t\t/*unboxstart*/\n\t\t\t\t\tringsamples = i * samples;\n\n\t\t\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\n\t\t\t\t\t\tif (j >= ringsamples) break;\n\t\t\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\n\t\t\t\t\t}\n\t\t\t\t\t/*unboxend*/\n\t\t\t\t}\n\n\t\t\t\tcol /= s; //divide by sample count\n\t\t\t}\n\n\t\t\tif (showFocus) {\n\t\t\t\tcol = debugFocus(col, blur, depth);\n\t\t\t}\n\n\t\t\tif (vignetting) {\n\t\t\t\tcol *= vignette();\n\t\t\t}\n\n\t\t\tgl_FragColor.rgb = col;\n\t\t\tgl_FragColor.a = 1.0;\n\t\t}"},t={uniforms:{mNear:{value:1},mFar:{value:1e3}},vertexShader:"\n\n\t\tvarying float vViewZDepth;\n\n\t\tvoid main() {\n\n\t\t\t#include <begin_vertex>\n\t\t\t#include <project_vertex>\n\n\t\t\tvViewZDepth = - mvPosition.z;\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float mNear;\n\t\tuniform float mFar;\n\n\t\tvarying float vViewZDepth;\n\n\t\tvoid main() {\n\n\t\t\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\n\t\t\tgl_FragColor = vec4( vec3( color ), 1.0 );\n\n\t\t}"};THREE.BokehDepthShader=t,THREE.BokehShader=e}()},3675:()=>{THREE.BufferGeometryUtils=class{static computeTangents(e){e.computeTangents(),console.warn("THREE.BufferGeometryUtils: .computeTangents() has been removed. Use THREE.BufferGeometry.computeTangents() instead.")}static mergeBufferGeometries(e,t=!1){const n=null!==e[0].index,r=new Set(Object.keys(e[0].attributes)),o=new Set(Object.keys(e[0].morphAttributes)),a={},i={},s=e[0].morphTargetsRelative,l=new THREE.BufferGeometry;let c=0;for(let f=0;f<e.length;++f){const u=e[f];let d=0;if(n!==(null!==u.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in u.attributes){if(!r.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===a[e]&&(a[e]=[]),a[e].push(u.attributes[e]),d++}if(d!==r.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". Make sure all geometries have the same number of attributes."),null;if(s!==u.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const e in u.morphAttributes){if(!o.has(e))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===i[e]&&(i[e]=[]),i[e].push(u.morphAttributes[e])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(u.userData),t){let e;if(n)e=u.index.count;else{if(void 0===u.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+f+". The geometry must have either an index or a position attribute"),null;e=u.attributes.position.count}l.addGroup(c,e,f),c+=e}}if(n){let t=0;const n=[];for(let r=0;r<e.length;++r){const o=e[r].index;for(let e=0;e<o.count;++e)n.push(o.getX(e)+t);t+=e[r].attributes.position.count}l.setIndex(n)}for(const e in a){const t=this.mergeBufferAttributes(a[e]);if(!t)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" attribute."),null;l.setAttribute(e,t)}for(const e in i){const t=i[e][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[e]=[];for(let n=0;n<t;++n){const t=[];for(let r=0;r<i[e].length;++r)t.push(i[e][r][n]);const r=this.mergeBufferAttributes(t);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+e+" morphAttribute."),null;l.morphAttributes[e].push(r)}}return l}static mergeBufferAttributes(e){let t,n,r,o=0;for(let a=0;a<e.length;++a){const i=e[a];if(i.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=i.array.constructor),t!==i.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=i.itemSize),n!==i.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===r&&(r=i.normalized),r!==i.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. THREE.BufferAttribute.normalized must be consistent across matching attributes."),null;o+=i.array.length}const a=new t(o);let i=0;for(let t=0;t<e.length;++t)a.set(e[t].array,i),i+=e[t].array.length;return new THREE.BufferAttribute(a,n,r)}static interleaveAttributes(e){let t,n=0,r=0;for(let o=0,a=e.length;o<a;++o){const a=e[o];if(void 0===t&&(t=a.array.constructor),t!==a.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;n+=a.array.length,r+=a.itemSize}const o=new THREE.InterleavedBuffer(new t(n),r);let a=0;const i=[],s=["getX","getY","getZ","getW"],l=["setX","setY","setZ","setW"];for(let t=0,n=e.length;t<n;t++){const n=e[t],r=n.itemSize,c=n.count,f=new THREE.InterleavedBufferAttribute(o,r,a,n.normalized);i.push(f),a+=r;for(let e=0;e<c;e++)for(let t=0;t<r;t++)f[l[t]](e,n[s[t]](e))}return i}static estimateBytesUsed(e){let t=0;for(const n in e.attributes){const r=e.getAttribute(n);t+=r.count*r.itemSize*r.array.BYTES_PER_ELEMENT}const n=e.getIndex();return t+=n?n.count*n.itemSize*n.array.BYTES_PER_ELEMENT:0,t}static mergeVertices(e,t=1e-4){t=Math.max(t,Number.EPSILON);const n={},r=e.getIndex(),o=e.getAttribute("position"),a=r?r.count:o.count;let i=0;const s=Object.keys(e.attributes),l={},c={},f=[],u=["getX","getY","getZ","getW"];for(let t=0,n=s.length;t<n;t++){const n=s[t];l[n]=[];const r=e.morphAttributes[n];r&&(c[n]=new Array(r.length).fill().map((()=>[])))}const d=Math.log10(1/t),p=Math.pow(10,d);for(let t=0;t<a;t++){const o=r?r.getX(t):t;let a="";for(let t=0,n=s.length;t<n;t++){const n=s[t],r=e.getAttribute(n),i=r.itemSize;for(let e=0;e<i;e++)a+=~~(r[u[e]](o)*p)+","}if(a in n)f.push(n[a]);else{for(let t=0,n=s.length;t<n;t++){const n=s[t],r=e.getAttribute(n),a=e.morphAttributes[n],i=r.itemSize,f=l[n],d=c[n];for(let e=0;e<i;e++){const t=u[e];if(f.push(r[t](o)),a)for(let e=0,n=a.length;e<n;e++)d[e].push(a[e][t](o))}}n[a]=i,f.push(i),i++}}const h=e.clone();for(let t=0,n=s.length;t<n;t++){const n=s[t],r=e.getAttribute(n),o=new r.array.constructor(l[n]),a=new THREE.BufferAttribute(o,r.itemSize,r.normalized);if(h.setAttribute(n,a),n in c)for(let t=0;t<c[n].length;t++){const r=e.morphAttributes[n][t],o=new r.array.constructor(c[n][t]),a=new THREE.BufferAttribute(o,r.itemSize,r.normalized);h.morphAttributes[n][t]=a}}return h.setIndex(f),h}static toTrianglesDrawMode(e,t){if(t===THREE.TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(t===THREE.TriangleFanDrawMode||t===THREE.TriangleStripDrawMode){let n=e.getIndex();if(null===n){const t=[],r=e.getAttribute("position");if(void 0===r)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<r.count;e++)t.push(e);e.setIndex(t),n=e.getIndex()}const r=n.count-2,o=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=r;e++)o.push(n.getX(0)),o.push(n.getX(e)),o.push(n.getX(e+1));else for(let e=0;e<r;e++)e%2==0?(o.push(n.getX(e)),o.push(n.getX(e+1)),o.push(n.getX(e+2))):(o.push(n.getX(e+2)),o.push(n.getX(e+1)),o.push(n.getX(e)));o.length/3!==r&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=e.clone();return a.setIndex(o),a.clearGroups(),a}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",t),e}static computeMorphedAttributes(e){if(!0!==e.geometry.isBufferGeometry)return console.error("THREE.BufferGeometryUtils: Geometry is not of type THREE.BufferGeometry."),null;const t=new THREE.Vector3,n=new THREE.Vector3,r=new THREE.Vector3,o=new THREE.Vector3,a=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Vector3;function f(e,f,u,d,p,h,v,m,x){t.fromBufferAttribute(u,h),n.fromBufferAttribute(u,v),r.fromBufferAttribute(u,m);const g=e.morphTargetInfluences;if(f.morphTargets&&d&&g){s.set(0,0,0),l.set(0,0,0),c.set(0,0,0);for(let e=0,f=d.length;e<f;e++){const f=g[e],u=d[e];0!==f&&(o.fromBufferAttribute(u,h),a.fromBufferAttribute(u,v),i.fromBufferAttribute(u,m),p?(s.addScaledVector(o,f),l.addScaledVector(a,f),c.addScaledVector(i,f)):(s.addScaledVector(o.sub(t),f),l.addScaledVector(a.sub(n),f),c.addScaledVector(i.sub(r),f)))}t.add(s),n.add(l),r.add(c)}e.isSkinnedMesh&&(e.boneTransform(h,t),e.boneTransform(v,n),e.boneTransform(m,r)),x[3*h+0]=t.x,x[3*h+1]=t.y,x[3*h+2]=t.z,x[3*v+0]=n.x,x[3*v+1]=n.y,x[3*v+2]=n.z,x[3*m+0]=r.x,x[3*m+1]=r.y,x[3*m+2]=r.z}const u=e.geometry,d=e.material;let p,h,v;const m=u.index,x=u.attributes.position,g=u.morphAttributes.position,y=u.morphTargetsRelative,E=u.attributes.normal,w=u.morphAttributes.position,b=u.groups,_=u.drawRange;let T,A,S,R,M,C,L,P;const k=new Float32Array(x.count*x.itemSize),N=new Float32Array(E.count*E.itemSize);if(null!==m)if(Array.isArray(d))for(T=0,S=b.length;T<S;T++)for(M=b[T],C=d[M.materialIndex],L=Math.max(M.start,_.start),P=Math.min(M.start+M.count,_.start+_.count),A=L,R=P;A<R;A+=3)p=m.getX(A),h=m.getX(A+1),v=m.getX(A+2),f(e,C,x,g,y,p,h,v,k),f(e,C,E,w,y,p,h,v,N);else for(L=Math.max(0,_.start),P=Math.min(m.count,_.start+_.count),T=L,S=P;T<S;T+=3)p=m.getX(T),h=m.getX(T+1),v=m.getX(T+2),f(e,d,x,g,y,p,h,v,k),f(e,d,E,w,y,p,h,v,N);else if(void 0!==x)if(Array.isArray(d))for(T=0,S=b.length;T<S;T++)for(M=b[T],C=d[M.materialIndex],L=Math.max(M.start,_.start),P=Math.min(M.start+M.count,_.start+_.count),A=L,R=P;A<R;A+=3)p=A,h=A+1,v=A+2,f(e,C,x,g,y,p,h,v,k),f(e,C,E,w,y,p,h,v,N);else for(L=Math.max(0,_.start),P=Math.min(x.count,_.start+_.count),T=L,S=P;T<S;T+=3)p=T,h=T+1,v=T+2,f(e,d,x,g,y,p,h,v,k),f(e,d,E,w,y,p,h,v,N);return{positionAttribute:x,normalAttribute:E,morphedPositionAttribute:new THREE.Float32BufferAttribute(k,3),morphedNormalAttribute:new THREE.Float32BufferAttribute(N,3)}}}},3138:()=>{THREE.ColladaExporter=class{parse(e,t,n={}){""!==(n=Object.assign({version:"1.4.1",author:null,textureDirectory:""},n)).textureDirectory&&(n.textureDirectory=`${n.textureDirectory}/`.replace(/\\/g,"/").replace(/\/+/g,"/"));const r=n.version;if("1.4.1"!==r&&"1.5.0"!==r)return console.warn(`ColladaExporter : Version ${r} not supported for export. Only 1.4.1 and 1.5.0.`),null;let o,a;function i(e,t){return o=o||document.createElement("canvas"),a=a||o.getContext("2d"),o.width=e.width,o.height=e.height,a.drawImage(e,0,0),function(e){const t=atob(e),n=new Uint8Array(t.length);for(let e=0,r=n.length;e<r;e++)n[e]=t.charCodeAt(e);return n}(o.toDataURL(`image/${t}`,1).replace(/^data:image\/(png|jpg);base64,/,""))}const s=["getX","getY","getZ","getW"];function l(e){if(e.isInterleavedBufferAttribute){const t=new e.array.constructor(e.count*e.itemSize),n=e.itemSize;for(let r=0,o=e.count;r<o;r++)for(let o=0;o<n;o++)t[r*n+o]=e[s[o]](r);return t}return e.array}function c(e,t,n,r){const o=l(e);return`<source id="${t}"><float_array id="${t}-array" count="${o.length}">`+o.join(" ")+"</float_array><technique_common>"+`<accessor source="#${t}-array" count="${Math.floor(o.length/e.itemSize)}" stride="${e.itemSize}">`+n.map((e=>`<param name="${e}" type="${r}" />`)).join("")+"</accessor></technique_common></source>"}let f;function u(e){let t=h.get(e);if(null==t){t=`image-${m.length+1}`;const o="png",a=e.name||t;let s=`<image id="${t}" name="${a}">`;s+="1.5.0"===r?`<init_from><ref>${n.textureDirectory}${a}.${o}</ref></init_from>`:`<init_from>${n.textureDirectory}${a}.${o}</init_from>`,s+="</image>",m.push(s),h.set(e,t),v.push({directory:n.textureDirectory,name:a,ext:o,data:i(e.image,o),original:e})}return t}const d=new WeakMap,p=new WeakMap,h=new WeakMap,v=[],m=[],x=[],g=[],y=[],E=function e(t){let n=`<node name="${t.name}">`;if(n+=function(e){return e.updateMatrix(),f=f||new THREE.Matrix4,f.copy(e.matrix),f.transpose(),`<matrix>${f.toArray().join(" ")}</matrix>`}(t),!0===t.isMesh&&null!==t.geometry){const e=function(e){let t=d.get(e);if(!t){const a=e;if(!0!==a.isBufferGeometry)throw new Error("THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.");const i=`Mesh${x.length+1}`,s=a.index?a.index.count*a.index.itemSize:a.attributes.position.count,f=null!=a.groups&&0!==a.groups.length?a.groups:[{start:0,count:s,materialIndex:0}];let u=`<geometry id="${i}"${e.name?` name="${e.name}"`:""}><mesh>`;const p=`${i}-position`,h=`${i}-vertices`;u+=c(a.attributes.position,p,["X","Y","Z"],"float"),u+=`<vertices id="${h}"><input semantic="POSITION" source="#${p}" /></vertices>`;let v=`<input semantic="VERTEX" source="#${h}" offset="0" />`;if("normal"in a.attributes){const e=`${i}-normal`;u+=c(a.attributes.normal,e,["X","Y","Z"],"float"),v+=`<input semantic="NORMAL" source="#${e}" offset="0" />`}if("uv"in a.attributes){const e=`${i}-texcoord`;u+=c(a.attributes.uv,e,["S","T"],"float"),v+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="0" />`}if("uv2"in a.attributes){const e=`${i}-texcoord2`;u+=c(a.attributes.uv2,e,["S","T"],"float"),v+=`<input semantic="TEXCOORD" source="#${e}" offset="0" set="1" />`}if("color"in a.attributes){const e=`${i}-color`;u+=c(a.attributes.color,e,["X","Y","Z"],"uint8"),v+=`<input semantic="COLOR" source="#${e}" offset="0" />`}let m=null;if(a.index)m=l(a.index);else{m=new Array(s);for(let e=0,t=m.length;e<t;e++)m[e]=e}for(let e=0,t=f.length;e<t;e++){const t=f[e],a=(n=m,r=t.start,o=t.count,Array.isArray(n)?n.slice(r,r+o):new n.constructor(n.buffer,r*n.BYTES_PER_ELEMENT,o)),i=a.length/3;u+=`<triangles material="MESH_MATERIAL_${t.materialIndex}" count="${i}">`,u+=v,u+=`<p>${a.join(" ")}</p>`,u+="</triangles>"}u+="</mesh></geometry>",x.push(u),t={meshid:i,bufferGeometry:a},d.set(e,t)}var n,r,o;return t}(t.geometry),r=e.meshid,o=e.bufferGeometry;let a,i=null;const s=t.material||new THREE.MeshBasicMaterial,f=Array.isArray(s)?s:[s];a=o.groups.length>f.length?new Array(o.groups.length):new Array(f.length),i=a.fill().map(((e,t)=>function(e){let t=p.get(e);if(null==t){t=`Mat${g.length+1}`;let n="phong";!0===e.isMeshLambertMaterial?n="lambert":!0===e.isMeshBasicMaterial&&(n="constant",null!==e.map&&console.warn("ColladaExporter: Texture maps not supported with THREE.MeshBasicMaterial."));const r=e.emissive?e.emissive:new THREE.Color(0,0,0),o=e.color?e.color:new THREE.Color(0,0,0),a=e.specular?e.specular:new THREE.Color(1,1,1),i=e.shininess||0,s=e.reflectivity||0;let l="";!0===e.transparent&&(l+="<transparent>"+(e.map?'<texture texture="diffuse-sampler"></texture>':"<float>1</float>")+"</transparent>",e.opacity<1&&(l+=`<transparency><float>${e.opacity}</float></transparency>`));const c=`<technique sid="common"><${n}><emission>`+(e.emissiveMap?'<texture texture="emissive-sampler" texcoord="TEXCOORD" />':`<color sid="emission">${r.r} ${r.g} ${r.b} 1</color>`)+"</emission>"+("constant"!==n?"<diffuse>"+(e.map?'<texture texture="diffuse-sampler" texcoord="TEXCOORD" />':`<color sid="diffuse">${o.r} ${o.g} ${o.b} 1</color>`)+"</diffuse>":"")+("constant"!==n?"<bump>"+(e.normalMap?'<texture texture="bump-sampler" texcoord="TEXCOORD" />':"")+"</bump>":"")+("phong"===n?`<specular><color sid="specular">${a.r} ${a.g} ${a.b} 1</color></specular><shininess>`+(e.specularMap?'<texture texture="specular-sampler" texcoord="TEXCOORD" />':`<float sid="shininess">${i}</float>`)+"</shininess>":"")+`<reflective><color>${o.r} ${o.g} ${o.b} 1</color></reflective>`+`<reflectivity><float>${s}</float></reflectivity>`+l+`</${n}></technique>`,f=`<effect id="${t}-effect"><profile_COMMON>`+(e.map?`<newparam sid="diffuse-surface"><surface type="2D"><init_from>${u(e.map)}</init_from></surface></newparam><newparam sid="diffuse-sampler"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`:"")+(e.specularMap?`<newparam sid="specular-surface"><surface type="2D"><init_from>${u(e.specularMap)}</init_from></surface></newparam><newparam sid="specular-sampler"><sampler2D><source>specular-surface</source></sampler2D></newparam>`:"")+(e.emissiveMap?`<newparam sid="emissive-surface"><surface type="2D"><init_from>${u(e.emissiveMap)}</init_from></surface></newparam><newparam sid="emissive-sampler"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`:"")+(e.normalMap?`<newparam sid="bump-surface"><surface type="2D"><init_from>${u(e.normalMap)}</init_from></surface></newparam><newparam sid="bump-sampler"><sampler2D><source>bump-surface</source></sampler2D></newparam>`:"")+c+(e.side===THREE.DoubleSide?'<extra><technique profile="THREEJS"><double_sided sid="double_sided" type="int">1</double_sided></technique></extra>':"")+"</profile_COMMON></effect>",d=`<material id="${t}"${e.name?` name="${e.name}"`:""}><instance_effect url="#${t}-effect" /></material>`;y.push(d),g.push(f),p.set(e,t)}return t}(f[t%f.length]))),n+=`<instance_geometry url="#${r}">`+(null!=i?"<bind_material><technique_common>"+i.map(((e,t)=>`<instance_material symbol="MESH_MATERIAL_${t}" target="#${e}" ><bind_vertex_input semantic="TEXCOORD" input_semantic="TEXCOORD" input_set="0" /></instance_material>`)).join("")+"</technique_common></bind_material>":"")+"</instance_geometry>"}return t.children.forEach((t=>n+=e(t))),n+="</node>",n}(e);let w=`<?xml version="1.0" encoding="UTF-8" standalone="no" ?><COLLADA xmlns="${"1.4.1"===r?"http://www.collada.org/2005/11/COLLADASchema":"https://www.khronos.org/collada/"}" version="${r}"><asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>`+(null!==n.author?`<author>${n.author}</author>`:"")+"</contributor>"+`<created>${(new Date).toISOString()}</created>`+`<modified>${(new Date).toISOString()}</modified><up_axis>Y_UP</up_axis></asset>`;w+=`<library_images>${m.join("")}</library_images>`,w+=`<library_effects>${g.join("")}</library_effects>`,w+=`<library_materials>${y.join("")}</library_materials>`,w+=`<library_geometries>${x.join("")}</library_geometries>`,w+=`<library_visual_scenes><visual_scene id="Scene" name="scene">${E}</visual_scene></library_visual_scenes>`,w+='<scene><instance_visual_scene url="#Scene"/></scene>',w+="</COLLADA>";const b={data:function(e){const t=/^<\//,n=/(\?>$)|(\/>$)/,r=/<[^>]+>[^<]*<\/[^<]+>/,o=(e,t)=>t>0?e+o(e,t-1):"";let a=0;return e.match(/(<[^>]+>[^<]+<\/[^<]+>)|(<[^>]+>)/g).map((e=>{r.test(e)||n.test(e)||!t.test(e)||a--;const i=`${o("  ",a)}${e}`;return r.test(e)||n.test(e)||t.test(e)||a++,i})).join("\n")}(w),textures:v};return"function"==typeof t&&requestAnimationFrame((()=>t(b))),b}}},1088:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=""===o.path?THREE.LoaderUtils.extractUrlBase(e):o.path,i=new THREE.FileLoader(o.manager);i.setPath(o.path),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(e,(function(n){try{t(o.parse(n,a))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e,t){function n(e,t){const n=[],r=e.childNodes;for(let e=0,o=r.length;e<o;e++){const o=r[e];o.nodeName===t&&n.push(o)}return n}function r(e){if(0===e.length)return[];const t=e.trim().split(/\s+/),n=new Array(t.length);for(let e=0,r=t.length;e<r;e++)n[e]=t[e];return n}function o(e){if(0===e.length)return[];const t=e.trim().split(/\s+/),n=new Array(t.length);for(let e=0,r=t.length;e<r;e++)n[e]=parseFloat(t[e]);return n}function a(e){if(0===e.length)return[];const t=e.trim().split(/\s+/),n=new Array(t.length);for(let e=0,r=t.length;e<r;e++)n[e]=parseInt(t[e]);return n}function i(e){return e.substring(1)}function s(e){return 0===Object.keys(e).length}function l(e){return void 0!==e&&!0===e.hasAttribute("meter")?parseFloat(e.getAttribute("meter")):1}function c(e){return void 0!==e?e.textContent:"Y_UP"}function f(e,t,r,o){const a=n(e,t)[0];if(void 0!==a){const e=n(a,r);for(let t=0;t<e.length;t++)o(e[t])}}function u(e,t){for(const n in e){e[n].build=t(e[n])}}function d(e,t){return void 0!==e.build||(e.build=t(e)),e.build}function p(e){const t={inputs:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"input":const e=i(r.getAttribute("source")),n=r.getAttribute("semantic");t.inputs[n]=e}}return t}function h(e){const t={};let n=e.getAttribute("target").split("/");const r=n.shift();let o=n.shift();const a=-1!==o.indexOf("("),s=-1!==o.indexOf(".");if(s)n=o.split("."),o=n.shift(),t.member=n.shift();else if(a){const e=o.split("(");o=e.shift();for(let t=0;t<e.length;t++)e[t]=parseInt(e[t].replace(/\)/,""));t.indices=e}return t.id=r,t.sid=o,t.arraySyntax=a,t.memberSyntax=s,t.sampler=i(e.getAttribute("source")),t}function v(e){const t=[],n=e.channels,r=e.samplers,o=e.sources;for(const e in n)if(n.hasOwnProperty(e)){const a=n[e],i=r[a.sampler],s=i.inputs.INPUT,l=i.inputs.OUTPUT;w(x(a,o[s],o[l]),t)}return t}function m(e){return d(Ye.animations[e],v)}function x(e,t,n){const r=Ye.nodes[e.id],o=ze(r.id),a=r.transforms[e.sid],i=r.matrix.clone().transpose();let s,l,c,f,u,d;const p={};switch(a){case"matrix":for(c=0,f=t.array.length;c<f;c++)if(s=t.array[c],l=c*n.stride,void 0===p[s]&&(p[s]={}),!0===e.arraySyntax){const t=n.array[l],r=e.indices[0]+4*e.indices[1];p[s][r]=t}else for(u=0,d=n.stride;u<d;u++)p[s][u]=n.array[l+u];break;case"translate":case"rotate":case"scale":console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.',a)}const h=function(e,t){const n=[];for(const t in e)n.push({time:parseFloat(t),value:e[t]});n.sort(r);for(let e=0;e<16;e++)b(n,e,t.elements[e]);return n;function r(e,t){return e.time-t.time}}(p,i);return{name:o.uuid,keyframes:h}}const g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Quaternion;function w(e,t){const n=e.keyframes,r=e.name,o=[],a=[],i=[],s=[];for(let e=0,t=n.length;e<t;e++){const t=n[e],r=t.time,l=t.value;Te.fromArray(l).transpose(),Te.decompose(g,E,y),o.push(r),a.push(g.x,g.y,g.z),i.push(E.x,E.y,E.z,E.w),s.push(y.x,y.y,y.z)}return a.length>0&&t.push(new THREE.VectorKeyframeTrack(r+".position",o,a)),i.length>0&&t.push(new THREE.QuaternionKeyframeTrack(r+".quaternion",o,i)),s.length>0&&t.push(new THREE.VectorKeyframeTrack(r+".scale",o,s)),t}function b(e,t,n){let r,o,a,i=!0;for(o=0,a=e.length;o<a;o++)r=e[o],void 0===r.value[t]?r.value[t]=null:i=!1;if(!0===i)for(o=0,a=e.length;o<a;o++)r=e[o],r.value[t]=n;else!function(e,t){let n,r;for(let o=0,a=e.length;o<a;o++){const a=e[o];if(null===a.value[t]){if(n=_(e,o,t),r=T(e,o,t),null===n){a.value[t]=r.value[t];continue}if(null===r){a.value[t]=n.value[t];continue}A(a,n,r,t)}}}(e,t)}function _(e,t,n){for(;t>=0;){const r=e[t];if(null!==r.value[n])return r;t--}return null}function T(e,t,n){for(;t<e.length;){const r=e[t];if(null!==r.value[n])return r;t++}return null}function A(e,t,n,r){n.time-t.time!=0?e.value[r]=(e.time-t.time)*(n.value[r]-t.value[r])/(n.time-t.time)+t.value[r]:e.value[r]=t.value[r]}function S(e){const t=[],n=e.name,r=e.end-e.start||-1,o=e.animations;for(let e=0,n=o.length;e<n;e++){const n=m(o[e]);for(let e=0,r=n.length;e<r;e++)t.push(n[e])}return new THREE.AnimationClip(n,r,t)}function R(e){return d(Ye.clips[e],S)}function M(e){const t={sources:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"bind_shape_matrix":t.bindShapeMatrix=o(r.textContent);break;case"source":const e=r.getAttribute("id");t.sources[e]=oe(r);break;case"joints":t.joints=C(r);break;case"vertex_weights":t.vertexWeights=L(r)}}return t}function C(e){const t={inputs:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"input":const e=r.getAttribute("semantic"),n=i(r.getAttribute("source"));t.inputs[e]=n}}return t}function L(e){const t={inputs:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"input":const e=r.getAttribute("semantic"),n=i(r.getAttribute("source")),o=parseInt(r.getAttribute("offset"));t.inputs[e]={id:n,offset:o};break;case"vcount":t.vcount=a(r.textContent);break;case"v":t.v=a(r.textContent)}}return t}function P(e){const t={id:e.id},n=Ye.geometries[t.id];return void 0!==e.skin&&(t.skin=function(e){const t=4,n={joints:[],indices:{array:[],stride:t},weights:{array:[],stride:t}},r=e.sources,o=e.vertexWeights,a=o.vcount,i=o.v,s=o.inputs.JOINT.offset,l=o.inputs.WEIGHT.offset,c=e.sources[e.joints.inputs.JOINT],f=e.sources[e.joints.inputs.INV_BIND_MATRIX],u=r[o.inputs.WEIGHT.id].array;let d,p,h,v=0;for(d=0,h=a.length;d<h;d++){const e=a[d],r=[];for(p=0;p<e;p++){const e=i[v+s],t=u[i[v+l]];r.push({index:e,weight:t}),v+=2}for(r.sort(m),p=0;p<t;p++){const e=r[p];void 0!==e?(n.indices.array.push(e.index),n.weights.array.push(e.weight)):(n.indices.array.push(0),n.weights.array.push(0))}}e.bindShapeMatrix?n.bindMatrix=(new THREE.Matrix4).fromArray(e.bindShapeMatrix).transpose():n.bindMatrix=(new THREE.Matrix4).identity();for(d=0,h=c.array.length;d<h;d++){const e=c.array[d],t=(new THREE.Matrix4).fromArray(f.array,d*f.stride).transpose();n.joints.push({name:e,boneInverse:t})}return n;function m(e,t){return t.weight-e.weight}}(e.skin),n.sources.skinIndices=t.skin.indices,n.sources.skinWeights=t.skin.weights),t}function k(e){return void 0!==e.build?e.build:e.init_from}function N(e){const t=Ye.images[e];return void 0!==t?d(t,k):(console.warn("THREE.ColladaLoader: Couldn't find image with ID:",e),null)}function H(e){const t={surfaces:{},samplers:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"newparam":z(r,t);break;case"technique":t.technique=I(r);break;case"extra":t.extra=W(r)}}return t}function z(e,t){const n=e.getAttribute("sid");for(let r=0,o=e.childNodes.length;r<o;r++){const o=e.childNodes[r];if(1===o.nodeType)switch(o.nodeName){case"surface":t.surfaces[n]=D(o);break;case"sampler2D":t.samplers[n]=F(o)}}}function D(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"init_from":t.init_from=r.textContent}}return t}function F(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"source":t.source=r.textContent}}return t}function I(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"constant":case"lambert":case"blinn":case"phong":t.type=r.nodeName,t.parameters=O(r)}}return t}function O(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"emission":case"diffuse":case"specular":case"bump":case"ambient":case"shininess":case"transparency":t[r.nodeName]=U(r);break;case"transparent":t[r.nodeName]={opaque:r.getAttribute("opaque"),data:U(r)}}}return t}function U(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"color":t[r.nodeName]=o(r.textContent);break;case"float":t[r.nodeName]=parseFloat(r.textContent);break;case"texture":t[r.nodeName]={id:r.getAttribute("texture"),extra:G(r)}}}return t}function G(e){const t={technique:{}};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"extra":B(r,t)}}return t}function B(e,t){for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"technique":V(r,t)}}}function V(e,t){for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"repeatU":case"repeatV":case"offsetU":case"offsetV":t.technique[r.nodeName]=parseFloat(r.textContent);break;case"wrapU":case"wrapV":"TRUE"===r.textContent.toUpperCase()?t.technique[r.nodeName]=1:"FALSE"===r.textContent.toUpperCase()?t.technique[r.nodeName]=0:t.technique[r.nodeName]=parseInt(r.textContent)}}}function W(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"technique":t.technique=j(r)}}return t}function j(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"double_sided":t[r.nodeName]=parseInt(r.textContent)}}return t}function q(e){return e}function X(e){const t=(n=e.url,d(Ye.effects[n],q));var n;const r=t.profile.technique,o=t.profile.extra;let a;switch(r.type){case"phong":case"blinn":a=new THREE.MeshPhongMaterial;break;case"lambert":a=new THREE.MeshLambertMaterial;break;default:a=new THREE.MeshBasicMaterial}function i(e){const n=t.profile.samplers[e.id];let r=null;if(void 0!==n){r=N(t.profile.surfaces[n.source].init_from)}else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."),r=N(e.id);if(null!==r){const t=function(e){let t,n=e.slice(2+(e.lastIndexOf(".")-1>>>0));switch(n=n.toLowerCase(),n){case"tga":t=We;break;default:t=Ve}return t}(r);if(void 0!==t){const n=t.load(r),o=e.extra;if(void 0!==o&&void 0!==o.technique&&!1===s(o.technique)){const e=o.technique;n.wrapS=e.wrapU?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,n.wrapT=e.wrapV?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,n.offset.set(e.offsetU||0,e.offsetV||0),n.repeat.set(e.repeatU||1,e.repeatV||1)}else n.wrapS=THREE.RepeatWrapping,n.wrapT=THREE.RepeatWrapping;return n}return console.warn("THREE.ColladaLoader: THREE.Loader for texture %s not found.",r),null}return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:",e.id),null}a.name=e.name||"";const l=r.parameters;for(const e in l){const t=l[e];switch(e){case"diffuse":t.color&&a.color.fromArray(t.color),t.texture&&(a.map=i(t.texture));break;case"specular":t.color&&a.specular&&a.specular.fromArray(t.color),t.texture&&(a.specularMap=i(t.texture));break;case"bump":t.texture&&(a.normalMap=i(t.texture));break;case"ambient":t.texture&&(a.lightMap=i(t.texture));break;case"shininess":t.float&&a.shininess&&(a.shininess=t.float);break;case"emission":t.color&&a.emissive&&a.emissive.fromArray(t.color),t.texture&&(a.emissiveMap=i(t.texture))}}let c=l.transparent,f=l.transparency;if(void 0===f&&c&&(f={float:1}),void 0===c&&f&&(c={opaque:"A_ONE",data:{color:[1,1,1,1]}}),c&&f)if(c.data.texture)a.transparent=!0;else{const e=c.data.color;switch(c.opaque){case"A_ONE":a.opacity=e[3]*f.float;break;case"RGB_ZERO":a.opacity=1-e[0]*f.float;break;case"A_ZERO":a.opacity=1-e[3]*f.float;break;case"RGB_ONE":a.opacity=e[0]*f.float;break;default:console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.',c.opaque)}a.opacity<1&&(a.transparent=!0)}return void 0!==o&&void 0!==o.technique&&1===o.technique.double_sided&&(a.side=THREE.DoubleSide),a}function Y(e){return d(Ye.materials[e],X)}function Q(e){for(let t=0;t<e.childNodes.length;t++){const n=e.childNodes[t];switch(n.nodeName){case"technique_common":return K(n)}}return{}}function K(e){const t={};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];switch(r.nodeName){case"perspective":case"orthographic":t.technique=r.nodeName,t.parameters=Z(r)}}return t}function Z(e){const t={};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];switch(r.nodeName){case"xfov":case"yfov":case"xmag":case"ymag":case"znear":case"zfar":case"aspect_ratio":t[r.nodeName]=parseFloat(r.textContent)}}return t}function J(e){let t;switch(e.optics.technique){case"perspective":t=new THREE.PerspectiveCamera(e.optics.parameters.yfov,e.optics.parameters.aspect_ratio,e.optics.parameters.znear,e.optics.parameters.zfar);break;case"orthographic":let n=e.optics.parameters.ymag,r=e.optics.parameters.xmag;const o=e.optics.parameters.aspect_ratio;r=void 0===r?n*o:r,n=void 0===n?r/o:n,r*=.5,n*=.5,t=new THREE.OrthographicCamera(-r,r,n,-n,e.optics.parameters.znear,e.optics.parameters.zfar);break;default:t=new THREE.PerspectiveCamera}return t.name=e.name||"",t}function $(e){const t=Ye.cameras[e];return void 0!==t?d(t,J):(console.warn("THREE.ColladaLoader: Couldn't find camera with ID:",e),null)}function ee(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"directional":case"point":case"spot":case"ambient":t.technique=r.nodeName,t.parameters=te(r)}}return t}function te(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"color":const e=o(r.textContent);t.color=(new THREE.Color).fromArray(e);break;case"falloff_angle":t.falloffAngle=parseFloat(r.textContent);break;case"quadratic_attenuation":const n=parseFloat(r.textContent);t.distance=n?Math.sqrt(1/n):0}}return t}function ne(e){let t;switch(e.technique){case"directional":t=new THREE.DirectionalLight;break;case"point":t=new THREE.PointLight;break;case"spot":t=new THREE.SpotLight;break;case"ambient":t=new THREE.AmbientLight}return e.parameters.color&&t.color.copy(e.parameters.color),e.parameters.distance&&(t.distance=e.parameters.distance),t}function re(e){const t=Ye.lights[e];return void 0!==t?d(t,ne):(console.warn("THREE.ColladaLoader: Couldn't find light with ID:",e),null)}function oe(e){const t={array:[],stride:3};for(let a=0;a<e.childNodes.length;a++){const i=e.childNodes[a];if(1===i.nodeType)switch(i.nodeName){case"float_array":t.array=o(i.textContent);break;case"Name_array":t.array=r(i.textContent);break;case"technique_common":const e=n(i,"accessor")[0];void 0!==e&&(t.stride=parseInt(e.getAttribute("stride")))}}return t}function ae(e){const t={};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];1===r.nodeType&&(t[r.getAttribute("semantic")]=i(r.getAttribute("source")))}return t}function ie(e){const t={type:e.nodeName,material:e.getAttribute("material"),count:parseInt(e.getAttribute("count")),inputs:{},stride:0,hasUV:!1};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"input":const e=i(r.getAttribute("source")),n=r.getAttribute("semantic"),o=parseInt(r.getAttribute("offset")),s=parseInt(r.getAttribute("set")),l=s>0?n+s:n;t.inputs[l]={id:e,offset:o},t.stride=Math.max(t.stride,o+1),"TEXCOORD"===n&&(t.hasUV=!0);break;case"vcount":t.vcount=a(r.textContent);break;case"p":t.p=a(r.textContent)}}return t}function se(e){let t=0;for(let n=0,r=e.length;n<r;n++){!0===e[n].hasUV&&t++}t>0&&t<e.length&&(e.uvsNeedsFix=!0)}function le(e){const t={},n=e.sources,r=e.vertices,o=e.primitives;if(0===o.length)return{};const a=function(e){const t={};for(let n=0;n<e.length;n++){const r=e[n];void 0===t[r.type]&&(t[r.type]=[]),t[r.type].push(r)}return t}(o);for(const e in a){const o=a[e];se(o),t[e]=ce(o,n,r)}return t}function ce(e,t,n){const r={},o={array:[],stride:0},a={array:[],stride:0},i={array:[],stride:0},s={array:[],stride:0},l={array:[],stride:0},c=[],f=4,u=[],d=4,p=new THREE.BufferGeometry,h=[];let v=0;for(let r=0;r<e.length;r++){const f=e[r],d=f.inputs;let m=0;switch(f.type){case"lines":case"linestrips":m=2*f.count;break;case"triangles":m=3*f.count;break;case"polylist":for(let e=0;e<f.count;e++){const t=f.vcount[e];switch(t){case 3:m+=3;break;case 4:m+=6;break;default:m+=3*(t-2)}}break;default:console.warn("THREE.ColladaLoader: Unknow primitive type:",f.type)}p.addGroup(v,m,r),v+=m,f.material&&h.push(f.material);for(const r in d){const p=d[r];switch(r){case"VERTEX":for(const r in n){const d=n[r];switch(r){case"POSITION":const n=o.array.length;if(fe(f,t[d],p.offset,o.array),o.stride=t[d].stride,t.skinWeights&&t.skinIndices&&(fe(f,t.skinIndices,p.offset,c),fe(f,t.skinWeights,p.offset,u)),!1===f.hasUV&&!0===e.uvsNeedsFix){const e=(o.array.length-n)/o.stride;for(let t=0;t<e;t++)i.array.push(0,0)}break;case"NORMAL":fe(f,t[d],p.offset,a.array),a.stride=t[d].stride;break;case"COLOR":fe(f,t[d],p.offset,l.array),l.stride=t[d].stride;break;case"TEXCOORD":fe(f,t[d],p.offset,i.array),i.stride=t[d].stride;break;case"TEXCOORD1":fe(f,t[d],p.offset,s.array),i.stride=t[d].stride;break;default:console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.',r)}}break;case"NORMAL":fe(f,t[p.id],p.offset,a.array),a.stride=t[p.id].stride;break;case"COLOR":fe(f,t[p.id],p.offset,l.array),l.stride=t[p.id].stride;break;case"TEXCOORD":fe(f,t[p.id],p.offset,i.array),i.stride=t[p.id].stride;break;case"TEXCOORD1":fe(f,t[p.id],p.offset,s.array),s.stride=t[p.id].stride}}}return o.array.length>0&&p.setAttribute("position",new THREE.Float32BufferAttribute(o.array,o.stride)),a.array.length>0&&p.setAttribute("normal",new THREE.Float32BufferAttribute(a.array,a.stride)),l.array.length>0&&p.setAttribute("color",new THREE.Float32BufferAttribute(l.array,l.stride)),i.array.length>0&&p.setAttribute("uv",new THREE.Float32BufferAttribute(i.array,i.stride)),s.array.length>0&&p.setAttribute("uv2",new THREE.Float32BufferAttribute(s.array,s.stride)),c.length>0&&p.setAttribute("skinIndex",new THREE.Float32BufferAttribute(c,f)),u.length>0&&p.setAttribute("skinWeight",new THREE.Float32BufferAttribute(u,d)),r.data=p,r.type=e[0].type,r.materialKeys=h,r}function fe(e,t,n,r){const o=e.p,a=e.stride,i=e.vcount;function s(e){let t=o[e+n]*c;const a=t+c;for(;t<a;t++)r.push(l[t])}const l=t.array,c=t.stride;if(void 0!==e.vcount){let e=0;for(let t=0,n=i.length;t<n;t++){const n=i[t];if(4===n){const t=e+1*a,n=e+2*a,r=e+3*a;s(e+0*a),s(t),s(r),s(t),s(n),s(r)}else if(3===n){const t=e+1*a,n=e+2*a;s(e+0*a),s(t),s(n)}else if(n>4)for(let t=1,r=n-2;t<=r;t++){const n=e+a*t,r=e+a*(t+1);s(e+0*a),s(n),s(r)}e+=a*n}}else for(let e=0,t=o.length;e<t;e+=a)s(e)}function ue(e){return d(Ye.geometries[e],le)}function de(e){return void 0!==e.build?e.build:e}function pe(e,t){for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"joint":t.joints[r.getAttribute("sid")]=he(r);break;case"link":t.links.push(me(r))}}}function he(e){let t;for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"prismatic":case"revolute":t=ve(r)}}return t}function ve(e){const t={sid:e.getAttribute("sid"),name:e.getAttribute("name")||"",axis:new THREE.Vector3,limits:{min:0,max:0},type:e.nodeName,static:!1,zeroPosition:0,middlePosition:0};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"axis":const e=o(r.textContent);t.axis.fromArray(e);break;case"limits":const n=r.getElementsByTagName("max")[0],a=r.getElementsByTagName("min")[0];t.limits.max=parseFloat(n.textContent),t.limits.min=parseFloat(a.textContent)}}return t.limits.min>=t.limits.max&&(t.static=!0),t.middlePosition=(t.limits.min+t.limits.max)/2,t}function me(e){const t={sid:e.getAttribute("sid"),name:e.getAttribute("name")||"",attachments:[],transforms:[]};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"attachment_full":t.attachments.push(xe(r));break;case"matrix":case"translate":case"rotate":t.transforms.push(ge(r))}}return t}function xe(e){const t={joint:e.getAttribute("joint").split("/").pop(),transforms:[],links:[]};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"link":t.links.push(me(r));break;case"matrix":case"translate":case"rotate":t.transforms.push(ge(r))}}return t}function ge(e){const t={type:e.nodeName},n=o(e.textContent);switch(t.type){case"matrix":t.obj=new THREE.Matrix4,t.obj.fromArray(n).transpose();break;case"translate":t.obj=new THREE.Vector3,t.obj.fromArray(n);break;case"rotate":t.obj=new THREE.Vector3,t.obj.fromArray(n),t.angle=THREE.MathUtils.degToRad(n[3])}return t}function ye(e,t){for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"technique_common":Ee(r,t)}}}function Ee(e,t){for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"inertia":t.inertia=o(r.textContent);break;case"mass":t.mass=o(r.textContent)[0]}}}function we(e){const t={target:e.getAttribute("target").split("/").pop()};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"axis":const e=r.getElementsByTagName("param")[0];t.axis=e.textContent;const n=t.axis.split("inst_").pop().split("axis")[0];t.jointIndex=n.substr(0,n.length-1)}}return t}function be(e){return void 0!==e.build?e.build:e}function _e(e){const t=[],n=Oe.querySelector('[id="'+e.id+'"]');for(let e=0;e<n.childNodes.length;e++){const r=n.childNodes[e];if(1!==r.nodeType)continue;let a,i;switch(r.nodeName){case"matrix":a=o(r.textContent);const e=(new THREE.Matrix4).fromArray(a).transpose();t.push({sid:r.getAttribute("sid"),type:r.nodeName,obj:e});break;case"translate":case"scale":a=o(r.textContent),i=(new THREE.Vector3).fromArray(a),t.push({sid:r.getAttribute("sid"),type:r.nodeName,obj:i});break;case"rotate":a=o(r.textContent),i=(new THREE.Vector3).fromArray(a);const n=THREE.MathUtils.degToRad(a[3]);t.push({sid:r.getAttribute("sid"),type:r.nodeName,obj:i,angle:n})}}return t}const Te=new THREE.Matrix4,Ae=new THREE.Vector3;function Se(e){const t={name:e.getAttribute("name")||"",type:e.getAttribute("type"),id:e.getAttribute("id"),sid:e.getAttribute("sid"),matrix:new THREE.Matrix4,nodes:[],instanceCameras:[],instanceControllers:[],instanceLights:[],instanceGeometries:[],instanceNodes:[],transforms:{}};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1!==r.nodeType)continue;let a;switch(r.nodeName){case"node":t.nodes.push(r.getAttribute("id")),Se(r);break;case"instance_camera":t.instanceCameras.push(i(r.getAttribute("url")));break;case"instance_controller":t.instanceControllers.push(Re(r));break;case"instance_light":t.instanceLights.push(i(r.getAttribute("url")));break;case"instance_geometry":t.instanceGeometries.push(Re(r));break;case"instance_node":t.instanceNodes.push(i(r.getAttribute("url")));break;case"matrix":a=o(r.textContent),t.matrix.multiply(Te.fromArray(a).transpose()),t.transforms[r.getAttribute("sid")]=r.nodeName;break;case"translate":a=o(r.textContent),Ae.fromArray(a),t.matrix.multiply(Te.makeTranslation(Ae.x,Ae.y,Ae.z)),t.transforms[r.getAttribute("sid")]=r.nodeName;break;case"rotate":a=o(r.textContent);const e=THREE.MathUtils.degToRad(a[3]);t.matrix.multiply(Te.makeRotationAxis(Ae.fromArray(a),e)),t.transforms[r.getAttribute("sid")]=r.nodeName;break;case"scale":a=o(r.textContent),t.matrix.scale(Ae.fromArray(a)),t.transforms[r.getAttribute("sid")]=r.nodeName;break;case"extra":break;default:console.log(r)}}return He(t.id)?console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.",t.id):Ye.nodes[t.id]=t,t}function Re(e){const t={id:i(e.getAttribute("url")),materials:{},skeletons:[]};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];switch(r.nodeName){case"bind_material":const e=r.getElementsByTagName("instance_material");for(let n=0;n<e.length;n++){const r=e[n],o=r.getAttribute("symbol"),a=r.getAttribute("target");t.materials[o]=i(a)}break;case"skeleton":t.skeletons.push(i(r.textContent))}}return t}function Me(e,t){const n=[],r=[];let o,a,i;for(o=0;o<e.length;o++){const r=e[o];let a;if(He(r))a=ze(r),Ce(a,t,n);else if(s=r,void 0!==Ye.visualScenes[s]){const e=Ye.visualScenes[r].children;for(let r=0;r<e.length;r++){const o=e[r];if("JOINT"===o.type){Ce(ze(o.id),t,n)}}}else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:",r)}var s;for(o=0;o<t.length;o++)for(a=0;a<n.length;a++)if(i=n[a],i.bone.name===t[o].name){r[o]=i,i.processed=!0;break}for(o=0;o<n.length;o++)i=n[o],!1===i.processed&&(r.push(i),i.processed=!0);const l=[],c=[];for(o=0;o<r.length;o++)i=r[o],l.push(i.bone),c.push(i.boneInverse);return new THREE.Skeleton(l,c)}function Ce(e,t,n){e.traverse((function(e){if(!0===e.isBone){let r;for(let n=0;n<t.length;n++){const o=t[n];if(o.name===e.name){r=o.boneInverse;break}}void 0===r&&(r=new THREE.Matrix4),n.push({bone:e,boneInverse:r,processed:!1})}}))}function Le(e){const t=[],n=e.matrix,r=e.nodes,o=e.type,a=e.instanceCameras,i=e.instanceControllers,s=e.instanceLights,l=e.instanceGeometries,c=e.instanceNodes;for(let e=0,n=r.length;e<n;e++)t.push(ze(r[e]));for(let e=0,n=a.length;e<n;e++){const n=$(a[e]);null!==n&&t.push(n.clone())}for(let e=0,n=i.length;e<n;e++){const n=i[e],r=(f=n.id,d(Ye.controllers[f],P)),o=Ne(ue(r.id),n.materials),a=Me(n.skeletons,r.skin.joints);for(let e=0,n=o.length;e<n;e++){const n=o[e];n.isSkinnedMesh&&(n.bind(a,r.skin.bindMatrix),n.normalizeSkinWeights()),t.push(n)}}var f;for(let e=0,n=s.length;e<n;e++){const n=re(s[e]);null!==n&&t.push(n.clone())}for(let e=0,n=l.length;e<n;e++){const n=l[e],r=Ne(ue(n.id),n.materials);for(let e=0,n=r.length;e<n;e++)t.push(r[e])}for(let e=0,n=c.length;e<n;e++)t.push(ze(c[e]).clone());let u;if(0===r.length&&1===t.length)u=t[0];else{u="JOINT"===o?new THREE.Bone:new THREE.Group;for(let e=0;e<t.length;e++)u.add(t[e])}return u.name="JOINT"===o?e.sid:e.name,u.matrix.copy(n),u.matrix.decompose(u.position,u.quaternion,u.scale),u}const Pe=new THREE.MeshBasicMaterial({color:16711935});function ke(e,t){const n=[];for(let r=0,o=e.length;r<o;r++){const o=t[e[r]];void 0===o?(console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.",e[r]),n.push(Pe)):n.push(Y(o))}return n}function Ne(e,t){const n=[];for(const r in e){const o=e[r],a=ke(o.materialKeys,t);0===a.length&&("lines"===r||"linestrips"===r?a.push(new THREE.LineBasicMaterial):a.push(new THREE.MeshPhongMaterial));const i=void 0!==o.data.attributes.skinIndex;if(i)for(let e=0,t=a.length;e<t;e++)a[e].skinning=!0;const s=1===a.length?a[0]:a;let l;switch(r){case"lines":l=new THREE.LineSegments(o.data,s);break;case"linestrips":l=new THREE.Line(o.data,s);break;case"triangles":case"polylist":l=i?new THREE.SkinnedMesh(o.data,s):new THREE.Mesh(o.data,s)}n.push(l)}return n}function He(e){return void 0!==Ye.nodes[e]}function ze(e){return d(Ye.nodes[e],Le)}function De(e){const t=new THREE.Group;t.name=e.name;const n=e.children;for(let e=0;e<n.length;e++){const r=n[e];t.add(ze(r.id))}return t}function Fe(e){return d(Ye.visualScenes[e],De)}if(0===e.length)return{scene:new THREE.Scene};const Ie=(new DOMParser).parseFromString(e,"application/xml"),Oe=n(Ie,"COLLADA")[0],Ue=Ie.getElementsByTagName("parsererror")[0];if(void 0!==Ue){const e=n(Ue,"div")[0];let t;return t=e?e.textContent:function(e){let t="";const n=[e];for(;n.length;){const e=n.shift();e.nodeType===Node.TEXT_NODE?t+=e.textContent:(t+="\n",n.push.apply(n,e.childNodes))}return t.trim()}(Ue),console.error("THREE.ColladaLoader: Failed to parse collada file.\n",t),null}const Ge=Oe.getAttribute("version");console.log("THREE.ColladaLoader: File version",Ge);const Be=function(e){return{unit:l(n(e,"unit")[0]),upAxis:c(n(e,"up_axis")[0])}}(n(Oe,"asset")[0]),Ve=new THREE.TextureLoader(this.manager);let We;Ve.setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin),THREE.TGALoader&&(We=new THREE.TGALoader(this.manager),We.setPath(this.resourcePath||t));const je=[];let qe={},Xe=0;const Ye={animations:{},clips:{},controllers:{},images:{},effects:{},materials:{},cameras:{},lights:{},geometries:{},nodes:{},visualScenes:{},kinematicsModels:{},physicsModels:{},kinematicsScenes:{}};f(Oe,"library_animations","animation",(function e(t){const n={sources:{},samplers:{},channels:{}};let r=!1;for(let o=0,a=t.childNodes.length;o<a;o++){const a=t.childNodes[o];if(1!==a.nodeType)continue;let i;switch(a.nodeName){case"source":i=a.getAttribute("id"),n.sources[i]=oe(a);break;case"sampler":i=a.getAttribute("id"),n.samplers[i]=p(a);break;case"channel":i=a.getAttribute("target"),n.channels[i]=h(a);break;case"animation":e(a),r=!0;break;default:console.log(a)}}!1===r&&(Ye.animations[t.getAttribute("id")||THREE.MathUtils.generateUUID()]=n)})),f(Oe,"library_animation_clips","animation_clip",(function(e){const t={name:e.getAttribute("id")||"default",start:parseFloat(e.getAttribute("start")||0),end:parseFloat(e.getAttribute("end")||0),animations:[]};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"instance_animation":t.animations.push(i(r.getAttribute("url")))}}Ye.clips[e.getAttribute("id")]=t})),f(Oe,"library_controllers","controller",(function(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"skin":t.id=i(r.getAttribute("source")),t.skin=M(r);break;case"morph":t.id=i(r.getAttribute("source")),console.warn("THREE.ColladaLoader: Morph target animation not supported yet.")}}Ye.controllers[e.getAttribute("id")]=t})),f(Oe,"library_images","image",(function(e){const t={init_from:n(e,"init_from")[0].textContent};Ye.images[e.getAttribute("id")]=t})),f(Oe,"library_effects","effect",(function(e){const t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"profile_COMMON":t.profile=H(r)}}Ye.effects[e.getAttribute("id")]=t})),f(Oe,"library_materials","material",(function(e){const t={name:e.getAttribute("name")};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"instance_effect":t.url=i(r.getAttribute("url"))}}Ye.materials[e.getAttribute("id")]=t})),f(Oe,"library_cameras","camera",(function(e){const t={name:e.getAttribute("name")};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"optics":t.optics=Q(r)}}Ye.cameras[e.getAttribute("id")]=t})),f(Oe,"library_lights","light",(function(e){let t={};for(let n=0,r=e.childNodes.length;n<r;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"technique_common":t=ee(r)}}Ye.lights[e.getAttribute("id")]=t})),f(Oe,"library_geometries","geometry",(function(e){const t={name:e.getAttribute("name"),sources:{},vertices:{},primitives:[]},r=n(e,"mesh")[0];if(void 0!==r){for(let e=0;e<r.childNodes.length;e++){const n=r.childNodes[e];if(1!==n.nodeType)continue;const o=n.getAttribute("id");switch(n.nodeName){case"source":t.sources[o]=oe(n);break;case"vertices":t.vertices=ae(n);break;case"polygons":console.warn("THREE.ColladaLoader: Unsupported primitive type: ",n.nodeName);break;case"lines":case"linestrips":case"polylist":case"triangles":t.primitives.push(ie(n));break;default:console.log(n)}}Ye.geometries[e.getAttribute("id")]=t}})),f(Oe,"library_nodes","node",Se),f(Oe,"library_visual_scenes","visual_scene",(function(e){const t={name:e.getAttribute("name"),children:[]};!function(e){const t=e.getElementsByTagName("node");for(let e=0;e<t.length;e++){const n=t[e];!1===n.hasAttribute("id")&&n.setAttribute("id","three_default_"+Xe++)}}(e);const r=n(e,"node");for(let e=0;e<r.length;e++)t.children.push(Se(r[e]));Ye.visualScenes[e.getAttribute("id")]=t})),f(Oe,"library_kinematics_models","kinematics_model",(function(e){const t={name:e.getAttribute("name")||"",joints:{},links:[]};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"technique_common":pe(r,t)}}Ye.kinematicsModels[e.getAttribute("id")]=t})),f(Oe,"library_physics_models","physics_model",(function(e){const t={name:e.getAttribute("name")||"",rigidBodies:{}};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"rigid_body":t.rigidBodies[r.getAttribute("name")]={},ye(r,t.rigidBodies[r.getAttribute("name")])}}Ye.physicsModels[e.getAttribute("id")]=t})),f(Oe,"scene","instance_kinematics_scene",(function(e){const t={bindJointAxis:[]};for(let n=0;n<e.childNodes.length;n++){const r=e.childNodes[n];if(1===r.nodeType)switch(r.nodeName){case"bind_joint_axis":t.bindJointAxis.push(we(r))}}Ye.kinematicsScenes[i(e.getAttribute("url"))]=t})),u(Ye.animations,v),u(Ye.clips,S),u(Ye.controllers,P),u(Ye.images,k),u(Ye.effects,q),u(Ye.materials,X),u(Ye.cameras,J),u(Ye.lights,ne),u(Ye.geometries,le),u(Ye.visualScenes,De),function(){const e=Ye.clips;if(!0===s(e)){if(!1===s(Ye.animations)){const e=[];for(const t in Ye.animations){const n=m(t);for(let t=0,r=n.length;t<r;t++)e.push(n[t])}je.push(new THREE.AnimationClip("default",-1,e))}}else for(const t in e)je.push(R(t))}(),function(){const e=Object.keys(Ye.kinematicsModels)[0],t=Object.keys(Ye.kinematicsScenes)[0],n=Object.keys(Ye.visualScenes)[0];if(void 0===e||void 0===t)return;const r=(o=e,d(Ye.kinematicsModels[o],de));var o;const a=function(e){return d(Ye.kinematicsScenes[e],be)}(t),i=Fe(n),s=a.bindJointAxis,l={};for(let e=0,t=s.length;e<t;e++){const t=s[e],n=Oe.querySelector('[sid="'+t.target+'"]');if(n){const e=n.parentElement;c(t.jointIndex,e)}}function c(e,t){const n=t.getAttribute("name"),o=r.joints[e];i.traverse((function(r){r.name===n&&(l[e]={object:r,transforms:_e(t),joint:o,position:o.zeroPosition})}))}const f=new THREE.Matrix4;qe={joints:r&&r.joints,getJointValue:function(e){const t=l[e];if(t)return t.position;console.warn("THREE.ColladaLoader: Joint "+e+" doesn't exist.")},setJointValue:function(e,t){const n=l[e];if(n){const r=n.joint;if(t>r.limits.max||t<r.limits.min)console.warn("THREE.ColladaLoader: Joint "+e+" value "+t+" outside of limits (min: "+r.limits.min+", max: "+r.limits.max+").");else if(r.static)console.warn("THREE.ColladaLoader: Joint "+e+" is static.");else{const o=n.object,a=r.axis,i=n.transforms;Te.identity();for(let n=0;n<i.length;n++){const o=i[n];if(o.sid&&-1!==o.sid.indexOf(e))switch(r.type){case"revolute":Te.multiply(f.makeRotationAxis(a,THREE.MathUtils.degToRad(t)));break;case"prismatic":Te.multiply(f.makeTranslation(a.x*t,a.y*t,a.z*t));break;default:console.warn("THREE.ColladaLoader: Unknown joint type: "+r.type)}else switch(o.type){case"matrix":Te.multiply(o.obj);break;case"translate":Te.multiply(f.makeTranslation(o.obj.x,o.obj.y,o.obj.z));break;case"scale":Te.scale(o.obj);break;case"rotate":Te.multiply(f.makeRotationAxis(o.obj,o.angle))}}o.matrix.copy(Te),o.matrix.decompose(o.position,o.quaternion,o.scale),l[e].position=t}}else console.log("THREE.ColladaLoader: "+e+" does not exist.")}}}();const Qe=function(e){return Fe(i(n(e,"instance_visual_scene")[0].getAttribute("url")))}(n(Oe,"scene")[0]);return Qe.animations=je,"Z_UP"===Be.upAxis&&Qe.quaternion.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)),Qe.scale.multiplyScalar(Be.unit),{get animations(){return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."),je},kinematics:qe,library:Ye,scene:Qe}}}THREE.ColladaLoader=e}()},864:()=>{!function(){const e=new THREE.Vector3,t=new THREE.Line3,n=new THREE.Plane,r=new THREE.Vector3,o=new THREE.Triangle;class a{constructor(){this.normal=new THREE.Vector3,this.midpoint=new THREE.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}static create(e,t,n){const r=new a,o=new i(e,r),s=new i(t,r),l=new i(n,r);return o.next=l.prev=s,s.next=o.prev=l,l.next=s.prev=o,r.edge=o,r.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return o.set(e.point,t.point,n.point),o.getNormal(this.normal),o.getMidpoint(this.midpoint),this.area=o.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class i{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return null!==t?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return null!==t?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class s{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class l{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,null===t.prev?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,null===t.next?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail;null!==e.next;)e=e.next;return this.tail=e,this}remove(e){return null===e.prev?this.head=e.next:e.prev.next=e.next,null===e.next?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return null===e.prev?this.head=t.next:e.prev.next=t.next,null===t.next?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return null===this.head}}THREE.ConvexHull=class{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new l,this.unassigned=new l,this.vertices=[]}setFromPoints(e){!0!==Array.isArray(e)&&console.error("THREE.ConvexHull: Points parameter is not an array."),e.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.vertices.push(new s(e[t]));return this.compute(),this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse((function(e){const n=e.geometry;if(void 0!==n){if(n.isGeometry)return void console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");if(n.isBufferGeometry){const r=n.attributes.position;if(void 0!==r)for(let n=0,o=r.count;n<o;n++){const o=new THREE.Vector3;o.fromBufferAttribute(r,n).applyMatrix4(e.matrixWorld),t.push(o)}}}})),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let n=0,r=t.length;n<r;n++){if(t[n].distanceToPoint(e)>this.tolerance)return!1}return!0}intersectRay(e,t){const n=this.faces;let r=-1/0,o=1/0;for(let t=0,a=n.length;t<a;t++){const a=n[t],i=a.distanceToPoint(e.origin),s=a.normal.dot(e.direction);if(i>0&&s>=0)return null;const l=0!==s?-i/s:0;if(!(l<=0)&&(s>0?o=Math.min(l,o):r=Math.max(l,r),r>o))return null}return r!==-1/0?e.at(r,t):e.at(o,t),t}intersectsRay(t){return null!==this.intersectRay(t,e)}makeEmpty(){return this.faces=[],this.vertices=[],this}addVertexToFace(e,t){return e.face=t,null===t.outside?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}removeVertexFromFace(e,t){return e===t.outside&&(null!==e.next&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}removeAllVerticesFromFace(e){if(null!==e.outside){const t=e.outside;let n=e.outside;for(;null!==n.next&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}}deleteFaceVertices(e,t){const n=this.removeAllVerticesFromFace(e);if(void 0!==n)if(void 0===t)this.unassigned.appendChain(n);else{let e=n;do{const n=e.next;t.distanceToPoint(e.point)>this.tolerance?this.addVertexToFace(e,t):this.unassigned.append(e),e=n}while(null!==e)}return this}resolveUnassignedPoints(e){if(!1===this.unassigned.isEmpty()){let t=this.unassigned.first();do{const n=t.next;let r=this.tolerance,o=null;for(let n=0;n<e.length;n++){const a=e[n];if(0===a.mark){const e=a.distanceToPoint(t.point);if(e>r&&(r=e,o=a),r>1e3*this.tolerance)break}}null!==o&&this.addVertexToFace(t,o),t=n}while(null!==t)}return this}computeExtremes(){const e=new THREE.Vector3,t=new THREE.Vector3,n=[],r=[];for(let e=0;e<3;e++)n[e]=r[e]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let o=0,a=this.vertices.length;o<a;o++){const a=this.vertices[o],i=a.point;for(let t=0;t<3;t++)i.getComponent(t)<e.getComponent(t)&&(e.setComponent(t,i.getComponent(t)),n[t]=a);for(let e=0;e<3;e++)i.getComponent(e)>t.getComponent(e)&&(t.setComponent(e,i.getComponent(e)),r[e]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:n,max:r}}computeInitialHull(){const e=this.vertices,o=this.computeExtremes(),i=o.min,s=o.max;let l=0,c=0;for(let e=0;e<3;e++){const t=s[e].point.getComponent(e)-i[e].point.getComponent(e);t>l&&(l=t,c=e)}const f=i[c],u=s[c];let d,p;l=0,t.set(f.point,u.point);for(let n=0,o=this.vertices.length;n<o;n++){const o=e[n];if(o!==f&&o!==u){t.closestPointToPoint(o.point,!0,r);const e=r.distanceToSquared(o.point);e>l&&(l=e,d=o)}}l=-1,n.setFromCoplanarPoints(f.point,u.point,d.point);for(let t=0,r=this.vertices.length;t<r;t++){const r=e[t];if(r!==f&&r!==u&&r!==d){const e=Math.abs(n.distanceToPoint(r.point));e>l&&(l=e,p=r)}}const h=[];if(n.distanceToPoint(p.point)<0){h.push(a.create(f,u,d),a.create(p,u,f),a.create(p,d,u),a.create(p,f,d));for(let e=0;e<3;e++){const t=(e+1)%3;h[e+1].getEdge(2).setTwin(h[0].getEdge(t)),h[e+1].getEdge(1).setTwin(h[t+1].getEdge(0))}}else{h.push(a.create(f,d,u),a.create(p,f,u),a.create(p,u,d),a.create(p,d,f));for(let e=0;e<3;e++){const t=(e+1)%3;h[e+1].getEdge(2).setTwin(h[0].getEdge((3-e)%3)),h[e+1].getEdge(0).setTwin(h[t+1].getEdge(1))}}for(let e=0;e<4;e++)this.faces.push(h[e]);for(let t=0,n=e.length;t<n;t++){const n=e[t];if(n!==f&&n!==u&&n!==d&&n!==p){l=this.tolerance;let e=null;for(let t=0;t<4;t++){const r=this.faces[t].distanceToPoint(n.point);r>l&&(l=r,e=this.faces[t])}null!==e&&this.addVertexToFace(n,e)}}return this}reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const n=this.faces[t];0===n.mark&&e.push(n)}return this.faces=e,this}nextVertexToAdd(){if(!1===this.assigned.isEmpty()){let e,t=0;const n=this.assigned.first().face;let r=n.outside;do{const o=n.distanceToPoint(r.point);o>t&&(t=o,e=r),r=r.next}while(null!==r&&r.face===n);return e}}computeHorizon(e,t,n,r){let o;this.deleteFaceVertices(n),n.mark=1,o=null===t?t=n.getEdge(0):t.next;do{const t=o.twin,n=t.face;0===n.mark&&(n.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,t,n,r):r.push(o)),o=o.next}while(o!==t);return this}addAdjoiningFace(e,t){const n=a.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)}addNewFaces(e,t){this.newFaces=[];let n=null,r=null;for(let o=0;o<t.length;o++){const a=t[o],i=this.addAdjoiningFace(e,a);null===n?n=i:i.next.setTwin(r),this.newFaces.push(i.face),r=i}return n.next.setTwin(r),this}addVertexToHull(e){const t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this}cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}compute(){let e;for(this.computeInitialHull();void 0!==(e=this.nextVertexToAdd());)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}}()},235:()=>{!function(){const e={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new THREE.Vector2(.001953125,0)},cKernel:{value:[]}},vertexShader:"\n\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 imageCoord = vUv;\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\t\t\timageCoord += uImageIncrement;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}",buildKernel:function(e){let n=2*Math.ceil(3*e)+1;n>25&&(n=25);const r=.5*(n-1),o=new Array(n);let a=0;for(let i=0;i<n;++i)o[i]=t(i-r,e),a+=o[i];for(let e=0;e<n;++e)o[e]/=a;return o}};function t(e,t){return Math.exp(-e*e/(2*t*t))}THREE.ConvolutionShader=e}()},1790:()=>{var e;e={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\t\t}"},THREE.CopyShader=e},3861:()=>{!function(){class e extends THREE.CompressedTextureLoader{constructor(e){super(e)}parse(e,t){const n={mipmaps:[],width:0,height:0,format:null,mipmapCount:1};function r(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}function o(e,t,n,r){const o=n*r*4,a=new Uint8Array(e,t,o),i=new Uint8Array(o);let s=0,l=0;for(let e=0;e<r;e++)for(let e=0;e<n;e++){const e=a[l];l++;const t=a[l];l++;const n=a[l];l++;const r=a[l];l++,i[s]=n,s++,i[s]=t,s++,i[s]=e,s++,i[s]=r,s++}return i}const a=r("DXT1"),i=r("DXT3"),s=r("DXT5"),l=r("ETC1"),c=new Int32Array(e,0,31);if(542327876!==c[0])return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."),n;if(4&!c[20])return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."),n;let f;const u=c[21];let d=!1;switch(u){case a:f=8,n.format=THREE.RGB_S3TC_DXT1_Format;break;case i:f=16,n.format=THREE.RGBA_S3TC_DXT3_Format;break;case s:f=16,n.format=THREE.RGBA_S3TC_DXT5_Format;break;case l:f=8,n.format=THREE.RGB_ETC1_Format;break;default:if(!(32===c[22]&&16711680&c[23]&&65280&c[24]&&255&c[25]&&4278190080&c[26]))return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ",(p=u,String.fromCharCode(255&p,p>>8&255,p>>16&255,p>>24&255))),n;d=!0,f=64,n.format=THREE.RGBAFormat}var p;n.mipmapCount=1,131072&c[2]&&!1!==t&&(n.mipmapCount=Math.max(1,c[7]));const h=c[28];if(n.isCubemap=!!(512&h),n.isCubemap&&(!(1024&h)||!(2048&h)||!(4096&h)||!(8192&h)||!(16384&h)||!(32768&h)))return console.error("THREE.DDSLoader.parse: Incomplete cubemap faces"),n;n.width=c[4],n.height=c[3];let v=c[1]+4;const m=n.isCubemap?6:1;for(let t=0;t<m;t++){let t=n.width,r=n.height;for(let a=0;a<n.mipmapCount;a++){let a,i;d?(a=o(e,v,t,r),i=a.length):(i=Math.max(4,t)/4*Math.max(4,r)/4*f,a=new Uint8Array(e,v,i));const s={data:a,width:t,height:r};n.mipmaps.push(s),v+=i,t=Math.max(t>>1,1),r=Math.max(r>>1,1)}}return n}}THREE.DDSLoader=e}()},3538:()=>{!function(){const e=new WeakMap;class t extends THREE.Loader{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,t,n,r){const o=new THREE.FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,(e=>{const n={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(e,n).then(t).catch(r)}),n,r)}decodeDracoFile(e,t,n,r){const o={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:r||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,o).then(t)}decodeGeometry(t,n){for(const e in n.attributeTypes){const t=n.attributeTypes[e];void 0!==t.BYTES_PER_ELEMENT&&(n.attributeTypes[e]=t.name)}const r=JSON.stringify(n);if(e.has(t)){const n=e.get(t);if(n.key===r)return n.promise;if(0===t.byteLength)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let o;const a=this.workerNextTaskID++,i=t.byteLength,s=this._getWorker(a,i).then((e=>(o=e,new Promise(((e,r)=>{o._callbacks[a]={resolve:e,reject:r},o.postMessage({type:"decode",id:a,taskConfig:n,buffer:t},[t])}))))).then((e=>this._createGeometry(e.geometry)));return s.catch((()=>!0)).then((()=>{o&&a&&this._releaseTask(o,a)})),e.set(t,{key:r,promise:s}),s}_createGeometry(e){const t=new THREE.BufferGeometry;e.index&&t.setIndex(new THREE.BufferAttribute(e.index.array,1));for(let n=0;n<e.attributes.length;n++){const r=e.attributes[n],o=r.name,a=r.array,i=r.itemSize;t.setAttribute(o,new THREE.BufferAttribute(a,i))}return t}_loadLibrary(e,t){const n=new THREE.FileLoader(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise(((t,r)=>{n.load(e,t,void 0,r)}))}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e="object"!=typeof WebAssembly||"js"===this.decoderConfig.type,t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then((t=>{const r=t[0];e||(this.decoderConfig.wasmBinary=t[1]);const o=n.toString(),a=["/* draco decoder */",r,"","/* worker */",o.substring(o.indexOf("{")+1,o.lastIndexOf("}"))].join("\n");this.workerSourceURL=URL.createObjectURL(new Blob([a]))})),this.decoderPending}_getWorker(e,t){return this._initDecoder().then((()=>{if(this.workerPool.length<this.workerLimit){const e=new Worker(this.workerSourceURL);e._callbacks={},e._taskCosts={},e._taskLoad=0,e.postMessage({type:"init",decoderConfig:this.decoderConfig}),e.onmessage=function(t){const n=t.data;switch(n.type){case"decode":e._callbacks[n.id].resolve(n);break;case"error":e._callbacks[n.id].reject(n);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+n.type+'"')}},this.workerPool.push(e)}else this.workerPool.sort((function(e,t){return e._taskLoad>t._taskLoad?-1:1}));const n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n}))}_releaseTask(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]}debug(){console.log("Task load: ",this.workerPool.map((e=>e._taskLoad)))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function n(){let e,t;function n(e,t,n,r,o,a){const i=a.num_components(),s=n.num_points()*i,l=s*o.BYTES_PER_ELEMENT,c=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,o),f=e._malloc(l);t.GetAttributeDataArrayForAllPoints(n,a,c,l,f);const u=new o(e.HEAPF32.buffer,f,s).slice();return e._free(f),{name:r,array:u,itemSize:i}}onmessage=function(r){const o=r.data;switch(o.type){case"init":e=o.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const r=o.buffer,a=o.taskConfig;t.then((e=>{const t=e.draco,i=new t.Decoder,s=new t.DecoderBuffer;s.Init(new Int8Array(r),r.byteLength);try{const e=function(e,t,r,o){const a=o.attributeIDs,i=o.attributeTypes;let s,l;const c=t.GetEncodedGeometryType(r);if(c===e.TRIANGULAR_MESH)s=new e.Mesh,l=t.DecodeBufferToMesh(r,s);else{if(c!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");s=new e.PointCloud,l=t.DecodeBufferToPointCloud(r,s)}if(!l.ok()||0===s.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+l.error_msg());const f={index:null,attributes:[]};for(const r in a){const l=self[i[r]];let c,u;if(o.useUniqueIDs)u=a[r],c=t.GetAttributeByUniqueId(s,u);else{if(u=t.GetAttributeId(s,e[a[r]]),-1===u)continue;c=t.GetAttribute(s,u)}f.attributes.push(n(e,t,s,r,l,c))}c===e.TRIANGULAR_MESH&&(f.index=function(e,t,n){const r=3*n.num_faces(),o=4*r,a=e._malloc(o);t.GetTrianglesUInt32Array(n,o,a);const i=new Uint32Array(e.HEAPF32.buffer,a,r).slice();return e._free(a),{array:i,itemSize:1}}(e,t,s));return e.destroy(s),f}(t,i,s,a),r=e.attributes.map((e=>e.array.buffer));e.index&&r.push(e.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:e},r)}catch(e){console.error(e),self.postMessage({type:"error",id:o.id,error:e.message})}finally{t.destroy(s),t.destroy(i)}}))}}}THREE.DRACOLoader=t}()},8084:()=>{const e=/\bvoid\s+main\s*\(\s*\)\s*{/g;function t(e){return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm,(function(e,n){let r=THREE.ShaderChunk[n];return r?t(r):e}))}const n=Object.assign||function(){let e=arguments[0];for(let t=1,n=arguments.length;t<n;t++){let n=arguments[t];if(n)for(let t in n)n.hasOwnProperty(t)&&(e[t]=n[t])}return e};let r=0;const o=Date.now(),a=new WeakMap;function i(e,t){return"uniforms"===e?void 0:t}THREE.createDerivedMaterial=function(s,l){const c=function(e){return JSON.stringify(e,i)}(l);let f=a.get(s);if(f||(f=Object.create(null),a.set(s,f)),f[c])return f[c].clone();const u=++r,d=`_derivedShaders${u}`,p=`_onBeforeCompile${u}`;let h,v;function m(r){s.onBeforeCompile.call(this,r);const{vertex:a,fragment:i}=this[d]||(this[d]={vertex:{},fragment:{}});if(a.source!==r.vertexShader||i.source!==r.fragmentShader){const n=function({vertexShader:n,fragmentShader:r},o,a){let{vertexDefs:i,vertexTransform:s,vertexMainIntro:l,fragmentDefs:c,fragmentDiffuseTransform:f,fragmentMainIntro:u,fragmentColorTransform:d,timeUniform:p}=o;if(p){const e=`\nuniform float ${p};\n`;i=(i||"")+e,c=(c||"")+e}(i||s||l)&&(s&&(n=t(n),i=`\n        ${i||""}\n        void vertexTransform_${a}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n          ${s}\n        }\n      `,n=n.replace(/\b(position|normal|uv)\b/g,((e,t,n,r)=>/\battribute\s+vec3\s+$/.test(r.substr(0,n))?t:`_${t}_${a}`)),l=`\n        vec3 _position_${a} = vec3(position);\n        vec3 _normal_${a} = vec3(normal);\n        vec2 _uv_${a} = vec2(uv);\n        vertexTransform_${a}(_position_${a}, _normal_${a}, _uv_${a});\n        ${l||""}\n      `),n=n.replace(e,`${i||""}\n\n$&\n\n${l||""}`));(c||f||u||d)&&(r=t(r),f&&(c=`\n        ${c||""}\n        void fragmentDiffuseTransform_${a}(inout vec3 diffuse) {\n          ${f}\n        }\n      `,r=r.replace(/\b(diffuse)\b/g,((e,t,n,r)=>/\buniform\s+vec3\s+$/.test(r.substr(0,n))?t:`_${t}_${a}`)),u=`\n        vec3 _diffuse_${a} = diffuse;\n        fragmentDiffuseTransform_${a}(_diffuse_${a});\n        ${u||""}\n      `),r=r.replace(e,`\n      ${c||""}\n      void threejsMain_${a}() {\n      ${u||""}\n    `),r+=`\n      void main() {\n        threejsMain_${a}();\n        ${d||""}\n      }\n    `);return{vertexShader:n,fragmentShader:r}}(r,l,u);a.source=r.vertexShader,a.result=n.vertexShader,i.source=r.fragmentShader,i.result=n.fragmentShader}r.vertexShader=a.result,r.fragmentShader=i.result,n(r.uniforms,this.uniforms),l.timeUniform&&(r.uniforms[l.timeUniform]={get value(){return Date.now()-o}}),this[p]&&this[p](r)}function x(){this._listeners=void 0}x.prototype=Object.create(s,{constructor:{value:x},isDerivedMaterial:{value:!0},baseMaterial:{value:s},onBeforeCompile:{get:()=>m,set(e){this[p]=e}},copy:{value:function(e){return s.copy.call(this,e),s.isShaderMaterial||s.isDerivedMaterial||(this.extensions=e.extensions,this.defines=n({},e.defines),this.uniforms=THREE.UniformsUtils.clone(e.uniforms)),this}},getDepthMaterial:{value:function(){let e=this._depthMaterial;return e||(v||(v=createDerivedMaterial(s.isDerivedMaterial?s.getDepthMaterial():new THREE.MeshDepthMaterial({depthPacking:THREE.RGBADepthPacking}),l),v.defines.IS_DEPTH_MATERIAL=""),e=this._depthMaterial=v.clone()),e}},getDistanceMaterial:{value:function(){let e=this._distanceMaterial;return e||(h||(h=createDerivedMaterial(s.isDerivedMaterial?s.getDistanceMaterial():new THREE.MeshDistanceMaterial,l),h.defines.IS_DISTANCE_MATERIAL=""),e=this._distanceMaterial=h.clone()),e}},dispose:{value(){const{_depthMaterial:e,_distanceMaterial:t}=this;e&&e.dispose(),t&&t.dispose(),s.dispose.call(this)}}});const g=new x;return g.copy(s),g.uniforms=n(THREE.UniformsUtils.clone(s.uniforms||{}),l.uniforms),g.defines=n({},s.defines,l.defines),g.defines.DERIVED_MATERIAL=u,g.extensions=n({},s.extensions,l.extensions),f[c]=g,g.clone()};const s={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};THREE.getShadersForMaterial=function(e){let t=s[e.type];return t?THREE.ShaderLib[t]:e},THREE.getShaderUniformTypes=function(e){let t,n=/\buniform\s+(int|float|vec[234])\s+([A-Za-z_][\w]*)/g,r=Object.create(null);for(;null!==(t=n.exec(e));)r[t[2]]=t[1];return r}},6999:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},tDisp:{value:null},byp:{value:0},amount:{value:.08},angle:{value:.02},seed:{value:.02},seed_x:{value:.02},seed_y:{value:.02},distortion_x:{value:.5},distortion_y:{value:.6},col_s:{value:.05}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\t\tvoid main() {\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t}",fragmentShader:"\n\n\t\tuniform int byp; //should we apply the glitch ?\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tDisp;\n\n\t\tuniform float amount;\n\t\tuniform float angle;\n\t\tuniform float seed;\n\t\tuniform float seed_x;\n\t\tuniform float seed_y;\n\t\tuniform float distortion_x;\n\t\tuniform float distortion_y;\n\t\tuniform float col_s;\n\n\t\tvarying vec2 vUv;\n\n\n\t\tfloat rand(vec2 co){\n\t\t\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n\t\t}\n\n\t\tvoid main() {\n\t\t\tif(byp<1) {\n\t\t\t\tvec2 p = vUv;\n\t\t\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\n\t\t\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\n\t\t\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\t\tvec4 normal = texture2D (tDisp, p*seed*seed);\n\t\t\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\n\t\t\t\t\tif(seed_x>0.){\n\t\t\t\t\t\tp.y = 1. - (p.y + distortion_y);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.y = distortion_y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\n\t\t\t\t\tif(seed_y>0.){\n\t\t\t\t\t\tp.x=distortion_x;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp.x = 1. - (p.x + distortion_x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp.x+=normal.x*seed_x*(seed/5.);\n\t\t\t\tp.y+=normal.y*seed_y*(seed/5.);\n\t\t\t\t//base from RGB shift shader\n\t\t\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\n\t\t\t\tvec4 cr = texture2D(tDiffuse, p + offset);\n\t\t\t\tvec4 cga = texture2D(tDiffuse, p);\n\t\t\t\tvec4 cb = texture2D(tDiffuse, p - offset);\n\t\t\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\n\t\t\t\t//add noise\n\t\t\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\n\t\t\t\tgl_FragColor = gl_FragColor+ snow;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgl_FragColor=texture2D (tDiffuse, vUv);\n\t\t\t}\n\t\t}"};THREE.DigitalGlitch=e}()},900:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},tSize:{value:new THREE.Vector2(256,256)},center:{value:new THREE.Vector2(.5,.5)},angle:{value:1.57},scale:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec2 center;\n\t\tuniform float angle;\n\t\tuniform float scale;\n\t\tuniform vec2 tSize;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tfloat pattern() {\n\n\t\t\tfloat s = sin( angle ), c = cos( angle );\n\n\t\t\tvec2 tex = vUv * tSize - center;\n\t\t\tvec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\n\n\t\t\treturn ( sin( point.x ) * sin( point.y ) ) * 4.0;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 color = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat average = ( color.r + color.g + color.b ) / 3.0;\n\n\t\t\tgl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\n\n\t\t}"};THREE.DotScreenShader=e}()},9174:()=>{!function(){const e=new THREE.Plane,t=new THREE.Raycaster,n=new THREE.Vector2,r=new THREE.Vector3,o=new THREE.Vector3,a=new THREE.Vector3,i=new THREE.Matrix4;class s extends THREE.EventDispatcher{constructor(s,l,c){super();let f=null,u=null;const d=[],p=this;function h(){c.addEventListener("pointermove",m),c.addEventListener("pointerdown",x),c.addEventListener("pointerup",g),c.addEventListener("pointerleave",g),c.addEventListener("touchmove",y,{passive:!1}),c.addEventListener("touchstart",E,{passive:!1}),c.addEventListener("touchend",w)}function v(){c.removeEventListener("pointermove",m),c.removeEventListener("pointerdown",x),c.removeEventListener("pointerup",g),c.removeEventListener("pointerleave",g),c.removeEventListener("touchmove",y),c.removeEventListener("touchstart",E),c.removeEventListener("touchend",w),c.style.cursor=""}function m(h){if(!1!==p.enabled)switch(h.preventDefault(),h.pointerType){case"mouse":case"pen":!function(h){const v=c.getBoundingClientRect();if(n.x=(h.clientX-v.left)/v.width*2-1,n.y=-(h.clientY-v.top)/v.height*2+1,t.setFromCamera(n,l),f&&p.enabled)return t.ray.intersectPlane(e,o)&&f.position.copy(o.sub(r).applyMatrix4(i)),void p.dispatchEvent({type:"drag",object:f});if(d.length=0,t.setFromCamera(n,l),t.intersectObjects(s,!0,d),d.length>0){const t=d[0].object;e.setFromNormalAndCoplanarPoint(l.getWorldDirection(e.normal),a.setFromMatrixPosition(t.matrixWorld)),u!==t&&null!==u&&(p.dispatchEvent({type:"hoveroff",object:u}),c.style.cursor="auto",u=null),u!==t&&(p.dispatchEvent({type:"hoveron",object:t}),c.style.cursor="pointer",u=t)}else null!==u&&(p.dispatchEvent({type:"hoveroff",object:u}),c.style.cursor="auto",u=null)}(h)}}function x(u){if(!1!==p.enabled)switch(u.preventDefault(),u.pointerType){case"mouse":case"pen":!function(u){u.preventDefault(),d.length=0,t.setFromCamera(n,l),t.intersectObjects(s,!0,d),d.length>0&&(f=!0===p.transformGroup?s[0]:d[0].object,t.ray.intersectPlane(e,o)&&(i.copy(f.parent.matrixWorld).invert(),r.copy(o).sub(a.setFromMatrixPosition(f.matrixWorld))),c.style.cursor="move",p.dispatchEvent({type:"dragstart",object:f}))}(u)}}function g(e){if(!1!==p.enabled)switch(e.preventDefault(),e.pointerType){case"mouse":case"pen":!function(e){e.preventDefault(),f&&(p.dispatchEvent({type:"dragend",object:f}),f=null);c.style.cursor=u?"pointer":"auto"}(e)}}function y(a){if(!1===p.enabled)return;a.preventDefault(),a=a.changedTouches[0];const s=c.getBoundingClientRect();return n.x=(a.clientX-s.left)/s.width*2-1,n.y=-(a.clientY-s.top)/s.height*2+1,t.setFromCamera(n,l),f&&p.enabled?(t.ray.intersectPlane(e,o)&&f.position.copy(o.sub(r).applyMatrix4(i)),void p.dispatchEvent({type:"drag",object:f})):void 0}function E(u){if(!1===p.enabled)return;u.preventDefault(),u=u.changedTouches[0];const h=c.getBoundingClientRect();n.x=(u.clientX-h.left)/h.width*2-1,n.y=-(u.clientY-h.top)/h.height*2+1,d.length=0,t.setFromCamera(n,l),t.intersectObjects(s,!0,d),d.length>0&&(f=!0===p.transformGroup?s[0]:d[0].object,e.setFromNormalAndCoplanarPoint(l.getWorldDirection(e.normal),a.setFromMatrixPosition(f.matrixWorld)),t.ray.intersectPlane(e,o)&&(i.copy(f.parent.matrixWorld).invert(),r.copy(o).sub(a.setFromMatrixPosition(f.matrixWorld))),c.style.cursor="move",p.dispatchEvent({type:"dragstart",object:f}))}function w(e){!1!==p.enabled&&(e.preventDefault(),f&&(p.dispatchEvent({type:"dragend",object:f}),f=null),c.style.cursor="auto")}h(),this.enabled=!0,this.transformGroup=!1,this.activate=h,this.deactivate=v,this.dispose=function(){v()},this.getObjects=function(){return s}}}THREE.DragControls=s}()},5470:()=>{!function(){const e=new THREE.OrthographicCamera(-1,1,1,-1,0,1),t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),t.setAttribute("uv",new THREE.Float32BufferAttribute([0,2,0,0,2,0],2));THREE.EffectComposer=class{constructor(e,t){if(this.renderer=e,void 0===t){const n={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},r=e.getSize(new THREE.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=r.width,this._height=r.height,(t=new THREE.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,n)).texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),void 0===THREE.ShaderPass&&console.error("THREE.EffectComposer relies on THREE.ShaderPass"),this.copyPass=new THREE.ShaderPass(THREE.CopyShader),this.clock=new THREE.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let n=!1;for(let t=0,r=this.passes.length;t<r;t++){const r=this.passes[t];if(!1!==r.enabled){if(r.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(t),r.render(this.renderer,this.writeBuffer,this.readBuffer,e,n),r.needsSwap){if(n){const t=this.renderer.getContext(),n=this.renderer.state.buffers.stencil;n.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),n.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==THREE.MaskPass&&(r instanceof THREE.MaskPass?n=!0:r instanceof THREE.ClearMaskPass&&(n=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const t=this.renderer.getSize(new THREE.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const n=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(n,r),this.renderTarget2.setSize(n,r);for(let e=0;e<this.passes.length;e++)this.passes[e].setSize(n,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}},THREE.FullScreenQuad=class{constructor(e){this._mesh=new THREE.Mesh(t,e)}dispose(){this._mesh.geometry.dispose()}render(t){t.render(this._mesh,e)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}},THREE.Pass=class{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}}()},2509:(e,t,n)=>{"use strict";n.r(t);var r=n(743);n(8080);!function(){let e,t,n;class o extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=""===o.path?THREE.LoaderUtils.extractUrlBase(e):o.path,i=new THREE.FileLoader(this.manager);i.setPath(o.path),i.setResponseType("arraybuffer"),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(e,(function(n){try{t(o.parse(n,a))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(t,n){if(function(e){const t="Kaydara FBX Binary  \0";return e.byteLength>=t.length&&t===w(e,0,t.length)}(t))e=(new c).parse(t);else{const n=w(t);if(!function(e){const t=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let n=0;function r(t){const r=e[t-1];return e=e.slice(n+t),n++,r}for(let e=0;e<t.length;++e){if(r(1)===t[e])return!1}return!0}(n))throw new Error("THREE.FBXLoader: Unknown format.");if(d(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+d(n));e=(new l).parse(n)}const r=new THREE.TextureLoader(this.manager).setPath(this.resourcePath||n).setCrossOrigin(this.crossOrigin);return new a(r,this.manager).parse(e)}}class a{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){t=this.parseConnections();const e=this.parseImages(),r=this.parseTextures(e),o=this.parseMaterials(r),a=this.parseDeformers(),s=(new i).parse(a);return this.parseScene(a,s,o),n}parseConnections(){const t=new Map;if("Connections"in e){e.Connections.connections.forEach((function(e){const n=e[0],r=e[1],o=e[2];t.has(n)||t.set(n,{parents:[],children:[]});const a={ID:r,relationship:o};t.get(n).parents.push(a),t.has(r)||t.set(r,{parents:[],children:[]});const i={ID:n,relationship:o};t.get(r).children.push(i)}))}return t}parseImages(){const t={},n={};if("Video"in e.Objects){const r=e.Objects.Video;for(const e in r){const o=r[e];if(t[parseInt(e)]=o.RelativeFilename||o.Filename,"Content"in o){const t=o.Content instanceof ArrayBuffer&&o.Content.byteLength>0,a="string"==typeof o.Content&&""!==o.Content;if(t||a){const t=this.parseImage(r[e]);n[o.RelativeFilename||o.Filename]=t}}}}for(const e in t){const r=t[e];void 0!==n[r]?t[e]=n[r]:t[e]=t[e].split("\\").pop()}return t}parseImage(e){const t=e.Content,n=e.RelativeFilename||e.Filename,r=n.slice(n.lastIndexOf(".")+1).toLowerCase();let o;switch(r){case"bmp":o="image/bmp";break;case"jpg":case"jpeg":o="image/jpeg";break;case"png":o="image/png";break;case"tif":o="image/tiff";break;case"tga":null===this.manager.getHandler(".tga")&&console.warn("FBXLoader: TGA loader not found, skipping ",n),o="image/tga";break;default:return void console.warn('FBXLoader: Image type "'+r+'" is not supported.')}if("string"==typeof t)return"data:"+o+";base64,"+t;{const e=new Uint8Array(t);return window.URL.createObjectURL(new Blob([e],{type:o}))}}parseTextures(t){const n=new Map;if("Texture"in e.Objects){const r=e.Objects.Texture;for(const e in r){const o=this.parseTexture(r[e],t);n.set(parseInt(e),o)}}return n}parseTexture(e,t){const n=this.loadTexture(e,t);n.ID=e.id,n.name=e.attrName;const r=e.WrapModeU,o=e.WrapModeV,a=void 0!==r?r.value:0,i=void 0!==o?o.value:0;if(n.wrapS=0===a?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,n.wrapT=0===i?THREE.RepeatWrapping:THREE.ClampToEdgeWrapping,"Scaling"in e){const t=e.Scaling.value;n.repeat.x=t[0],n.repeat.y=t[1]}return n}loadTexture(e,n){let r;const o=this.textureLoader.path,a=t.get(e.id).children;let i;void 0!==a&&a.length>0&&void 0!==n[a[0].ID]&&(r=n[a[0].ID],0!==r.indexOf("blob:")&&0!==r.indexOf("data:")||this.textureLoader.setPath(void 0));const s=e.FileName.slice(-3).toLowerCase();if("tga"===s){const t=this.manager.getHandler(".tga");null===t?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",e.RelativeFilename),i=new THREE.Texture):i=t.load(r)}else"psd"===s?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",e.RelativeFilename),i=new THREE.Texture):i=this.textureLoader.load(r);return this.textureLoader.setPath(o),i}parseMaterials(t){const n=new Map;if("Material"in e.Objects){const r=e.Objects.Material;for(const e in r){const o=this.parseMaterial(r[e],t);null!==o&&n.set(parseInt(e),o)}}return n}parseMaterial(e,n){const r=e.id,o=e.attrName;let a=e.ShadingModel;if("object"==typeof a&&(a=a.value),!t.has(r))return null;const i=this.parseParameters(e,n,r);let s;switch(a.toLowerCase()){case"phong":s=new THREE.MeshPhongMaterial;break;case"lambert":s=new THREE.MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to THREE.MeshPhongMaterial.',a),s=new THREE.MeshPhongMaterial}return s.setValues(i),s.name=o,s}parseParameters(e,n,r){const o={};e.BumpFactor&&(o.bumpScale=e.BumpFactor.value),e.Diffuse?o.color=(new THREE.Color).fromArray(e.Diffuse.value):!e.DiffuseColor||"Color"!==e.DiffuseColor.type&&"ColorRGB"!==e.DiffuseColor.type||(o.color=(new THREE.Color).fromArray(e.DiffuseColor.value)),e.DisplacementFactor&&(o.displacementScale=e.DisplacementFactor.value),e.Emissive?o.emissive=(new THREE.Color).fromArray(e.Emissive.value):!e.EmissiveColor||"Color"!==e.EmissiveColor.type&&"ColorRGB"!==e.EmissiveColor.type||(o.emissive=(new THREE.Color).fromArray(e.EmissiveColor.value)),e.EmissiveFactor&&(o.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),e.Opacity&&(o.opacity=parseFloat(e.Opacity.value)),o.opacity<1&&(o.transparent=!0),e.ReflectionFactor&&(o.reflectivity=e.ReflectionFactor.value),e.Shininess&&(o.shininess=e.Shininess.value),e.Specular?o.specular=(new THREE.Color).fromArray(e.Specular.value):e.SpecularColor&&"Color"===e.SpecularColor.type&&(o.specular=(new THREE.Color).fromArray(e.SpecularColor.value));const a=this;return t.get(r).children.forEach((function(e){const t=e.relationship;switch(t){case"Bump":o.bumpMap=a.getTexture(n,e.ID);break;case"Maya|TEX_ao_map":o.aoMap=a.getTexture(n,e.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":o.map=a.getTexture(n,e.ID),o.map.encoding=THREE.sRGBEncoding;break;case"DisplacementColor":o.displacementMap=a.getTexture(n,e.ID);break;case"EmissiveColor":o.emissiveMap=a.getTexture(n,e.ID),o.emissiveMap.encoding=THREE.sRGBEncoding;break;case"NormalMap":case"Maya|TEX_normal_map":o.normalMap=a.getTexture(n,e.ID);break;case"ReflectionColor":o.envMap=a.getTexture(n,e.ID),o.envMap.mapping=THREE.EquirectangularReflectionMapping,o.envMap.encoding=THREE.sRGBEncoding;break;case"SpecularColor":o.specularMap=a.getTexture(n,e.ID),o.specularMap.encoding=THREE.sRGBEncoding;break;case"TransparentColor":case"TransparencyFactor":o.alphaMap=a.getTexture(n,e.ID),o.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",t)}})),o}getTexture(n,r){return"LayeredTexture"in e.Objects&&r in e.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),r=t.get(r).children[0].ID),n.get(r)}parseDeformers(){const n={},r={};if("Deformer"in e.Objects){const o=e.Objects.Deformer;for(const e in o){const a=o[e],i=t.get(parseInt(e));if("Skin"===a.attrType){const t=this.parseSkeleton(i,o);t.ID=e,i.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),t.geometryID=i.parents[0].ID,n[e]=t}else if("BlendShape"===a.attrType){const t={id:e};t.rawTargets=this.parseMorphTargets(i,o),t.id=e,i.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),r[e]=t}}}return{skeletons:n,morphTargets:r}}parseSkeleton(e,t){const n=[];return e.children.forEach((function(e){const r=t[e.ID];if("Cluster"!==r.attrType)return;const o={ID:e.ID,indices:[],weights:[],transformLink:(new THREE.Matrix4).fromArray(r.TransformLink.a)};"Indexes"in r&&(o.indices=r.Indexes.a,o.weights=r.Weights.a),n.push(o)})),{rawBones:n,bones:[]}}parseMorphTargets(e,n){const r=[];for(let o=0;o<e.children.length;o++){const a=e.children[o],i=n[a.ID],s={name:i.attrName,initialWeight:i.DeformPercent,id:i.id,fullWeights:i.FullWeights.a};if("BlendShapeChannel"!==i.attrType)return;s.geoID=t.get(parseInt(a.ID)).children.filter((function(e){return void 0===e.relationship}))[0].ID,r.push(s)}return r}parseScene(r,o,a){n=new THREE.Group;const i=this.parseModels(r.skeletons,o,a),l=e.Objects.Model,c=this;i.forEach((function(e){const r=l[e.ID];c.setLookAtProperties(e,r);t.get(e.ID).parents.forEach((function(t){const n=i.get(t.ID);void 0!==n&&n.add(e)})),null===e.parent&&n.add(e)})),this.bindSkeleton(r.skeletons,o,i),this.createAmbientLight(),this.setupMorphMaterials(),n.traverse((function(e){if(e.userData.transformData){e.parent&&(e.userData.transformData.parentMatrix=e.parent.matrix,e.userData.transformData.parentMatrixWorld=e.parent.matrixWorld);const t=g(e.userData.transformData);e.applyMatrix4(t),e.updateWorldMatrix()}}));const f=(new s).parse();1===n.children.length&&n.children[0].isGroup&&(n.children[0].animations=f,n=n.children[0]),n.animations=f}parseModels(n,r,o){const a=new Map,i=e.Objects.Model;for(const e in i){const s=parseInt(e),l=i[e],c=t.get(s);let f=this.buildSkeleton(c,n,s,l.attrName);if(!f){switch(l.attrType){case"Camera":f=this.createCamera(c);break;case"Light":f=this.createLight(c);break;case"Mesh":f=this.createMesh(c,r,o);break;case"NurbsCurve":f=this.createCurve(c,r);break;case"LimbNode":case"Root":f=new THREE.Bone;break;case"Null":default:f=new THREE.Group}f.name=l.attrName?THREE.PropertyBinding.sanitizeNodeName(l.attrName):"",f.ID=s}this.getTransformData(f,l),a.set(s,f)}return a}buildSkeleton(e,t,n,r){let o=null;return e.parents.forEach((function(e){for(const a in t){const i=t[a];i.rawBones.forEach((function(t,a){if(t.ID===e.ID){const e=o;o=new THREE.Bone,o.matrixWorld.copy(t.transformLink),o.name=r?THREE.PropertyBinding.sanitizeNodeName(r):"",o.ID=n,i.bones[a]=o,null!==e&&o.add(e)}}))}})),o}createCamera(t){let n,r;if(t.children.forEach((function(t){const n=e.Objects.NodeAttribute[t.ID];void 0!==n&&(r=n)})),void 0===r)n=new THREE.Object3D;else{let e=0;void 0!==r.CameraProjectionType&&1===r.CameraProjectionType.value&&(e=1);let t=1;void 0!==r.NearPlane&&(t=r.NearPlane.value/1e3);let o=1e3;void 0!==r.FarPlane&&(o=r.FarPlane.value/1e3);let a=window.innerWidth,i=window.innerHeight;void 0!==r.AspectWidth&&void 0!==r.AspectHeight&&(a=r.AspectWidth.value,i=r.AspectHeight.value);const s=a/i;let l=45;void 0!==r.FieldOfView&&(l=r.FieldOfView.value);const c=r.FocalLength?r.FocalLength.value:null;switch(e){case 0:n=new THREE.PerspectiveCamera(l,s,t,o),null!==c&&n.setFocalLength(c);break;case 1:n=new THREE.OrthographicCamera(-a/2,a/2,i/2,-i/2,t,o);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+e+"."),n=new THREE.Object3D}}return n}createLight(t){let n,r;if(t.children.forEach((function(t){const n=e.Objects.NodeAttribute[t.ID];void 0!==n&&(r=n)})),void 0===r)n=new THREE.Object3D;else{let e;e=void 0===r.LightType?0:r.LightType.value;let t=16777215;void 0!==r.Color&&(t=(new THREE.Color).fromArray(r.Color.value));let o=void 0===r.Intensity?1:r.Intensity.value/100;void 0!==r.CastLightOnObject&&0===r.CastLightOnObject.value&&(o=0);let a=0;void 0!==r.FarAttenuationEnd&&(a=void 0!==r.EnableFarAttenuation&&0===r.EnableFarAttenuation.value?0:r.FarAttenuationEnd.value);const i=1;switch(e){case 0:n=new THREE.PointLight(t,o,a,i);break;case 1:n=new THREE.DirectionalLight(t,o);break;case 2:let e=Math.PI/3;void 0!==r.InnerAngle&&(e=THREE.MathUtils.degToRad(r.InnerAngle.value));let s=0;void 0!==r.OuterAngle&&(s=THREE.MathUtils.degToRad(r.OuterAngle.value),s=Math.max(s,1)),n=new THREE.SpotLight(t,o,a,e,s,i);break;default:console.warn("THREE.FBXLoader: Unknown light type "+r.LightType.value+", defaulting to a THREE.PointLight."),n=new THREE.PointLight(t,o)}void 0!==r.CastShadows&&1===r.CastShadows.value&&(n.castShadow=!0)}return n}createMesh(e,t,n){let r,o=null,a=null;const i=[];return e.children.forEach((function(e){t.has(e.ID)&&(o=t.get(e.ID)),n.has(e.ID)&&i.push(n.get(e.ID))})),i.length>1?a=i:i.length>0?a=i[0]:(a=new THREE.MeshPhongMaterial({color:13421772}),i.push(a)),"color"in o.attributes&&i.forEach((function(e){e.vertexColors=!0})),o.FBX_Deformer?(i.forEach((function(e){e.skinning=!0})),r=new THREE.SkinnedMesh(o,a),r.normalizeSkinWeights()):r=new THREE.Mesh(o,a),r}createCurve(e,t){const n=e.children.reduce((function(e,n){return t.has(n.ID)&&(e=t.get(n.ID)),e}),null),r=new THREE.LineBasicMaterial({color:3342591,linewidth:1});return new THREE.Line(n,r)}getTransformData(e,t){const n={};"InheritType"in t&&(n.inheritType=parseInt(t.InheritType.value)),n.eulerOrder="RotationOrder"in t?y(t.RotationOrder.value):"ZYX","Lcl_Translation"in t&&(n.translation=t.Lcl_Translation.value),"PreRotation"in t&&(n.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(n.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(n.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(n.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(n.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(n.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(n.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(n.rotationPivot=t.RotationPivot.value),e.userData.transformData=n}setLookAtProperties(r,o){if("LookAtProperty"in o){t.get(r.ID).children.forEach((function(t){if("LookAtProperty"===t.relationship){const o=e.Objects.Model[t.ID];if("Lcl_Translation"in o){const e=o.Lcl_Translation.value;void 0!==r.target?(r.target.position.fromArray(e),n.add(r.target)):r.lookAt((new THREE.Vector3).fromArray(e))}}}))}}bindSkeleton(e,n,r){const o=this.parsePoseNodes();for(const a in e){const i=e[a];t.get(parseInt(i.ID)).parents.forEach((function(e){if(n.has(e.ID)){const n=e.ID;t.get(n).parents.forEach((function(e){if(r.has(e.ID)){r.get(e.ID).bind(new THREE.Skeleton(i.bones),o[e.ID])}}))}}))}}parsePoseNodes(){const t={};if("Pose"in e.Objects){const n=e.Objects.Pose;for(const e in n)if("BindPose"===n[e].attrType){const r=n[e].PoseNode;Array.isArray(r)?r.forEach((function(e){t[e.Node]=(new THREE.Matrix4).fromArray(e.Matrix.a)})):t[r.Node]=(new THREE.Matrix4).fromArray(r.Matrix.a)}}return t}createAmbientLight(){if("GlobalSettings"in e&&"AmbientColor"in e.GlobalSettings){const t=e.GlobalSettings.AmbientColor.value,r=t[0],o=t[1],a=t[2];if(0!==r||0!==o||0!==a){const e=new THREE.Color(r,o,a);n.add(new THREE.AmbientLight(e,1))}}}setupMorphMaterials(){const e=this;n.traverse((function(t){t.isMesh&&t.geometry.morphAttributes.position&&t.geometry.morphAttributes.position.length&&(Array.isArray(t.material)?t.material.forEach((function(n,r){e.setupMorphMaterial(t,n,r)})):e.setupMorphMaterial(t,t.material))}))}setupMorphMaterial(e,t,r){const o=e.uuid,a=t.uuid;let i=!1;if(n.traverse((function(e){e.isMesh&&(Array.isArray(e.material)?e.material.forEach((function(t){t.uuid===a&&e.uuid!==o&&(i=!0)})):e.material.uuid===a&&e.uuid!==o&&(i=!0))})),!0===i){const n=t.clone();n.morphTargets=!0,void 0===r?e.material=n:e.material[r]=n}else t.morphTargets=!0}}class i{parse(n){const r=new Map;if("Geometry"in e.Objects){const o=e.Objects.Geometry;for(const e in o){const a=t.get(parseInt(e)),i=this.parseGeometry(a,o[e],n);r.set(parseInt(e),i)}}return r}parseGeometry(e,t,n){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,n);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(t,n,r){const o=r.skeletons,a=[],i=t.parents.map((function(t){return e.Objects.Model[t.ID]}));if(0===i.length)return;const s=t.children.reduce((function(e,t){return void 0!==o[t.ID]&&(e=o[t.ID]),e}),null);t.children.forEach((function(e){void 0!==r.morphTargets[e.ID]&&a.push(r.morphTargets[e.ID])}));const l=i[0],c={};"RotationOrder"in l&&(c.eulerOrder=y(l.RotationOrder.value)),"InheritType"in l&&(c.inheritType=parseInt(l.InheritType.value)),"GeometricTranslation"in l&&(c.translation=l.GeometricTranslation.value),"GeometricRotation"in l&&(c.rotation=l.GeometricRotation.value),"GeometricScaling"in l&&(c.scale=l.GeometricScaling.value);const f=g(c);return this.genGeometry(n,s,a,f)}genGeometry(e,t,n,r){const o=new THREE.BufferGeometry;e.attrName&&(o.name=e.attrName);const a=this.parseGeoNode(e,t),i=this.genBuffers(a),s=new THREE.Float32BufferAttribute(i.vertex,3);if(s.applyMatrix4(r),o.setAttribute("position",s),i.colors.length>0&&o.setAttribute("color",new THREE.Float32BufferAttribute(i.colors,3)),t&&(o.setAttribute("skinIndex",new THREE.Uint16BufferAttribute(i.weightsIndices,4)),o.setAttribute("skinWeight",new THREE.Float32BufferAttribute(i.vertexWeights,4)),o.FBX_Deformer=t),i.normal.length>0){const e=(new THREE.Matrix3).getNormalMatrix(r),t=new THREE.Float32BufferAttribute(i.normal,3);t.applyNormalMatrix(e),o.setAttribute("normal",t)}if(i.uvs.forEach((function(e,t){let n="uv"+(t+1).toString();0===t&&(n="uv"),o.setAttribute(n,new THREE.Float32BufferAttribute(i.uvs[t],2))})),a.material&&"AllSame"!==a.material.mappingType){let e=i.materialIndex[0],t=0;if(i.materialIndex.forEach((function(n,r){n!==e&&(o.addGroup(t,r-t,e),e=n,t=r)})),o.groups.length>0){const t=o.groups[o.groups.length-1],n=t.start+t.count;n!==i.materialIndex.length&&o.addGroup(n,i.materialIndex.length-n,e)}0===o.groups.length&&o.addGroup(0,i.materialIndex.length,i.materialIndex[0])}return this.addMorphTargets(o,e,n,r),o}parseGeoNode(e,t){const n={};if(n.vertexPositions=void 0!==e.Vertices?e.Vertices.a:[],n.vertexIndices=void 0!==e.PolygonVertexIndex?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(n.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(n.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(n.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){n.uv=[];let t=0;for(;e.LayerElementUV[t];)e.LayerElementUV[t].UV&&n.uv.push(this.parseUVs(e.LayerElementUV[t])),t++}return n.weightTable={},null!==t&&(n.skeleton=t,t.rawBones.forEach((function(e,t){e.indices.forEach((function(r,o){void 0===n.weightTable[r]&&(n.weightTable[r]=[]),n.weightTable[r].push({id:t,weight:e.weights[o]})}))}))),n}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let n=0,r=0,o=!1,a=[],i=[],s=[],l=[],c=[],f=[];const u=this;return e.vertexIndices.forEach((function(d,p){let h,m=!1;d<0&&(d^=-1,m=!0);let x=[],g=[];if(a.push(3*d,3*d+1,3*d+2),e.color){const t=v(p,n,d,e.color);s.push(t[0],t[1],t[2])}if(e.skeleton){if(void 0!==e.weightTable[d]&&e.weightTable[d].forEach((function(e){g.push(e.weight),x.push(e.id)})),g.length>4){o||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),o=!0);const e=[0,0,0,0],t=[0,0,0,0];g.forEach((function(n,r){let o=n,a=x[r];t.forEach((function(t,n,r){if(o>t){r[n]=o,o=t;const i=e[n];e[n]=a,a=i}}))})),x=e,g=t}for(;g.length<4;)g.push(0),x.push(0);for(let e=0;e<4;++e)c.push(g[e]),f.push(x[e])}if(e.normal){const t=v(p,n,d,e.normal);i.push(t[0],t[1],t[2])}e.material&&"AllSame"!==e.material.mappingType&&(h=v(p,n,d,e.material)[0]),e.uv&&e.uv.forEach((function(e,t){const r=v(p,n,d,e);void 0===l[t]&&(l[t]=[]),l[t].push(r[0]),l[t].push(r[1])})),r++,m&&(u.genFace(t,e,a,h,i,s,l,c,f,r),n++,r=0,a=[],i=[],s=[],l=[],c=[],f=[])})),t}genFace(e,t,n,r,o,a,i,s,l,c){for(let f=2;f<c;f++)e.vertex.push(t.vertexPositions[n[0]]),e.vertex.push(t.vertexPositions[n[1]]),e.vertex.push(t.vertexPositions[n[2]]),e.vertex.push(t.vertexPositions[n[3*(f-1)]]),e.vertex.push(t.vertexPositions[n[3*(f-1)+1]]),e.vertex.push(t.vertexPositions[n[3*(f-1)+2]]),e.vertex.push(t.vertexPositions[n[3*f]]),e.vertex.push(t.vertexPositions[n[3*f+1]]),e.vertex.push(t.vertexPositions[n[3*f+2]]),t.skeleton&&(e.vertexWeights.push(s[0]),e.vertexWeights.push(s[1]),e.vertexWeights.push(s[2]),e.vertexWeights.push(s[3]),e.vertexWeights.push(s[4*(f-1)]),e.vertexWeights.push(s[4*(f-1)+1]),e.vertexWeights.push(s[4*(f-1)+2]),e.vertexWeights.push(s[4*(f-1)+3]),e.vertexWeights.push(s[4*f]),e.vertexWeights.push(s[4*f+1]),e.vertexWeights.push(s[4*f+2]),e.vertexWeights.push(s[4*f+3]),e.weightsIndices.push(l[0]),e.weightsIndices.push(l[1]),e.weightsIndices.push(l[2]),e.weightsIndices.push(l[3]),e.weightsIndices.push(l[4*(f-1)]),e.weightsIndices.push(l[4*(f-1)+1]),e.weightsIndices.push(l[4*(f-1)+2]),e.weightsIndices.push(l[4*(f-1)+3]),e.weightsIndices.push(l[4*f]),e.weightsIndices.push(l[4*f+1]),e.weightsIndices.push(l[4*f+2]),e.weightsIndices.push(l[4*f+3])),t.color&&(e.colors.push(a[0]),e.colors.push(a[1]),e.colors.push(a[2]),e.colors.push(a[3*(f-1)]),e.colors.push(a[3*(f-1)+1]),e.colors.push(a[3*(f-1)+2]),e.colors.push(a[3*f]),e.colors.push(a[3*f+1]),e.colors.push(a[3*f+2])),t.material&&"AllSame"!==t.material.mappingType&&(e.materialIndex.push(r),e.materialIndex.push(r),e.materialIndex.push(r)),t.normal&&(e.normal.push(o[0]),e.normal.push(o[1]),e.normal.push(o[2]),e.normal.push(o[3*(f-1)]),e.normal.push(o[3*(f-1)+1]),e.normal.push(o[3*(f-1)+2]),e.normal.push(o[3*f]),e.normal.push(o[3*f+1]),e.normal.push(o[3*f+2])),t.uv&&t.uv.forEach((function(t,n){void 0===e.uvs[n]&&(e.uvs[n]=[]),e.uvs[n].push(i[n][0]),e.uvs[n].push(i[n][1]),e.uvs[n].push(i[n][2*(f-1)]),e.uvs[n].push(i[n][2*(f-1)+1]),e.uvs[n].push(i[n][2*f]),e.uvs[n].push(i[n][2*f+1])}))}addMorphTargets(t,n,r,o){if(0===r.length)return;t.morphTargetsRelative=!0,t.morphAttributes.position=[];const a=this;r.forEach((function(r){r.rawTargets.forEach((function(r){const i=e.Objects.Geometry[r.geoID];void 0!==i&&a.genMorphGeometry(t,n,i,o,r.name)}))}))}genMorphGeometry(e,t,n,r,o){const a=void 0!==t.PolygonVertexIndex?t.PolygonVertexIndex.a:[],i=void 0!==n.Vertices?n.Vertices.a:[],s=void 0!==n.Indexes?n.Indexes.a:[],l=3*e.attributes.position.count,c=new Float32Array(l);for(let e=0;e<s.length;e++){const t=3*s[e];c[t]=i[3*e],c[t+1]=i[3*e+1],c[t+2]=i[3*e+2]}const f={vertexIndices:a,vertexPositions:c},u=this.genBuffers(f),d=new THREE.Float32BufferAttribute(u.vertex,3);d.name=o||n.attrName,d.applyMatrix4(r),e.morphAttributes.position.push(d)}parseNormals(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Normals.a;let o=[];return"IndexToDirect"===n&&("NormalIndex"in e?o=e.NormalIndex.a:"NormalsIndex"in e&&(o=e.NormalsIndex.a)),{dataSize:3,buffer:r,indices:o,mappingType:t,referenceType:n}}parseUVs(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.UV.a;let o=[];return"IndexToDirect"===n&&(o=e.UVIndex.a),{dataSize:2,buffer:r,indices:o,mappingType:t,referenceType:n}}parseVertexColors(e){const t=e.MappingInformationType,n=e.ReferenceInformationType,r=e.Colors.a;let o=[];return"IndexToDirect"===n&&(o=e.ColorIndex.a),{dataSize:4,buffer:r,indices:o,mappingType:t,referenceType:n}}parseMaterialIndices(e){const t=e.MappingInformationType,n=e.ReferenceInformationType;if("NoMappingInformation"===t)return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:n};const r=e.Materials.a,o=[];for(let e=0;e<r.length;++e)o.push(e);return{dataSize:1,buffer:r,indices:o,mappingType:t,referenceType:n}}parseNurbsGeometry(e){if(void 0===THREE.NURBSCurve)return console.error("THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new THREE.BufferGeometry;const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new THREE.BufferGeometry;const n=t-1,r=e.KnotVector.a,o=[],a=e.Points.a;for(let e=0,t=a.length;e<t;e+=4)o.push((new THREE.Vector4).fromArray(a,e));let i,s;if("Closed"===e.Form)o.push(o[0]);else if("Periodic"===e.Form){i=n,s=r.length-1-i;for(let e=0;e<n;++e)o.push(o[e])}const l=new THREE.NURBSCurve(n,r,o,i,s).getPoints(7*o.length),c=new Float32Array(3*l.length);l.forEach((function(e,t){e.toArray(c,3*t)}));const f=new THREE.BufferGeometry;return f.setAttribute("position",new THREE.BufferAttribute(c,3)),f}}class s{parse(){const e=[],t=this.parseClips();if(void 0!==t)for(const n in t){const r=t[n],o=this.addClip(r);e.push(o)}return e}parseClips(){if(void 0===e.Objects.AnimationCurve)return;const t=this.parseAnimationCurveNodes();this.parseAnimationCurves(t);const n=this.parseAnimationLayers(t);return this.parseAnimStacks(n)}parseAnimationCurveNodes(){const t=e.Objects.AnimationCurveNode,n=new Map;for(const e in t){const r=t[e];if(null!==r.attrName.match(/S|R|T|DeformPercent/)){const e={id:r.id,attr:r.attrName,curves:{}};n.set(e.id,e)}}return n}parseAnimationCurves(n){const r=e.Objects.AnimationCurve;for(const e in r){const o={id:r[e].id,times:r[e].KeyTime.a.map(p),values:r[e].KeyValueFloat.a},a=t.get(o.id);if(void 0!==a){const e=a.parents[0].ID,t=a.parents[0].relationship;t.match(/X/)?n.get(e).curves.x=o:t.match(/Y/)?n.get(e).curves.y=o:t.match(/Z/)?n.get(e).curves.z=o:t.match(/d|DeformPercent/)&&n.has(e)&&(n.get(e).curves.morph=o)}}}parseAnimationLayers(r){const o=e.Objects.AnimationLayer,a=new Map;for(const i in o){const o=[],s=t.get(parseInt(i));if(void 0!==s){s.children.forEach((function(a,i){if(r.has(a.ID)){const s=r.get(a.ID);if(void 0!==s.curves.x||void 0!==s.curves.y||void 0!==s.curves.z){if(void 0===o[i]){const r=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID;if(void 0!==r){const t=e.Objects.Model[r.toString()];if(void 0===t)return void console.warn("THREE.FBXLoader: Encountered a unused curve.",a);const s={modelName:t.attrName?THREE.PropertyBinding.sanitizeNodeName(t.attrName):"",ID:t.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};n.traverse((function(e){e.ID===t.id&&(s.transform=e.matrix,e.userData.transformData&&(s.eulerOrder=e.userData.transformData.eulerOrder))})),s.transform||(s.transform=new THREE.Matrix4),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),o[i]=s}}o[i]&&(o[i][s.attr]=s)}else if(void 0!==s.curves.morph){if(void 0===o[i]){const n=t.get(a.ID).parents.filter((function(e){return void 0!==e.relationship}))[0].ID,r=t.get(n).parents[0].ID,s=t.get(r).parents[0].ID,l=t.get(s).parents[0].ID,c=e.Objects.Model[l],f={modelName:c.attrName?THREE.PropertyBinding.sanitizeNodeName(c.attrName):"",morphName:e.Objects.Deformer[n].attrName};o[i]=f}o[i][s.attr]=s}}})),a.set(parseInt(i),o)}}return a}parseAnimStacks(n){const r=e.Objects.AnimationStack,o={};for(const e in r){const a=t.get(parseInt(e)).children;a.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const i=n.get(a[0].ID);o[e]={name:r[e].attrName,layer:i}}return o}addClip(e){let t=[];const n=this;return e.layer.forEach((function(e){t=t.concat(n.generateTracks(e))})),new THREE.AnimationClip(e.name,-1,t)}generateTracks(e){const t=[];let n=new THREE.Vector3,r=new THREE.Quaternion,o=new THREE.Vector3;if(e.transform&&e.transform.decompose(n,r,o),n=n.toArray(),r=(new THREE.Euler).setFromQuaternion(r,e.eulerOrder).toArray(),o=o.toArray(),void 0!==e.T&&Object.keys(e.T.curves).length>0){const r=this.generateVectorTrack(e.modelName,e.T.curves,n,"position");void 0!==r&&t.push(r)}if(void 0!==e.R&&Object.keys(e.R.curves).length>0){const n=this.generateRotationTrack(e.modelName,e.R.curves,r,e.preRotation,e.postRotation,e.eulerOrder);void 0!==n&&t.push(n)}if(void 0!==e.S&&Object.keys(e.S.curves).length>0){const n=this.generateVectorTrack(e.modelName,e.S.curves,o,"scale");void 0!==n&&t.push(n)}if(void 0!==e.DeformPercent){const n=this.generateMorphTrack(e);void 0!==n&&t.push(n)}return t}generateVectorTrack(e,t,n,r){const o=this.getTimesForAllAxes(t),a=this.getKeyframeTrackValues(o,t,n);return new THREE.VectorKeyframeTrack(e+"."+r,o,a)}generateRotationTrack(e,t,n,r,o,a){void 0!==t.x&&(this.interpolateRotations(t.x),t.x.values=t.x.values.map(THREE.MathUtils.degToRad)),void 0!==t.y&&(this.interpolateRotations(t.y),t.y.values=t.y.values.map(THREE.MathUtils.degToRad)),void 0!==t.z&&(this.interpolateRotations(t.z),t.z.values=t.z.values.map(THREE.MathUtils.degToRad));const i=this.getTimesForAllAxes(t),s=this.getKeyframeTrackValues(i,t,n);void 0!==r&&((r=r.map(THREE.MathUtils.degToRad)).push(a),r=(new THREE.Euler).fromArray(r),r=(new THREE.Quaternion).setFromEuler(r)),void 0!==o&&((o=o.map(THREE.MathUtils.degToRad)).push(a),o=(new THREE.Euler).fromArray(o),o=(new THREE.Quaternion).setFromEuler(o).invert());const l=new THREE.Quaternion,c=new THREE.Euler,f=[];for(let e=0;e<s.length;e+=3)c.set(s[e],s[e+1],s[e+2],a),l.setFromEuler(c),void 0!==r&&l.premultiply(r),void 0!==o&&l.multiply(o),l.toArray(f,e/3*4);return new THREE.QuaternionKeyframeTrack(e+".quaternion",i,f)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,r=t.values.map((function(e){return e/100})),o=n.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new THREE.NumberKeyframeTrack(e.modelName+".morphTargetInfluences["+o+"]",t.times,r)}getTimesForAllAxes(e){let t=[];if(void 0!==e.x&&(t=t.concat(e.x.times)),void 0!==e.y&&(t=t.concat(e.y.times)),void 0!==e.z&&(t=t.concat(e.z.times)),t=t.sort((function(e,t){return e-t})),t.length>1){let e=1,n=t[0];for(let r=1;r<t.length;r++){const o=t[r];o!==n&&(t[e]=o,n=o,e++)}t=t.slice(0,e)}return t}getKeyframeTrackValues(e,t,n){const r=n,o=[];let a=-1,i=-1,s=-1;return e.forEach((function(e){if(t.x&&(a=t.x.times.indexOf(e)),t.y&&(i=t.y.times.indexOf(e)),t.z&&(s=t.z.times.indexOf(e)),-1!==a){const e=t.x.values[a];o.push(e),r[0]=e}else o.push(r[0]);if(-1!==i){const e=t.y.values[i];o.push(e),r[1]=e}else o.push(r[1]);if(-1!==s){const e=t.z.values[s];o.push(e),r[2]=e}else o.push(r[2])})),o}interpolateRotations(e){for(let t=1;t<e.values.length;t++){const n=e.values[t-1],r=e.values[t]-n,o=Math.abs(r);if(o>=180){const a=o/180,i=r/a;let s=n+i;const l=e.times[t-1],c=(e.times[t]-l)/a;let f=l+c;const u=[],d=[];for(;f<e.times[t];)u.push(f),f+=c,d.push(s),s+=i;e.times=b(e.times,t,u),e.values=b(e.values,t,d)}}}}class l{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new u,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,n=e.split(/[\r\n]+/);return n.forEach((function(e,r){const o=e.match(/^[\s\t]*;/),a=e.match(/^[\s\t]*$/);if(o||a)return;const i=e.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),s=e.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),l=e.match("^\\t{"+(t.currentIndent-1)+"}}");i?t.parseNodeBegin(e,i):s?t.parseNodeProperty(e,s,n[++r]):l?t.popStack():e.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(e)})),this.allNodes}parseNodeBegin(e,t){const n=t[1].trim().replace(/^"/,"").replace(/"$/,""),r=t[2].split(",").map((function(e){return e.trim().replace(/^"/,"").replace(/"$/,"")})),o={name:n},a=this.parseNodeAttr(r),i=this.getCurrentNode();0===this.currentIndent?this.allNodes.add(n,o):n in i?("PoseNode"===n?i.PoseNode.push(o):void 0!==i[n].id&&(i[n]={},i[n][i[n].id]=i[n]),""!==a.id&&(i[n][a.id]=o)):"number"==typeof a.id?(i[n]={},i[n][a.id]=o):"Properties70"!==n&&(i[n]="PoseNode"===n?[o]:o),"number"==typeof a.id&&(o.id=a.id),""!==a.name&&(o.attrName=a.name),""!==a.type&&(o.attrType=a.type),this.pushStack(o)}parseNodeAttr(e){let t=e[0];""!==e[0]&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let n="",r="";return e.length>1&&(n=e[1].replace(/^(\w+)::/,""),r=e[2]),{id:t,name:n,type:r}}parseNodeProperty(e,t,n){let r=t[1].replace(/^"/,"").replace(/"$/,"").trim(),o=t[2].replace(/^"/,"").replace(/"$/,"").trim();"Content"===r&&","===o&&(o=n.replace(/"/g,"").replace(/,$/,"").trim());const a=this.getCurrentNode();if("Properties70"!==a.name){if("C"===r){const e=o.split(",").slice(1),t=parseInt(e[0]),n=parseInt(e[1]);let i=o.split(",").slice(3);i=i.map((function(e){return e.trim().replace(/^"/,"")})),r="connections",o=[t,n],function(e,t){for(let n=0,r=e.length,o=t.length;n<o;n++,r++)e[r]=t[n]}(o,i),void 0===a[r]&&(a[r]=[])}"Node"===r&&(a.id=o),r in a&&Array.isArray(a[r])?a[r].push(o):"a"!==r?a[r]=o:a.a=o,this.setCurrentProp(a,r),"a"===r&&","!==o.slice(-1)&&(a.a=E(o))}else this.parseNodeSpecialProperty(e,r,o)}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,","!==e.slice(-1)&&(t.a=E(t.a))}parseNodeSpecialProperty(e,t,n){const r=n.split('",').map((function(e){return e.trim().replace(/^\"/,"").replace(/\s/,"_")})),o=r[0],a=r[1],i=r[2],s=r[3];let l=r[4];switch(a){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":l=parseFloat(l);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":l=E(l)}this.getPrevNode()[o]={type:a,type2:i,flag:s,value:l},this.setCurrentProp(this.getPrevNode(),o)}}class c{parse(e){const t=new f(e);t.skip(23);const n=t.getUint32();if(n<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+n);const r=new u;for(;!this.endOfContent(t);){const e=this.parseNode(t,n);null!==e&&r.add(e.name,e)}return r}endOfContent(e){return e.size()%16==0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const n={},r=t>=7500?e.getUint64():e.getUint32(),o=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const a=e.getUint8(),i=e.getString(a);if(0===r)return null;const s=[];for(let t=0;t<o;t++)s.push(this.parseProperty(e));const l=s.length>0?s[0]:"",c=s.length>1?s[1]:"",f=s.length>2?s[2]:"";for(n.singleProperty=1===o&&e.getOffset()===r;r>e.getOffset();){const r=this.parseNode(e,t);null!==r&&this.parseSubNode(i,n,r)}return n.propertyList=s,"number"==typeof l&&(n.id=l),""!==c&&(n.attrName=c),""!==f&&(n.attrType=f),""!==i&&(n.name=i),n}parseSubNode(e,t,n){if(!0===n.singleProperty){const e=n.propertyList[0];Array.isArray(e)?(t[n.name]=n,n.a=e):t[n.name]=e}else if("Connections"===e&&"C"===n.name){const e=[];n.propertyList.forEach((function(t,n){0!==n&&e.push(t)})),void 0===t.connections&&(t.connections=[]),t.connections.push(e)}else if("Properties70"===n.name){Object.keys(n).forEach((function(e){t[e]=n[e]}))}else if("Properties70"===e&&"P"===n.name){let e=n.propertyList[0],r=n.propertyList[1];const o=n.propertyList[2],a=n.propertyList[3];let i;0===e.indexOf("Lcl ")&&(e=e.replace("Lcl ","Lcl_")),0===r.indexOf("Lcl ")&&(r=r.replace("Lcl ","Lcl_")),i="Color"===r||"ColorRGB"===r||"Vector"===r||"Vector3D"===r||0===r.indexOf("Lcl_")?[n.propertyList[4],n.propertyList[5],n.propertyList[6]]:n.propertyList[4],t[e]={type:r,type2:o,flag:a,value:i}}else void 0===t[n.name]?"number"==typeof n.id?(t[n.name]={},t[n.name][n.id]=n):t[n.name]=n:"PoseNode"===n.name?(Array.isArray(t[n.name])||(t[n.name]=[t[n.name]]),t[n.name].push(n)):void 0===t[n.name][n.id]&&(t[n.name][n.id]=n)}parseProperty(e){const t=e.getString(1);let n;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return n=e.getUint32(),e.getArrayBuffer(n);case"S":return n=e.getUint32(),e.getString(n);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const o=e.getUint32(),a=e.getUint32(),i=e.getUint32();if(0===a)switch(t){case"b":case"c":return e.getBooleanArray(o);case"d":return e.getFloat64Array(o);case"f":return e.getFloat32Array(o);case"i":return e.getInt32Array(o);case"l":return e.getInt64Array(o)}void 0===r&&console.error("THREE.FBXLoader: External library fflate.min.js required.");const s=r.unzlibSync(new Uint8Array(e.getArrayBuffer(i))),l=new f(s.buffer);switch(t){case"b":case"c":return l.getBooleanArray(o);case"d":return l.getFloat64Array(o);case"f":return l.getFloat32Array(o);case"i":return l.getInt32Array(o);case"l":return l.getInt64Array(o)}default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class f{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=void 0===t||t}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return 1==(1&this.getUint8())}getBooleanArray(e){const t=[];for(let n=0;n<e;n++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),2147483648&t?(t=4294967295&~t,e=4294967295&~e,4294967295===e&&(t=t+1&4294967295),e=e+1&4294967295,-(4294967296*t+e)):4294967296*t+e}getInt64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),4294967296*t+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let n=0;n<e;n++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){let t=[];for(let n=0;n<e;n++)t[n]=this.getUint8();const n=t.indexOf(0);return n>=0&&(t=t.slice(0,n)),THREE.LoaderUtils.decodeText(new Uint8Array(t))}}class u{add(e,t){this[e]=t}}function d(e){const t=e.match(/FBXVersion: (\d+)/);if(t){return parseInt(t[1])}throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function p(e){return e/46186158e3}const h=[];function v(e,t,n,r){let o;switch(r.mappingType){case"ByPolygonVertex":o=e;break;case"ByPolygon":o=t;break;case"ByVertice":o=n;break;case"AllSame":o=r.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+r.mappingType)}"IndexToDirect"===r.referenceType&&(o=r.indices[o]);const a=o*r.dataSize,i=a+r.dataSize;return function(e,t,n,r){for(let o=n,a=0;o<r;o++,a++)e[a]=t[o];return e}(h,r.buffer,a,i)}const m=new THREE.Euler,x=new THREE.Vector3;function g(e){const t=new THREE.Matrix4,n=new THREE.Matrix4,r=new THREE.Matrix4,o=new THREE.Matrix4,a=new THREE.Matrix4,i=new THREE.Matrix4,s=new THREE.Matrix4,l=new THREE.Matrix4,c=new THREE.Matrix4,f=new THREE.Matrix4,u=new THREE.Matrix4,d=new THREE.Matrix4,p=e.inheritType?e.inheritType:0;if(e.translation&&t.setPosition(x.fromArray(e.translation)),e.preRotation){const t=e.preRotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),n.makeRotationFromEuler(m.fromArray(t))}if(e.rotation){const t=e.rotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),r.makeRotationFromEuler(m.fromArray(t))}if(e.postRotation){const t=e.postRotation.map(THREE.MathUtils.degToRad);t.push(e.eulerOrder),o.makeRotationFromEuler(m.fromArray(t)),o.invert()}e.scale&&a.scale(x.fromArray(e.scale)),e.scalingOffset&&s.setPosition(x.fromArray(e.scalingOffset)),e.scalingPivot&&i.setPosition(x.fromArray(e.scalingPivot)),e.rotationOffset&&l.setPosition(x.fromArray(e.rotationOffset)),e.rotationPivot&&c.setPosition(x.fromArray(e.rotationPivot)),e.parentMatrixWorld&&(u.copy(e.parentMatrix),f.copy(e.parentMatrixWorld));const h=(new THREE.Matrix4).copy(n).multiply(r).multiply(o),v=new THREE.Matrix4;v.extractRotation(f);const g=new THREE.Matrix4;g.copyPosition(f);const y=new THREE.Matrix4,E=(new THREE.Matrix4).copy(g).invert().multiply(f);y.copy(v).invert().multiply(E);const w=a,b=new THREE.Matrix4;if(0===p)b.copy(v).multiply(h).multiply(y).multiply(w);else if(1===p)b.copy(v).multiply(y).multiply(h).multiply(w);else{const e=(new THREE.Matrix4).scale((new THREE.Vector3).setFromMatrixScale(u)),t=(new THREE.Matrix4).copy(e).invert(),n=(new THREE.Matrix4).copy(y).multiply(t);b.copy(v).multiply(h).multiply(n).multiply(w)}const _=new THREE.Matrix4;_.copy(c).invert();const T=new THREE.Matrix4;T.copy(i).invert();let A=new THREE.Matrix4;A.copy(t).multiply(l).multiply(c).multiply(n).multiply(r).multiply(o).multiply(_).multiply(s).multiply(i).multiply(a).multiply(T);const S=(new THREE.Matrix4).copyPosition(A),R=(new THREE.Matrix4).copy(f).multiply(S);return d.copyPosition(R),A=(new THREE.Matrix4).copy(d).multiply(b),A.premultiply(f.invert()),A}function y(e){const t=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return 6===(e=e||0)?(console.warn("THREE.FBXLoader: unsupported THREE.Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),t[0]):t[e]}function E(e){return e.split(",").map((function(e){return parseFloat(e)}))}function w(e,t,n){return void 0===t&&(t=0),void 0===n&&(n=e.byteLength),THREE.LoaderUtils.decodeText(new Uint8Array(e,t,n))}function b(e,t,n){return e.slice(0,t).concat(n).concat(e.slice(t))}THREE.FBXLoader=o}()},5435:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/1024,1/512)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:'\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\t#define FXAA_PC 1\n\t\t#define FXAA_GLSL_100 1\n\t\t#define FXAA_QUALITY_PRESET 12\n\n\t\t#define FXAA_GREEN_AS_LUMA 1\n\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_PC_CONSOLE\n\t\t\t\t//\n\t\t\t\t// The console algorithm for PC is included\n\t\t\t\t// for developers targeting really low spec machines.\n\t\t\t\t// Likely better to just run FXAA_PC, and use a really low preset.\n\t\t\t\t//\n\t\t\t\t#define FXAA_PC_CONSOLE 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_120\n\t\t\t\t#define FXAA_GLSL_120 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GLSL_130\n\t\t\t\t#define FXAA_GLSL_130 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_3\n\t\t\t\t#define FXAA_HLSL_3 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_4\n\t\t\t\t#define FXAA_HLSL_4 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_HLSL_5\n\t\t\t\t#define FXAA_HLSL_5 0\n\t\t#endif\n\t\t/*==========================================================================*/\n\t\t#ifndef FXAA_GREEN_AS_LUMA\n\t\t\t\t//\n\t\t\t\t// For those using non-linear color,\n\t\t\t\t// and either not able to get luma in alpha, or not wanting to,\n\t\t\t\t// this enables FXAA to run using green as a proxy for luma.\n\t\t\t\t// So with this enabled, no need to pack luma in alpha.\n\t\t\t\t//\n\t\t\t\t// This will turn off AA on anything which lacks some amount of green.\n\t\t\t\t// Pure red and blue or combination of only R and B, will get no AA.\n\t\t\t\t//\n\t\t\t\t// Might want to lower the settings for both,\n\t\t\t\t//\t\tfxaaConsoleEdgeThresholdMin\n\t\t\t\t//\t\tfxaaQualityEdgeThresholdMin\n\t\t\t\t// In order to insure AA does not get turned off on colors\n\t\t\t\t// which contain a minor amount of green.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_GREEN_AS_LUMA 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_EARLY_EXIT\n\t\t\t\t//\n\t\t\t\t// Controls algorithm\'s early exit path.\n\t\t\t\t// On PS3 turning this ON adds 2 cycles to the shader.\n\t\t\t\t// On 360 turning this OFF adds 10ths of a millisecond to the shader.\n\t\t\t\t// Turning this off on console will result in a more blurry image.\n\t\t\t\t// So this defaults to on.\n\t\t\t\t//\n\t\t\t\t// 1 = On.\n\t\t\t\t// 0 = Off.\n\t\t\t\t//\n\t\t\t\t#define FXAA_EARLY_EXIT 1\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_DISCARD\n\t\t\t\t//\n\t\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t\t//\n\t\t\t\t// 1 = Use discard on pixels which don\'t need AA.\n\t\t\t\t//\t\t For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t\t// 0 = Return unchanged color on pixels which don\'t need AA.\n\t\t\t\t//\n\t\t\t\t#define FXAA_DISCARD 0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t//\n\t\t\t\t// Used for GLSL 120 only.\n\t\t\t\t//\n\t\t\t\t// 1 = GL API supports fast pixel offsets\n\t\t\t\t// 0 = do not use fast pixel offsets\n\t\t\t\t//\n\t\t\t\t#ifdef GL_EXT_gpu_shader4\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_FAST_PIXEL_OFFSET\n\t\t\t\t\t\t#define FXAA_FAST_PIXEL_OFFSET 0\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t//\n\t\t\t\t// 1 = API supports gather4 on alpha channel.\n\t\t\t\t// 0 = API does not support gather4 on alpha channel.\n\t\t\t\t//\n\t\t\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_ARB_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifdef GL_NV_gpu_shader5\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 1\n\t\t\t\t#endif\n\t\t\t\t#ifndef FXAA_GATHER4_ALPHA\n\t\t\t\t\t\t#define FXAA_GATHER4_ALPHA 0\n\t\t\t\t#endif\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tFXAA QUALITY - TUNING KNOBS\n\t\t------------------------------------------------------------------------------\n\t\tNOTE the other tuning knobs are now in the shader function inputs!\n\t\t============================================================================*/\n\t\t#ifndef FXAA_QUALITY_PRESET\n\t\t\t\t//\n\t\t\t\t// Choose the quality preset.\n\t\t\t\t// This needs to be compiled into the shader as it effects code.\n\t\t\t\t// Best option to include multiple presets is to\n\t\t\t\t// in each shader define the preset, then include this file.\n\t\t\t\t//\n\t\t\t\t// OPTIONS\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 10 to 15 - default medium dither (10=fastest, 15=highest quality)\n\t\t\t\t// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\n\t\t\t\t// 39\t\t\t - no dither, very expensive\n\t\t\t\t//\n\t\t\t\t// NOTES\n\t\t\t\t// -----------------------------------------------------------------------\n\t\t\t\t// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\n\t\t\t\t// 13 = about same speed as FXAA 3.9 and better than 12\n\t\t\t\t// 23 = closest to FXAA 3.9 visually and performance wise\n\t\t\t\t//\t_ = the lowest digit is directly related to performance\n\t\t\t\t// _\t= the highest digit is directly related to style\n\t\t\t\t//\n\t\t\t\t#define FXAA_QUALITY_PRESET 12\n\t\t#endif\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - PRESETS\n\n\t\t============================================================================*/\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - MEDIUM DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 10)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 3.0\n\t\t\t\t#define FXAA_QUALITY_P2 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 11)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 3.0\n\t\t\t\t#define FXAA_QUALITY_P3 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 12)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 4.0\n\t\t\t\t#define FXAA_QUALITY_P4 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 13)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 4.0\n\t\t\t\t#define FXAA_QUALITY_P5 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 14)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 4.0\n\t\t\t\t#define FXAA_QUALITY_P6 12.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 15)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 12.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - LOW DITHER PRESETS\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 20)\n\t\t\t\t#define FXAA_QUALITY_PS 3\n\t\t\t\t#define FXAA_QUALITY_P0 1.5\n\t\t\t\t#define FXAA_QUALITY_P1 2.0\n\t\t\t\t#define FXAA_QUALITY_P2 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 21)\n\t\t\t\t#define FXAA_QUALITY_PS 4\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 22)\n\t\t\t\t#define FXAA_QUALITY_PS 5\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 23)\n\t\t\t\t#define FXAA_QUALITY_PS 6\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 24)\n\t\t\t\t#define FXAA_QUALITY_PS 7\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 3.0\n\t\t\t\t#define FXAA_QUALITY_P6 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 25)\n\t\t\t\t#define FXAA_QUALITY_PS 8\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 4.0\n\t\t\t\t#define FXAA_QUALITY_P7 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 26)\n\t\t\t\t#define FXAA_QUALITY_PS 9\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 4.0\n\t\t\t\t#define FXAA_QUALITY_P8 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 27)\n\t\t\t\t#define FXAA_QUALITY_PS 10\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 4.0\n\t\t\t\t#define FXAA_QUALITY_P9 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 28)\n\t\t\t\t#define FXAA_QUALITY_PS 11\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 4.0\n\t\t\t\t#define FXAA_QUALITY_P10 8.0\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_QUALITY_PRESET == 29)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.5\n\t\t\t\t#define FXAA_QUALITY_P2 2.0\n\t\t\t\t#define FXAA_QUALITY_P3 2.0\n\t\t\t\t#define FXAA_QUALITY_P4 2.0\n\t\t\t\t#define FXAA_QUALITY_P5 2.0\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t\t FXAA QUALITY - EXTREME QUALITY\n\t\t============================================================================*/\n\t\t#if (FXAA_QUALITY_PRESET == 39)\n\t\t\t\t#define FXAA_QUALITY_PS 12\n\t\t\t\t#define FXAA_QUALITY_P0 1.0\n\t\t\t\t#define FXAA_QUALITY_P1 1.0\n\t\t\t\t#define FXAA_QUALITY_P2 1.0\n\t\t\t\t#define FXAA_QUALITY_P3 1.0\n\t\t\t\t#define FXAA_QUALITY_P4 1.0\n\t\t\t\t#define FXAA_QUALITY_P5 1.5\n\t\t\t\t#define FXAA_QUALITY_P6 2.0\n\t\t\t\t#define FXAA_QUALITY_P7 2.0\n\t\t\t\t#define FXAA_QUALITY_P8 2.0\n\t\t\t\t#define FXAA_QUALITY_P9 2.0\n\t\t\t\t#define FXAA_QUALITY_P10 4.0\n\t\t\t\t#define FXAA_QUALITY_P11 8.0\n\t\t#endif\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tAPI PORTING\n\n\t\t============================================================================*/\n\t\t#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard discard\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 vec2\n\t\t\t\t#define FxaaFloat3 vec3\n\t\t\t\t#define FxaaFloat4 vec4\n\t\t\t\t#define FxaaHalf float\n\t\t\t\t#define FxaaHalf2 vec2\n\t\t\t\t#define FxaaHalf3 vec3\n\t\t\t\t#define FxaaHalf4 vec4\n\t\t\t\t#define FxaaInt2 ivec2\n\t\t\t\t#define FxaaSat(x) clamp(x, 0.0, 1.0)\n\t\t\t\t#define FxaaTex sampler2D\n\t\t#else\n\t\t\t\t#define FxaaBool bool\n\t\t\t\t#define FxaaDiscard clip(-1)\n\t\t\t\t#define FxaaFloat float\n\t\t\t\t#define FxaaFloat2 float2\n\t\t\t\t#define FxaaFloat3 float3\n\t\t\t\t#define FxaaFloat4 float4\n\t\t\t\t#define FxaaHalf half\n\t\t\t\t#define FxaaHalf2 half2\n\t\t\t\t#define FxaaHalf3 half3\n\t\t\t\t#define FxaaHalf4 half4\n\t\t\t\t#define FxaaSat(x) saturate(x)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t#define FxaaTexTop(t, p) texture2D(t, p, 0.0)\n\t\t\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_120 == 1)\n\t\t\t\t// Requires,\n\t\t\t\t//\t#version 120\n\t\t\t\t// And at least,\n\t\t\t\t//\t#extension GL_EXT_gpu_shader4 : enable\n\t\t\t\t//\t(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\n\t\t\t\t#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\n\t\t\t\t#if (FXAA_FAST_PIXEL_OFFSET == 1)\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\n\t\t\t\t#else\n\t\t\t\t\t\t#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\n\t\t\t\t#endif\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_GLSL_130 == 1)\n\t\t\t\t// Requires "#version 130" or better\n\t\t\t\t#define FxaaTexTop(t, p) textureLod(t, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t// use #extension GL_ARB_gpu_shader5 : enable\n\t\t\t\t\t\t#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\n\t\t\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\n\t\t\t\t\t\t#define FxaaTexGreen4(t, p) textureGather(t, p, 1)\n\t\t\t\t\t\t#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\n\t\t\t\t#endif\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_3 == 1)\n\t\t\t\t#define FxaaInt2 float2\n\t\t\t\t#define FxaaTex sampler2D\n\t\t\t\t#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\n\t\t\t\t#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_4 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t#if (FXAA_HLSL_5 == 1)\n\t\t\t\t#define FxaaInt2 int2\n\t\t\t\tstruct FxaaTex { SamplerState smpl; Texture2D tex; };\n\t\t\t\t#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\n\t\t\t\t#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\n\t\t\t\t#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\n\t\t\t\t#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\n\t\t\t\t#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\n\t\t\t\t#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\n\t\t#endif\n\n\n\t\t/*============================================================================\n\t\t\t\t\t\t\t\t\t\t\t GREEN AS LUMA OPTION SUPPORT FUNCTION\n\t\t============================================================================*/\n\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\n\t\t#else\n\t\t\t\tFxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\n\t\t#endif\n\n\n\n\n\t\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t FXAA3 QUALITY - PC\n\n\t\t============================================================================*/\n\t\t#if (FXAA_PC == 1)\n\t\t/*--------------------------------------------------------------------------*/\n\t\tFxaaFloat4 FxaaPixelShader(\n\t\t\t\t//\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy} = center of pixel\n\t\t\t\tFxaaFloat2 pos,\n\t\t\t\t//\n\t\t\t\t// Used only for FXAA Console, and not used on the 360 version.\n\t\t\t\t// Use noperspective interpolation here (turn off perspective interpolation).\n\t\t\t\t// {xy_} = upper left of pixel\n\t\t\t\t// {_zw} = lower right of pixel\n\t\t\t\tFxaaFloat4 fxaaConsolePosPos,\n\t\t\t\t//\n\t\t\t\t// Input color texture.\n\t\t\t\t// {rgb_} = color in linear or perceptual color space\n\t\t\t\t// if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t//\t\t {__a} = luma in perceptual color space (not linear)\n\t\t\t\tFxaaTex tex,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 2nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -1.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegOne,\n\t\t\t\t//\n\t\t\t\t// Only used on the optimized 360 version of FXAA Console.\n\t\t\t\t// For everything but 360, just use the same input here as for "tex".\n\t\t\t\t// For 360, same texture, just alias with a 3nd sampler.\n\t\t\t\t// This sampler needs to have an exponent bias of -2.\n\t\t\t\tFxaaTex fxaaConsole360TexExpBiasNegTwo,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x_} = 1.0/screenWidthInPixels\n\t\t\t\t// {_y} = 1.0/screenHeightInPixels\n\t\t\t\tFxaaFloat2 fxaaQualityRcpFrame,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// This effects sub-pixel AA quality and inversely sharpness.\n\t\t\t\t//\t Where N ranges between,\n\t\t\t\t//\t\t N = 0.50 (default)\n\t\t\t\t//\t\t N = 0.33 (sharper)\n\t\t\t\t// {x__} = -N/screenWidthInPixels\n\t\t\t\t// {_y_} = -N/screenHeightInPixels\n\t\t\t\t// {_z_} =\tN/screenWidthInPixels\n\t\t\t\t// {__w} =\tN/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Not used on 360, but used on PS3 and PC.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} = -2.0/screenWidthInPixels\n\t\t\t\t// {_y_} = -2.0/screenHeightInPixels\n\t\t\t\t// {_z_} =\t2.0/screenWidthInPixels\n\t\t\t\t// {__w} =\t2.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsoleRcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\n\t\t\t\t// This must be from a constant/uniform.\n\t\t\t\t// {x__} =\t8.0/screenWidthInPixels\n\t\t\t\t// {_y_} =\t8.0/screenHeightInPixels\n\t\t\t\t// {_z_} = -4.0/screenWidthInPixels\n\t\t\t\t// {__w} = -4.0/screenHeightInPixels\n\t\t\t\tFxaaFloat4 fxaaConsole360RcpFrameOpt2,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_SUBPIX define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Choose the amount of sub-pixel aliasing removal.\n\t\t\t\t// This can effect sharpness.\n\t\t\t\t//\t 1.00 - upper limit (softer)\n\t\t\t\t//\t 0.75 - default amount of filtering\n\t\t\t\t//\t 0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n\t\t\t\t//\t 0.25 - almost off\n\t\t\t\t//\t 0.00 - completely off\n\t\t\t\tFxaaFloat fxaaQualitySubpix,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// The minimum amount of local contrast required to apply algorithm.\n\t\t\t\t//\t 0.333 - too little (faster)\n\t\t\t\t//\t 0.250 - low quality\n\t\t\t\t//\t 0.166 - default\n\t\t\t\t//\t 0.125 - high quality\n\t\t\t\t//\t 0.063 - overkill (slower)\n\t\t\t\tFxaaFloat fxaaQualityEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Quality.\n\t\t\t\t// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t//\t 0.0833 - upper limit (default, the start of visible unfiltered edges)\n\t\t\t\t//\t 0.0625 - high quality (faster)\n\t\t\t\t//\t 0.0312 - visible limit (slower)\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaQualityEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only three safe values here: 2 and 4 and 8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// For all other platforms can be a non-power of two.\n\t\t\t\t//\t 8.0 is sharper (default!!!)\n\t\t\t\t//\t 4.0 is softer\n\t\t\t\t//\t 2.0 is really soft (good only for vector graphics inputs)\n\t\t\t\tFxaaFloat fxaaConsoleEdgeSharpness,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// This does not effect PS3, as this needs to be compiled in.\n\t\t\t\t//\t Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\n\t\t\t\t//\t Due to the PS3 being ALU bound,\n\t\t\t\t//\t there are only two safe values here: 1/4 and 1/8.\n\t\t\t\t//\t These options use the shaders ability to a free *|/ by 2|4|8.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// Other platforms can use other values.\n\t\t\t\t//\t 0.125 leaves less aliasing, but is softer (default!!!)\n\t\t\t\t//\t 0.25 leaves more aliasing, and is sharper\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThreshold,\n\t\t\t\t//\n\t\t\t\t// Only used on FXAA Console.\n\t\t\t\t// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\n\t\t\t\t// It is here now to allow easier tuning.\n\t\t\t\t// Trims the algorithm from processing darks.\n\t\t\t\t// The console setting has a different mapping than the quality setting.\n\t\t\t\t// This only applies when FXAA_EARLY_EXIT is 1.\n\t\t\t\t// This does not apply to PS3,\n\t\t\t\t// PS3 was simplified to avoid more shader instructions.\n\t\t\t\t//\t 0.06 - faster but more aliasing in darks\n\t\t\t\t//\t 0.05 - default\n\t\t\t\t//\t 0.04 - slower and less aliasing in darks\n\t\t\t\t// Special notes when using FXAA_GREEN_AS_LUMA,\n\t\t\t\t//\t Likely want to set this to zero.\n\t\t\t\t//\t As colors that are mostly not-green\n\t\t\t\t//\t will appear very dark in the green channel!\n\t\t\t\t//\t Tune by looking at mostly non-green content,\n\t\t\t\t//\t then start at zero and increase until aliasing is a problem.\n\t\t\t\tFxaaFloat fxaaConsoleEdgeThresholdMin,\n\t\t\t\t//\n\t\t\t\t// Extra constants for 360 FXAA Console only.\n\t\t\t\t// Use zeros or anything else for other platforms.\n\t\t\t\t// These must be in physical constant registers and NOT immediates.\n\t\t\t\t// Immediates will result in compiler un-optimizing.\n\t\t\t\t// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\n\t\t\t\tFxaaFloat4 fxaaConsole360ConstDir\n\t\t) {\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posM;\n\t\t\t\tposM.x = pos.x;\n\t\t\t\tposM.y = pos.y;\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 1)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\n\t\t\t\t\t\t\t\tFxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\t#define lumaM luma4A.w\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#define lumaE luma4A.z\n\t\t\t\t\t\t#define lumaS luma4A.x\n\t\t\t\t\t\t#define lumaSE luma4A.y\n\t\t\t\t\t\t#define lumaNW luma4B.w\n\t\t\t\t\t\t#define lumaN luma4B.z\n\t\t\t\t\t\t#define lumaW luma4B.x\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\n\t\t\t\t\t\t#if (FXAA_GREEN_AS_LUMA == 0)\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.w\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#define lumaM rgbyM.y\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat maxSM = max(lumaS, lumaM);\n\t\t\t\tFxaaFloat minSM = min(lumaS, lumaM);\n\t\t\t\tFxaaFloat maxESM = max(lumaE, maxSM);\n\t\t\t\tFxaaFloat minESM = min(lumaE, minSM);\n\t\t\t\tFxaaFloat maxWN = max(lumaN, lumaW);\n\t\t\t\tFxaaFloat minWN = min(lumaN, lumaW);\n\t\t\t\tFxaaFloat rangeMax = max(maxWN, maxESM);\n\t\t\t\tFxaaFloat rangeMin = min(minWN, minESM);\n\t\t\t\tFxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n\t\t\t\tFxaaFloat range = rangeMax - rangeMin;\n\t\t\t\tFxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n\t\t\t\tFxaaBool earlyExit = range < rangeMaxClamped;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(earlyExit)\n\t\t\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\t\t\tFxaaDiscard;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\treturn rgbyM;\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_GATHER4_ALPHA == 0)\n\t\t\t\t\t\t#if (FXAA_GLSL_100 == 1)\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tFxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\t#endif\n\t\t\t\t#else\n\t\t\t\t\t\tFxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\n\t\t\t\t\t\tFxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNS = lumaN + lumaS;\n\t\t\t\tFxaaFloat lumaWE = lumaW + lumaE;\n\t\t\t\tFxaaFloat subpixRcpRange = 1.0/range;\n\t\t\t\tFxaaFloat subpixNSWE = lumaNS + lumaWE;\n\t\t\t\tFxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n\t\t\t\tFxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNESE = lumaNE + lumaSE;\n\t\t\t\tFxaaFloat lumaNWNE = lumaNW + lumaNE;\n\t\t\t\tFxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n\t\t\t\tFxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat lumaNWSW = lumaNW + lumaSW;\n\t\t\t\tFxaaFloat lumaSWSE = lumaSW + lumaSE;\n\t\t\t\tFxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n\t\t\t\tFxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n\t\t\t\tFxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n\t\t\t\tFxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n\t\t\t\tFxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\n\t\t\t\tFxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\n\t\t\t\tFxaaFloat lengthSign = fxaaQualityRcpFrame.x;\n\t\t\t\tFxaaBool horzSpan = edgeHorz >= edgeVert;\n\t\t\t\tFxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!horzSpan) lumaN = lumaW;\n\t\t\t\tif(!horzSpan) lumaS = lumaE;\n\t\t\t\tif(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\n\t\t\t\tFxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat gradientN = lumaN - lumaM;\n\t\t\t\tFxaaFloat gradientS = lumaS - lumaM;\n\t\t\t\tFxaaFloat lumaNN = lumaN + lumaM;\n\t\t\t\tFxaaFloat lumaSS = lumaS + lumaM;\n\t\t\t\tFxaaBool pairN = abs(gradientN) >= abs(gradientS);\n\t\t\t\tFxaaFloat gradient = max(abs(gradientN), abs(gradientS));\n\t\t\t\tif(pairN) lengthSign = -lengthSign;\n\t\t\t\tFxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posB;\n\t\t\t\tposB.x = posM.x;\n\t\t\t\tposB.y = posM.y;\n\t\t\t\tFxaaFloat2 offNP;\n\t\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\t\t\t\tif(!horzSpan) posB.x += lengthSign * 0.5;\n\t\t\t\tif( horzSpan) posB.y += lengthSign * 0.5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat2 posN;\n\t\t\t\tposN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat2 posP;\n\t\t\t\tposP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\n\t\t\t\tposP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\n\t\t\t\tFxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\n\t\t\t\tFxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\n\t\t\t\tFxaaFloat subpixE = subpixC * subpixC;\n\t\t\t\tFxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(!pairN) lumaNN = lumaSS;\n\t\t\t\tFxaaFloat gradientScaled = gradient * 1.0/4.0;\n\t\t\t\tFxaaFloat lumaMM = lumaM - lumaNN * 0.5;\n\t\t\t\tFxaaFloat subpixF = subpixD * subpixE;\n\t\t\t\tFxaaBool lumaMLTZero = lumaMM < 0.0;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tlumaEndN -= lumaNN * 0.5;\n\t\t\t\tlumaEndP -= lumaNN * 0.5;\n\t\t\t\tFxaaBool doneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\tFxaaBool doneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\n\t\t\t\tFxaaBool doneNP = (!doneN) || (!doneP);\n\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\n\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 3)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 4)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 5)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 6)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 7)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t#if (FXAA_QUALITY_PS > 8)\n\t\t\t\tif(doneNP) {\n\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\n\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\n\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 9)\n\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\n\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 10)\n\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\n\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 11)\n\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\n\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t#if (FXAA_QUALITY_PS > 12)\n\t\t\t\t\t\t\t\t\t\t\t\tif(doneNP) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneN = abs(lumaEndN) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneP = abs(lumaEndP) >= gradientScaled;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdoneNP = (!doneN) || (!doneP);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t\t\t}\n\t\t\t\t\t\t#endif\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\t}\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat dstN = posM.x - posN.x;\n\t\t\t\tFxaaFloat dstP = posP.x - posM.x;\n\t\t\t\tif(!horzSpan) dstN = posM.y - posN.y;\n\t\t\t\tif(!horzSpan) dstP = posP.y - posM.y;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLength = (dstP + dstN);\n\t\t\t\tFxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n\t\t\t\tFxaaFloat spanLengthRcp = 1.0/spanLength;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaBool directionN = dstN < dstP;\n\t\t\t\tFxaaFloat dst = min(dstN, dstP);\n\t\t\t\tFxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\n\t\t\t\tFxaaFloat subpixG = subpixF * subpixF;\n\t\t\t\tFxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n\t\t\t\tFxaaFloat subpixH = subpixG * fxaaQualitySubpix;\n\t\t/*--------------------------------------------------------------------------*/\n\t\t\t\tFxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n\t\t\t\tFxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n\t\t\t\tif(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\n\t\t\t\tif( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\n\t\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\t\treturn FxaaTexTop(tex, posM);\n\t\t\t\t#else\n\t\t\t\t\t\treturn FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\n\t\t\t\t#endif\n\t\t}\n\t\t/*==========================================================================*/\n\t\t#endif\n\n\t\tvoid main() {\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\tvUv,\n\t\t\t\tvec4(0.0),\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\ttDiffuse,\n\t\t\t\tresolution,\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\tvec4(0.0),\n\t\t\t\t0.75,\n\t\t\t\t0.166,\n\t\t\t\t0.0833,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\tvec4(0.0)\n\t\t\t);\n\n\t\t\t// TODO avoid querying texture twice for same texel\n\t\t\tgl_FragColor.a = texture2D(tDiffuse, vUv).a;\n\t\t}'};THREE.FXAAShader=e}()},7342:()=>{!function(){const e=new THREE.Vector3,t=new THREE.Spherical,n=new THREE.Vector3;function r(e){e.preventDefault()}THREE.FirstPersonControls=class{constructor(o,a){void 0===a&&(console.warn('THREE.FirstPersonControls: The second parameter "domElement" is now mandatory.'),a=document),this.object=o,this.domElement=a,this.enabled=!0,this.movementSpeed=1,this.lookSpeed=.005,this.lookVertical=!0,this.autoForward=!1,this.activeLook=!0,this.heightSpeed=!1,this.heightCoef=1,this.heightMin=0,this.heightMax=1,this.constrainVertical=!1,this.verticalMin=0,this.verticalMax=Math.PI,this.mouseDragOn=!1,this.autoSpeedFactor=0,this.mouseX=0,this.mouseY=0,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.viewHalfX=0,this.viewHalfY=0;let i=0,s=0;this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)},this.onMouseDown=function(e){if(this.domElement!==document&&this.domElement.focus(),e.preventDefault(),this.activeLook)switch(e.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0},this.onMouseUp=function(e){if(e.preventDefault(),this.activeLook)switch(e.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1},this.onMouseMove=function(e){this.domElement===document?(this.mouseX=e.pageX-this.viewHalfX,this.mouseY=e.pageY-this.viewHalfY):(this.mouseX=e.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=e.pageY-this.domElement.offsetTop-this.viewHalfY)},this.onKeyDown=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!0;break;case"ArrowLeft":case"KeyA":this.moveLeft=!0;break;case"ArrowDown":case"KeyS":this.moveBackward=!0;break;case"ArrowRight":case"KeyD":this.moveRight=!0;break;case"KeyR":this.moveUp=!0;break;case"KeyF":this.moveDown=!0}},this.onKeyUp=function(e){switch(e.code){case"ArrowUp":case"KeyW":this.moveForward=!1;break;case"ArrowLeft":case"KeyA":this.moveLeft=!1;break;case"ArrowDown":case"KeyS":this.moveBackward=!1;break;case"ArrowRight":case"KeyD":this.moveRight=!1;break;case"KeyR":this.moveUp=!1;break;case"KeyF":this.moveDown=!1}},this.lookAt=function(e,t,r){return e.isVector3?n.copy(e):n.set(e,t,r),this.object.lookAt(n),p(this),this},this.update=function(){const e=new THREE.Vector3;return function(t){if(!1===this.enabled)return;if(this.heightSpeed){const e=THREE.MathUtils.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=t*(e*this.heightCoef)}else this.autoSpeedFactor=0;const n=t*this.movementSpeed;(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(n+this.autoSpeedFactor)),this.moveBackward&&this.object.translateZ(n),this.moveLeft&&this.object.translateX(-n),this.moveRight&&this.object.translateX(n),this.moveUp&&this.object.translateY(n),this.moveDown&&this.object.translateY(-n);let r=t*this.lookSpeed;this.activeLook||(r=0);let o=1;this.constrainVertical&&(o=Math.PI/(this.verticalMax-this.verticalMin)),s-=this.mouseX*r,this.lookVertical&&(i-=this.mouseY*r*o),i=Math.max(-85,Math.min(85,i));let a=THREE.MathUtils.degToRad(90-i);const l=THREE.MathUtils.degToRad(s);this.constrainVertical&&(a=THREE.MathUtils.mapLinear(a,0,Math.PI,this.verticalMin,this.verticalMax));const c=this.object.position;e.setFromSphericalCoords(1,a,l).add(c),this.object.lookAt(e)}}(),this.dispose=function(){this.domElement.removeEventListener("contextmenu",r),this.domElement.removeEventListener("mousedown",c),this.domElement.removeEventListener("mousemove",l),this.domElement.removeEventListener("mouseup",f),window.removeEventListener("keydown",u),window.removeEventListener("keyup",d)};const l=this.onMouseMove.bind(this),c=this.onMouseDown.bind(this),f=this.onMouseUp.bind(this),u=this.onKeyDown.bind(this),d=this.onKeyUp.bind(this);function p(n){const r=n.object.quaternion;e.set(0,0,-1).applyQuaternion(r),t.setFromVector3(e),i=90-THREE.MathUtils.radToDeg(t.phi),s=THREE.MathUtils.radToDeg(t.theta)}this.domElement.addEventListener("contextmenu",r),this.domElement.addEventListener("mousemove",l),this.domElement.addEventListener("mousedown",c),this.domElement.addEventListener("mouseup",f),window.addEventListener("keydown",u),window.addEventListener("keyup",d),this.handleResize(),p(this)}}}()},9607:()=>{!function(){const e={uniforms:{mRefractionRatio:{value:1.02},mFresnelBias:{value:.1},mFresnelPower:{value:2},mFresnelScale:{value:1},tCube:{value:null}},vertexShader:"\n\n\t\tuniform float mRefractionRatio;\n\t\tuniform float mFresnelBias;\n\t\tuniform float mFresnelScale;\n\t\tuniform float mFresnelPower;\n\n\t\tvarying vec3 vReflect;\n\t\tvarying vec3 vRefract[3];\n\t\tvarying float vReflectionFactor;\n\n\t\tvoid main() {\n\n\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t\t\tvec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\n\n\t\t\tvec3 I = worldPosition.xyz - cameraPosition;\n\n\t\t\tvReflect = reflect( I, worldNormal );\n\t\t\tvRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\n\t\t\tvRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\n\t\t\tvRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\n\t\t\tvReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\n\n\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t}",fragmentShader:"\n\n\t\tuniform samplerCube tCube;\n\n\t\tvarying vec3 vReflect;\n\t\tvarying vec3 vRefract[3];\n\t\tvarying float vReflectionFactor;\n\n\t\tvoid main() {\n\n\t\t\tvec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\t\t\tvec4 refractedColor = vec4( 1.0 );\n\n\t\t\trefractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\n\t\t\trefractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\n\t\t\trefractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\n\n\t\t\tgl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\n\n\t\t}"};THREE.FresnelShader=e}()},5992:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.splitLayer=!1}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){let t={x:0,y:0,z:0,e:0,f:0,extruding:!1,relative:!1};const n=[];let r;const o=new THREE.LineBasicMaterial({color:16711680});o.name="path";const a=new THREE.LineBasicMaterial({color:65280});function i(e){r={vertex:[],pathVertex:[],z:e.z},n.push(r)}function s(e,n){return t.relative?n:n-e}function l(e,n){return t.relative?e+n:n}a.name="extruded";const c=e.replace(/;.+/g,"").split("\n");for(let e=0;e<c.length;e++){const n=c[e].split(" "),o=n[0].toUpperCase(),a={};if(n.splice(1).forEach((function(e){if(void 0!==e[0]){const t=e[0].toLowerCase(),n=parseFloat(e.substring(1));a[t]=n}})),"G0"===o||"G1"===o){const e={x:void 0!==a.x?l(t.x,a.x):t.x,y:void 0!==a.y?l(t.y,a.y):t.y,z:void 0!==a.z?l(t.z,a.z):t.z,e:void 0!==a.e?l(t.e,a.e):t.e,f:void 0!==a.f?l(t.f,a.f):t.f};s(t.e,e.e)>0&&(e.extruding=s(t.e,e.e)>0,null!=r&&e.z==r.z||i(e)),f=t,u=e,void 0===r&&i(f),t.extruding?(r.vertex.push(f.x,f.y,f.z),r.vertex.push(u.x,u.y,u.z)):(r.pathVertex.push(f.x,f.y,f.z),r.pathVertex.push(u.x,u.y,u.z)),t=e}else if("G2"===o||"G3"===o);else if("G90"===o)t.relative=!1;else if("G91"===o)t.relative=!0;else if("G92"===o){const e=t;e.x=void 0!==a.x?a.x:e.x,e.y=void 0!==a.y?a.y:e.y,e.z=void 0!==a.z?a.z:e.z,e.e=void 0!==a.e?a.e:e.e,t=e}}var f,u;function d(e,t,n){const r=new THREE.BufferGeometry;r.setAttribute("position",new THREE.Float32BufferAttribute(e,3));const i=new THREE.LineSegments(r,t?a:o);i.name="layer"+n,p.add(i)}const p=new THREE.Group;if(p.name="gcode",this.splitLayer)for(let e=0;e<n.length;e++){const t=n[e];d(t.vertex,!0,e),d(t.pathVertex,!1,e)}else{const e=[],t=[];for(let r=0;r<n.length;r++){const o=n[r],a=o.vertex,i=o.pathVertex;for(let t=0;t<a.length;t++)e.push(a[t]);for(let e=0;e<i.length;e++)t.push(i[e])}d(e,!0,n.length),d(t,!1,n.length)}return p.quaternion.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)),p}}THREE.GCodeLoader=e}()},5071:()=>{!function(){class e{constructor(){this.pluginCallbacks=[],this.register((function(e){return new M(e)})),this.register((function(e){return new C(e)})),this.register((function(e){return new L(e)}))}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n){const r=new R,o=[];for(let e=0,t=this.pluginCallbacks.length;e<t;e++)o.push(this.pluginCallbacks[e](r));r.setPlugins(o),r.write(e,t,n)}}const t=0,n=1,r=2,o=3,a=4,i=5121,s=5123,l=5126,c=5125,f=34962,u=34963,d=9728,p=9729,h=9984,v=9985,m=9986,x=9987,g=33071,y=33648,E=10497,w={};w[THREE.NearestFilter]=d,w[THREE.NearestMipmapNearestFilter]=h,w[THREE.NearestMipmapLinearFilter]=m,w[THREE.LinearFilter]=p,w[THREE.LinearMipmapNearestFilter]=v,w[THREE.LinearMipmapLinearFilter]=x,w[THREE.ClampToEdgeWrapping]=g,w[THREE.RepeatWrapping]=E,w[THREE.MirroredRepeatWrapping]=y;const b={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"};function _(e,t){return e.length===t.length&&e.every((function(e,n){return e===t[n]}))}function T(e){return 4*Math.ceil(e/4)}function A(e,t=0){const n=T(e.byteLength);if(n!==e.byteLength){const r=new Uint8Array(n);if(r.set(new Uint8Array(e)),0!==t)for(let o=e.byteLength;o<n;o++)r[o]=t;return r.buffer}return e}let S=null;class R{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}write(e,t,n){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,embedImages:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e);const r=this;Promise.all(this.pending).then((function(){const e=r.buffers,n=r.json,o=r.options,a=r.extensionsUsed,i=new Blob(e,{type:"application/octet-stream"}),s=Object.keys(a);if(s.length>0&&(n.extensionsUsed=s),n.buffers&&n.buffers.length>0&&(n.buffers[0].byteLength=i.size),!0===o.binary){const e=new window.FileReader;e.readAsArrayBuffer(i),e.onloadend=function(){const r=A(e.result),o=new DataView(new ArrayBuffer(8));o.setUint32(0,r.byteLength,!0),o.setUint32(4,5130562,!0);const a=A(function(e){if(void 0!==window.TextEncoder)return(new TextEncoder).encode(e).buffer;const t=new Uint8Array(new ArrayBuffer(e.length));for(let n=0,r=e.length;n<r;n++){const r=e.charCodeAt(n);t[n]=r>255?32:r}return t.buffer}(JSON.stringify(n)),32),i=new DataView(new ArrayBuffer(8));i.setUint32(0,a.byteLength,!0),i.setUint32(4,1313821514,!0);const s=new ArrayBuffer(12),l=new DataView(s);l.setUint32(0,1179937895,!0),l.setUint32(4,2,!0);const c=12+i.byteLength+a.byteLength+o.byteLength+r.byteLength;l.setUint32(8,c,!0);const f=new Blob([s,i,a,o,r],{type:"application/octet-stream"}),u=new window.FileReader;u.readAsArrayBuffer(f),u.onloadend=function(){t(u.result)}}}else if(n.buffers&&n.buffers.length>0){const e=new window.FileReader;e.readAsDataURL(i),e.onloadend=function(){const r=e.result;n.buffers[0].uri=r,t(n)}}else t(n)}))}serializeUserData(e,t){if(0===Object.keys(e.userData).length)return;const n=this.options,r=this.extensionsUsed;try{const o=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&o.gltfExtensions){void 0===t.extensions&&(t.extensions={});for(const e in o.gltfExtensions)t.extensions[e]=o.gltfExtensions[e],r[e]=!0;delete o.gltfExtensions}Object.keys(o).length>0&&(t.extras=o)}catch(t){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+t.message)}}getUID(e){return this.uids.has(e)||this.uids.set(e,this.uid++),this.uids.get(e)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const t=new THREE.Vector3;for(let n=0,r=e.count;n<r;n++)if(Math.abs(t.fromBufferAttribute(e,n).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),r=new THREE.Vector3;for(let e=0,t=n.count;e<t;e++)r.fromBufferAttribute(n,e),0===r.x&&0===r.y&&0===r.z?r.setX(1):r.normalize(),n.setXYZ(e,r.x,r.y,r.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const r={};0===t.offset.x&&0===t.offset.y||(r.offset=t.offset.toArray(),n=!0),0!==t.rotation&&(r.rotation=t.rotation,n=!0),1===t.repeat.x&&1===t.repeat.y||(r.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=r,this.extensionsUsed.KHR_texture_transform=!0)}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,r,o){const a=this.json;let u;a.bufferViews||(a.bufferViews=[]),u=t===i?1:t===s?2:4;const d=T(r*e.itemSize*u),p=new DataView(new ArrayBuffer(d));let h=0;for(let o=n;o<n+r;o++)for(let n=0;n<e.itemSize;n++){let r;e.itemSize>4?r=e.array[o*e.itemSize+n]:0===n?r=e.getX(o):1===n?r=e.getY(o):2===n?r=e.getZ(o):3===n&&(r=e.getW(o)),t===l?p.setFloat32(h,r,!0):t===c?p.setUint32(h,r,!0):t===s?p.setUint16(h,r,!0):t===i&&p.setUint8(h,r),h+=u}const v={buffer:this.processBuffer(p.buffer),byteOffset:this.byteOffset,byteLength:d};void 0!==o&&(v.target=o),o===f&&(v.byteStride=e.itemSize*u),this.byteOffset+=d,a.bufferViews.push(v);return{id:a.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),new Promise((function(r){const o=new window.FileReader;o.readAsArrayBuffer(e),o.onloadend=function(){const e=A(o.result),a={buffer:t.processBuffer(e),byteOffset:t.byteOffset,byteLength:e.byteLength};t.byteOffset+=e.byteLength,r(n.bufferViews.push(a)-1)}}))}processAccessor(e,t,n,r){const o=this.options,a=this.json;let d;if(e.array.constructor===Float32Array)d=l;else if(e.array.constructor===Uint32Array)d=c;else if(e.array.constructor===Uint16Array)d=s;else{if(e.array.constructor!==Uint8Array)throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");d=i}if(void 0===n&&(n=0),void 0===r&&(r=e.count),o.truncateDrawRange&&void 0!==t&&null===t.index){const o=n+r,a=t.drawRange.count===1/0?e.count:t.drawRange.start+t.drawRange.count;n=Math.max(n,t.drawRange.start),(r=Math.min(o,a)-n)<0&&(r=0)}if(0===r)return null;const p=function(e,t,n){const r={min:new Array(e.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(e.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let o=t;o<t+n;o++)for(let t=0;t<e.itemSize;t++){let n;e.itemSize>4?n=e.array[o*e.itemSize+t]:0===t?n=e.getX(o):1===t?n=e.getY(o):2===t?n=e.getZ(o):3===t&&(n=e.getW(o)),r.min[t]=Math.min(r.min[t],n),r.max[t]=Math.max(r.max[t],n)}return r}(e,n,r);let h;void 0!==t&&(h=e===t.index?u:f);const v=this.processBufferView(e,d,n,r,h),m={bufferView:v.id,byteOffset:v.byteOffset,componentType:d,count:r,max:p.max,min:p.min,type:{1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"}[e.itemSize]};return!0===e.normalized&&(m.normalized=!0),a.accessors||(a.accessors=[]),a.accessors.push(m)-1}processImage(e,t,n){const r=this,o=r.cache,a=r.json,i=r.options,s=r.pending;o.images.has(e)||o.images.set(e,{});const l=o.images.get(e),c=t===THREE.RGBAFormat?"image/png":"image/jpeg",f=c+":flipY/"+n.toString();if(void 0!==l[f])return l[f];a.images||(a.images=[]);const u={mimeType:c};if(i.embedImages){const o=S=S||document.createElement("canvas");o.width=Math.min(e.width,i.maxTextureSize),o.height=Math.min(e.height,i.maxTextureSize);const a=o.getContext("2d");if(!0===n&&(a.translate(0,o.height),a.scale(1,-1)),"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap)a.drawImage(e,0,0,o.width,o.height);else{t!==THREE.RGBAFormat&&t!==THREE.RGBFormat&&console.error("GLTFExporter: Only RGB and RGBA formats are supported."),(e.width>i.maxTextureSize||e.height>i.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);let n=e.data;if(t===THREE.RGBFormat){n=new Uint8ClampedArray(e.height*e.width*4);for(let t=0,r=0;t<n.length;t+=4,r+=3)n[t+0]=e.data[r+0],n[t+1]=e.data[r+1],n[t+2]=e.data[r+2],n[t+3]=255}a.putImageData(new ImageData(n,e.width,e.height),0,0)}!0===i.binary?s.push(new Promise((function(e){o.toBlob((function(t){r.processBufferViewImage(t).then((function(t){u.bufferView=t,e()}))}),c)}))):u.uri=o.toDataURL(c)}else u.uri=e.src;const d=a.images.push(u)-1;return l[f]=d,d}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:w[e.magFilter],minFilter:w[e.minFilter],wrapS:w[e.wrapS],wrapT:w[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const t=this.cache,n=this.json;if(t.textures.has(e))return t.textures.get(e);n.textures||(n.textures=[]);const r={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY)};e.name&&(r.name=e.name),this._invokeAll((function(t){t.writeTexture&&t.writeTexture(e,r)}));const o=n.textures.push(r)-1;return t.textures.set(e,o),o}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const r={pbrMetallicRoughness:{}};!0!==e.isMeshStandardMaterial&&!0!==e.isMeshBasicMaterial&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const o=e.color.toArray().concat([e.opacity]);if(_(o,[1,1,1,1])||(r.pbrMetallicRoughness.baseColorFactor=o),e.isMeshStandardMaterial?(r.pbrMetallicRoughness.metallicFactor=e.metalness,r.pbrMetallicRoughness.roughnessFactor=e.roughness):(r.pbrMetallicRoughness.metallicFactor=.5,r.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap)if(e.metalnessMap===e.roughnessMap){const t={index:this.processTexture(e.metalnessMap)};this.applyTextureTransform(t,e.metalnessMap),r.pbrMetallicRoughness.metallicRoughnessTexture=t}else console.warn("THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.");if(e.map){const t={index:this.processTexture(e.map)};this.applyTextureTransform(t,e.map),r.pbrMetallicRoughness.baseColorTexture=t}if(e.emissive){const t=e.emissive.clone().multiplyScalar(e.emissiveIntensity).toArray();if(_(t,[0,0,0])||(r.emissiveFactor=t),e.emissiveMap){const t={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(t,e.emissiveMap),r.emissiveTexture=t}}if(e.normalMap){const t={index:this.processTexture(e.normalMap)};e.normalScale&&-1!==e.normalScale.x&&(e.normalScale.x!==e.normalScale.y&&console.warn("THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X."),t.scale=e.normalScale.x),this.applyTextureTransform(t,e.normalMap),r.normalTexture=t}if(e.aoMap){const t={index:this.processTexture(e.aoMap),texCoord:1};1!==e.aoMapIntensity&&(t.strength=e.aoMapIntensity),this.applyTextureTransform(t,e.aoMap),r.occlusionTexture=t}e.transparent?r.alphaMode="BLEND":e.alphaTest>0&&(r.alphaMode="MASK",r.alphaCutoff=e.alphaTest),e.side===THREE.DoubleSide&&(r.doubleSided=!0),""!==e.name&&(r.name=e.name),this.serializeUserData(e,r),this._invokeAll((function(t){t.writeMaterial&&t.writeMaterial(e,r)}));const a=n.materials.push(r)-1;return t.materials.set(e,a),a}processMesh(e){const i=this.cache,s=this.json,l=[e.geometry.uuid];if(Array.isArray(e.material))for(let t=0,n=e.material.length;t<n;t++)l.push(e.material[t].uuid);else l.push(e.material.uuid);const c=l.join(":");if(i.meshes.has(c))return i.meshes.get(c);const f=e.geometry;let u;if(u=e.isLineSegments?n:e.isLineLoop?r:e.isLine?o:e.isPoints?t:e.material.wireframe?n:a,!0!==f.isBufferGeometry)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const d={},p={},h=[],v=[],m={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},x=f.getAttribute("normal");void 0===x||this.isNormalizedNormalAttribute(x)||(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),f.setAttribute("normal",this.createNormalizedNormalAttribute(x)));let g=null;for(let e in f.attributes){if("morph"===e.substr(0,5))continue;const t=f.attributes[e];e=m[e]||e.toUpperCase();if(/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(e)||(e="_"+e),i.attributes.has(this.getUID(t))){p[e]=i.attributes.get(this.getUID(t));continue}g=null;const n=t.array;"JOINTS_0"!==e||n instanceof Uint16Array||n instanceof Uint8Array||(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),g=new THREE.BufferAttribute(new Uint16Array(n),t.itemSize,t.normalized));const r=this.processAccessor(g||t,f);null!==r&&(p[e]=r,i.attributes.set(this.getUID(t),r))}if(void 0!==x&&f.setAttribute("normal",x),0===Object.keys(p).length)return null;if(void 0!==e.morphTargetInfluences&&e.morphTargetInfluences.length>0){const t=[],n=[],r={};if(void 0!==e.morphTargetDictionary)for(const t in e.morphTargetDictionary)r[e.morphTargetDictionary[t]]=t;for(let o=0;o<e.morphTargetInfluences.length;++o){const a={};let s=!1;for(const e in f.morphAttributes){if("position"!==e&&"normal"!==e){s||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),s=!0);continue}const t=f.morphAttributes[e][o],n=e.toUpperCase(),r=f.attributes[e];if(i.attributes.has(this.getUID(t))){a[n]=i.attributes.get(this.getUID(t));continue}const l=t.clone();if(!f.morphTargetsRelative)for(let e=0,n=t.count;e<n;e++)l.setXYZ(e,t.getX(e)-r.getX(e),t.getY(e)-r.getY(e),t.getZ(e)-r.getZ(e));a[n]=this.processAccessor(l,f),i.attributes.set(this.getUID(r),a[n])}v.push(a),t.push(e.morphTargetInfluences[o]),void 0!==e.morphTargetDictionary&&n.push(r[o])}d.weights=t,n.length>0&&(d.extras={},d.extras.targetNames=n)}const y=Array.isArray(e.material);if(y&&0===f.groups.length)return null;const E=y?e.material:[e.material],w=y?f.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let e=0,t=w.length;e<t;e++){const t={mode:u,attributes:p};if(this.serializeUserData(f,t),v.length>0&&(t.targets=v),null!==f.index){let n=this.getUID(f.index);void 0===w[e].start&&void 0===w[e].count||(n+=":"+w[e].start+":"+w[e].count),i.attributes.has(n)?t.indices=i.attributes.get(n):(t.indices=this.processAccessor(f.index,f,w[e].start,w[e].count),i.attributes.set(n,t.indices)),null===t.indices&&delete t.indices}const n=this.processMaterial(E[w[e].materialIndex]);null!==n&&(t.material=n),h.push(t)}d.primitives=h,s.meshes||(s.meshes=[]),this._invokeAll((function(t){t.writeMesh&&t.writeMesh(e,d)}));const b=s.meshes.push(d)-1;return i.meshes.set(c,b),b}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,r={type:n?"orthographic":"perspective"};return n?r.orthographic={xmag:2*e.right,ymag:2*e.top,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:r.perspective={aspectRatio:e.aspect,yfov:THREE.MathUtils.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},""!==e.name&&(r.name=e.type),t.cameras.push(r)-1}processAnimation(t,n){const r=this.json,o=this.nodeMap;r.animations||(r.animations=[]);const a=(t=e.Utils.mergeMorphTargetTracks(t.clone(),n)).tracks,i=[],s=[];for(let e=0;e<a.length;++e){const t=a[e],r=THREE.PropertyBinding.parseTrackName(t.name);let l=THREE.PropertyBinding.findNode(n,r.nodeName);const c=b[r.propertyName];if("bones"===r.objectName&&(l=!0===l.isSkinnedMesh?l.skeleton.getBoneByName(r.objectIndex):void 0),!l||!c)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',t.name),null;const f=1;let u,d=t.values.length/t.times.length;c===b.morphTargetInfluences&&(d/=l.morphTargetInfluences.length),!0===t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline?(u="CUBICSPLINE",d/=3):u=t.getInterpolation()===THREE.InterpolateDiscrete?"STEP":"LINEAR",s.push({input:this.processAccessor(new THREE.BufferAttribute(t.times,f)),output:this.processAccessor(new THREE.BufferAttribute(t.values,d)),interpolation:u}),i.push({sampler:s.length-1,target:{node:o.get(l),path:c}})}return r.animations.push({name:t.name||"clip_"+r.animations.length,samplers:s,channels:i}),r.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,r=t.nodes[n.get(e)],o=e.skeleton;if(void 0===o)return null;const a=e.skeleton.bones[0];if(void 0===a)return null;const i=[],s=new Float32Array(16*o.bones.length),l=new THREE.Matrix4;for(let t=0;t<o.bones.length;++t)i.push(n.get(o.bones[t])),l.copy(o.boneInverses[t]),l.multiply(e.bindMatrix).toArray(s,16*t);void 0===t.skins&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new THREE.BufferAttribute(s,16)),joints:i,skeleton:n.get(a)});return r.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,r=this.nodeMap;t.nodes||(t.nodes=[]);const o={};if(n.trs){const t=e.quaternion.toArray(),n=e.position.toArray(),r=e.scale.toArray();_(t,[0,0,0,1])||(o.rotation=t),_(n,[0,0,0])||(o.translation=n),_(r,[1,1,1])||(o.scale=r)}else e.matrixAutoUpdate&&e.updateMatrix(),!1===_(e.matrix.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])&&(o.matrix=e.matrix.elements);if(""!==e.name&&(o.name=String(e.name)),this.serializeUserData(e,o),e.isMesh||e.isLine||e.isPoints){const t=this.processMesh(e);null!==t&&(o.mesh=t)}else e.isCamera&&(o.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const t=[];for(let r=0,o=e.children.length;r<o;r++){const o=e.children[r];if(o.visible||!1===n.onlyVisible){const e=this.processNode(o);null!==e&&t.push(e)}}t.length>0&&(o.children=t)}this._invokeAll((function(t){t.writeNode&&t.writeNode(e,o)}));const a=t.nodes.push(o)-1;return r.set(e,a),a}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const r={};""!==e.name&&(r.name=e.name),t.scenes.push(r);const o=[];for(let t=0,r=e.children.length;t<r;t++){const r=e.children[t];if(r.visible||!1===n.onlyVisible){const e=this.processNode(r);null!==e&&o.push(e)}}o.length>0&&(r.nodes=o),this.serializeUserData(e,r)}processObjects(e){const t=new THREE.Scene;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll((function(t){t.beforeParse&&t.beforeParse(e)}));const n=[];for(let t=0;t<e.length;t++)e[t]instanceof THREE.Scene?this.processScene(e[t]):n.push(e[t]);n.length>0&&this.processObjects(n);for(let e=0;e<this.skins.length;++e)this.processSkin(this.skins[e]);for(let n=0;n<t.animations.length;++n)this.processAnimation(t.animations[n],e[0]);this._invokeAll((function(t){t.afterParse&&t.afterParse(e)}))}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class M{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight)return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);const n=this.writer,r=n.json,o=n.extensionsUsed,a={};e.name&&(a.name=e.name),a.color=e.color.toArray(),a.intensity=e.intensity,e.isDirectionalLight?a.type="directional":e.isPointLight?(a.type="point",e.distance>0&&(a.range=e.distance)):e.isSpotLight&&(a.type="spot",e.distance>0&&(a.range=e.distance),a.spot={},a.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,a.spot.outerConeAngle=e.angle),void 0!==e.decay&&2!==e.decay&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),!e.target||e.target.parent===e&&0===e.target.position.x&&0===e.target.position.y&&-1===e.target.position.z||console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),o[this.name]||(r.extensions=r.extensions||{},r.extensions[this.name]={lights:[]},o[this.name]=!0);const i=r.extensions[this.name].lights;i.push(a),t.extensions=t.extensions||{},t.extensions[this.name]={light:i.length-1}}}class C{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const n=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},n[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class L{constructor(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,t){if(!e.isGLTFSpecularGlossinessMaterial)return;const n=this.writer,r=n.extensionsUsed,o={};t.pbrMetallicRoughness.baseColorFactor&&(o.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);const a=[1,1,1];if(e.specular.toArray(a,0),o.specularFactor=a,o.glossinessFactor=e.glossiness,t.pbrMetallicRoughness.baseColorTexture&&(o.diffuseTexture=t.pbrMetallicRoughness.baseColorTexture),e.specularMap){const t={index:n.processTexture(e.specularMap)};n.applyTextureTransform(t,e.specularMap),o.specularGlossinessTexture=t}t.extensions=t.extensions||{},t.extensions[this.name]=o,r[this.name]=!0}}e.Utils={insertKeyframe:function(e,t){const n=.001,r=e.getValueSize(),o=new e.TimeBufferType(e.times.length+1),a=new e.ValueBufferType(e.values.length+r),i=e.createInterpolant(new e.ValueBufferType(r));let s;if(0===e.times.length){o[0]=t;for(let e=0;e<r;e++)a[e]=0;s=0}else if(t<e.times[0]){if(Math.abs(e.times[0]-t)<n)return 0;o[0]=t,o.set(e.times,1),a.set(i.evaluate(t),0),a.set(e.values,r),s=0}else if(t>e.times[e.times.length-1]){if(Math.abs(e.times[e.times.length-1]-t)<n)return e.times.length-1;o[o.length-1]=t,o.set(e.times,0),a.set(e.values,0),a.set(i.evaluate(t),e.values.length),s=o.length-1}else for(let l=0;l<e.times.length;l++){if(Math.abs(e.times[l]-t)<n)return l;if(e.times[l]<t&&e.times[l+1]>t){o.set(e.times.slice(0,l+1),0),o[l+1]=t,o.set(e.times.slice(l+1),l+2),a.set(e.values.slice(0,(l+1)*r),0),a.set(i.evaluate(t),(l+1)*r),a.set(e.values.slice((l+1)*r),(l+2)*r),s=l+1;break}}return e.times=o,e.values=a,s},mergeMorphTargetTracks:function(e,t){const n=[],r={},o=e.tracks;for(let e=0;e<o.length;++e){let a=o[e];const i=THREE.PropertyBinding.parseTrackName(a.name),s=THREE.PropertyBinding.findNode(t,i.nodeName);if("morphTargetInfluences"!==i.propertyName||void 0===i.propertyIndex){n.push(a);continue}if(a.createInterpolant!==a.InterpolantFactoryMethodDiscrete&&a.createInterpolant!==a.InterpolantFactoryMethodLinear){if(a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),a=a.clone(),a.setInterpolation(THREE.InterpolateLinear)}const l=s.morphTargetInfluences.length,c=s.morphTargetDictionary[i.propertyIndex];if(void 0===c)throw new Error("THREE.GLTFExporter: Morph target name not found: "+i.propertyIndex);let f;if(void 0===r[s.uuid]){f=a.clone();const e=new f.ValueBufferType(l*f.times.length);for(let t=0;t<f.times.length;t++)e[t*l+c]=f.values[t];f.name=(i.nodeName||"")+".morphTargetInfluences",f.values=e,r[s.uuid]=f,n.push(f);continue}const u=a.createInterpolant(new a.ValueBufferType(1));f=r[s.uuid];for(let e=0;e<f.times.length;e++)f.values[e*l+c]=u.evaluate(f.times[e]);for(let e=0;e<a.times.length;e++){const t=this.insertKeyframe(f,a.times[e]);f.values[t*l+c]=a.values[e]}}return e.tracks=n,e}},THREE.GLTFExporter=e}()},3818:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(e){return new a(e)})),this.register((function(e){return new s(e)})),this.register((function(e){return new l(e)})),this.register((function(e){return new i(e)})),this.register((function(e){return new r(e)})),this.register((function(e){return new c(e)}))}load(e,t,n,r){const o=this;let a;a=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:THREE.LoaderUtils.extractUrlBase(e),this.manager.itemStart(e);const i=function(t){r?r(t):console.error(t),o.manager.itemError(e),o.manager.itemEnd(e)},s=new THREE.FileLoader(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(function(n){try{o.parse(n,a,(function(n){t(n),o.manager.itemEnd(e)}),i)}catch(e){i(e)}}),n,i)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return-1===this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.push(e),this}unregister(e){return-1!==this.pluginCallbacks.indexOf(e)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,r,a){let i;const s={},l={};if("string"==typeof e)i=e;else{if(THREE.LoaderUtils.decodeText(new Uint8Array(e,0,4))===f){try{s[n.KHR_BINARY_GLTF]=new p(e)}catch(e){return void(a&&a(e))}i=s[n.KHR_BINARY_GLTF].content}else i=THREE.LoaderUtils.decodeText(new Uint8Array(e))}const c=JSON.parse(i);if(void 0===c.asset||c.asset.version[0]<2)return void(a&&a(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const u=new W(c,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let e=0;e<this.pluginCallbacks.length;e++){const t=this.pluginCallbacks[e](u);l[t.name]=t,s[t.name]=!0}if(c.extensionsUsed)for(let e=0;e<c.extensionsUsed.length;++e){const t=c.extensionsUsed[e],r=c.extensionsRequired||[];switch(t){case n.KHR_MATERIALS_UNLIT:s[t]=new o;break;case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:s[t]=new x;break;case n.KHR_DRACO_MESH_COMPRESSION:s[t]=new h(c,this.dracoLoader);break;case n.KHR_TEXTURE_TRANSFORM:s[t]=new v;break;case n.KHR_MESH_QUANTIZATION:s[t]=new g;break;default:r.indexOf(t)>=0&&void 0===l[t]&&console.warn('THREE.GLTFLoader: Unknown extension "'+t+'".')}}u.setExtensions(s),u.setPlugins(l),u.parse(r,a)}}function t(){let e={};return{get:function(t){return e[t]},add:function(t,n){e[t]=n},remove:function(t){delete e[t]},removeAll:function(){e={}}}}const n={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class r{constructor(e){this.parser=e,this.name=n.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,r=t.length;n<r;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&void 0!==r.extensions[this.name].light&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let r=t.cache.get(n);if(r)return r;const o=t.json,a=((o.extensions&&o.extensions[this.name]||{}).lights||[])[e];let i;const s=new THREE.Color(16777215);void 0!==a.color&&s.fromArray(a.color);const l=void 0!==a.range?a.range:0;switch(a.type){case"directional":i=new THREE.DirectionalLight(s),i.target.position.set(0,0,-1),i.add(i.target);break;case"point":i=new THREE.PointLight(s),i.distance=l;break;case"spot":i=new THREE.SpotLight(s),i.distance=l,a.spot=a.spot||{},a.spot.innerConeAngle=void 0!==a.spot.innerConeAngle?a.spot.innerConeAngle:0,a.spot.outerConeAngle=void 0!==a.spot.outerConeAngle?a.spot.outerConeAngle:Math.PI/4,i.angle=a.spot.outerConeAngle,i.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,i.target.position.set(0,0,-1),i.add(i.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return i.position.set(0,0,0),i.decay=2,void 0!==a.intensity&&(i.intensity=a.intensity),i.name=t.createUniqueName(a.name||"light_"+e),r=Promise.resolve(i),t.cache.add(n,r),r}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return void 0===o?null:this._loadLight(o).then((function(e){return n._getNodeRef(t.cache,o,e)}))}}class o{constructor(){this.name=n.KHR_MATERIALS_UNLIT}getMaterialType(){return THREE.MeshBasicMaterial}extendParams(e,t,n){const r=[];e.color=new THREE.Color(1,1,1),e.opacity=1;const o=t.pbrMetallicRoughness;if(o){if(Array.isArray(o.baseColorFactor)){const t=o.baseColorFactor;e.color.fromArray(t),e.opacity=t[3]}void 0!==o.baseColorTexture&&r.push(n.assignTexture(e,"map",o.baseColorTexture))}return Promise.all(r)}}class a{constructor(e){this.parser=e,this.name=n.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const o=[],a=r.extensions[this.name];if(void 0!==a.clearcoatFactor&&(t.clearcoat=a.clearcoatFactor),void 0!==a.clearcoatTexture&&o.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),void 0!==a.clearcoatRoughnessFactor&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),void 0!==a.clearcoatRoughnessTexture&&o.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),void 0!==a.clearcoatNormalTexture&&(o.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),void 0!==a.clearcoatNormalTexture.scale)){const e=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new THREE.Vector2(e,-e)}return Promise.all(o)}}class i{constructor(e){this.parser=e,this.name=n.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const t=this.parser.json.materials[e];return t.extensions&&t.extensions[this.name]?THREE.MeshPhysicalMaterial:null}extendMaterialParams(e,t){const n=this.parser,r=n.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const o=[],a=r.extensions[this.name];return void 0!==a.transmissionFactor&&(t.transmission=a.transmissionFactor),void 0!==a.transmissionTexture&&o.push(n.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(o)}}class s{constructor(e){this.parser=e,this.name=n.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,r=n.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const o=r.extensions[this.name],a=n.images[o.source],i=t.options.ktx2Loader;if(!i){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,a,i)}}class l{constructor(e){this.parser=e,this.name=n.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,r=n.json,o=r.textures[e];if(!o.extensions||!o.extensions[t])return null;const a=o.extensions[t],i=r.images[a.source];let s=n.textureLoader;if(i.uri){const e=n.options.manager.getHandler(i.uri);null!==e&&(s=e)}return this.detectSupport().then((function(o){if(o)return n.loadTextureImage(e,i,s);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(1===t.height)}}))),this.isSupported}}class c{constructor(e){this.name=n.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const e=n.extensions[this.name],r=this.parser.getDependency("buffer",e.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([r,o.ready]).then((function(t){const n=e.byteOffset||0,r=e.byteLength||0,a=e.count,i=e.byteStride,s=new ArrayBuffer(a*i),l=new Uint8Array(t[0],n,r);return o.decodeGltfBuffer(new Uint8Array(s),a,i,l,e.mode,e.filter),s}))}return null}}const f="glTF",u=1313821514,d=5130562;class p{constructor(e){this.name=n.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,12);if(this.header={magic:THREE.LoaderUtils.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==f)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-12,o=new DataView(e,12);let a=0;for(;a<r;){const t=o.getUint32(a,!0);a+=4;const n=o.getUint32(a,!0);if(a+=4,n===u){const n=new Uint8Array(e,12+a,t);this.content=THREE.LoaderUtils.decodeText(n)}else if(n===d){const n=12+a;this.body=e.slice(n,n+t)}a+=t}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class h{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=n.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,r=this.dracoLoader,o=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,i={},s={},l={};for(const e in a){const t=P[e]||e.toLowerCase();i[t]=a[e]}for(const t in e.attributes){const r=P[t]||t.toLowerCase();if(void 0!==a[t]){const o=n.accessors[e.attributes[t]],a=R[o.componentType];l[r]=a,s[r]=!0===o.normalized}}return t.getDependency("bufferView",o).then((function(e){return new Promise((function(t){r.decodeDracoFile(e,(function(e){for(const t in e.attributes){const n=e.attributes[t],r=s[t];void 0!==r&&(n.normalized=r)}t(e)}),i,l)}))}))}}class v{constructor(){this.name=n.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return e=e.clone(),void 0!==t.offset&&e.offset.fromArray(t.offset),void 0!==t.rotation&&(e.rotation=t.rotation),void 0!==t.scale&&e.repeat.fromArray(t.scale),void 0!==t.texCoord&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),e.needsUpdate=!0,e}}class m extends THREE.MeshStandardMaterial{constructor(e){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","\tuniform sampler2D specularMap;","#endif"].join("\n"),n=["#ifdef USE_GLOSSINESSMAP","\tuniform sampler2D glossinessMap;","#endif"].join("\n"),r=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","\tvec4 texelSpecular = texture2D( specularMap, vUv );","\ttexelSpecular = sRGBToLinear( texelSpecular );","\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","\tspecularFactor *= texelSpecular.rgb;","#endif"].join("\n"),o=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );","\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","\tglossinessFactor *= texelGlossiness.a;","#endif"].join("\n"),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join("\n"),i={specular:{value:(new THREE.Color).setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=i,this.onBeforeCompile=function(e){for(const t in i)e.uniforms[t]=i[t];e.fragmentShader=e.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",r).replace("#include <metalnessmap_fragment>",o).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return i.specular.value},set:function(e){i.specular.value=e}},specularMap:{get:function(){return i.specularMap.value},set:function(e){i.specularMap.value=e,e?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return i.glossiness.value},set:function(e){i.glossiness.value=e}},glossinessMap:{get:function(){return i.glossinessMap.value},set:function(e){i.glossinessMap.value=e,e?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class x{constructor(){this.name=n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return m}extendParams(e,t,n){const r=t.extensions[this.name];e.color=new THREE.Color(1,1,1),e.opacity=1;const o=[];if(Array.isArray(r.diffuseFactor)){const t=r.diffuseFactor;e.color.fromArray(t),e.opacity=t[3]}if(void 0!==r.diffuseTexture&&o.push(n.assignTexture(e,"map",r.diffuseTexture)),e.emissive=new THREE.Color(0,0,0),e.glossiness=void 0!==r.glossinessFactor?r.glossinessFactor:1,e.specular=new THREE.Color(1,1,1),Array.isArray(r.specularFactor)&&e.specular.fromArray(r.specularFactor),void 0!==r.specularGlossinessTexture){const t=r.specularGlossinessTexture;o.push(n.assignTexture(e,"glossinessMap",t)),o.push(n.assignTexture(e,"specularMap",t))}return Promise.all(o)}createMaterial(e){const t=new m(e);return t.fog=!0,t.color=e.color,t.map=void 0===e.map?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=void 0===e.aoMap?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=void 0===e.emissiveMap?null:e.emissiveMap,t.bumpMap=void 0===e.bumpMap?null:e.bumpMap,t.bumpScale=1,t.normalMap=void 0===e.normalMap?null:e.normalMap,t.normalMapType=THREE.TangentSpaceNormalMap,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=void 0===e.specularMap?null:e.specularMap,t.specular=e.specular,t.glossinessMap=void 0===e.glossinessMap?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=void 0===e.envMap?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class g{constructor(){this.name=n.KHR_MESH_QUANTIZATION}}class y extends THREE.Interpolant{constructor(e,t,n,r){super(e,t,n,r)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,o=e*r*3+r;for(let e=0;e!==r;e++)t[e]=n[o+e];return t}}y.prototype.beforeStart_=y.prototype.copySampleValue_,y.prototype.afterEnd_=y.prototype.copySampleValue_,y.prototype.interpolate_=function(e,t,n,r){const o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,s=2*i,l=3*i,c=r-t,f=(n-t)/c,u=f*f,d=u*f,p=e*l,h=p-l,v=-2*d+3*u,m=d-u,x=1-v,g=m-u+f;for(let e=0;e!==i;e++){const t=a[h+e+i],n=a[h+e+s]*c,r=a[p+e+i],l=a[p+e]*c;o[e]=x*t+g*n+v*r+m*l}return o};const E=0,w=1,b=2,_=3,T=4,A=5,S=6,R={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},M={9728:THREE.NearestFilter,9729:THREE.LinearFilter,9984:THREE.NearestMipmapNearestFilter,9985:THREE.LinearMipmapNearestFilter,9986:THREE.NearestMipmapLinearFilter,9987:THREE.LinearMipmapLinearFilter},C={33071:THREE.ClampToEdgeWrapping,33648:THREE.MirroredRepeatWrapping,10497:THREE.RepeatWrapping},L={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},P={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},k={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},N={CUBICSPLINE:void 0,LINEAR:THREE.InterpolateLinear,STEP:THREE.InterpolateDiscrete},H="OPAQUE",z="MASK",D="BLEND";function F(e,t){return"string"!=typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}function I(e,t,n){for(const r in n.extensions)void 0===e[r]&&(t.userData.gltfExtensions=t.userData.gltfExtensions||{},t.userData.gltfExtensions[r]=n.extensions[r])}function O(e,t){void 0!==t.extras&&("object"==typeof t.extras?Object.assign(e.userData,t.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+t.extras))}function U(e,t){if(e.updateMorphTargets(),void 0!==t.weights)for(let n=0,r=t.weights.length;n<r;n++)e.morphTargetInfluences[n]=t.weights[n];if(t.extras&&Array.isArray(t.extras.targetNames)){const n=t.extras.targetNames;if(e.morphTargetInfluences.length===n.length){e.morphTargetDictionary={};for(let t=0,r=n.length;t<r;t++)e.morphTargetDictionary[n[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function G(e){const t=e.extensions&&e.extensions[n.KHR_DRACO_MESH_COMPRESSION];let r;return r=t?"draco:"+t.bufferView+":"+t.indices+":"+B(t.attributes):e.indices+":"+B(e.attributes)+":"+e.mode,r}function B(e){let t="";const n=Object.keys(e).sort();for(let r=0,o=n.length;r<o;r++)t+=n[r]+":"+e[n[r]]+";";return t}function V(e){switch(e){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class W{constructor(e={},n={}){this.json=e,this.extensions={},this.plugins={},this.options=n,this.cache=new t,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},"undefined"!=typeof createImageBitmap&&!1===/Firefox/.test(navigator.userAgent)?this.textureLoader=new THREE.ImageBitmapLoader(this.options.manager):this.textureLoader=new THREE.TextureLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new THREE.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,r=this.json,o=this.extensions;this.cache.removeAll(),this._invokeAll((function(e){return e._markDefs&&e._markDefs()})),Promise.all(this._invokeAll((function(e){return e.beforeRoot&&e.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(t){const a={scene:t[0][r.scene||0],scenes:t[0],animations:t[1],cameras:t[2],asset:r.asset,parser:n,userData:{}};I(o,a,r),O(a,r),Promise.all(n._invokeAll((function(e){return e.afterRoot&&e.afterRoot(a)}))).then((function(){e(a)}))})).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let n=0,r=t.length;n<r;n++){const r=t[n].joints;for(let t=0,n=r.length;t<n;t++)e[r[t]].isBone=!0}for(let t=0,r=e.length;t<r;t++){const r=e[t];void 0!==r.mesh&&(this._addNodeRef(this.meshCache,r.mesh),void 0!==r.skin&&(n[r.mesh].isSkinnedMesh=!0)),void 0!==r.camera&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){void 0!==t&&(void 0===e.refs[t]&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const r=n.clone();return r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const r=e(t[n]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let r=0;r<t.length;r++){const o=e(t[r]);o&&n.push(o)}return n}getDependency(e,t){const n=e+":"+t;let r=this.cache.get(n);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this.loadNode(t);break;case"mesh":r=this._invokeOne((function(e){return e.loadMesh&&e.loadMesh(t)}));break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne((function(e){return e.loadBufferView&&e.loadBufferView(t)}));break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne((function(e){return e.loadMaterial&&e.loadMaterial(t)}));break;case"texture":r=this._invokeOne((function(e){return e.loadTexture&&e.loadTexture(t)}));break;case"skin":r=this.loadSkin(t);break;case"animation":r=this.loadAnimation(t);break;case"camera":r=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,r=this.json[e+("mesh"===e?"es":"s")]||[];t=Promise.all(r.map((function(t,r){return n.getDependency(e,r)}))),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&"arraybuffer"!==t.type)throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(void 0===t.uri&&0===e)return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);const o=this.options;return new Promise((function(e,n){r.load(F(t.uri,o.path),e,void 0,(function(){n(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))}))}))}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then((function(e){const n=t.byteLength||0,r=t.byteOffset||0;return e.slice(r,r+n)}))}loadAccessor(e){const t=this,n=this.json,r=this.json.accessors[e];if(void 0===r.bufferView&&void 0===r.sparse)return Promise.resolve(null);const o=[];return void 0!==r.bufferView?o.push(this.getDependency("bufferView",r.bufferView)):o.push(null),void 0!==r.sparse&&(o.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),o.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(o).then((function(e){const o=e[0],a=L[r.type],i=R[r.componentType],s=i.BYTES_PER_ELEMENT,l=s*a,c=r.byteOffset||0,f=void 0!==r.bufferView?n.bufferViews[r.bufferView].byteStride:void 0,u=!0===r.normalized;let d,p;if(f&&f!==l){const e=Math.floor(c/f),n="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+e+":"+r.count;let l=t.cache.get(n);l||(d=new i(o,e*f,r.count*f/s),l=new THREE.InterleavedBuffer(d,f/s),t.cache.add(n,l)),p=new THREE.InterleavedBufferAttribute(l,a,c%f/s,u)}else d=null===o?new i(r.count*a):new i(o,c,r.count*a),p=new THREE.BufferAttribute(d,a,u);if(void 0!==r.sparse){const t=L.SCALAR,n=R[r.sparse.indices.componentType],s=r.sparse.indices.byteOffset||0,l=r.sparse.values.byteOffset||0,c=new n(e[1],s,r.sparse.count*t),f=new i(e[2],l,r.sparse.count*a);null!==o&&(p=new THREE.BufferAttribute(p.array.slice(),p.itemSize,p.normalized));for(let e=0,t=c.length;e<t;e++){const t=c[e];if(p.setX(t,f[e*a]),a>=2&&p.setY(t,f[e*a+1]),a>=3&&p.setZ(t,f[e*a+2]),a>=4&&p.setW(t,f[e*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse THREE.BufferAttribute.")}}return p}))}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e],o=t.images[r.source];let a=this.textureLoader;if(o.uri){const e=n.manager.getHandler(o.uri);null!==e&&(a=e)}return this.loadTextureImage(e,o,a)}loadTextureImage(e,t,n){const r=this,o=this.json,a=this.options,i=o.textures[e],s=self.URL||self.webkitURL;let l=t.uri,c=!1,f=!0;if("image/jpeg"===t.mimeType&&(f=!1),void 0!==t.bufferView)l=r.getDependency("bufferView",t.bufferView).then((function(e){if("image/png"===t.mimeType){const t=new DataView(e,25,1).getUint8(0,!1);f=6===t||4===t||3===t}c=!0;const n=new Blob([e],{type:t.mimeType});return l=s.createObjectURL(n),l}));else if(void 0===t.uri)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");return Promise.resolve(l).then((function(e){return new Promise((function(t,r){let o=t;!0===n.isImageBitmapLoader&&(o=function(e){t(new THREE.CanvasTexture(e))}),n.load(F(e,a.path),o,void 0,r)}))})).then((function(t){!0===c&&s.revokeObjectURL(l),t.flipY=!1,i.name&&(t.name=i.name),f||(t.format=THREE.RGBFormat);const n=(o.samplers||{})[i.sampler]||{};return t.magFilter=M[n.magFilter]||THREE.LinearFilter,t.minFilter=M[n.minFilter]||THREE.LinearMipmapLinearFilter,t.wrapS=C[n.wrapS]||THREE.RepeatWrapping,t.wrapT=C[n.wrapT]||THREE.RepeatWrapping,r.associations.set(t,{type:"textures",index:e}),t}))}assignTexture(e,t,r){const o=this;return this.getDependency("texture",r.index).then((function(a){if(void 0===r.texCoord||0==r.texCoord||"aoMap"===t&&1==r.texCoord||console.warn("THREE.GLTFLoader: Custom UV set "+r.texCoord+" for texture "+t+" not yet supported."),o.extensions[n.KHR_TEXTURE_TRANSFORM]){const e=void 0!==r.extensions?r.extensions[n.KHR_TEXTURE_TRANSFORM]:void 0;if(e){const t=o.associations.get(a);a=o.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(a,e),o.associations.set(a,t)}}e[t]=a}))}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const r=void 0!==t.attributes.color,o=void 0===t.attributes.normal,a=!0===e.isSkinnedMesh,i=Object.keys(t.morphAttributes).length>0,s=i&&void 0!==t.morphAttributes.normal;if(e.isPoints){const e="PointsMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new THREE.PointsMaterial,THREE.Material.prototype.copy.call(t,n),t.color.copy(n.color),t.map=n.map,t.sizeAttenuation=!1,this.cache.add(e,t)),n=t}else if(e.isLine){const e="LineBasicMaterial:"+n.uuid;let t=this.cache.get(e);t||(t=new THREE.LineBasicMaterial,THREE.Material.prototype.copy.call(t,n),t.color.copy(n.color),this.cache.add(e,t)),n=t}if(r||o||a||i){let e="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(e+="specular-glossiness:"),a&&(e+="skinning:"),r&&(e+="vertex-colors:"),o&&(e+="flat-shading:"),i&&(e+="morph-targets:"),s&&(e+="morph-normals:");let t=this.cache.get(e);t||(t=n.clone(),a&&(t.skinning=!0),r&&(t.vertexColors=!0),o&&(t.flatShading=!0),i&&(t.morphTargets=!0),s&&(t.morphNormals=!0),this.cache.add(e,t),this.associations.set(t,this.associations.get(n))),n=t}n.aoMap&&void 0===t.attributes.uv2&&void 0!==t.attributes.uv&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return THREE.MeshStandardMaterial}loadMaterial(e){const t=this,r=this.json,o=this.extensions,a=r.materials[e];let i;const s={},l=a.extensions||{},c=[];if(l[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const e=o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];i=e.getMaterialType(),c.push(e.extendParams(s,a,t))}else if(l[n.KHR_MATERIALS_UNLIT]){const e=o[n.KHR_MATERIALS_UNLIT];i=e.getMaterialType(),c.push(e.extendParams(s,a,t))}else{const n=a.pbrMetallicRoughness||{};if(s.color=new THREE.Color(1,1,1),s.opacity=1,Array.isArray(n.baseColorFactor)){const e=n.baseColorFactor;s.color.fromArray(e),s.opacity=e[3]}void 0!==n.baseColorTexture&&c.push(t.assignTexture(s,"map",n.baseColorTexture)),s.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,s.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(c.push(t.assignTexture(s,"metalnessMap",n.metallicRoughnessTexture)),c.push(t.assignTexture(s,"roughnessMap",n.metallicRoughnessTexture))),i=this._invokeOne((function(t){return t.getMaterialType&&t.getMaterialType(e)})),c.push(Promise.all(this._invokeAll((function(t){return t.extendMaterialParams&&t.extendMaterialParams(e,s)}))))}!0===a.doubleSided&&(s.side=THREE.DoubleSide);const f=a.alphaMode||H;return f===D?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,f===z&&(s.alphaTest=void 0!==a.alphaCutoff?a.alphaCutoff:.5)),void 0!==a.normalTexture&&i!==THREE.MeshBasicMaterial&&(c.push(t.assignTexture(s,"normalMap",a.normalTexture)),s.normalScale=new THREE.Vector2(1,-1),void 0!==a.normalTexture.scale&&s.normalScale.set(a.normalTexture.scale,-a.normalTexture.scale)),void 0!==a.occlusionTexture&&i!==THREE.MeshBasicMaterial&&(c.push(t.assignTexture(s,"aoMap",a.occlusionTexture)),void 0!==a.occlusionTexture.strength&&(s.aoMapIntensity=a.occlusionTexture.strength)),void 0!==a.emissiveFactor&&i!==THREE.MeshBasicMaterial&&(s.emissive=(new THREE.Color).fromArray(a.emissiveFactor)),void 0!==a.emissiveTexture&&i!==THREE.MeshBasicMaterial&&c.push(t.assignTexture(s,"emissiveMap",a.emissiveTexture)),Promise.all(c).then((function(){let r;return r=i===m?o[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s):new i(s),a.name&&(r.name=a.name),r.map&&(r.map.encoding=THREE.sRGBEncoding),r.emissiveMap&&(r.emissiveMap.encoding=THREE.sRGBEncoding),O(r,a),t.associations.set(r,{type:"materials",index:e}),a.extensions&&I(o,r,a),r}))}createUniqueName(e){const t=THREE.PropertyBinding.sanitizeNodeName(e||"");let n=t;for(let e=1;this.nodeNamesUsed[n];++e)n=t+"_"+e;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,r=this.extensions,o=this.primitiveCache;function a(e){return r[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e,t).then((function(n){return q(n,e,t)}))}const i=[];for(let r=0,s=e.length;r<s;r++){const s=e[r],l=G(s),c=o[l];if(c)i.push(c.promise);else{let e;e=s.extensions&&s.extensions[n.KHR_DRACO_MESH_COMPRESSION]?a(s):q(new THREE.BufferGeometry,s,t),o[l]={primitive:s,promise:e},i.push(e)}}return Promise.all(i)}loadMesh(e){const t=this,n=this.json,r=this.extensions,o=n.meshes[e],a=o.primitives,i=[];for(let e=0,t=a.length;e<t;e++){const t=void 0===a[e].material?(void 0===(s=this.cache).DefaultMaterial&&(s.DefaultMaterial=new THREE.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:THREE.FrontSide})),s.DefaultMaterial):this.getDependency("material",a[e].material);i.push(t)}var s;return i.push(t.loadGeometries(a)),Promise.all(i).then((function(n){const i=n.slice(0,n.length-1),s=n[n.length-1],l=[];for(let n=0,c=s.length;n<c;n++){const c=s[n],f=a[n];let u;const d=i[n];if(f.mode===T||f.mode===A||f.mode===S||void 0===f.mode)u=!0===o.isSkinnedMesh?new THREE.SkinnedMesh(c,d):new THREE.Mesh(c,d),!0!==u.isSkinnedMesh||u.geometry.attributes.skinWeight.normalized||u.normalizeSkinWeights(),f.mode===A?u.geometry=X(u.geometry,THREE.TriangleStripDrawMode):f.mode===S&&(u.geometry=X(u.geometry,THREE.TriangleFanDrawMode));else if(f.mode===w)u=new THREE.LineSegments(c,d);else if(f.mode===_)u=new THREE.Line(c,d);else if(f.mode===b)u=new THREE.LineLoop(c,d);else{if(f.mode!==E)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+f.mode);u=new THREE.Points(c,d)}Object.keys(u.geometry.morphAttributes).length>0&&U(u,o),u.name=t.createUniqueName(o.name||"mesh_"+e),O(u,o),f.extensions&&I(r,u,f),t.assignFinalMaterial(u),l.push(u)}if(1===l.length)return l[0];const c=new THREE.Group;for(let e=0,t=l.length;e<t;e++)c.add(l[e]);return c}))}loadCamera(e){let t;const n=this.json.cameras[e],r=n[n.type];if(r)return"perspective"===n.type?t=new THREE.PerspectiveCamera(THREE.MathUtils.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):"orthographic"===n.type&&(t=new THREE.OrthographicCamera(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),O(t,n),Promise.resolve(t);console.warn("THREE.GLTFLoader: Missing camera parameters.")}loadSkin(e){const t=this.json.skins[e],n={joints:t.joints};return void 0===t.inverseBindMatrices?Promise.resolve(n):this.getDependency("accessor",t.inverseBindMatrices).then((function(e){return n.inverseBindMatrices=e,n}))}loadAnimation(e){const t=this.json.animations[e],n=[],r=[],o=[],a=[],i=[];for(let e=0,s=t.channels.length;e<s;e++){const s=t.channels[e],l=t.samplers[s.sampler],c=s.target,f=void 0!==c.node?c.node:c.id,u=void 0!==t.parameters?t.parameters[l.input]:l.input,d=void 0!==t.parameters?t.parameters[l.output]:l.output;n.push(this.getDependency("node",f)),r.push(this.getDependency("accessor",u)),o.push(this.getDependency("accessor",d)),a.push(l),i.push(c)}return Promise.all([Promise.all(n),Promise.all(r),Promise.all(o),Promise.all(a),Promise.all(i)]).then((function(n){const r=n[0],o=n[1],a=n[2],i=n[3],s=n[4],l=[];for(let e=0,t=r.length;e<t;e++){const t=r[e],n=o[e],c=a[e],f=i[e],u=s[e];if(void 0===t)continue;let d;switch(t.updateMatrix(),t.matrixAutoUpdate=!0,k[u.path]){case k.weights:d=THREE.NumberKeyframeTrack;break;case k.rotation:d=THREE.QuaternionKeyframeTrack;break;case k.position:case k.scale:default:d=THREE.VectorKeyframeTrack}const p=t.name?t.name:t.uuid,h=void 0!==f.interpolation?N[f.interpolation]:THREE.InterpolateLinear,v=[];k[u.path]===k.weights?t.traverse((function(e){!0===e.isMesh&&e.morphTargetInfluences&&v.push(e.name?e.name:e.uuid)})):v.push(p);let m=c.array;if(c.normalized){const e=V(m.constructor),t=new Float32Array(m.length);for(let n=0,r=m.length;n<r;n++)t[n]=m[n]*e;m=t}for(let e=0,t=v.length;e<t;e++){const t=new d(v[e]+"."+k[u.path],n.array,m,h);"CUBICSPLINE"===f.interpolation&&(t.createInterpolant=function(e){return new y(this.times,this.values,this.getValueSize()/3,e)},t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),l.push(t)}}const c=t.name?t.name:"animation_"+e;return new THREE.AnimationClip(c,void 0,l)}))}createNodeMesh(e){const t=this.json,n=this,r=t.nodes[e];return void 0===r.mesh?null:n.getDependency("mesh",r.mesh).then((function(e){const t=n._getNodeRef(n.meshCache,r.mesh,e);return void 0!==r.weights&&t.traverse((function(e){if(e.isMesh)for(let t=0,n=r.weights.length;t<n;t++)e.morphTargetInfluences[t]=r.weights[t]})),t}))}loadNode(e){const t=this.json,n=this.extensions,r=this,o=t.nodes[e],a=o.name?r.createUniqueName(o.name):"";return function(){const t=[],n=r._invokeOne((function(t){return t.createNodeMesh&&t.createNodeMesh(e)}));return n&&t.push(n),void 0!==o.camera&&t.push(r.getDependency("camera",o.camera).then((function(e){return r._getNodeRef(r.cameraCache,o.camera,e)}))),r._invokeAll((function(t){return t.createNodeAttachment&&t.createNodeAttachment(e)})).forEach((function(e){t.push(e)})),Promise.all(t)}().then((function(t){let i;if(i=!0===o.isBone?new THREE.Bone:t.length>1?new THREE.Group:1===t.length?t[0]:new THREE.Object3D,i!==t[0])for(let e=0,n=t.length;e<n;e++)i.add(t[e]);if(o.name&&(i.userData.name=o.name,i.name=a),O(i,o),o.extensions&&I(n,i,o),void 0!==o.matrix){const e=new THREE.Matrix4;e.fromArray(o.matrix),i.applyMatrix4(e)}else void 0!==o.translation&&i.position.fromArray(o.translation),void 0!==o.rotation&&i.quaternion.fromArray(o.rotation),void 0!==o.scale&&i.scale.fromArray(o.scale);return r.associations.set(i,{type:"nodes",index:e}),i}))}loadScene(e){const t=this.json,n=this.extensions,r=this.json.scenes[e],o=this,a=new THREE.Group;r.name&&(a.name=o.createUniqueName(r.name)),O(a,r),r.extensions&&I(n,a,r);const i=r.nodes||[],s=[];for(let e=0,n=i.length;e<n;e++)s.push(j(i[e],a,t,o));return Promise.all(s).then((function(){return a}))}}function j(e,t,n,r){const o=n.nodes[e];return r.getDependency("node",e).then((function(e){if(void 0===o.skin)return e;let t;return r.getDependency("skin",o.skin).then((function(e){t=e;const n=[];for(let e=0,o=t.joints.length;e<o;e++)n.push(r.getDependency("node",t.joints[e]));return Promise.all(n)})).then((function(n){return e.traverse((function(e){if(!e.isMesh)return;const r=[],o=[];for(let e=0,a=n.length;e<a;e++){const a=n[e];if(a){r.push(a);const n=new THREE.Matrix4;void 0!==t.inverseBindMatrices&&n.fromArray(t.inverseBindMatrices.array,16*e),o.push(n)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[e])}e.bind(new THREE.Skeleton(r,o),e.matrixWorld)})),e}))})).then((function(e){t.add(e);const a=[];if(o.children){const t=o.children;for(let o=0,i=t.length;o<i;o++){const i=t[o];a.push(j(i,e,n,r))}}return Promise.all(a)}))}function q(e,t,n){const r=t.attributes,o=[];function a(t,r){return n.getDependency("accessor",t).then((function(t){e.setAttribute(r,t)}))}for(const t in r){const n=P[t]||t.toLowerCase();n in e.attributes||o.push(a(r[t],n))}if(void 0!==t.indices&&!e.index){const r=n.getDependency("accessor",t.indices).then((function(t){e.setIndex(t)}));o.push(r)}return O(e,t),function(e,t,n){const r=t.attributes,o=new THREE.Box3;if(void 0===r.POSITION)return;{const e=n.json.accessors[r.POSITION],t=e.min,a=e.max;if(void 0===t||void 0===a)return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");if(o.set(new THREE.Vector3(t[0],t[1],t[2]),new THREE.Vector3(a[0],a[1],a[2])),e.normalized){const t=V(R[e.componentType]);o.min.multiplyScalar(t),o.max.multiplyScalar(t)}}const a=t.targets;if(void 0!==a){const e=new THREE.Vector3,t=new THREE.Vector3;for(let r=0,o=a.length;r<o;r++){const o=a[r];if(void 0!==o.POSITION){const r=n.json.accessors[o.POSITION],a=r.min,i=r.max;if(void 0!==a&&void 0!==i){if(t.setX(Math.max(Math.abs(a[0]),Math.abs(i[0]))),t.setY(Math.max(Math.abs(a[1]),Math.abs(i[1]))),t.setZ(Math.max(Math.abs(a[2]),Math.abs(i[2]))),r.normalized){const e=V(R[r.componentType]);t.multiplyScalar(e)}e.max(t)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}o.expandByVector(e)}e.boundingBox=o;const i=new THREE.Sphere;o.getCenter(i.center),i.radius=o.min.distanceTo(o.max)/2,e.boundingSphere=i}(e,t,n),Promise.all(o).then((function(){return void 0!==t.targets?function(e,t,n){let r=!1,o=!1;for(let e=0,n=t.length;e<n;e++){const n=t[e];if(void 0!==n.POSITION&&(r=!0),void 0!==n.NORMAL&&(o=!0),r&&o)break}if(!r&&!o)return Promise.resolve(e);const a=[],i=[];for(let s=0,l=t.length;s<l;s++){const l=t[s];if(r){const t=void 0!==l.POSITION?n.getDependency("accessor",l.POSITION):e.attributes.position;a.push(t)}if(o){const t=void 0!==l.NORMAL?n.getDependency("accessor",l.NORMAL):e.attributes.normal;i.push(t)}}return Promise.all([Promise.all(a),Promise.all(i)]).then((function(t){const n=t[0],a=t[1];return r&&(e.morphAttributes.position=n),o&&(e.morphAttributes.normal=a),e.morphTargetsRelative=!0,e}))}(e,t.targets,n):e}))}function X(e,t){let n=e.getIndex();if(null===n){const t=[],r=e.getAttribute("position");if(void 0===r)return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(let e=0;e<r.count;e++)t.push(e);e.setIndex(t),n=e.getIndex()}const r=n.count-2,o=[];if(t===THREE.TriangleFanDrawMode)for(let e=1;e<=r;e++)o.push(n.getX(0)),o.push(n.getX(e)),o.push(n.getX(e+1));else for(let e=0;e<r;e++)e%2==0?(o.push(n.getX(e)),o.push(n.getX(e+1)),o.push(n.getX(e+2))):(o.push(n.getX(e+2)),o.push(n.getX(e+1)),o.push(n.getX(e)));o.length/3!==r&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const a=e.clone();return a.setIndex(o),a}THREE.GLTFLoader=e}()},3425:()=>{THREE.GPUComputationRenderer=class{constructor(e,t,n){this.variables=[],this.currentTextureIndex=0;let r=THREE.FloatType;const o=new THREE.Scene,a=new THREE.Camera;a.position.z=1;const i={passThruTexture:{value:null}},s=f("uniform sampler2D passThruTexture;\n\nvoid main() {\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\n\tgl_FragColor = texture2D( passThruTexture, uv );\n\n}\n",i),l=new THREE.Mesh(new THREE.PlaneGeometry(2,2),s);function c(n){n.defines.resolution="vec2( "+e.toFixed(1)+", "+t.toFixed(1)+" )"}function f(e,t){t=t||{};const n=new THREE.ShaderMaterial({uniforms:t,vertexShader:"void main()\t{\n\n\tgl_Position = vec4( position, 1.0 );\n\n}\n",fragmentShader:e});return c(n),n}o.add(l),this.setDataType=function(e){return r=e,this},this.addVariable=function(e,t,n){const r={name:e,initialValueTexture:n,material:this.createShaderMaterial(t),dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};return this.variables.push(r),r},this.setVariableDependencies=function(e,t){e.dependencies=t},this.init=function(){if(!1===n.capabilities.isWebGL2&&!1===n.extensions.has("OES_texture_float"))return"No OES_texture_float support for float textures.";if(0===n.capabilities.maxVertexTextures)return"No support for vertex shader textures.";for(let n=0;n<this.variables.length;n++){const r=this.variables[n];r.renderTargets[0]=this.createRenderTarget(e,t,r.wrapS,r.wrapT,r.minFilter,r.magFilter),r.renderTargets[1]=this.createRenderTarget(e,t,r.wrapS,r.wrapT,r.minFilter,r.magFilter),this.renderTexture(r.initialValueTexture,r.renderTargets[0]),this.renderTexture(r.initialValueTexture,r.renderTargets[1]);const o=r.material,a=o.uniforms;if(null!==r.dependencies)for(let e=0;e<r.dependencies.length;e++){const t=r.dependencies[e];if(t.name!==r.name){let e=!1;for(let n=0;n<this.variables.length;n++)if(t.name===this.variables[n].name){e=!0;break}if(!e)return"Variable dependency not found. Variable="+r.name+", dependency="+t.name}a[t.name]={value:null},o.fragmentShader="\nuniform sampler2D "+t.name+";\n"+o.fragmentShader}}return this.currentTextureIndex=0,null},this.compute=function(){const e=this.currentTextureIndex,t=0===this.currentTextureIndex?1:0;for(let n=0,r=this.variables.length;n<r;n++){const r=this.variables[n];if(null!==r.dependencies){const t=r.material.uniforms;for(let n=0,o=r.dependencies.length;n<o;n++){const o=r.dependencies[n];t[o.name].value=o.renderTargets[e].texture}}this.doRenderTarget(r.material,r.renderTargets[t])}this.currentTextureIndex=t},this.getCurrentRenderTarget=function(e){return e.renderTargets[this.currentTextureIndex]},this.getAlternateRenderTarget=function(e){return e.renderTargets[0===this.currentTextureIndex?1:0]},this.addResolutionDefine=c,this.createShaderMaterial=f,this.createRenderTarget=function(n,o,a,i,s,l){return n=n||e,o=o||t,a=a||THREE.ClampToEdgeWrapping,i=i||THREE.ClampToEdgeWrapping,s=s||THREE.NearestFilter,l=l||THREE.NearestFilter,new THREE.WebGLRenderTarget(n,o,{wrapS:a,wrapT:i,minFilter:s,magFilter:l,format:THREE.RGBAFormat,type:r,depthBuffer:!1})},this.createTexture=function(){const n=new Float32Array(e*t*4);return new THREE.DataTexture(n,e,t,THREE.RGBAFormat,THREE.FloatType)},this.renderTexture=function(e,t){i.passThruTexture.value=e,this.doRenderTarget(s,t),i.passThruTexture.value=null},this.doRenderTarget=function(e,t){const r=n.getRenderTarget();l.material=e,n.setRenderTarget(t),n.render(o,a),l.material=s,n.setRenderTarget(r)}}}},9929:()=>{!function(){const e={uniforms:{tDiffuse:{value:null}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 tex = texture2D( tDiffuse, vUv );\n\n\t\t\tgl_FragColor = LinearTosRGB( tex ); // optional: LinearToGamma( tex, float( GAMMA_FACTOR ) );\n\n\t\t}"};THREE.GammaCorrectionShader=e}()},6842:()=>{!function(){const e=new THREE.Matrix4,t=new THREE.Object3D,n=new THREE.Vector3;class r extends THREE.EventDispatcher{constructor(){super(),this.uuid=THREE.MathUtils.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}applyMatrix4(e){const t=(new THREE.Matrix3).getNormalMatrix(e);for(let t=0,n=this.vertices.length;t<n;t++){this.vertices[t].applyMatrix4(e)}for(let e=0,n=this.faces.length;e<n;e++){const n=this.faces[e];n.normal.applyMatrix3(t).normalize();for(let e=0,r=n.vertexNormals.length;e<r;e++)n.vertexNormals[e].applyMatrix3(t).normalize()}return null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this}rotateX(t){return e.makeRotationX(t),this.applyMatrix4(e),this}rotateY(t){return e.makeRotationY(t),this.applyMatrix4(e),this}rotateZ(t){return e.makeRotationZ(t),this.applyMatrix4(e),this}translate(t,n,r){return e.makeTranslation(t,n,r),this.applyMatrix4(e),this}scale(t,n,r){return e.makeScale(t,n,r),this.applyMatrix4(e),this}lookAt(e){return t.lookAt(e),t.updateMatrix(),this.applyMatrix4(t.matrix),this}fromBufferGeometry(e){const t=this,n=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const o=r.position,i=r.normal,s=r.color,l=r.uv,c=r.uv2;void 0!==c&&(this.faceVertexUvs[1]=[]);for(let e=0;e<o.count;e++)t.vertices.push((new THREE.Vector3).fromBufferAttribute(o,e)),void 0!==s&&t.colors.push((new THREE.Color).fromBufferAttribute(s,e));function f(e,n,r,o){const f=void 0===s?[]:[t.colors[e].clone(),t.colors[n].clone(),t.colors[r].clone()],u=void 0===i?[]:[(new THREE.Vector3).fromBufferAttribute(i,e),(new THREE.Vector3).fromBufferAttribute(i,n),(new THREE.Vector3).fromBufferAttribute(i,r)],d=new a(e,n,r,u,f,o);t.faces.push(d),void 0!==l&&t.faceVertexUvs[0].push([(new THREE.Vector2).fromBufferAttribute(l,e),(new THREE.Vector2).fromBufferAttribute(l,n),(new THREE.Vector2).fromBufferAttribute(l,r)]),void 0!==c&&t.faceVertexUvs[1].push([(new THREE.Vector2).fromBufferAttribute(c,e),(new THREE.Vector2).fromBufferAttribute(c,n),(new THREE.Vector2).fromBufferAttribute(c,r)])}const u=e.groups;if(u.length>0)for(let e=0;e<u.length;e++){const t=u[e],r=t.start;for(let e=r,o=r+t.count;e<o;e+=3)void 0!==n?f(n.getX(e),n.getX(e+1),n.getX(e+2),t.materialIndex):f(e,e+1,e+2,t.materialIndex)}else if(void 0!==n)for(let e=0;e<n.count;e+=3)f(n.getX(e),n.getX(e+1),n.getX(e+2));else for(let e=0;e<o.count;e+=3)f(e,e+1,e+2);return this.computeFaceNormals(),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(n).negate(),this.translate(n.x,n.y,n.z),this}normalize(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=0===t?1:1/t,r=new THREE.Matrix4;return r.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(r),this}computeFaceNormals(){const e=new THREE.Vector3,t=new THREE.Vector3;for(let n=0,r=this.faces.length;n<r;n++){const r=this.faces[n],o=this.vertices[r.a],a=this.vertices[r.b],i=this.vertices[r.c];e.subVectors(i,a),t.subVectors(o,a),e.cross(t),e.normalize(),r.normal.copy(e)}}computeVertexNormals(e=!0){const t=new Array(this.vertices.length);for(let e=0,n=this.vertices.length;e<n;e++)t[e]=new THREE.Vector3;if(e){const e=new THREE.Vector3,n=new THREE.Vector3;for(let r=0,o=this.faces.length;r<o;r++){const o=this.faces[r],a=this.vertices[o.a],i=this.vertices[o.b],s=this.vertices[o.c];e.subVectors(s,i),n.subVectors(a,i),e.cross(n),t[o.a].add(e),t[o.b].add(e),t[o.c].add(e)}}else{this.computeFaceNormals();for(let e=0,n=this.faces.length;e<n;e++){const n=this.faces[e];t[n.a].add(n.normal),t[n.b].add(n.normal),t[n.c].add(n.normal)}}for(let e=0,n=this.vertices.length;e<n;e++)t[e].normalize();for(let e=0,n=this.faces.length;e<n;e++){const n=this.faces[e],r=n.vertexNormals;3===r.length?(r[0].copy(t[n.a]),r[1].copy(t[n.b]),r[2].copy(t[n.c])):(r[0]=t[n.a].clone(),r[1]=t[n.b].clone(),r[2]=t[n.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeFlatVertexNormals(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],n=t.vertexNormals;3===n.length?(n[0].copy(t.normal),n[1].copy(t.normal),n[2].copy(t.normal)):(n[0]=t.normal.clone(),n[1]=t.normal.clone(),n[2]=t.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)}computeMorphNormals(){for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.__originalFaceNormal?t.__originalFaceNormal.copy(t.normal):t.__originalFaceNormal=t.normal.clone(),t.__originalVertexNormals||(t.__originalVertexNormals=[]);for(let e=0,n=t.vertexNormals.length;e<n;e++)t.__originalVertexNormals[e]?t.__originalVertexNormals[e].copy(t.vertexNormals[e]):t.__originalVertexNormals[e]=t.vertexNormals[e].clone()}const e=new r;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const e=this.morphNormals[t].faceNormals,n=this.morphNormals[t].vertexNormals;for(let t=0,r=this.faces.length;t<r;t++){const t=new THREE.Vector3,r={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3};e.push(t),n.push(r)}}const n=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e],r=n.faceNormals[e],o=n.vertexNormals[e];r.copy(t.normal),o.a.copy(t.vertexNormals[0]),o.b.copy(t.vertexNormals[1]),o.c.copy(t.vertexNormals[2])}}for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.normal=t.__originalFaceNormal,t.vertexNormals=t.__originalVertexNormals}}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3),this.boundingBox.setFromPoints(this.vertices)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere),this.boundingSphere.setFromPoints(this.vertices)}merge(e,t,n=0){if(!e||!e.isGeometry)return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);let r;const o=this.vertices.length,i=this.vertices,s=e.vertices,l=this.faces,c=e.faces,f=this.colors,u=e.colors;void 0!==t&&(r=(new THREE.Matrix3).getNormalMatrix(t));for(let e=0,n=s.length;e<n;e++){const n=s[e].clone();void 0!==t&&n.applyMatrix4(t),i.push(n)}for(let e=0,t=u.length;e<t;e++)f.push(u[e].clone());for(let e=0,t=c.length;e<t;e++){const t=c[e];let i,s;const f=t.vertexNormals,u=t.vertexColors,d=new a(t.a+o,t.b+o,t.c+o);d.normal.copy(t.normal),void 0!==r&&d.normal.applyMatrix3(r).normalize();for(let e=0,t=f.length;e<t;e++)i=f[e].clone(),void 0!==r&&i.applyMatrix3(r).normalize(),d.vertexNormals.push(i);d.color.copy(t.color);for(let e=0,t=u.length;e<t;e++)s=u[e],d.vertexColors.push(s.clone());d.materialIndex=t.materialIndex+n,l.push(d)}for(let t=0,n=e.faceVertexUvs.length;t<n;t++){const n=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,r=n.length;e<r;e++){const r=n[e],o=[];for(let e=0,t=r.length;e<t;e++)o.push(r[e].clone());this.faceVertexUvs[t].push(o)}}}mergeMesh(e){e&&e.isMesh?(e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)):console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e)}mergeVertices(e=4){const t={},n=[],r=[],o=Math.pow(10,e);for(let e=0,a=this.vertices.length;e<a;e++){const a=this.vertices[e],i=Math.round(a.x*o)+"_"+Math.round(a.y*o)+"_"+Math.round(a.z*o);void 0===t[i]?(t[i]=e,n.push(this.vertices[e]),r[e]=n.length-1):r[e]=r[t[i]]}const a=[];for(let e=0,t=this.faces.length;e<t;e++){const t=this.faces[e];t.a=r[t.a],t.b=r[t.b],t.c=r[t.c];const n=[t.a,t.b,t.c];for(let t=0;t<3;t++)if(n[t]===n[(t+1)%3]){a.push(e);break}}for(let e=a.length-1;e>=0;e--){const t=a[e];this.faces.splice(t,1);for(let e=0,n=this.faceVertexUvs.length;e<n;e++)this.faceVertexUvs[e].splice(t,1)}const i=this.vertices.length-n.length;return this.vertices=n,i}setFromPoints(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const n=e[t];this.vertices.push(new THREE.Vector3(n.x,n.y,n.z||0))}return this}sortFacesByMaterialIndex(){const e=this.faces,t=e.length;for(let n=0;n<t;n++)e[n]._id=n;e.sort((function(e,t){return e.materialIndex-t.materialIndex}));const n=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let o,a;n&&n.length===t&&(o=[]),r&&r.length===t&&(a=[]);for(let i=0;i<t;i++){const t=e[i]._id;o&&o.push(n[t]),a&&a.push(r[t])}o&&(this.faceVertexUvs[0]=o),a&&(this.faceVertexUvs[1]=a)}toJSON(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}const t=[];for(let e=0;e<this.vertices.length;e++){const n=this.vertices[e];t.push(n.x,n.y,n.z)}const n=[],r=[],o={},a=[],i={},s=[],l={};for(let e=0;e<this.faces.length;e++){const t=this.faces[e],r=!0,o=!1,a=void 0!==this.faceVertexUvs[0][e],i=t.normal.length()>0,s=t.vertexNormals.length>0,l=1!==t.color.r||1!==t.color.g||1!==t.color.b,p=t.vertexColors.length>0;let h=0;if(h=c(h,0,0),h=c(h,1,r),h=c(h,2,o),h=c(h,3,a),h=c(h,4,i),h=c(h,5,s),h=c(h,6,l),h=c(h,7,p),n.push(h),n.push(t.a,t.b,t.c),n.push(t.materialIndex),a){const t=this.faceVertexUvs[0][e];n.push(d(t[0]),d(t[1]),d(t[2]))}if(i&&n.push(f(t.normal)),s){const e=t.vertexNormals;n.push(f(e[0]),f(e[1]),f(e[2]))}if(l&&n.push(u(t.color)),p){const e=t.vertexColors;n.push(u(e[0]),u(e[1]),u(e[2]))}}function c(e,t,n){return n?e|1<<t:e&~(1<<t)}function f(e){const t=e.x.toString()+e.y.toString()+e.z.toString();return void 0!==o[t]||(o[t]=r.length/3,r.push(e.x,e.y,e.z)),o[t]}function u(e){const t=e.r.toString()+e.g.toString()+e.b.toString();return void 0!==i[t]||(i[t]=a.length,a.push(e.getHex())),i[t]}function d(e){const t=e.x.toString()+e.y.toString();return void 0!==l[t]||(l[t]=s.length/2,s.push(e.x,e.y)),l[t]}return e.data={},e.data.vertices=t,e.data.normals=r,a.length>0&&(e.data.colors=a),s.length>0&&(e.data.uvs=[s]),e.data.faces=n,e}clone(){return(new r).copy(this)}copy(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let e=0,n=t.length;e<n;e++)this.vertices.push(t[e].clone());const n=e.colors;for(let e=0,t=n.length;e<t;e++)this.colors.push(n[e].clone());const r=e.faces;for(let e=0,t=r.length;e<t;e++)this.faces.push(r[e].clone());for(let t=0,n=e.faceVertexUvs.length;t<n;t++){const n=e.faceVertexUvs[t];void 0===this.faceVertexUvs[t]&&(this.faceVertexUvs[t]=[]);for(let e=0,r=n.length;e<r;e++){const r=n[e],o=[];for(let e=0,t=r.length;e<t;e++){const t=r[e];o.push(t.clone())}this.faceVertexUvs[t].push(o)}}const o=e.morphTargets;for(let e=0,t=o.length;e<t;e++){const t={};if(t.name=o[e].name,void 0!==o[e].vertices){t.vertices=[];for(let n=0,r=o[e].vertices.length;n<r;n++)t.vertices.push(o[e].vertices[n].clone())}if(void 0!==o[e].normals){t.normals=[];for(let n=0,r=o[e].normals.length;n<r;n++)t.normals.push(o[e].normals[n].clone())}this.morphTargets.push(t)}const a=e.morphNormals;for(let e=0,t=a.length;e<t;e++){const t={};if(void 0!==a[e].vertexNormals){t.vertexNormals=[];for(let n=0,r=a[e].vertexNormals.length;n<r;n++){const r=a[e].vertexNormals[n],o={};o.a=r.a.clone(),o.b=r.b.clone(),o.c=r.c.clone(),t.vertexNormals.push(o)}}if(void 0!==a[e].faceNormals){t.faceNormals=[];for(let n=0,r=a[e].faceNormals.length;n<r;n++)t.faceNormals.push(a[e].faceNormals[n].clone())}this.morphNormals.push(t)}const i=e.skinWeights;for(let e=0,t=i.length;e<t;e++)this.skinWeights.push(i[e].clone());const s=e.skinIndices;for(let e=0,t=s.length;e<t;e++)this.skinIndices.push(s[e].clone());const l=e.lineDistances;for(let e=0,t=l.length;e<t;e++)this.lineDistances.push(l[e]);const c=e.boundingBox;null!==c&&(this.boundingBox=c.clone());const f=e.boundingSphere;return null!==f&&(this.boundingSphere=f.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this}toBufferGeometry(){const e=(new o).fromGeometry(this),t=new THREE.BufferGeometry,n=new Float32Array(3*e.vertices.length);if(t.setAttribute("position",new THREE.BufferAttribute(n,3).copyVector3sArray(e.vertices)),e.normals.length>0){const n=new Float32Array(3*e.normals.length);t.setAttribute("normal",new THREE.BufferAttribute(n,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const n=new Float32Array(3*e.colors.length);t.setAttribute("color",new THREE.BufferAttribute(n,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const n=new Float32Array(2*e.uvs.length);t.setAttribute("uv",new THREE.BufferAttribute(n,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const n=new Float32Array(2*e.uvs2.length);t.setAttribute("uv2",new THREE.BufferAttribute(n,2).copyVector2sArray(e.uvs2))}t.groups=e.groups;for(const n in e.morphTargets){const r=[],o=e.morphTargets[n];for(let e=0,t=o.length;e<t;e++){const t=o[e],n=new THREE.Float32BufferAttribute(3*t.data.length,3);n.name=t.name,r.push(n.copyVector3sArray(t.data))}t.morphAttributes[n]=r}if(e.skinIndices.length>0){const n=new THREE.Float32BufferAttribute(4*e.skinIndices.length,4);t.setAttribute("skinIndex",n.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const n=new THREE.Float32BufferAttribute(4*e.skinWeights.length,4);t.setAttribute("skinWeight",n.copyVector4sArray(e.skinWeights))}return null!==e.boundingSphere&&(t.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(t.boundingBox=e.boundingBox.clone()),t}computeTangents(){console.error("THREE.Geometry: .computeTangents() has been removed.")}computeLineDistances(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")}applyMatrix(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}dispose(){this.dispatchEvent({type:"dispose"})}static createBufferGeometryFromObject(e){let t=new THREE.BufferGeometry;const n=e.geometry;if(e.isPoints||e.isLine){const e=new THREE.Float32BufferAttribute(3*n.vertices.length,3),r=new THREE.Float32BufferAttribute(3*n.colors.length,3);if(t.setAttribute("position",e.copyVector3sArray(n.vertices)),t.setAttribute("color",r.copyColorsArray(n.colors)),n.lineDistances&&n.lineDistances.length===n.vertices.length){const e=new THREE.Float32BufferAttribute(n.lineDistances.length,1);t.setAttribute("lineDistance",e.copyArray(n.lineDistances))}null!==n.boundingSphere&&(t.boundingSphere=n.boundingSphere.clone()),null!==n.boundingBox&&(t.boundingBox=n.boundingBox.clone())}else e.isMesh&&(t=n.toBufferGeometry());return t}}r.prototype.isGeometry=!0;class o{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(e){const t=[];let n,r,o;const a=e.faces;for(r=0;r<a.length;r++){const e=a[r];e.materialIndex!==o&&(o=e.materialIndex,void 0!==n&&(n.count=3*r-n.start,t.push(n)),n={start:3*r,materialIndex:o})}void 0!==n&&(n.count=3*r-n.start,t.push(n)),this.groups=t}fromGeometry(e){const t=e.faces,n=e.vertices,r=e.faceVertexUvs,o=r[0]&&r[0].length>0,a=r[1]&&r[1].length>0,i=e.morphTargets,s=i.length;let l;if(s>0){l=[];for(let e=0;e<s;e++)l[e]={name:i[e].name,data:[]};this.morphTargets.position=l}const c=e.morphNormals,f=c.length;let u;if(f>0){u=[];for(let e=0;e<f;e++)u[e]={name:c[e].name,data:[]};this.morphTargets.normal=u}const d=e.skinIndices,p=e.skinWeights,h=d.length===n.length,v=p.length===n.length;n.length>0&&0===t.length&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let e=0;e<t.length;e++){const m=t[e];this.vertices.push(n[m.a],n[m.b],n[m.c]);const x=m.vertexNormals;if(3===x.length)this.normals.push(x[0],x[1],x[2]);else{const e=m.normal;this.normals.push(e,e,e)}const g=m.vertexColors;if(3===g.length)this.colors.push(g[0],g[1],g[2]);else{const e=m.color;this.colors.push(e,e,e)}if(!0===o){const t=r[0][e];void 0!==t?this.uvs.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",e),this.uvs.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}if(!0===a){const t=r[1][e];void 0!==t?this.uvs2.push(t[0],t[1],t[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",e),this.uvs2.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2))}for(let e=0;e<s;e++){const t=i[e].vertices;l[e].data.push(t[m.a],t[m.b],t[m.c])}for(let t=0;t<f;t++){const n=c[t].vertexNormals[e];u[t].data.push(n.a,n.b,n.c)}h&&this.skinIndices.push(d[m.a],d[m.b],d[m.c]),v&&this.skinWeights.push(p[m.a],p[m.b],p[m.c])}return this.computeGroups(e),this.verticesNeedUpdate=e.verticesNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,null!==e.boundingSphere&&(this.boundingSphere=e.boundingSphere.clone()),null!==e.boundingBox&&(this.boundingBox=e.boundingBox.clone()),this}}class a{constructor(e,t,n,r,o,a=0){this.a=e,this.b=t,this.c=n,this.normal=r&&r.isVector3?r:new THREE.Vector3,this.vertexNormals=Array.isArray(r)?r:[],this.color=o&&o.isColor?o:new THREE.Color,this.vertexColors=Array.isArray(o)?o:[],this.materialIndex=a}clone(){return(new this.constructor).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,n=e.vertexNormals.length;t<n;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,n=e.vertexColors.length;t<n;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}THREE.Face3=a,THREE.Geometry=r}()},1553:()=>{!function(){class e extends THREE.Pass{constructor(e=64){super(),void 0===THREE.DigitalGlitch&&console.error("THREE.GlitchPass relies on THREE.DigitalGlitch");const t=THREE.DigitalGlitch;this.uniforms=THREE.UniformsUtils.clone(t.uniforms),this.uniforms.tDisp.value=this.generateHeightmap(e),this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:t.vertexShader,fragmentShader:t.fragmentShader}),this.fsQuad=new THREE.FullScreenQuad(this.material),this.goWild=!1,this.curF=0,this.generateTrigger()}render(e,t,n){this.uniforms.tDiffuse.value=n.texture,this.uniforms.seed.value=Math.random(),this.uniforms.byp.value=0,this.curF%this.randX==0||1==this.goWild?(this.uniforms.amount.value=Math.random()/30,this.uniforms.angle.value=THREE.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.seed_x.value=THREE.MathUtils.randFloat(-1,1),this.uniforms.seed_y.value=THREE.MathUtils.randFloat(-1,1),this.uniforms.distortion_x.value=THREE.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=THREE.MathUtils.randFloat(0,1),this.curF=0,this.generateTrigger()):this.curF%this.randX<this.randX/5?(this.uniforms.amount.value=Math.random()/90,this.uniforms.angle.value=THREE.MathUtils.randFloat(-Math.PI,Math.PI),this.uniforms.distortion_x.value=THREE.MathUtils.randFloat(0,1),this.uniforms.distortion_y.value=THREE.MathUtils.randFloat(0,1),this.uniforms.seed_x.value=THREE.MathUtils.randFloat(-.3,.3),this.uniforms.seed_y.value=THREE.MathUtils.randFloat(-.3,.3)):0==this.goWild&&(this.uniforms.byp.value=1),this.curF++,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(),this.fsQuad.render(e))}generateTrigger(){this.randX=THREE.MathUtils.randInt(120,240)}generateHeightmap(e){const t=new Float32Array(e*e*3),n=e*e;for(let e=0;e<n;e++){const n=THREE.MathUtils.randFloat(0,1);t[3*e+0]=n,t[3*e+1]=n,t[3*e+2]=n}return new THREE.DataTexture(t,e,e,THREE.RGBFormat,THREE.FloatType)}}THREE.GlitchPass=e}()},801:()=>{!function(){const e={uniforms:{tInput:{value:null}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t vUv = uv;\n\t\t gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t }",fragmentShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tInput;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );\n\n\t\t}"},t={uniforms:{tInput:{value:null},fStepSize:{value:1},vSunPositionScreenSpace:{value:new THREE.Vector3}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t vUv = uv;\n\t\t gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t }",fragmentShader:'\n\n\t\t#define TAPS_PER_PASS 6.0\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tInput;\n\n\t\tuniform vec3 vSunPositionScreenSpace;\n\t\tuniform float fStepSize; // filter step size\n\n\t\tvoid main() {\n\n\t\t// delta from current pixel to "sun" position\n\n\t\t\tvec2 delta = vSunPositionScreenSpace.xy - vUv;\n\t\t\tfloat dist = length( delta );\n\n\t\t// Step vector (uv space)\n\n\t\t\tvec2 stepv = fStepSize * delta / dist;\n\n\t\t// Number of iterations between pixel and sun\n\n\t\t\tfloat iters = dist/fStepSize;\n\n\t\t\tvec2 uv = vUv.xy;\n\t\t\tfloat col = 0.0;\n\n\t\t// This breaks ANGLE in Chrome 22\n\t\t//\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n\t\t/*\n\t\t// Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\n\t\t// so i\'ve just left the loop\n\n\t\t"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {",\n\n\t\t// Accumulate samples, making sure we dont walk past the light source.\n\n\t\t// The check for uv.y < 1 would not be necessary with "border" UV wrap\n\t\t// mode, with a black border color. I don\'t think this is currently\n\t\t// exposed by three.js. As a result there might be artifacts when the\n\t\t// sun is to the left, right or bottom of screen as these cases are\n\t\t// not specifically handled.\n\n\t\t"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );",\n\t\t"\tuv += stepv;",\n\n\t\t"}",\n\t\t*/\n\n\t\t// Unrolling loop manually makes it work in ANGLE\n\n\t\t\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) ); // used to fade out godrays\n\n\t\t\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;\n\t\t\tuv += stepv;\n\n\t\t// Should technically be dividing by \'iters but \'TAPS_PER_PASS\' smooths out\n\t\t// objectionable artifacts, in particular near the sun position. The side\n\t\t// effect is that the result is darker than it should be around the sun, as\n\t\t// TAPS_PER_PASS is greater than the number of samples actually accumulated.\n\t\t// When the result is inverted (in the shader \'godrays_combine this produces\n\t\t// a slight bright spot at the position of the sun, even when it is occluded.\n\n\t\t\tgl_FragColor = vec4( col/TAPS_PER_PASS );\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}'},n={uniforms:{tColors:{value:null},tGodRays:{value:null},fGodRayIntensity:{value:.69}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform sampler2D tColors;\n\t\tuniform sampler2D tGodRays;\n\n\t\tuniform float fGodRayIntensity;\n\n\t\tvoid main() {\n\n\t\t// Since THREE.MeshDepthMaterial renders foreground objects white and background\n\t\t// objects black, the god-rays will be white streaks. Therefore value is inverted\n\t\t// before being combined with tColors\n\n\t\t\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );\n\t\t\tgl_FragColor.a = 1.0;\n\n\t\t}"},r={uniforms:{vSunPositionScreenSpace:{value:new THREE.Vector3},fAspect:{value:1},sunColor:{value:new THREE.Color(16772608)},bgColor:{value:new THREE.Color(0)}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tuniform vec3 vSunPositionScreenSpace;\n\t\tuniform float fAspect;\n\n\t\tuniform vec3 sunColor;\n\t\tuniform vec3 bgColor;\n\n\t\tvoid main() {\n\n\t\t\tvec2 diff = vUv - vSunPositionScreenSpace.xy;\n\n\t\t// Correct for aspect ratio\n\n\t\t\tdiff.x *= fAspect;\n\n\t\t\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );\n\t\t\tprop = 0.35 * pow( 1.0 - prop, 3.0 );\n\n\t\t\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;\n\t\t\tgl_FragColor.w = 1.0;\n\n\t\t}"};THREE.GodRaysCombineShader=n,THREE.GodRaysDepthMaskShader=e,THREE.GodRaysFakeSunShader=r,THREE.GodRaysGenerateShader=t}()},5847:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.hdrLoader=new THREE.RGBELoader,this.type=THREE.UnsignedByteType}load(e,t,n,r){Array.isArray(e)||(console.warn("THREE.HDRCubeTextureLoader signature has changed. Use .setDataType() instead."),this.setDataType(e),e=t,t=n,n=r,r=arguments[4]);const o=new THREE.CubeTexture;switch(o.type=this.type,o.type){case THREE.UnsignedByteType:o.encoding=THREE.RGBEEncoding,o.format=THREE.RGBAFormat,o.minFilter=THREE.NearestFilter,o.magFilter=THREE.NearestFilter,o.generateMipmaps=!1;break;case THREE.FloatType:case THREE.HalfFloatType:o.encoding=THREE.LinearEncoding,o.format=THREE.RGBFormat,o.minFilter=THREE.LinearFilter,o.magFilter=THREE.LinearFilter,o.generateMipmaps=!1}const a=this;let i=0;function s(t,n,r,s){new THREE.FileLoader(a.manager).setPath(a.path).setResponseType("arraybuffer").setWithCredentials(a.withCredentials).load(e[t],(function(e){i++;const r=a.hdrLoader.parse(e);if(r){if(void 0!==r.data){const e=new THREE.DataTexture(r.data,r.width,r.height);e.type=o.type,e.encoding=o.encoding,e.format=o.format,e.minFilter=o.minFilter,e.magFilter=o.magFilter,e.generateMipmaps=o.generateMipmaps,o.images[t]=e}6===i&&(o.needsUpdate=!0,n&&n(o))}}),r,s)}for(let o=0;o<e.length;o++)s(o,t,n,r);return o}setDataType(e){return this.type=e,this.hdrLoader.setDataType(e),this}}THREE.HDRCubeTextureLoader=e}()},1517:()=>{!function(){const e=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let t=0;t<256;t++)e[256+t]=e[t];function t(e){return e*e*e*(e*(6*e-15)+10)}function n(e,t,n){return t+e*(n-t)}function r(e,t,n,r){const o=15&e,a=o<8?t:n,i=o<4?n:12==o||14==o?t:r;return(0==(1&o)?a:-a)+(0==(2&o)?i:-i)}THREE.ImprovedNoise=class{noise(o,a,i){const s=Math.floor(o),l=Math.floor(a),c=Math.floor(i),f=255&s,u=255&l,d=255&c,p=(o-=s)-1,h=(a-=l)-1,v=(i-=c)-1,m=t(o),x=t(a),g=t(i),y=e[f]+u,E=e[y]+d,w=e[y+1]+d,b=e[f+1]+u,_=e[b]+d,T=e[b+1]+d;return n(g,n(x,n(m,r(e[E],o,a,i),r(e[_],p,a,i)),n(m,r(e[w],o,h,i),r(e[T],p,h,i))),n(x,n(m,r(e[E+1],o,a,v),r(e[_+1],p,a,v)),n(m,r(e[w+1],o,h,v),r(e[T+1],p,h,v))))}}}()},5151:(e,t,n)=>{"use strict";n.r(t);var r=n(743);!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t=new THREE.LoadingManager;t.setURLModifier((function(e){const t=function(e){for(const t in n)if(t.substr(-e.length)===e)return n[t]}(e);if(t){console.log("Loading",e);const n=new Blob([t.buffer],{type:"application/octet-stream"});return URL.createObjectURL(n)}return e}));const n=r.unzipSync(new Uint8Array(e));if(n["doc.kml"]){const e=(new DOMParser).parseFromString(r.strFromU8(n["doc.kml"]),"application/xml").querySelector("Placemark Model Link href");if(e){return new THREE.ColladaLoader(t).parse(r.strFromU8(n[e.textContent]))}}else{console.warn("KMZLoader: Missing doc.kml file.");for(const e in n){if("dae"===e.split(".").pop().toLowerCase()){return new THREE.ColladaLoader(t).parse(r.strFromU8(n[e]))}}}return console.error("KMZLoader: Couldn't find .dae file."),{scene:new THREE.Group}}}THREE.KMZLoader=e}()},2596:()=>{function e(){}var t,n,r,o;e.Handlers={handlers:[],add:function(e,t){this.handlers.push(e,t)},get:function(e){for(var t=this.handlers,n=0,r=t.length;n<r;n+=2){var o=t[n],a=t[n+1];if(o.test(e))return a}return null}},Object.assign(e.prototype,{crossOrigin:"anonymous",onLoadStart:function(){},onLoadProgress:function(){},onLoadComplete:function(){},initMaterials:function(e,t,n){for(var r=[],o=0;o<e.length;++o)r[o]=this.createMaterial(e[o],t,n);return r},createMaterial:(t={NoBlending:THREE.NoBlending,NormalBlending:THREE.NormalBlending,AdditiveBlending:THREE.AdditiveBlending,SubtractiveBlending:THREE.SubtractiveBlending,MultiplyBlending:THREE.MultiplyBlending,CustomBlending:THREE.CustomBlending},n=new THREE.Color,r=new THREE.TextureLoader,o=new THREE.MaterialLoader,function(a,i,s){var l={};function c(t,n,o,a,c){var f,u=i+t,d=e.Handlers.get(u);null!==d?f=d.load(u):(r.setCrossOrigin(s),f=r.load(u)),void 0!==n&&(f.repeat.fromArray(n),1!==n[0]&&(f.wrapS=THREE.RepeatWrapping),1!==n[1]&&(f.wrapT=THREE.RepeatWrapping)),void 0!==o&&f.offset.fromArray(o),void 0!==a&&("repeat"===a[0]&&(f.wrapS=THREE.RepeatWrapping),"mirror"===a[0]&&(f.wrapS=THREE.MirroredRepeatWrapping),"repeat"===a[1]&&(f.wrapT=THREE.RepeatWrapping),"mirror"===a[1]&&(f.wrapT=THREE.MirroredRepeatWrapping)),void 0!==c&&(f.anisotropy=c);var p=THREE.MathUtils.generateUUID();return l[p]=f,p}var f={uuid:THREE.MathUtils.generateUUID(),type:"MeshLambertMaterial"};for(var u in a){var d=a[u];switch(u){case"DbgColor":case"DbgIndex":case"opticalDensity":case"illumination":break;case"DbgName":f.name=d;break;case"blending":f.blending=t[d];break;case"colorAmbient":case"mapAmbient":console.warn("THREE_Loader.createMaterial:",u,"is no longer supported.");break;case"colorDiffuse":f.color=n.fromArray(d).getHex();break;case"colorSpecular":f.specular=n.fromArray(d).getHex();break;case"colorEmissive":f.emissive=n.fromArray(d).getHex();break;case"specularCoef":f.shininess=d;break;case"shading":"basic"===d.toLowerCase()&&(f.type="MeshBasicMaterial"),"phong"===d.toLowerCase()&&(f.type="MeshPhongMaterial"),"standard"===d.toLowerCase()&&(f.type="MeshStandardMaterial");break;case"mapDiffuse":f.map=c(d,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);break;case"mapDiffuseRepeat":case"mapDiffuseOffset":case"mapDiffuseWrap":case"mapDiffuseAnisotropy":break;case"mapEmissive":f.emissiveMap=c(d,a.mapEmissiveRepeat,a.mapEmissiveOffset,a.mapEmissiveWrap,a.mapEmissiveAnisotropy);break;case"mapEmissiveRepeat":case"mapEmissiveOffset":case"mapEmissiveWrap":case"mapEmissiveAnisotropy":break;case"mapLight":f.lightMap=c(d,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);break;case"mapLightRepeat":case"mapLightOffset":case"mapLightWrap":case"mapLightAnisotropy":break;case"mapAO":f.aoMap=c(d,a.mapAORepeat,a.mapAOOffset,a.mapAOWrap,a.mapAOAnisotropy);break;case"mapAORepeat":case"mapAOOffset":case"mapAOWrap":case"mapAOAnisotropy":break;case"mapBump":f.bumpMap=c(d,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);break;case"mapBumpScale":f.bumpScale=d;break;case"mapBumpRepeat":case"mapBumpOffset":case"mapBumpWrap":case"mapBumpAnisotropy":break;case"mapNormal":f.normalMap=c(d,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);break;case"mapNormalFactor":f.normalScale=d;break;case"mapNormalRepeat":case"mapNormalOffset":case"mapNormalWrap":case"mapNormalAnisotropy":break;case"mapSpecular":f.specularMap=c(d,a.mapSpecularRepeat,a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);break;case"mapSpecularRepeat":case"mapSpecularOffset":case"mapSpecularWrap":case"mapSpecularAnisotropy":break;case"mapMetalness":f.metalnessMap=c(d,a.mapMetalnessRepeat,a.mapMetalnessOffset,a.mapMetalnessWrap,a.mapMetalnessAnisotropy);break;case"mapMetalnessRepeat":case"mapMetalnessOffset":case"mapMetalnessWrap":case"mapMetalnessAnisotropy":break;case"mapRoughness":f.roughnessMap=c(d,a.mapRoughnessRepeat,a.mapRoughnessOffset,a.mapRoughnessWrap,a.mapRoughnessAnisotropy);break;case"mapRoughnessRepeat":case"mapRoughnessOffset":case"mapRoughnessWrap":case"mapRoughnessAnisotropy":break;case"mapAlpha":f.alphaMap=c(d,a.mapAlphaRepeat,a.mapAlphaOffset,a.mapAlphaWrap,a.mapAlphaAnisotropy);break;case"mapAlphaRepeat":case"mapAlphaOffset":case"mapAlphaWrap":case"mapAlphaAnisotropy":break;case"flipSided":f.side=THREE.BackSide;break;case"doubleSided":f.side=THREE.DoubleSide;break;case"transparency":console.warn("THREE_Loader.createMaterial: transparency has been renamed to opacity"),f.opacity=d;break;case"depthTest":case"depthWrite":case"colorWrite":case"opacity":case"reflectivity":case"transparent":case"visible":case"wireframe":f[u]=d;break;case"vertexColors":!0===d&&(f.vertexColors=THREE.VertexColors),"face"===d&&(f.vertexColors=THREE.FaceColors);break;default:console.error("THREE_Loader.createMaterial: Unsupported",u,d)}}return"MeshBasicMaterial"===f.type&&delete f.emissive,"MeshPhongMaterial"!==f.type&&delete f.specular,f.opacity<1&&(f.transparent=!0),o.setTextures(l),o.parse(f)})}),THREE.LegacyJSONLoader=function(){function t(e){"boolean"==typeof e&&(console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),e=void 0),this.manager=void 0!==e?e:THREE.DefaultLoadingManager,this.withCredentials=!1}return Object.assign(t.prototype,{crossOrigin:"anonymous",load:function(e,t,n,r){var o=this,a=void 0===this.path?THREE.LoaderUtils.extractUrlBase(e):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){var r=JSON.parse(n),i=r.metadata;if(void 0!==i){var s=i.type;if(void 0!==s&&"object"===s.toLowerCase())return void console.error("THREE.JSONLoader: "+e+" should be loaded with THREE.ObjectLoader instead.")}var l=o.parse(r,a);t(l.geometry,l.materials)}),n,r)},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setCrossOrigin:function(e){return this.crossOrigin=e,this},parse:function(t,n){void 0!==t.data&&(t=t.data),void 0!==t.scale?t.scale=1/t.scale:t.scale=1;var r=new THREE.Geometry;return function(e,t){function n(e,t){return e&1<<t}var r,o,a,i,s,l,c,f,u,d,p,h,v,m,x,g,y,E,w,b,_,T,A,S,R,M,C,L=e.faces,P=e.vertices,k=e.normals,N=e.colors,H=e.scale,z=0;if(void 0!==e.uvs){for(r=0;r<e.uvs.length;r++)e.uvs[r].length&&z++;for(r=0;r<z;r++)t.faceVertexUvs[r]=[]}for(i=0,s=P.length;i<s;)(E=new THREE.Vector3).x=P[i++]*H,E.y=P[i++]*H,E.z=P[i++]*H,t.vertices.push(E);for(i=0,s=L.length;i<s;)if(p=n(d=L[i++],0),h=n(d,1),v=n(d,3),m=n(d,4),x=n(d,5),g=n(d,6),y=n(d,7),p){if((b=new THREE.Face3).a=L[i],b.b=L[i+1],b.c=L[i+3],(_=new THREE.Face3).a=L[i+1],_.b=L[i+2],_.c=L[i+3],i+=4,h&&(u=L[i++],b.materialIndex=u,_.materialIndex=u),a=t.faces.length,v)for(r=0;r<z;r++)for(S=e.uvs[r],t.faceVertexUvs[r][a]=[],t.faceVertexUvs[r][a+1]=[],o=0;o<4;o++)M=S[2*(f=L[i++])],C=S[2*f+1],R=new THREE.Vector2(M,C),2!==o&&t.faceVertexUvs[r][a].push(R),0!==o&&t.faceVertexUvs[r][a+1].push(R);if(m&&(c=3*L[i++],b.normal.set(k[c++],k[c++],k[c]),_.normal.copy(b.normal)),x)for(r=0;r<4;r++)c=3*L[i++],A=new THREE.Vector3(k[c++],k[c++],k[c]),2!==r&&b.vertexNormals.push(A),0!==r&&_.vertexNormals.push(A);if(g&&(T=N[l=L[i++]],b.color.setHex(T),_.color.setHex(T)),y)for(r=0;r<4;r++)T=N[l=L[i++]],2!==r&&b.vertexColors.push(new THREE.Color(T)),0!==r&&_.vertexColors.push(new THREE.Color(T));t.faces.push(b),t.faces.push(_)}else{if((w=new THREE.Face3).a=L[i++],w.b=L[i++],w.c=L[i++],h&&(u=L[i++],w.materialIndex=u),a=t.faces.length,v)for(r=0;r<z;r++)for(S=e.uvs[r],t.faceVertexUvs[r][a]=[],o=0;o<3;o++)M=S[2*(f=L[i++])],C=S[2*f+1],R=new THREE.Vector2(M,C),t.faceVertexUvs[r][a].push(R);if(m&&(c=3*L[i++],w.normal.set(k[c++],k[c++],k[c])),x)for(r=0;r<3;r++)c=3*L[i++],A=new THREE.Vector3(k[c++],k[c++],k[c]),w.vertexNormals.push(A);if(g&&(l=L[i++],w.color.setHex(N[l])),y)for(r=0;r<3;r++)l=L[i++],w.vertexColors.push(new THREE.Color(N[l]));t.faces.push(w)}}(t,r),function(e,t){var n=void 0!==e.influencesPerVertex?e.influencesPerVertex:2;if(e.skinWeights)for(var r=0,o=e.skinWeights.length;r<o;r+=n){var a=e.skinWeights[r],i=n>1?e.skinWeights[r+1]:0,s=n>2?e.skinWeights[r+2]:0,l=n>3?e.skinWeights[r+3]:0;t.skinWeights.push(new THREE.Vector4(a,i,s,l))}if(e.skinIndices)for(r=0,o=e.skinIndices.length;r<o;r+=n){var c=e.skinIndices[r],f=n>1?e.skinIndices[r+1]:0,u=n>2?e.skinIndices[r+2]:0,d=n>3?e.skinIndices[r+3]:0;t.skinIndices.push(new THREE.Vector4(c,f,u,d))}t.bones=e.bones,t.bones&&t.bones.length>0&&(t.skinWeights.length!==t.skinIndices.length||t.skinIndices.length!==t.vertices.length)&&console.warn("When skinning, number of vertices ("+t.vertices.length+"), skinIndices ("+t.skinIndices.length+"), and skinWeights ("+t.skinWeights.length+") should match.")}(t,r),function(e,t){var n=e.scale;if(void 0!==e.morphTargets)for(var r=0,o=e.morphTargets.length;r<o;r++){t.morphTargets[r]={},t.morphTargets[r].name=e.morphTargets[r].name,t.morphTargets[r].vertices=[];for(var a=t.morphTargets[r].vertices,i=e.morphTargets[r].vertices,s=0,l=i.length;s<l;s+=3){var c=new THREE.Vector3;c.x=i[s]*n,c.y=i[s+1]*n,c.z=i[s+2]*n,a.push(c)}}if(void 0!==e.morphColors&&e.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var f=t.faces,u=e.morphColors[0].colors;for(r=0,o=f.length;r<o;r++)f[r].color.fromArray(u,3*r)}}(t,r),function(e,t){var n=[],r=[];void 0!==e.animation&&r.push(e.animation),void 0!==e.animations&&(e.animations.length?r=r.concat(e.animations):r.push(e.animations));for(var o=0;o<r.length;o++){var a=THREE.AnimationClip.parseAnimation(r[o],t.bones);a&&n.push(a)}if(t.morphTargets){var i=THREE.AnimationClip.CreateClipsFromMorphTargetSequences(t.morphTargets,10);n=n.concat(i)}n.length>0&&(t.animations=n)}(t,r),r.computeFaceNormals(),r.computeBoundingSphere(),void 0===t.materials||0===t.materials.length?{geometry:r}:{geometry:r,materials:e.prototype.initMaterials(t.materials,this.resourcePath||n,this.crossOrigin)}}}),t}()},7542:()=>{class e extends THREE.Group{constructor(){super(),this.type="LensFlare",this.positionScreen=new THREE.Vector3,this.flareVisible=!1;var e=new THREE.DataTexture(new Uint8Array(768),16,16,THREE.RGBFormat);e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.needsUpdate=!0;var t=new THREE.DataTexture(new Uint8Array(1024),16,16,THREE.RGBAFormat);t.minFilter=THREE.NearestFilter,t.magFilter=THREE.NearestFilter,t.needsUpdate=!0;var n=THREE.LensFlare.Shader,r=new THREE.RawShaderMaterial({uniforms:n.uniforms,vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,depthWrite:!1}),o=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),r);o.frustumCulled=!1;var a=new THREE.Vector2,i=new THREE.Vector2,s=new THREE.Box2,l=0;this.update=function(n,r,f){if(n instanceof THREE.WebGLRenderer){var u=n.info.render.frame;if(l!==u){l=u;var d=f.w/f.z,p=.5*f.z,h=.5*f.w,v=16/f.w;a.set(v*d,v),s.min.set(f.x,f.y),s.max.set(f.x+(f.z-16),f.y+(f.w-16)),this.positionScreen.setFromMatrixPosition(this.matrixWorld),this.positionScreen.applyMatrix4(r.matrixWorldInverse),this.positionScreen.applyMatrix4(r.projectionMatrix),i.x=f.x+this.positionScreen.x*p+p-8,i.y=f.y+this.positionScreen.y*h+h-8,!0===s.containsPoint(i)?(this.flareVisible=!0,n.copyFramebufferToTexture(i,e),o.material.uniforms.renderType.value=0,o.material.uniforms.scale.value=a,o.material.uniforms.screenPosition.value=this.positionScreen,o.material.depthTest=!0,n.render(o,r),n.copyFramebufferToTexture(i,t),o.material.uniforms.renderType.value=1,o.material.uniforms.map.value=e,o.material.depthTest=!1,n.render(o,r),function(){for(var e=2*-c.positionScreen.x,t=2*-c.positionScreen.y,n=0,r=c.children.length;n<r;n++){var o=c.children[n];o.flarePosition.x=c.positionScreen.x+e*o.flareDistance,o.flarePosition.y=c.positionScreen.y+t*o.flareDistance}}()):this.flareVisible=!1}}};var c=this;this.getOcclusionMap=function(){return t},this.dispose=function(){o.material.dispose(),e.dispose(),t.dispose()}}}e.prototype.isLensFlare=!0,THREE.LensFlare=e,THREE.LensFlare.Shader={uniforms:{renderType:{value:0},map:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:["precision highp float;","uniform vec3 screenPosition;","uniform vec2 scale;","attribute vec3 position;","attribute vec2 uv;","varying vec2 vUV;","void main() {","\tvUV = uv;","\tvec2 pos = position.xy;","\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["precision highp float;","uniform lowp int renderType;","uniform sampler2D map;","varying vec2 vUV;","void main() {","\tif ( renderType == 0 ) {","\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );","\t} else {","\t\tgl_FragColor = texture2D( map, vUV );","\t}","}"].join("\n")};class t extends THREE.Mesh{constructor(e,t,n,r,o,a){super(),this.type="LensFlareElement",this.frustumCulled=!1,this.renderOrder=1/0,this.flareTexture=e,this.flareSize=t||1,this.flareDistance=n||0,this.flareBlending=o||THREE.AdditiveBlending,this.flareColor=r||new THREE.Color(16777215),this.flareOpacity=a||1,this.flarePosition=new THREE.Vector3,this.flareRotation=0,this.geometry=new THREE.PlaneBufferGeometry(2,2);var i=THREE.LensFlareElement.Shader;this.material=new THREE.RawShaderMaterial({uniforms:i.uniforms,vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,blending:this.flareBlending,transparent:!0,depthWrite:!1});var s=new THREE.Vector2,l=new THREE.Vector4;this.onBeforeRender=function(e,t,n,r,o,a){var i=this.parent;if(null!==i){e.getCurrentViewport(l),i.update(e,n,l);var c=this.flareSize/l.w,f=l.w/l.z;s.set(c*f,c),this.material.uniforms.map.value=this.flareTexture,this.material.uniforms.occlusionMap.value=i.getOcclusionMap(),this.material.uniforms.opacity.value=this.flareOpacity,this.material.uniforms.color.value=this.flareColor,this.material.uniforms.scale.value=s,this.material.uniforms.rotation.value=this.flareRotation,this.material.uniforms.screenPosition.value=this.flarePosition,!1===i.flareVisible&&(this.material.uniforms.opacity.value=0)}else console.error("THREE.LensFlareElement: LensFlareElement not assigned to a LensFlare. Rendering not possible.")},this.dispose=function(){this.material.dispose()}}}t.prototype.isLensFlareElement=!0,THREE.LensFlareElement=t,THREE.LensFlareElement.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},opacity:{value:1},color:{value:null},scale:{value:null},rotation:{value:0},screenPosition:{value:null}},vertexShader:["precision highp float;","uniform vec3 screenPosition;","uniform vec2 scale;","uniform float rotation;","uniform sampler2D occlusionMap;","attribute vec3 position;","attribute vec2 uv;","varying vec2 vUV;","varying float vVisibility;","void main() {","\tvUV = uv;","\tvec2 pos = position.xy;","\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );"," visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );","\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );","\tvVisibility =        visibility.r / 9.0;","\tvVisibility *= 1.0 - visibility.g / 9.0;","\tvVisibility *=       visibility.b / 9.0;","\tvVisibility *= 1.0 - visibility.a / 9.0;","\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;","\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;","\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );","}"].join("\n"),fragmentShader:["precision highp float;","uniform sampler2D map;","uniform float opacity;","uniform vec3 color;","varying vec2 vUV;","varying float vVisibility;","void main() {","\tvec4 texture = texture2D( map, vUV );","\ttexture.a *= opacity * vVisibility;","\tgl_FragColor = texture;","\tgl_FragColor.rgb *= color;","}"].join("\n")}},6707:()=>{!function(){const e={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new THREE.Color(0)},defaultOpacity:{value:0}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}"};THREE.LuminosityHighPassShader=e}()},4559:()=>{!function(){class e{constructor(e,t){this.lut=[],this.setColorMap(e,t)}set(t){return t instanceof e&&this.copy(t),this}setMin(e){return this.minV=e,this}setMax(e){return this.maxV=e,this}setColorMap(e,n=32){this.map=t[e]||t.rainbow,this.n=n;const r=1/this.n;this.lut.length=0;for(let e=0;e<=1;e+=r)for(let t=0;t<this.map.length-1;t++)if(e>=this.map[t][0]&&e<this.map[t+1][0]){const n=this.map[t][0],r=this.map[t+1][0],o=new THREE.Color(this.map[t][1]),a=new THREE.Color(this.map[t+1][1]),i=o.lerp(a,(e-n)/(r-n));this.lut.push(i)}return this}copy(e){return this.lut=e.lut,this.map=e.map,this.n=e.n,this.minV=e.minV,this.maxV=e.maxV,this}getColor(e){e<=this.minV?e=this.minV:e>=this.maxV&&(e=this.maxV),e=(e-this.minV)/(this.maxV-this.minV);let t=Math.round(e*this.n);return t==this.n&&(t-=1),this.lut[t]}addColorMap(e,n){t[e]=n}createCanvas(){const e=document.createElement("canvas");return e.width=1,e.height=this.n,this.updateCanvas(e),e}updateCanvas(e){const t=e.getContext("2d",{alpha:!1}),n=t.getImageData(0,0,1,this.n),r=n.data;let o=0;const a=1/this.n;for(let e=1;e>=0;e-=a)for(let t=this.map.length-1;t>=0;t--)if(e<this.map[t][0]&&e>=this.map[t-1][0]){const n=this.map[t-1][0],a=this.map[t][0],i=new THREE.Color(this.map[t-1][1]),s=new THREE.Color(this.map[t][1]),l=i.lerp(s,(e-n)/(a-n));r[4*o]=Math.round(255*l.r),r[4*o+1]=Math.round(255*l.g),r[4*o+2]=Math.round(255*l.b),r[4*o+3]=255,o+=1}return t.putImageData(n,0,0),e}}e.prototype.lut=[],e.prototype.map=[],e.prototype.n=256,e.prototype.minV=0,e.prototype.maxV=1;const t={rainbow:[[0,255],[.2,65535],[.5,65280],[.8,16776960],[1,16711680]],cooltowarm:[[0,3952322],[.2,10206463],[.5,14474460],[.8,16163717],[1,11797542]],blackbody:[[0,0],[.2,7864320],[.5,15086080],[.8,16776960],[1,16777215]],grayscale:[[0,0],[.2,4210752],[.5,8355712],[.8,12566463],[1,16777215]]};THREE.ColorMapKeywords=t,THREE.Lut=e}()},7862:()=>{!function(){const e=[[-.525731,0,.850651],[-.442863,.238856,.864188],[-.295242,0,.955423],[-.309017,.5,.809017],[-.16246,.262866,.951056],[0,0,1],[0,.850651,.525731],[-.147621,.716567,.681718],[.147621,.716567,.681718],[0,.525731,.850651],[.309017,.5,.809017],[.525731,0,.850651],[.295242,0,.955423],[.442863,.238856,.864188],[.16246,.262866,.951056],[-.681718,.147621,.716567],[-.809017,.309017,.5],[-.587785,.425325,.688191],[-.850651,.525731,0],[-.864188,.442863,.238856],[-.716567,.681718,.147621],[-.688191,.587785,.425325],[-.5,.809017,.309017],[-.238856,.864188,.442863],[-.425325,.688191,.587785],[-.716567,.681718,-.147621],[-.5,.809017,-.309017],[-.525731,.850651,0],[0,.850651,-.525731],[-.238856,.864188,-.442863],[0,.955423,-.295242],[-.262866,.951056,-.16246],[0,1,0],[0,.955423,.295242],[-.262866,.951056,.16246],[.238856,.864188,.442863],[.262866,.951056,.16246],[.5,.809017,.309017],[.238856,.864188,-.442863],[.262866,.951056,-.16246],[.5,.809017,-.309017],[.850651,.525731,0],[.716567,.681718,.147621],[.716567,.681718,-.147621],[.525731,.850651,0],[.425325,.688191,.587785],[.864188,.442863,.238856],[.688191,.587785,.425325],[.809017,.309017,.5],[.681718,.147621,.716567],[.587785,.425325,.688191],[.955423,.295242,0],[1,0,0],[.951056,.16246,.262866],[.850651,-.525731,0],[.955423,-.295242,0],[.864188,-.442863,.238856],[.951056,-.16246,.262866],[.809017,-.309017,.5],[.681718,-.147621,.716567],[.850651,0,.525731],[.864188,.442863,-.238856],[.809017,.309017,-.5],[.951056,.16246,-.262866],[.525731,0,-.850651],[.681718,.147621,-.716567],[.681718,-.147621,-.716567],[.850651,0,-.525731],[.809017,-.309017,-.5],[.864188,-.442863,-.238856],[.951056,-.16246,-.262866],[.147621,.716567,-.681718],[.309017,.5,-.809017],[.425325,.688191,-.587785],[.442863,.238856,-.864188],[.587785,.425325,-.688191],[.688191,.587785,-.425325],[-.147621,.716567,-.681718],[-.309017,.5,-.809017],[0,.525731,-.850651],[-.525731,0,-.850651],[-.442863,.238856,-.864188],[-.295242,0,-.955423],[-.16246,.262866,-.951056],[0,0,-1],[.295242,0,-.955423],[.16246,.262866,-.951056],[-.442863,-.238856,-.864188],[-.309017,-.5,-.809017],[-.16246,-.262866,-.951056],[0,-.850651,-.525731],[-.147621,-.716567,-.681718],[.147621,-.716567,-.681718],[0,-.525731,-.850651],[.309017,-.5,-.809017],[.442863,-.238856,-.864188],[.16246,-.262866,-.951056],[.238856,-.864188,-.442863],[.5,-.809017,-.309017],[.425325,-.688191,-.587785],[.716567,-.681718,-.147621],[.688191,-.587785,-.425325],[.587785,-.425325,-.688191],[0,-.955423,-.295242],[0,-1,0],[.262866,-.951056,-.16246],[0,-.850651,.525731],[0,-.955423,.295242],[.238856,-.864188,.442863],[.262866,-.951056,.16246],[.5,-.809017,.309017],[.716567,-.681718,.147621],[.525731,-.850651,0],[-.238856,-.864188,-.442863],[-.5,-.809017,-.309017],[-.262866,-.951056,-.16246],[-.850651,-.525731,0],[-.716567,-.681718,-.147621],[-.716567,-.681718,.147621],[-.525731,-.850651,0],[-.5,-.809017,.309017],[-.238856,-.864188,.442863],[-.262866,-.951056,.16246],[-.864188,-.442863,.238856],[-.809017,-.309017,.5],[-.688191,-.587785,.425325],[-.681718,-.147621,.716567],[-.442863,-.238856,.864188],[-.587785,-.425325,.688191],[-.309017,-.5,.809017],[-.147621,-.716567,.681718],[-.425325,-.688191,.587785],[-.16246,-.262866,.951056],[.442863,-.238856,.864188],[.16246,-.262866,.951056],[.309017,-.5,.809017],[.147621,-.716567,.681718],[0,-.525731,.850651],[.425325,-.688191,.587785],[.587785,-.425325,.688191],[.688191,-.587785,.425325],[-.955423,.295242,0],[-.951056,.16246,.262866],[-1,0,0],[-.850651,0,.525731],[-.955423,-.295242,0],[-.951056,-.16246,.262866],[-.864188,.442863,-.238856],[-.951056,.16246,-.262866],[-.809017,.309017,-.5],[-.864188,-.442863,-.238856],[-.951056,-.16246,-.262866],[-.809017,-.309017,-.5],[-.681718,.147621,-.716567],[-.681718,-.147621,-.716567],[-.850651,0,-.525731],[-.688191,.587785,-.425325],[-.587785,.425325,-.688191],[-.425325,.688191,-.587785],[-.425325,-.688191,-.587785],[-.587785,-.425325,-.688191],[-.688191,-.587785,-.425325]];class t extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(t){const n=new DataView(t),r={},o=["ident","version","skinwidth","skinheight","framesize","num_skins","num_vertices","num_st","num_tris","num_glcmds","num_frames","offset_skins","offset_st","offset_tris","offset_frames","offset_glcmds","offset_end"];for(let e=0;e<o.length;e++)r[o[e]]=n.getInt32(4*e,!0);if(844121161!==r.ident||8!==r.version)return void console.error("Not a valid MD2 file");if(r.offset_end!==n.byteLength)return void console.error("Corrupted MD2 file");const a=new THREE.BufferGeometry,i=[];let s=r.offset_st;for(let e=0,t=r.num_st;e<t;e++){const e=n.getInt16(s+0,!0),t=n.getInt16(s+2,!0);i.push(e/r.skinwidth,1-t/r.skinheight),s+=4}s=r.offset_tris;const l=[],c=[];for(let e=0,t=r.num_tris;e<t;e++)l.push(n.getUint16(s+0,!0),n.getUint16(s+2,!0),n.getUint16(s+4,!0)),c.push(n.getUint16(s+6,!0),n.getUint16(s+8,!0),n.getUint16(s+10,!0)),s+=12;const f=new THREE.Vector3,u=new THREE.Vector3,d=[],p=[];s=r.offset_frames;for(let t=0,o=r.num_frames;t<o;t++){u.set(n.getFloat32(s+0,!0),n.getFloat32(s+4,!0),n.getFloat32(s+8,!0)),f.set(n.getFloat32(s+12,!0),n.getFloat32(s+16,!0),n.getFloat32(s+20,!0)),s+=24;for(let e=0;e<16;e++){const t=n.getUint8(s+e,!0);if(0===t)break;d[e]=t}const t={name:String.fromCharCode.apply(null,d),vertices:[],normals:[]};s+=16;for(let o=0;o<r.num_vertices;o++){let r=n.getUint8(s++,!0),o=n.getUint8(s++,!0),a=n.getUint8(s++,!0);const i=e[n.getUint8(s++,!0)];r=r*u.x+f.x,o=o*u.y+f.y,a=a*u.z+f.z,t.vertices.push(r,a,o),t.normals.push(i[0],i[2],i[1])}p.push(t)}const h=[],v=[],m=[],x=p[0].vertices,g=p[0].normals;for(let e=0,t=l.length;e<t;e++){let t=3*l[e];const n=x[t],r=x[t+1],o=x[t+2];h.push(n,r,o);const a=g[t],s=g[t+1],f=g[t+2];v.push(a,s,f);t=2*c[e];const u=i[t],d=i[t+1];m.push(u,d)}a.setAttribute("position",new THREE.Float32BufferAttribute(h,3)),a.setAttribute("normal",new THREE.Float32BufferAttribute(v,3)),a.setAttribute("uv",new THREE.Float32BufferAttribute(m,2));const y=[],E=[];for(let e=0,t=p.length;e<t;e++){const t=p[e],n=t.name;if(t.vertices.length>0){const e=[];for(let n=0,r=l.length;n<r;n++){const r=3*l[n],o=t.vertices[r],a=t.vertices[r+1],i=t.vertices[r+2];e.push(o,a,i)}const r=new THREE.Float32BufferAttribute(e,3);r.name=n,y.push(r)}if(t.normals.length>0){const e=[];for(let n=0,r=l.length;n<r;n++){const r=3*l[n],o=t.normals[r],a=t.normals[r+1],i=t.normals[r+2];e.push(o,a,i)}const r=new THREE.Float32BufferAttribute(e,3);r.name=n,E.push(r)}}return a.morphAttributes.position=y,a.morphAttributes.normal=E,a.morphTargetsRelative=!1,a.animations=THREE.AnimationClip.CreateClipsFromMorphTargetSequences(p,10),a}}THREE.MD2Loader=t}()},1617:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=""===this.path?THREE.LoaderUtils.extractUrlBase(e):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){try{t(o.parse(n,a))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}setMaterialOptions(e){return this.materialOptions=e,this}parse(e,n){const r=e.split("\n");let o={};const a=/\s+/,i={};for(let e=0;e<r.length;e++){let t=r[e];if(t=t.trim(),0===t.length||"#"===t.charAt(0))continue;const n=t.indexOf(" ");let s=n>=0?t.substring(0,n):t;s=s.toLowerCase();let l=n>=0?t.substring(n+1):"";if(l=l.trim(),"newmtl"===s)o={name:l},i[l]=o;else if("ka"===s||"kd"===s||"ks"===s||"ke"===s){const e=l.split(a,3);o[s]=[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]}else o[s]=l}const s=new t(this.resourcePath||n,this.materialOptions);return s.setCrossOrigin(this.crossOrigin),s.setManager(this.manager),s.setMaterials(i),s}}class t{constructor(e="",t={}){this.baseUrl=e,this.options=t,this.materialsInfo={},this.materials={},this.materialsArray=[],this.nameLookup={},this.crossOrigin="anonymous",this.side=void 0!==this.options.side?this.options.side:THREE.FrontSide,this.wrap=void 0!==this.options.wrap?this.options.wrap:THREE.RepeatWrapping}setCrossOrigin(e){return this.crossOrigin=e,this}setManager(e){this.manager=e}setMaterials(e){this.materialsInfo=this.convert(e),this.materials={},this.materialsArray=[],this.nameLookup={}}convert(e){if(!this.options)return e;const t={};for(const n in e){const r=e[n],o={};t[n]=o;for(const e in r){let t=!0,n=r[e];const a=e.toLowerCase();switch(a){case"kd":case"ka":case"ks":this.options&&this.options.normalizeRGB&&(n=[n[0]/255,n[1]/255,n[2]/255]),this.options&&this.options.ignoreZeroRGBs&&0===n[0]&&0===n[1]&&0===n[2]&&(t=!1)}t&&(o[a]=n)}}return t}preload(){for(const e in this.materialsInfo)this.create(e)}getIndex(e){return this.nameLookup[e]}getAsArray(){let e=0;for(const t in this.materialsInfo)this.materialsArray[e]=this.create(t),this.nameLookup[t]=e,e++;return this.materialsArray}create(e){return void 0===this.materials[e]&&this.createMaterial_(e),this.materials[e]}createMaterial_(e){const t=this,n=this.materialsInfo[e],r={name:e,side:this.side};function o(e,n){if(r[e])return;const o=t.getTextureParams(n,r),a=t.loadTexture((i=t.baseUrl,"string"!=typeof(s=o.url)||""===s?"":/^https?:\/\//i.test(s)?s:i+s));var i,s;a.repeat.copy(o.scale),a.offset.copy(o.offset),a.wrapS=t.wrap,a.wrapT=t.wrap,r[e]=a}for(const e in n){const t=n[e];let a;if(""!==t)switch(e.toLowerCase()){case"kd":r.color=(new THREE.Color).fromArray(t);break;case"ks":r.specular=(new THREE.Color).fromArray(t);break;case"ke":r.emissive=(new THREE.Color).fromArray(t);break;case"map_kd":o("map",t);break;case"map_ks":o("specularMap",t);break;case"map_ke":o("emissiveMap",t);break;case"norm":o("normalMap",t);break;case"map_bump":case"bump":o("bumpMap",t);break;case"map_d":o("alphaMap",t),r.transparent=!0;break;case"ns":r.shininess=parseFloat(t);break;case"d":a=parseFloat(t),a<1&&(r.opacity=a,r.transparent=!0);break;case"tr":a=parseFloat(t),this.options&&this.options.invertTrProperty&&(a=1-a),a>0&&(r.opacity=1-a,r.transparent=!0)}}return this.materials[e]=new THREE.MeshPhongMaterial(r),this.materials[e]}getTextureParams(e,t){const n={scale:new THREE.Vector2(1,1),offset:new THREE.Vector2(0,0)},r=e.split(/\s+/);let o;return o=r.indexOf("-bm"),o>=0&&(t.bumpScale=parseFloat(r[o+1]),r.splice(o,2)),o=r.indexOf("-s"),o>=0&&(n.scale.set(parseFloat(r[o+1]),parseFloat(r[o+2])),r.splice(o,4)),o=r.indexOf("-o"),o>=0&&(n.offset.set(parseFloat(r[o+1]),parseFloat(r[o+2])),r.splice(o,4)),n.url=r.join(" ").trim(),n}loadTexture(e,t,n,r,o){const a=void 0!==this.manager?this.manager:THREE.DefaultLoadingManager;let i=a.getHandler(e);null===i&&(i=new THREE.TextureLoader(a)),i.setCrossOrigin&&i.setCrossOrigin(this.crossOrigin);const s=i.load(e,n,r,o);return void 0!==t&&(s.mapping=t),s}}THREE.MTLLoader=e}()},3230:()=>{!function(){class e extends THREE.Pass{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,n){const r=e.getContext(),o=e.state;let a,i;o.buffers.color.setMask(!1),o.buffers.depth.setMask(!1),o.buffers.color.setLocked(!0),o.buffers.depth.setLocked(!0),this.inverse?(a=0,i=1):(a=1,i=0),o.buffers.stencil.setTest(!0),o.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),o.buffers.stencil.setFunc(r.ALWAYS,a,4294967295),o.buffers.stencil.setClear(i),o.buffers.stencil.setLocked(!0),e.setRenderTarget(n),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),o.buffers.color.setLocked(!1),o.buffers.depth.setLocked(!1),o.buffers.stencil.setLocked(!1),o.buffers.stencil.setFunc(r.EQUAL,1,4294967295),o.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),o.buffers.stencil.setLocked(!0)}}class t extends THREE.Pass{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}THREE.ClearMaskPass=t,THREE.MaskPass=e}()},7684:()=>{class e extends THREE.Object3D{constructor(e,t,n,r){function o(e,t){return void 0!==e?e:t}super(),this.name="mirror_"+this.id,r=r||{},this.matrixNeedsUpdate=!0;var a=o(r.textureWidth,512),i=o(r.textureHeight,512);this.clipBias=o(r.clipBias,0),this.renderer=e,this.scene=n,this.mirrorPlane=new THREE.Plane,this.normal=new THREE.Vector3(0,0,1),this.cameraWorldPosition=new THREE.Vector3,this.rotationMatrix=new THREE.Matrix4,this.lookAtPosition=new THREE.Vector3(0,0,-1),this.clipPlane=new THREE.Vector4,t instanceof THREE.PerspectiveCamera?this.camera=t:(this.camera=new THREE.PerspectiveCamera,console.log(this.name+": camera is not a Perspective Camera!")),this.textureMatrix=new THREE.Matrix4,this.mirrorCamera=this.camera.clone(),this.mesh=new THREE.Object3D,this.texture=new THREE.WebGLRenderTarget(a,i),this.tempTexture=new THREE.WebGLRenderTarget(a,i),THREE.Math.isPowerOfTwo(a)&&THREE.Math.isPowerOfTwo(i)||(this.texture.texture.generateMipmaps=!1,this.tempTexture.texture.generateMipmaps=!1),this.updateTextureMatrix(),this.render()}renderWithMirror(e){this.updateTextureMatrix(),this.matrixNeedsUpdate=!1;var t=e.camera;e.camera=this.mirrorCamera,e.render(!0),e.material.uniforms.mirrorSampler.value=e.tempTexture.texture,this.render(),this.matrixNeedsUpdate=!0,e.material.uniforms.mirrorSampler.value=e.texture.texture,e.camera=t,e.updateTextureMatrix()}updateTextureMatrix(){function e(e){return e?e<0?-1:1:0}null!=this.parent&&(this.mesh=this.parent),this.updateMatrixWorld(),this.camera.updateMatrixWorld(),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.matrixWorld),this.normal=new THREE.Vector3(0,1,0).applyEuler(this.mesh.rotation);var t=new THREE.Vector3(0,0,1).applyEuler(this.camera.rotation);if(this.normal.dot(t)<0){var n=new THREE.Vector3(0,0,1).applyEuler(this.mesh.rotation);this.normal.reflect(n)}var r=this.mesh.position.clone().sub(this.cameraWorldPosition);r.reflect(this.normal).negate(),r.add(this.mesh.position),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition);var o=this.mesh.position.clone().sub(this.lookAtPosition);o.reflect(this.normal).negate(),o.add(this.mesh.position),this.up.set(0,-1,0),this.up.applyMatrix4(this.rotationMatrix),this.up.reflect(this.normal).negate(),this.mirrorCamera.position.copy(r),this.mirrorCamera.up=this.up,this.mirrorCamera.lookAt(o),this.mirrorCamera.aspect=this.camera.aspect,this.mirrorCamera.updateProjectionMatrix(),this.mirrorCamera.updateMatrixWorld(),this.mirrorCamera.matrixWorldInverse.copy(this.mirrorCamera.matrixWorld).invert(),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix),this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse),this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal,this.mesh.position),this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse),this.clipPlane.set(this.mirrorPlane.normal.x,this.mirrorPlane.normal.y,this.mirrorPlane.normal.z,this.mirrorPlane.constant);var a=new THREE.Vector4,i=this.mirrorCamera.projectionMatrix;a.x=(e(this.clipPlane.x)+i.elements[8])/i.elements[0],a.y=(e(this.clipPlane.y)+i.elements[9])/i.elements[5],a.z=-1,a.w=(1+i.elements[10])/i.elements[14];var s=new THREE.Vector4;s=this.clipPlane.multiplyScalar(2/this.clipPlane.dot(a)),i.elements[2]=s.x,i.elements[6]=s.y,i.elements[10]=s.z+1-this.clipBias,i.elements[14]=s.w;var l=new THREE.Vector3;l.setFromMatrixPosition(this.camera.matrixWorld),this.eye=l}render(e){if(this.matrixNeedsUpdate&&this.updateTextureMatrix(),this.matrixNeedsUpdate=!0,void 0!==this.scene&&this.scene instanceof THREE.Scene){var t=void 0!==e&&e?this.tempTexture:this.texture;this.renderer.setRenderTarget(t),this.renderer.clear(),this.renderer.render(this.scene,this.mirrorCamera)}}}e.prototype.isMirrorRenderer=!0,THREE.MirrorRenderer=e},5640:(e,t,n)=>{"use strict";n.r(t);var r=n(743);!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){let n=e,o=0;const a=new Int8Array(new Int16Array([1]).buffer)[0]>0,i={};const s=function(e,t){null==t&&(t=1);let r=1,i=Uint8Array;switch(e){case"uchar":break;case"schar":i=Int8Array;break;case"ushort":i=Uint16Array,r=2;break;case"sshort":i=Int16Array,r=2;break;case"uint":i=Uint32Array,r=4;break;case"sint":i=Int32Array,r=4;break;case"float":i=Float32Array,r=4;break;case"complex":case"double":i=Float64Array,r=8}let s=new i(n.slice(o,o+=t*r));return true!=a&&(s=function(e,t){const n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);for(let r=0;r<e.byteLength;r+=t)for(let e=r+t-1,o=r;e>o;e--,o++){const t=n[o];n[o]=n[e],n[e]=t}return e}(s,r)),1==t?s[0]:s}("uchar",e.byteLength),l=s.length;let c,f=null,u=0;for(c=1;c<l;c++)if(10==s[c-1]&&10==s[c]){f=this.parseChars(s,0,c-2),u=c+1;break}if(function(e){let n,r,o,a,s,l,c,f;const u=e.split(/\r?\n/);for(c=0,f=u.length;c<f;c++)s=u[c],s.match(/NRRD\d+/)?i.isNrrd=!0:s.match(/^#/)||(l=s.match(/(.*):(.*)/))&&(r=l[1].trim(),n=l[2].trim(),o=t[r],o?o.call(i,n):i[r]=n);if(!i.isNrrd)throw new Error("Not an NRRD file");if("bz2"===i.encoding||"bzip2"===i.encoding)throw new Error("Bzip is not supported");if(!i.vectors&&(i.vectors=[new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1)],i.spacings))for(a=0;a<=2;a++)isNaN(i.spacings[a])||i.vectors[a].multiplyScalar(i.spacings[a])}(f),n=s.subarray(u),"gz"===i.encoding.substring(0,2))n=r.gunzipSync(new Uint8Array(n));else if("ascii"===i.encoding||"text"===i.encoding||"txt"===i.encoding||"hex"===i.encoding)n=function(e,t,n){let r,o="";t=t||0,n=n||e.length;const a=i.sizes.reduce((function(e,t){return e*t}),1);let s=10;"hex"===i.encoding&&(s=16);const l=new i.__array(a);let c=0,f=parseInt;i.__array!==Float32Array&&i.__array!==Float64Array||(f=parseFloat);for(let a=t;a<n;a++)r=e[a],(r<9||r>13)&&32!==r?o+=String.fromCharCode(r):(""!==o&&(l[c]=f(o,s),c++),o="");return""!==o&&(l[c]=f(o,s),c++),l}(n);else if("raw"===i.encoding){const e=new Uint8Array(n.length);for(let t=0;t<n.length;t++)e[t]=n[t];n=e}n=n.buffer;const d=new THREE.Volume;d.header=i,d.data=new i.__array(n);const p=d.computeMinMax(),h=p[0],v=p[1];d.windowLow=h,d.windowHigh=v,d.dimensions=[i.sizes[0],i.sizes[1],i.sizes[2]],d.xLength=d.dimensions[0],d.yLength=d.dimensions[1],d.zLength=d.dimensions[2];const m=new THREE.Vector3(i.vectors[0][0],i.vectors[0][1],i.vectors[0][2]).length(),x=new THREE.Vector3(i.vectors[1][0],i.vectors[1][1],i.vectors[1][2]).length(),g=new THREE.Vector3(i.vectors[2][0],i.vectors[2][1],i.vectors[2][2]).length();d.spacing=[m,x,g],d.matrix=new THREE.Matrix4;let y=1,E=1;if("left-posterior-superior"==i.space?(y=-1,E=-1):"left-anterior-superior"===i.space&&(y=-1),i.vectors){const e=i.vectors;d.matrix.set(y*e[0][0],y*e[1][0],y*e[2][0],0,E*e[0][1],E*e[1][1],E*e[2][1],0,1*e[0][2],1*e[1][2],1*e[2][2],0,0,0,0,1)}else d.matrix.set(y,0,0,0,0,E,0,0,0,0,1,0,0,0,0,1);return d.inverseMatrix=new THREE.Matrix4,d.inverseMatrix.copy(d.matrix).invert(),d.RASDimensions=new THREE.Vector3(d.xLength,d.yLength,d.zLength).applyMatrix4(d.matrix).round().toArray().map(Math.abs),d.lowerThreshold===-1/0&&(d.lowerThreshold=h),d.upperThreshold===1/0&&(d.upperThreshold=v),d}parseChars(e,t,n){void 0===t&&(t=0),void 0===n&&(n=e.length);let r="",o=0;for(o=t;o<n;++o)r+=String.fromCharCode(e[o]);return r}}const t={type:function(e){switch(e){case"uchar":case"unsigned char":case"uint8":case"uint8_t":this.__array=Uint8Array;break;case"signed char":case"int8":case"int8_t":this.__array=Int8Array;break;case"short":case"short int":case"signed short":case"signed short int":case"int16":case"int16_t":this.__array=Int16Array;break;case"ushort":case"unsigned short":case"unsigned short int":case"uint16":case"uint16_t":this.__array=Uint16Array;break;case"int":case"signed int":case"int32":case"int32_t":this.__array=Int32Array;break;case"uint":case"unsigned int":case"uint32":case"uint32_t":this.__array=Uint32Array;break;case"float":this.__array=Float32Array;break;case"double":this.__array=Float64Array;break;default:throw new Error("Unsupported NRRD data type: "+e)}return this.type=e},endian:function(e){return this.endian=e},encoding:function(e){return this.encoding=e},dimension:function(e){return this.dim=parseInt(e,10)},sizes:function(e){let t;return this.sizes=function(){const n=e.split(/\s+/),r=[];for(let e=0,o=n.length;e<o;e++)t=n[e],r.push(parseInt(t,10));return r}()},space:function(e){return this.space=e},"space origin":function(e){return this.space_origin=e.split("(")[1].split(")")[0].split(",")},"space directions":function(e){let t,n;const r=e.match(/\(.*?\)/g);return this.vectors=function(){const e=[];for(let o=0,a=r.length;o<a;o++)n=r[o],e.push(function(){const e=n.slice(1,-1).split(/,/),r=[];for(let n=0,o=e.length;n<o;n++)t=e[n],r.push(parseFloat(t));return r}());return e}()},spacings:function(e){let t;const n=e.split(/\s+/);return this.spacings=function(){const e=[];for(let r=0,o=n.length;r<o;r++)t=n[r],e.push(parseFloat(t));return e}()}};THREE.NRRDLoader=e}()},8080:()=>{!function(){class e extends THREE.Curve{constructor(e,t,n,r,o){super(),this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=r||0,this.endKnot=o||this.knots.length-1;for(let e=0;e<n.length;++e){const t=n[e];this.controlPoints[e]=new THREE.Vector4(t.x,t.y,t.z,t.w)}}getPoint(e,t=new THREE.Vector3){const n=t,r=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),o=THREE.NURBSUtils.calcBSplinePoint(this.degree,this.knots,this.controlPoints,r);return 1!==o.w&&o.divideScalar(o.w),n.set(o.x,o.y,o.z)}getTangent(e,t=new THREE.Vector3){const n=t,r=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),o=THREE.NURBSUtils.calcNURBSDerivatives(this.degree,this.knots,this.controlPoints,r,1);return n.copy(o[1]).normalize(),n}}THREE.NURBSCurve=e}()},6136:()=>{THREE.NURBSSurface=class{constructor(e,t,n,r,o){this.degree1=e,this.degree2=t,this.knots1=n,this.knots2=r,this.controlPoints=[];const a=n.length-e-1,i=r.length-t-1;for(let e=0;e<a;++e){this.controlPoints[e]=[];for(let t=0;t<i;++t){const n=o[e][t];this.controlPoints[e][t]=new THREE.Vector4(n.x,n.y,n.z,n.w)}}}getPoint(e,t,n){const r=this.knots1[0]+e*(this.knots1[this.knots1.length-1]-this.knots1[0]),o=this.knots2[0]+t*(this.knots2[this.knots2.length-1]-this.knots2[0]);THREE.NURBSUtils.calcSurfacePoint(this.degree1,this.degree2,this.knots1,this.knots2,this.controlPoints,r,o,n)}}},3723:()=>{THREE.NURBSUtils=class{static findSpan(e,t,n){const r=n.length-e-1;if(t>=n[r])return r-1;if(t<=n[e])return e;let o=e,a=r,i=Math.floor((o+a)/2);for(;t<n[i]||t>=n[i+1];)t<n[i]?a=i:o=i,i=Math.floor((o+a)/2);return i}static calcBasisFunctions(e,t,n,r){const o=[],a=[],i=[];o[0]=1;for(let s=1;s<=n;++s){a[s]=t-r[e+1-s],i[s]=r[e+s]-t;let n=0;for(let e=0;e<s;++e){const t=i[e+1],r=a[s-e],l=o[e]/(t+r);o[e]=n+t*l,n=r*l}o[s]=n}return o}static calcBSplinePoint(e,t,n,r){const o=this.findSpan(e,r,t),a=this.calcBasisFunctions(o,r,e,t),i=new THREE.Vector4(0,0,0,0);for(let t=0;t<=e;++t){const r=n[o-e+t],s=a[t],l=r.w*s;i.x+=r.x*l,i.y+=r.y*l,i.z+=r.z*l,i.w+=r.w*s}return i}static calcBasisFunctionDerivatives(e,t,n,r,o){const a=[];for(let e=0;e<=n;++e)a[e]=0;const i=[];for(let e=0;e<=r;++e)i[e]=a.slice(0);const s=[];for(let e=0;e<=n;++e)s[e]=a.slice(0);s[0][0]=1;const l=a.slice(0),c=a.slice(0);for(let r=1;r<=n;++r){l[r]=t-o[e+1-r],c[r]=o[e+r]-t;let n=0;for(let e=0;e<r;++e){const t=c[e+1],o=l[r-e];s[r][e]=t+o;const a=s[e][r-1]/s[r][e];s[e][r]=n+t*a,n=o*a}s[r][r]=n}for(let e=0;e<=n;++e)i[0][e]=s[e][n];for(let e=0;e<=n;++e){let t=0,o=1;const l=[];for(let e=0;e<=n;++e)l[e]=a.slice(0);l[0][0]=1;for(let a=1;a<=r;++a){let r=0;const c=e-a,f=n-a;e>=a&&(l[o][0]=l[t][0]/s[f+1][c],r=l[o][0]*s[c][f]);const u=e-1<=f?a-1:n-e;for(let e=c>=-1?1:-c;e<=u;++e)l[o][e]=(l[t][e]-l[t][e-1])/s[f+1][c+e],r+=l[o][e]*s[c+e][f];e<=f&&(l[o][a]=-l[t][a-1]/s[f+1][e],r+=l[o][a]*s[e][f]),i[a][e]=r;const d=t;t=o,o=d}}let f=n;for(let e=1;e<=r;++e){for(let t=0;t<=n;++t)i[e][t]*=f;f*=n-e}return i}static calcBSplineDerivatives(e,t,n,r,o){const a=o<e?o:e,i=[],s=this.findSpan(e,r,t),l=this.calcBasisFunctionDerivatives(s,r,e,a,t),c=[];for(let e=0;e<n.length;++e){const t=n[e].clone(),r=t.w;t.x*=r,t.y*=r,t.z*=r,c[e]=t}for(let t=0;t<=a;++t){const n=c[s-e].clone().multiplyScalar(l[t][0]);for(let r=1;r<=e;++r)n.add(c[s-e+r].clone().multiplyScalar(l[t][r]));i[t]=n}for(let e=a+1;e<=o+1;++e)i[e]=new THREE.Vector4(0,0,0);return i}static calcKoverI(e,t){let n=1;for(let t=2;t<=e;++t)n*=t;let r=1;for(let e=2;e<=t;++e)r*=e;for(let n=2;n<=e-t;++n)r*=n;return n/r}static calcRationalCurveDerivatives(e){const t=e.length,n=[],r=[];for(let o=0;o<t;++o){const t=e[o];n[o]=new THREE.Vector3(t.x,t.y,t.z),r[o]=t.w}const o=[];for(let e=0;e<t;++e){const t=n[e].clone();for(let n=1;n<=e;++n)t.sub(o[e-n].clone().multiplyScalar(this.calcKoverI(e,n)*r[n]));o[e]=t.divideScalar(r[0])}return o}static calcNURBSDerivatives(e,t,n,r,o){const a=this.calcBSplineDerivatives(e,t,n,r,o);return this.calcRationalCurveDerivatives(a)}static calcSurfacePoint(e,t,n,r,o,a,i,s){const l=this.findSpan(e,a,n),c=this.findSpan(t,i,r),f=this.calcBasisFunctions(l,a,e,n),u=this.calcBasisFunctions(c,i,t,r),d=[];for(let n=0;n<=t;++n){d[n]=new THREE.Vector4(0,0,0,0);for(let r=0;r<=e;++r){const a=o[l-e+r][c-t+n].clone(),i=a.w;a.x*=i,a.y*=i,a.z*=i,d[n].add(a.multiplyScalar(f[r]))}}const p=new THREE.Vector4(0,0,0,0);for(let e=0;e<=t;++e)p.add(d[e].multiplyScalar(u[e]));p.divideScalar(p.w),s.set(p.x,p.y,p.z)}}},6834:()=>{THREE.OBJExporter=class{parse(e){let t="",n=0,r=0,o=0;const a=new THREE.Vector3,i=new THREE.Color,s=new THREE.Vector3,l=new THREE.Vector2,c=[];return e.traverse((function(e){!0===e.isMesh&&function(e){let i=0,f=0,u=0;const d=e.geometry,p=new THREE.Matrix3;if(!0!==d.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const h=d.getAttribute("position"),v=d.getAttribute("normal"),m=d.getAttribute("uv"),x=d.getIndex();if(t+="o "+e.name+"\n",e.material&&e.material.name&&(t+="usemtl "+e.material.name+"\n"),void 0!==h)for(let n=0,r=h.count;n<r;n++,i++)a.x=h.getX(n),a.y=h.getY(n),a.z=h.getZ(n),a.applyMatrix4(e.matrixWorld),t+="v "+a.x+" "+a.y+" "+a.z+"\n";if(void 0!==m)for(let e=0,n=m.count;e<n;e++,u++)l.x=m.getX(e),l.y=m.getY(e),t+="vt "+l.x+" "+l.y+"\n";if(void 0!==v){p.getNormalMatrix(e.matrixWorld);for(let e=0,n=v.count;e<n;e++,f++)s.x=v.getX(e),s.y=v.getY(e),s.z=v.getZ(e),s.applyMatrix3(p).normalize(),t+="vn "+s.x+" "+s.y+" "+s.z+"\n"}if(null!==x)for(let e=0,a=x.count;e<a;e+=3){for(let t=0;t<3;t++){const a=x.getX(e+t)+1;c[t]=n+a+(v||m?"/"+(m?r+a:"")+(v?"/"+(o+a):""):"")}t+="f "+c.join(" ")+"\n"}else for(let e=0,a=h.count;e<a;e+=3){for(let t=0;t<3;t++){const a=e+t+1;c[t]=n+a+(v||m?"/"+(m?r+a:"")+(v?"/"+(o+a):""):"")}t+="f "+c.join(" ")+"\n"}n+=i,r+=u,o+=f}(e),!0===e.isLine&&function(e){let r=0;const o=e.geometry,i=e.type;if(!0!==o.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const s=o.getAttribute("position");if(t+="o "+e.name+"\n",void 0!==s)for(let n=0,o=s.count;n<o;n++,r++)a.x=s.getX(n),a.y=s.getY(n),a.z=s.getZ(n),a.applyMatrix4(e.matrixWorld),t+="v "+a.x+" "+a.y+" "+a.z+"\n";if("Line"===i){t+="l ";for(let e=1,r=s.count;e<=r;e++)t+=n+e+" ";t+="\n"}if("LineSegments"===i)for(let e=1,r=e+1,o=s.count;e<o;e+=2,r=e+1)t+="l "+(n+e)+" "+(n+r)+"\n";n+=r}(e),!0===e.isPoints&&function(e){let r=0;const o=e.geometry;if(!0!==o.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const s=o.getAttribute("position"),l=o.getAttribute("color");if(t+="o "+e.name+"\n",void 0!==s)for(let n=0,o=s.count;n<o;n++,r++)a.fromBufferAttribute(s,n),a.applyMatrix4(e.matrixWorld),t+="v "+a.x+" "+a.y+" "+a.z,void 0!==l&&(i.fromBufferAttribute(l,n),t+=" "+i.r+" "+i.g+" "+i.b),t+="\n";t+="p ";for(let e=1,r=s.count;e<=r;e++)t+=n+e+" ";t+="\n",n+=r}(e)})),t}}},4271:()=>{!function(){const e=/^[og]\s*(.+)?/,t=/^mtllib /,n=/^usemtl /,r=/^usemap /,o=new THREE.Vector3,a=new THREE.Vector3,i=new THREE.Vector3,s=new THREE.Vector3,l=new THREE.Vector3;function c(){const e={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&!1===this.object.fromDeclaration)return this.object.name=e,void(this.object.fromDeclaration=!1!==t);const n=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:!1!==t,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(e,t){const n=this._finalize(!1);n&&(n.inherited||n.groupCount<=0)&&this.materials.splice(n.index,1);const r={index:this.materials.length,name:e||"",mtllib:Array.isArray(t)&&t.length>0?t[t.length-1]:"",smooth:void 0!==n?n.smooth:this.smooth,groupStart:void 0!==n?n.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(e){const t={index:"number"==typeof e?e:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return t.clone=this.clone.bind(t),t}};return this.materials.push(r),r},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(e){const t=this.currentMaterial();if(t&&-1===t.groupEnd&&(t.groupEnd=this.geometry.vertices.length/3,t.groupCount=t.groupEnd-t.groupStart,t.inherited=!1),e&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return e&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),t}},n&&n.name&&"function"==typeof n.clone){const e=n.clone(0);e.inherited=!0,this.object.materials.push(e)}this.objects.push(this.object)},finalize:function(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseNormalIndex:function(e,t){const n=parseInt(e,10);return 3*(n>=0?n-1:n+t/3)},parseUVIndex:function(e,t){const n=parseInt(e,10);return 2*(n>=0?n-1:n+t/2)},addVertex:function(e,t,n){const r=this.vertices,o=this.object.geometry.vertices;o.push(r[e+0],r[e+1],r[e+2]),o.push(r[t+0],r[t+1],r[t+2]),o.push(r[n+0],r[n+1],r[n+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,n){const r=this.normals,o=this.object.geometry.normals;o.push(r[e+0],r[e+1],r[e+2]),o.push(r[t+0],r[t+1],r[t+2]),o.push(r[n+0],r[n+1],r[n+2])},addFaceNormal:function(e,t,n){const r=this.vertices,c=this.object.geometry.normals;o.fromArray(r,e),a.fromArray(r,t),i.fromArray(r,n),l.subVectors(i,a),s.subVectors(o,a),l.cross(s),l.normalize(),c.push(l.x,l.y,l.z),c.push(l.x,l.y,l.z),c.push(l.x,l.y,l.z)},addColor:function(e,t,n){const r=this.colors,o=this.object.geometry.colors;void 0!==r[e]&&o.push(r[e+0],r[e+1],r[e+2]),void 0!==r[t]&&o.push(r[t+0],r[t+1],r[t+2]),void 0!==r[n]&&o.push(r[n+0],r[n+1],r[n+2])},addUV:function(e,t,n){const r=this.uvs,o=this.object.geometry.uvs;o.push(r[e+0],r[e+1]),o.push(r[t+0],r[t+1]),o.push(r[n+0],r[n+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,n,r,o,a,i,s,l){const c=this.vertices.length;let f=this.parseVertexIndex(e,c),u=this.parseVertexIndex(t,c),d=this.parseVertexIndex(n,c);if(this.addVertex(f,u,d),this.addColor(f,u,d),void 0!==i&&""!==i){const e=this.normals.length;f=this.parseNormalIndex(i,e),u=this.parseNormalIndex(s,e),d=this.parseNormalIndex(l,e),this.addNormal(f,u,d)}else this.addFaceNormal(f,u,d);if(void 0!==r&&""!==r){const e=this.uvs.length;f=this.parseUVIndex(r,e),u=this.parseUVIndex(o,e),d=this.parseUVIndex(a,e),this.addUV(f,u,d),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let n=0,r=e.length;n<r;n++){const r=this.parseVertexIndex(e[n],t);this.addVertexPoint(r),this.addColor(r)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const n=this.vertices.length,r=this.uvs.length;for(let t=0,r=e.length;t<r;t++)this.addVertexLine(this.parseVertexIndex(e[t],n));for(let e=0,n=t.length;e<n;e++)this.addUVLine(this.parseUVIndex(t[e],r))}};return e.startObject("",!1),e}class f extends THREE.Loader{constructor(e){super(e),this.materials=null}load(e,t,n,r){const o=this,a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}setMaterials(e){return this.materials=e,this}parse(o){const a=new c;-1!==o.indexOf("\r\n")&&(o=o.replace(/\r\n/g,"\n")),-1!==o.indexOf("\\\n")&&(o=o.replace(/\\\n/g,""));const i=o.split("\n");let s="",l="",f=0,u=[];const d="function"==typeof"".trimLeft;for(let o=0,c=i.length;o<c;o++)if(s=i[o],s=d?s.trimLeft():s.trim(),f=s.length,0!==f&&(l=s.charAt(0),"#"!==l))if("v"===l){const e=s.split(/\s+/);switch(e[0]){case"v":a.vertices.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3])),e.length>=7?a.colors.push(parseFloat(e[4]/255),parseFloat(e[5]/255),parseFloat(e[6]/255)):a.colors.push(void 0,void 0,void 0);break;case"vn":a.normals.push(parseFloat(e[1]),parseFloat(e[2]),parseFloat(e[3]));break;case"vt":a.uvs.push(parseFloat(e[1]),parseFloat(e[2]))}}else if("f"===l){const e=s.substr(1).trim().split(/\s+/),t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];if(r.length>0){const e=r.split("/");t.push(e)}}const n=t[0];for(let e=1,r=t.length-1;e<r;e++){const r=t[e],o=t[e+1];a.addFace(n[0],r[0],o[0],n[1],r[1],o[1],n[2],r[2],o[2])}}else if("l"===l){const e=s.substring(1).trim().split(" ");let t=[];const n=[];if(-1===s.indexOf("/"))t=e;else for(let r=0,o=e.length;r<o;r++){const o=e[r].split("/");""!==o[0]&&t.push(o[0]),""!==o[1]&&n.push(o[1])}a.addLineGeometry(t,n)}else if("p"===l){const e=s.substr(1).trim().split(" ");a.addPointGeometry(e)}else if(null!==(u=e.exec(s))){const e=(" "+u[0].substr(1).trim()).substr(1);a.startObject(e)}else if(n.test(s))a.object.startMaterial(s.substring(7).trim(),a.materialLibraries);else if(t.test(s))a.materialLibraries.push(s.substring(7).trim());else if(r.test(s))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if("s"===l){if(u=s.split(" "),u.length>1){const e=u[1].trim().toLowerCase();a.object.smooth="0"!==e&&"off"!==e}else a.object.smooth=!0;const e=a.object.currentMaterial();e&&(e.smooth=a.object.smooth)}else{if("\0"===s)continue;console.warn('THREE.OBJLoader: Unexpected line: "'+s+'"')}a.finalize();const p=new THREE.Group;p.materialLibraries=[].concat(a.materialLibraries);if(!0===!(1===a.objects.length&&0===a.objects[0].geometry.vertices.length))for(let e=0,t=a.objects.length;e<t;e++){const t=a.objects[e],n=t.geometry,r=t.materials,o="Line"===n.type,i="Points"===n.type;let s=!1;if(0===n.vertices.length)continue;const l=new THREE.BufferGeometry;l.setAttribute("position",new THREE.Float32BufferAttribute(n.vertices,3)),n.normals.length>0&&l.setAttribute("normal",new THREE.Float32BufferAttribute(n.normals,3)),n.colors.length>0&&(s=!0,l.setAttribute("color",new THREE.Float32BufferAttribute(n.colors,3))),!0===n.hasUVIndices&&l.setAttribute("uv",new THREE.Float32BufferAttribute(n.uvs,2));const c=[];for(let e=0,t=r.length;e<t;e++){const t=r[e],n=t.name+"_"+t.smooth+"_"+s;let l=a.materials[n];if(null!==this.materials)if(l=this.materials.create(t.name),!o||!l||l instanceof THREE.LineBasicMaterial){if(i&&l&&!(l instanceof THREE.PointsMaterial)){const e=new THREE.PointsMaterial({size:10,sizeAttenuation:!1});THREE.Material.prototype.copy.call(e,l),e.color.copy(l.color),e.map=l.map,l=e}}else{const e=new THREE.LineBasicMaterial;THREE.Material.prototype.copy.call(e,l),e.color.copy(l.color),l=e}void 0===l&&(l=o?new THREE.LineBasicMaterial:i?new THREE.PointsMaterial({size:1,sizeAttenuation:!1}):new THREE.MeshPhongMaterial,l.name=t.name,l.flatShading=!t.smooth,l.vertexColors=s,a.materials[n]=l),c.push(l)}let f;if(c.length>1){for(let e=0,t=r.length;e<t;e++){const t=r[e];l.addGroup(t.groupStart,t.groupCount,e)}f=o?new THREE.LineSegments(l,c):i?new THREE.Points(l,c):new THREE.Mesh(l,c)}else f=o?new THREE.LineSegments(l,c[0]):i?new THREE.Points(l,c[0]):new THREE.Mesh(l,c[0]);f.name=t.name,p.add(f)}else if(a.vertices.length>0){const e=new THREE.PointsMaterial({size:1,sizeAttenuation:!1}),t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.Float32BufferAttribute(a.vertices,3)),a.colors.length>0&&void 0!==a.colors[0]&&(t.setAttribute("color",new THREE.Float32BufferAttribute(a.colors,3)),e.vertexColors=!0);const n=new THREE.Points(t,e);p.add(n)}return p}}THREE.OBJLoader=f}()},6427:()=>{THREE.ShaderLib.ocean_sim_vertex={vertexShader:["varying vec2 vUV;","void main (void) {","vUV = position.xy * 0.5 + 0.5;","gl_Position = vec4(position, 1.0);","}"].join("\n")},THREE.ShaderLib.ocean_subtransform={uniforms:{u_input:{value:null},u_transformSize:{value:512},u_subtransformSize:{value:250}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","uniform sampler2D u_input;","uniform float u_transformSize;","uniform float u_subtransformSize;","varying vec2 vUV;","vec2 multiplyComplex (vec2 a, vec2 b) {","return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);","}","void main (void) {","#ifdef HORIZONTAL","float index = vUV.x * u_transformSize - 0.5;","#else","float index = vUV.y * u_transformSize - 0.5;","#endif","float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);","#ifdef HORIZONTAL","vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;","vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;","#else","vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;","vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;","#endif","float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);","vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));","vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);","vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);","gl_FragColor = vec4(outputA, outputB);","}"].join("\n")},THREE.ShaderLib.ocean_initial_spectrum={uniforms:{u_wind:{value:new THREE.Vector2(10,10)},u_resolution:{value:512},u_size:{value:250}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","const float CM = 0.23;","uniform vec2 u_wind;","uniform float u_resolution;","uniform float u_size;","float square (float x) {","return x * x;","}","float omega (float k) {","return sqrt(G * k * (1.0 + square(k / KM)));","}","float tanh_ (float x) {","return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));","}","void main (void) {","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 K = (2.0 * PI * vec2(n, m)) / u_size;","float k = length(K);","float l_wind = length(u_wind);","float Omega = 0.84;","float kp = G * square(Omega / l_wind);","float c = omega(k) / k;","float cp = omega(kp) / kp;","float Lpm = exp(-1.25 * square(kp / k));","float gamma = 1.7;","float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));","float Gamma = exp(-square(sqrt(k / kp) - 1.0) / 2.0 * square(sigma));","float Jp = pow(gamma, Gamma);","float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));","float alphap = 0.006 * sqrt(Omega);","float Bl = 0.5 * alphap * cp / c * Fp;","float z0 = 0.000037 * square(l_wind) / G * pow(l_wind / cp, 0.9);","float uStar = 0.41 * l_wind / log(10.0 / z0);","float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));","float Fm = exp(-0.25 * square(k / KM - 1.0));","float Bh = 0.5 * alpham * CM / c * Fm * Lpm;","float a0 = log(2.0) / 4.0;","float am = 0.13 * uStar / CM;","float Delta = tanh_(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));","float cosPhi = dot(normalize(u_wind), normalize(K));","float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));","float dk = 2.0 * PI / u_size;","float h = sqrt(S / 2.0) * dk;","if (K.x == 0.0 && K.y == 0.0) {","h = 0.0;","}","gl_FragColor = vec4(h, 0.0, 0.0, 0.0);","}"].join("\n")},THREE.ShaderLib.ocean_phase={uniforms:{u_phases:{value:null},u_deltaTime:{value:null},u_resolution:{value:null},u_size:{value:null}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","varying vec2 vUV;","uniform sampler2D u_phases;","uniform float u_deltaTime;","uniform float u_resolution;","uniform float u_size;","float omega (float k) {","return sqrt(G * k * (1.0 + k * k / KM * KM));","}","void main (void) {","float deltaTime = 1.0 / 60.0;","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;","float phase = texture2D(u_phases, vUV).r;","float deltaPhase = omega(length(waveVector)) * u_deltaTime;","phase = mod(phase + deltaPhase, 2.0 * PI);","gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);","}"].join("\n")},THREE.ShaderLib.ocean_spectrum={uniforms:{u_size:{value:null},u_resolution:{value:null},u_choppiness:{value:null},u_phases:{value:null},u_initialSpectrum:{value:null}},fragmentShader:["precision highp float;","const float PI = 3.14159265359;","const float G = 9.81;","const float KM = 370.0;","varying vec2 vUV;","uniform float u_size;","uniform float u_resolution;","uniform float u_choppiness;","uniform sampler2D u_phases;","uniform sampler2D u_initialSpectrum;","vec2 multiplyComplex (vec2 a, vec2 b) {","return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);","}","vec2 multiplyByI (vec2 z) {","return vec2(-z[1], z[0]);","}","float omega (float k) {","return sqrt(G * k * (1.0 + k * k / KM * KM));","}","void main (void) {","vec2 coordinates = gl_FragCoord.xy - 0.5;","float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;","float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;","vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;","float phase = texture2D(u_phases, vUV).r;","vec2 phaseVector = vec2(cos(phase), sin(phase));","vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;","vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;","h0Star.y *= -1.0;","vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));","vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;","vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;","if (waveVector.x == 0.0 && waveVector.y == 0.0) {","h = vec2(0.0);","hX = vec2(0.0);","hZ = vec2(0.0);","}","gl_FragColor = vec4(hX + multiplyByI(h), hZ);","}"].join("\n")},THREE.ShaderLib.ocean_normals={uniforms:{u_displacementMap:{value:null},u_resolution:{value:null},u_size:{value:null}},fragmentShader:["precision highp float;","varying vec2 vUV;","uniform sampler2D u_displacementMap;","uniform float u_resolution;","uniform float u_size;","void main (void) {","float texel = 1.0 / u_resolution;","float texelSize = u_size / u_resolution;","vec3 center = texture2D(u_displacementMap, vUV).rgb;","vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;","vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;","vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;","vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;","vec3 topRight = cross(right, top);","vec3 topLeft = cross(top, left);","vec3 bottomLeft = cross(left, bottom);","vec3 bottomRight = cross(bottom, right);","gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);","}"].join("\n")},THREE.ShaderChunk.screenplane_pars_vertex=["const float infinite = 150000.0;","const float screenScale = 1.2;","const vec3 groundNormal = vec3( 0.0, 1.0, 0.0 );","varying vec3 vCamPosition;","vec3 interceptPlane( in vec3 source, in vec3 dir, in vec3 normal, float height )","{","\tfloat distance = ( - height - dot( normal, source ) ) / dot( normal, dir );","\tif( distance < 0.0 )","\t\treturn source + dir * distance;","\telse ","\t\treturn - ( vec3( source.x, height, source.z ) + vec3( dir.x, height, dir.z ) * infinite );","}","mat3 getRotation()","{","\treturn mat3( ","\t\tviewMatrix[0].xyz,","\t\tviewMatrix[1].xyz,","\t\tviewMatrix[2].xyz","\t);","}","vec3 getCameraPos( in mat3 rotation )","{","\treturn - viewMatrix[3].xyz * rotation;","}","vec2 getImagePlan()","{","\tfloat focal = projectionMatrix[0].x;","\tfloat aspect = projectionMatrix[1].y;","\treturn vec2( ( uv.x - 0.5 ) * screenScale * aspect, ( uv.y - 0.5 ) * screenScale * focal );","}","vec3 getCamRay( in mat3 rotation, in vec2 screenUV )","{","\treturn vec3( screenUV.x, screenUV.y, projectionMatrix[0].x ) * rotation;","}","vec3 computeProjectedPosition()","{","\tmat3 cameraRotation = getRotation();","\tvec3 camPosition = getCameraPos( cameraRotation );","\tvCamPosition = camPosition;","\tvec2 screenUV = getImagePlan();","\tvec3 ray = getCamRay( cameraRotation, screenUV );","\tvec3 finalPos = interceptPlane( camPosition, ray, groundNormal, -u_groundHeight );","\tfloat distance = length( finalPos );","\tif( distance > infinite )","\t\tfinalPos *= infinite / distance;","\treturn finalPos;","}"].join("\n"),THREE.ShaderChunk.screenplane_vertex=["vec4 screenPlaneWorldPosition = vec4( computeProjectedPosition(), 1.0 );"].join("\n"),THREE.ShaderChunk.screenplane_pars_fragment=["varying vec3 vCamPosition;"].join("\n"),THREE.ShaderChunk.oceanfft_pars_vertex=["uniform sampler2D u_displacementMap;","uniform float u_geometrySize;","uniform float u_size;"].join("\n"),THREE.ShaderChunk.oceanfft_vertex=["vec3 displacement = texture2D( u_displacementMap, worldPosition.xz * 0.002 ).rgb * ( u_geometrySize / u_size );","vec4 oceanfftWorldPosition = worldPosition + vec4( displacement, 0.0 );"].join("\n"),THREE.ShaderLib.ocean_main={uniforms:{u_displacementMap:{value:null},u_reflection:{value:null},u_normalMap:{value:null},u_geometrySize:{value:null},u_size:{value:null},u_mirrorMatrix:{value:null},u_oceanColor:{value:null},u_sunDirection:{value:null},u_exposure:{value:null},u_groundHeight:{value:null}},vertexShader:["precision highp float;","varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform mat4 u_mirrorMatrix;","uniform float u_groundHeight;",THREE.ShaderChunk.screenplane_pars_vertex,THREE.ShaderChunk.oceanfft_pars_vertex,"void main (void) {",THREE.ShaderChunk.screenplane_vertex,"vec4 worldPosition = screenPlaneWorldPosition;",THREE.ShaderChunk.oceanfft_vertex,"vWorldPosition = oceanfftWorldPosition.xyz;","vReflectCoordinates = u_mirrorMatrix * oceanfftWorldPosition;","gl_Position = projectionMatrix * viewMatrix * oceanfftWorldPosition;","}"].join("\n"),vertexShaderNoTexLookup:["precision highp float;","varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform mat4 u_mirrorMatrix;","uniform float u_groundHeight;",THREE.ShaderChunk.screenplane_pars_vertex,THREE.ShaderChunk.oceanfft_pars_vertex,"void main (void) {",THREE.ShaderChunk.screenplane_vertex,"vWorldPosition = screenPlaneWorldPosition.xyz;","vReflectCoordinates = u_mirrorMatrix * screenPlaneWorldPosition;","gl_Position = projectionMatrix * viewMatrix * screenPlaneWorldPosition;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec4 vReflectCoordinates;","uniform sampler2D u_reflection;","uniform sampler2D u_normalMap;","uniform vec3 u_oceanColor;","uniform vec3 u_sunDirection;","uniform float u_exposure;","vec3 hdr (vec3 color, float exposure) {","return 1.0 - exp(-color * exposure);","}",THREE.ShaderChunk.screenplane_pars_fragment,"void main (void) {","vec3 normal = texture2D( u_normalMap, vWorldPosition.xz * 0.002 ).rgb;","vec3 view = normalize( vCamPosition - vWorldPosition );","vec3 reflection = normalize( reflect( -u_sunDirection, normal ) );","float specularFactor = pow( max( 0.0, dot( view, reflection ) ), 500.0 ) * 20.0;","vec3 distortion = 200.0 * normal * vec3( 1.0, 0.0, 0.1 );","vec3 reflectionColor = texture2DProj( u_reflection, vReflectCoordinates.xyz + distortion ).xyz;","float distanceRatio = min( 1.0, log( 1.0 / length( vCamPosition - vWorldPosition ) * 3000.0 + 1.0 ) );","distanceRatio *= distanceRatio;","distanceRatio = distanceRatio * 0.7 + 0.3;","normal = ( distanceRatio * normal + vec3( 0.0, 1.0 - distanceRatio, 0.0 ) ) * 0.5;","normal /= length( normal );","float fresnel = pow( 1.0 - dot( normal, view ), 2.0 );","float skyFactor = ( fresnel + 0.2 ) * 10.0;","vec3 waterColor = ( 1.0 - fresnel ) * u_oceanColor;","vec3 color = ( skyFactor + specularFactor + waterColor ) * reflectionColor + waterColor * 0.5 ;","color = hdr( color, u_exposure );","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")}},2700:()=>{!function(){const e={type:"change"},t={type:"start"},n={type:"end"};class r extends THREE.EventDispatcher{constructor(r,o){super(),void 0===o&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),o===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=r,this.domElement=o,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return c.phi},this.getAzimuthalAngle=function(){return c.theta},this.listenToKeyEvents=function(e){e.addEventListener("keydown",V),this._domElementKeyEvents=e},this.saveState=function(){a.target0.copy(a.target),a.position0.copy(a.object.position),a.zoom0=a.object.zoom},this.reset=function(){a.target.copy(a.target0),a.object.position.copy(a.position0),a.object.zoom=a.zoom0,a.object.updateProjectionMatrix(),a.dispatchEvent(e),a.update(),s=i.NONE},this.update=function(){const t=new THREE.Vector3,n=(new THREE.Quaternion).setFromUnitVectors(r.up,new THREE.Vector3(0,1,0)),o=n.clone().invert(),h=new THREE.Vector3,v=new THREE.Quaternion,m=2*Math.PI;return function(){const r=a.object.position;t.copy(r).sub(a.target),t.applyQuaternion(n),c.setFromVector3(t),a.autoRotate&&s===i.NONE&&T(2*Math.PI/60/60*a.autoRotateSpeed),a.enableDamping?(c.theta+=f.theta*a.dampingFactor,c.phi+=f.phi*a.dampingFactor):(c.theta+=f.theta,c.phi+=f.phi);let x=a.minAzimuthAngle,g=a.maxAzimuthAngle;return isFinite(x)&&isFinite(g)&&(x<-Math.PI?x+=m:x>Math.PI&&(x-=m),g<-Math.PI?g+=m:g>Math.PI&&(g-=m),c.theta=x<=g?Math.max(x,Math.min(g,c.theta)):c.theta>(x+g)/2?Math.max(x,c.theta):Math.min(g,c.theta)),c.phi=Math.max(a.minPolarAngle,Math.min(a.maxPolarAngle,c.phi)),c.makeSafe(),c.radius*=u,c.radius=Math.max(a.minDistance,Math.min(a.maxDistance,c.radius)),!0===a.enableDamping?a.target.addScaledVector(d,a.dampingFactor):a.target.add(d),t.setFromSpherical(c),t.applyQuaternion(o),r.copy(a.target).add(t),a.object.lookAt(a.target),!0===a.enableDamping?(f.theta*=1-a.dampingFactor,f.phi*=1-a.dampingFactor,d.multiplyScalar(1-a.dampingFactor)):(f.set(0,0,0),d.set(0,0,0)),u=1,!!(p||h.distanceToSquared(a.object.position)>l||8*(1-v.dot(a.object.quaternion))>l)&&(a.dispatchEvent(e),h.copy(a.object.position),v.copy(a.object.quaternion),p=!1,!0)}}(),this.dispose=function(){a.domElement.removeEventListener("contextmenu",X),a.domElement.removeEventListener("pointerdown",O),a.domElement.removeEventListener("wheel",B),a.domElement.removeEventListener("touchstart",W),a.domElement.removeEventListener("touchend",q),a.domElement.removeEventListener("touchmove",j),a.domElement.ownerDocument.removeEventListener("pointermove",U),a.domElement.ownerDocument.removeEventListener("pointerup",G),null!==a._domElementKeyEvents&&a._domElementKeyEvents.removeEventListener("keydown",V)};const a=this,i={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=i.NONE;const l=1e-6,c=new THREE.Spherical,f=new THREE.Spherical;let u=1;const d=new THREE.Vector3;let p=!1;const h=new THREE.Vector2,v=new THREE.Vector2,m=new THREE.Vector2,x=new THREE.Vector2,g=new THREE.Vector2,y=new THREE.Vector2,E=new THREE.Vector2,w=new THREE.Vector2,b=new THREE.Vector2;function _(){return Math.pow(.95,a.zoomSpeed)}function T(e){f.theta-=e}function A(e){f.phi-=e}const S=function(){const e=new THREE.Vector3;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),d.add(e)}}(),R=function(){const e=new THREE.Vector3;return function(t,n){!0===a.screenSpacePanning?e.setFromMatrixColumn(n,1):(e.setFromMatrixColumn(n,0),e.crossVectors(a.object.up,e)),e.multiplyScalar(t),d.add(e)}}(),M=function(){const e=new THREE.Vector3;return function(t,n){const r=a.domElement;if(a.object.isPerspectiveCamera){const o=a.object.position;e.copy(o).sub(a.target);let i=e.length();i*=Math.tan(a.object.fov/2*Math.PI/180),S(2*t*i/r.clientHeight,a.object.matrix),R(2*n*i/r.clientHeight,a.object.matrix)}else a.object.isOrthographicCamera?(S(t*(a.object.right-a.object.left)/a.object.zoom/r.clientWidth,a.object.matrix),R(n*(a.object.top-a.object.bottom)/a.object.zoom/r.clientHeight,a.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),a.enablePan=!1)}}();function C(e){a.object.isPerspectiveCamera?u/=e:a.object.isOrthographicCamera?(a.object.zoom=Math.max(a.minZoom,Math.min(a.maxZoom,a.object.zoom*e)),a.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),a.enableZoom=!1)}function L(e){a.object.isPerspectiveCamera?u*=e:a.object.isOrthographicCamera?(a.object.zoom=Math.max(a.minZoom,Math.min(a.maxZoom,a.object.zoom/e)),a.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),a.enableZoom=!1)}function P(e){h.set(e.clientX,e.clientY)}function k(e){x.set(e.clientX,e.clientY)}function N(e){if(1==e.touches.length)h.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);h.set(t,n)}}function H(e){if(1==e.touches.length)x.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);x.set(t,n)}}function z(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,r=Math.sqrt(t*t+n*n);E.set(0,r)}function D(e){if(1==e.touches.length)v.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);v.set(t,n)}m.subVectors(v,h).multiplyScalar(a.rotateSpeed);const t=a.domElement;T(2*Math.PI*m.x/t.clientHeight),A(2*Math.PI*m.y/t.clientHeight),h.copy(v)}function F(e){if(1==e.touches.length)g.set(e.touches[0].pageX,e.touches[0].pageY);else{const t=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);g.set(t,n)}y.subVectors(g,x).multiplyScalar(a.panSpeed),M(y.x,y.y),x.copy(g)}function I(e){const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,r=Math.sqrt(t*t+n*n);w.set(0,r),b.set(0,Math.pow(w.y/E.y,a.zoomSpeed)),C(b.y),E.copy(w)}function O(e){if(!1!==a.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){let n;switch(e.preventDefault(),a.domElement.focus?a.domElement.focus():window.focus(),e.button){case 0:n=a.mouseButtons.LEFT;break;case 1:n=a.mouseButtons.MIDDLE;break;case 2:n=a.mouseButtons.RIGHT;break;default:n=-1}switch(n){case THREE.MOUSE.DOLLY:if(!1===a.enableZoom)return;!function(e){E.set(e.clientX,e.clientY)}(e),s=i.DOLLY;break;case THREE.MOUSE.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===a.enablePan)return;k(e),s=i.PAN}else{if(!1===a.enableRotate)return;P(e),s=i.ROTATE}break;case THREE.MOUSE.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===a.enableRotate)return;P(e),s=i.ROTATE}else{if(!1===a.enablePan)return;k(e),s=i.PAN}break;default:s=i.NONE}s!==i.NONE&&(a.domElement.ownerDocument.addEventListener("pointermove",U),a.domElement.ownerDocument.addEventListener("pointerup",G),a.dispatchEvent(t))}(e)}}function U(e){if(!1!==a.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===a.enabled)return;switch(e.preventDefault(),s){case i.ROTATE:if(!1===a.enableRotate)return;!function(e){v.set(e.clientX,e.clientY),m.subVectors(v,h).multiplyScalar(a.rotateSpeed);const t=a.domElement;T(2*Math.PI*m.x/t.clientHeight),A(2*Math.PI*m.y/t.clientHeight),h.copy(v),a.update()}(e);break;case i.DOLLY:if(!1===a.enableZoom)return;!function(e){w.set(e.clientX,e.clientY),b.subVectors(w,E),b.y>0?C(_()):b.y<0&&L(_()),E.copy(w),a.update()}(e);break;case i.PAN:if(!1===a.enablePan)return;!function(e){g.set(e.clientX,e.clientY),y.subVectors(g,x).multiplyScalar(a.panSpeed),M(y.x,y.y),x.copy(g),a.update()}(e)}}(e)}}function G(e){switch(e.pointerType){case"mouse":case"pen":!function(e){if(a.domElement.ownerDocument.removeEventListener("pointermove",U),a.domElement.ownerDocument.removeEventListener("pointerup",G),!1===a.enabled)return;a.dispatchEvent(n),s=i.NONE}()}}function B(e){!1===a.enabled||!1===a.enableZoom||s!==i.NONE&&s!==i.ROTATE||(e.preventDefault(),a.dispatchEvent(t),function(e){e.deltaY<0?L(_()):e.deltaY>0&&C(_()),a.update()}(e),a.dispatchEvent(n))}function V(e){!1!==a.enabled&&!1!==a.enablePan&&function(e){let t=!1;switch(e.code){case a.keys.UP:M(0,a.keyPanSpeed),t=!0;break;case a.keys.BOTTOM:M(0,-a.keyPanSpeed),t=!0;break;case a.keys.LEFT:M(a.keyPanSpeed,0),t=!0;break;case a.keys.RIGHT:M(-a.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),a.update())}(e)}function W(e){if(!1!==a.enabled){switch(e.preventDefault(),e.touches.length){case 1:switch(a.touches.ONE){case THREE.TOUCH.ROTATE:if(!1===a.enableRotate)return;N(e),s=i.TOUCH_ROTATE;break;case THREE.TOUCH.PAN:if(!1===a.enablePan)return;H(e),s=i.TOUCH_PAN;break;default:s=i.NONE}break;case 2:switch(a.touches.TWO){case THREE.TOUCH.DOLLY_PAN:if(!1===a.enableZoom&&!1===a.enablePan)return;!function(e){a.enableZoom&&z(e),a.enablePan&&H(e)}(e),s=i.TOUCH_DOLLY_PAN;break;case THREE.TOUCH.DOLLY_ROTATE:if(!1===a.enableZoom&&!1===a.enableRotate)return;!function(e){a.enableZoom&&z(e),a.enableRotate&&N(e)}(e),s=i.TOUCH_DOLLY_ROTATE;break;default:s=i.NONE}break;default:s=i.NONE}s!==i.NONE&&a.dispatchEvent(t)}}function j(e){if(!1!==a.enabled)switch(e.preventDefault(),s){case i.TOUCH_ROTATE:if(!1===a.enableRotate)return;D(e),a.update();break;case i.TOUCH_PAN:if(!1===a.enablePan)return;F(e),a.update();break;case i.TOUCH_DOLLY_PAN:if(!1===a.enableZoom&&!1===a.enablePan)return;!function(e){a.enableZoom&&I(e),a.enablePan&&F(e)}(e),a.update();break;case i.TOUCH_DOLLY_ROTATE:if(!1===a.enableZoom&&!1===a.enableRotate)return;!function(e){a.enableZoom&&I(e),a.enableRotate&&D(e)}(e),a.update();break;default:s=i.NONE}}function q(e){!1!==a.enabled&&(a.dispatchEvent(n),s=i.NONE)}function X(e){!1!==a.enabled&&e.preventDefault()}a.domElement.addEventListener("contextmenu",X),a.domElement.addEventListener("pointerdown",O),a.domElement.addEventListener("wheel",B,{passive:!1}),a.domElement.addEventListener("touchstart",W,{passive:!1}),a.domElement.addEventListener("touchend",q),a.domElement.addEventListener("touchmove",j,{passive:!1}),this.update()}}THREE.MapControls=class extends r{constructor(e,t){super(e,t),this.screenSpacePanning=!1,this.mouseButtons.LEFT=THREE.MOUSE.PAN,this.mouseButtons.RIGHT=THREE.MOUSE.ROTATE,this.touches.ONE=THREE.TOUCH.PAN,this.touches.TWO=THREE.TOUCH.DOLLY_ROTATE}},THREE.OrbitControls=r}()},5100:()=>{THREE.OrthographicTrackballControls=function(e,t){var n=this,r=-1,o=0,a=1,i=2,s=3,l=4;this.object=e,this.domElement=void 0!==t?t:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.radius=0,this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.noRoll=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.keys=[65,83,68],this.target=new THREE.Vector3;var c=!0,f=r,u=r,d=new THREE.Vector3,p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector2,m=new THREE.Vector2,x=0,g=0,y=new THREE.Vector2,E=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom;var w={type:"change"},b={type:"start"},_={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}this.radius=.5*Math.min(this.screen.width,this.screen.height),this.left0=this.object.left,this.right0=this.object.right,this.top0=this.object.top,this.bottom0=this.object.bottom},this.handleEvent=function(e){"function"==typeof this[e.type]&&this[e.type](e)};var T,A,S,R,M,C,L=(T=new THREE.Vector2,function(e,t){return T.set((e-n.screen.left)/n.screen.width,(t-n.screen.top)/n.screen.height),T}),P=function(){var e=new THREE.Vector3,t=new THREE.Vector3,r=new THREE.Vector3;return function(o,a){r.set((o-.5*n.screen.width-n.screen.left)/n.radius,(.5*n.screen.height+n.screen.top-a)/n.radius,0);var i=r.length();return n.noRoll?i<Math.SQRT1_2?r.z=Math.sqrt(1-i*i):r.z=.5/i:i>1?r.normalize():r.z=Math.sqrt(1-i*i),d.copy(n.object.position).sub(n.target),e.copy(n.object.up).setLength(r.y),e.add(t.copy(n.object.up).cross(d).setLength(r.x)),e.add(d.setLength(r.z)),e}}();function k(e){!1!==n.enabled&&(window.removeEventListener("keydown",k),u=f,f===r&&(e.keyCode!==n.keys[o]||n.noRotate?e.keyCode!==n.keys[a]||n.noZoom?e.keyCode!==n.keys[i]||n.noPan||(f=i):f=a:f=o))}function N(e){!1!==n.enabled&&(f=u,window.addEventListener("keydown",k,!1))}function H(e){!1!==n.enabled&&(e.preventDefault(),e.stopPropagation(),f===r&&(f=e.button),f!==o||n.noRotate?f!==a||n.noZoom?f!==i||n.noPan||(y.copy(L(e.pageX,e.pageY)),E.copy(y)):(v.copy(L(e.pageX,e.pageY)),m.copy(v)):(p.copy(P(e.pageX,e.pageY)),h.copy(p)),document.addEventListener("mousemove",z,!1),document.addEventListener("mouseup",D,!1),n.dispatchEvent(b))}function z(e){!1!==n.enabled&&(e.preventDefault(),e.stopPropagation(),f!==o||n.noRotate?f!==a||n.noZoom?f!==i||n.noPan||E.copy(L(e.pageX,e.pageY)):m.copy(L(e.pageX,e.pageY)):h.copy(P(e.pageX,e.pageY)))}function D(e){!1!==n.enabled&&(e.preventDefault(),e.stopPropagation(),f=r,document.removeEventListener("mousemove",z),document.removeEventListener("mouseup",D),n.dispatchEvent(_))}function F(e){if(!1!==n.enabled){e.preventDefault(),e.stopPropagation();var t=0;e.wheelDelta?t=e.wheelDelta/40:e.detail&&(t=-e.detail/3),v.y+=.01*t,n.dispatchEvent(b),n.dispatchEvent(_)}}function I(e){if(!1!==n.enabled){switch(e.touches.length){case 1:f=s,p.copy(P(e.touches[0].pageX,e.touches[0].pageY)),h.copy(p);break;case 2:f=l;var t=e.touches[0].pageX-e.touches[1].pageX,o=e.touches[0].pageY-e.touches[1].pageY;g=x=Math.sqrt(t*t+o*o);var a=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;y.copy(L(a,i)),E.copy(y);break;default:f=r}n.dispatchEvent(b)}}function O(e){if(!1!==n.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:h.copy(P(e.touches[0].pageX,e.touches[0].pageY));break;case 2:var t=e.touches[0].pageX-e.touches[1].pageX,o=e.touches[0].pageY-e.touches[1].pageY;g=Math.sqrt(t*t+o*o);var a=(e.touches[0].pageX+e.touches[1].pageX)/2,i=(e.touches[0].pageY+e.touches[1].pageY)/2;E.copy(L(a,i));break;default:f=r}}function U(e){if(!1!==n.enabled){switch(e.touches.length){case 1:h.copy(P(e.touches[0].pageX,e.touches[0].pageY)),p.copy(h);break;case 2:x=g=0;var t=(e.touches[0].pageX+e.touches[1].pageX)/2,o=(e.touches[0].pageY+e.touches[1].pageY)/2;E.copy(L(t,o)),y.copy(E)}f=r,n.dispatchEvent(_)}}function G(e){e.preventDefault()}this.rotateCamera=(A=new THREE.Vector3,S=new THREE.Quaternion,function(){var e=Math.acos(p.dot(h)/p.length()/h.length());e&&(A.crossVectors(p,h).normalize(),e*=n.rotateSpeed,S.setFromAxisAngle(A,-e),d.applyQuaternion(S),n.object.up.applyQuaternion(S),h.applyQuaternion(S),n.staticMoving?p.copy(h):(S.setFromAxisAngle(A,e*(n.dynamicDampingFactor-1)),p.applyQuaternion(S)),c=!0)}),this.zoomCamera=function(){if(f===l){var e=g/x;x=g,n.object.zoom*=e,c=!0}else{e=1+(m.y-v.y)*n.zoomSpeed;Math.abs(e-1)>1e-6&&e>0&&(n.object.zoom/=e,n.staticMoving?v.copy(m):v.y+=(m.y-v.y)*this.dynamicDampingFactor,c=!0)}},this.panCamera=(R=new THREE.Vector2,M=new THREE.Vector3,C=new THREE.Vector3,function(){if(R.copy(E).sub(y),R.lengthSq()){var e=(n.object.right-n.object.left)/n.object.zoom,t=(n.object.top-n.object.bottom)/n.object.zoom;R.x*=e*n.panSpeed,R.y*=t*n.panSpeed,C.copy(d).cross(n.object.up).setLength(R.x),C.add(M.copy(n.object.up).setLength(R.y)),n.object.position.add(C),n.target.add(C),n.staticMoving?y.copy(E):y.add(R.subVectors(E,y).multiplyScalar(n.dynamicDampingFactor)),c=!0}}),this.update=function(){d.subVectors(n.object.position,n.target),n.noRotate||n.rotateCamera(),n.noZoom||(n.zoomCamera(),c&&n.object.updateProjectionMatrix()),n.noPan||n.panCamera(),n.object.position.addVectors(n.target,d),n.object.lookAt(n.target),c&&(n.dispatchEvent(w),c=!1)},this.reset=function(){f=r,u=r,n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.up.copy(n.up0),d.subVectors(n.object.position,n.target),n.object.left=n.left0,n.object.right=n.right0,n.object.top=n.top0,n.object.bottom=n.bottom0,n.object.lookAt(n.target),n.dispatchEvent(w),c=!1},this.disableEvents=function(){this.domElement.removeEventListener("contextmenu",G,!1),this.domElement.removeEventListener("mousedown",H,!1),this.domElement.removeEventListener("wheel",F,!1),this.domElement.removeEventListener("MozMousePixelScroll",F,!1),this.domElement.removeEventListener("touchstart",I,!1),this.domElement.removeEventListener("touchend",U,!1),this.domElement.removeEventListener("touchmove",O,!1),document.removeEventListener("mousemove",z,!1),document.removeEventListener("mouseup",D,!1),window.removeEventListener("keydown",k,!1),window.removeEventListener("keyup",N,!1)},this.dispose=this.disableEvents,this.enableEvents=function(){this.domElement.addEventListener("contextmenu",G,!1),this.domElement.addEventListener("mousedown",H,!1),this.domElement.addEventListener("wheel",F,!1),this.domElement.addEventListener("MozMousePixelScroll",F,!1),this.domElement.addEventListener("touchstart",I,!1),this.domElement.addEventListener("touchend",U,!1),this.domElement.addEventListener("touchmove",O,!1),window.addEventListener("keydown",k,!1),window.addEventListener("keyup",N,!1)},this.enableEvents(),this.handleResize(),this.update()},THREE.OrthographicTrackballControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.OrthographicTrackballControls.prototype.constructor=THREE.OrthographicTrackballControls},8726:()=>{!function(){class e extends THREE.Pass{constructor(e,t,n,r){super(),this.renderScene=t,this.renderCamera=n,this.selectedObjects=void 0!==r?r:[],this.visibleEdgeColor=new THREE.Color(1,1,1),this.hiddenEdgeColor=new THREE.Color(.1,.04,.02),this.edgeGlow=0,this.usePatternTexture=!1,this.edgeThickness=1,this.edgeStrength=3,this.downSampleRatio=2,this.pulsePeriod=0,this._visibilityCache=new Map,this.resolution=void 0!==e?new THREE.Vector2(e.x,e.y):new THREE.Vector2(256,256);const o={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat},a=Math.round(this.resolution.x/this.downSampleRatio),i=Math.round(this.resolution.y/this.downSampleRatio);this.maskBufferMaterial=new THREE.MeshBasicMaterial({color:16777215}),this.maskBufferMaterial.side=THREE.DoubleSide,this.renderTargetMaskBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,o),this.renderTargetMaskBuffer.texture.name="OutlinePass.mask",this.renderTargetMaskBuffer.texture.generateMipmaps=!1,this.depthMaterial=new THREE.MeshDepthMaterial,this.depthMaterial.side=THREE.DoubleSide,this.depthMaterial.depthPacking=THREE.RGBADepthPacking,this.depthMaterial.blending=THREE.NoBlending,this.prepareMaskMaterial=this.getPrepareMaskMaterial(),this.prepareMaskMaterial.side=THREE.DoubleSide,this.prepareMaskMaterial.fragmentShader=function(e,t){var n=t.isPerspectiveCamera?"perspective":"orthographic";return e.replace(/DEPTH_TO_VIEW_Z/g,n+"DepthToViewZ")}(this.prepareMaskMaterial.fragmentShader,this.renderCamera),this.renderTargetDepthBuffer=new THREE.WebGLRenderTarget(this.resolution.x,this.resolution.y,o),this.renderTargetDepthBuffer.texture.name="OutlinePass.depth",this.renderTargetDepthBuffer.texture.generateMipmaps=!1,this.renderTargetMaskDownSampleBuffer=new THREE.WebGLRenderTarget(a,i,o),this.renderTargetMaskDownSampleBuffer.texture.name="OutlinePass.depthDownSample",this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps=!1,this.renderTargetBlurBuffer1=new THREE.WebGLRenderTarget(a,i,o),this.renderTargetBlurBuffer1.texture.name="OutlinePass.blur1",this.renderTargetBlurBuffer1.texture.generateMipmaps=!1,this.renderTargetBlurBuffer2=new THREE.WebGLRenderTarget(Math.round(a/2),Math.round(i/2),o),this.renderTargetBlurBuffer2.texture.name="OutlinePass.blur2",this.renderTargetBlurBuffer2.texture.generateMipmaps=!1,this.edgeDetectionMaterial=this.getEdgeDetectionMaterial(),this.renderTargetEdgeBuffer1=new THREE.WebGLRenderTarget(a,i,o),this.renderTargetEdgeBuffer1.texture.name="OutlinePass.edge1",this.renderTargetEdgeBuffer1.texture.generateMipmaps=!1,this.renderTargetEdgeBuffer2=new THREE.WebGLRenderTarget(Math.round(a/2),Math.round(i/2),o),this.renderTargetEdgeBuffer2.texture.name="OutlinePass.edge2",this.renderTargetEdgeBuffer2.texture.generateMipmaps=!1;this.separableBlurMaterial1=this.getSeperableBlurMaterial(4),this.separableBlurMaterial1.uniforms.texSize.value.set(a,i),this.separableBlurMaterial1.uniforms.kernelRadius.value=1,this.separableBlurMaterial2=this.getSeperableBlurMaterial(4),this.separableBlurMaterial2.uniforms.texSize.value.set(Math.round(a/2),Math.round(i/2)),this.separableBlurMaterial2.uniforms.kernelRadius.value=4,this.overlayMaterial=this.getOverlayMaterial(),void 0===THREE.CopyShader&&console.error("THREE.OutlinePass relies on THREE.CopyShader");const s=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(s.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,blending:THREE.NoBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.fsQuad=new THREE.FullScreenQuad(null),this.tempPulseColor1=new THREE.Color,this.tempPulseColor2=new THREE.Color,this.textureMatrix=new THREE.Matrix4}dispose(){this.renderTargetMaskBuffer.dispose(),this.renderTargetDepthBuffer.dispose(),this.renderTargetMaskDownSampleBuffer.dispose(),this.renderTargetBlurBuffer1.dispose(),this.renderTargetBlurBuffer2.dispose(),this.renderTargetEdgeBuffer1.dispose(),this.renderTargetEdgeBuffer2.dispose()}setSize(e,t){this.renderTargetMaskBuffer.setSize(e,t),this.renderTargetDepthBuffer.setSize(e,t);let n=Math.round(e/this.downSampleRatio),r=Math.round(t/this.downSampleRatio);this.renderTargetMaskDownSampleBuffer.setSize(n,r),this.renderTargetBlurBuffer1.setSize(n,r),this.renderTargetEdgeBuffer1.setSize(n,r),this.separableBlurMaterial1.uniforms.texSize.value.set(n,r),n=Math.round(n/2),r=Math.round(r/2),this.renderTargetBlurBuffer2.setSize(n,r),this.renderTargetEdgeBuffer2.setSize(n,r),this.separableBlurMaterial2.uniforms.texSize.value.set(n,r)}changeVisibilityOfSelectedObjects(e){const t=this._visibilityCache;function n(n){n.isMesh&&(!0===e?n.visible=t.get(n):(t.set(n,n.visible),n.visible=e))}for(let e=0;e<this.selectedObjects.length;e++){this.selectedObjects[e].traverse(n)}}changeVisibilityOfNonSelectedObjects(e){const t=this._visibilityCache,n=[];function r(e){e.isMesh&&n.push(e)}for(let e=0;e<this.selectedObjects.length;e++){this.selectedObjects[e].traverse(r)}this.renderScene.traverse((function(r){if(r.isMesh||r.isSprite){let o=!1;for(let e=0;e<n.length;e++){if(n[e].id===r.id){o=!0;break}}if(!1===o){const n=r.visible;!1!==e&&!0!==t.get(r)||(r.visible=e),t.set(r,n)}}else(r.isPoints||r.isLine)&&(!0===e?r.visible=t.get(r):(t.set(r,r.visible),r.visible=e))}))}updateTextureMatrix(){this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.renderCamera.projectionMatrix),this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse)}render(t,n,r,o,a){if(this.selectedObjects.length>0){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const n=t.autoClear;t.autoClear=!1,a&&t.state.buffers.stencil.setTest(!1),t.setClearColor(16777215,1),this.changeVisibilityOfSelectedObjects(!1);const o=this.renderScene.background;if(this.renderScene.background=null,this.renderScene.overrideMaterial=this.depthMaterial,t.setRenderTarget(this.renderTargetDepthBuffer),t.clear(),t.render(this.renderScene,this.renderCamera),this.changeVisibilityOfSelectedObjects(!0),this._visibilityCache.clear(),this.updateTextureMatrix(),this.changeVisibilityOfNonSelectedObjects(!1),this.renderScene.overrideMaterial=this.prepareMaskMaterial,this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(this.renderCamera.near,this.renderCamera.far),this.prepareMaskMaterial.uniforms.depthTexture.value=this.renderTargetDepthBuffer.texture,this.prepareMaskMaterial.uniforms.textureMatrix.value=this.textureMatrix,t.setRenderTarget(this.renderTargetMaskBuffer),t.clear(),t.render(this.renderScene,this.renderCamera),this.renderScene.overrideMaterial=null,this.changeVisibilityOfNonSelectedObjects(!0),this._visibilityCache.clear(),this.renderScene.background=o,this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetMaskBuffer.texture,t.setRenderTarget(this.renderTargetMaskDownSampleBuffer),t.clear(),this.fsQuad.render(t),this.tempPulseColor1.copy(this.visibleEdgeColor),this.tempPulseColor2.copy(this.hiddenEdgeColor),this.pulsePeriod>0){const e=.625+.75*Math.cos(.01*performance.now()/this.pulsePeriod)/2;this.tempPulseColor1.multiplyScalar(e),this.tempPulseColor2.multiplyScalar(e)}this.fsQuad.material=this.edgeDetectionMaterial,this.edgeDetectionMaterial.uniforms.maskTexture.value=this.renderTargetMaskDownSampleBuffer.texture,this.edgeDetectionMaterial.uniforms.texSize.value.set(this.renderTargetMaskDownSampleBuffer.width,this.renderTargetMaskDownSampleBuffer.height),this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value=this.tempPulseColor1,this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value=this.tempPulseColor2,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial1,this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=e.BlurDirectionX,this.separableBlurMaterial1.uniforms.kernelRadius.value=this.edgeThickness,t.setRenderTarget(this.renderTargetBlurBuffer1),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial1.uniforms.colorTexture.value=this.renderTargetBlurBuffer1.texture,this.separableBlurMaterial1.uniforms.direction.value=e.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer1),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.separableBlurMaterial2,this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetEdgeBuffer1.texture,this.separableBlurMaterial2.uniforms.direction.value=e.BlurDirectionX,t.setRenderTarget(this.renderTargetBlurBuffer2),t.clear(),this.fsQuad.render(t),this.separableBlurMaterial2.uniforms.colorTexture.value=this.renderTargetBlurBuffer2.texture,this.separableBlurMaterial2.uniforms.direction.value=e.BlurDirectionY,t.setRenderTarget(this.renderTargetEdgeBuffer2),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.overlayMaterial,this.overlayMaterial.uniforms.maskTexture.value=this.renderTargetMaskBuffer.texture,this.overlayMaterial.uniforms.edgeTexture1.value=this.renderTargetEdgeBuffer1.texture,this.overlayMaterial.uniforms.edgeTexture2.value=this.renderTargetEdgeBuffer2.texture,this.overlayMaterial.uniforms.patternTexture.value=this.patternTexture,this.overlayMaterial.uniforms.edgeStrength.value=this.edgeStrength,this.overlayMaterial.uniforms.edgeGlow.value=this.edgeGlow,this.overlayMaterial.uniforms.usePatternTexture.value=this.usePatternTexture,a&&t.state.buffers.stencil.setTest(!0),t.setRenderTarget(r),this.fsQuad.render(t),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=n}this.renderToScreen&&(this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=r.texture,t.setRenderTarget(null),this.fsQuad.render(t))}getPrepareMaskMaterial(){return new THREE.ShaderMaterial({uniforms:{depthTexture:{value:null},cameraNearFar:{value:new THREE.Vector2(.5,.5)},textureMatrix:{value:null}},vertexShader:"#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",fragmentShader:"#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}"})}getEdgeDetectionMaterial(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},visibleEdgeColor:{value:new THREE.Vector3(1,1,1)},hiddenEdgeColor:{value:new THREE.Vector3(1,1,1)}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}"})}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{MAX_RADIUS:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)},kernelRadius:{value:1}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}"})}getOverlayMaterial(){return new THREE.ShaderMaterial({uniforms:{maskTexture:{value:null},edgeTexture1:{value:null},edgeTexture2:{value:null},patternTexture:{value:null},edgeStrength:{value:1},edgeGlow:{value:1},usePatternTexture:{value:0}},vertexShader:"varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0})}}e.BlurDirectionX=new THREE.Vector2(1,0),e.BlurDirectionY=new THREE.Vector2(0,1),THREE.OutlinePass=e}()},7181:()=>{THREE.PLYExporter=class{parse(e,t,n){function r(t){e.traverse((function(e){if(!0===e.isMesh){const n=e,r=n.geometry;if(!0!==r.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");!0===r.hasAttribute("position")&&t(n,r)}}))}t&&"object"==typeof t&&(console.warn('THREE.PLYExporter: The options parameter is now the third argument to the "parse" function. See the documentation for the new API.'),n=t,t=void 0);const o=(n=Object.assign({binary:!1,excludeAttributes:[],littleEndian:!1},n)).excludeAttributes;let a=!1,i=!1,s=!1,l=0,c=0;e.traverse((function(e){if(!0===e.isMesh){const t=e.geometry;if(!0!==t.isBufferGeometry)throw new Error("THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.");const n=t.getAttribute("position"),r=t.getAttribute("normal"),o=t.getAttribute("uv"),f=t.getAttribute("color"),u=t.getIndex();if(void 0===n)return;l+=n.count,c+=u?u.count/3:n.count/3,void 0!==r&&(a=!0),void 0!==o&&(s=!0),void 0!==f&&(i=!0)}}));const f=-1===o.indexOf("index");if(a=a&&-1===o.indexOf("normal"),i=i&&-1===o.indexOf("color"),s=s&&-1===o.indexOf("uv"),f&&c!==Math.floor(c))return console.error("PLYExporter: Failed to generate a valid PLY file with triangle indices because the number of indices is not divisible by 3."),null;let u=`ply\nformat ${n.binary?n.littleEndian?"binary_little_endian":"binary_big_endian":"ascii"} 1.0\nelement vertex ${l}\nproperty float x\nproperty float y\nproperty float z\n`;!0===a&&(u+="property float nx\nproperty float ny\nproperty float nz\n"),!0===s&&(u+="property float s\nproperty float t\n"),!0===i&&(u+="property uchar red\nproperty uchar green\nproperty uchar blue\n"),!0===f&&(u+=`element face ${c}\nproperty list uchar int vertex_index\n`),u+="end_header\n";const d=new THREE.Vector3,p=new THREE.Matrix3;let h=null;if(!0===n.binary){const e=(new TextEncoder).encode(u),t=l*(12+(a?12:0)+(i?3:0)+(s?8:0)),o=f?13*c:0,v=new DataView(new ArrayBuffer(e.length+t+o));new Uint8Array(v.buffer).set(e,0);let m=e.length,x=e.length+t,g=0;r((function(e,t){const r=t.getAttribute("position"),o=t.getAttribute("normal"),l=t.getAttribute("uv"),c=t.getAttribute("color"),u=t.getIndex();p.getNormalMatrix(e.matrixWorld);for(let t=0,f=r.count;t<f;t++)d.x=r.getX(t),d.y=r.getY(t),d.z=r.getZ(t),d.applyMatrix4(e.matrixWorld),v.setFloat32(m,d.x,n.littleEndian),m+=4,v.setFloat32(m,d.y,n.littleEndian),m+=4,v.setFloat32(m,d.z,n.littleEndian),m+=4,!0===a&&(null!=o?(d.x=o.getX(t),d.y=o.getY(t),d.z=o.getZ(t),d.applyMatrix3(p).normalize(),v.setFloat32(m,d.x,n.littleEndian),m+=4,v.setFloat32(m,d.y,n.littleEndian),m+=4,v.setFloat32(m,d.z,n.littleEndian),m+=4):(v.setFloat32(m,0,n.littleEndian),m+=4,v.setFloat32(m,0,n.littleEndian),m+=4,v.setFloat32(m,0,n.littleEndian),m+=4)),!0===s&&(null!=l?(v.setFloat32(m,l.getX(t),n.littleEndian),m+=4,v.setFloat32(m,l.getY(t),n.littleEndian),m+=4):!1!==s&&(v.setFloat32(m,0,n.littleEndian),m+=4,v.setFloat32(m,0,n.littleEndian),m+=4)),!0===i&&(null!=c?(v.setUint8(m,Math.floor(255*c.getX(t))),m+=1,v.setUint8(m,Math.floor(255*c.getY(t))),m+=1,v.setUint8(m,Math.floor(255*c.getZ(t))),m+=1):(v.setUint8(m,255),m+=1,v.setUint8(m,255),m+=1,v.setUint8(m,255),m+=1));if(!0===f)if(null!==u)for(let e=0,t=u.count;e<t;e+=3)v.setUint8(x,3),x+=1,v.setUint32(x,u.getX(e+0)+g,n.littleEndian),x+=4,v.setUint32(x,u.getX(e+1)+g,n.littleEndian),x+=4,v.setUint32(x,u.getX(e+2)+g,n.littleEndian),x+=4;else for(let e=0,t=r.count;e<t;e+=3)v.setUint8(x,3),x+=1,v.setUint32(x,g+e,n.littleEndian),x+=4,v.setUint32(x,g+e+1,n.littleEndian),x+=4,v.setUint32(x,g+e+2,n.littleEndian),x+=4;g+=r.count})),h=v.buffer}else{let e=0,t="",n="";r((function(r,o){const l=o.getAttribute("position"),u=o.getAttribute("normal"),h=o.getAttribute("uv"),v=o.getAttribute("color"),m=o.getIndex();p.getNormalMatrix(r.matrixWorld);for(let e=0,n=l.count;e<n;e++){d.x=l.getX(e),d.y=l.getY(e),d.z=l.getZ(e),d.applyMatrix4(r.matrixWorld);let n=d.x+" "+d.y+" "+d.z;!0===a&&(null!=u?(d.x=u.getX(e),d.y=u.getY(e),d.z=u.getZ(e),d.applyMatrix3(p).normalize(),n+=" "+d.x+" "+d.y+" "+d.z):n+=" 0 0 0"),!0===s&&(null!=h?n+=" "+h.getX(e)+" "+h.getY(e):!1!==s&&(n+=" 0 0")),!0===i&&(n+=null!=v?" "+Math.floor(255*v.getX(e))+" "+Math.floor(255*v.getY(e))+" "+Math.floor(255*v.getZ(e)):" 255 255 255"),t+=n+"\n"}if(!0===f){if(null!==m)for(let t=0,r=m.count;t<r;t+=3)n+=`3 ${m.getX(t+0)+e}`,n+=` ${m.getX(t+1)+e}`,n+=` ${m.getX(t+2)+e}\n`;else for(let t=0,r=l.count;t<r;t+=3)n+=`3 ${e+t} ${e+t+1} ${e+t+2}\n`;c+=m?m.count/3:l.count/3}e+=l.count})),h=`${u}${t}${f?`${n}\n`:"\n"}`}return"function"==typeof t&&requestAnimationFrame((()=>t(h))),h}}},8085:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.propertyNameMapping={}}load(e,t,n,r){const o=this,a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}setPropertyNameMapping(e){this.propertyNameMapping=e}parse(e){function t(e){let t="",n=0;const r=/ply([\s\S]*)end_header\r?\n/.exec(e);null!==r&&(t=r[1],n=new Blob([r[0]]).size);const o={comments:[],elements:[],headerLength:n,objInfo:""},a=t.split("\n");let i;function s(e,t){const n={type:e[0]};return"list"===n.type?(n.name=e[3],n.countType=e[1],n.itemType=e[2]):n.name=e[1],n.name in t&&(n.name=t[n.name]),n}for(let e=0;e<a.length;e++){let t=a[e];if(t=t.trim(),""===t)continue;const n=t.split(/\s+/),r=n.shift();switch(t=n.join(" "),r){case"format":o.format=n[0],o.version=n[1];break;case"comment":o.comments.push(t);break;case"element":void 0!==i&&o.elements.push(i),i={},i.name=n[0],i.count=parseInt(n[1]),i.properties=[];break;case"property":i.properties.push(s(n,f.propertyNameMapping));break;case"obj_info":o.objInfo=t;break;default:console.log("unhandled",r,n)}}return void 0!==i&&o.elements.push(i),o}function n(e,t){switch(t){case"char":case"uchar":case"short":case"ushort":case"int":case"uint":case"int8":case"uint8":case"int16":case"uint16":case"int32":case"uint32":return parseInt(e);case"float":case"double":case"float32":case"float64":return parseFloat(e)}}function r(e,t){const r=t.split(/\s+/),o={};for(let t=0;t<e.length;t++)if("list"===e[t].type){const a=[],i=n(r.shift(),e[t].countType);for(let o=0;o<i;o++)a.push(n(r.shift(),e[t].itemType));o[e[t].name]=a}else o[e[t].name]=n(r.shift(),e[t].type);return o}function o(e,t){const n={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]};let o;let s="";null!==(o=/end_header\s([\s\S]*)$/.exec(e))&&(s=o[1]);const l=s.split("\n");let c=0,f=0;for(let e=0;e<l.length;e++){let o=l[e];if(o=o.trim(),""===o)continue;f>=t.elements[c].count&&(c++,f=0);const a=r(t.elements[c].properties,o);i(n,t.elements[c].name,a),f++}return a(n)}function a(e){let t=new THREE.BufferGeometry;return e.indices.length>0&&t.setIndex(e.indices),t.setAttribute("position",new THREE.Float32BufferAttribute(e.vertices,3)),e.normals.length>0&&t.setAttribute("normal",new THREE.Float32BufferAttribute(e.normals,3)),e.uvs.length>0&&t.setAttribute("uv",new THREE.Float32BufferAttribute(e.uvs,2)),e.colors.length>0&&t.setAttribute("color",new THREE.Float32BufferAttribute(e.colors,3)),e.faceVertexUvs.length>0&&(t=t.toNonIndexed(),t.setAttribute("uv",new THREE.Float32BufferAttribute(e.faceVertexUvs,2))),t.computeBoundingSphere(),t}function i(e,t,n){if("vertex"===t)e.vertices.push(n.x,n.y,n.z),"nx"in n&&"ny"in n&&"nz"in n&&e.normals.push(n.nx,n.ny,n.nz),"s"in n&&"t"in n&&e.uvs.push(n.s,n.t),"red"in n&&"green"in n&&"blue"in n&&e.colors.push(n.red/255,n.green/255,n.blue/255);else if("face"===t){const t=n.vertex_indices||n.vertex_index,r=n.texcoord;3===t.length?(e.indices.push(t[0],t[1],t[2]),r&&6===r.length&&(e.faceVertexUvs.push(r[0],r[1]),e.faceVertexUvs.push(r[2],r[3]),e.faceVertexUvs.push(r[4],r[5]))):4===t.length&&(e.indices.push(t[0],t[1],t[3]),e.indices.push(t[1],t[2],t[3]))}}function s(e,t,n,r){switch(n){case"int8":case"char":return[e.getInt8(t),1];case"uint8":case"uchar":return[e.getUint8(t),1];case"int16":case"short":return[e.getInt16(t,r),2];case"uint16":case"ushort":return[e.getUint16(t,r),2];case"int32":case"int":return[e.getInt32(t,r),4];case"uint32":case"uint":return[e.getUint32(t,r),4];case"float32":case"float":return[e.getFloat32(t,r),4];case"float64":case"double":return[e.getFloat64(t,r),8]}}function l(e,t,n,r){const o={};let a,i=0;for(let l=0;l<n.length;l++)if("list"===n[l].type){const c=[];a=s(e,t+i,n[l].countType,r);const f=a[0];i+=a[1];for(let o=0;o<f;o++)a=s(e,t+i,n[l].itemType,r),c.push(a[0]),i+=a[1];o[n[l].name]=c}else a=s(e,t+i,n[l].type,r),o[n[l].name]=a[0],i+=a[1];return[o,i]}let c;const f=this;if(e instanceof ArrayBuffer){const n=THREE.LoaderUtils.decodeText(new Uint8Array(e)),r=t(n);c="ascii"===r.format?o(n,r):function(e,t){const n={indices:[],vertices:[],normals:[],uvs:[],faceVertexUvs:[],colors:[]},r="binary_little_endian"===t.format,o=new DataView(e,t.headerLength);let s,c=0;for(let e=0;e<t.elements.length;e++)for(let a=0;a<t.elements[e].count;a++){s=l(o,c,t.elements[e].properties,r),c+=s[1];const a=s[0];i(n,t.elements[e].name,a)}return a(n)}(e,r)}else c=o(e,t(e));return c}}THREE.PLYLoader=e}()},6716:()=>{THREE.ParallaxBarrierEffect=class{constructor(e){const t=new THREE.OrthographicCamera(-1,1,1,-1,0,1),n=new THREE.Scene,r=new THREE.StereoCamera,o={minFilter:THREE.LinearFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat},a=new THREE.WebGLRenderTarget(512,512,o),i=new THREE.WebGLRenderTarget(512,512,o),s=new THREE.ShaderMaterial({uniforms:{mapLeft:{value:a.texture},mapRight:{value:i.texture}},vertexShader:["varying vec2 vUv;","void main() {","\tvUv = vec2( uv.x, uv.y );","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D mapLeft;","uniform sampler2D mapRight;","varying vec2 vUv;","void main() {","\tvec2 uv = vUv;","\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {","\t\tgl_FragColor = texture2D( mapLeft, uv );","\t} else {","\t\tgl_FragColor = texture2D( mapRight, uv );","\t}","}"].join("\n")}),l=new THREE.Mesh(new THREE.PlaneGeometry(2,2),s);n.add(l),this.setSize=function(t,n){e.setSize(t,n);const r=e.getPixelRatio();a.setSize(t*r,n*r),i.setSize(t*r,n*r)},this.render=function(o,s){o.updateMatrixWorld(),null===s.parent&&s.updateMatrixWorld(),r.update(s),e.setRenderTarget(a),e.clear(),e.render(o,r.cameraL),e.setRenderTarget(i),e.clear(),e.render(o,r.cameraR),e.setRenderTarget(null),e.render(n,t)}}}},8721:()=>{class e{constructor(e,t,n){this.checkCompatibility(n),this.renderer=n,this.size=e||128,this.resolution=new THREE.Vector2(this.size,this.size),this.rt_1=new THREE.WebGLRenderTarget(this.size,this.size,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,type:THREE.FloatType,stencilBuffer:!1}),this.rt_2=this.rt_1.clone(),this.rt_3=this.rt_1.clone(),this.counter=0,this.texturePass=this.createTexturePassProgram(),this.simulatePass=this.createSimulatePassProgram(t),this.boundTextures=[],this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.mesh=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2)),this.scene.add(this.mesh)}checkCompatibility(e){var t=e.getContext();null!==t.getExtension("OES_texture_float")?0!==t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS)||this.onError("Vertex Shader Textures don't work"):this.onError("No Float Textures")}onError(e){console.log(e)}createDebugScene(){var e=new THREE.Object3D;e.position.z=0;var t,n=new THREE.PlaneBufferGeometry(100,100);return(t=new THREE.Mesh(n,new THREE.MeshBasicMaterial({map:this.rt_1}))).position.set(-105,0,0),e.add(t),(t=new THREE.Mesh(n,new THREE.MeshBasicMaterial({map:this.rt_2}))).position.set(0,0,0),e.add(t),(t=new THREE.Mesh(n,new THREE.MeshBasicMaterial({map:this.rt_3}))).position.set(105,0,0),e.add(t),e}removeDebugScene(e){e.remove(this.debugScene)}addDebugScene(e){e.add(this.debugScene)}createTexturePassProgram(){return new THREE.ShaderMaterial({uniforms:{texture:{type:"t",value:null}},vertexShader:this.VSPass,fragmentShader:this.FSPass})}createSimulatePassProgram(e){var t={t_oPos:{type:"t",value:null},t_pos:{type:"t",value:null},resolution:{type:"v2",value:this.resolution}};return new THREE.ShaderMaterial({uniforms:t,vertexShader:this.VSPass,fragmentShader:e})}update(){var e=this.counter%3;0==e?(this.simulatePass.uniforms.t_oPos.value=this.rt_1.texture,this.simulatePass.uniforms.t_pos.value=this.rt_2.texture,this.pass(this.simulatePass,this.rt_3),this.ooOutput=this.rt_1.texture,this.oOutput=this.rt_2.texture,this.output=this.rt_3.texture):1==e?(this.simulatePass.uniforms.t_oPos.value=this.rt_2.texture,this.simulatePass.uniforms.t_pos.value=this.rt_3.texture,this.pass(this.simulatePass,this.rt_1),this.ooOutput=this.rt_2.texture,this.oOutput=this.rt_3.texture,this.output=this.rt_1.texture):2==e&&(this.simulatePass.uniforms.t_oPos.value=this.rt_3.texture,this.simulatePass.uniforms.t_pos.value=this.rt_1.texture,this.pass(this.simulatePass,this.rt_2),this.ooOutput=this.rt_3.texture,this.oOutput=this.rt_1.texture,this.output=this.rt_2.texture),this.counter++,this.bindTextures()}render(e,t,n){this.renderer.setRenderTarget(n),this.renderer.render(e,t)}pass(e,t){this.mesh.material=e,this.renderer.setRenderTarget(t),this.renderer.render(this.scene,this.camera)}out(e){this.mesh.material=e.material,this.renderer.render(this.scene,this.camera)}setUniforms(e){for(var t in e)this.simulatePass.uniforms[t]=e[t];this.simulatePass.uniforms.t_pos={type:"t",value:null},this.simulatePass.uniforms.t_oPos={type:"t",value:null},this.simulatePass.uniforms.resolution={type:"v2",value:this.resolution}}setUniform(e,t){this.simulatePass.uniforms[e]=t}reset(e){this.texture=e,this.texturePass.uniforms.texture.value=e,this.pass(this.texturePass,this.rt_1),this.pass(this.texturePass,this.rt_2),this.pass(this.texturePass,this.rt_3)}passTexture(e,t){this.texturePass.uniforms.texture.value=e,this.pass(this.texturePass,t)}resetRand(e,t,n,r){e=e||100,t=t||0,n=n||0,r=r||0;for(var o=new Float32Array(this.size*this.size*4),a=0;a<o.length;a+=4)o[a+0]=t+(Math.random()-.5)*e,o[a+1]=n+(Math.random()-.5)*e,o[a+2]=r+(Math.random()-.5)*e,o[a+3]=100;var i=new THREE.DataTexture(o,this.size,this.size,THREE.RGBAFormat,THREE.FloatType);i.minFilter=THREE.NearestFilter,i.magFilter=THREE.NearestFilter,i.needsUpdate=!0,this.reset(i)}addBoundTexture(e,t){this.boundTextures.push([e,t])}bindTextures(){for(var e=0;e<this.boundTextures.length;e++){var t=this.boundTextures[e][0],n=this.boundTextures[e][1];t.value=this[n]}}}e.prototype.VSPass=["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = vec4( position, 1.0 );","}"].join("\n"),e.prototype.FSPass=["uniform sampler2D uTexture;","varying vec2 vUv;","void main() {","  vec4 c = texture2D( uTexture , vUv );","  gl_FragColor = c;","}"].join("\n"),e.prototype.isPhysicsRenderer=!0,THREE.PhysicsRenderer=e},4419:()=>{!function(){class e extends THREE.DataTextureLoader{constructor(e){super(e),this.type=THREE.UnsignedByteType}parse(e){const t=function(e,t){switch(e){case 1:console.error("THREE.RGBELoader Read Error: "+(t||""));break;case 2:console.error("THREE.RGBELoader Write Error: "+(t||""));break;case 3:console.error("THREE.RGBELoader Bad File Format: "+(t||""));break;default:case 4:console.error("THREE.RGBELoader: Error: "+(t||""))}return-1},n=function(e,t,n){t=t||1024;let r=e.pos,o=-1,a=0,i="",s=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));for(;0>(o=s.indexOf("\n"))&&a<t&&r<e.byteLength;)i+=s,a+=s.length,r+=128,s+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(r,r+128)));return-1<o&&(!1!==n&&(e.pos+=a+o+1),i+s.slice(0,o))},r=function(e,t,n,r){const o=e[t+3],a=Math.pow(2,o-128)/255;n[r+0]=e[t+0]*a,n[r+1]=e[t+1]*a,n[r+2]=e[t+2]*a},o=function(e,t,n,r){const o=e[t+3],a=Math.pow(2,o-128)/255;n[r+0]=THREE.DataUtils.toHalfFloat(e[t+0]*a),n[r+1]=THREE.DataUtils.toHalfFloat(e[t+1]*a),n[r+2]=THREE.DataUtils.toHalfFloat(e[t+2]*a)},a=new Uint8Array(e);a.pos=0;const i=function(e){const r=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*FORMAT=(\S+)\s*$/,i=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,s={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let l,c;if(e.pos>=e.byteLength||!(l=n(e)))return t(1,"no header found");if(!(c=l.match(/^#\?(\S+)/)))return t(3,"bad initial token");for(s.valid|=1,s.programtype=c[1],s.string+=l+"\n";l=n(e),!1!==l;)if(s.string+=l+"\n","#"!==l.charAt(0)){if((c=l.match(r))&&(s.gamma=parseFloat(c[1],10)),(c=l.match(o))&&(s.exposure=parseFloat(c[1],10)),(c=l.match(a))&&(s.valid|=2,s.format=c[1]),(c=l.match(i))&&(s.valid|=4,s.height=parseInt(c[1],10),s.width=parseInt(c[2],10)),2&s.valid&&4&s.valid)break}else s.comments+=l+"\n";return 2&s.valid?4&s.valid?s:t(3,"missing image size specifier"):t(3,"missing format specifier")}(a);if(-1!==i){const e=i.width,n=i.height,s=function(e,n,r){const o=n;if(o<8||o>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);if(o!==(e[2]<<8|e[3]))return t(3,"wrong scanline width");const a=new Uint8Array(4*n*r);if(!a.length)return t(4,"unable to allocate buffer space");let i=0,s=0;const l=4*o,c=new Uint8Array(4),f=new Uint8Array(l);let u=r;for(;u>0&&s<e.byteLength;){if(s+4>e.byteLength)return t(1);if(c[0]=e[s++],c[1]=e[s++],c[2]=e[s++],c[3]=e[s++],2!=c[0]||2!=c[1]||(c[2]<<8|c[3])!=o)return t(3,"bad rgbe scanline format");let n,r=0;for(;r<l&&s<e.byteLength;){n=e[s++];const o=n>128;if(o&&(n-=128),0===n||r+n>l)return t(3,"bad scanline data");if(o){const t=e[s++];for(let e=0;e<n;e++)f[r++]=t}else f.set(e.subarray(s,s+n),r),r+=n,s+=n}const d=o;for(let e=0;e<d;e++){let t=0;a[i]=f[e+t],t+=o,a[i+1]=f[e+t],t+=o,a[i+2]=f[e+t],t+=o,a[i+3]=f[e+t],i+=4}u--}return a}(a.subarray(a.pos),e,n);if(-1!==s){let t,a,l,c;switch(this.type){case THREE.UnsignedByteType:t=s,a=THREE.RGBEFormat,l=THREE.UnsignedByteType;break;case THREE.FloatType:c=s.length/4*3;const e=new Float32Array(c);for(let t=0;t<c;t++)r(s,4*t,e,3*t);t=e,a=THREE.RGBFormat,l=THREE.FloatType;break;case THREE.HalfFloatType:c=s.length/4*3;const n=new Uint16Array(c);for(let e=0;e<c;e++)o(s,4*e,n,3*e);t=n,a=THREE.RGBFormat,l=THREE.HalfFloatType;break;default:console.error("THREE.RGBELoader: unsupported type: ",this.type)}return{width:e,height:n,data:t,header:i.string,gamma:i.gamma,exposure:i.exposure,format:a,type:l}}}return null}setDataType(e){return this.type=e,this}load(e,t,n,r){return super.load(e,(function(e,n){switch(e.type){case THREE.UnsignedByteType:e.encoding=THREE.RGBEEncoding,e.minFilter=THREE.NearestFilter,e.magFilter=THREE.NearestFilter,e.generateMipmaps=!1,e.flipY=!0;break;case THREE.FloatType:case THREE.HalfFloatType:e.encoding=THREE.LinearEncoding,e.minFilter=THREE.LinearFilter,e.magFilter=THREE.LinearFilter,e.generateMipmaps=!1,e.flipY=!0}t&&t(e,n)}),n,r)}}THREE.RGBELoader=e}()},6288:()=>{!function(){class e extends THREE.Mesh{constructor(t,n={}){super(t),this.type="Reflector";const r=this,o=void 0!==n.color?new THREE.Color(n.color):new THREE.Color(8355711),a=n.textureWidth||512,i=n.textureHeight||512,s=n.clipBias||0,l=n.shader||e.ReflectorShader,c=new THREE.Plane,f=new THREE.Vector3,u=new THREE.Vector3,d=new THREE.Vector3,p=new THREE.Matrix4,h=new THREE.Vector3(0,0,-1),v=new THREE.Vector4,m=new THREE.Vector3,x=new THREE.Vector3,g=new THREE.Vector4,y=new THREE.Matrix4,E=new THREE.PerspectiveCamera,w={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat},b=new THREE.WebGLRenderTarget(a,i,w);THREE.MathUtils.isPowerOfTwo(a)&&THREE.MathUtils.isPowerOfTwo(i)||(b.texture.generateMipmaps=!1);const _=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(l.uniforms),fragmentShader:l.fragmentShader,vertexShader:l.vertexShader});_.uniforms.tDiffuse.value=b.texture,_.uniforms.color.value=o,_.uniforms.textureMatrix.value=y,this.material=_,this.onBeforeRender=function(e,t,n){if(u.setFromMatrixPosition(r.matrixWorld),d.setFromMatrixPosition(n.matrixWorld),p.extractRotation(r.matrixWorld),f.set(0,0,1),f.applyMatrix4(p),m.subVectors(u,d),m.dot(f)>0)return;m.reflect(f).negate(),m.add(u),p.extractRotation(n.matrixWorld),h.set(0,0,-1),h.applyMatrix4(p),h.add(d),x.subVectors(u,h),x.reflect(f).negate(),x.add(u),E.position.copy(m),E.up.set(0,1,0),E.up.applyMatrix4(p),E.up.reflect(f),E.lookAt(x),E.far=n.far,E.updateMatrixWorld(),E.projectionMatrix.copy(n.projectionMatrix),y.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),y.multiply(E.projectionMatrix),y.multiply(E.matrixWorldInverse),y.multiply(r.matrixWorld),c.setFromNormalAndCoplanarPoint(f,u),c.applyMatrix4(E.matrixWorldInverse),v.set(c.normal.x,c.normal.y,c.normal.z,c.constant);const o=E.projectionMatrix;g.x=(Math.sign(v.x)+o.elements[8])/o.elements[0],g.y=(Math.sign(v.y)+o.elements[9])/o.elements[5],g.z=-1,g.w=(1+o.elements[10])/o.elements[14],v.multiplyScalar(2/v.dot(g)),o.elements[2]=v.x,o.elements[6]=v.y,o.elements[10]=v.z+1-s,o.elements[14]=v.w,b.texture.encoding=THREE.LinearEncoding,r.visible=!1;const a=e.getRenderTarget(),i=e.xr.enabled,l=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(b),e.state.buffers.depth.setMask(!0),!1===e.autoClear&&e.clear(),e.render(t,E),e.xr.enabled=i,e.shadowMap.autoUpdate=l,e.setRenderTarget(a);const w=n.viewport;void 0!==w&&e.state.viewport(w),r.visible=!0},this.getRenderTarget=function(){return b}}}e.prototype.isReflector=!0,e.ReflectorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},THREE.Reflector=e}()},822:()=>{!function(){class e extends THREE.Mesh{constructor(t,n={}){super(t),this.type="Refractor";const r=this,o=void 0!==n.color?new THREE.Color(n.color):new THREE.Color(8355711),a=n.textureWidth||512,i=n.textureHeight||512,s=n.clipBias||0,l=n.shader||e.RefractorShader,c=new THREE.PerspectiveCamera;c.matrixAutoUpdate=!1,c.userData.refractor=!0;const f=new THREE.Plane,u=new THREE.Matrix4,d={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat},p=new THREE.WebGLRenderTarget(a,i,d);THREE.MathUtils.isPowerOfTwo(a)&&THREE.MathUtils.isPowerOfTwo(i)||(p.texture.generateMipmaps=!1),this.material=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(l.uniforms),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,transparent:!0}),this.material.uniforms.color.value=o,this.material.uniforms.tDiffuse.value=p.texture,this.material.uniforms.textureMatrix.value=u;!function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Matrix4,r=new THREE.Vector3,o=new THREE.Vector3}();const h=function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Quaternion,o=new THREE.Vector3;return function(){r.matrixWorld.decompose(t,n,o),e.set(0,0,1).applyQuaternion(n).normalize(),e.negate(),f.setFromNormalAndCoplanarPoint(e,t)}}(),v=function(){const e=new THREE.Plane,t=new THREE.Vector4,n=new THREE.Vector4;return function(r){c.matrixWorld.copy(r.matrixWorld),c.matrixWorldInverse.copy(c.matrixWorld).invert(),c.projectionMatrix.copy(r.projectionMatrix),c.far=r.far,e.copy(f),e.applyMatrix4(c.matrixWorldInverse),t.set(e.normal.x,e.normal.y,e.normal.z,e.constant);const o=c.projectionMatrix;n.x=(Math.sign(t.x)+o.elements[8])/o.elements[0],n.y=(Math.sign(t.y)+o.elements[9])/o.elements[5],n.z=-1,n.w=(1+o.elements[10])/o.elements[14],t.multiplyScalar(2/t.dot(n)),o.elements[2]=t.x,o.elements[6]=t.y,o.elements[10]=t.z+1-s,o.elements[14]=t.w}}();this.onBeforeRender=function(e,t,n){p.texture.encoding=e.outputEncoding,!0!==n.userData.refractor&&(h(),function(e){u.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),u.multiply(e.projectionMatrix),u.multiply(e.matrixWorldInverse),u.multiply(r.matrixWorld)}(n),v(n),function(e,t,n){r.visible=!1;const o=e.getRenderTarget(),a=e.xr.enabled,i=e.shadowMap.autoUpdate;e.xr.enabled=!1,e.shadowMap.autoUpdate=!1,e.setRenderTarget(p),!1===e.autoClear&&e.clear(),e.render(t,c),e.xr.enabled=a,e.shadowMap.autoUpdate=i,e.setRenderTarget(o);const s=n.viewport;void 0!==s&&e.state.viewport(s),r.visible=!0}(e,t,n))},this.getRenderTarget=function(){return p}}}e.prototype.isRefractor=!0,e.RefractorShader={uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:"\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"},THREE.Refractor=e}()},7613:()=>{!function(){class e extends THREE.Pass{constructor(e,t,n,r,o){super(),this.scene=e,this.camera=t,this.overrideMaterial=n,this.clearColor=r,this.clearAlpha=void 0!==o?o:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new THREE.Color}render(e,t,n){const r=e.autoClear;let o,a;e.autoClear=!1,void 0!==this.overrideMaterial&&(a=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),this.clearColor&&(e.getClearColor(this._oldClearColor),o=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:n),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),this.clearColor&&e.setClearColor(this._oldClearColor,o),void 0!==this.overrideMaterial&&(this.scene.overrideMaterial=a),e.autoClear=r}}THREE.RenderPass=e}()},2025:()=>{!function(){class e extends THREE.Pass{constructor(e,t,n,r){super(),this.width=void 0!==n?n:512,this.height=void 0!==r?r:512,this.clear=!0,this.camera=t,this.scene=e,this.kernelRadius=8,this.kernelSize=32,this.kernel=[],this.noiseTexture=null,this.output=0,this.minDistance=.005,this.maxDistance=.1,this._visibilityCache=new Map,this.generateSampleKernel(),this.generateRandomKernelRotations();const o=new THREE.DepthTexture;o.type=THREE.UnsignedShortType,this.beautyRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.normalRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter,format:THREE.RGBAFormat,depthTexture:o}),this.ssaoRenderTarget=new THREE.WebGLRenderTarget(this.width,this.height,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat}),this.blurRenderTarget=this.ssaoRenderTarget.clone(),void 0===THREE.SSAOShader&&console.error("THREE.SSAOPass: The pass relies on THREE.SSAOShader."),this.ssaoMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAOShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAOShader.uniforms),vertexShader:THREE.SSAOShader.vertexShader,fragmentShader:THREE.SSAOShader.fragmentShader,blending:THREE.NoBlending}),this.ssaoMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.ssaoMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.ssaoMaterial.uniforms.tDepth.value=this.normalRenderTarget.depthTexture,this.ssaoMaterial.uniforms.tNoise.value=this.noiseTexture,this.ssaoMaterial.uniforms.kernel.value=this.kernel,this.ssaoMaterial.uniforms.cameraNear.value=this.camera.near,this.ssaoMaterial.uniforms.cameraFar.value=this.camera.far,this.ssaoMaterial.uniforms.resolution.value.set(this.width,this.height),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.normalMaterial=new THREE.MeshNormalMaterial,this.normalMaterial.blending=THREE.NoBlending,this.blurMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAOBlurShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAOBlurShader.uniforms),vertexShader:THREE.SSAOBlurShader.vertexShader,fragmentShader:THREE.SSAOBlurShader.fragmentShader}),this.blurMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.blurMaterial.uniforms.resolution.value.set(this.width,this.height),this.depthRenderMaterial=new THREE.ShaderMaterial({defines:Object.assign({},THREE.SSAODepthShader.defines),uniforms:THREE.UniformsUtils.clone(THREE.SSAODepthShader.uniforms),vertexShader:THREE.SSAODepthShader.vertexShader,fragmentShader:THREE.SSAODepthShader.fragmentShader,blending:THREE.NoBlending}),this.depthRenderMaterial.uniforms.tDepth.value=this.normalRenderTarget.depthTexture,this.depthRenderMaterial.uniforms.cameraNear.value=this.camera.near,this.depthRenderMaterial.uniforms.cameraFar.value=this.camera.far,this.copyMaterial=new THREE.ShaderMaterial({uniforms:THREE.UniformsUtils.clone(THREE.CopyShader.uniforms),vertexShader:THREE.CopyShader.vertexShader,fragmentShader:THREE.CopyShader.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:THREE.DstColorFactor,blendDst:THREE.ZeroFactor,blendEquation:THREE.AddEquation,blendSrcAlpha:THREE.DstAlphaFactor,blendDstAlpha:THREE.ZeroFactor,blendEquationAlpha:THREE.AddEquation}),this.fsQuad=new THREE.FullScreenQuad(null),this.originalClearColor=new THREE.Color}dispose(){this.beautyRenderTarget.dispose(),this.normalRenderTarget.dispose(),this.ssaoRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.normalMaterial.dispose(),this.blurMaterial.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this.fsQuad.dispose()}render(t,n){switch(t.setRenderTarget(this.beautyRenderTarget),t.clear(),t.render(this.scene,this.camera),this.overrideVisibility(),this.renderOverride(t,this.normalMaterial,this.normalRenderTarget,7829503,1),this.restoreVisibility(),this.ssaoMaterial.uniforms.kernelRadius.value=this.kernelRadius,this.ssaoMaterial.uniforms.minDistance.value=this.minDistance,this.ssaoMaterial.uniforms.maxDistance.value=this.maxDistance,this.renderPass(t,this.ssaoMaterial,this.ssaoRenderTarget),this.renderPass(t,this.blurMaterial,this.blurRenderTarget),this.output){case e.OUTPUT.SSAO:this.copyMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n);break;case e.OUTPUT.Blur:this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n);break;case e.OUTPUT.Beauty:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n);break;case e.OUTPUT.Depth:this.renderPass(t,this.depthRenderMaterial,this.renderToScreen?null:n);break;case e.OUTPUT.Normal:this.copyMaterial.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n);break;case e.OUTPUT.Default:this.copyMaterial.uniforms.tDiffuse.value=this.beautyRenderTarget.texture,this.copyMaterial.blending=THREE.NoBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n),this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=THREE.CustomBlending,this.renderPass(t,this.copyMaterial,this.renderToScreen?null:n);break;default:console.warn("THREE.SSAOPass: Unknown output type.")}}renderPass(e,t,n,r,o){e.getClearColor(this.originalClearColor);const a=e.getClearAlpha(),i=e.autoClear;e.setRenderTarget(n),e.autoClear=!1,null!=r&&(e.setClearColor(r),e.setClearAlpha(o||0),e.clear()),this.fsQuad.material=t,this.fsQuad.render(e),e.autoClear=i,e.setClearColor(this.originalClearColor),e.setClearAlpha(a)}renderOverride(e,t,n,r,o){e.getClearColor(this.originalClearColor);const a=e.getClearAlpha(),i=e.autoClear;e.setRenderTarget(n),e.autoClear=!1,r=t.clearColor||r,o=t.clearAlpha||o,null!=r&&(e.setClearColor(r),e.setClearAlpha(o||0),e.clear()),this.scene.overrideMaterial=t,e.render(this.scene,this.camera),this.scene.overrideMaterial=null,e.autoClear=i,e.setClearColor(this.originalClearColor),e.setClearAlpha(a)}setSize(e,t){this.width=e,this.height=t,this.beautyRenderTarget.setSize(e,t),this.ssaoRenderTarget.setSize(e,t),this.normalRenderTarget.setSize(e,t),this.blurRenderTarget.setSize(e,t),this.ssaoMaterial.uniforms.resolution.value.set(e,t),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.blurMaterial.uniforms.resolution.value.set(e,t)}generateSampleKernel(){const e=this.kernelSize,t=this.kernel;for(let n=0;n<e;n++){const r=new THREE.Vector3;r.x=2*Math.random()-1,r.y=2*Math.random()-1,r.z=Math.random(),r.normalize();let o=n/e;o=THREE.MathUtils.lerp(.1,1,o*o),r.multiplyScalar(o),t.push(r)}}generateRandomKernelRotations(){void 0===THREE.SimplexNoise&&console.error("THREE.SSAOPass: The pass relies on THREE.SimplexNoise.");const e=new THREE.SimplexNoise,t=new Float32Array(64);for(let n=0;n<16;n++){const r=4*n,o=2*Math.random()-1,a=2*Math.random()-1,i=0,s=e.noise3d(o,a,i);t[r]=s,t[r+1]=s,t[r+2]=s,t[r+3]=1}this.noiseTexture=new THREE.DataTexture(t,4,4,THREE.RGBAFormat,THREE.FloatType),this.noiseTexture.wrapS=THREE.RepeatWrapping,this.noiseTexture.wrapT=THREE.RepeatWrapping}overrideVisibility(){const e=this.scene,t=this._visibilityCache;e.traverse((function(e){t.set(e,e.visible),(e.isPoints||e.isLine)&&(e.visible=!1)}))}restoreVisibility(){const e=this.scene,t=this._visibilityCache;e.traverse((function(e){const n=t.get(e);e.visible=n})),t.clear()}}e.OUTPUT={Default:0,SSAO:1,Blur:2,Beauty:3,Depth:4,Normal:5},THREE.SSAOPass=e}()},9681:()=>{!function(){const e={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SIZE:32},uniforms:{tDiffuse:{value:null},tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},kernel:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new THREE.Vector2},cameraProjectionMatrix:{value:new THREE.Matrix4},cameraInverseProjectionMatrix:{value:new THREE.Matrix4},kernelRadius:{value:8},minDistance:{value:.005},maxDistance:{value:.05}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t}\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\t\t\tvec3 viewNormal = getViewNormal( vUv );\n\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t float occlusion = 0.0;\n\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n\t\t\t\t\tocclusion += 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n\t\t}"},t={defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:"varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"uniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}"},n={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2}},vertexShader:"varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}"};THREE.SSAOBlurShader=n,THREE.SSAODepthShader=t,THREE.SSAOShader=e}()},3202:()=>{THREE.STLExporter=class{parse(e,t={}){const n=void 0!==t.binary&&t.binary,r=[];let o,a=0;e.traverse((function(e){if(e.isMesh){const t=e.geometry;if(!0!==t.isBufferGeometry)throw new Error("THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.");const n=t.index,o=t.getAttribute("position");a+=null!==n?n.count/3:o.count/3,r.push({object3d:e,geometry:t})}}));let i=80;if(!0===n){const e=new ArrayBuffer(2*a+3*a*4*4+80+4);o=new DataView(e),o.setUint32(i,a,!0),i+=4}else o="",o+="solid exported\n";const s=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Vector3,f=new THREE.Vector3,u=new THREE.Vector3,d=new THREE.Vector3;for(let e=0,t=r.length;e<t;e++){const t=r[e].object3d,n=r[e].geometry,o=n.index,a=n.getAttribute("position");if(null!==o)for(let e=0;e<o.count;e+=3)p(o.getX(e+0),o.getX(e+1),o.getX(e+2),a,t);else for(let e=0;e<a.count;e+=3)p(e+0,e+1,e+2,a,t)}return!1===n&&(o+="endsolid exported\n"),o;function p(e,t,r,a,p){s.fromBufferAttribute(a,e),l.fromBufferAttribute(a,t),c.fromBufferAttribute(a,r),!0===p.isSkinnedMesh&&(p.boneTransform(e,s),p.boneTransform(t,l),p.boneTransform(r,c)),s.applyMatrix4(p.matrixWorld),l.applyMatrix4(p.matrixWorld),c.applyMatrix4(p.matrixWorld),function(e,t,r){f.subVectors(r,t),u.subVectors(e,t),f.cross(u).normalize(),d.copy(f).normalize(),!0===n?(o.setFloat32(i,d.x,!0),i+=4,o.setFloat32(i,d.y,!0),i+=4,o.setFloat32(i,d.z,!0),i+=4):(o+="\tfacet normal "+d.x+" "+d.y+" "+d.z+"\n",o+="\t\touter loop\n")}(s,l,c),h(s),h(l),h(c),!0===n?(o.setUint16(i,0,!0),i+=2):(o+="\t\tendloop\n",o+="\tendfacet\n")}function h(e){!0===n?(o.setFloat32(i,e.x,!0),i+=4,o.setFloat32(i,e.y,!0),i+=4,o.setFloat32(i,e.z,!0),i+=4):o+="\t\t\tvertex "+e.x+" "+e.y+" "+e.z+"\n"}}}},3215:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){function t(e,t,n){for(let r=0,o=e.length;r<o;r++)if(e[r]!==t.getUint8(n+r,!1))return!1;return!0}const n=function(e){if("string"==typeof e){const t=new Uint8Array(e.length);for(let n=0;n<e.length;n++)t[n]=255&e.charCodeAt(n);return t.buffer||t}return e}(e);return function(e){const n=new DataView(e);if(84+50*n.getUint32(80,!0)===n.byteLength)return!0;const r=[115,111,108,105,100];for(let e=0;e<5;e++)if(t(r,n,e))return!1;return!0}(n)?function(e){const t=new DataView(e),n=t.getUint32(80,!0);let r,o,a,i,s,l,c,f,u=!1;for(let e=0;e<70;e++)1129270351==t.getUint32(e,!1)&&82==t.getUint8(e+4)&&61==t.getUint8(e+5)&&(u=!0,i=new Float32Array(3*n*3),s=t.getUint8(e+6)/255,l=t.getUint8(e+7)/255,c=t.getUint8(e+8)/255,f=t.getUint8(e+9)/255);const d=new THREE.BufferGeometry,p=new Float32Array(3*n*3),h=new Float32Array(3*n*3);for(let e=0;e<n;e++){const n=84+50*e,f=t.getFloat32(n,!0),d=t.getFloat32(n+4,!0),v=t.getFloat32(n+8,!0);if(u){const e=t.getUint16(n+48,!0);0==(32768&e)?(r=(31&e)/31,o=(e>>5&31)/31,a=(e>>10&31)/31):(r=s,o=l,a=c)}for(let s=1;s<=3;s++){const l=n+12*s,c=3*e*3+3*(s-1);p[c]=t.getFloat32(l,!0),p[c+1]=t.getFloat32(l+4,!0),p[c+2]=t.getFloat32(l+8,!0),h[c]=f,h[c+1]=d,h[c+2]=v,u&&(i[c]=r,i[c+1]=o,i[c+2]=a)}}return d.setAttribute("position",new THREE.BufferAttribute(p,3)),d.setAttribute("normal",new THREE.BufferAttribute(h,3)),u&&(d.setAttribute("color",new THREE.BufferAttribute(i,3)),d.hasColors=!0,d.alpha=f),d}(n):function(e){const t=new THREE.BufferGeometry,n=/solid([\s\S]*?)endsolid/g,r=/facet([\s\S]*?)endfacet/g;let o=0;const a=/[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source,i=new RegExp("vertex"+a+a+a,"g"),s=new RegExp("normal"+a+a+a,"g"),l=[],c=[],f=new THREE.Vector3;let u,d=0,p=0,h=0;for(;null!==(u=n.exec(e));){p=h;const e=u[0];for(;null!==(u=r.exec(e));){let e=0,t=0;const n=u[0];for(;null!==(u=s.exec(n));)f.x=parseFloat(u[1]),f.y=parseFloat(u[2]),f.z=parseFloat(u[3]),t++;for(;null!==(u=i.exec(n));)l.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3])),c.push(f.x,f.y,f.z),e++,h++;1!==t&&console.error("THREE.STLLoader: Something isn't right with the normal of face number "+o),3!==e&&console.error("THREE.STLLoader: Something isn't right with the vertices of face number "+o),o++}const n=p,a=h-p;t.addGroup(n,a,d),d++}return t.setAttribute("position",new THREE.Float32BufferAttribute(l,3)),t.setAttribute("normal",new THREE.Float32BufferAttribute(c,3)),t}("string"!=typeof(r=e)?THREE.LoaderUtils.decodeText(new Uint8Array(r)):r);var r}}THREE.STLLoader=e}()},356:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t=this;function n(e,t,n,o,a,i,s,l){if(0==t||0==n)return void e.lineTo(l.x,l.y);o=o*Math.PI/180,t=Math.abs(t),n=Math.abs(n);const c=(s.x-l.x)/2,f=(s.y-l.y)/2,u=Math.cos(o)*c+Math.sin(o)*f,d=-Math.sin(o)*c+Math.cos(o)*f;let p=t*t,h=n*n;const v=u*u,m=d*d,x=v/p+m/h;if(x>1){const e=Math.sqrt(x);p=(t*=e)*t,h=(n*=e)*n}const g=p*m+h*v,y=(p*h-g)/g;let E=Math.sqrt(Math.max(0,y));a===i&&(E=-E);const w=E*t*d/n,b=-E*n*u/t,_=Math.cos(o)*w-Math.sin(o)*b+(s.x+l.x)/2,T=Math.sin(o)*w+Math.cos(o)*b+(s.y+l.y)/2,A=r(1,0,(u-w)/t,(d-b)/n),S=r((u-w)/t,(d-b)/n,(-u-w)/t,(-d-b)/n)%(2*Math.PI);e.currentPath.absellipse(_,T,t,n,A,A+S,0===i,o)}function r(e,t,n,r){const o=e*n+t*r,a=Math.sqrt(e*e+t*t)*Math.sqrt(n*n+r*r);let i=Math.acos(Math.max(-1,Math.min(1,o/a)));return e*r-t*n<0&&(i=-i),i}function o(e,t){t=Object.assign({},t);let n={};if(e.hasAttribute("class")){const t=e.getAttribute("class").split(/\s/).filter(Boolean).map((e=>e.trim()));for(let e=0;e<t.length;e++)n=Object.assign(n,p["."+t[e]])}function r(r,o,a){void 0===a&&(a=function(e){return e.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),e}),e.hasAttribute(r)&&(t[o]=a(e.getAttribute(r))),n[r]&&(t[o]=a(n[r])),e.style&&""!==e.style[r]&&(t[o]=a(e.style[r]))}function o(e){return Math.max(0,Math.min(1,c(e)))}function a(e){return Math.max(0,c(e))}return e.hasAttribute("id")&&(n=Object.assign(n,p["#"+e.getAttribute("id")])),r("fill","fill"),r("fill-opacity","fillOpacity",o),r("opacity","opacity",o),r("stroke","stroke"),r("stroke-opacity","strokeOpacity",o),r("stroke-width","strokeWidth",a),r("stroke-linejoin","strokeLineJoin"),r("stroke-linecap","strokeLineCap"),r("stroke-miterlimit","strokeMiterLimit",a),r("visibility","visibility"),t}function a(e,t){return e-(t-e)}function i(e,t,n){if("string"!=typeof e)throw new TypeError("Invalid input: "+typeof e);const r={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/};let o=0,a=!0,i="",s="";const l=[];function c(e,t,n){const r=new SyntaxError('Unexpected character "'+e+'" at index '+t+".");throw r.partial=n,r}function f(){""!==i&&(""===s?l.push(Number(i)):l.push(Number(i)*Math.pow(10,Number(s)))),i="",s=""}let u;const d=e.length;for(let p=0;p<d;p++)if(u=e[p],Array.isArray(t)&&t.includes(l.length%n)&&r.FLAGS.test(u))o=1,i=u,f();else{if(0===o){if(r.WHITESPACE.test(u))continue;if(r.DIGIT.test(u)||r.SIGN.test(u)){o=1,i=u;continue}if(r.POINT.test(u)){o=2,i=u;continue}r.COMMA.test(u)&&(a&&c(u,p,l),a=!0)}if(1===o){if(r.DIGIT.test(u)){i+=u;continue}if(r.POINT.test(u)){i+=u,o=2;continue}if(r.EXP.test(u)){o=3;continue}r.SIGN.test(u)&&1===i.length&&r.SIGN.test(i[0])&&c(u,p,l)}if(2===o){if(r.DIGIT.test(u)){i+=u;continue}if(r.EXP.test(u)){o=3;continue}r.POINT.test(u)&&"."===i[i.length-1]&&c(u,p,l)}if(3===o){if(r.DIGIT.test(u)){s+=u;continue}if(r.SIGN.test(u)){if(""===s){s+=u;continue}1===s.length&&r.SIGN.test(s)&&c(u,p,l)}}r.WHITESPACE.test(u)?(f(),o=0,a=!1):r.COMMA.test(u)?(f(),o=0,a=!0):r.SIGN.test(u)?(f(),o=1,i=u):r.POINT.test(u)?(f(),o=2,i=u):c(u,p,l)}return f(),l}const s=["mm","cm","in","pt","pc","px"],l={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:12,pc:1,px:-1},px:{px:1}};function c(e){let n,r="px";if("string"==typeof e||e instanceof String)for(let t=0,n=s.length;t<n;t++){const n=s[t];if(e.endsWith(n)){r=n,e=e.substring(0,e.length-n.length);break}}return"px"===r&&"px"!==t.defaultUnit?n=l.in[t.defaultUnit]/t.defaultDPI:(n=l[r][t.defaultUnit],n<0&&(n=l[r].in*t.defaultDPI)),n*parseFloat(e)}function f(e){const t=e.elements;return Math.sqrt(t[0]*t[0]+t[1]*t[1])}function u(e){const t=e.elements;return Math.sqrt(t[3]*t[3]+t[4]*t[4])}const d=[],p={},h=[],v=new THREE.Matrix3,m=new THREE.Matrix3,x=new THREE.Matrix3,g=new THREE.Matrix3,y=new THREE.Vector2,E=new THREE.Vector3,w=new THREE.Matrix3,b=(new DOMParser).parseFromString(e,"image/svg+xml");!function e(t,r){if(1!==t.nodeType)return;const s=function(e){if(!(e.hasAttribute("transform")||"use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))))return null;const t=function(e){const t=new THREE.Matrix3,n=v;if("use"===e.nodeName&&(e.hasAttribute("x")||e.hasAttribute("y"))){const n=c(e.getAttribute("x")),r=c(e.getAttribute("y"));t.translate(n,r)}if(e.hasAttribute("transform")){const r=e.getAttribute("transform").split(")");for(let e=r.length-1;e>=0;e--){const o=r[e].trim();if(""===o)continue;const a=o.indexOf("("),s=o.length;if(a>0&&a<s){const e=o.substr(0,a),t=i(o.substr(a+1,s-a-1));switch(n.identity(),e){case"translate":if(t.length>=1){const e=t[0];let r=e;t.length>=2&&(r=t[1]),n.translate(e,r)}break;case"rotate":if(t.length>=1){let e=0,r=0,o=0;e=-t[0]*Math.PI/180,t.length>=3&&(r=t[1],o=t[2]),m.identity().translate(-r,-o),x.identity().rotate(e),g.multiplyMatrices(x,m),m.identity().translate(r,o),n.multiplyMatrices(m,g)}break;case"scale":if(t.length>=1){const e=t[0];let r=e;t.length>=2&&(r=t[1]),n.scale(e,r)}break;case"skewX":1===t.length&&n.set(1,Math.tan(t[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":1===t.length&&n.set(1,0,0,Math.tan(t[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":6===t.length&&n.set(t[0],t[2],t[4],t[1],t[3],t[5],0,0,1)}}t.premultiply(n)}}return t}(e);h.length>0&&t.premultiply(h[h.length-1]);return w.copy(t),h.push(t),t}(t);let l=!0,b=null;switch(t.nodeName){case"svg":break;case"style":!function(e){if(!e.sheet||!e.sheet.cssRules||!e.sheet.cssRules.length)return;for(let t=0;t<e.sheet.cssRules.length;t++){const n=e.sheet.cssRules[t];if(1!==n.type)continue;const r=n.selectorText.split(/,/gm).filter(Boolean).map((e=>e.trim()));for(let e=0;e<r.length;e++)p[r[e]]=Object.assign(p[r[e]]||{},n.style)}}(t);break;case"g":r=o(t,r);break;case"path":r=o(t,r),t.hasAttribute("d")&&(b=function(e){const t=new THREE.ShapePath,r=new THREE.Vector2,o=new THREE.Vector2,s=new THREE.Vector2;let l=!0,c=!1;const f=e.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);for(let e=0,u=f.length;e<u;e++){const u=f[e],d=u.charAt(0),p=u.substr(1).trim();let h;switch(!0===l&&(c=!0,l=!1),d){case"M":h=i(p);for(let e=0,n=h.length;e<n;e+=2)r.x=h[e+0],r.y=h[e+1],o.x=r.x,o.y=r.y,0===e?t.moveTo(r.x,r.y):t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"H":h=i(p);for(let e=0,n=h.length;e<n;e++)r.x=h[e],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"V":h=i(p);for(let e=0,n=h.length;e<n;e++)r.y=h[e],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"L":h=i(p);for(let e=0,n=h.length;e<n;e+=2)r.x=h[e+0],r.y=h[e+1],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"C":h=i(p);for(let e=0,n=h.length;e<n;e+=6)t.bezierCurveTo(h[e+0],h[e+1],h[e+2],h[e+3],h[e+4],h[e+5]),o.x=h[e+2],o.y=h[e+3],r.x=h[e+4],r.y=h[e+5],0===e&&!0===c&&s.copy(r);break;case"S":h=i(p);for(let e=0,n=h.length;e<n;e+=4)t.bezierCurveTo(a(r.x,o.x),a(r.y,o.y),h[e+0],h[e+1],h[e+2],h[e+3]),o.x=h[e+0],o.y=h[e+1],r.x=h[e+2],r.y=h[e+3],0===e&&!0===c&&s.copy(r);break;case"Q":h=i(p);for(let e=0,n=h.length;e<n;e+=4)t.quadraticCurveTo(h[e+0],h[e+1],h[e+2],h[e+3]),o.x=h[e+0],o.y=h[e+1],r.x=h[e+2],r.y=h[e+3],0===e&&!0===c&&s.copy(r);break;case"T":h=i(p);for(let e=0,n=h.length;e<n;e+=2){const n=a(r.x,o.x),i=a(r.y,o.y);t.quadraticCurveTo(n,i,h[e+0],h[e+1]),o.x=n,o.y=i,r.x=h[e+0],r.y=h[e+1],0===e&&!0===c&&s.copy(r)}break;case"A":h=i(p,[3,4],7);for(let e=0,a=h.length;e<a;e+=7){if(h[e+5]==r.x&&h[e+6]==r.y)continue;const a=r.clone();r.x=h[e+5],r.y=h[e+6],o.x=r.x,o.y=r.y,n(t,h[e],h[e+1],h[e+2],h[e+3],h[e+4],a,r),0===e&&!0===c&&s.copy(r)}break;case"m":h=i(p);for(let e=0,n=h.length;e<n;e+=2)r.x+=h[e+0],r.y+=h[e+1],o.x=r.x,o.y=r.y,0===e?t.moveTo(r.x,r.y):t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"h":h=i(p);for(let e=0,n=h.length;e<n;e++)r.x+=h[e],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"v":h=i(p);for(let e=0,n=h.length;e<n;e++)r.y+=h[e],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"l":h=i(p);for(let e=0,n=h.length;e<n;e+=2)r.x+=h[e+0],r.y+=h[e+1],o.x=r.x,o.y=r.y,t.lineTo(r.x,r.y),0===e&&!0===c&&s.copy(r);break;case"c":h=i(p);for(let e=0,n=h.length;e<n;e+=6)t.bezierCurveTo(r.x+h[e+0],r.y+h[e+1],r.x+h[e+2],r.y+h[e+3],r.x+h[e+4],r.y+h[e+5]),o.x=r.x+h[e+2],o.y=r.y+h[e+3],r.x+=h[e+4],r.y+=h[e+5],0===e&&!0===c&&s.copy(r);break;case"s":h=i(p);for(let e=0,n=h.length;e<n;e+=4)t.bezierCurveTo(a(r.x,o.x),a(r.y,o.y),r.x+h[e+0],r.y+h[e+1],r.x+h[e+2],r.y+h[e+3]),o.x=r.x+h[e+0],o.y=r.y+h[e+1],r.x+=h[e+2],r.y+=h[e+3],0===e&&!0===c&&s.copy(r);break;case"q":h=i(p);for(let e=0,n=h.length;e<n;e+=4)t.quadraticCurveTo(r.x+h[e+0],r.y+h[e+1],r.x+h[e+2],r.y+h[e+3]),o.x=r.x+h[e+0],o.y=r.y+h[e+1],r.x+=h[e+2],r.y+=h[e+3],0===e&&!0===c&&s.copy(r);break;case"t":h=i(p);for(let e=0,n=h.length;e<n;e+=2){const n=a(r.x,o.x),i=a(r.y,o.y);t.quadraticCurveTo(n,i,r.x+h[e+0],r.y+h[e+1]),o.x=n,o.y=i,r.x=r.x+h[e+0],r.y=r.y+h[e+1],0===e&&!0===c&&s.copy(r)}break;case"a":h=i(p,[3,4],7);for(let e=0,a=h.length;e<a;e+=7){if(0==h[e+5]&&0==h[e+6])continue;const a=r.clone();r.x+=h[e+5],r.y+=h[e+6],o.x=r.x,o.y=r.y,n(t,h[e],h[e+1],h[e+2],h[e+3],h[e+4],a,r),0===e&&!0===c&&s.copy(r)}break;case"Z":case"z":t.currentPath.autoClose=!0,t.currentPath.curves.length>0&&(r.copy(s),t.currentPath.currentPoint.copy(r),l=!0);break;default:console.warn(u)}c=!1}return t}(t));break;case"rect":r=o(t,r),b=function(e){const t=c(e.getAttribute("x")||0),n=c(e.getAttribute("y")||0),r=c(e.getAttribute("rx")||0),o=c(e.getAttribute("ry")||0),a=c(e.getAttribute("width")),i=c(e.getAttribute("height")),s=new THREE.ShapePath;s.moveTo(t+2*r,n),s.lineTo(t+a-2*r,n),(0!==r||0!==o)&&s.bezierCurveTo(t+a,n,t+a,n,t+a,n+2*o);s.lineTo(t+a,n+i-2*o),(0!==r||0!==o)&&s.bezierCurveTo(t+a,n+i,t+a,n+i,t+a-2*r,n+i);s.lineTo(t+2*r,n+i),(0!==r||0!==o)&&s.bezierCurveTo(t,n+i,t,n+i,t,n+i-2*o);s.lineTo(t,n+2*o),(0!==r||0!==o)&&s.bezierCurveTo(t,n,t,n,t+2*r,n);return s}(t);break;case"polygon":r=o(t,r),b=function(e){function t(e,t,n){const a=c(t),i=c(n);0===o?r.moveTo(a,i):r.lineTo(a,i),o++}const n=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,r=new THREE.ShapePath;let o=0;return e.getAttribute("points").replace(n,t),r.currentPath.autoClose=!0,r}(t);break;case"polyline":r=o(t,r),b=function(e){function t(e,t,n){const a=c(t),i=c(n);0===o?r.moveTo(a,i):r.lineTo(a,i),o++}const n=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,r=new THREE.ShapePath;let o=0;return e.getAttribute("points").replace(n,t),r.currentPath.autoClose=!1,r}(t);break;case"circle":r=o(t,r),b=function(e){const t=c(e.getAttribute("cx")||0),n=c(e.getAttribute("cy")||0),r=c(e.getAttribute("r")||0),o=new THREE.Path;o.absarc(t,n,r,0,2*Math.PI);const a=new THREE.ShapePath;return a.subPaths.push(o),a}(t);break;case"ellipse":r=o(t,r),b=function(e){const t=c(e.getAttribute("cx")||0),n=c(e.getAttribute("cy")||0),r=c(e.getAttribute("rx")||0),o=c(e.getAttribute("ry")||0),a=new THREE.Path;a.absellipse(t,n,r,o,0,2*Math.PI);const i=new THREE.ShapePath;return i.subPaths.push(a),i}(t);break;case"line":r=o(t,r),b=function(e){const t=c(e.getAttribute("x1")||0),n=c(e.getAttribute("y1")||0),r=c(e.getAttribute("x2")||0),o=c(e.getAttribute("y2")||0),a=new THREE.ShapePath;return a.moveTo(t,n),a.lineTo(r,o),a.currentPath.autoClose=!1,a}(t);break;case"defs":l=!1;break;case"use":r=o(t,r);const s=t.href.baseVal.substring(1),f=t.viewportElement.getElementById(s);f?e(f,r):console.warn("SVGLoader: 'use node' references non-existent node id: "+s)}if(b&&(void 0!==r.fill&&"none"!==r.fill&&b.color.setStyle(r.fill),function(e,t){function n(e){E.set(e.x,e.y,1).applyMatrix3(t),e.set(E.x,E.y)}const r=function(e){return 0!==e.elements[1]||0!==e.elements[3]}(t),o=e.subPaths;for(let e=0,a=o.length;e<a;e++){const a=o[e].curves;for(let e=0;e<a.length;e++){const o=a[e];o.isLineCurve?(n(o.v1),n(o.v2)):o.isCubicBezierCurve?(n(o.v0),n(o.v1),n(o.v2),n(o.v3)):o.isQuadraticBezierCurve?(n(o.v0),n(o.v1),n(o.v2)):o.isEllipseCurve&&(r&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),y.set(o.aX,o.aY),n(y),o.aX=y.x,o.aY=y.y,o.xRadius*=f(t),o.yRadius*=u(t))}}}(b,w),d.push(b),b.userData={node:t,style:r}),l){const n=t.childNodes;for(let t=0;t<n.length;t++)e(n[t],r)}s&&(h.pop(),h.length>0?w.copy(h[h.length-1]):w.identity())}(b.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4});return{paths:d,xml:b.documentElement}}static createShapes(e){const t=999999999,n=0,r=1,o=2,a=3,i=4,s=5,l=6,c={loc:n,t:0};function f(e,t,r,a){const i=e.x,s=t.x,l=r.x,f=a.x,d=e.y,p=t.y,h=r.y,v=a.y,m=(f-l)*(d-h)-(v-h)*(i-l),x=(v-h)*(s-i)-(f-l)*(p-d),g=m/x,y=((s-i)*(d-h)-(p-d)*(i-l))/x;if(0===x&&0!==m||g<=0||g>=1||y<0||y>1)return null;if(0===m&&0===x){for(let l=0;l<2;l++){if(u(0===l?r:a,e,t),c.loc==n){const e=0===l?r:a;return{x:e.x,y:e.y,t:c.t}}if(c.loc==o){return{x:+(i+c.t*(s-i)).toPrecision(10),y:+(d+c.t*(p-d)).toPrecision(10),t:c.t}}}return null}for(let o=0;o<2;o++)if(u(0===o?r:a,e,t),c.loc==n){const e=0===o?r:a;return{x:e.x,y:e.y,t:c.t}}return{x:+(i+g*(s-i)).toPrecision(10),y:+(d+g*(p-d)).toPrecision(10),t:g}}function u(e,t,f){const u=f.x-t.x,d=f.y-t.y,p=e.x-t.x,h=e.y-t.y,v=u*h-p*d;if(e.x===t.x&&e.y===t.y)return c.loc=n,void(c.t=0);if(e.x===f.x&&e.y===f.y)return c.loc=r,void(c.t=1);if(v<-Number.EPSILON)return void(c.loc=a);if(v>Number.EPSILON)return void(c.loc=i);if(u*p<0||d*h<0)return void(c.loc=s);if(Math.sqrt(u*u+d*d)<Math.sqrt(p*p+h*h))return void(c.loc=l);let m;m=0!==u?p/u:h/d,c.loc=o,c.t=m}function d(e,t,n){const r=new THREE.Vector2;t.getCenter(r);const o=[];return n.forEach((t=>{if(t.boundingBox.containsPoint(r)){(function(e,t){const n=[],r=[];for(let o=1;o<e.length;o++){const a=e[o-1],i=e[o];for(let e=1;e<t.length;e++){const o=f(a,i,t[e-1],t[e]);null!==o&&void 0===n.find((e=>e.t<=o.t+Number.EPSILON&&e.t>=o.t-Number.EPSILON))&&(n.push(o),r.push(new THREE.Vector2(o.x,o.y)))}}return r})(e,t.points).forEach((e=>{o.push({identifier:t.identifier,isCW:t.isCW,point:e})}))}})),o.sort(((e,t)=>e.point.x-t.point.x)),o}let p=0,h=t,v=-999999999,m=e.subPaths.map((e=>{const n=e.getPoints();let r=-999999999,o=t,a=-999999999,i=t;for(let e=0;e<n.length;e++){const t=n[e];t.y>r&&(r=t.y),t.y<o&&(o=t.y),t.x>a&&(a=t.x),t.x<i&&(i=t.x)}return v<=a&&(v=a+1),h>=i&&(h=i-1),{points:n,isCW:THREE.ShapeUtils.isClockWise(n),identifier:p++,boundingBox:new THREE.Box2(new THREE.Vector2(i,o),new THREE.Vector2(a,r))}}));m=m.filter((e=>e.points.length>0));const x=m.map((t=>function(e,t,n,r,o){null!=o&&""!==o||(o="nonzero");const a=new THREE.Vector2;e.boundingBox.getCenter(a);const i=d([new THREE.Vector2(n,a.y),new THREE.Vector2(r,a.y)],e.boundingBox,t);i.sort(((e,t)=>e.point.x-t.point.x));const s=[],l=[];i.forEach((t=>{t.identifier===e.identifier?s.push(t):l.push(t)}));const c=s[0].point.x,f=[];let u=0;for(;u<l.length&&l[u].point.x<c;)f.length>0&&f[f.length-1]===l[u].identifier?f.pop():f.push(l[u].identifier),u++;if(f.push(e.identifier),"evenodd"===o){const t=f.length%2==0,n=f[f.length-2];return{identifier:e.identifier,isHole:t,for:n}}if("nonzero"===o){let n=!0,r=null,o=null;for(let e=0;e<f.length;e++){const a=f[e];n?(o=t[a].isCW,n=!1,r=a):o!==t[a].isCW&&(o=t[a].isCW,n=!0)}return{identifier:e.identifier,isHole:n,for:r}}console.warn('fill-rule: "'+o+'" is currently not implemented.')}(t,m,h,v,e.userData.style.fillRule))),g=[];return m.forEach((e=>{if(!x[e.identifier].isHole){const t=new THREE.Shape(e.points);x.filter((t=>t.isHole&&t.for===e.identifier)).forEach((e=>{const n=m[e.identifier];t.holes.push(new THREE.Path(n.points))})),g.push(t)}})),g}static getStrokeStyle(e,t,n,r,o){return{strokeColor:t=void 0!==t?t:"#000",strokeWidth:e=void 0!==e?e:1,strokeLineJoin:n=void 0!==n?n:"miter",strokeLineCap:r=void 0!==r?r:"butt",strokeMiterLimit:o=void 0!==o?o:4}}static pointsToStroke(t,n,r,o){const a=[],i=[],s=[];if(0===e.pointsToStrokeWithBuffers(t,n,r,o,a,i,s))return null;const l=new THREE.BufferGeometry;return l.setAttribute("position",new THREE.Float32BufferAttribute(a,3)),l.setAttribute("normal",new THREE.Float32BufferAttribute(i,3)),l.setAttribute("uv",new THREE.Float32BufferAttribute(s,2)),l}static pointsToStrokeWithBuffers(e,t,n,r,o,a,i,s){const l=new THREE.Vector2,c=new THREE.Vector2,f=new THREE.Vector2,u=new THREE.Vector2,d=new THREE.Vector2,p=new THREE.Vector2,h=new THREE.Vector2,v=new THREE.Vector2,m=new THREE.Vector2,x=new THREE.Vector2,g=new THREE.Vector2,y=new THREE.Vector2,E=new THREE.Vector2,w=new THREE.Vector2,b=new THREE.Vector2,_=new THREE.Vector2,T=new THREE.Vector2;n=void 0!==n?n:12,r=void 0!==r?r:.001,s=void 0!==s?s:0;const A=(e=function(e){let t=!1;for(let n=1,o=e.length-1;n<o;n++)if(e[n].distanceTo(e[n+1])<r){t=!0;break}if(!t)return e;const n=[];n.push(e[0]);for(let t=1,o=e.length-1;t<o;t++)e[t].distanceTo(e[t+1])>=r&&n.push(e[t]);return n.push(e[e.length-1]),n}(e)).length;if(A<2)return 0;const S=e[0].equals(e[A-1]);let R,M,C=e[0];const L=t.strokeWidth/2,P=1/(A-1);let k,N,H,z,D=0,F=!1,I=0,O=3*s,U=2*s;G(e[0],e[1],l).multiplyScalar(L),v.copy(e[0]).sub(l),m.copy(e[0]).add(l),x.copy(v),g.copy(m);for(let n=1;n<A;n++){R=e[n],M=n===A-1?S?e[1]:void 0:e[n+1];const r=l;if(G(C,R,r),f.copy(r).multiplyScalar(L),y.copy(R).sub(f),E.copy(R).add(f),k=D+P,N=!1,void 0!==M){G(R,M,c),f.copy(c).multiplyScalar(L),w.copy(R).sub(f),b.copy(R).add(f),H=!0,f.subVectors(M,C),r.dot(f)<0&&(H=!1),1===n&&(F=H),f.subVectors(M,R),f.normalize();const e=Math.abs(r.dot(f));if(0!==e){const n=L/e;f.multiplyScalar(-n),u.subVectors(R,C),d.copy(u).setLength(n).add(f),_.copy(d).negate();const r=d.length(),o=u.length();u.divideScalar(o),p.subVectors(M,R);const a=p.length();switch(p.divideScalar(a),u.dot(_)<o&&p.dot(_)<a&&(N=!0),T.copy(d).add(R),_.add(R),z=!1,N?H?(b.copy(_),E.copy(_)):(w.copy(_),y.copy(_)):W(),t.strokeLineJoin){case"bevel":j(H,N,k);break;case"round":q(H,N),H?V(R,y,w,k,0):V(R,b,E,k,1);break;case"miter":case"miter-clip":default:const e=L*t.strokeMiterLimit/r;if(e<1){if("miter-clip"!==t.strokeLineJoin){j(H,N,k);break}q(H,N),H?(p.subVectors(T,y).multiplyScalar(e).add(y),h.subVectors(T,w).multiplyScalar(e).add(w),B(y,k,0),B(p,k,0),B(R,k,.5),B(R,k,.5),B(p,k,0),B(h,k,0),B(R,k,.5),B(h,k,0),B(w,k,0)):(p.subVectors(T,E).multiplyScalar(e).add(E),h.subVectors(T,b).multiplyScalar(e).add(b),B(E,k,1),B(p,k,1),B(R,k,.5),B(R,k,.5),B(p,k,1),B(h,k,1),B(R,k,.5),B(h,k,1),B(b,k,1))}else N?(H?(B(m,D,1),B(v,D,0),B(T,k,0),B(m,D,1),B(T,k,0),B(_,k,1)):(B(m,D,1),B(v,D,0),B(T,k,1),B(v,D,0),B(_,k,0),B(T,k,1)),H?w.copy(T):b.copy(T)):H?(B(y,k,0),B(T,k,0),B(R,k,.5),B(R,k,.5),B(T,k,0),B(w,k,0)):(B(E,k,1),B(T,k,1),B(R,k,.5),B(R,k,.5),B(T,k,1),B(b,k,1)),z=!0}}else W()}else W();S||n!==A-1||X(e[0],x,g,H,!0,D),D=k,C=R,v.copy(w),m.copy(b)}if(S){if(N&&o){let e=T,t=_;F!==H&&(e=_,t=T),H?(z||F)&&(t.toArray(o,0),t.toArray(o,9),z&&e.toArray(o,3)):!z&&F||(t.toArray(o,3),t.toArray(o,9),z&&e.toArray(o,0))}}else X(R,y,E,H,!1,k);return I;function G(e,t,n){return n.subVectors(t,e),n.set(-n.y,n.x).normalize()}function B(e,t,n){o&&(o[O]=e.x,o[O+1]=e.y,o[O+2]=0,a&&(a[O]=0,a[O+1]=0,a[O+2]=1),O+=3,i&&(i[U]=t,i[U+1]=n,U+=2)),I+=3}function V(e,t,r,o,a){l.copy(t).sub(e).normalize(),c.copy(r).sub(e).normalize();let i=Math.PI;const s=l.dot(c);Math.abs(s)<1&&(i=Math.abs(Math.acos(s))),i/=n,f.copy(t);for(let t=0,r=n-1;t<r;t++)u.copy(f).rotateAround(e,i),B(f,o,a),B(u,o,a),B(e,o,.5),f.copy(u);B(u,o,a),B(r,o,a),B(e,o,.5)}function W(){B(m,D,1),B(v,D,0),B(y,k,0),B(m,D,1),B(y,k,1),B(E,k,0)}function j(e,t,n){t?e?(B(m,D,1),B(v,D,0),B(y,k,0),B(m,D,1),B(y,k,0),B(_,k,1),B(y,n,0),B(w,n,0),B(_,n,.5)):(B(m,D,1),B(v,D,0),B(E,k,1),B(v,D,0),B(_,k,0),B(E,k,1),B(E,n,1),B(b,n,0),B(_,n,.5)):e?(B(y,n,0),B(w,n,0),B(R,n,.5)):(B(E,n,1),B(b,n,0),B(R,n,.5))}function q(e,t){t&&(e?(B(m,D,1),B(v,D,0),B(y,k,0),B(m,D,1),B(y,k,0),B(_,k,1),B(y,D,0),B(R,k,.5),B(_,k,1),B(R,k,.5),B(w,D,0),B(_,k,1)):(B(m,D,1),B(v,D,0),B(E,k,1),B(v,D,0),B(_,k,0),B(E,k,1),B(E,D,1),B(_,k,0),B(R,k,.5),B(R,k,.5),B(_,k,0),B(b,D,1)))}function X(e,n,r,a,i,s){switch(t.strokeLineCap){case"round":i?V(e,r,n,s,.5):V(e,n,r,s,.5);break;case"square":if(i)l.subVectors(n,e),c.set(l.y,-l.x),f.addVectors(l,c).add(e),u.subVectors(c,l).add(e),a?(f.toArray(o,3),u.toArray(o,0),u.toArray(o,9)):(f.toArray(o,3),f.toArray(o,9),u.toArray(o,0));else{l.subVectors(r,e),c.set(l.y,-l.x),f.addVectors(l,c).add(e),u.subVectors(c,l).add(e);const t=o.length;a?(f.toArray(o,t-3),u.toArray(o,t-6),u.toArray(o,t-12)):(f.toArray(o,t-6),u.toArray(o,t-3),u.toArray(o,t-12))}}}}}THREE.SVGLoader=e}()},8233:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},amount:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float amount;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 color = texture2D( tDiffuse, vUv );\n\t\t\tvec3 c = color.rgb;\n\n\t\t\tcolor.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n\t\t\tcolor.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n\t\t\tcolor.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n\n\t\t\tgl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n\n\t\t}"};THREE.SepiaShader=e}()},8695:()=>{!function(){class e extends THREE.Pass{constructor(e,t){super(),this.textureID=void 0!==t?t:"tDiffuse",e instanceof THREE.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=THREE.UniformsUtils.clone(e.uniforms),this.material=new THREE.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new THREE.FullScreenQuad(this.material)}render(e,t,n){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=n.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}}THREE.ShaderPass=e}()},6868:()=>{THREE.SimplexNoise=class{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let t=0;t<256;t++)this.p[t]=Math.floor(256*e.random());this.perm=[];for(let e=0;e<512;e++)this.perm[e]=this.p[255&e];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}dot(e,t,n){return e[0]*t+e[1]*n}dot3(e,t,n,r){return e[0]*t+e[1]*n+e[2]*r}dot4(e,t,n,r,o){return e[0]*t+e[1]*n+e[2]*r+e[3]*o}noise(e,t){let n,r,o;const a=(e+t)*(.5*(Math.sqrt(3)-1)),i=Math.floor(e+a),s=Math.floor(t+a),l=(3-Math.sqrt(3))/6,c=(i+s)*l,f=e-(i-c),u=t-(s-c);let d,p;f>u?(d=1,p=0):(d=0,p=1);const h=f-d+l,v=u-p+l,m=f-1+2*l,x=u-1+2*l,g=255&i,y=255&s,E=this.perm[g+this.perm[y]]%12,w=this.perm[g+d+this.perm[y+p]]%12,b=this.perm[g+1+this.perm[y+1]]%12;let _=.5-f*f-u*u;_<0?n=0:(_*=_,n=_*_*this.dot(this.grad3[E],f,u));let T=.5-h*h-v*v;T<0?r=0:(T*=T,r=T*T*this.dot(this.grad3[w],h,v));let A=.5-m*m-x*x;return A<0?o=0:(A*=A,o=A*A*this.dot(this.grad3[b],m,x)),70*(n+r+o)}noise3d(e,t,n){let r,o,a,i;const s=(e+t+n)*(1/3),l=Math.floor(e+s),c=Math.floor(t+s),f=Math.floor(n+s),u=1/6,d=(l+c+f)*u,p=e-(l-d),h=t-(c-d),v=n-(f-d);let m,x,g,y,E,w;p>=h?h>=v?(m=1,x=0,g=0,y=1,E=1,w=0):p>=v?(m=1,x=0,g=0,y=1,E=0,w=1):(m=0,x=0,g=1,y=1,E=0,w=1):h<v?(m=0,x=0,g=1,y=0,E=1,w=1):p<v?(m=0,x=1,g=0,y=0,E=1,w=1):(m=0,x=1,g=0,y=1,E=1,w=0);const b=p-m+u,_=h-x+u,T=v-g+u,A=p-y+2*u,S=h-E+2*u,R=v-w+2*u,M=p-1+.5,C=h-1+.5,L=v-1+.5,P=255&l,k=255&c,N=255&f,H=this.perm[P+this.perm[k+this.perm[N]]]%12,z=this.perm[P+m+this.perm[k+x+this.perm[N+g]]]%12,D=this.perm[P+y+this.perm[k+E+this.perm[N+w]]]%12,F=this.perm[P+1+this.perm[k+1+this.perm[N+1]]]%12;let I=.6-p*p-h*h-v*v;I<0?r=0:(I*=I,r=I*I*this.dot3(this.grad3[H],p,h,v));let O=.6-b*b-_*_-T*T;O<0?o=0:(O*=O,o=O*O*this.dot3(this.grad3[z],b,_,T));let U=.6-A*A-S*S-R*R;U<0?a=0:(U*=U,a=U*U*this.dot3(this.grad3[D],A,S,R));let G=.6-M*M-C*C-L*L;return G<0?i=0:(G*=G,i=G*G*this.dot3(this.grad3[F],M,C,L)),32*(r+o+a+i)}noise4d(e,t,n,r){const o=this.grad4,a=this.simplex,i=this.perm,s=(Math.sqrt(5)-1)/4,l=(5-Math.sqrt(5))/20;let c,f,u,d,p;const h=(e+t+n+r)*s,v=Math.floor(e+h),m=Math.floor(t+h),x=Math.floor(n+h),g=Math.floor(r+h),y=(v+m+x+g)*l,E=e-(v-y),w=t-(m-y),b=n-(x-y),_=r-(g-y),T=(E>w?32:0)+(E>b?16:0)+(w>b?8:0)+(E>_?4:0)+(w>_?2:0)+(b>_?1:0),A=a[T][0]>=3?1:0,S=a[T][1]>=3?1:0,R=a[T][2]>=3?1:0,M=a[T][3]>=3?1:0,C=a[T][0]>=2?1:0,L=a[T][1]>=2?1:0,P=a[T][2]>=2?1:0,k=a[T][3]>=2?1:0,N=a[T][0]>=1?1:0,H=a[T][1]>=1?1:0,z=a[T][2]>=1?1:0,D=a[T][3]>=1?1:0,F=E-A+l,I=w-S+l,O=b-R+l,U=_-M+l,G=E-C+2*l,B=w-L+2*l,V=b-P+2*l,W=_-k+2*l,j=E-N+3*l,q=w-H+3*l,X=b-z+3*l,Y=_-D+3*l,Q=E-1+4*l,K=w-1+4*l,Z=b-1+4*l,J=_-1+4*l,$=255&v,ee=255&m,te=255&x,ne=255&g,re=i[$+i[ee+i[te+i[ne]]]]%32,oe=i[$+A+i[ee+S+i[te+R+i[ne+M]]]]%32,ae=i[$+C+i[ee+L+i[te+P+i[ne+k]]]]%32,ie=i[$+N+i[ee+H+i[te+z+i[ne+D]]]]%32,se=i[$+1+i[ee+1+i[te+1+i[ne+1]]]]%32;let le=.6-E*E-w*w-b*b-_*_;le<0?c=0:(le*=le,c=le*le*this.dot4(o[re],E,w,b,_));let ce=.6-F*F-I*I-O*O-U*U;ce<0?f=0:(ce*=ce,f=ce*ce*this.dot4(o[oe],F,I,O,U));let fe=.6-G*G-B*B-V*V-W*W;fe<0?u=0:(fe*=fe,u=fe*fe*this.dot4(o[ae],G,B,V,W));let ue=.6-j*j-q*q-X*X-Y*Y;ue<0?d=0:(ue*=ue,d=ue*ue*this.dot4(o[ie],j,q,X,Y));let de=.6-Q*Q-K*K-Z*Z-J*J;return de<0?p=0:(de*=de,p=de*de*this.dot4(o[se],Q,K,Z,J)),27*(c+f+u+d+p)}}},1701:()=>{!function(){const e=new THREE.Vector3,t=new THREE.Vector3;function n(e,t){var n=e.indexOf(t);n>-1&&e.splice(n,1)}function r(e,t){const n=t.position.distanceTo(e.position);let r=0;const o=[];for(let n=0,r=e.faces.length;n<r;n++){const r=e.faces[n];r.hasVertex(t)&&o.push(r)}for(let t=0,n=e.faces.length;t<n;t++){let n=1;const a=e.faces[t];for(let e=0;e<o.length;e++){const t=o[e],r=a.normal.dot(t.normal);n=Math.min(n,(1.001-r)/2)}r=Math.max(r,n)}o.length<2&&(r=1);return n*r+0}function o(e){if(0===e.neighbors.length)return e.collapseNeighbor=null,void(e.collapseCost=-.01);e.collapseCost=1e5,e.collapseNeighbor=null;for(let t=0;t<e.neighbors.length;t++){const n=r(e,e.neighbors[t]);e.collapseNeighbor||(e.collapseNeighbor=e.neighbors[t],e.collapseCost=n,e.minCost=n,e.totalCost=0,e.costCount=0),e.costCount++,e.totalCost+=n,n<e.minCost&&(e.collapseNeighbor=e.neighbors[t],e.minCost=n)}e.collapseCost=e.totalCost/e.costCount}function a(e,t){for(console.assert(0===e.faces.length);e.neighbors.length;){n(e.neighbors.pop().neighbors,e)}n(t,e)}function i(e,t){n(t,e),e.v1&&n(e.v1.faces,e),e.v2&&n(e.v2.faces,e),e.v3&&n(e.v3.faces,e);const r=[e.v1,e.v2,e.v3];for(let e=0;e<3;e++){const t=r[e],n=r[(e+1)%3];t&&n&&(t.removeIfNonNeighbor(n),n.removeIfNonNeighbor(t))}}function s(e,t,n,r){if(!r)return void a(n,e);const s=[];for(let e=0;e<n.neighbors.length;e++)s.push(n.neighbors[e]);for(let e=n.faces.length-1;e>=0;e--)n.faces[e].hasVertex(r)&&i(n.faces[e],t);for(let e=n.faces.length-1;e>=0;e--)n.faces[e].replaceVertex(n,r);a(n,e);for(let e=0;e<s.length;e++)o(s[e])}function l(e){let t=e[0];for(let n=0;n<e.length;n++)e[n].collapseCost<t.collapseCost&&(t=e[n]);return t}class c{constructor(e,t,n,r,o,a){this.a=r,this.b=o,this.c=a,this.v1=e,this.v2=t,this.v3=n,this.normal=new THREE.Vector3,this.computeNormal(),e.faces.push(this),e.addUniqueNeighbor(t),e.addUniqueNeighbor(n),t.faces.push(this),t.addUniqueNeighbor(e),t.addUniqueNeighbor(n),n.faces.push(this),n.addUniqueNeighbor(e),n.addUniqueNeighbor(t)}computeNormal(){const n=this.v1.position,r=this.v2.position,o=this.v3.position;e.subVectors(o,r),t.subVectors(n,r),e.cross(t).normalize(),this.normal.copy(e)}hasVertex(e){return e===this.v1||e===this.v2||e===this.v3}replaceVertex(e,t){e===this.v1?this.v1=t:e===this.v2?this.v2=t:e===this.v3&&(this.v3=t),n(e.faces,this),t.faces.push(this),e.removeIfNonNeighbor(this.v1),this.v1.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v2),this.v2.removeIfNonNeighbor(e),e.removeIfNonNeighbor(this.v3),this.v3.removeIfNonNeighbor(e),this.v1.addUniqueNeighbor(this.v2),this.v1.addUniqueNeighbor(this.v3),this.v2.addUniqueNeighbor(this.v1),this.v2.addUniqueNeighbor(this.v3),this.v3.addUniqueNeighbor(this.v1),this.v3.addUniqueNeighbor(this.v2),this.computeNormal()}}class f{constructor(e,t){this.position=e,this.id=t,this.faces=[],this.neighbors=[],this.collapseCost=0,this.collapseNeighbor=null}addUniqueNeighbor(e){var t,n;t=this.neighbors,n=e,-1===t.indexOf(n)&&t.push(n)}removeIfNonNeighbor(e){const t=this.neighbors,n=this.faces,r=t.indexOf(e);if(-1!==r){for(let t=0;t<n.length;t++)if(n[t].hasVertex(e))return;t.splice(r,1)}}}THREE.SimplifyModifier=class{constructor(){if(void 0===THREE.BufferGeometryUtils)throw"THREE.SimplifyModifier relies on THREE.BufferGeometryUtils"}modify(e,t){if(!0===e.isGeometry)return void console.error("THREE.SimplifyModifier no longer supports Geometry. Use THREE.BufferGeometry instead.");const n=(e=e.clone()).attributes;for(const t in n)"position"!==t&&e.deleteAttribute(t);const r=[],a=[],i=(e=THREE.BufferGeometryUtils.mergeVertices(e)).getAttribute("position");for(let e=0;e<i.count;e++){const t=(new THREE.Vector3).fromBufferAttribute(i,e),n=new f(t,e);r.push(n)}let u,d=e.getIndex();if(null!==d)for(let e=0;e<d.count;e+=3){const t=d.getX(e),n=d.getX(e+1),o=d.getX(e+2),i=new c(r[t],r[n],r[o],t,n,o);a.push(i)}else for(let e=0;e<i.count;e+=3){const t=e,n=e+1,o=e+2,i=new c(r[t],r[n],r[o],t,n,o);a.push(i)}for(let e=0,t=r.length;e<t;e++)o(r[e]);let p=t;for(;p--;){if(u=l(r),!u){console.log("THREE.SimplifyModifier: No next vertex");break}s(r,a,u,u.collapseNeighbor)}const h=new THREE.BufferGeometry,v=[];d=[];for(let e=0;e<r.length;e++){const t=r[e].position;v.push(t.x,t.y,t.z)}for(let e=0;e<a.length;e++){const t=a[e],n=r.indexOf(t.v1),o=r.indexOf(t.v2),i=r.indexOf(t.v3);d.push(n,o,i)}return h.setAttribute("position",new THREE.Float32BufferAttribute(v,3)),h.setIndex(d),h}}}()},9413:()=>{THREE.StereoEffect=class{constructor(e){const t=new THREE.StereoCamera;t.aspect=.5;const n=new THREE.Vector2;this.setEyeSeparation=function(e){t.eyeSep=e},this.setSize=function(t,n){e.setSize(t,n)},this.render=function(r,o){r.updateMatrixWorld(),null===o.parent&&o.updateMatrixWorld(),t.update(o),e.getSize(n),e.autoClear&&e.clear(),e.setScissorTest(!0),e.setScissor(0,0,n.width/2,n.height),e.setViewport(0,0,n.width/2,n.height),e.render(r,t.cameraL),e.setScissor(n.width/2,0,n.width/2,n.height),e.setViewport(n.width/2,0,n.width/2,n.height),e.render(r,t.cameraR),e.setScissorTest(!1)}}}},3531:()=>{!function(){class e extends THREE.Loader{constructor(e){super(e),this.debug=!1,this.group=null,this.position=0,this.materials=[],this.meshes=[]}load(e,t,n,r){const o=this,a=""===this.path?THREE.LoaderUtils.extractUrlBase(e):this.path,i=new THREE.FileLoader(this.manager);i.setPath(this.path),i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){try{t(o.parse(n,a))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e,t){this.group=new THREE.Group,this.position=0,this.materials=[],this.meshes=[],this.readFile(e,t);for(let e=0;e<this.meshes.length;e++)this.group.add(this.meshes[e]);return this.group}readFile(e,a){const i=new DataView(e),s=this.readChunk(i);if(s.id===n||s.id===r||s.id===t){let e=this.nextChunk(i,s);for(;0!==e;){if(e===o){const e=this.readDWord(i);this.debugMessage("3DS file version: "+e)}else e===u?(this.resetPosition(i),this.readMeshData(i,a)):this.debugMessage("Unknown main chunk: "+e.toString(16));e=this.nextChunk(i,s)}}this.debugMessage("Parsed "+this.meshes.length+" meshes")}readMeshData(e,t){const n=this.readChunk(e);let r=this.nextChunk(e,n);for(;0!==r;){if(r===d){const t=+this.readDWord(e);this.debugMessage("Mesh Version: "+t)}else if(r===p){const t=this.readFloat(e);this.debugMessage("Master scale: "+t),this.group.scale.set(t,t,t)}else r===H?(this.debugMessage("Named Object"),this.resetPosition(e),this.readNamedObject(e)):r===h?(this.debugMessage("Material"),this.resetPosition(e),this.readMaterialEntry(e,t)):this.debugMessage("Unknown MDATA chunk: "+r.toString(16));r=this.nextChunk(e,n)}}readNamedObject(e){const t=this.readChunk(e),n=this.readString(e,64);t.cur=this.position;let r=this.nextChunk(e,t);for(;0!==r;){if(r===z){this.resetPosition(e);const t=this.readMesh(e);t.name=n,this.meshes.push(t)}else this.debugMessage("Unknown named object chunk: "+r.toString(16));r=this.nextChunk(e,t)}this.endChunk(t)}readMaterialEntry(e,t){const n=this.readChunk(e);let r=this.nextChunk(e,n);const o=new THREE.MeshPhongMaterial;for(;0!==r;){if(r===v)o.name=this.readString(e,64),this.debugMessage("   Name: "+o.name);else if(r===_)this.debugMessage("   Wireframe"),o.wireframe=!0;else if(r===T){const t=this.readByte(e);o.wireframeLinewidth=t,this.debugMessage("   Wireframe Thickness: "+t)}else if(r===w)o.side=THREE.DoubleSide,this.debugMessage("   DoubleSided");else if(r===b)this.debugMessage("   Additive Blending"),o.blending=THREE.AdditiveBlending;else if(r===x)this.debugMessage("   Diffuse THREE.Color"),o.color=this.readColor(e);else if(r===g)this.debugMessage("   Specular THREE.Color"),o.specular=this.readColor(e);else if(r===m)this.debugMessage("   Ambient color"),o.color=this.readColor(e);else if(r===y){const t=this.readPercentage(e);o.shininess=100*t,this.debugMessage("   Shininess : "+t)}else if(r===E){const t=this.readPercentage(e);o.opacity=1-t,this.debugMessage("  Transparency : "+t),o.transparent=o.opacity<1}else r===A?(this.debugMessage("   ColorMap"),this.resetPosition(e),o.map=this.readMap(e,t)):r===R?(this.debugMessage("   BumpMap"),this.resetPosition(e),o.bumpMap=this.readMap(e,t)):r===S?(this.debugMessage("   OpacityMap"),this.resetPosition(e),o.alphaMap=this.readMap(e,t)):r===M?(this.debugMessage("   SpecularMap"),this.resetPosition(e),o.specularMap=this.readMap(e,t)):this.debugMessage("   Unknown material chunk: "+r.toString(16));r=this.nextChunk(e,n)}this.endChunk(n),this.materials[o.name]=o}readMesh(e){const t=this.readChunk(e);let n=this.nextChunk(e,t);const r=new THREE.BufferGeometry,o=new THREE.MeshPhongMaterial,a=new THREE.Mesh(r,o);for(a.name="mesh";0!==n;){if(n===D){const t=this.readWord(e);this.debugMessage("   Vertex: "+t);const n=[];for(let r=0;r<t;r++)n.push(this.readFloat(e)),n.push(this.readFloat(e)),n.push(this.readFloat(e));r.setAttribute("position",new THREE.Float32BufferAttribute(n,3))}else if(n===F)this.resetPosition(e),this.readFaceArray(e,a);else if(n===O){const t=this.readWord(e);this.debugMessage("   UV: "+t);const n=[];for(let r=0;r<t;r++)n.push(this.readFloat(e)),n.push(this.readFloat(e));r.setAttribute("uv",new THREE.Float32BufferAttribute(n,2))}else if(n===U){this.debugMessage("   Tranformation Matrix (TODO)");const t=[];for(let n=0;n<12;n++)t[n]=this.readFloat(e);const n=new THREE.Matrix4;n.elements[0]=t[0],n.elements[1]=t[6],n.elements[2]=t[3],n.elements[3]=t[9],n.elements[4]=t[2],n.elements[5]=t[8],n.elements[6]=t[5],n.elements[7]=t[11],n.elements[8]=t[1],n.elements[9]=t[7],n.elements[10]=t[4],n.elements[11]=t[10],n.elements[12]=0,n.elements[13]=0,n.elements[14]=0,n.elements[15]=1,n.transpose();const o=new THREE.Matrix4;o.copy(n).invert(),r.applyMatrix4(o),n.decompose(a.position,a.quaternion,a.scale)}else this.debugMessage("   Unknown mesh chunk: "+n.toString(16));n=this.nextChunk(e,t)}return this.endChunk(t),r.computeVertexNormals(),a}readFaceArray(e,t){const n=this.readChunk(e),r=this.readWord(e);this.debugMessage("   Faces: "+r);const o=[];for(let t=0;t<r;++t)o.push(this.readWord(e),this.readWord(e),this.readWord(e)),this.readWord(e);t.geometry.setIndex(o);let a=0,i=0;for(;this.position<n.end;){const n=this.readChunk(e);if(n.id===I){this.debugMessage("      Material THREE.Group"),this.resetPosition(e);const n=this.readMaterialGroup(e),r=3*n.index.length;t.geometry.addGroup(i,r,a),i+=r,a++;const o=this.materials[n.name];!1===Array.isArray(t.material)&&(t.material=[]),void 0!==o&&t.material.push(o)}else this.debugMessage("      Unknown face array chunk: "+n.toString(16));this.endChunk(n)}1===t.material.length&&(t.material=t.material[0]),this.endChunk(n)}readMap(e,t){const n=this.readChunk(e);let r=this.nextChunk(e,n),o={};const a=new THREE.TextureLoader(this.manager);for(a.setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);0!==r;){if(r===C){const n=this.readString(e,128);o=a.load(n),this.debugMessage("      File: "+t+n)}else r===k?(o.offset.x=this.readFloat(e),this.debugMessage("      OffsetX: "+o.offset.x)):r===N?(o.offset.y=this.readFloat(e),this.debugMessage("      OffsetY: "+o.offset.y)):r===L?(o.repeat.x=this.readFloat(e),this.debugMessage("      RepeatX: "+o.repeat.x)):r===P?(o.repeat.y=this.readFloat(e),this.debugMessage("      RepeatY: "+o.repeat.y)):this.debugMessage("      Unknown map chunk: "+r.toString(16));r=this.nextChunk(e,n)}return this.endChunk(n),o}readMaterialGroup(e){this.readChunk(e);const t=this.readString(e,64),n=this.readWord(e);this.debugMessage("         Name: "+t),this.debugMessage("         Faces: "+n);const r=[];for(let t=0;t<n;++t)r.push(this.readWord(e));return{name:t,index:r}}readColor(e){const t=this.readChunk(e),n=new THREE.Color;if(t.id===i||t.id===s){const t=this.readByte(e),r=this.readByte(e),o=this.readByte(e);n.setRGB(t/255,r/255,o/255),this.debugMessage("      THREE.Color: "+n.r+", "+n.g+", "+n.b)}else if(t.id===a||t.id===l){const t=this.readFloat(e),r=this.readFloat(e),o=this.readFloat(e);n.setRGB(t,r,o),this.debugMessage("      THREE.Color: "+n.r+", "+n.g+", "+n.b)}else this.debugMessage("      Unknown color chunk: "+t.toString(16));return this.endChunk(t),n}readChunk(e){const t={};return t.cur=this.position,t.id=this.readWord(e),t.size=this.readDWord(e),t.end=t.cur+t.size,t.cur+=6,t}endChunk(e){this.position=e.end}nextChunk(e,t){if(t.cur>=t.end)return 0;this.position=t.cur;try{const n=this.readChunk(e);return t.cur+=n.size,n.id}catch(e){return this.debugMessage("Unable to read chunk at "+this.position),0}}resetPosition(){this.position-=6}readByte(e){const t=e.getUint8(this.position,!0);return this.position+=1,t}readFloat(e){try{const t=e.getFloat32(this.position,!0);return this.position+=4,t}catch(t){this.debugMessage(t+" "+this.position+" "+e.byteLength)}}readInt(e){const t=e.getInt32(this.position,!0);return this.position+=4,t}readShort(e){const t=e.getInt16(this.position,!0);return this.position+=2,t}readDWord(e){const t=e.getUint32(this.position,!0);return this.position+=4,t}readWord(e){const t=e.getUint16(this.position,!0);return this.position+=2,t}readString(e,t){let n="";for(let r=0;r<t;r++){const t=this.readByte(e);if(!t)break;n+=String.fromCharCode(t)}return n}readPercentage(e){const t=this.readChunk(e);let n;switch(t.id){case c:n=this.readShort(e)/100;break;case f:n=this.readFloat(e);break;default:this.debugMessage("      Unknown percentage chunk: "+t.toString(16))}return this.endChunk(t),n}debugMessage(e){this.debug&&console.log(e)}}const t=19789,n=15786,r=49725,o=2,a=16,i=17,s=18,l=19,c=48,f=49,u=15677,d=15678,p=256,h=45055,v=40960,m=40976,x=40992,g=41008,y=41024,E=41040,w=41089,b=41091,_=41093,T=41095,A=41472,S=41488,R=41520,M=41476,C=41728,L=41812,P=41814,k=41816,N=41818,H=16384,z=16640,D=16656,F=16672,I=16688,O=16704,U=16736;THREE.TDSLoader=e}()},6889:()=>{!function(){class e extends THREE.DataTextureLoader{constructor(e){super(e)}parse(e){const t=0,n=1,r=2,o=3,a=9,i=10,s=11,l=48,c=4,f=0,u=1,d=2,p=3;e.length<19&&console.error("THREE.TGALoader: Not enough data to contain header.");let h=0;const v=new Uint8Array(e),m={id_length:v[h++],colormap_type:v[h++],image_type:v[h++],colormap_index:v[h++]|v[h++]<<8,colormap_length:v[h++]|v[h++]<<8,colormap_size:v[h++],origin:[v[h++]|v[h++]<<8,v[h++]|v[h++]<<8],width:v[h++]|v[h++]<<8,height:v[h++]|v[h++]<<8,pixel_size:v[h++],flags:v[h++]};!function(e){switch(e.image_type){case n:case a:(e.colormap_length>256||24!==e.colormap_size||1!==e.colormap_type)&&console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");break;case r:case o:case i:case s:e.colormap_type&&console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");break;case t:console.error("THREE.TGALoader: No data.");default:console.error('THREE.TGALoader: Invalid type "%s".',e.image_type)}(e.width<=0||e.height<=0)&&console.error("THREE.TGALoader: Invalid image size."),8!==e.pixel_size&&16!==e.pixel_size&&24!==e.pixel_size&&32!==e.pixel_size&&console.error('THREE.TGALoader: Invalid pixel size "%s".',e.pixel_size)}(m),m.id_length+h>e.length&&console.error("THREE.TGALoader: No data."),h+=m.id_length;let x=!1,g=!1,y=!1;switch(m.image_type){case a:x=!0,g=!0;break;case n:g=!0;break;case i:x=!0;break;case r:break;case s:x=!0,y=!0;break;case o:y=!0}const E=new Uint8Array(m.width*m.height*4),w=function(e,t,n,r,o){let a,i;const s=n.pixel_size>>3,l=n.width*n.height*s;if(t&&(i=o.subarray(r,r+=n.colormap_length*(n.colormap_size>>3))),e){let e,t,n;a=new Uint8Array(l);let i=0;const c=new Uint8Array(s);for(;i<l;)if(e=o[r++],t=1+(127&e),128&e){for(n=0;n<s;++n)c[n]=o[r++];for(n=0;n<t;++n)a.set(c,i+n*s);i+=s*t}else{for(t*=s,n=0;n<t;++n)a[i+n]=o[r++];i+=t}}else a=o.subarray(r,r+=t?n.width*n.height:l);return{pixel_data:a,palettes:i}}(x,g,m,h,v);return function(e,t,n,r,o){let a,i,s,h,v,x;switch((m.flags&l)>>c){default:case d:a=0,s=1,v=t,i=0,h=1,x=n;break;case f:a=0,s=1,v=t,i=n-1,h=-1,x=-1;break;case p:a=t-1,s=-1,v=-1,i=0,h=1,x=n;break;case u:a=t-1,s=-1,v=-1,i=n-1,h=-1,x=-1}if(y)switch(m.pixel_size){case 8:!function(e,t,n,r,o,a,i,s){let l,c,f,u=0;const d=m.width;for(f=t;f!==r;f+=n)for(c=o;c!==i;c+=a,u++)l=s[u],e[4*(c+d*f)+0]=l,e[4*(c+d*f)+1]=l,e[4*(c+d*f)+2]=l,e[4*(c+d*f)+3]=255}(e,i,h,x,a,s,v,r);break;case 16:!function(e,t,n,r,o,a,i,s){let l,c,f=0;const u=m.width;for(c=t;c!==r;c+=n)for(l=o;l!==i;l+=a,f+=2)e[4*(l+u*c)+0]=s[f+0],e[4*(l+u*c)+1]=s[f+0],e[4*(l+u*c)+2]=s[f+0],e[4*(l+u*c)+3]=s[f+1]}(e,i,h,x,a,s,v,r);break;default:console.error("THREE.TGALoader: Format not supported.")}else switch(m.pixel_size){case 8:!function(e,t,n,r,o,a,i,s,l){const c=l;let f,u,d,p=0;const h=m.width;for(d=t;d!==r;d+=n)for(u=o;u!==i;u+=a,p++)f=s[p],e[4*(u+h*d)+3]=255,e[4*(u+h*d)+2]=c[3*f+0],e[4*(u+h*d)+1]=c[3*f+1],e[4*(u+h*d)+0]=c[3*f+2]}(e,i,h,x,a,s,v,r,o);break;case 16:!function(e,t,n,r,o,a,i,s){let l,c,f,u=0;const d=m.width;for(f=t;f!==r;f+=n)for(c=o;c!==i;c+=a,u+=2)l=s[u+0]+(s[u+1]<<8),e[4*(c+d*f)+0]=(31744&l)>>7,e[4*(c+d*f)+1]=(992&l)>>2,e[4*(c+d*f)+2]=(31&l)>>3,e[4*(c+d*f)+3]=32768&l?0:255}(e,i,h,x,a,s,v,r);break;case 24:!function(e,t,n,r,o,a,i,s){let l,c,f=0;const u=m.width;for(c=t;c!==r;c+=n)for(l=o;l!==i;l+=a,f+=3)e[4*(l+u*c)+3]=255,e[4*(l+u*c)+2]=s[f+0],e[4*(l+u*c)+1]=s[f+1],e[4*(l+u*c)+0]=s[f+2]}(e,i,h,x,a,s,v,r);break;case 32:!function(e,t,n,r,o,a,i,s){let l,c,f=0;const u=m.width;for(c=t;c!==r;c+=n)for(l=o;l!==i;l+=a,f+=4)e[4*(l+u*c)+2]=s[f+0],e[4*(l+u*c)+1]=s[f+1],e[4*(l+u*c)+0]=s[f+2],e[4*(l+u*c)+3]=s[f+3]}(e,i,h,x,a,s,v,r);break;default:console.error("THREE.TGALoader: Format not supported.")}}(E,m.width,m.height,w.pixel_data,w.palettes),{data:E,width:m.width,height:m.height,flipY:!0,generateMipmaps:!0,minFilter:THREE.LinearMipmapLinearFilter}}}THREE.TGALoader=e}()},7879:()=>{THREE.TessellateModifier=class{constructor(e=.1,t=6){this.maxEdgeLength=e,this.maxIterations=t}modify(e){if(!0===e.isGeometry)return console.error("THREE.TessellateModifier no longer supports Geometry. Use THREE.BufferGeometry instead."),e;null!==e.index&&(e=e.toNonIndexed());const t=this.maxIterations,n=this.maxEdgeLength*this.maxEdgeLength,r=new THREE.Vector3,o=new THREE.Vector3,a=new THREE.Vector3,i=new THREE.Vector3,s=[r,o,a,i],l=new THREE.Vector3,c=new THREE.Vector3,f=new THREE.Vector3,u=new THREE.Vector3,d=[l,c,f,u],p=new THREE.Color,h=new THREE.Color,v=new THREE.Color,m=new THREE.Color,x=[p,h,v,m],g=new THREE.Vector2,y=new THREE.Vector2,E=new THREE.Vector2,w=new THREE.Vector2,b=[g,y,E,w],_=new THREE.Vector2,T=new THREE.Vector2,A=new THREE.Vector2,S=new THREE.Vector2,R=[_,T,A,S],M=e.attributes,C=void 0!==M.normal,L=void 0!==M.color,P=void 0!==M.uv,k=void 0!==M.uv2;let N=M.position.array,H=C?M.normal.array:null,z=L?M.color.array:null,D=P?M.uv.array:null,F=k?M.uv2.array:null,I=N,O=H,U=z,G=D,B=F,V=0,W=!0;function j(e,t,n){const r=s[e],o=s[t],a=s[n];if(I.push(r.x,r.y,r.z),I.push(o.x,o.y,o.z),I.push(a.x,a.y,a.z),C){const r=d[e],o=d[t],a=d[n];O.push(r.x,r.y,r.z),O.push(o.x,o.y,o.z),O.push(a.x,a.y,a.z)}if(L){const r=x[e],o=x[t],a=x[n];U.push(r.x,r.y,r.z),U.push(o.x,o.y,o.z),U.push(a.x,a.y,a.z)}if(P){const r=b[e],o=b[t],a=b[n];G.push(r.x,r.y),G.push(o.x,o.y),G.push(a.x,a.y)}if(k){const r=R[e],o=R[t],a=R[n];B.push(r.x,r.y),B.push(o.x,o.y),B.push(a.x,a.y)}}for(;W&&V<t;){V++,W=!1,N=I,I=[],C&&(H=O,O=[]),L&&(z=U,U=[]),P&&(D=G,G=[]),k&&(F=B,B=[]);for(let e=0,t=0,s=N.length;e<s;e+=9,t+=6){r.fromArray(N,e+0),o.fromArray(N,e+3),a.fromArray(N,e+6),C&&(l.fromArray(H,e+0),c.fromArray(H,e+3),f.fromArray(H,e+6)),L&&(p.fromArray(z,e+0),h.fromArray(z,e+3),v.fromArray(z,e+6)),P&&(g.fromArray(D,t+0),y.fromArray(D,t+2),E.fromArray(D,t+4)),k&&(_.fromArray(F,t+0),T.fromArray(F,t+2),A.fromArray(F,t+4));const s=r.distanceToSquared(o),d=o.distanceToSquared(a),x=r.distanceToSquared(a);s>n||d>n||x>n?(W=!0,s>=d&&s>=x?(i.lerpVectors(r,o,.5),C&&u.lerpVectors(l,c,.5),L&&m.lerpColors(p,h,.5),P&&w.lerpVectors(g,y,.5),k&&S.lerpVectors(_,T,.5),j(0,3,2),j(3,1,2)):d>=s&&d>=x?(i.lerpVectors(o,a,.5),C&&u.lerpVectors(c,f,.5),L&&m.lerpColors(h,v,.5),P&&w.lerpVectors(y,E,.5),k&&S.lerpVectors(T,A,.5),j(0,1,3),j(3,2,0)):(i.lerpVectors(r,a,.5),C&&u.lerpVectors(l,f,.5),L&&m.lerpColors(p,v,.5),P&&w.lerpVectors(g,E,.5),k&&S.lerpVectors(_,A,.5),j(0,1,3),j(3,1,2))):j(0,1,2)}}const q=new THREE.BufferGeometry;return q.setAttribute("position",new THREE.Float32BufferAttribute(I,3)),C&&q.setAttribute("normal",new THREE.Float32BufferAttribute(O,3)),L&&q.setAttribute("color",new THREE.Float32BufferAttribute(U,3)),P&&q.setAttribute("uv",new THREE.Float32BufferAttribute(G,2)),k&&q.setAttribute("uv2",new THREE.Float32BufferAttribute(B,2)),q}}},9443:()=>{"use strict";var e,t;window.ThreeBSP=(t=1e-5,(e=function(e){this.matrix=new THREE.Matrix4,this.create(e)}).prototype.subtract=function(t){var n=this.tree.clone(),r=t.tree.clone();return n.invert(),n.clipTo(r),r.clipTo(n),r.invert(),r.clipTo(n),r.invert(),n.build(r.allPolygons()),n.invert(),(n=new e(n)).matrix=this.matrix,n},e.prototype.union=function(t){var n=this.tree.clone(),r=t.tree.clone();return n.clipTo(r),r.clipTo(n),r.invert(),r.clipTo(n),r.invert(),n.build(r.allPolygons()),(n=new e(n)).matrix=this.matrix,n},e.prototype.intersect=function(t){var n=this.tree.clone(),r=t.tree.clone();return n.invert(),r.clipTo(n),r.invert(),n.clipTo(r),r.clipTo(n),n.build(r.allPolygons()),n.invert(),(n=new e(n)).matrix=this.matrix,n},e.prototype.create=function(t){if(t instanceof THREE.Geometry)this.fromGeometry(t);else if(t instanceof THREE.BufferGeometry)this.fromBufferGeometry(t);else{if(!(t instanceof THREE.Mesh)){if(t instanceof e.Node)return this.tree=t,this;throw new Error("ThreeBSP: is unable to create a BSP for the given input")}this.fromMesh(t)}},e.prototype.fromGeometry=function(t){var n,r,o,a,i,s,l,c=[];for(n=0,r=t.faces.length;n<r;n++)o=t.faces[n],i=t.faceVertexUvs[0][n],l=new e.Polygon,a=t.vertices[o.a],s=i?new THREE.Vector2(i[0].x,i[0].y):null,(a=new e.Vertex(a.x,a.y,a.z,o.vertexNormals[0],s)).applyMatrix4(this.matrix),l.vertices.push(a),a=t.vertices[o.b],s=i?new THREE.Vector2(i[1].x,i[1].y):null,(a=new e.Vertex(a.x,a.y,a.z,o.vertexNormals[1],s)).applyMatrix4(this.matrix),l.vertices.push(a),a=t.vertices[o.c],s=i?new THREE.Vector2(i[2].x,i[2].y):null,(a=new e.Vertex(a.x,a.y,a.z,o.vertexNormals[2],s)).applyMatrix4(this.matrix),l.vertices.push(a),l.calculateProperties(),c.push(l);this.tree=new e.Node(c)},e.prototype.fromIndexedBufferGeometry=function(t){var n,r,o,a,i,s,l,c,f,u,d,p,h,v=t.index.array,m=t.attributes.position.array,x=t.attributes.normal.array,g=t.attributes.uv.array,y=[];for(n=0,r=v.length;n<r;n+=3){for(i=new e.Polygon,s=0;s<3;s++)c=1+(l=3*(o=v[n+s])),f=l+2,d=1+(u=2*o),p=x?new THREE.Vector3(x[l],x[c],x[f]):null,h=g?new THREE.Vector2(g[u],g[d]):null,(a=new e.Vertex(m[l],m[c],m[f],p,h)).applyMatrix4(this.matrix),i.vertices.push(a);i.calculateProperties(),y.push(i)}this.tree=new e.Node(y)},e.prototype.fromNonIndexedBufferGeometry=function(t){var n,r,o,a,i,s,l=t.attributes.position.array,c=t.attributes.normal.array,f=t.attributes.uv.array,u=[];for(n=0,r=l.length;n<r;n+=9)a=new e.Polygon,i=c?new THREE.Vector3(c[n],c[n+1],c[n+2]):null,s=f?new THREE.Vector2(f[n],f[n+1]):null,(o=new e.Vertex(l[n],l[n+1],l[n+2],i,s)).applyMatrix4(this.matrix),a.vertices.push(o),i=c?new THREE.Vector3(c[n+3],c[n+4],c[n+5]):null,s=f?new THREE.Vector2(f[n+2],f[n+3]):null,(o=new e.Vertex(l[n+3],l[n+4],l[n+5],i,s)).applyMatrix4(this.matrix),a.vertices.push(o),i=c?new THREE.Vector3(c[n+6],c[n+7],c[n+8]):null,s=f?new THREE.Vector2(f[n+4],f[n+5]):null,(o=new e.Vertex(l[n+6],l[n+7],l[n+8])).applyMatrix4(this.matrix),a.vertices.push(o),a.calculateProperties(),u.push(a);this.tree=new e.Node(u)},e.prototype.fromBufferGeometry=function(e){null===e.index?this.fromNonIndexedBufferGeometry(e):this.fromIndexedBufferGeometry(e)},e.prototype.fromMesh=function(e){var t=e.geometry;e.updateMatrix(),this.matrix=e.matrix.clone(),this.create(t)},e.prototype.toGeometry=function(){var e,t,n,r,o,a,i,s,l,c,f=(new THREE.Matrix4).getInverse(this.matrix),u=new THREE.Geometry,d=this.tree.allPolygons(),p=d.length,h={};for(e=0;e<p;e++)for(r=(n=d[e]).vertices.length,t=2;t<r;t++)c=[],s=n.vertices[0],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?o=h[s.x+","+s.y+","+s.z]:(u.vertices.push(s),o=h[s.x+","+s.y+","+s.z]=u.vertices.length-1),s=n.vertices[t-1],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?a=h[s.x+","+s.y+","+s.z]:(u.vertices.push(s),a=h[s.x+","+s.y+","+s.z]=u.vertices.length-1),s=n.vertices[t],c.push(new THREE.Vector2(s.uv.x,s.uv.y)),(s=new THREE.Vector3(s.x,s.y,s.z)).applyMatrix4(f),void 0!==h[s.x+","+s.y+","+s.z]?i=h[s.x+","+s.y+","+s.z]:(u.vertices.push(s),i=h[s.x+","+s.y+","+s.z]=u.vertices.length-1),l=new THREE.Face3(o,a,i,new THREE.Vector3(n.normal.x,n.normal.y,n.normal.z)),u.faces.push(l),u.faceVertexUvs[0].push(c);return u},e.prototype.toBufferGeometry=function(){var e,t,n,r,o,a,i,s,l=(new THREE.Matrix4).getInverse(this.matrix),c=new THREE.BufferGeometry,f=[],u=[],d=[],p=[],h=this.tree.allPolygons(),v=h.length,m={},x=0;for(e=0;e<v;e++)for(r=(n=h[e]).vertices.length,t=2;t<r;t++)(s=n.vertices[0]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?o=m[s.x+","+s.y+","+s.z]:(u.push(s.x,s.y,s.z),o=x,d.push(n.normal.x,n.normal.y,n.normal.z),x++),(s=n.vertices[t-1]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?a=m[s.x+","+s.y+","+s.z]:(u.push(s.x,s.y,s.z),a=x,d.push(n.normal.x,n.normal.y,n.normal.z),x++),(s=n.vertices[t]).clone().applyMatrix4(l),p.push(s.uv.x,s.uv.y),void 0!==m[s.x+","+s.y+","+s.z]?i=m[s.x+","+s.y+","+s.z]:(u.push(s.x,s.y,s.z),i=x,d.push(n.normal.x,n.normal.y,n.normal.z),x++),f.push(o,a,i);return c.setAttribute("uv",new THREE.BufferAttribute(new Float32Array(p),2)),c.setAttribute("position",new THREE.BufferAttribute(new Float32Array(u),3)),c.setAttribute("normal",new THREE.BufferAttribute(new Float32Array(d),3)),c.setIndex(new THREE.BufferAttribute(new Uint32Array(f),1)),c},e.prototype.toMesh=function(e){var t=this.toGeometry(),n=new THREE.Mesh(t,e);return n.position.setFromMatrixPosition(this.matrix),n.rotation.setFromRotationMatrix(this.matrix),n},(e.Polygon=function(e,t,n){e instanceof Array||(e=[]),this.vertices=e,e.length>0?this.calculateProperties():this.normal=this.w=void 0}).prototype.calculateProperties=function(){var e=this.vertices[0],t=this.vertices[1],n=this.vertices[2];return this.normal=t.clone().subtract(e).cross(n.clone().subtract(e)).normalize(),this.w=this.normal.clone().dot(e),this},e.Polygon.prototype.clone=function(){var t,n,r=new e.Polygon;for(t=0,n=this.vertices.length;t<n;t++)r.vertices.push(this.vertices[t].clone());return r.calculateProperties(),r},e.Polygon.prototype.flip=function(){var e,t=[];for(this.normal.multiplyScalar(-1),this.w*=-1,e=this.vertices.length-1;e>=0;e--)t.push(this.vertices[e]);return this.vertices=t,this},e.Polygon.prototype.classifyVertex=function(e){var n=this.normal.dot(e)-this.w;return n<-1e-5?2:n>t?1:0},e.Polygon.prototype.classifySide=function(e){var t,n,r,o=0,a=0,i=e.vertices.length;for(t=0;t<i;t++)n=e.vertices[t],1===(r=this.classifyVertex(n))?o++:2===r&&a++;return o>0&&0===a?1:0===o&&a>0?2:0===o&&0===a?0:3},e.Polygon.prototype.splitPolygon=function(t,n,r,o,a){var i=this.classifySide(t);if(0===i)(this.normal.dot(t.normal)>0?n:r).push(t);else if(1===i)o.push(t);else if(2===i)a.push(t);else{var s,l,c,f,u,d,p,h,v,m=[],x=[];for(l=0,s=t.vertices.length;l<s;l++)c=(l+1)%s,d=t.vertices[l],p=t.vertices[c],f=this.classifyVertex(d),u=this.classifyVertex(p),2!=f&&m.push(d),1!=f&&x.push(d),3==(f|u)&&(h=(this.w-this.normal.dot(d))/this.normal.dot(p.clone().subtract(d)),v=d.interpolate(p,h),m.push(v),x.push(v));m.length>=3&&o.push(new e.Polygon(m).calculateProperties()),x.length>=3&&a.push(new e.Polygon(x).calculateProperties())}},(e.Vertex=function(e,t,n,r,o){this.x=e,this.y=t,this.z=n,this.normal=r||new THREE.Vector3,this.uv=o||new THREE.Vector2}).prototype.clone=function(){return new e.Vertex(this.x,this.y,this.z,this.normal.clone(),this.uv.clone())},e.Vertex.prototype.add=function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this},e.Vertex.prototype.subtract=function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this},e.Vertex.prototype.multiplyScalar=function(e){return this.x*=e,this.y*=e,this.z*=e,this},e.Vertex.prototype.cross=function(e){var t=this.x,n=this.y,r=this.z;return this.x=n*e.z-r*e.y,this.y=r*e.x-t*e.z,this.z=t*e.y-n*e.x,this},e.Vertex.prototype.normalize=function(){var e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);return this.x/=e,this.y/=e,this.z/=e,this},e.Vertex.prototype.dot=function(e){return this.x*e.x+this.y*e.y+this.z*e.z},e.Vertex.prototype.lerp=function(e,t){return this.add(e.clone().subtract(this).multiplyScalar(t)),this.normal.add(e.normal.clone().sub(this.normal).multiplyScalar(t)),this.uv.add(e.uv.clone().sub(this.uv).multiplyScalar(t)),this},e.Vertex.prototype.interpolate=function(e,t){return this.clone().lerp(e,t)},e.Vertex.prototype.applyMatrix4=function(e){var t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r+o[12],this.y=o[1]*t+o[5]*n+o[9]*r+o[13],this.z=o[2]*t+o[6]*n+o[10]*r+o[14],this},(e.Node=function(t){var n,r,o=[],a=[];if(this.polygons=[],this.front=this.back=void 0,t instanceof Array&&0!==t.length){for(this.divider=t[0].clone(),n=0,r=t.length;n<r;n++)this.divider.splitPolygon(t[n],this.polygons,this.polygons,o,a);o.length>0&&(this.front=new e.Node(o)),a.length>0&&(this.back=new e.Node(a))}}).isConvex=function(e){var t,n;for(t=0;t<e.length;t++)for(n=0;n<e.length;n++)if(t!==n&&2!==e[t].classifySide(e[n]))return!1;return!0},e.Node.prototype.build=function(t){var n,r,o=[],a=[];for(this.divider||(this.divider=t[0].clone()),n=0,r=t.length;n<r;n++)this.divider.splitPolygon(t[n],this.polygons,this.polygons,o,a);o.length>0&&(this.front||(this.front=new e.Node),this.front.build(o)),a.length>0&&(this.back||(this.back=new e.Node),this.back.build(a))},e.Node.prototype.allPolygons=function(){var e=this.polygons.slice();return this.front&&(e=e.concat(this.front.allPolygons())),this.back&&(e=e.concat(this.back.allPolygons())),e},e.Node.prototype.clone=function(){var t=new e.Node;return t.divider=this.divider.clone(),t.polygons=this.polygons.map((function(e){return e.clone()})),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t},e.Node.prototype.invert=function(){var e,t,n;for(e=0,t=this.polygons.length;e<t;e++)this.polygons[e].flip();return this.divider.flip(),this.front&&this.front.invert(),this.back&&this.back.invert(),n=this.front,this.front=this.back,this.back=n,this},e.Node.prototype.clipPolygons=function(e){var t,n,r,o;if(!this.divider)return e.slice();for(r=[],o=[],t=0,n=e.length;t<n;t++)this.divider.splitPolygon(e[t],r,o,r,o);return this.front&&(r=this.front.clipPolygons(r)),o=this.back?this.back.clipPolygons(o):[],r.concat(o)},e.Node.prototype.clipTo=function(e){this.polygons=e.clipPolygons(this.polygons),this.front&&this.front.clipTo(e),this.back&&this.back.clipTo(e)},e)},303:()=>{!function(){const e={type:"change"},t={type:"start"},n={type:"end"};class r extends THREE.EventDispatcher{constructor(r,o){super(),void 0===o&&console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.'),o===document&&console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');const a=this,i=-1,s=0,l=1,c=2,f=3,u=4;this.object=r,this.domElement=o,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.keys=["KeyA","KeyS","KeyD"],this.mouseButtons={LEFT:THREE.MOUSE.ROTATE,MIDDLE:THREE.MOUSE.DOLLY,RIGHT:THREE.MOUSE.PAN},this.target=new THREE.Vector3;const d=1e-6,p=new THREE.Vector3;let h=1,v=i,m=i,x=0,g=0,y=0;const E=new THREE.Vector3,w=new THREE.Vector2,b=new THREE.Vector2,_=new THREE.Vector3,T=new THREE.Vector2,A=new THREE.Vector2,S=new THREE.Vector2,R=new THREE.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.zoom0=this.object.zoom,this.handleResize=function(){const e=a.domElement.getBoundingClientRect(),t=a.domElement.ownerDocument.documentElement;a.screen.left=e.left+window.pageXOffset-t.clientLeft,a.screen.top=e.top+window.pageYOffset-t.clientTop,a.screen.width=e.width,a.screen.height=e.height};const M=function(){const e=new THREE.Vector2;return function(t,n){return e.set((t-a.screen.left)/a.screen.width,(n-a.screen.top)/a.screen.height),e}}(),C=function(){const e=new THREE.Vector2;return function(t,n){return e.set((t-.5*a.screen.width-a.screen.left)/(.5*a.screen.width),(a.screen.height+2*(a.screen.top-n))/a.screen.width),e}}();function L(e){if(!1!==a.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(e.preventDefault(),v===i)switch(e.button){case a.mouseButtons.LEFT:v=s;break;case a.mouseButtons.MIDDLE:v=l;break;case a.mouseButtons.RIGHT:v=c;break;default:v=i}const n=m!==i?m:v;n!==s||a.noRotate?n!==l||a.noZoom?n!==c||a.noPan||(S.copy(M(e.pageX,e.pageY)),R.copy(S)):(T.copy(M(e.pageX,e.pageY)),A.copy(T)):(b.copy(C(e.pageX,e.pageY)),w.copy(b));a.domElement.ownerDocument.addEventListener("pointermove",P),a.domElement.ownerDocument.addEventListener("pointerup",k),a.dispatchEvent(t)}(e)}}function P(e){if(!1!==a.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===a.enabled)return;e.preventDefault();const t=m!==i?m:v;t!==s||a.noRotate?t!==l||a.noZoom?t!==c||a.noPan||R.copy(M(e.pageX,e.pageY)):A.copy(M(e.pageX,e.pageY)):(w.copy(b),b.copy(C(e.pageX,e.pageY)))}(e)}}function k(e){if(!1!==a.enabled)switch(e.pointerType){case"mouse":case"pen":!function(e){if(!1===a.enabled)return;e.preventDefault(),v=i,a.domElement.ownerDocument.removeEventListener("pointermove",P),a.domElement.ownerDocument.removeEventListener("pointerup",k),a.dispatchEvent(n)}(e)}}function N(e){!1!==a.enabled&&(window.removeEventListener("keydown",N),m===i&&(e.code!==a.keys[s]||a.noRotate?e.code!==a.keys[l]||a.noZoom?e.code!==a.keys[c]||a.noPan||(m=c):m=l:m=s))}function H(){!1!==a.enabled&&(m=i,window.addEventListener("keydown",N))}function z(e){if(!1!==a.enabled&&!0!==a.noZoom){switch(e.preventDefault(),e.deltaMode){case 2:T.y-=.025*e.deltaY;break;case 1:T.y-=.01*e.deltaY;break;default:T.y-=25e-5*e.deltaY}a.dispatchEvent(t),a.dispatchEvent(n)}}function D(e){if(!1!==a.enabled){switch(e.preventDefault(),e.touches.length){case 1:v=f,b.copy(C(e.touches[0].pageX,e.touches[0].pageY)),w.copy(b);break;default:v=u;const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;g=x=Math.sqrt(t*t+n*n);const r=(e.touches[0].pageX+e.touches[1].pageX)/2,o=(e.touches[0].pageY+e.touches[1].pageY)/2;S.copy(M(r,o)),R.copy(S)}a.dispatchEvent(t)}}function F(e){if(!1!==a.enabled)switch(e.preventDefault(),e.touches.length){case 1:w.copy(b),b.copy(C(e.touches[0].pageX,e.touches[0].pageY));break;default:const t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;g=Math.sqrt(t*t+n*n);const r=(e.touches[0].pageX+e.touches[1].pageX)/2,o=(e.touches[0].pageY+e.touches[1].pageY)/2;R.copy(M(r,o))}}function I(e){if(!1!==a.enabled){switch(e.touches.length){case 0:v=i;break;case 1:v=f,b.copy(C(e.touches[0].pageX,e.touches[0].pageY)),w.copy(b)}a.dispatchEvent(n)}}function O(e){!1!==a.enabled&&e.preventDefault()}this.rotateCamera=function(){const e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,r=new THREE.Vector3,o=new THREE.Vector3,i=new THREE.Vector3;return function(){i.set(b.x-w.x,b.y-w.y,0);let s=i.length();s?(E.copy(a.object.position).sub(a.target),n.copy(E).normalize(),r.copy(a.object.up).normalize(),o.crossVectors(r,n).normalize(),r.setLength(b.y-w.y),o.setLength(b.x-w.x),i.copy(r.add(o)),e.crossVectors(i,E).normalize(),s*=a.rotateSpeed,t.setFromAxisAngle(e,s),E.applyQuaternion(t),a.object.up.applyQuaternion(t),_.copy(e),y=s):!a.staticMoving&&y&&(y*=Math.sqrt(1-a.dynamicDampingFactor),E.copy(a.object.position).sub(a.target),t.setFromAxisAngle(_,y),E.applyQuaternion(t),a.object.up.applyQuaternion(t)),w.copy(b)}}(),this.zoomCamera=function(){let e;v===u?(e=x/g,x=g,a.object.isPerspectiveCamera?E.multiplyScalar(e):a.object.isOrthographicCamera?(a.object.zoom*=e,a.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(e=1+(A.y-T.y)*a.zoomSpeed,1!==e&&e>0&&(a.object.isPerspectiveCamera?E.multiplyScalar(e):a.object.isOrthographicCamera?(a.object.zoom/=e,a.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),a.staticMoving?T.copy(A):T.y+=(A.y-T.y)*this.dynamicDampingFactor)},this.panCamera=function(){const e=new THREE.Vector2,t=new THREE.Vector3,n=new THREE.Vector3;return function(){if(e.copy(R).sub(S),e.lengthSq()){if(a.object.isOrthographicCamera){const t=(a.object.right-a.object.left)/a.object.zoom/a.domElement.clientWidth,n=(a.object.top-a.object.bottom)/a.object.zoom/a.domElement.clientWidth;e.x*=t,e.y*=n}e.multiplyScalar(E.length()*a.panSpeed),n.copy(E).cross(a.object.up).setLength(e.x),n.add(t.copy(a.object.up).setLength(e.y)),a.object.position.add(n),a.target.add(n),a.staticMoving?S.copy(R):S.add(e.subVectors(R,S).multiplyScalar(a.dynamicDampingFactor))}}}(),this.checkDistances=function(){a.noZoom&&a.noPan||(E.lengthSq()>a.maxDistance*a.maxDistance&&(a.object.position.addVectors(a.target,E.setLength(a.maxDistance)),T.copy(A)),E.lengthSq()<a.minDistance*a.minDistance&&(a.object.position.addVectors(a.target,E.setLength(a.minDistance)),T.copy(A)))},this.update=function(){E.subVectors(a.object.position,a.target),a.noRotate||a.rotateCamera(),a.noZoom||a.zoomCamera(),a.noPan||a.panCamera(),a.object.position.addVectors(a.target,E),a.object.isPerspectiveCamera?(a.checkDistances(),a.object.lookAt(a.target),p.distanceToSquared(a.object.position)>d&&(a.dispatchEvent(e),p.copy(a.object.position))):a.object.isOrthographicCamera?(a.object.lookAt(a.target),(p.distanceToSquared(a.object.position)>d||h!==a.object.zoom)&&(a.dispatchEvent(e),p.copy(a.object.position),h=a.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type")},this.reset=function(){v=i,m=i,a.target.copy(a.target0),a.object.position.copy(a.position0),a.object.up.copy(a.up0),a.object.zoom=a.zoom0,a.object.updateProjectionMatrix(),E.subVectors(a.object.position,a.target),a.object.lookAt(a.target),a.dispatchEvent(e),p.copy(a.object.position),h=a.object.zoom},this.dispose=function(){a.domElement.removeEventListener("contextmenu",O),a.domElement.removeEventListener("pointerdown",L),a.domElement.removeEventListener("wheel",z),a.domElement.removeEventListener("touchstart",D),a.domElement.removeEventListener("touchend",I),a.domElement.removeEventListener("touchmove",F),a.domElement.ownerDocument.removeEventListener("pointermove",P),a.domElement.ownerDocument.removeEventListener("pointerup",k),window.removeEventListener("keydown",N),window.removeEventListener("keyup",H)},this.domElement.addEventListener("contextmenu",O),this.domElement.addEventListener("pointerdown",L),this.domElement.addEventListener("wheel",z,{passive:!1}),this.domElement.addEventListener("touchstart",D,{passive:!1}),this.domElement.addEventListener("touchend",I),this.domElement.addEventListener("touchmove",F,{passive:!1}),this.domElement.ownerDocument.addEventListener("pointermove",P),this.domElement.ownerDocument.addEventListener("pointerup",k),window.addEventListener("keydown",N),window.addEventListener("keyup",H),this.handleResize(),this.update()}}THREE.TrackballControls=r}()},841:()=>{!function(){const e=new THREE.Raycaster,t=new THREE.Vector3,n=new THREE.Vector3,r=new THREE.Quaternion,o={X:new THREE.Vector3(1,0,0),Y:new THREE.Vector3(0,1,0),Z:new THREE.Vector3(0,0,1)},a={type:"change"},i={type:"mouseDown"},s={type:"mouseUp",mode:null},l={type:"objectChange"};class c extends THREE.Object3D{constructor(e,t){super(),void 0===t&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.visible=!1,this.domElement=t;const n=new L;this._gizmo=n,this.add(n);const r=new P;this._plane=r,this.add(r);const o=this;function i(e,t){let i=t;Object.defineProperty(o,e,{get:function(){return void 0!==i?i:t},set:function(t){i!==t&&(i=t,r[e]=t,n[e]=t,o.dispatchEvent({type:e+"-changed",value:t}),o.dispatchEvent(a))}}),o[e]=t,r[e]=t,n[e]=t}i("camera",e),i("object",void 0),i("enabled",!0),i("axis",null),i("mode","translate"),i("translationSnap",null),i("rotationSnap",null),i("scaleSnap",null),i("space","world"),i("size",1),i("dragging",!1),i("showX",!0),i("showY",!0),i("showZ",!0);const s=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Quaternion,v=new THREE.Quaternion,m=new THREE.Vector3,x=new THREE.Quaternion,g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Vector3,w=new THREE.Vector3;i("worldPosition",s),i("worldPositionStart",l),i("worldQuaternion",c),i("worldQuaternionStart",v),i("cameraPosition",m),i("cameraQuaternion",x),i("pointStart",g),i("pointEnd",y),i("rotationAxis",E),i("rotationAngle",0),i("eye",w),this._offset=new THREE.Vector3,this._startNorm=new THREE.Vector3,this._endNorm=new THREE.Vector3,this._cameraScale=new THREE.Vector3,this._parentPosition=new THREE.Vector3,this._parentQuaternion=new THREE.Quaternion,this._parentQuaternionInv=new THREE.Quaternion,this._parentScale=new THREE.Vector3,this._worldScaleStart=new THREE.Vector3,this._worldQuaternionInv=new THREE.Quaternion,this._worldScale=new THREE.Vector3,this._positionStart=new THREE.Vector3,this._quaternionStart=new THREE.Quaternion,this._scaleStart=new THREE.Vector3,this._getPointer=f.bind(this),this._onPointerDown=d.bind(this),this._onPointerHover=u.bind(this),this._onPointerMove=p.bind(this),this._onPointerUp=h.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.ownerDocument.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){void 0!==this.object&&(this.object.updateMatrixWorld(),null===this.object.parent?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(t){if(void 0===this.object||!0===this.dragging)return;e.setFromCamera(t,this.camera);const n=v(this._gizmo.picker[this.mode],e);this.axis=n?n.object.name:null}pointerDown(t){if(void 0!==this.object&&!0!==this.dragging&&0===t.button&&null!==this.axis){e.setFromCamera(t,this.camera);const n=v(this._plane,e,!0);if(n){let e=this.space;if("scale"===this.mode?e="local":"E"!==this.axis&&"XYZE"!==this.axis&&"XYZ"!==this.axis||(e="world"),"local"===e&&"rotate"===this.mode){const e=this.rotationSnap;"X"===this.axis&&e&&(this.object.rotation.x=Math.round(this.object.rotation.x/e)*e),"Y"===this.axis&&e&&(this.object.rotation.y=Math.round(this.object.rotation.y/e)*e),"Z"===this.axis&&e&&(this.object.rotation.z=Math.round(this.object.rotation.z/e)*e)}this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(n.point).sub(this.worldPositionStart)}this.dragging=!0,i.mode=this.mode,this.dispatchEvent(i)}}pointerMove(i){const s=this.axis,c=this.mode,f=this.object;let u=this.space;if("scale"===c?u="local":"E"!==s&&"XYZE"!==s&&"XYZ"!==s||(u="world"),void 0===f||null===s||!1===this.dragging||-1!==i.button)return;e.setFromCamera(i,this.camera);const d=v(this._plane,e,!0);if(d){if(this.pointEnd.copy(d.point).sub(this.worldPositionStart),"translate"===c)this._offset.copy(this.pointEnd).sub(this.pointStart),"local"===u&&"XYZ"!==s&&this._offset.applyQuaternion(this._worldQuaternionInv),-1===s.indexOf("X")&&(this._offset.x=0),-1===s.indexOf("Y")&&(this._offset.y=0),-1===s.indexOf("Z")&&(this._offset.z=0),"local"===u&&"XYZ"!==s?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),f.position.copy(this._offset).add(this._positionStart),this.translationSnap&&("local"===u&&(f.position.applyQuaternion(r.copy(this._quaternionStart).invert()),-1!==s.search("X")&&(f.position.x=Math.round(f.position.x/this.translationSnap)*this.translationSnap),-1!==s.search("Y")&&(f.position.y=Math.round(f.position.y/this.translationSnap)*this.translationSnap),-1!==s.search("Z")&&(f.position.z=Math.round(f.position.z/this.translationSnap)*this.translationSnap),f.position.applyQuaternion(this._quaternionStart)),"world"===u&&(f.parent&&f.position.add(t.setFromMatrixPosition(f.parent.matrixWorld)),-1!==s.search("X")&&(f.position.x=Math.round(f.position.x/this.translationSnap)*this.translationSnap),-1!==s.search("Y")&&(f.position.y=Math.round(f.position.y/this.translationSnap)*this.translationSnap),-1!==s.search("Z")&&(f.position.z=Math.round(f.position.z/this.translationSnap)*this.translationSnap),f.parent&&f.position.sub(t.setFromMatrixPosition(f.parent.matrixWorld))));else if("scale"===c){if(-1!==s.search("XYZ")){let e=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(e*=-1),n.set(e,e,e)}else t.copy(this.pointStart),n.copy(this.pointEnd),t.applyQuaternion(this._worldQuaternionInv),n.applyQuaternion(this._worldQuaternionInv),n.divide(t),-1===s.search("X")&&(n.x=1),-1===s.search("Y")&&(n.y=1),-1===s.search("Z")&&(n.z=1);f.scale.copy(this._scaleStart).multiply(n),this.scaleSnap&&(-1!==s.search("X")&&(f.scale.x=Math.round(f.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==s.search("Y")&&(f.scale.y=Math.round(f.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),-1!==s.search("Z")&&(f.scale.z=Math.round(f.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if("rotate"===c){this._offset.copy(this.pointEnd).sub(this.pointStart);const e=20/this.worldPosition.distanceTo(t.setFromMatrixPosition(this.camera.matrixWorld));"E"===s?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):"XYZE"===s?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(t.copy(this.rotationAxis).cross(this.eye))*e):"X"!==s&&"Y"!==s&&"Z"!==s||(this.rotationAxis.copy(o[s]),t.copy(o[s]),"local"===u&&t.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(t.cross(this.eye).normalize())*e),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),"local"===u&&"E"!==s&&"XYZE"!==s?(f.quaternion.copy(this._quaternionStart),f.quaternion.multiply(r.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),f.quaternion.copy(r.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),f.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(a),this.dispatchEvent(l)}}pointerUp(e){0===e.button&&(this.dragging&&null!==this.axis&&(s.mode=this.mode,this.dispatchEvent(s)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.traverse((function(e){e.geometry&&e.geometry.dispose(),e.material&&e.material.dispose()}))}attach(e){return this.object=e,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}getMode(){return this.mode}setMode(e){this.mode=e}setTranslationSnap(e){this.translationSnap=e}setRotationSnap(e){this.rotationSnap=e}setScaleSnap(e){this.scaleSnap=e}setSize(e){this.size=e}setSpace(e){this.space=e}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function f(e){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:e.button};{const t=e.changedTouches?e.changedTouches[0]:e,n=this.domElement.getBoundingClientRect();return{x:(t.clientX-n.left)/n.width*2-1,y:-(t.clientY-n.top)/n.height*2+1,button:e.button}}}function u(e){if(this.enabled)switch(e.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(e))}}function d(e){this.enabled&&(this.domElement.style.touchAction="none",this.domElement.ownerDocument.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(e)),this.pointerDown(this._getPointer(e)))}function p(e){this.enabled&&this.pointerMove(this._getPointer(e))}function h(e){this.enabled&&(this.domElement.style.touchAction="",this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(e)))}function v(e,t,n){const r=t.intersectObject(e,!0);for(let e=0;e<r.length;e++)if(r[e].object.visible||n)return r[e];return!1}c.prototype.isTransformControls=!0;const m=new THREE.Euler,x=new THREE.Vector3(0,1,0),g=new THREE.Vector3(0,0,0),y=new THREE.Matrix4,E=new THREE.Quaternion,w=new THREE.Quaternion,b=new THREE.Vector3,_=new THREE.Matrix4,T=new THREE.Vector3(1,0,0),A=new THREE.Vector3(0,1,0),S=new THREE.Vector3(0,0,1),R=new THREE.Vector3,M=new THREE.Vector3,C=new THREE.Vector3;class L extends THREE.Object3D{constructor(){super(),this.type="TransformControlsGizmo";const e=new THREE.MeshBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,side:THREE.DoubleSide,fog:!1,toneMapped:!1}),t=new THREE.LineBasicMaterial({depthTest:!1,depthWrite:!1,transparent:!0,linewidth:1,fog:!1,toneMapped:!1}),n=e.clone();n.opacity=.15;const r=e.clone();r.opacity=.33;const o=e.clone();o.color.set(16711680);const a=e.clone();a.color.set(65280);const i=e.clone();i.color.set(255);const s=e.clone();s.opacity=.25;const l=s.clone();l.color.set(16776960);const c=s.clone();c.color.set(65535);const f=s.clone();f.color.set(16711935);e.clone().color.set(16776960);const u=t.clone();u.color.set(16711680);const d=t.clone();d.color.set(65280);const p=t.clone();p.color.set(255);const h=t.clone();h.color.set(65535);const v=t.clone();v.color.set(16711935);const m=t.clone();m.color.set(16776960);const x=t.clone();x.color.set(7895160);const g=m.clone();g.opacity=.25;const y=new THREE.CylinderGeometry(0,.05,.2,12,1,!1),E=new THREE.BoxGeometry(.125,.125,.125),w=new THREE.BufferGeometry;function b(e,t){const n=new THREE.BufferGeometry,r=[];for(let n=0;n<=64*t;++n)r.push(0,Math.cos(n/32*Math.PI)*e,Math.sin(n/32*Math.PI)*e);return n.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),n}w.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,0,0],3));const _={X:[[new THREE.Mesh(y,o),[1,0,0],[0,0,-Math.PI/2],null,"fwd"],[new THREE.Mesh(y,o),[1,0,0],[0,0,Math.PI/2],null,"bwd"],[new THREE.Line(w,u)]],Y:[[new THREE.Mesh(y,a),[0,1,0],null,null,"fwd"],[new THREE.Mesh(y,a),[0,1,0],[Math.PI,0,0],null,"bwd"],[new THREE.Line(w,d),null,[0,0,Math.PI/2]]],Z:[[new THREE.Mesh(y,i),[0,0,1],[Math.PI/2,0,0],null,"fwd"],[new THREE.Mesh(y,i),[0,0,1],[-Math.PI/2,0,0],null,"bwd"],[new THREE.Line(w,p),null,[0,-Math.PI/2,0]]],XYZ:[[new THREE.Mesh(new THREE.OctahedronGeometry(.1,0),s.clone()),[0,0,0],[0,0,0]]],XY:[[new THREE.Mesh(new THREE.PlaneGeometry(.295,.295),l.clone()),[.15,.15,0]],[new THREE.Line(w,m),[.18,.3,0],null,[.125,1,1]],[new THREE.Line(w,m),[.3,.18,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new THREE.Mesh(new THREE.PlaneGeometry(.295,.295),c.clone()),[0,.15,.15],[0,Math.PI/2,0]],[new THREE.Line(w,h),[0,.18,.3],[0,0,Math.PI/2],[.125,1,1]],[new THREE.Line(w,h),[0,.3,.18],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new THREE.Mesh(new THREE.PlaneGeometry(.295,.295),f.clone()),[.15,0,.15],[-Math.PI/2,0,0]],[new THREE.Line(w,v),[.18,0,.3],null,[.125,1,1]],[new THREE.Line(w,v),[.3,0,.18],[0,-Math.PI/2,0],[.125,1,1]]]},T={X:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),n),[.6,0,0],[0,0,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),n),[0,.6,0]]],Z:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,1,4,1,!1),n),[0,0,.6],[Math.PI/2,0,0]]],XYZ:[[new THREE.Mesh(new THREE.OctahedronGeometry(.2,0),n)]],XY:[[new THREE.Mesh(new THREE.PlaneGeometry(.4,.4),n),[.2,.2,0]]],YZ:[[new THREE.Mesh(new THREE.PlaneGeometry(.4,.4),n),[0,.2,.2],[0,Math.PI/2,0]]],XZ:[[new THREE.Mesh(new THREE.PlaneGeometry(.4,.4),n),[.2,0,.2],[-Math.PI/2,0,0]]]},A={START:[[new THREE.Mesh(new THREE.OctahedronGeometry(.01,2),r),null,null,null,"helper"]],END:[[new THREE.Mesh(new THREE.OctahedronGeometry(.01,2),r),null,null,null,"helper"]],DELTA:[[new THREE.Line(function(){const e=new THREE.BufferGeometry;return e.setAttribute("position",new THREE.Float32BufferAttribute([0,0,0,1,1,1],3)),e}(),r),null,null,null,"helper"]],X:[[new THREE.Line(w,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new THREE.Line(w,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new THREE.Line(w,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},S={X:[[new THREE.Line(b(1,.5),u)],[new THREE.Mesh(new THREE.OctahedronGeometry(.04,0),o),[0,0,.99],null,[1,3,1]]],Y:[[new THREE.Line(b(1,.5),d),null,[0,0,-Math.PI/2]],[new THREE.Mesh(new THREE.OctahedronGeometry(.04,0),a),[0,0,.99],null,[3,1,1]]],Z:[[new THREE.Line(b(1,.5),p),null,[0,Math.PI/2,0]],[new THREE.Mesh(new THREE.OctahedronGeometry(.04,0),i),[.99,0,0],null,[1,3,1]]],E:[[new THREE.Line(b(1.25,1),g),null,[0,Math.PI/2,0]],[new THREE.Mesh(new THREE.CylinderGeometry(.03,0,.15,4,1,!1),g),[1.17,0,0],[0,0,-Math.PI/2],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderGeometry(.03,0,.15,4,1,!1),g),[-1.17,0,0],[0,0,Math.PI/2],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderGeometry(.03,0,.15,4,1,!1),g),[0,-1.17,0],[Math.PI,0,0],[1,1,.001]],[new THREE.Mesh(new THREE.CylinderGeometry(.03,0,.15,4,1,!1),g),[0,1.17,0],[0,0,0],[1,1,.001]]],XYZE:[[new THREE.Line(b(1,1),x),null,[0,Math.PI/2,0]]]},R={AXIS:[[new THREE.Line(w,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},M={X:[[new THREE.Mesh(new THREE.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.TorusGeometry(1,.1,4,24),n),[0,0,0],[Math.PI/2,0,0]]],Z:[[new THREE.Mesh(new THREE.TorusGeometry(1,.1,4,24),n),[0,0,0],[0,0,-Math.PI/2]]],E:[[new THREE.Mesh(new THREE.TorusGeometry(1.25,.1,2,24),n)]],XYZE:[[new THREE.Mesh(new THREE.SphereGeometry(.7,10,8),n)]]},C={X:[[new THREE.Mesh(E,o),[.8,0,0],[0,0,-Math.PI/2]],[new THREE.Line(w,u),null,null,[.8,1,1]]],Y:[[new THREE.Mesh(E,a),[0,.8,0]],[new THREE.Line(w,d),null,[0,0,Math.PI/2],[.8,1,1]]],Z:[[new THREE.Mesh(E,i),[0,0,.8],[Math.PI/2,0,0]],[new THREE.Line(w,p),null,[0,-Math.PI/2,0],[.8,1,1]]],XY:[[new THREE.Mesh(E,l),[.85,.85,0],null,[2,2,.2]],[new THREE.Line(w,m),[.855,.98,0],null,[.125,1,1]],[new THREE.Line(w,m),[.98,.855,0],[0,0,Math.PI/2],[.125,1,1]]],YZ:[[new THREE.Mesh(E,c),[0,.85,.85],null,[.2,2,2]],[new THREE.Line(w,h),[0,.855,.98],[0,0,Math.PI/2],[.125,1,1]],[new THREE.Line(w,h),[0,.98,.855],[0,-Math.PI/2,0],[.125,1,1]]],XZ:[[new THREE.Mesh(E,f),[.85,0,.85],null,[2,.2,2]],[new THREE.Line(w,v),[.855,0,.98],null,[.125,1,1]],[new THREE.Line(w,v),[.98,0,.855],[0,-Math.PI/2,0],[.125,1,1]]],XYZX:[[new THREE.Mesh(new THREE.BoxGeometry(.125,.125,.125),s.clone()),[1.1,0,0]]],XYZY:[[new THREE.Mesh(new THREE.BoxGeometry(.125,.125,.125),s.clone()),[0,1.1,0]]],XYZZ:[[new THREE.Mesh(new THREE.BoxGeometry(.125,.125,.125),s.clone()),[0,0,1.1]]]},L={X:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,.8,4,1,!1),n),[.5,0,0],[0,0,-Math.PI/2]]],Y:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,.5,0]]],Z:[[new THREE.Mesh(new THREE.CylinderGeometry(.2,0,.8,4,1,!1),n),[0,0,.5],[Math.PI/2,0,0]]],XY:[[new THREE.Mesh(E,n),[.85,.85,0],null,[3,3,.2]]],YZ:[[new THREE.Mesh(E,n),[0,.85,.85],null,[.2,3,3]]],XZ:[[new THREE.Mesh(E,n),[.85,0,.85],null,[3,.2,3]]],XYZX:[[new THREE.Mesh(new THREE.BoxGeometry(.2,.2,.2),n),[1.1,0,0]]],XYZY:[[new THREE.Mesh(new THREE.BoxGeometry(.2,.2,.2),n),[0,1.1,0]]],XYZZ:[[new THREE.Mesh(new THREE.BoxGeometry(.2,.2,.2),n),[0,0,1.1]]]},P={X:[[new THREE.Line(w,r.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new THREE.Line(w,r.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new THREE.Line(w,r.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function k(e){const t=new THREE.Object3D;for(const n in e)for(let r=e[n].length;r--;){const o=e[n][r][0].clone(),a=e[n][r][1],i=e[n][r][2],s=e[n][r][3],l=e[n][r][4];o.name=n,o.tag=l,a&&o.position.set(a[0],a[1],a[2]),i&&o.rotation.set(i[0],i[1],i[2]),s&&o.scale.set(s[0],s[1],s[2]),o.updateMatrix();const c=o.geometry.clone();c.applyMatrix4(o.matrix),o.geometry=c,o.renderOrder=1/0,o.position.set(0,0,0),o.rotation.set(0,0,0),o.scale.set(1,1,1),t.add(o)}return t}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=k(_)),this.add(this.gizmo.rotate=k(S)),this.add(this.gizmo.scale=k(C)),this.add(this.picker.translate=k(T)),this.add(this.picker.rotate=k(M)),this.add(this.picker.scale=k(L)),this.add(this.helper.translate=k(A)),this.add(this.helper.rotate=k(R)),this.add(this.helper.scale=k(P)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(e){const n="local"===("scale"===this.mode?this.space:"local")?this.worldQuaternion:w;this.gizmo.translate.visible="translate"===this.mode,this.gizmo.rotate.visible="rotate"===this.mode,this.gizmo.scale.visible="scale"===this.mode,this.helper.translate.visible="translate"===this.mode,this.helper.rotate.visible="rotate"===this.mode,this.helper.scale.visible="scale"===this.mode;let o=[];o=o.concat(this.picker[this.mode].children),o=o.concat(this.gizmo[this.mode].children),o=o.concat(this.helper[this.mode].children);for(let e=0;e<o.length;e++){const a=o[e];let i;if(a.visible=!0,a.rotation.set(0,0,0),a.position.copy(this.worldPosition),i=this.camera.isOrthographicCamera?(this.camera.top-this.camera.bottom)/this.camera.zoom:this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),a.scale.set(1,1,1).multiplyScalar(i*this.size/7),"helper"!==a.tag){if(a.quaternion.copy(n),"translate"===this.mode||"scale"===this.mode){const e=.99,t=.2,r=0;"X"!==a.name&&"XYZX"!==a.name||Math.abs(x.copy(T).applyQuaternion(n).dot(this.eye))>e&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),"Y"!==a.name&&"XYZY"!==a.name||Math.abs(x.copy(A).applyQuaternion(n).dot(this.eye))>e&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),"Z"!==a.name&&"XYZZ"!==a.name||Math.abs(x.copy(S).applyQuaternion(n).dot(this.eye))>e&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),"XY"===a.name&&Math.abs(x.copy(S).applyQuaternion(n).dot(this.eye))<t&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),"YZ"===a.name&&Math.abs(x.copy(T).applyQuaternion(n).dot(this.eye))<t&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),"XZ"===a.name&&Math.abs(x.copy(A).applyQuaternion(n).dot(this.eye))<t&&(a.scale.set(1e-10,1e-10,1e-10),a.visible=!1),-1!==a.name.search("X")&&(x.copy(T).applyQuaternion(n).dot(this.eye)<r?"fwd"===a.tag?a.visible=!1:a.scale.x*=-1:"bwd"===a.tag&&(a.visible=!1)),-1!==a.name.search("Y")&&(x.copy(A).applyQuaternion(n).dot(this.eye)<r?"fwd"===a.tag?a.visible=!1:a.scale.y*=-1:"bwd"===a.tag&&(a.visible=!1)),-1!==a.name.search("Z")&&(x.copy(S).applyQuaternion(n).dot(this.eye)<r?"fwd"===a.tag?a.visible=!1:a.scale.z*=-1:"bwd"===a.tag&&(a.visible=!1))}else"rotate"===this.mode&&(E.copy(n),x.copy(this.eye).applyQuaternion(r.copy(n).invert()),-1!==a.name.search("E")&&a.quaternion.setFromRotationMatrix(y.lookAt(this.eye,g,A)),"X"===a.name&&(r.setFromAxisAngle(T,Math.atan2(-x.y,x.z)),r.multiplyQuaternions(E,r),a.quaternion.copy(r)),"Y"===a.name&&(r.setFromAxisAngle(A,Math.atan2(x.x,x.z)),r.multiplyQuaternions(E,r),a.quaternion.copy(r)),"Z"===a.name&&(r.setFromAxisAngle(S,Math.atan2(x.y,x.x)),r.multiplyQuaternions(E,r),a.quaternion.copy(r)));a.visible=a.visible&&(-1===a.name.indexOf("X")||this.showX),a.visible=a.visible&&(-1===a.name.indexOf("Y")||this.showY),a.visible=a.visible&&(-1===a.name.indexOf("Z")||this.showZ),a.visible=a.visible&&(-1===a.name.indexOf("E")||this.showX&&this.showY&&this.showZ),a.material._opacity=a.material._opacity||a.material.opacity,a.material._color=a.material._color||a.material.color.clone(),a.material.color.copy(a.material._color),a.material.opacity=a.material._opacity,this.enabled?this.axis&&(a.name===this.axis||this.axis.split("").some((function(e){return a.name===e}))?(a.material.opacity=1,a.material.color.lerp(new THREE.Color(1,1,1),.5)):(a.material.opacity*=.25,a.material.color.lerp(new THREE.Color(1,1,1),.5))):(a.material.opacity*=.5,a.material.color.lerp(new THREE.Color(1,1,1),.5))}else a.visible=!1,"AXIS"===a.name?(a.position.copy(this.worldPositionStart),a.visible=!!this.axis,"X"===this.axis&&(r.setFromEuler(m.set(0,0,0)),a.quaternion.copy(n).multiply(r),Math.abs(x.copy(T).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),"Y"===this.axis&&(r.setFromEuler(m.set(0,0,Math.PI/2)),a.quaternion.copy(n).multiply(r),Math.abs(x.copy(A).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),"Z"===this.axis&&(r.setFromEuler(m.set(0,Math.PI/2,0)),a.quaternion.copy(n).multiply(r),Math.abs(x.copy(S).applyQuaternion(n).dot(this.eye))>.9&&(a.visible=!1)),"XYZE"===this.axis&&(r.setFromEuler(m.set(0,Math.PI/2,0)),x.copy(this.rotationAxis),a.quaternion.setFromRotationMatrix(y.lookAt(g,x,A)),a.quaternion.multiply(r),a.visible=this.dragging),"E"===this.axis&&(a.visible=!1)):"START"===a.name?(a.position.copy(this.worldPositionStart),a.visible=this.dragging):"END"===a.name?(a.position.copy(this.worldPosition),a.visible=this.dragging):"DELTA"===a.name?(a.position.copy(this.worldPositionStart),a.quaternion.copy(this.worldQuaternionStart),t.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),t.applyQuaternion(this.worldQuaternionStart.clone().invert()),a.scale.copy(t),a.visible=this.dragging):(a.quaternion.copy(n),this.dragging?a.position.copy(this.worldPositionStart):a.position.copy(this.worldPosition),this.axis&&(a.visible=-1!==this.axis.search(a.name)))}super.updateMatrixWorld(e)}}L.prototype.isTransformControlsGizmo=!0;class P extends THREE.Mesh{constructor(){super(new THREE.PlaneGeometry(1e5,1e5,2,2),new THREE.MeshBasicMaterial({visible:!1,wireframe:!0,side:THREE.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.type="TransformControlsPlane"}updateMatrixWorld(e){let n=this.space;switch(this.position.copy(this.worldPosition),"scale"===this.mode&&(n="local"),R.copy(T).applyQuaternion("local"===n?this.worldQuaternion:w),M.copy(A).applyQuaternion("local"===n?this.worldQuaternion:w),C.copy(S).applyQuaternion("local"===n?this.worldQuaternion:w),x.copy(M),this.mode){case"translate":case"scale":switch(this.axis){case"X":x.copy(this.eye).cross(R),b.copy(R).cross(x);break;case"Y":x.copy(this.eye).cross(M),b.copy(M).cross(x);break;case"Z":x.copy(this.eye).cross(C),b.copy(C).cross(x);break;case"XY":b.copy(C);break;case"YZ":b.copy(R);break;case"XZ":x.copy(C),b.copy(M);break;case"XYZ":case"E":b.set(0,0,0)}break;case"rotate":default:b.set(0,0,0)}0===b.length()?this.quaternion.copy(this.cameraQuaternion):(_.lookAt(t.set(0,0,0),b,x),this.quaternion.setFromRotationMatrix(_)),super.updateMatrixWorld(e)}}P.prototype.isTransformControlsPlane=!0,THREE.TransformControls=c,THREE.TransformControlsGizmo=L,THREE.TransformControlsPlane=P}()},7763:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\n\t\t\tgl_FragColor = vec4( vec3( depth ), opacity );\n\n\t\t}"};THREE.UnpackDepthRGBAShader=e}()},8168:()=>{!function(){class e extends THREE.Pass{constructor(e,t,n,r){super(),this.strength=void 0!==t?t:1,this.radius=n,this.threshold=r,this.resolution=void 0!==e?new THREE.Vector2(e.x,e.y):new THREE.Vector2(256,256),this.clearColor=new THREE.Color(0,0,0);const o={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let a=Math.round(this.resolution.x/2),i=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(a,i,o),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let e=0;e<this.nMips;e++){const t=new THREE.WebGLRenderTarget(a,i,o);t.texture.name="UnrealBloomPass.h"+e,t.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(t);const n=new THREE.WebGLRenderTarget(a,i,o);n.texture.name="UnrealBloomPass.v"+e,n.texture.generateMipmaps=!1,this.renderTargetsVertical.push(n),a=Math.round(a/2),i=Math.round(i/2)}void 0===THREE.LuminosityHighPassShader&&console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");const s=THREE.LuminosityHighPassShader;this.highPassUniforms=THREE.UniformsUtils.clone(s.uniforms),this.highPassUniforms.luminosityThreshold.value=r,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new THREE.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const l=[3,5,7,9,11];a=Math.round(this.resolution.x/2),i=Math.round(this.resolution.y/2);for(let e=0;e<this.nMips;e++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[e])),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(a,i),a=Math.round(a/2),i=Math.round(i/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;this.compositeMaterial.uniforms.bloomFactors.value=[1,.8,.6,.4,.2],this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,void 0===THREE.CopyShader&&console.error("THREE.UnrealBloomPass relies on THREE.CopyShader");const c=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(c.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.basic=new THREE.MeshBasicMaterial,this.fsQuad=new THREE.FullScreenQuad(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let n=Math.round(e/2),r=Math.round(t/2);this.renderTargetBright.setSize(n,r);for(let e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(n,r),this.renderTargetsVertical[e].setSize(n,r),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(n,r),n=Math.round(n/2),r=Math.round(r/2)}render(t,n,r,o,a){t.getClearColor(this._oldClearColor),this.oldClearAlpha=t.getClearAlpha();const i=t.autoClear;t.autoClear=!1,t.setClearColor(this.clearColor,0),a&&t.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=r.texture,t.setRenderTarget(null),t.clear(),this.fsQuad.render(t)),this.highPassUniforms.tDiffuse.value=r.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,t.setRenderTarget(this.renderTargetBright),t.clear(),this.fsQuad.render(t);let s=this.renderTargetBright;for(let n=0;n<this.nMips;n++)this.fsQuad.material=this.separableBlurMaterials[n],this.separableBlurMaterials[n].uniforms.colorTexture.value=s.texture,this.separableBlurMaterials[n].uniforms.direction.value=e.BlurDirectionX,t.setRenderTarget(this.renderTargetsHorizontal[n]),t.clear(),this.fsQuad.render(t),this.separableBlurMaterials[n].uniforms.colorTexture.value=this.renderTargetsHorizontal[n].texture,this.separableBlurMaterials[n].uniforms.direction.value=e.BlurDirectionY,t.setRenderTarget(this.renderTargetsVertical[n]),t.clear(),this.fsQuad.render(t),s=this.renderTargetsVertical[n];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,t.setRenderTarget(this.renderTargetsHorizontal[0]),t.clear(),this.fsQuad.render(t),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,a&&t.state.buffers.stencil.setTest(!0),this.renderToScreen?(t.setRenderTarget(null),this.fsQuad.render(t)):(t.setRenderTarget(r),this.fsQuad.render(t)),t.setClearColor(this._oldClearColor,this.oldClearAlpha),t.autoClear=i}getSeperableBlurMaterial(e){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})}getCompositeMaterial(e){return new THREE.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform sampler2D dirtTexture;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}"})}}e.BlurDirectionX=new THREE.Vector2(1,0),e.BlurDirectionY=new THREE.Vector2(0,1),THREE.UnrealBloomPass=e}()},8694:(e,t,n)=>{"use strict";n.r(t);var r=n(3946),o=n.n(r);!function(){class e extends THREE.Loader{constructor(e){if(super(e),void 0===o())throw Error("THREE.VRMLLoader: External library chevrotain.min.js required.")}load(e,t,n,r){const o=this,a=""===o.path?THREE.LoaderUtils.extractUrlBase(e):o.path,i=new THREE.FileLoader(o.manager);i.setPath(o.path),i.setRequestHeader(o.requestHeader),i.setWithCredentials(o.withCredentials),i.load(e,(function(n){try{t(o.parse(n,a))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e,n){const s={};function l(e){e.DEF&&(s[e.DEF]=e);const t=e.fields;for(let e=0,n=t.length;e<n;e++){const n=t[e];if("node"===n.type){const e=n.values;for(let t=0,n=e.length;t<n;t++)l(e[t])}}}function c(e){return e.USE?function(e){const t=c(s[e]);return t.isObject3D||t.isMaterial?t.clone():t}(e.USE):(void 0!==e.build||(e.build=function(e){const t=e.name;let n;switch(t){case"Group":case"Transform":case"Collision":n=function(e){const t=new THREE.Group,n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"bboxCenter":case"bboxSize":case"center":break;case"children":d(a,t);break;case"collide":break;case"rotation":const e=new THREE.Vector3(a[0],a[1],a[2]),n=a[3];t.quaternion.setFromAxisAngle(e,n);break;case"scale":t.scale.set(a[0],a[1],a[2]);break;case"scaleOrientation":break;case"translation":t.position.set(a[0],a[1],a[2]);break;case"proxy":break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return t}(e);break;case"Background":n=function(e){const t=new THREE.Group;let n,r,o,a;const i=e.fields;for(let e=0,t=i.length;e<t;e++){const t=i[e],s=t.name,l=t.values;switch(s){case"groundAngle":n=l;break;case"groundColor":r=l;break;case"backUrl":case"bottomUrl":case"frontUrl":case"leftUrl":case"rightUrl":case"topUrl":break;case"skyAngle":o=l;break;case"skyColor":a=l;break;default:console.warn("THREE.VRMLLoader: Unknown field:",s)}}const s=1e4;if(a){const e=new THREE.SphereGeometry(s,32,16),n=new THREE.MeshBasicMaterial({fog:!1,side:THREE.BackSide,depthWrite:!1,depthTest:!1});a.length>3?(N(e,s,o,k(a),!0),n.vertexColors=!0):n.color.setRGB(a[0],a[1],a[2]);const r=new THREE.Mesh(e,n);t.add(r)}if(r&&r.length>0){const e=new THREE.SphereGeometry(s,32,16,0,2*Math.PI,.5*Math.PI,1.5*Math.PI),o=new THREE.MeshBasicMaterial({fog:!1,side:THREE.BackSide,vertexColors:!0,depthWrite:!1,depthTest:!1});N(e,s,n,k(r),!1);const a=new THREE.Mesh(e,o);t.add(a)}return t.renderOrder=-1/0,t}(e);break;case"Shape":n=function(e){const t=e.fields;let n,r,o=new THREE.MeshBasicMaterial({color:0});for(let e=0,r=t.length;e<r;e++){const r=t[e],a=r.name,i=r.values;switch(a){case"appearance":null!==i[0]&&(o=c(i[0]));break;case"geometry":null!==i[0]&&(n=c(i[0]));break;default:console.warn("THREE.VRMLLoader: Unknown field:",a)}}if(n&&n.attributes.position){const e=n._type;if("points"===e){const e=new THREE.PointsMaterial({color:16777215});void 0!==n.attributes.color?e.vertexColors=!0:o.isMeshPhongMaterial&&e.color.copy(o.emissive),r=new THREE.Points(n,e)}else if("line"===e){const e=new THREE.LineBasicMaterial({color:16777215});void 0!==n.attributes.color?e.vertexColors=!0:o.isMeshPhongMaterial&&e.color.copy(o.emissive),r=new THREE.LineSegments(n,e)}else void 0!==n._solid&&(o.side=n._solid?THREE.FrontSide:THREE.DoubleSide),void 0!==n.attributes.color&&(o.vertexColors=!0),r=new THREE.Mesh(n,o)}else r=new THREE.Object3D,r.visible=!1;return r}(e);break;case"Appearance":n=function(e){let t,n=new THREE.MeshPhongMaterial;const r=e.fields;for(let e=0,o=r.length;e<o;e++){const o=r[e],a=o.name,i=o.values;switch(a){case"material":if(null!==i[0]){const e=c(i[0]);e.diffuseColor&&n.color.copy(e.diffuseColor),e.emissiveColor&&n.emissive.copy(e.emissiveColor),e.shininess&&(n.shininess=e.shininess),e.specularColor&&n.specular.copy(e.specularColor),e.transparency&&(n.opacity=1-e.transparency),e.transparency>0&&(n.transparent=!0)}else n=new THREE.MeshBasicMaterial({color:0});break;case"texture":const e=i[0];null!==e&&("ImageTexture"!==e.name&&"PixelTexture"!==e.name||(n.map=c(e)));break;case"textureTransform":null!==i[0]&&(t=c(i[0]));break;default:console.warn("THREE.VRMLLoader: Unknown field:",a)}}if(n.map){if(n.map.__type){switch(n.map.__type){case i.INTENSITY_ALPHA:n.opacity=1;break;case i.RGB:n.color.set(16777215);break;case i.RGBA:n.color.set(16777215),n.opacity=1}delete n.map.__type}t&&(n.map.center.copy(t.center),n.map.rotation=t.rotation,n.map.repeat.copy(t.scale),n.map.offset.copy(t.translation))}return n}(e);break;case"Material":n=function(e){const t={},n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"ambientIntensity":break;case"diffuseColor":t.diffuseColor=new THREE.Color(a[0],a[1],a[2]);break;case"emissiveColor":t.emissiveColor=new THREE.Color(a[0],a[1],a[2]);break;case"shininess":t.shininess=a[0];break;case"specularColor":t.emissiveColor=new THREE.Color(a[0],a[1],a[2]);break;case"transparency":t.transparency=a[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return t}(e);break;case"ImageTexture":n=function(e){let t,n=THREE.RepeatWrapping,r=THREE.RepeatWrapping;const o=e.fields;for(let e=0,a=o.length;e<a;e++){const a=o[e],i=a.name,s=a.values;switch(i){case"url":const e=s[0];e&&(t=H.load(e));break;case"repeatS":!1===s[0]&&(n=THREE.ClampToEdgeWrapping);break;case"repeatT":!1===s[0]&&(r=THREE.ClampToEdgeWrapping);break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}t&&(t.wrapS=n,t.wrapT=r);return t}(e);break;case"PixelTexture":n=function(e){let t,n=THREE.RepeatWrapping,r=THREE.RepeatWrapping;const o=e.fields;for(let e=0,a=o.length;e<a;e++){const a=o[e],i=a.name,s=a.values;switch(i){case"image":const e=s[0],o=s[1],a=s[2],l=2===a||4===a,c=u(a),d=new Uint8Array(e*o*(!0===l?4:3)),p={r:0,g:0,b:0,a:0};for(let e=3,t=0,n=s.length;e<n;e++,t++)if(f(s[e],c,p),!0===l){const e=4*t;d[e+0]=p.r,d[e+1]=p.g,d[e+2]=p.b,d[e+3]=p.a}else{const e=3*t;d[e+0]=p.r,d[e+1]=p.g,d[e+2]=p.b}t=new THREE.DataTexture(d,e,o,!0===l?THREE.RGBAFormat:THREE.RGBFormat),t.__type=c;break;case"repeatS":!1===s[0]&&(n=THREE.ClampToEdgeWrapping);break;case"repeatT":!1===s[0]&&(r=THREE.ClampToEdgeWrapping);break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}t&&(t.wrapS=n,t.wrapT=r);return t}(e);break;case"TextureTransform":n=function(e){const t={center:new THREE.Vector2,rotation:new THREE.Vector2,scale:new THREE.Vector2,translation:new THREE.Vector2},n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"center":t.center.set(a[0],a[1]);break;case"rotation":t.rotation=a[0];break;case"scale":t.scale.set(a[0],a[1]);break;case"translation":t.translation.set(a[0],a[1]);break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return t}(e);break;case"IndexedFaceSet":n=function(e){let t,n,r,o,a,i,s,l,f=!0,u=!0,d=0,m=!0,x=!0;const g=e.fields;for(let e=0,p=g.length;e<p;e++){const p=g[e],h=p.name,v=p.values;switch(h){case"color":const e=v[0];null!==e&&(t=c(e));break;case"coord":const p=v[0];null!==p&&(n=c(p));break;case"normal":const g=v[0];null!==g&&(r=c(g));break;case"texCoord":const y=v[0];null!==y&&(o=c(y));break;case"ccw":f=v[0];break;case"colorIndex":a=v;break;case"colorPerVertex":m=v[0];break;case"convex":break;case"coordIndex":i=v;break;case"creaseAngle":d=v[0];break;case"normalIndex":s=v;break;case"normalPerVertex":x=v[0];break;case"solid":u=v[0];break;case"texCoordIndex":l=v;break;default:console.warn("THREE.VRMLLoader: Unknown field:",h)}}if(void 0===i)return console.warn("THREE.VRMLLoader: Missing coordIndex."),new THREE.BufferGeometry;const y=p(i,f);let E,w,b;if(t)if(!0===m)if(a&&a.length>0){E=T(y,p(a,f),t,3)}else E=R(y,new THREE.Float32BufferAttribute(t,3));else if(a&&a.length>0){E=A(y,h(v(t,a),i))}else{E=A(y,h(t,i))}if(r)if(!0===x)if(s&&s.length>0){w=T(y,p(s,f),r,3)}else w=R(y,new THREE.Float32BufferAttribute(r,3));else if(s&&s.length>0){w=A(y,h(v(r,s),i))}else{w=A(y,h(r,i))}else w=L(y,n,d);if(o)if(l&&l.length>0){b=T(y,p(l,f),o,2)}else b=R(y,new THREE.Float32BufferAttribute(o,2));const _=new THREE.BufferGeometry,S=R(y,new THREE.Float32BufferAttribute(n,3));_.setAttribute("position",S),_.setAttribute("normal",w),E&&_.setAttribute("color",E);b&&_.setAttribute("uv",b);return _._solid=u,_._type="mesh",_}(e);break;case"IndexedLineSet":n=function(e){let t,n,r,o,a=!0;const i=e.fields;for(let e=0,s=i.length;e<s;e++){const s=i[e],l=s.name,f=s.values;switch(l){case"color":const e=f[0];null!==e&&(t=c(e));break;case"coord":const i=f[0];null!==i&&(n=c(i));break;case"colorIndex":r=f;break;case"colorPerVertex":a=f[0];break;case"coordIndex":o=f;break;default:console.warn("THREE.VRMLLoader: Unknown field:",l)}}let s;const l=m(o);if(t)if(!0===a)if(r.length>0){s=T(l,m(r),t,3)}else s=R(l,new THREE.Float32BufferAttribute(t,3));else if(r.length>0){s=S(l,x(v(t,r),o))}else{s=S(l,x(t,o))}const f=new THREE.BufferGeometry,u=R(l,new THREE.Float32BufferAttribute(n,3));f.setAttribute("position",u),s&&f.setAttribute("color",s);return f._type="line",f}(e);break;case"PointSet":n=function(e){let t,n;const r=e.fields;for(let e=0,o=r.length;e<o;e++){const o=r[e],a=o.name,i=o.values;switch(a){case"color":const e=i[0];null!==e&&(t=c(e));break;case"coord":const r=i[0];null!==r&&(n=c(r));break;default:console.warn("THREE.VRMLLoader: Unknown field:",a)}}const o=new THREE.BufferGeometry;o.setAttribute("position",new THREE.Float32BufferAttribute(n,3)),t&&o.setAttribute("color",new THREE.Float32BufferAttribute(t,3));return o._type="points",o}(e);break;case"Box":n=function(e){const t=new THREE.Vector3(2,2,2),n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"size":t.x=a[0],t.y=a[1],t.z=a[2];break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return new THREE.BoxGeometry(t.x,t.y,t.z)}(e);break;case"Cone":n=function(e){let t=1,n=2,r=!1;const o=e.fields;for(let e=0,a=o.length;e<a;e++){const a=o[e],i=a.name,s=a.values;switch(i){case"bottom":r=!s[0];break;case"bottomRadius":t=s[0];break;case"height":n=s[0];break;case"side":break;default:console.warn("THREE.VRMLLoader: Unknown field:",i)}}return new THREE.ConeGeometry(t,n,16,1,r)}(e);break;case"Cylinder":n=function(e){let t=1,n=2;const r=e.fields;for(let e=0,o=r.length;e<o;e++){const o=r[e],a=o.name,i=o.values;switch(a){case"bottom":break;case"radius":t=i[0];break;case"height":n=i[0];break;case"side":case"top":break;default:console.warn("THREE.VRMLLoader: Unknown field:",a)}}return new THREE.CylinderGeometry(t,t,n,16,1)}(e);break;case"Sphere":n=function(e){let t=1;const n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"radius":t=a[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return new THREE.SphereGeometry(t,16,16)}(e);break;case"ElevationGrid":n=function(e){let t,n,r,o,a=!0,i=!0,s=!0,l=!0,f=0,u=2,d=2,p=1,h=1;const v=e.fields;for(let e=0,m=v.length;e<m;e++){const m=v[e],x=m.name,g=m.values;switch(x){case"color":const e=g[0];null!==e&&(t=c(e));break;case"normal":const v=g[0];null!==v&&(n=c(v));break;case"texCoord":const m=g[0];null!==m&&(r=c(m));break;case"height":o=g;break;case"ccw":l=g[0];break;case"colorPerVertex":a=g[0];break;case"creaseAngle":f=g[0];break;case"normalPerVertex":i=g[0];break;case"solid":s=g[0];break;case"xDimension":u=g[0];break;case"xSpacing":p=g[0];break;case"zDimension":d=g[0];break;case"zSpacing":h=g[0];break;default:console.warn("THREE.VRMLLoader: Unknown field:",x)}}const m=[],x=[],g=[],y=[];for(let e=0;e<d;e++)for(let s=0;s<u;s++){const l=e*u+s,c=p*e,f=o[l],v=h*s;if(m.push(c,f,v),t&&!0===a){const e=t[3*l+0],n=t[3*l+1],r=t[3*l+2];g.push(e,n,r)}if(n&&!0===i){const e=n[3*l+0],t=n[3*l+1],r=n[3*l+2];x.push(e,t,r)}if(r){const e=r[2*l+0],t=r[2*l+1];y.push(e,t)}else y.push(e/(u-1),s/(d-1))}const E=[];for(let e=0;e<u-1;e++)for(let t=0;t<d-1;t++){const n=e+t*u,r=e+(t+1)*u,o=e+1+(t+1)*u,a=e+1+t*u;!0===l?(E.push(n,o,r),E.push(o,n,a)):(E.push(n,r,o),E.push(o,a,n))}const w=R(E,new THREE.Float32BufferAttribute(m,3)),b=R(E,new THREE.Float32BufferAttribute(y,2));let _,T;if(t)if(!1===a){for(let e=0;e<u-1;e++)for(let n=0;n<d-1;n++){const r=e+n*(u-1),o=t[3*r+0],a=t[3*r+1],i=t[3*r+2];g.push(o,a,i),g.push(o,a,i),g.push(o,a,i),g.push(o,a,i),g.push(o,a,i),g.push(o,a,i)}_=new THREE.Float32BufferAttribute(g,3)}else _=R(E,new THREE.Float32BufferAttribute(g,3));if(n)if(!1===i){for(let e=0;e<u-1;e++)for(let t=0;t<d-1;t++){const r=e+t*(u-1),o=n[3*r+0],a=n[3*r+1],i=n[3*r+2];x.push(o,a,i),x.push(o,a,i),x.push(o,a,i),x.push(o,a,i),x.push(o,a,i),x.push(o,a,i)}T=new THREE.Float32BufferAttribute(x,3)}else T=R(E,new THREE.Float32BufferAttribute(x,3));else T=L(E,m,f);const A=new THREE.BufferGeometry;A.setAttribute("position",w),A.setAttribute("normal",T),A.setAttribute("uv",b),_&&A.setAttribute("color",_);return A._solid=s,A._type="mesh",A}(e);break;case"Extrusion":n=function(e){let t,n,r=[1,1,1,-1,-1,-1,-1,1,1,1],o=[0,0,0,0,1,0],a=!0,i=!0,s=0,l=!0,c=!0;const f=e.fields;for(let e=0,u=f.length;e<u;e++){const u=f[e],d=u.name,p=u.values;switch(d){case"beginCap":a=p[0];break;case"ccw":i=p[0];break;case"convex":break;case"creaseAngle":s=p[0];break;case"crossSection":r=p;break;case"endCap":l=p[0];break;case"orientation":n=p;break;case"scale":t=p;break;case"solid":c=p[0];break;case"spine":o=p;break;default:console.warn("THREE.VRMLLoader: Unknown field:",d)}}const u=r[0]===r[r.length-2]&&r[1]===r[r.length-1],d=[],p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector3,m=new THREE.Vector3,x=new THREE.Quaternion;for(let e=0,a=0,i=0,s=o.length;e<s;e+=3,a+=2,i+=4){p.fromArray(o,e),h.x=t?t[a+0]:1,h.y=1,h.z=t?t[a+1]:1,v.x=n?n[i+0]:0,v.y=n?n[i+1]:0,v.z=n?n[i+2]:1;const s=n?n[i+3]:0;for(let e=0,t=r.length;e<t;e+=2)m.x=r[e+0],m.y=0,m.z=r[e+1],m.multiply(h),x.setFromAxisAngle(v,s),m.applyQuaternion(x),m.add(p),d.push(m.x,m.y,m.z)}const g=[],y=o.length/3,E=r.length/2;for(let e=0;e<y-1;e++)for(let t=0;t<E-1;t++){const n=t+e*E;let r=t+1+e*E;const o=t+(e+1)*E;let a=t+1+(e+1)*E;t===E-2&&!0===u&&(r=e*E,a=(e+1)*E),!0===i?(g.push(n,r,o),g.push(o,r,a)):(g.push(n,o,r),g.push(o,a,r))}if(!0===a||!0===l){const e=[];for(let t=0,n=r.length;t<n;t+=2)e.push(new THREE.Vector2(r[t],r[t+1]));const t=THREE.ShapeUtils.triangulateShape(e,[]),n=[];for(let e=0,r=t.length;e<r;e++){const r=t[e];n.push(r[0],r[1],r[2])}if(!0===a)for(let e=0,t=n.length;e<t;e+=3)!0===i?g.push(n[e+0],n[e+1],n[e+2]):g.push(n[e+0],n[e+2],n[e+1]);if(!0===l){const e=E*(y-1);for(let t=0,r=n.length;t<r;t+=3)!0===i?g.push(e+n[t+0],e+n[t+2],e+n[t+1]):g.push(e+n[t+0],e+n[t+1],e+n[t+2])}}const w=R(g,new THREE.Float32BufferAttribute(d,3)),b=L(g,d,s),_=new THREE.BufferGeometry;return _.setAttribute("position",w),_.setAttribute("normal",b),_._solid=c,_._type="mesh",_}(e);break;case"Color":case"Coordinate":case"Normal":case"TextureCoordinate":n=function(e){return e.fields[0].values}(e);break;case"WorldInfo":n=function(e){const t={},n=e.fields;for(let e=0,r=n.length;e<r;e++){const r=n[e],o=r.name,a=r.values;switch(o){case"title":t.title=a[0];break;case"info":t.info=a;break;default:console.warn("THREE.VRMLLoader: Unknown field:",o)}}return t}(e);break;case"Anchor":case"Billboard":case"Inline":case"LOD":case"Switch":case"AudioClip":case"DirectionalLight":case"PointLight":case"Script":case"Sound":case"SpotLight":case"CylinderSensor":case"PlaneSensor":case"ProximitySensor":case"SphereSensor":case"TimeSensor":case"TouchSensor":case"VisibilitySensor":case"Text":case"FontStyle":case"MovieTexture":case"ColorInterpolator":case"CoordinateInterpolator":case"NormalInterpolator":case"OrientationInterpolator":case"PositionInterpolator":case"ScalarInterpolator":case"Fog":case"NavigationInfo":case"Viewpoint":break;default:console.warn("THREE.VRMLLoader: Unknown node:",t)}void 0!==n&&void 0!==e.DEF&&!0===n.hasOwnProperty("name")&&(n.name=e.DEF);return n}(e)),e.build)}function f(e,t,n){let r;switch(t){case i.INTENSITY:r=parseInt(e),n.r=r,n.g=r,n.b=r;break;case i.INTENSITY_ALPHA:r=parseInt("0x"+e.substring(2,4)),n.r=r,n.g=r,n.b=r,n.a=parseInt("0x"+e.substring(4,6));break;case i.RGB:n.r=parseInt("0x"+e.substring(2,4)),n.g=parseInt("0x"+e.substring(4,6)),n.b=parseInt("0x"+e.substring(6,8));break;case i.RGBA:n.r=parseInt("0x"+e.substring(2,4)),n.g=parseInt("0x"+e.substring(4,6)),n.b=parseInt("0x"+e.substring(6,8)),n.a=parseInt("0x"+e.substring(8,10))}}function u(e){let t;switch(e){case 1:t=i.INTENSITY;break;case 2:t=i.INTENSITY_ALPHA;break;case 3:t=i.RGB;break;case 4:t=i.RGBA}return t}function d(e,t){for(let n=0,r=e.length;n<r;n++){const r=c(e[n]);r instanceof THREE.Object3D&&t.add(r)}}function p(e,t){const n=[];let r=0;for(let o=0,a=e.length;o<a;o++){const i=e[r],s=e[o+(t?1:2)],l=e[o+(t?2:1)];n.push(i,s,l),(-1===e[o+3]||o+3>=a)&&(o+=3,r=o+1)}return n}function h(e,t){const n=[];let r=0;for(let o=0,a=t.length;o<a;o++){const i=3*r,s=e[i],l=e[i+1],c=e[i+2];n.push(s,l,c),(-1===t[o+3]||o+3>=a)&&(o+=3,r++)}return n}function v(e,t){const n=[];for(let r=0,o=t.length;r<o;r++){const o=3*t[r],a=e[o],i=e[o+1],s=e[o+2];n.push(a,i,s)}return n}function m(e){const t=[];for(let n=0,r=e.length;n<r;n++){const o=e[n],a=e[n+1];t.push(o,a),(-1===e[n+2]||n+2>=r)&&(n+=2)}return t}function x(e,t){const n=[];let r=0;for(let o=0,a=t.length;o<a;o++){const i=3*r,s=e[i],l=e[i+1],c=e[i+2];n.push(s,l,c),(-1===t[o+2]||o+2>=a)&&(o+=2,r++)}return n}const g=new THREE.Vector3,y=new THREE.Vector3,E=new THREE.Vector3,w=new THREE.Vector2,b=new THREE.Vector2,_=new THREE.Vector2;function T(e,t,n,r){const o=[];for(let a=0,i=e.length;a<i;a+=3){const e=t[a],i=t[a+1],s=t[a+2];2===r?(w.fromArray(n,e*r),b.fromArray(n,i*r),_.fromArray(n,s*r),o.push(w.x,w.y),o.push(b.x,b.y),o.push(_.x,_.y)):(g.fromArray(n,e*r),y.fromArray(n,i*r),E.fromArray(n,s*r),o.push(g.x,g.y,g.z),o.push(y.x,y.y,y.z),o.push(E.x,E.y,E.z))}return new THREE.Float32BufferAttribute(o,r)}function A(e,t){const n=[];for(let r=0,o=0,a=e.length;r<a;r+=3,o++)g.fromArray(t,3*o),n.push(g.x,g.y,g.z),n.push(g.x,g.y,g.z),n.push(g.x,g.y,g.z);return new THREE.Float32BufferAttribute(n,3)}function S(e,t){const n=[];for(let r=0,o=0,a=e.length;r<a;r+=2,o++)g.fromArray(t,3*o),n.push(g.x,g.y,g.z),n.push(g.x,g.y,g.z);return new THREE.Float32BufferAttribute(n,3)}function R(e,t){const n=t.array,r=t.itemSize,o=new n.constructor(e.length*r);let a=0,i=0;for(let t=0,s=e.length;t<s;t++){a=e[t]*r;for(let e=0;e<r;e++)o[i++]=n[a++]}return new THREE.Float32BufferAttribute(o,r)}const M=new THREE.Vector3,C=new THREE.Vector3;function L(e,t,n){const r=[],o={};for(let n=0,i=e.length;n<i;n+=3){const i=e[n],s=e[n+1],l=e[n+2],c=new a(i,s,l);g.fromArray(t,3*i),y.fromArray(t,3*s),E.fromArray(t,3*l),C.subVectors(E,y),M.subVectors(g,y),C.cross(M),C.normalize(),c.normal.copy(C),void 0===o[i]&&(o[i]=[]),void 0===o[s]&&(o[s]=[]),void 0===o[l]&&(o[l]=[]),o[i].push(c.normal),o[s].push(c.normal),o[l].push(c.normal),r.push(c)}const i=[];for(let e=0,a=r.length;e<a;e++){const a=r[e],s=P(o[a.a],a.normal,n),l=P(o[a.b],a.normal,n),c=P(o[a.c],a.normal,n);g.fromArray(t,3*a.a),y.fromArray(t,3*a.b),E.fromArray(t,3*a.c),i.push(s.x,s.y,s.z),i.push(l.x,l.y,l.z),i.push(c.x,c.y,c.z)}return new THREE.Float32BufferAttribute(i,3)}function P(e,t,n){const r=new THREE.Vector3;if(0===n)r.copy(t);else for(let o=0,a=e.length;o<a;o++)e[o].angleTo(t)<n&&r.add(e[o]);return r.normalize()}function k(e){const t=[];for(let n=0,r=e.length;n<r;n+=3)t.push(new THREE.Color(e[n],e[n+1],e[n+2]));return t}function N(e,t,n,r,o){const a=[],i=!0===o?0:Math.PI;for(let e=0,s=r.length;e<s;e++){let r=0===e?0:n[e-1];r=!0===o?r:i-r;const s=new THREE.Vector3;s.setFromSphericalCoords(t,r,0),a.push(s)}const s=e.index,l=e.attributes.position,c=new THREE.BufferAttribute(new Float32Array(3*e.attributes.position.count),3),f=new THREE.Vector3,u=new THREE.Color;for(let e=0;e<s.count;e++){const t=s.getX(e);let n,i;f.fromBufferAttribute(l,t);let d=1;for(let e=1;e<a.length;e++){n=e-1,i=e;const t=a[n],r=a[i];if(!0===o){if(f.y<=t.y&&f.y>r.y){d=Math.abs(t.y-f.y)/Math.abs(t.y-r.y);break}}else if(f.y>=t.y&&f.y<r.y){d=Math.abs(t.y-f.y)/Math.abs(t.y-r.y);break}}const p=r[n],h=r[i];u.copy(p).lerp(h,d),c.setXYZ(t,u.r,u.g,u.b)}e.setAttribute("color",c)}const H=new THREE.TextureLoader(this.manager);if(H.setPath(this.resourcePath||n).setCrossOrigin(this.crossOrigin),-1===e.indexOf("#VRML V2.0"))throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");return function(e){const t=e.nodes,n=new THREE.Scene;for(let e=0,n=t.length;e<n;e++){l(t[e])}for(let e=0,r=t.length;e<r;e++){const r=t[e],o=c(r);o instanceof THREE.Object3D&&n.add(o),"WorldInfo"===r.name&&(n.userData.worldInfo=o)}return n}(function(e){const n=function(){const e=o().createToken,t=e({name:"RouteIdentifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/}),n=e({name:"Identifier",pattern:/[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,longer_alt:t}),r=["Anchor","Billboard","Collision","Group","Transform","Inline","LOD","Switch","AudioClip","DirectionalLight","PointLight","Script","Shape","Sound","SpotLight","WorldInfo","CylinderSensor","PlaneSensor","ProximitySensor","SphereSensor","TimeSensor","TouchSensor","VisibilitySensor","Box","Cone","Cylinder","ElevationGrid","Extrusion","IndexedFaceSet","IndexedLineSet","PointSet","Sphere","Color","Coordinate","Normal","TextureCoordinate","Appearance","FontStyle","ImageTexture","Material","MovieTexture","PixelTexture","TextureTransform","ColorInterpolator","CoordinateInterpolator","NormalInterpolator","OrientationInterpolator","PositionInterpolator","ScalarInterpolator","Background","Fog","NavigationInfo","Viewpoint","Text"],a=e({name:"Version",pattern:/#VRML.*/,longer_alt:n}),i=e({name:"NodeName",pattern:new RegExp(r.join("|")),longer_alt:n}),s=e({name:"DEF",pattern:/DEF/,longer_alt:n}),l=e({name:"USE",pattern:/USE/,longer_alt:n}),c=e({name:"ROUTE",pattern:/ROUTE/,longer_alt:n}),f=e({name:"TO",pattern:/TO/,longer_alt:n}),u=e({name:"StringLiteral",pattern:/"(:?[^\\"\n\r]+|\\(:?[bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/}),d=e({name:"HexLiteral",pattern:/0[xX][0-9a-fA-F]+/}),p=e({name:"NumberLiteral",pattern:/[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/}),h=e({name:"TrueLiteral",pattern:/TRUE/}),v=e({name:"FalseLiteral",pattern:/FALSE/}),m=e({name:"NullLiteral",pattern:/NULL/}),x=e({name:"LSquare",pattern:/\[/}),g=e({name:"RSquare",pattern:/]/}),y=e({name:"LCurly",pattern:/{/}),E=e({name:"RCurly",pattern:/}/}),w=e({name:"Comment",pattern:/#.*/,group:o().Lexer.SKIPPED}),b=[e({name:"WhiteSpace",pattern:/[ ,\s]/,group:o().Lexer.SKIPPED}),i,s,l,c,f,h,v,m,a,n,t,u,d,p,x,g,y,E,w],_={};for(let e=0,t=b.length;e<t;e++){const t=b[e];_[t.name]=t}return{tokens:b,tokenVocabulary:_}}(),a=new t(n.tokens),i=new r(n.tokenVocabulary),s=function(e){function t(){e.call(this),this.validateVisitor()}function n(e,t){const n={type:null,values:[]};if(t.node){n.type="node";for(let r=0,o=t.node.length;r<o;r++){const o=t.node[r];n.values.push(e.visit(o))}}if(t.use){n.type="use";for(let r=0,o=t.use.length;r<o;r++){const o=t.use[r];n.values.push(e.visit(o))}}if(t.StringLiteral){n.type="string";for(let e=0,r=t.StringLiteral.length;e<r;e++){const r=t.StringLiteral[e];n.values.push(r.image.replace(/'|"/g,""))}}if(t.NumberLiteral){n.type="number";for(let e=0,r=t.NumberLiteral.length;e<r;e++){const r=t.NumberLiteral[e];n.values.push(parseFloat(r.image))}}if(t.HexLiteral){n.type="hex";for(let e=0,r=t.HexLiteral.length;e<r;e++){const r=t.HexLiteral[e];n.values.push(r.image)}}if(t.TrueLiteral){n.type="boolean";for(let e=0,r=t.TrueLiteral.length;e<r;e++){"TRUE"===t.TrueLiteral[e].image&&n.values.push(!0)}}if(t.FalseLiteral){n.type="boolean";for(let e=0,r=t.FalseLiteral.length;e<r;e++){"FALSE"===t.FalseLiteral[e].image&&n.values.push(!1)}}return t.NullLiteral&&(n.type="null",t.NullLiteral.forEach((function(){n.values.push(null)}))),n}return t.prototype=Object.assign(Object.create(e.prototype),{constructor:t,vrml:function(e){const t={version:this.visit(e.version),nodes:[],routes:[]};for(let n=0,r=e.node.length;n<r;n++){const r=e.node[n];t.nodes.push(this.visit(r))}if(e.route)for(let n=0,r=e.route.length;n<r;n++){const r=e.route[n];t.routes.push(this.visit(r))}return t},version:function(e){return e.Version[0].image},node:function(e){const t={name:e.NodeName[0].image,fields:[]};if(e.field)for(let n=0,r=e.field.length;n<r;n++){const r=e.field[n];t.fields.push(this.visit(r))}return e.def&&(t.DEF=this.visit(e.def[0])),t},field:function(e){const t={name:e.Identifier[0].image,type:null,values:null};let n;return e.singleFieldValue&&(n=this.visit(e.singleFieldValue[0])),e.multiFieldValue&&(n=this.visit(e.multiFieldValue[0])),t.type=n.type,t.values=n.values,t},def:function(e){return(e.Identifier||e.NodeName)[0].image},use:function(e){return{USE:(e.Identifier||e.NodeName)[0].image}},singleFieldValue:function(e){return n(this,e)},multiFieldValue:function(e){return n(this,e)},route:function(e){return{FROM:e.RouteIdentifier[0].image,TO:e.RouteIdentifier[1].image}}}),new t}(i.getBaseCstVisitorConstructor()),l=a.lex(e);i.input=l.tokens;const c=i.vrml();if(i.errors.length>0)throw console.error(i.errors),Error("THREE.VRMLLoader: Parsing errors detected.");return s.visit(c)}(e))}}class t{constructor(e){this.lexer=new(o().Lexer)(e)}lex(e){const t=this.lexer.tokenize(e);if(t.errors.length>0)throw console.error(t.errors),Error("THREE.VRMLLexer: Lexing errors detected.");return t}}const n=o().CstParser;class r extends n{constructor(e){super(e);const t=this,n=e.Version,r=e.LCurly,o=e.RCurly,a=e.LSquare,i=e.RSquare,s=e.Identifier,l=e.RouteIdentifier,c=e.StringLiteral,f=e.HexLiteral,u=e.NumberLiteral,d=e.TrueLiteral,p=e.FalseLiteral,h=e.NullLiteral,v=e.DEF,m=e.USE,x=e.ROUTE,g=e.TO,y=e.NodeName;t.RULE("vrml",(function(){t.SUBRULE(t.version),t.AT_LEAST_ONE((function(){t.SUBRULE(t.node)})),t.MANY((function(){t.SUBRULE(t.route)}))})),t.RULE("version",(function(){t.CONSUME(n)})),t.RULE("node",(function(){t.OPTION((function(){t.SUBRULE(t.def)})),t.CONSUME(y),t.CONSUME(r),t.MANY((function(){t.SUBRULE(t.field)})),t.CONSUME(o)})),t.RULE("field",(function(){t.CONSUME(s),t.OR2([{ALT:function(){t.SUBRULE(t.singleFieldValue)}},{ALT:function(){t.SUBRULE(t.multiFieldValue)}}])})),t.RULE("def",(function(){t.CONSUME(v),t.OR([{ALT:function(){t.CONSUME(s)}},{ALT:function(){t.CONSUME(y)}}])})),t.RULE("use",(function(){t.CONSUME(m),t.OR([{ALT:function(){t.CONSUME(s)}},{ALT:function(){t.CONSUME(y)}}])})),t.RULE("singleFieldValue",(function(){t.AT_LEAST_ONE((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(c)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(d)}},{ALT:function(){t.CONSUME(p)}},{ALT:function(){t.CONSUME(h)}}])}))})),t.RULE("multiFieldValue",(function(){t.CONSUME(a),t.MANY((function(){t.OR([{ALT:function(){t.SUBRULE(t.node)}},{ALT:function(){t.SUBRULE(t.use)}},{ALT:function(){t.CONSUME(c)}},{ALT:function(){t.CONSUME(f)}},{ALT:function(){t.CONSUME(u)}},{ALT:function(){t.CONSUME(h)}}])})),t.CONSUME(i)})),t.RULE("route",(function(){t.CONSUME(x),t.CONSUME(l),t.CONSUME(g),t.CONSUME2(l)})),this.performSelfAnalysis()}}class a{constructor(e,t,n){this.a=e,this.b=t,this.c=n,this.normal=new THREE.Vector3}}const i={INTENSITY:1,INTENSITY_ALPHA:2,RGB:3,RGBA:4};THREE.VRMLLoader=e}()},507:(e,t,n)=>{"use strict";n.r(t);var r=n(743);!function(){class e extends THREE.Loader{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new THREE.FileLoader(o.manager);a.setPath(o.path),a.setResponseType("arraybuffer"),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(n))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){function t(e,t){const n=e.length,r=new Float32Array(n+t.length);return r.set(e),r.set(t,n),r}var n=THREE.LoaderUtils.decodeText(new Uint8Array(e,0,250)).split("\n");return-1!==n[0].indexOf("xml")?function(e){function n(e){var t,n,r,o,a,i,s="undefined"!=typeof Uint8Array?Uint8Array:Array,l=[],c=[],f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",u=f.length;for(t=0;t<u;t++)l[t]=f[t];for(t=0;t<u;++t)c[f.charCodeAt(t)]=t;if(c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63,(u=e.length)%4>0)throw new Error("Invalid string. Length must be a multiple of 4");i=new s(3*u/4-(a="="===e[u-2]?2:"="===e[u-1]?1:0)),r=a>0?u-4:u;var d=0;for(t=0,n=0;t<r;t+=4,n+=3)o=c[e.charCodeAt(t)]<<18|c[e.charCodeAt(t+1)]<<12|c[e.charCodeAt(t+2)]<<6|c[e.charCodeAt(t+3)],i[d++]=(16711680&o)>>16,i[d++]=(65280&o)>>8,i[d++]=255&o;return 2===a?(o=c[e.charCodeAt(t)]<<2|c[e.charCodeAt(t+1)]>>4,i[d++]=255&o):1===a&&(o=c[e.charCodeAt(t)]<<10|c[e.charCodeAt(t+1)]<<4|c[e.charCodeAt(t+2)]>>2,i[d++]=o>>8&255,i[d++]=255&o),i}function o(e,o){var a,s,l,c,f=0;if("UInt64"===i.attributes.header_type?f=8:"UInt32"===i.attributes.header_type&&(f=4),"binary"===e.attributes.format&&o){var u,d,p,h,v,m;if("Float32"===e.attributes.type)var x=new Float32Array;else"Int64"===e.attributes.type&&(x=new Int32Array);d=(u=n(e["#text"]))[0];for(var g=1;g<f-1;g++)d|=u[g]<<g*f;for(h=(d+3)*f,m=h+=h%3>0?3-h%3:0,(v=[]).push(m),p=3*f,g=0;g<d;g++){for(var y=u[g*f+p],E=1;E<f-1;E++)y|=u[g*f+p+E]<<8*E;m+=y,v.push(m)}for(g=0;g<v.length-1;g++)w=r.unzlibSync(u.slice(v[g],v[g+1])).buffer,"Float32"===e.attributes.type?x=t(x,w=new Float32Array(w)):"Int64"===e.attributes.type&&(s=w=new Int32Array(w),l=void 0,c=void 0,l=(a=x).length,(c=new Int32Array(l+s.length)).set(a),c.set(s,l),x=c);delete e["#text"],"Int64"===e.attributes.type&&"binary"===e.attributes.format&&(x=x.filter((function(e,t){if(t%2!=1)return!0})))}else{if("binary"!==e.attributes.format||o)if(e["#text"])var w=e["#text"].split(/\s+/).filter((function(e){if(""!==e)return e}));else w=new Int32Array(0).buffer;else w=(w=n(e["#text"])).slice(f).buffer;delete e["#text"],"Float32"===e.attributes.type?x=new Float32Array(w):"Int32"===e.attributes.type?x=new Int32Array(w):"Int64"===e.attributes.type&&(x=new Int32Array(w),"binary"===e.attributes.format&&(x=x.filter((function(e,t){if(t%2!=1)return!0}))))}return x}var a=null;if(window.DOMParser)try{a=(new DOMParser).parseFromString(e,"text/xml")}catch(e){a=null}else{if(!window.ActiveXObject)throw new Error("Cannot parse xml string!");try{if((a=new ActiveXObject("Microsoft.XMLDOM")).async=!1,!a.loadXML())throw new Error(a.parseError.reason+a.parseError.srcText)}catch(e){a=null}}var i=function e(t){var n={};if(1===t.nodeType){if(t.attributes&&t.attributes.length>0){n.attributes={};for(var r=0;r<t.attributes.length;r++){var o=t.attributes.item(r);n.attributes[o.nodeName]=o.nodeValue.trim()}}}else 3===t.nodeType&&(n=t.nodeValue.trim());if(t.hasChildNodes())for(var a=0;a<t.childNodes.length;a++){var i=t.childNodes.item(a),s=i.nodeName;if(void 0===n[s])""!==(c=e(i))&&(n[s]=c);else{if(void 0===n[s].push){var l=n[s];n[s]=[l]}var c;""!==(c=e(i))&&n[s].push(c)}}return n}(a.documentElement),s=[],l=[],c=[];if(i.PolyData){for(var f=i.PolyData.Piece,u=i.attributes.hasOwnProperty("compressor"),d=["PointData","Points","Strips","Polys"],p=0,h=d.length;p<h;){var v=f[d[p]];if(v&&v.DataArray){if("[object Array]"===Object.prototype.toString.call(v.DataArray))var m=v.DataArray;else m=[v.DataArray];for(var x=0,g=m.length;x<g;)"#text"in m[x]&&m[x]["#text"].length>0&&(m[x].text=o(m[x],u)),x++;switch(d[p]){case"PointData":var y=parseInt(f.attributes.NumberOfPoints),E=v.attributes.Normals;if(y>0)for(var w=0,b=m.length;w<b;w++)if(E===m[w].attributes.Name){var _=m[w].attributes.NumberOfComponents;(l=new Float32Array(y*_)).set(m[w].text,0)}break;case"Points":(y=parseInt(f.attributes.NumberOfPoints))>0&&(_=v.DataArray.attributes.NumberOfComponents,(s=new Float32Array(y*_)).set(v.DataArray.text,0));break;case"Strips":var T=parseInt(f.attributes.NumberOfStrips);if(T>0){var A=new Int32Array(v.DataArray[0].text.length),S=new Int32Array(v.DataArray[1].text.length);A.set(v.DataArray[0].text,0),S.set(v.DataArray[1].text,0);var R=T+A.length;c=new Uint32Array(3*R-9*T);var M=0;for(w=0,b=T;w<b;w++){for(var C=[],L=0,P=S[w],k=0;L<P-k;L++)C.push(A[L]),w>0&&(k=S[w-1]);var N=0;for(P=S[w],k=0;N<P-k-2;N++)N%2?(c[M++]=C[N],c[M++]=C[N+2],c[M++]=C[N+1]):(c[M++]=C[N],c[M++]=C[N+1],c[M++]=C[N+2]),w>0&&(k=S[w-1])}}break;case"Polys":var H=parseInt(f.attributes.NumberOfPolys);if(H>0){A=new Int32Array(v.DataArray[0].text.length),S=new Int32Array(v.DataArray[1].text.length),A.set(v.DataArray[0].text,0),S.set(v.DataArray[1].text,0),R=H+A.length,c=new Uint32Array(3*R-9*H),M=0;var z=0;for(w=0,b=H,k=0;w<b;){var D=[];for(L=0,P=S[w];L<P-k;)D.push(A[z++]),L++;for(N=1;N<P-k-1;)c[M++]=D[0],c[M++]=D[N],c[M++]=D[N+1],N++;k=S[++w-1]}}}}p++}var F=new THREE.BufferGeometry;return F.setIndex(new THREE.BufferAttribute(c,1)),F.setAttribute("position",new THREE.BufferAttribute(s,3)),l.length===s.length&&F.setAttribute("normal",new THREE.BufferAttribute(l,3)),F}throw new Error("Unsupported DATASET type")}(THREE.LoaderUtils.decodeText(e)):n[2].includes("ASCII")?function(e){for(var t,n=[],r=[],o=[],a=[],i=/^[^\d.\s-]+/,s=/(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)\s+(\-?\d+\.?[\d\-\+e]*)/g,l=/^(\d+)\s+([\s\d]*)/,c=/^POINTS /,f=/^POLYGONS /,u=/^TRIANGLE_STRIPS /,d=/^POINT_DATA[ ]+(\d+)/,p=/^CELL_DATA[ ]+(\d+)/,h=/^COLOR_SCALARS[ ]+(\w+)[ ]+3/,v=/^NORMALS[ ]+(\w+)[ ]+(\w+)/,m=!1,x=!1,g=!1,y=!1,E=!1,w=!1,b=!1,_=e.split("\n"),T=0,A=_.length;T<A;T++){var S=_[T].trim();if(0===S.indexOf("DATASET")){var R=S.split(" ")[1];if("POLYDATA"!==R)throw new Error("Unsupported DATASET type: "+R)}else if(m)for(;null!==(t=s.exec(S))&&null===i.exec(S);){var M=parseFloat(t[1]),C=parseFloat(t[2]),L=parseFloat(t[3]);r.push(M,C,L)}else if(x){if(null!==(t=l.exec(S))){var P=parseInt(t[1]),k=t[2].split(/\s+/);if(P>=3)for(var N=parseInt(k[0]),H=1,z=0;z<P-2;++z)D=parseInt(k[H]),F=parseInt(k[H+1]),n.push(N,D,F),H++}}else if(g){if(null!==(t=l.exec(S))){var D,F;if(P=parseInt(t[1]),k=t[2].split(/\s+/),P>=3)for(z=0;z<P-2;z++)z%2==1?(N=parseInt(k[z]),D=parseInt(k[z+2]),F=parseInt(k[z+1]),n.push(N,D,F)):(N=parseInt(k[z]),D=parseInt(k[z+1]),F=parseInt(k[z+2]),n.push(N,D,F))}}else if(y||E)if(w)for(;null!==(t=s.exec(S))&&null===i.exec(S);){var I=parseFloat(t[1]),O=parseFloat(t[2]),U=parseFloat(t[3]);o.push(I,O,U)}else if(b)for(;null!==(t=s.exec(S))&&null===i.exec(S);){var G=parseFloat(t[1]),B=parseFloat(t[2]),V=parseFloat(t[3]);a.push(G,B,V)}null!==f.exec(S)?(x=!0,m=!1,g=!1):null!==c.exec(S)?(x=!1,m=!0,g=!1):null!==u.exec(S)?(x=!1,m=!1,g=!0):null!==d.exec(S)?(y=!0,m=!1,x=!1,g=!1):null!==p.exec(S)?(E=!0,m=!1,x=!1,g=!1):null!==h.exec(S)?(w=!0,b=!1,m=!1,x=!1,g=!1):null!==v.exec(S)&&(b=!0,w=!1,m=!1,x=!1,g=!1)}var W=new THREE.BufferGeometry;if(W.setIndex(n),W.setAttribute("position",new THREE.Float32BufferAttribute(r,3)),a.length===r.length&&W.setAttribute("normal",new THREE.Float32BufferAttribute(a,3)),o.length!==n.length)o.length===r.length&&W.setAttribute("color",new THREE.Float32BufferAttribute(o,3));else{var j=(W=W.toNonIndexed()).attributes.position.count/3;if(o.length===3*j){var q=[];for(T=0;T<j;T++)I=o[3*T+0],O=o[3*T+1],U=o[3*T+2],q.push(I,O,U),q.push(I,O,U),q.push(I,O,U);W.setAttribute("color",new THREE.Float32BufferAttribute(q,3))}}return W}(THREE.LoaderUtils.decodeText(e)):function(e){var t,n,r,o,a,i,s,l=new Uint8Array(e),c=new DataView(e),f=[],u=[],d=[],p=[],h=0;function v(e,t){for(var n=t,r=e[n],o=[];10!==r;)o.push(String.fromCharCode(r)),r=e[++n];return{start:t,end:n,next:n+1,parsedString:o.join("")}}for(;;){if(0===(s=(i=v(l,h)).parsedString).indexOf("DATASET")){var m=s.split(" ")[1];if("POLYDATA"!==m)throw new Error("Unsupported DATASET type: "+m)}else if(0===s.indexOf("POINTS")){for(p.push(s),t=4*(o=parseInt(s.split(" ")[1],10))*3,f=new Float32Array(3*o),n=i.next,r=0;r<o;r++)f[3*r]=c.getFloat32(n,!1),f[3*r+1]=c.getFloat32(n+4,!1),f[3*r+2]=c.getFloat32(n+8,!1),n+=12;i.next=i.next+t+1}else if(0===s.indexOf("TRIANGLE_STRIPS")){var x=parseInt(s.split(" ")[1],10);t=4*(b=parseInt(s.split(" ")[2],10)),d=new Uint32Array(3*b-9*x);var g=0;for(n=i.next,r=0;r<x;r++){var y=c.getInt32(n,!1),E=[];for(n+=4,a=0;a<y;a++)E.push(c.getInt32(n,!1)),n+=4;for(var w=0;w<y-2;w++)w%2?(d[g++]=E[w],d[g++]=E[w+2],d[g++]=E[w+1]):(d[g++]=E[w],d[g++]=E[w+1],d[g++]=E[w+2])}i.next=i.next+t+1}else if(0===s.indexOf("POLYGONS")){var b;for(x=parseInt(s.split(" ")[1],10),t=4*(b=parseInt(s.split(" ")[2],10)),d=new Uint32Array(3*b-9*x),g=0,n=i.next,r=0;r<x;r++){for(y=c.getInt32(n,!1),E=[],n+=4,a=0;a<y;a++)E.push(c.getInt32(n,!1)),n+=4;for(w=1;w<y-1;w++)d[g++]=E[0],d[g++]=E[w],d[g++]=E[w+1]}i.next=i.next+t+1}else if(0===s.indexOf("POINT_DATA")){for(o=parseInt(s.split(" ")[1],10),i=v(l,i.next),t=4*o*3,u=new Float32Array(3*o),n=i.next,r=0;r<o;r++)u[3*r]=c.getFloat32(n,!1),u[3*r+1]=c.getFloat32(n+4,!1),u[3*r+2]=c.getFloat32(n+8,!1),n+=12;i.next=i.next+t}if((h=i.next)>=l.byteLength)break}var _=new THREE.BufferGeometry;return _.setIndex(new THREE.BufferAttribute(d,1)),_.setAttribute("position",new THREE.BufferAttribute(f,3)),u.length===f.length&&_.setAttribute("normal",new THREE.BufferAttribute(u,3)),_}(e)}}THREE.VTKLoader=e}()},9127:()=>{!function(){const e={uniforms:{tDiffuse:{value:null},offset:{value:1},darkness:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float offset;\n\t\tuniform float darkness;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t// Eskil's vignette\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tvec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n\t\t\tgl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n\n\t\t}"};THREE.VignetteShader=e}()},5144:()=>{var e;(e=function(e,t,n,r,o){if(arguments.length>0){switch(this.xLength=Number(e)||1,this.yLength=Number(t)||1,this.zLength=Number(n)||1,r){case"Uint8":case"uint8":case"uchar":case"unsigned char":case"uint8_t":this.data=new Uint8Array(o);break;case"Int8":case"int8":case"signed char":case"int8_t":this.data=new Int8Array(o);break;case"Int16":case"int16":case"short":case"short int":case"signed short":case"signed short int":case"int16_t":this.data=new Int16Array(o);break;case"Uint16":case"uint16":case"ushort":case"unsigned short":case"unsigned short int":case"uint16_t":this.data=new Uint16Array(o);break;case"Int32":case"int32":case"int":case"signed int":case"int32_t":this.data=new Int32Array(o);break;case"Uint32":case"uint32":case"uint":case"unsigned int":case"uint32_t":this.data=new Uint32Array(o);break;case"longlong":case"long long":case"long long int":case"signed long long":case"signed long long int":case"int64":case"int64_t":case"ulonglong":case"unsigned long long":case"unsigned long long int":case"uint64":case"uint64_t":throw"Error in Volume constructor : this type is not supported in JavaScript";case"Float32":case"float32":case"float":this.data=new Float32Array(o);break;case"Float64":case"float64":case"double":this.data=new Float64Array(o);break;default:this.data=new Uint8Array(o)}if(this.data.length!==this.xLength*this.yLength*this.zLength)throw"Error in Volume constructor, lengths are not matching arrayBuffer size"}this.spacing=[1,1,1],this.offset=[0,0,0],this.matrix=new THREE.Matrix3,this.matrix.identity();var a=-1/0;Object.defineProperty(this,"lowerThreshold",{get:function(){return a},set:function(e){a=e,this.sliceList.forEach((function(e){e.geometryNeedsUpdate=!0}))}});var i=1/0;Object.defineProperty(this,"upperThreshold",{get:function(){return i},set:function(e){i=e,this.sliceList.forEach((function(e){e.geometryNeedsUpdate=!0}))}}),this.sliceList=[]}).prototype={constructor:e,getData:function(e,t,n){return this.data[n*this.xLength*this.yLength+t*this.xLength+e]},access:function(e,t,n){return n*this.xLength*this.yLength+t*this.xLength+e},reverseAccess:function(e){var t=Math.floor(e/(this.yLength*this.xLength)),n=Math.floor((e-t*this.yLength*this.xLength)/this.xLength);return[e-t*this.yLength*this.xLength-n*this.xLength,n,t]},map:function(e,t){var n=this.data.length;t=t||this;for(var r=0;r<n;r++)this.data[r]=e.call(t,this.data[r],r,this.data);return this},extractPerpendicularPlane:function(e,t){var n,r,o,a,i,s,l,c,f=(new THREE.Matrix4).identity(),u=this,d=new THREE.Vector3,p=new THREE.Vector3,h=new THREE.Vector3,v=new THREE.Vector3(this.xLength,this.yLength,this.zLength);switch(e){case"x":d.set(1,0,0),p.set(0,0,-1),h.set(0,-1,0),i=this.spacing[2],s=this.spacing[1],c=new THREE.Vector3(t,0,0),f.multiply((new THREE.Matrix4).makeRotationY(Math.PI/2)),l=(u.RASDimensions[0]-1)/2,f.setPosition(new THREE.Vector3(t-l,0,0));break;case"y":d.set(0,1,0),p.set(1,0,0),h.set(0,0,1),i=this.spacing[0],s=this.spacing[2],c=new THREE.Vector3(0,t,0),f.multiply((new THREE.Matrix4).makeRotationX(-Math.PI/2)),l=(u.RASDimensions[1]-1)/2,f.setPosition(new THREE.Vector3(0,t-l,0));break;case"z":default:d.set(0,0,1),p.set(1,0,0),h.set(0,-1,0),i=this.spacing[0],s=this.spacing[1],c=new THREE.Vector3(0,0,t),l=(u.RASDimensions[2]-1)/2,f.setPosition(new THREE.Vector3(0,0,t-l))}p.applyMatrix4(u.inverseMatrix).normalize(),p.argVar="i",h.applyMatrix4(u.inverseMatrix).normalize(),h.argVar="j",d.applyMatrix4(u.inverseMatrix).normalize(),n=Math.floor(Math.abs(p.dot(v))),r=Math.floor(Math.abs(h.dot(v))),o=Math.abs(n*i),a=Math.abs(r*s),c=Math.abs(Math.round(c.applyMatrix4(u.inverseMatrix).dot(d)));var m=[new THREE.Vector3(1,0,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1)],x=[p,h,d].find((function(e){return Math.abs(e.dot(m[0]))>.9})),g=[p,h,d].find((function(e){return Math.abs(e.dot(m[1]))>.9})),y=[p,h,d].find((function(e){return Math.abs(e.dot(m[2]))>.9}));return{iLength:n,jLength:r,sliceAccess:function(e,t){var n=x===d?c:"i"===x.argVar?e:t,r=g===d?c:"i"===g.argVar?e:t,o=y===d?c:"i"===y.argVar?e:t,a=x.dot(m[0])>0?n:u.xLength-1-n,i=g.dot(m[1])>0?r:u.yLength-1-r,s=y.dot(m[2])>0?o:u.zLength-1-o;return u.access(a,i,s)},matrix:f,planeWidth:o,planeHeight:a}},extractSlice:function(e,t){var n=new THREE.VolumeSlice(this,t,e);return this.sliceList.push(n),n},repaintAllSlices:function(){return this.sliceList.forEach((function(e){e.repaint()})),this},computeMinMax:function(){var e=1/0,t=-1/0,n=this.data.length,r=0;for(r=0;r<n;r++)if(!isNaN(this.data[r])){var o=this.data[r];e=Math.min(e,o),t=Math.max(t,o)}return this.min=e,this.max=t,[e,t]}},THREE.Volume=e},1362:()=>{!function(){const e={uniforms:{u_size:{value:new THREE.Vector3(1,1,1)},u_renderstyle:{value:0},u_renderthreshold:{value:.5},u_clim:{value:new THREE.Vector2(1,1)},u_data:{value:null},u_cmdata:{value:null}},vertexShader:'\n\n\t\tvarying vec4 v_nearpos;\n\t\tvarying vec4 v_farpos;\n\t\tvarying vec3 v_position;\n\n\t\tvoid main() {\n\t\t\t\t// Prepare transforms to map to "camera view". See also:\n\t\t\t\t// https://threejs.org/docs/#api/renderers/webgl/WebGLProgram\n\t\t\t\tmat4 viewtransformf = modelViewMatrix;\n\t\t\t\tmat4 viewtransformi = inverse(modelViewMatrix);\n\n\t\t\t\t// Project local vertex coordinate to camera position. Then do a step\n\t\t\t\t// backward (in cam coords) to the near clipping plane, and project back. Do\n\t\t\t\t// the same for the far clipping plane. This gives us all the information we\n\t\t\t\t// need to calculate the ray and truncate it to the viewing cone.\n\t\t\t\tvec4 position4 = vec4(position, 1.0);\n\t\t\t\tvec4 pos_in_cam = viewtransformf * position4;\n\n\t\t\t\t// Intersection of ray and near clipping plane (z = -1 in clip coords)\n\t\t\t\tpos_in_cam.z = -pos_in_cam.w;\n\t\t\t\tv_nearpos = viewtransformi * pos_in_cam;\n\n\t\t\t\t// Intersection of ray and far clipping plane (z = +1 in clip coords)\n\t\t\t\tpos_in_cam.z = pos_in_cam.w;\n\t\t\t\tv_farpos = viewtransformi * pos_in_cam;\n\n\t\t\t\t// Set varyings and output pos\n\t\t\t\tv_position = position;\n\t\t\t\tgl_Position = projectionMatrix * viewMatrix * modelMatrix * position4;\n\t\t}',fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\t\t\t\tprecision mediump sampler3D;\n\n\t\t\t\tuniform vec3 u_size;\n\t\t\t\tuniform int u_renderstyle;\n\t\t\t\tuniform float u_renderthreshold;\n\t\t\t\tuniform vec2 u_clim;\n\n\t\t\t\tuniform sampler3D u_data;\n\t\t\t\tuniform sampler2D u_cmdata;\n\n\t\t\t\tvarying vec3 v_position;\n\t\t\t\tvarying vec4 v_nearpos;\n\t\t\t\tvarying vec4 v_farpos;\n\n\t\t\t\t// The maximum distance through our rendering volume is sqrt(3).\n\t\t\t\tconst int MAX_STEPS = 887;\t// 887 for 512^3, 1774 for 1024^3\n\t\t\t\tconst int REFINEMENT_STEPS = 4;\n\t\t\t\tconst float relative_step_size = 1.0;\n\t\t\t\tconst vec4 ambient_color = vec4(0.2, 0.4, 0.2, 1.0);\n\t\t\t\tconst vec4 diffuse_color = vec4(0.8, 0.2, 0.2, 1.0);\n\t\t\t\tconst vec4 specular_color = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t\tconst float shininess = 40.0;\n\n\t\t\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\t\t\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray);\n\n\t\t\t\tfloat sample1(vec3 texcoords);\n\t\t\t\tvec4 apply_colormap(float val);\n\t\t\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray);\n\n\n\t\t\t\tvoid main() {\n\t\t\t\t\t\t// Normalize clipping plane info\n\t\t\t\t\t\tvec3 farpos = v_farpos.xyz / v_farpos.w;\n\t\t\t\t\t\tvec3 nearpos = v_nearpos.xyz / v_nearpos.w;\n\n\t\t\t\t\t\t// Calculate unit vector pointing in the view direction through this fragment.\n\t\t\t\t\t\tvec3 view_ray = normalize(nearpos.xyz - farpos.xyz);\n\n\t\t\t\t\t\t// Compute the (negative) distance to the front surface or near clipping plane.\n\t\t\t\t\t\t// v_position is the back face of the cuboid, so the initial distance calculated in the dot\n\t\t\t\t\t\t// product below is the distance from near clip plane to the back of the cuboid\n\t\t\t\t\t\tfloat distance = dot(nearpos - v_position, view_ray);\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.x - 0.5 - v_position.x) / view_ray.x));\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.y - 0.5 - v_position.y) / view_ray.y));\n\t\t\t\t\t\tdistance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(u_size.z - 0.5 - v_position.z) / view_ray.z));\n\n\t\t\t\t\t\t// Now we have the starting position on the front surface\n\t\t\t\t\t\tvec3 front = v_position + view_ray * distance;\n\n\t\t\t\t\t\t// Decide how many steps to take\n\t\t\t\t\t\tint nsteps = int(-distance / relative_step_size + 0.5);\n\t\t\t\t\t\tif ( nsteps < 1 )\n\t\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t// Get starting location and step vector in texture coordinates\n\t\t\t\t\t\tvec3 step = ((v_position - front) / u_size) / float(nsteps);\n\t\t\t\t\t\tvec3 start_loc = front / u_size;\n\n\t\t\t\t\t\t// For testing: show the number of steps. This helps to establish\n\t\t\t\t\t\t// whether the rays are correctly oriented\n\t\t\t\t\t\t//'gl_FragColor = vec4(0.0, float(nsteps) / 1.0 / u_size.x, 1.0, 1.0);\n\t\t\t\t\t\t//'return;\n\n\t\t\t\t\t\tif (u_renderstyle == 0)\n\t\t\t\t\t\t\t\tcast_mip(start_loc, step, nsteps, view_ray);\n\t\t\t\t\t\telse if (u_renderstyle == 1)\n\t\t\t\t\t\t\t\tcast_iso(start_loc, step, nsteps, view_ray);\n\n\t\t\t\t\t\tif (gl_FragColor.a < 0.05)\n\t\t\t\t\t\t\t\tdiscard;\n\t\t\t\t}\n\n\n\t\t\t\tfloat sample1(vec3 texcoords) {\n\t\t\t\t\t\t/* Sample float value from a 3D texture. Assumes intensity data. */\n\t\t\t\t\t\treturn texture(u_data, texcoords.xyz).r;\n\t\t\t\t}\n\n\n\t\t\t\tvec4 apply_colormap(float val) {\n\t\t\t\t\t\tval = (val - u_clim[0]) / (u_clim[1] - u_clim[0]);\n\t\t\t\t\t\treturn texture2D(u_cmdata, vec2(val, 0.5));\n\t\t\t\t}\n\n\n\t\t\t\tvoid cast_mip(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\t\t\t\tfloat max_val = -1e6;\n\t\t\t\t\t\tint max_i = 100;\n\t\t\t\t\t\tvec3 loc = start_loc;\n\n\t\t\t\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t\t\t\t// inside the loop.\n\t\t\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\t\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t// Sample from the 3D texture\n\t\t\t\t\t\t\t\tfloat val = sample1(loc);\n\t\t\t\t\t\t\t\t// Apply MIP operation\n\t\t\t\t\t\t\t\tif (val > max_val) {\n\t\t\t\t\t\t\t\t\t\tmax_val = val;\n\t\t\t\t\t\t\t\t\t\tmax_i = iter;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Advance location deeper into the volume\n\t\t\t\t\t\t\t\tloc += step;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Refine location, gives crispier images\n\t\t\t\t\t\tvec3 iloc = start_loc + step * (float(max_i) - 0.5);\n\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\t\t\t\t\tmax_val = max(max_val, sample1(iloc));\n\t\t\t\t\t\t\t\tiloc += istep;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Resolve final color\n\t\t\t\t\t\tgl_FragColor = apply_colormap(max_val);\n\t\t\t\t}\n\n\n\t\t\t\tvoid cast_iso(vec3 start_loc, vec3 step, int nsteps, vec3 view_ray) {\n\n\t\t\t\t\t\tgl_FragColor = vec4(0.0);\t// init transparent\n\t\t\t\t\t\tvec4 color3 = vec4(0.0);\t// final color\n\t\t\t\t\t\tvec3 dstep = 1.5 / u_size;\t// step to sample derivative\n\t\t\t\t\t\tvec3 loc = start_loc;\n\n\t\t\t\t\t\tfloat low_threshold = u_renderthreshold - 0.02 * (u_clim[1] - u_clim[0]);\n\n\t\t\t\t\t\t// Enter the raycasting loop. In WebGL 1 the loop index cannot be compared with\n\t\t\t\t\t\t// non-constant expression. So we use a hard-coded max, and an additional condition\n\t\t\t\t\t\t// inside the loop.\n\t\t\t\t\t\tfor (int iter=0; iter<MAX_STEPS; iter++) {\n\t\t\t\t\t\t\t\tif (iter >= nsteps)\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t// Sample from the 3D texture\n\t\t\t\t\t\t\t\tfloat val = sample1(loc);\n\n\t\t\t\t\t\t\t\tif (val > low_threshold) {\n\t\t\t\t\t\t\t\t\t\t// Take the last interval in smaller steps\n\t\t\t\t\t\t\t\t\t\tvec3 iloc = loc - 0.5 * step;\n\t\t\t\t\t\t\t\t\t\tvec3 istep = step / float(REFINEMENT_STEPS);\n\t\t\t\t\t\t\t\t\t\tfor (int i=0; i<REFINEMENT_STEPS; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tval = sample1(iloc);\n\t\t\t\t\t\t\t\t\t\t\t\tif (val > u_renderthreshold) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgl_FragColor = add_lighting(val, iloc, dstep, view_ray);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tiloc += istep;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Advance location deeper into the volume\n\t\t\t\t\t\t\t\tloc += step;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tvec4 add_lighting(float val, vec3 loc, vec3 step, vec3 view_ray)\n\t\t\t\t{\n\t\t\t\t\t// Calculate color by incorporating lighting\n\n\t\t\t\t\t\t// View direction\n\t\t\t\t\t\tvec3 V = normalize(view_ray);\n\n\t\t\t\t\t\t// calculate normal vector from gradient\n\t\t\t\t\t\tvec3 N;\n\t\t\t\t\t\tfloat val1, val2;\n\t\t\t\t\t\tval1 = sample1(loc + vec3(-step[0], 0.0, 0.0));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(+step[0], 0.0, 0.0));\n\t\t\t\t\t\tN[0] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\t\t\t\t\t\tval1 = sample1(loc + vec3(0.0, -step[1], 0.0));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(0.0, +step[1], 0.0));\n\t\t\t\t\t\tN[1] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\t\t\t\t\t\tval1 = sample1(loc + vec3(0.0, 0.0, -step[2]));\n\t\t\t\t\t\tval2 = sample1(loc + vec3(0.0, 0.0, +step[2]));\n\t\t\t\t\t\tN[2] = val1 - val2;\n\t\t\t\t\t\tval = max(max(val1, val2), val);\n\n\t\t\t\t\t\tfloat gm = length(N); // gradient magnitude\n\t\t\t\t\t\tN = normalize(N);\n\n\t\t\t\t\t\t// Flip normal so it points towards viewer\n\t\t\t\t\t\tfloat Nselect = float(dot(N, V) > 0.0);\n\t\t\t\t\t\tN = (2.0 * Nselect - 1.0) * N;\t// ==\tNselect * N - (1.0-Nselect)*N;\n\n\t\t\t\t\t\t// Init colors\n\t\t\t\t\t\tvec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\t\t\tvec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\t\t\t\tvec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\n\n\t\t\t\t\t\t// note: could allow multiple lights\n\t\t\t\t\t\tfor (int i=0; i<1; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t // Get light direction (make sure to prevent zero devision)\n\t\t\t\t\t\t\t\tvec3 L = normalize(view_ray);\t//lightDirs[i];\n\t\t\t\t\t\t\t\tfloat lightEnabled = float( length(L) > 0.0 );\n\t\t\t\t\t\t\t\tL = normalize(L + (1.0 - lightEnabled));\n\n\t\t\t\t\t\t\t\t// Calculate lighting properties\n\t\t\t\t\t\t\t\tfloat lambertTerm = clamp(dot(N, L), 0.0, 1.0);\n\t\t\t\t\t\t\t\tvec3 H = normalize(L+V); // Halfway vector\n\t\t\t\t\t\t\t\tfloat specularTerm = pow(max(dot(H, N), 0.0), shininess);\n\n\t\t\t\t\t\t\t\t// Calculate mask\n\t\t\t\t\t\t\t\tfloat mask1 = lightEnabled;\n\n\t\t\t\t\t\t\t\t// Calculate colors\n\t\t\t\t\t\t\t\tambient_color +=\tmask1 * ambient_color;\t// * gl_LightSource[i].ambient;\n\t\t\t\t\t\t\t\tdiffuse_color +=\tmask1 * lambertTerm;\n\t\t\t\t\t\t\t\tspecular_color += mask1 * specularTerm * specular_color;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculate final color by componing different components\n\t\t\t\t\t\tvec4 final_color;\n\t\t\t\t\t\tvec4 color = apply_colormap(val);\n\t\t\t\t\t\tfinal_color = color * (ambient_color + diffuse_color) + specular_color;\n\t\t\t\t\t\tfinal_color.a = color.a;\n\t\t\t\t\t\treturn final_color;\n\t\t\t\t}"};THREE.VolumeRenderShader1=e}()},8:()=>{var e;(e=function(e,t,n){var r=this;this.volume=e,t=t||0,Object.defineProperty(this,"index",{get:function(){return t},set:function(e){return t=e,r.geometryNeedsUpdate=!0,t}}),this.axis=n||"z",this.canvas=document.createElement("canvas"),this.canvasBuffer=document.createElement("canvas"),this.updateGeometry();var o=new THREE.Texture(this.canvas);o.minFilter=THREE.LinearFilter,o.wrapS=o.wrapT=THREE.ClampToEdgeWrapping;var a=new THREE.MeshBasicMaterial({map:o,side:THREE.DoubleSide,transparent:!0});this.mesh=new THREE.Mesh(this.geometry,a),this.mesh.matrixAutoUpdate=!1,this.geometryNeedsUpdate=!0,this.repaint()}).prototype={constructor:e,repaint:function(){this.geometryNeedsUpdate&&this.updateGeometry();var e=this.iLength,t=this.jLength,n=this.sliceAccess,r=this.volume,o=this.canvasBuffer,a=this.ctxBuffer,i=a.getImageData(0,0,e,t),s=i.data,l=r.data,c=r.upperThreshold,f=r.lowerThreshold,u=r.windowLow,d=r.windowHigh,p=0;if("label"===r.dataType)for(var h=0;h<t;h++)for(var v=0;v<e;v++){var m=l[n(v,h)];m=m>=this.colorMap.length?m%this.colorMap.length+1:m;var x=this.colorMap[m];s[4*p]=x>>24&255,s[4*p+1]=x>>16&255,s[4*p+2]=x>>8&255,s[4*p+3]=255&x,p++}else for(h=0;h<t;h++)for(v=0;v<e;v++){var g=l[n(v,h)],y=255;y=c>=g&&f<=g?y:0,g=(g=Math.floor(255*(g-u)/(d-u)))>255?255:g<0?0:0|g,s[4*p]=g,s[4*p+1]=g,s[4*p+2]=g,s[4*p+3]=y,p++}a.putImageData(i,0,0),this.ctx.drawImage(o,0,0,e,t,0,0,this.canvas.width,this.canvas.height),this.mesh.material.map.needsUpdate=!0},updateGeometry:function(){var e=this.volume.extractPerpendicularPlane(this.axis,this.index);this.sliceAccess=e.sliceAccess,this.jLength=e.jLength,this.iLength=e.iLength,this.matrix=e.matrix,this.canvas.width=e.planeWidth,this.canvas.height=e.planeHeight,this.canvasBuffer.width=this.iLength,this.canvasBuffer.height=this.jLength,this.ctx=this.canvas.getContext("2d"),this.ctxBuffer=this.canvasBuffer.getContext("2d"),this.geometry&&this.geometry.dispose(),this.geometry=new THREE.PlaneGeometry(e.planeWidth,e.planeHeight),this.mesh&&(this.mesh.geometry=this.geometry,this.mesh.matrix.identity(),this.mesh.applyMatrix4(this.matrix)),this.geometryNeedsUpdate=!1}},THREE.VolumeSlice=e},3946:function(e){"undefined"!=typeof self&&self,e.exports=function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=18)}([function(e,t,n){"use strict";function r(e){return e&&0===e.length}function o(e){return null==e?[]:Object.keys(e)}function a(e){for(var t=[],n=Object.keys(e),r=0;r<n.length;r++)t.push(e[n[r]]);return t}function i(e,t){for(var n=[],r=o(e),a=0;a<r.length;a++){var i=r[a];n.push(t.call(null,e[i],i))}return n}function s(e,t){for(var n=[],r=0;r<e.length;r++)n.push(t.call(null,e[r],r));return n}function l(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];Array.isArray(r)?t=t.concat(l(r)):t.push(r)}return t}function c(e){return r(e)?void 0:e[0]}function f(e){var t=e&&e.length;return t?e[t-1]:void 0}function u(e,t){if(Array.isArray(e))for(var n=0;n<e.length;n++)t.call(null,e[n],n);else{if(!k(e))throw Error("non exhaustive match");var r=o(e);for(n=0;n<r.length;n++){var a=r[n],i=e[a];t.call(null,i,a)}}}function d(e){return"string"==typeof e}function p(e){return void 0===e}function h(e){return e instanceof Function}function v(e,t){return void 0===t&&(t=1),e.slice(t,e.length)}function m(e,t){return void 0===t&&(t=1),e.slice(0,e.length-t)}function x(e,t){var n=[];if(Array.isArray(e))for(var r=0;r<e.length;r++){var o=e[r];t.call(null,o)&&n.push(o)}return n}function g(e,t){return x(e,(function(e){return!t(e)}))}function y(e,t){for(var n=Object.keys(e),r={},o=0;o<n.length;o++){var a=n[o],i=e[a];t(i)&&(r[a]=i)}return r}function E(e,t){return!!k(e)&&e.hasOwnProperty(t)}function w(e,t){return void 0!==T(e,(function(e){return e===t}))}function b(e){for(var t=[],n=0;n<e.length;n++)t.push(e[n]);return t}function _(e){var t={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t}function T(e,t){for(var n=0;n<e.length;n++){var r=e[n];if(t.call(null,r))return r}}function A(e,t){for(var n=[],r=0;r<e.length;r++){var o=e[r];t.call(null,o)&&n.push(o)}return n}function S(e,t,n){for(var r=Array.isArray(e),i=r?e:a(e),s=r?[]:o(e),l=n,c=0;c<i.length;c++)l=t.call(null,l,i[c],r?c:s[c]);return l}function R(e){return g(e,(function(e){return null==e}))}function M(e,t){void 0===t&&(t=function(e){return e});var n=[];return S(e,(function(e,r){var o=t(r);return w(n,o)?e:(n.push(o),e.concat(r))}),[])}function C(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];var r=[null].concat(t);return Function.bind.apply(e,r)}function L(e){return Array.isArray(e)}function P(e){return e instanceof RegExp}function k(e){return e instanceof Object}function N(e,t){for(var n=0;n<e.length;n++)if(!t(e[n],n))return!1;return!0}function H(e,t){return g(e,(function(e){return w(t,e)}))}function z(e,t){for(var n=0;n<e.length;n++)if(t(e[n]))return!0;return!1}function D(e,t){for(var n=0;n<e.length;n++)if(e[n]===t)return n;return-1}function F(e,t){var n=b(e);return n.sort((function(e,n){return t(e)-t(n)})),n}function I(e,t){if(e.length!==t.length)throw Error("can't zipObject with different number of keys and values!");for(var n={},r=0;r<e.length;r++)n[e[r]]=t[r];return n}function O(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var r=0;r<t.length;r++)for(var a=t[r],i=o(a),s=0;s<i.length;s++){var l=i[s];e[l]=a[l]}return e}function U(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];for(var r=0;r<t.length;r++){var a=t[r];if(!p(a))for(var i=o(a),s=0;s<i.length;s++){var l=i[s];E(e,l)||(e[l]=a[l])}}return e}function G(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return U.apply(null,[{}].concat(e))}function B(e,t){var n={};return u(e,(function(e){var r=t(e),o=n[r];o?o.push(e):n[r]=[e]})),n}function V(e,t){for(var n=_(e),r=o(t),a=0;a<r.length;a++){var i=r[a],s=t[i];n[i]=s}return n}function W(){}function j(e){return e}function q(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];t.push(void 0!==r?r:void 0)}return t}function X(e){console&&console.error&&console.error("Error: "+e)}function Y(e){console&&console.warn&&console.warn("Warning: "+e)}function Q(){return"function"==typeof Map}function K(e,t){t.forEach((function(t){var n=t.prototype;Object.getOwnPropertyNames(n).forEach((function(r){if("constructor"!==r){var o=Object.getOwnPropertyDescriptor(n,r);o&&(o.get||o.set)?Object.defineProperty(e.prototype,r,o):e.prototype[r]=t.prototype[r]}}))}))}function Z(e){function t(){}t.prototype=e;var n=new t;function r(){return typeof n.bar}return r(),r(),e}Object.defineProperty(t,"__esModule",{value:!0}),t.isEmpty=r,t.keys=o,t.values=a,t.mapValues=i,t.map=s,t.flatten=l,t.first=c,t.last=f,t.forEach=u,t.isString=d,t.isUndefined=p,t.isFunction=h,t.drop=v,t.dropRight=m,t.filter=x,t.reject=g,t.pick=y,t.has=E,t.contains=w,t.cloneArr=b,t.cloneObj=_,t.find=T,t.findAll=A,t.reduce=S,t.compact=R,t.uniq=M,t.partial=C,t.isArray=L,t.isRegExp=P,t.isObject=k,t.every=N,t.difference=H,t.some=z,t.indexOf=D,t.sortBy=F,t.zipObject=I,t.assign=O,t.assignNoOverwrite=U,t.defaults=G,t.groupBy=B,t.merge=V,t.NOOP=W,t.IDENTITY=j,t.packArray=q,t.PRINT_ERROR=X,t.PRINT_WARNING=Y,t.isES2015MapSupported=Q,t.applyMixins=K,t.toFastProperties=Z},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(0),i=n(2),s=function(){function e(e){this.definition=e}return e.prototype.accept=function(e){e.visit(this),a.forEach(this.definition,(function(t){t.accept(e)}))},e}();t.AbstractProduction=s;var l=function(e){function t(t){var n=e.call(this,[])||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),Object.defineProperty(t.prototype,"definition",{get:function(){return void 0!==this.referencedRule?this.referencedRule.definition:[]},set:function(e){},enumerable:!0,configurable:!0}),t.prototype.accept=function(e){e.visit(this)},t}(s);t.NonTerminal=l;var c=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.orgText="",a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.Rule=c;var f=function(e){function t(t){var n=e.call(this,t.definition)||this;return a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.Flat=f;var u=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.Option=u;var d=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.RepetitionMandatory=d;var p=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.RepetitionMandatoryWithSeparator=p;var h=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.Repetition=h;var v=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.RepetitionWithSeparator=v;var m=function(e){function t(t){var n=e.call(this,t.definition)||this;return n.idx=1,a.assign(n,a.pick(t,(function(e){return void 0!==e}))),n}return o(t,e),t}(s);t.Alternation=m;var x=function(){function e(e){this.idx=1,a.assign(this,a.pick(e,(function(e){return void 0!==e})))}return e.prototype.accept=function(e){e.visit(this)},e}();function g(e){function t(e){return a.map(e,g)}if(e instanceof l)return{type:"NonTerminal",name:e.nonTerminalName,idx:e.idx};if(e instanceof f)return{type:"Flat",definition:t(e.definition)};if(e instanceof u)return{type:"Option",idx:e.idx,definition:t(e.definition)};if(e instanceof d)return{type:"RepetitionMandatory",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof p)return{type:"RepetitionMandatoryWithSeparator",name:e.name,idx:e.idx,separator:g(new x({terminalType:e.separator})),definition:t(e.definition)};if(e instanceof v)return{type:"RepetitionWithSeparator",name:e.name,idx:e.idx,separator:g(new x({terminalType:e.separator})),definition:t(e.definition)};if(e instanceof h)return{type:"Repetition",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof m)return{type:"Alternation",name:e.name,idx:e.idx,definition:t(e.definition)};if(e instanceof x){var n={type:"Terminal",name:i.tokenName(e.terminalType),label:i.tokenLabel(e.terminalType),idx:e.idx},r=e.terminalType.PATTERN;return e.terminalType.PATTERN&&(n.pattern=a.isRegExp(r)?r.source:r),n}if(e instanceof c)return{type:"Rule",name:e.name,orgText:e.orgText,definition:t(e.definition)};throw Error("non exhaustive match")}t.Terminal=x,t.serializeGrammar=function(e){return a.map(e,g)},t.serializeProduction=g},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(4),a=n(15),i=n(7);function s(e){return r.isString(e.LABEL)&&""!==e.LABEL}function l(e){return r.isObject(e)&&e.hasOwnProperty("tokenName")&&r.isString(e.tokenName)?e.tokenName:o.functionName(e)}t.tokenLabel=function(e){return s(e)?e.LABEL:l(e)},t.hasTokenLabel=s,t.tokenName=l;var c="parent",f="categories",u="label",d="group",p="push_mode",h="pop_mode",v="longer_alt",m="line_breaks",x="start_chars_hint";function g(e){return function(e){var t=e.name,n=e.pattern,a={};if(o.defineNameProp(a,t)||(a.tokenName=t),r.isUndefined(n)||(a.PATTERN=n),r.has(e,c))throw"The parent property is no longer supported.\nSee: https://github.com/SAP/chevrotain/issues/564#issuecomment-349062346 for details.";return r.has(e,f)&&(a.CATEGORIES=e[f]),i.augmentTokenTypes([a]),r.has(e,u)&&(a.LABEL=e[u]),r.has(e,d)&&(a.GROUP=e[d]),r.has(e,h)&&(a.POP_MODE=e[h]),r.has(e,p)&&(a.PUSH_MODE=e[p]),r.has(e,v)&&(a.LONGER_ALT=e[v]),r.has(e,m)&&(a.LINE_BREAKS=e[m]),r.has(e,x)&&(a.START_CHARS_HINT=e[x]),a}(e)}t.createToken=g,t.EOF=g({name:"EOF",pattern:a.Lexer.NA}),i.augmentTokenTypes([t.EOF]),t.createTokenInstance=function(e,t,n,r,o,a,i,s){return{image:t,startOffset:n,endOffset:r,startLine:o,endLine:a,startColumn:i,endColumn:s,tokenTypeIdx:e.tokenTypeIdx,tokenType:e}},t.tokenMatcher=function(e,t){return i.tokenStructuredMatcher(e,t)}},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(4),i=n(0),s=n(26),l=n(2),c=n(23),f=n(16),u=n(10),d=n(24),p=n(25),h=n(31),v=n(32),m=n(34),x=n(35),g=n(36),y=n(37),E=n(38);t.END_OF_FILE=l.createTokenInstance(l.EOF,"",NaN,NaN,NaN,NaN,NaN,NaN),Object.freeze(t.END_OF_FILE),t.DEFAULT_PARSER_CONFIG=Object.freeze({recoveryEnabled:!1,maxLookahead:4,ignoredIssues:{},dynamicTokensEnabled:!1,outputCst:!0,errorMessageProvider:u.defaultParserErrorProvider,serializedGrammar:null}),t.DEFAULT_RULE_CONFIG=Object.freeze({recoveryValueFunc:function(){},resyncEnabled:!0}),function(e){e[e.INVALID_RULE_NAME=0]="INVALID_RULE_NAME",e[e.DUPLICATE_RULE_NAME=1]="DUPLICATE_RULE_NAME",e[e.INVALID_RULE_OVERRIDE=2]="INVALID_RULE_OVERRIDE",e[e.DUPLICATE_PRODUCTIONS=3]="DUPLICATE_PRODUCTIONS",e[e.UNRESOLVED_SUBRULE_REF=4]="UNRESOLVED_SUBRULE_REF",e[e.LEFT_RECURSION=5]="LEFT_RECURSION",e[e.NONE_LAST_EMPTY_ALT=6]="NONE_LAST_EMPTY_ALT",e[e.AMBIGUOUS_ALTS=7]="AMBIGUOUS_ALTS",e[e.CONFLICT_TOKENS_RULES_NAMESPACE=8]="CONFLICT_TOKENS_RULES_NAMESPACE",e[e.INVALID_TOKEN_NAME=9]="INVALID_TOKEN_NAME",e[e.INVALID_NESTED_RULE_NAME=10]="INVALID_NESTED_RULE_NAME",e[e.DUPLICATE_NESTED_NAME=11]="DUPLICATE_NESTED_NAME",e[e.NO_NON_EMPTY_LOOKAHEAD=12]="NO_NON_EMPTY_LOOKAHEAD",e[e.AMBIGUOUS_PREFIX_ALTS=13]="AMBIGUOUS_PREFIX_ALTS",e[e.TOO_MANY_ALTS=14]="TOO_MANY_ALTS"}(t.ParserDefinitionErrorType||(t.ParserDefinitionErrorType={})),t.EMPTY_ALT=function(e){return void 0===e&&(e=void 0),function(){return e}};var w=function(){function e(e,n){void 0===n&&(n=t.DEFAULT_PARSER_CONFIG),this.ignoredIssues=t.DEFAULT_PARSER_CONFIG.ignoredIssues,this.definitionErrors=[],this.selfAnalysisDone=!1,this.initErrorHandler(n),this.initLexerAdapter(),this.initLooksAhead(n),this.initRecognizerEngine(e,n),this.initRecoverable(n),this.initTreeBuilder(n),this.initContentAssist(),this.ignoredIssues=i.has(n,"ignoredIssues")?n.ignoredIssues:t.DEFAULT_PARSER_CONFIG.ignoredIssues,i.toFastProperties(this)}return e.performSelfAnalysis=function(e){e.performSelfAnalysis()},e.prototype.performSelfAnalysis=function(){var t,n=this;this.selfAnalysisDone=!0;var r=a.classNameFromInstance(this),o=this.gastProductionsCache;if(this.serializedGrammar){var l=c.deserializeGrammar(this.serializedGrammar,this.tokensMap);i.forEach(l,(function(e){n.gastProductionsCache.put(e.name,e)}))}var p=d.resolveGrammar({rules:o.values()});if(this.definitionErrors.push.apply(this.definitionErrors,p),i.isEmpty(p)){var h=d.validateGrammar({rules:o.values(),maxLookahead:this.maxLookahead,tokenTypes:i.values(this.tokensMap),ignoredIssues:this.ignoredIssues,errMsgProvider:u.defaultGrammarValidatorErrorProvider,grammarName:r});this.definitionErrors.push.apply(this.definitionErrors,h)}if(i.isEmpty(this.definitionErrors)){var v=s.computeAllProdsFollows(o.values());this.resyncFollows=v}var m=f.analyzeCst(o.values(),this.fullRuleNameToShort);if(this.allRuleNames=m.allRuleNames,!e.DEFER_DEFINITION_ERRORS_HANDLING&&!i.isEmpty(this.definitionErrors))throw t=i.map(this.definitionErrors,(function(e){return e.message})),new Error("Parser Definition Errors detected:\n "+t.join("\n-------------------------------\n"))},e.DEFER_DEFINITION_ERRORS_HANDLING=!1,e}();t.Parser=w,i.applyMixins(w,[p.Recoverable,h.LooksAhead,v.TreeBuilder,m.LexerAdapter,g.RecognizerEngine,x.RecognizerApi,y.ErrorHandler,E.ContentAssist]);var b=function(e){function n(n,r){void 0===r&&(r=t.DEFAULT_PARSER_CONFIG);var o=i.cloneObj(r);return o.outputCst=!0,e.call(this,n,o)||this}return o(n,e),n}(w);t.CstParser=b;var _=function(e){function n(n,r){void 0===r&&(r=t.DEFAULT_PARSER_CONFIG);var o=i.cloneObj(r);return o.outputCst=!1,e.call(this,n,o)||this}return o(n,e),n}(w);t.EmbeddedActionsParser=_},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0);t.classNameFromInstance=function(e){return i(e.constructor)};var o=/^\s*function\s*(\S*)\s*\(/,a="name";function i(e){return e.name||e.toString().match(o)[1]}t.functionName=i,t.defineNameProp=function(e,t){var n=Object.getOwnPropertyDescriptor(e,a);return!(!r.isUndefined(n)&&!n.configurable||(Object.defineProperty(e,a,{enumerable:!1,configurable:!0,writable:!1,value:t}),0))};var s=function(){function e(){this._state={}}return e.prototype.keys=function(){return r.keys(this._state)},e.prototype.values=function(){return r.values(this._state)},e.prototype.put=function(e,t){this._state[e]=t},e.prototype.putAll=function(e){this._state=r.assign(this._state,e._state)},e.prototype.get=function(e){return this._state[e]},e.prototype.containsKey=function(e){return r.has(this._state,e)},e.prototype.clear=function(){this._state={}},e}();t.HashTable=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(1),o=function(){function e(){}return e.prototype.visit=function(e){if(e instanceof r.NonTerminal)return this.visitNonTerminal(e);if(e instanceof r.Flat)return this.visitFlat(e);if(e instanceof r.Option)return this.visitOption(e);if(e instanceof r.RepetitionMandatory)return this.visitRepetitionMandatory(e);if(e instanceof r.RepetitionMandatoryWithSeparator)return this.visitRepetitionMandatoryWithSeparator(e);if(e instanceof r.RepetitionWithSeparator)return this.visitRepetitionWithSeparator(e);if(e instanceof r.Repetition)return this.visitRepetition(e);if(e instanceof r.Alternation)return this.visitAlternation(e);if(e instanceof r.Terminal)return this.visitTerminal(e);if(e instanceof r.Rule)return this.visitRule(e);throw Error("non exhaustive match")},e.prototype.visitNonTerminal=function(e){},e.prototype.visitFlat=function(e){},e.prototype.visitOption=function(e){},e.prototype.visitRepetition=function(e){},e.prototype.visitRepetitionMandatory=function(e){},e.prototype.visitRepetitionMandatoryWithSeparator=function(e){},e.prototype.visitRepetitionWithSeparator=function(e){},e.prototype.visitAlternation=function(e){},e.prototype.visitTerminal=function(e){},e.prototype.visitRule=function(e){},e}();t.GAstVisitor=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o="MismatchedTokenException",a="NoViableAltException",i="EarlyExitException",s="NotAllInputParsedException",l=[o,a,i,s];function c(e,t,n){this.name=o,this.message=e,this.token=t,this.previousToken=n,this.resyncedTokens=[]}function f(e,t,n){this.name=a,this.message=e,this.token=t,this.previousToken=n,this.resyncedTokens=[]}function u(e,t){this.name=s,this.message=e,this.token=t,this.resyncedTokens=[]}function d(e,t,n){this.name=i,this.message=e,this.token=t,this.previousToken=n,this.resyncedTokens=[]}Object.freeze(l),t.isRecognitionException=function(e){return r.contains(l,e.name)},t.MismatchedTokenException=c,c.prototype=Error.prototype,t.NoViableAltException=f,f.prototype=Error.prototype,t.NotAllInputParsedException=u,u.prototype=Error.prototype,t.EarlyExitException=d,d.prototype=Error.prototype},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(4),a=n(2);function i(e){for(var t=r.cloneArr(e),n=e,o=!0;o;){n=r.compact(r.flatten(r.map(n,(function(e){return e.CATEGORIES}))));var a=r.difference(n,t);t=t.concat(a),r.isEmpty(a)?o=!1:n=a}return t}function s(e){r.forEach(e,(function(e){u(e)||(t.tokenIdxToClass.put(t.tokenShortNameIdx,e),e.tokenTypeIdx=t.tokenShortNameIdx++),d(e)&&!r.isArray(e.CATEGORIES)&&(e.CATEGORIES=[e.CATEGORIES]),d(e)||(e.CATEGORIES=[]),p(e)||(e.categoryMatches=[]),h(e)||(e.categoryMatchesMap={}),v(e)||(e.tokenName=a.tokenName(e))}))}function l(e){r.forEach(e,(function(e){e.categoryMatches=[],r.forEach(e.categoryMatchesMap,(function(n,r){e.categoryMatches.push(t.tokenIdxToClass.get(r).tokenTypeIdx)}))}))}function c(e){r.forEach(e,(function(e){f([],e)}))}function f(e,t){r.forEach(e,(function(e){t.categoryMatchesMap[e.tokenTypeIdx]=!0})),r.forEach(t.CATEGORIES,(function(n){var o=e.concat(t);r.contains(o,n)||f(o,n)}))}function u(e){return r.has(e,"tokenTypeIdx")}function d(e){return r.has(e,"CATEGORIES")}function p(e){return r.has(e,"categoryMatches")}function h(e){return r.has(e,"categoryMatchesMap")}function v(e){return r.has(e,"tokenName")}t.tokenStructuredMatcher=function(e,t){var n=e.tokenTypeIdx;return n===t.tokenTypeIdx||!0===t.isParent&&!0===t.categoryMatchesMap[n]},t.tokenStructuredMatcherNoCategories=function(e,t){return e.tokenTypeIdx===t.tokenTypeIdx},t.tokenShortNameIdx=1,t.tokenIdxToClass=new o.HashTable,t.augmentTokenTypes=function(e){var t=i(e);s(t),c(t),l(t),r.forEach(t,(function(e){e.isParent=e.categoryMatches.length>0}))},t.expandCategories=i,t.assignTokenDefaultProps=s,t.assignCategoriesTokensProp=l,t.assignCategoriesMapProp=c,t.singleAssignCategoriesToksMap=f,t.hasShortKeyProperty=u,t.hasCategoriesProperty=d,t.hasExtendingTokensTypesProperty=p,t.hasExtendingTokensTypesMapProperty=h,t.hasTokenNameProperty=v,t.isTokenType=function(e){return r.has(e,"tokenTypeIdx")}},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(0),i=n(1),s=n(5),l=n(2);t.isSequenceProd=function(e){return e instanceof i.Flat||e instanceof i.Option||e instanceof i.Repetition||e instanceof i.RepetitionMandatory||e instanceof i.RepetitionMandatoryWithSeparator||e instanceof i.RepetitionWithSeparator||e instanceof i.Terminal||e instanceof i.Rule},t.isOptionalProd=function e(t,n){return void 0===n&&(n=[]),!!(t instanceof i.Option||t instanceof i.Repetition||t instanceof i.RepetitionWithSeparator)||(t instanceof i.Alternation?a.some(t.definition,(function(t){return e(t,n)})):!(t instanceof i.NonTerminal&&a.contains(n,t))&&t instanceof i.AbstractProduction&&(t instanceof i.NonTerminal&&n.push(t),a.every(t.definition,(function(t){return e(t,n)}))))},t.isBranchingProd=function(e){return e instanceof i.Alternation},t.getProductionDslName=function(e){if(e instanceof i.NonTerminal)return"SUBRULE";if(e instanceof i.Option)return"OPTION";if(e instanceof i.Alternation)return"OR";if(e instanceof i.RepetitionMandatory)return"AT_LEAST_ONE";if(e instanceof i.RepetitionMandatoryWithSeparator)return"AT_LEAST_ONE_SEP";if(e instanceof i.RepetitionWithSeparator)return"MANY_SEP";if(e instanceof i.Repetition)return"MANY";if(e instanceof i.Terminal)return"CONSUME";throw Error("non exhaustive match")};var c=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.separator="-",t.dslMethods={option:[],alternation:[],repetition:[],repetitionWithSeparator:[],repetitionMandatory:[],repetitionMandatoryWithSeparator:[]},t}return o(t,e),t.prototype.visitTerminal=function(e){var t=l.tokenName(e.terminalType)+this.separator+"Terminal";a.has(this.dslMethods,t)||(this.dslMethods[t]=[]),this.dslMethods[t].push(e)},t.prototype.visitNonTerminal=function(e){var t=e.nonTerminalName+this.separator+"Terminal";a.has(this.dslMethods,t)||(this.dslMethods[t]=[]),this.dslMethods[t].push(e)},t.prototype.visitOption=function(e){this.dslMethods.option.push(e)},t.prototype.visitRepetitionWithSeparator=function(e){this.dslMethods.repetitionWithSeparator.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.dslMethods.repetitionMandatory.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.dslMethods.repetitionMandatoryWithSeparator.push(e)},t.prototype.visitRepetition=function(e){this.dslMethods.repetition.push(e)},t.prototype.visitAlternation=function(e){this.dslMethods.alternation.push(e)},t}(s.GAstVisitor);t.DslMethodsCollectorVisitor=c},function(e,t,n){"use strict";function r(e,t,n){return n|t|e}Object.defineProperty(t,"__esModule",{value:!0}),t.BITS_FOR_METHOD_IDX=4,t.BITS_FOR_OCCURRENCE_IDX=4,t.BITS_FOR_RULE_IDX=24,t.BITS_FOR_ALT_IDX=8,t.OR_IDX=1<<t.BITS_FOR_METHOD_IDX,t.OPTION_IDX=2<<t.BITS_FOR_METHOD_IDX,t.MANY_IDX=3<<t.BITS_FOR_METHOD_IDX,t.AT_LEAST_ONE_IDX=4<<t.BITS_FOR_METHOD_IDX,t.MANY_SEP_IDX=5<<t.BITS_FOR_METHOD_IDX,t.AT_LEAST_ONE_SEP_IDX=6<<t.BITS_FOR_METHOD_IDX,t.getKeyForAutomaticLookahead=r;var o=32-t.BITS_FOR_ALT_IDX;t.getKeyForAltIndex=function(e,t,n,a){var i=a+1<<o;return r(e,t,n)|i}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(2),o=n(0),a=n(0),i=n(1),s=n(8),l=n(11),c=n(17),f=n(3);t.defaultParserErrorProvider={buildMismatchTokenMessage:function(e){var t=e.expected,n=e.actual;return e.previous,e.ruleName,"Expecting "+(r.hasTokenLabel(t)?"--\x3e "+r.tokenLabel(t)+" <--":"token of type --\x3e "+r.tokenName(t)+" <--")+" but found --\x3e '"+n.image+"' <--"},buildNotAllInputParsedMessage:function(e){var t=e.firstRedundant;return e.ruleName,"Redundant input, expecting EOF but found: "+t.image},buildNoViableAltMessage:function(e){var t=e.expectedPathsPerAlt,n=e.actual,o=(e.previous,e.customUserDescription),i=(e.ruleName,"\nbut found: '"+a.first(n).image+"'");if(o)return"Expecting: "+o+i;var s=a.reduce(t,(function(e,t){return e.concat(t)}),[]),l=a.map(s,(function(e){return"["+a.map(e,(function(e){return r.tokenLabel(e)})).join(", ")+"]"}));return"Expecting: one of these possible Token sequences:\n"+a.map(l,(function(e,t){return"  "+(t+1)+". "+e})).join("\n")+i},buildEarlyExitMessage:function(e){var t=e.expectedIterationPaths,n=e.actual,o=e.customUserDescription,i=(e.ruleName,"\nbut found: '"+a.first(n).image+"'");return o?"Expecting: "+o+i:"Expecting: expecting at least one iteration which starts with one of these possible Token sequences::\n  <"+a.map(t,(function(e){return"["+a.map(e,(function(e){return r.tokenLabel(e)})).join(",")+"]"})).join(" ,")+">"+i}},Object.freeze(t.defaultParserErrorProvider),t.defaultGrammarResolverErrorProvider={buildRuleNotFoundError:function(e,t){return"Invalid grammar, reference to a rule which is not defined: ->"+t.nonTerminalName+"<-\ninside top level rule: ->"+e.name+"<-"}},t.defaultGrammarValidatorErrorProvider={buildDuplicateFoundError:function(e,t){var n,o=e.name,l=a.first(t),c=l.idx,f=s.getProductionDslName(l),u=(n=l)instanceof i.Terminal?r.tokenName(n.terminalType):n instanceof i.NonTerminal?n.nonTerminalName:"",d="->"+f+"<- with numerical suffix: ->"+c+"<-\n                  "+(u?"and argument: ->"+u+"<-":"")+"\n                  appears more than once ("+t.length+" times) in the top level rule: ->"+o+"<-.\n                  "+(0===c?"Also note that numerical suffix 0 means "+f+" without any suffix.":"")+"\n                  To fix this make sure each usage of "+f+" "+(u?"with the argument: ->"+u+"<-":"")+"\n                  in the rule ->"+o+"<- has a different occurrence index (0-5), as that combination acts as a unique\n                  position key in the grammar, which is needed by the parsing engine.\n                  \n                  For further details see: https://sap.github.io/chevrotain/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ";return(d=d.replace(/[ \t]+/g," ")).replace(/\s\s+/g,"\n")},buildInvalidNestedRuleNameError:function(e,t){return"Invalid nested rule name: ->"+t.name+"<- inside rule: ->"+e.name+"<-\nit must match the pattern: ->"+l.validNestedRuleName.toString()+"<-.\nNote that this means a nested rule name must start with the '$'(dollar) sign."},buildDuplicateNestedRuleNameError:function(e,t){return"Duplicate nested rule name: ->"+a.first(t).name+"<- inside rule: ->"+e.name+"<-\nA nested name must be unique in the scope of a top level grammar rule."},buildNamespaceConflictError:function(e){return"Namespace conflict found in grammar.\nThe grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <"+e.name+">.\nTo resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter."},buildAlternationPrefixAmbiguityError:function(e){var t=a.map(e.prefixPath,(function(e){return r.tokenLabel(e)})).join(", "),n=0===e.alternation.idx?"":e.alternation.idx;return"Ambiguous alternatives: <"+e.ambiguityIndices.join(" ,")+"> due to common lookahead prefix\nin <OR"+n+"> inside <"+e.topLevelRule.name+"> Rule,\n<"+t+"> may appears as a prefix path in all these alternatives.\nhttps://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details."},buildAlternationAmbiguityError:function(e){var t=a.map(e.prefixPath,(function(e){return r.tokenLabel(e)})).join(", "),n=0===e.alternation.idx?"":e.alternation.idx,o="Ambiguous alternatives: <"+e.ambiguityIndices.join(" ,")+"> in <OR"+n+"> inside <"+e.topLevelRule.name+"> Rule,\n<"+t+"> may appears as a prefix path in all these alternatives.\n",i=c.VERSION.replace(/\./g,"_");return o+"To Resolve this, try one of of the following: \n1. Refactor your grammar to be LL(K) for the current value of k (by default k="+f.DEFAULT_PARSER_CONFIG.maxLookahead+"})\n2. Increase the value of K for your grammar by providing a larger 'maxLookahead' value in the parser's config\n3. This issue can be ignored (if you know what you are doing...), see https://sap.github.io/chevrotain/documentation/"+i+"/interfaces/iparserconfig.html#ignoredissues for more details\n"},buildEmptyRepetitionError:function(e){var t=s.getProductionDslName(e.repetition);return 0!==e.repetition.idx&&(t+=e.repetition.idx),"The repetition <"+t+"> within Rule <"+e.topLevelRule.name+"> can never consume any tokens.\nThis could lead to an infinite loop."},buildTokenNameError:function(e){return"Invalid Grammar Token name: ->"+r.tokenName(e.tokenType)+"<- it must match the pattern: ->"+e.expectedPattern.toString()+"<-"},buildEmptyAlternationError:function(e){return"Ambiguous empty alternative: <"+(e.emptyChoiceIdx+1)+"> in <OR"+e.alternation.idx+"> inside <"+e.topLevelRule.name+"> Rule.\nOnly the last alternative may be an empty alternative."},buildTooManyAlternativesError:function(e){return"An Alternation cannot have more than 256 alternatives:\n<OR"+e.alternation.idx+"> inside <"+e.topLevelRule.name+"> Rule.\n has "+(e.alternation.definition.length+1)+" alternatives."},buildLeftRecursionError:function(e){var t=e.topLevelRule.name;return"Left Recursion found in grammar.\nrule: <"+t+"> can be invoked from itself (directly or indirectly)\nwithout consuming any Tokens. The grammar path that causes this is: \n "+t+" --\x3e "+o.map(e.leftRecursionPath,(function(e){return e.name})).concat([t]).join(" --\x3e ")+"\n To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring."},buildInvalidRuleNameError:function(e){return"Invalid grammar rule name: ->"+e.topLevelRule.name+"<- it must match the pattern: ->"+e.expectedPattern.toString()+"<-"},buildDuplicateRuleNameError:function(e){return"Duplicate definition, rule: ->"+(e.topLevelRule instanceof i.Rule?e.topLevelRule.name:e.topLevelRule)+"<- is already defined in the grammar: ->"+e.grammarName+"<-"}}},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(0),i=n(0),s=n(3),l=n(8),c=n(2),f=n(12),u=n(16),d=n(13),p=n(1),h=n(5);function v(e){return l.getProductionDslName(e)+"_#_"+e.idx+"_#_"+m(e)}function m(e){return e instanceof p.Terminal?c.tokenName(e.terminalType):e instanceof p.NonTerminal?e.nonTerminalName:""}t.validateGrammar=function(e,t,n,r,o,f){var d=a.map(e,(function(e){return function(e,t){var n=new x;e.accept(n);var r=n.allProductions,o=a.groupBy(r,v),i=a.pick(o,(function(e){return e.length>1}));return a.map(a.values(i),(function(n){var r=a.first(n),o=t.buildDuplicateFoundError(e,n),i=l.getProductionDslName(r),c={message:o,type:s.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,ruleName:e.name,dslName:i,occurrence:r.idx},f=m(r);return f&&(c.parameter=f),c}))}(e,o)})),p=a.map(e,(function(e){return b(e,e,o)})),h=[],_=[],T=[];i.every(p,i.isEmpty)&&(h=i.map(e,(function(e){return A(e,o)})),_=i.map(e,(function(e){return S(e,t,r,o)})),T=C(e,t,o));var R=function(e,t,n){var r=[],o=i.map(t,(function(e){return c.tokenName(e)}));return i.forEach(e,(function(e){var t=e.name;if(i.contains(o,t)){var a=n.buildNamespaceConflictError(e);r.push({message:a,type:s.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,ruleName:t})}})),r}(e,n,o),L=a.map(n,(function(e){return E(e,o)})),P=function(e,t){var n=[];return i.forEach(e,(function(e){var r=new u.NamedDSLMethodsCollectorVisitor("");e.accept(r);var o=i.map(r.result,(function(e){return e.orgProd}));n.push(i.map(o,(function(n){return y(e,n,t)})))})),i.flatten(n)}(e,o),k=function(e,t){var n=[];return i.forEach(e,(function(e){var r=new u.NamedDSLMethodsCollectorVisitor("");e.accept(r);var o=i.groupBy(r.result,(function(e){return e.name})),a=i.pick(o,(function(e){return e.length>1}));i.forEach(i.values(a),(function(r){var o=i.map(r,(function(e){return e.orgProd})),a=t.buildDuplicateNestedRuleNameError(e,o);n.push({message:a,type:s.ParserDefinitionErrorType.DUPLICATE_NESTED_NAME,ruleName:e.name})}))})),n}(e,o),N=i.map(e,(function(e){return M(e,o)})),H=i.map(e,(function(e){return g(e,o)})),z=i.map(e,(function(t){return w(t,e,f,o)}));return a.flatten(d.concat(L,P,k,T,p,h,_,R,N,H,z))},t.identifyProductionForDuplicates=v;var x=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.allProductions=[],t}return o(t,e),t.prototype.visitNonTerminal=function(e){this.allProductions.push(e)},t.prototype.visitOption=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetition=function(e){this.allProductions.push(e)},t.prototype.visitAlternation=function(e){this.allProductions.push(e)},t.prototype.visitTerminal=function(e){this.allProductions.push(e)},t}(h.GAstVisitor);function g(e,n){var r=[],o=e.name;return o.match(t.validTermsPattern)||r.push({message:n.buildInvalidRuleNameError({topLevelRule:e,expectedPattern:t.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_RULE_NAME,ruleName:o}),r}function y(e,n,r){var o,a=[];return n.name.match(t.validNestedRuleName)||(o=r.buildInvalidNestedRuleNameError(e,n),a.push({message:o,type:s.ParserDefinitionErrorType.INVALID_NESTED_RULE_NAME,ruleName:e.name})),a}function E(e,n){var r=[];return c.tokenName(e).match(t.validTermsPattern)||r.push({message:n.buildTokenNameError({tokenType:e,expectedPattern:t.validTermsPattern}),type:s.ParserDefinitionErrorType.INVALID_TOKEN_NAME}),r}function w(e,t,n,r){var o=[];if(i.reduce(t,(function(t,n){return n.name===e.name?t+1:t}),0)>1){var a=r.buildDuplicateRuleNameError({topLevelRule:e,grammarName:n});o.push({message:a,type:s.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:e.name})}return o}function b(e,t,n,r){void 0===r&&(r=[]);var o=[],i=_(t.definition);if(a.isEmpty(i))return[];var l=e.name;a.contains(i,e)&&o.push({message:n.buildLeftRecursionError({topLevelRule:e,leftRecursionPath:r}),type:s.ParserDefinitionErrorType.LEFT_RECURSION,ruleName:l});var c=a.difference(i,r.concat([e])),f=a.map(c,(function(t){var o=a.cloneArr(r);return o.push(t),b(e,t,n,o)}));return o.concat(a.flatten(f))}function _(e){var t=[];if(a.isEmpty(e))return t;var n=a.first(e);if(n instanceof p.NonTerminal)t.push(n.referencedRule);else if(n instanceof p.Flat||n instanceof p.Option||n instanceof p.RepetitionMandatory||n instanceof p.RepetitionMandatoryWithSeparator||n instanceof p.RepetitionWithSeparator||n instanceof p.Repetition)t=t.concat(_(n.definition));else if(n instanceof p.Alternation)t=a.flatten(a.map(n.definition,(function(e){return _(e.definition)})));else if(!(n instanceof p.Terminal))throw Error("non exhaustive match");var r=l.isOptionalProd(n),o=e.length>1;if(r&&o){var i=a.drop(e);return t.concat(_(i))}return t}t.OccurrenceValidationCollector=x,t.validTermsPattern=/^[a-zA-Z_]\w*$/,t.validNestedRuleName=new RegExp(t.validTermsPattern.source.replace("^","^\\$")),t.validateRuleName=g,t.validateNestedRuleName=y,t.validateTokenName=E,t.validateRuleDoesNotAlreadyExist=w,t.validateRuleIsOverridden=function(e,t,n){var r,o=[];return a.contains(t,e)||(r="Invalid rule override, rule: ->"+e+"<- cannot be overridden in the grammar: ->"+n+"<-as it is not defined in any of the super grammars ",o.push({message:r,type:s.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,ruleName:e})),o},t.validateNoLeftRecursion=b,t.getFirstNoneTerminal=_;var T=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.alternations=[],t}return o(t,e),t.prototype.visitAlternation=function(e){this.alternations.push(e)},t}(h.GAstVisitor);function A(e,t){var n=new T;e.accept(n);var r=n.alternations;return a.reduce(r,(function(n,r){var o=a.dropRight(r.definition),i=a.map(o,(function(n,o){var i=d.nextPossibleTokensAfter([n],[],null,1);return a.isEmpty(i)?{message:t.buildEmptyAlternationError({topLevelRule:e,alternation:r,emptyChoiceIdx:o}),type:s.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,ruleName:e.name,occurrence:r.idx,alternative:o+1}:null}));return n.concat(a.compact(i))}),[])}function S(e,t,n,r){var o=new T;e.accept(o);var c=o.alternations,u=n[e.name];return u&&(c=i.reject(c,(function(e){return u[l.getProductionDslName(e)+(0===e.idx?"":e.idx)]}))),a.reduce(c,(function(n,o){var l=o.idx,c=f.getLookaheadPathsForOr(l,e,t),u=function(e,t,n,r){var o=[],l=i.reduce(e,(function(t,n,r){return i.forEach(n,(function(n){var a=[r];i.forEach(e,(function(e,t){r!==t&&f.containsPath(e,n)&&a.push(t)})),a.length>1&&!f.containsPath(o,n)&&(o.push(n),t.push({alts:a,path:n}))})),t}),[]);return a.map(l,(function(e){var o=i.map(e.alts,(function(e){return e+1}));return{message:r.buildAlternationAmbiguityError({topLevelRule:n,alternation:t,ambiguityIndices:o,prefixPath:e.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_ALTS,ruleName:n.name,occurrence:t.idx,alternatives:[e.alts]}}))}(c,o,e,r),d=L(c,o,e,r);return n.concat(u,d)}),[])}t.validateEmptyOrAlternative=A,t.validateAmbiguousAlternationAlternatives=S;var R=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.allProductions=[],t}return o(t,e),t.prototype.visitRepetitionWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatory=function(e){this.allProductions.push(e)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.allProductions.push(e)},t.prototype.visitRepetition=function(e){this.allProductions.push(e)},t}(h.GAstVisitor);function M(e,t){var n=new T;e.accept(n);var r=n.alternations;return a.reduce(r,(function(n,r){return r.definition.length>255&&n.push({message:t.buildTooManyAlternativesError({topLevelRule:e,alternation:r}),type:s.ParserDefinitionErrorType.TOO_MANY_ALTS,ruleName:e.name,occurrence:r.idx}),n}),[])}function C(e,t,n){var r=[];return i.forEach(e,(function(e){var o=new R;e.accept(o);var a=o.allProductions;i.forEach(a,(function(o){var a=f.getProdType(o),l=o.idx,c=f.getLookaheadPathsForOptionalProd(l,e,a,t)[0];if(i.isEmpty(i.flatten(c))){var u=n.buildEmptyRepetitionError({topLevelRule:e,repetition:o});r.push({message:u,type:s.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,ruleName:e.name})}}))})),r}function L(e,t,n,r){var o=[],a=i.reduce(e,(function(e,t,n){var r=i.map(t,(function(e){return{idx:n,path:e}}));return e.concat(r)}),[]);return i.forEach(a,(function(e){var l=e.idx,c=e.path,u=i.findAll(a,(function(e){return e.idx<l&&f.isStrictPrefixOfPath(e.path,c)})),d=i.map(u,(function(e){var o=[e.idx+1,l+1],a=0===t.idx?"":t.idx;return{message:r.buildAlternationPrefixAmbiguityError({topLevelRule:n,alternation:t,ambiguityIndices:o,prefixPath:e.path}),type:s.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,ruleName:n.name,occurrence:a,alternatives:o}}));o=o.concat(d)})),o}t.RepetionCollector=R,t.validateTooManyAlts=M,t.validateSomeNonEmptyLookaheadPath=C,t.checkPrefixAlternativesAmbiguities=L},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a,i=n(0),s=n(13),l=n(14),c=n(7),f=n(1),u=n(5);!function(e){e[e.OPTION=0]="OPTION",e[e.REPETITION=1]="REPETITION",e[e.REPETITION_MANDATORY=2]="REPETITION_MANDATORY",e[e.REPETITION_MANDATORY_WITH_SEPARATOR=3]="REPETITION_MANDATORY_WITH_SEPARATOR",e[e.REPETITION_WITH_SEPARATOR=4]="REPETITION_WITH_SEPARATOR",e[e.ALTERNATION=5]="ALTERNATION"}(a=t.PROD_TYPE||(t.PROD_TYPE={})),t.getProdType=function(e){if(e instanceof f.Option)return a.OPTION;if(e instanceof f.Repetition)return a.REPETITION;if(e instanceof f.RepetitionMandatory)return a.REPETITION_MANDATORY;if(e instanceof f.RepetitionMandatoryWithSeparator)return a.REPETITION_MANDATORY_WITH_SEPARATOR;if(e instanceof f.RepetitionWithSeparator)return a.REPETITION_WITH_SEPARATOR;if(e instanceof f.Alternation)return a.ALTERNATION;throw Error("non exhaustive match")},t.buildLookaheadFuncForOr=function(e,t,n,r,o,a){var i=v(e,t,n);return a(i,r,g(i)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher,o)},t.buildLookaheadFuncForOptionalProd=function(e,t,n,r,o,a){var i=m(e,t,o,n),s=g(i)?c.tokenStructuredMatcherNoCategories:c.tokenStructuredMatcher;return a(i[0],s,r)},t.buildAlternativesLookAheadFunc=function(e,t,n,r){var o=e.length,a=i.every(e,(function(e){return i.every(e,(function(e){return 1===e.length}))}));if(t)return function(t){for(var r=i.map(t,(function(e){return e.GATE})),a=0;a<o;a++){var s=e[a],l=s.length,c=r[a];if(void 0===c||!1!==c.call(this))e:for(var f=0;f<l;f++){for(var u=s[f],d=u.length,p=0;p<d;p++){var h=this.LA(p+1);if(!1===n(h,u[p]))continue e}return a}}};if(a&&!r){var s=i.map(e,(function(e){return i.flatten(e)})),l=i.reduce(s,(function(e,t,n){return i.forEach(t,(function(t){i.has(e,t.tokenTypeIdx)||(e[t.tokenTypeIdx]=n),i.forEach(t.categoryMatches,(function(t){i.has(e,t)||(e[t]=n)}))})),e}),[]);return function(){var e=this.LA(1);return l[e.tokenTypeIdx]}}return function(){for(var t=0;t<o;t++){var r=e[t],a=r.length;e:for(var i=0;i<a;i++){for(var s=r[i],l=s.length,c=0;c<l;c++){var f=this.LA(c+1);if(!1===n(f,s[c]))continue e}return t}}}},t.buildSingleAlternativeLookaheadFunction=function(e,t,n){var r=i.every(e,(function(e){return 1===e.length})),o=e.length;if(r&&!n){var a=i.flatten(e);if(1===a.length&&i.isEmpty(a[0].categoryMatches)){var s=a[0].tokenTypeIdx;return function(){return this.LA(1).tokenTypeIdx===s}}var l=i.reduce(a,(function(e,t,n){return e[t.tokenTypeIdx]=!0,i.forEach(t.categoryMatches,(function(t){e[t]=!0})),e}),[]);return function(){var e=this.LA(1);return!0===l[e.tokenTypeIdx]}}return function(){e:for(var n=0;n<o;n++){for(var r=e[n],a=r.length,i=0;i<a;i++){var s=this.LA(i+1);if(!1===t(s,r[i]))continue e}return!0}return!1}};var d=function(e){function t(t,n,r){var o=e.call(this)||this;return o.topProd=t,o.targetOccurrence=n,o.targetProdType=r,o}return o(t,e),t.prototype.startWalking=function(){return this.walk(this.topProd),this.restDef},t.prototype.checkIsTarget=function(e,t,n,r){return e.idx===this.targetOccurrence&&this.targetProdType===t&&(this.restDef=n.concat(r),!0)},t.prototype.walkOption=function(t,n,r){this.checkIsTarget(t,a.OPTION,n,r)||e.prototype.walkOption.call(this,t,n,r)},t.prototype.walkAtLeastOne=function(t,n,r){this.checkIsTarget(t,a.REPETITION_MANDATORY,n,r)||e.prototype.walkOption.call(this,t,n,r)},t.prototype.walkAtLeastOneSep=function(t,n,r){this.checkIsTarget(t,a.REPETITION_MANDATORY_WITH_SEPARATOR,n,r)||e.prototype.walkOption.call(this,t,n,r)},t.prototype.walkMany=function(t,n,r){this.checkIsTarget(t,a.REPETITION,n,r)||e.prototype.walkOption.call(this,t,n,r)},t.prototype.walkManySep=function(t,n,r){this.checkIsTarget(t,a.REPETITION_WITH_SEPARATOR,n,r)||e.prototype.walkOption.call(this,t,n,r)},t}(l.RestWalker),p=function(e){function t(t,n){var r=e.call(this)||this;return r.targetOccurrence=t,r.targetProdType=n,r.result=[],r}return o(t,e),t.prototype.checkIsTarget=function(e,t){e.idx===this.targetOccurrence&&this.targetProdType===t&&(this.result=e.definition)},t.prototype.visitOption=function(e){this.checkIsTarget(e,a.OPTION)},t.prototype.visitRepetition=function(e){this.checkIsTarget(e,a.REPETITION)},t.prototype.visitRepetitionMandatory=function(e){this.checkIsTarget(e,a.REPETITION_MANDATORY)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.checkIsTarget(e,a.REPETITION_MANDATORY_WITH_SEPARATOR)},t.prototype.visitRepetitionWithSeparator=function(e){this.checkIsTarget(e,a.REPETITION_WITH_SEPARATOR)},t.prototype.visitAlternation=function(e){this.checkIsTarget(e,a.ALTERNATION)},t}(u.GAstVisitor);function h(e,t){function n(e,t){return i.reduce(e,(function(e,n,r){if(r!==t){var o=i.map(n,(function(e){return e.partialPath}));return e.concat(o)}return e}),[])}function r(e,t){return void 0===i.find(e,(function(e){return i.every(t,(function(t,n){return(r=t)===(o=e[n])||r&&o&&(r.categoryMatchesMap[o.tokenTypeIdx]||o.categoryMatchesMap[r.tokenTypeIdx]);var r,o}))}))}function o(e){for(var t=[],n=0;n<e;n++)t.push([]);return t}for(var a=i.map(e,(function(e){return s.possiblePathsFrom([e],1)})),l=o(a.length),c=a,f=1;f<=t;f++){var u=c;c=o(u.length);for(var d=0;d<u.length;d++)for(var p=u[d],h=n(u,d),v=0;v<p.length;v++){var m=p[v].partialPath,g=p[v].suffixDef;if(r(h,m)||i.isEmpty(g)||m.length===t){var y=l[d];x(y,m)||y.push(m)}else{var E=s.possiblePathsFrom(g,f+1,m);c[d]=c[d].concat(E)}}}return l}function v(e,t,n){var r=new p(e,a.ALTERNATION);return t.accept(r),h(r.result,n)}function m(e,t,n,r){var o=new p(e,n);t.accept(o);var a=o.result,i=new d(t,e,n).startWalking();return h([new f.Flat({definition:a}),new f.Flat({definition:i})],r)}function x(e,t){return void 0!==i.find(e,(function(e){return t.length===e.length&&i.every(t,(function(t,n){return t===e[n]||e[n].categoryMatchesMap[t.tokenTypeIdx]}))}))}function g(e){return i.every(e,(function(e){return i.every(e,(function(e){return i.every(e,(function(e){return i.isEmpty(e.categoryMatches)}))}))}))}t.lookAheadSequenceFromAlternatives=h,t.getLookaheadPathsForOr=v,t.getLookaheadPathsForOptionalProd=m,t.containsPath=x,t.isStrictPrefixOfPath=function(e,t){return e.length<t.length&&i.every(e,(function(e,n){var r=t[n];return e===r||r.categoryMatchesMap[e.tokenTypeIdx]}))},t.areTokenCategoriesNotUsed=g},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(14),i=n(0),s=n(2),l=n(21),c=n(1),f=function(e){function t(t,n){var r=e.call(this)||this;return r.topProd=t,r.path=n,r.possibleTokTypes=[],r.nextProductionName="",r.nextProductionOccurrence=0,r.found=!1,r.isAtEndOfPath=!1,r}return o(t,e),t.prototype.startWalking=function(){if(this.found=!1,this.path.ruleStack[0]!==this.topProd.name)throw Error("The path does not start with the walker's top Rule!");return this.ruleStack=i.cloneArr(this.path.ruleStack).reverse(),this.occurrenceStack=i.cloneArr(this.path.occurrenceStack).reverse(),this.ruleStack.pop(),this.occurrenceStack.pop(),this.updateExpectedNext(),this.walk(this.topProd),this.possibleTokTypes},t.prototype.walk=function(t,n){void 0===n&&(n=[]),this.found||e.prototype.walk.call(this,t,n)},t.prototype.walkProdRef=function(e,t,n){if(e.referencedRule.name===this.nextProductionName&&e.idx===this.nextProductionOccurrence){var r=t.concat(n);this.updateExpectedNext(),this.walk(e.referencedRule,r)}},t.prototype.updateExpectedNext=function(){i.isEmpty(this.ruleStack)?(this.nextProductionName="",this.nextProductionOccurrence=0,this.isAtEndOfPath=!0):(this.nextProductionName=this.ruleStack.pop(),this.nextProductionOccurrence=this.occurrenceStack.pop())},t}(a.RestWalker);t.AbstractNextPossibleTokensWalker=f;var u=function(e){function t(t,n){var r=e.call(this,t,n)||this;return r.path=n,r.nextTerminalName="",r.nextTerminalOccurrence=0,r.nextTerminalName=s.tokenName(r.path.lastTok),r.nextTerminalOccurrence=r.path.lastTokOccurrence,r}return o(t,e),t.prototype.walkTerminal=function(e,t,n){if(this.isAtEndOfPath&&s.tokenName(e.terminalType)===this.nextTerminalName&&e.idx===this.nextTerminalOccurrence&&!this.found){var r=t.concat(n),o=new c.Flat({definition:r});this.possibleTokTypes=l.first(o),this.found=!0}},t}(f);t.NextAfterTokenWalker=u;var d=function(e){function t(t,n){var r=e.call(this)||this;return r.topRule=t,r.occurrence=n,r.result={token:void 0,occurrence:void 0,isEndOfRule:void 0},r}return o(t,e),t.prototype.startWalking=function(){return this.walk(this.topRule),this.result},t}(a.RestWalker);t.AbstractNextTerminalAfterProductionWalker=d;var p=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.walkMany=function(t,n,r){if(t.idx===this.occurrence){var o=i.first(n.concat(r));this.result.isEndOfRule=void 0===o,o instanceof c.Terminal&&(this.result.token=o.terminalType,this.result.occurrence=o.idx)}else e.prototype.walkMany.call(this,t,n,r)},t}(d);t.NextTerminalAfterManyWalker=p;var h=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.walkManySep=function(t,n,r){if(t.idx===this.occurrence){var o=i.first(n.concat(r));this.result.isEndOfRule=void 0===o,o instanceof c.Terminal&&(this.result.token=o.terminalType,this.result.occurrence=o.idx)}else e.prototype.walkManySep.call(this,t,n,r)},t}(d);t.NextTerminalAfterManySepWalker=h;var v=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.walkAtLeastOne=function(t,n,r){if(t.idx===this.occurrence){var o=i.first(n.concat(r));this.result.isEndOfRule=void 0===o,o instanceof c.Terminal&&(this.result.token=o.terminalType,this.result.occurrence=o.idx)}else e.prototype.walkAtLeastOne.call(this,t,n,r)},t}(d);t.NextTerminalAfterAtLeastOneWalker=v;var m=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return o(t,e),t.prototype.walkAtLeastOneSep=function(t,n,r){if(t.idx===this.occurrence){var o=i.first(n.concat(r));this.result.isEndOfRule=void 0===o,o instanceof c.Terminal&&(this.result.token=o.terminalType,this.result.occurrence=o.idx)}else e.prototype.walkAtLeastOneSep.call(this,t,n,r)},t}(d);function x(e,t,n,r){var o=i.cloneArr(n);o.push(e.name);var a=i.cloneArr(r);return a.push(1),{idx:t,def:e.definition,ruleStack:o,occurrenceStack:a}}t.NextTerminalAfterAtLeastOneSepWalker=m,t.possiblePathsFrom=function e(t,n,r){void 0===r&&(r=[]),r=i.cloneArr(r);var o=[],a=0;function s(s){var l=e(s.concat(i.drop(t,a+1)),n,r);return o.concat(l)}for(;r.length<n&&a<t.length;){var l=t[a];if(l instanceof c.Flat)return s(l.definition);if(l instanceof c.NonTerminal)return s(l.definition);if(l instanceof c.Option)o=s(l.definition);else{if(l instanceof c.RepetitionMandatory)return s(f=l.definition.concat([new c.Repetition({definition:l.definition})]));if(l instanceof c.RepetitionMandatoryWithSeparator)return s(f=[new c.Flat({definition:l.definition}),new c.Repetition({definition:[new c.Terminal({terminalType:l.separator})].concat(l.definition)})]);if(l instanceof c.RepetitionWithSeparator){var f=l.definition.concat([new c.Repetition({definition:[new c.Terminal({terminalType:l.separator})].concat(l.definition)})]);o=s(f)}else if(l instanceof c.Repetition)f=l.definition.concat([new c.Repetition({definition:l.definition})]),o=s(f);else{if(l instanceof c.Alternation)return i.forEach(l.definition,(function(e){o=s(e.definition)})),o;if(!(l instanceof c.Terminal))throw Error("non exhaustive match");r.push(l.terminalType)}}a++}return o.push({partialPath:r,suffixDef:i.drop(t,a)}),o},t.nextPossibleTokensAfter=function(e,t,n,r){var o=["EXIT_NONE_TERMINAL"],a=!1,s=t.length,l=s-r-1,f=[],u=[];for(u.push({idx:-1,def:e,ruleStack:[],occurrenceStack:[]});!i.isEmpty(u);){var d=u.pop();if("EXIT_ALTERNATIVE"!==d){var p=d.def,h=d.idx,v=d.ruleStack,m=d.occurrenceStack;if(!i.isEmpty(p)){var g=p[0];if("EXIT_NONE_TERMINAL"===g){var y={idx:h,def:i.drop(p),ruleStack:i.dropRight(v),occurrenceStack:i.dropRight(m)};u.push(y)}else if(g instanceof c.Terminal)if(h<s-1){var E=h+1;n(t[E],g.terminalType)&&(y={idx:E,def:i.drop(p),ruleStack:v,occurrenceStack:m},u.push(y))}else{if(h!==s-1)throw Error("non exhaustive match");f.push({nextTokenType:g.terminalType,nextTokenOccurrence:g.idx,ruleStack:v,occurrenceStack:m}),a=!0}else if(g instanceof c.NonTerminal){var w=i.cloneArr(v);w.push(g.nonTerminalName);var b=i.cloneArr(m);b.push(g.idx),y={idx:h,def:g.definition.concat(o,i.drop(p)),ruleStack:w,occurrenceStack:b},u.push(y)}else if(g instanceof c.Option){var _={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m};u.push(_),u.push("EXIT_ALTERNATIVE");var T={idx:h,def:g.definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m};u.push(T)}else if(g instanceof c.RepetitionMandatory){var A=new c.Repetition({definition:g.definition,idx:g.idx});y={idx:h,def:g.definition.concat([A],i.drop(p)),ruleStack:v,occurrenceStack:m},u.push(y)}else if(g instanceof c.RepetitionMandatoryWithSeparator){var S=new c.Terminal({terminalType:g.separator});A=new c.Repetition({definition:[S].concat(g.definition),idx:g.idx}),y={idx:h,def:g.definition.concat([A],i.drop(p)),ruleStack:v,occurrenceStack:m},u.push(y)}else if(g instanceof c.RepetitionWithSeparator){_={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m},u.push(_),u.push("EXIT_ALTERNATIVE"),S=new c.Terminal({terminalType:g.separator});var R=new c.Repetition({definition:[S].concat(g.definition),idx:g.idx});T={idx:h,def:g.definition.concat([R],i.drop(p)),ruleStack:v,occurrenceStack:m},u.push(T)}else if(g instanceof c.Repetition)_={idx:h,def:i.drop(p),ruleStack:v,occurrenceStack:m},u.push(_),u.push("EXIT_ALTERNATIVE"),R=new c.Repetition({definition:g.definition,idx:g.idx}),T={idx:h,def:g.definition.concat([R],i.drop(p)),ruleStack:v,occurrenceStack:m},u.push(T);else if(g instanceof c.Alternation)for(var M=g.definition.length-1;M>=0;M--){var C={idx:h,def:g.definition[M].definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m};u.push(C),u.push("EXIT_ALTERNATIVE")}else if(g instanceof c.Flat)u.push({idx:h,def:g.definition.concat(i.drop(p)),ruleStack:v,occurrenceStack:m});else{if(!(g instanceof c.Rule))throw Error("non exhaustive match");u.push(x(g,h,v,m))}}}else a&&i.last(u).idx<=l&&u.pop()}return f}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(1),a=function(){function e(){}return e.prototype.walk=function(e,t){var n=this;void 0===t&&(t=[]),r.forEach(e.definition,(function(a,i){var s=r.drop(e.definition,i+1);if(a instanceof o.NonTerminal)n.walkProdRef(a,s,t);else if(a instanceof o.Terminal)n.walkTerminal(a,s,t);else if(a instanceof o.Flat)n.walkFlat(a,s,t);else if(a instanceof o.Option)n.walkOption(a,s,t);else if(a instanceof o.RepetitionMandatory)n.walkAtLeastOne(a,s,t);else if(a instanceof o.RepetitionMandatoryWithSeparator)n.walkAtLeastOneSep(a,s,t);else if(a instanceof o.RepetitionWithSeparator)n.walkManySep(a,s,t);else if(a instanceof o.Repetition)n.walkMany(a,s,t);else{if(!(a instanceof o.Alternation))throw Error("non exhaustive match");n.walkOr(a,s,t)}}))},e.prototype.walkTerminal=function(e,t,n){},e.prototype.walkProdRef=function(e,t,n){},e.prototype.walkFlat=function(e,t,n){var r=t.concat(n);this.walk(e,r)},e.prototype.walkOption=function(e,t,n){var r=t.concat(n);this.walk(e,r)},e.prototype.walkAtLeastOne=function(e,t,n){var r=[new o.Option({definition:e.definition})].concat(t,n);this.walk(e,r)},e.prototype.walkAtLeastOneSep=function(e,t,n){var r=i(e,t,n);this.walk(e,r)},e.prototype.walkMany=function(e,t,n){var r=[new o.Option({definition:e.definition})].concat(t,n);this.walk(e,r)},e.prototype.walkManySep=function(e,t,n){var r=i(e,t,n);this.walk(e,r)},e.prototype.walkOr=function(e,t,n){var a=this,i=t.concat(n);r.forEach(e.definition,(function(e){var t=new o.Flat({definition:[e]});a.walk(t,i)}))},e}();function i(e,t,n){return[new o.Option({definition:[new o.Terminal({terminalType:e.separator})].concat(e.definition)})].concat(t,n)}t.RestWalker=a},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(27),o=n(0),a=n(7),i=n(20);!function(e){e[e.MISSING_PATTERN=0]="MISSING_PATTERN",e[e.INVALID_PATTERN=1]="INVALID_PATTERN",e[e.EOI_ANCHOR_FOUND=2]="EOI_ANCHOR_FOUND",e[e.UNSUPPORTED_FLAGS_FOUND=3]="UNSUPPORTED_FLAGS_FOUND",e[e.DUPLICATE_PATTERNS_FOUND=4]="DUPLICATE_PATTERNS_FOUND",e[e.INVALID_GROUP_TYPE_FOUND=5]="INVALID_GROUP_TYPE_FOUND",e[e.PUSH_MODE_DOES_NOT_EXIST=6]="PUSH_MODE_DOES_NOT_EXIST",e[e.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE=7]="MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE",e[e.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY=8]="MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY",e[e.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST=9]="MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST",e[e.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED=10]="LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED",e[e.SOI_ANCHOR_FOUND=11]="SOI_ANCHOR_FOUND",e[e.EMPTY_MATCH_PATTERN=12]="EMPTY_MATCH_PATTERN",e[e.NO_LINE_BREAKS_FLAGS=13]="NO_LINE_BREAKS_FLAGS",e[e.UNREACHABLE_PATTERN=14]="UNREACHABLE_PATTERN",e[e.IDENTIFY_TERMINATOR=15]="IDENTIFY_TERMINATOR",e[e.CUSTOM_LINE_BREAK=16]="CUSTOM_LINE_BREAK"}(t.LexerDefinitionErrorType||(t.LexerDefinitionErrorType={}));var s={deferDefinitionErrorsHandling:!1,positionTracking:"full",lineTerminatorsPattern:/\n|\r\n?/g,lineTerminatorCharacters:["\n","\r"],ensureOptimizations:!1,safeMode:!1,errorMessageProvider:i.defaultLexerErrorProvider};Object.freeze(s);var l=function(){function e(e,t){var n=this;if(void 0===t&&(t=s),this.lexerDefinition=e,this.lexerDefinitionErrors=[],this.lexerDefinitionWarning=[],this.patternIdxToConfig={},this.charCodeToPatternIdxToConfig={},this.modes=[],this.emptyGroups={},this.config=void 0,this.trackStartLines=!0,this.trackEndLines=!0,this.hasCustom=!1,this.canModeBeOptimized={},"boolean"==typeof t)throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");if(this.config=o.merge(s,t),this.config.lineTerminatorsPattern===s.lineTerminatorsPattern)this.config.lineTerminatorsPattern=r.LineTerminatorOptimizedTester;else if(this.config.lineTerminatorCharacters===s.lineTerminatorCharacters)throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");if(t.safeMode&&t.ensureOptimizations)throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');this.trackStartLines=/full|onlyStart/i.test(this.config.positionTracking),this.trackEndLines=/full/i.test(this.config.positionTracking);var i,l=!0;o.isArray(e)?((i={modes:{}}).modes[r.DEFAULT_MODE]=o.cloneArr(e),i[r.DEFAULT_MODE]=r.DEFAULT_MODE):(l=!1,i=o.cloneObj(e)),this.lexerDefinitionErrors=this.lexerDefinitionErrors.concat(r.performRuntimeChecks(i,this.trackStartLines,this.config.lineTerminatorCharacters)),this.lexerDefinitionWarning=this.lexerDefinitionWarning.concat(r.performWarningRuntimeChecks(i,this.trackStartLines,this.config.lineTerminatorCharacters)),i.modes=i.modes?i.modes:{},o.forEach(i.modes,(function(e,t){i.modes[t]=o.reject(e,(function(e){return o.isUndefined(e)}))}));var c=o.keys(i.modes);if(o.forEach(i.modes,(function(e,i){if(n.modes.push(i),n.lexerDefinitionErrors=n.lexerDefinitionErrors.concat(r.validatePatterns(e,c)),o.isEmpty(n.lexerDefinitionErrors)){a.augmentTokenTypes(e);var s=r.analyzeTokenTypes(e,{lineTerminatorCharacters:n.config.lineTerminatorCharacters,positionTracking:t.positionTracking,ensureOptimizations:t.ensureOptimizations,safeMode:t.safeMode});n.patternIdxToConfig[i]=s.patternIdxToConfig,n.charCodeToPatternIdxToConfig[i]=s.charCodeToPatternIdxToConfig,n.emptyGroups=o.merge(n.emptyGroups,s.emptyGroups),n.hasCustom=s.hasCustom||n.hasCustom,n.canModeBeOptimized[i]=s.canBeOptimized}})),this.defaultMode=i.defaultMode,!o.isEmpty(this.lexerDefinitionErrors)&&!this.config.deferDefinitionErrorsHandling){var f=o.map(this.lexerDefinitionErrors,(function(e){return e.message})).join("-----------------------\n");throw new Error("Errors detected in definition of Lexer:\n"+f)}if(o.forEach(this.lexerDefinitionWarning,(function(e){o.PRINT_WARNING(e.message)})),r.SUPPORT_STICKY?(this.chopInput=o.IDENTITY,this.match=this.matchWithTest):(this.updateLastIndex=o.NOOP,this.match=this.matchWithExec),l&&(this.handleModes=o.NOOP),!1===this.trackStartLines&&(this.computeNewColumn=o.IDENTITY),!1===this.trackEndLines&&(this.updateTokenEndLineColumnLocation=o.NOOP),/full/i.test(this.config.positionTracking))this.createTokenInstance=this.createFullToken;else if(/onlyStart/i.test(this.config.positionTracking))this.createTokenInstance=this.createStartOnlyToken;else{if(!/onlyOffset/i.test(this.config.positionTracking))throw Error('Invalid <positionTracking> config option: "'+this.config.positionTracking+'"');this.createTokenInstance=this.createOffsetOnlyToken}this.hasCustom?this.addToken=this.addTokenUsingPush:this.addToken=this.addTokenUsingMemberAccess;var u=o.reduce(this.canModeBeOptimized,(function(e,t,n){return!1===t&&e.push(n),e}),[]);if(t.ensureOptimizations&&!o.isEmpty(u))throw Error("Lexer Modes: < "+u.join(", ")+' > cannot be optimized.\n\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n\t Or inspect the console log for details on how to resolve these issues.')}return e.prototype.tokenize=function(e,t){if(void 0===t&&(t=this.defaultMode),!o.isEmpty(this.lexerDefinitionErrors)){var n=o.map(this.lexerDefinitionErrors,(function(e){return e.message})).join("-----------------------\n");throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n"+n)}return this.tokenizeInternal(e,t)},e.prototype.tokenizeInternal=function(e,t){var n,a,i,s,l,c,f,u,d,p,h,v,m=this,x=e,g=x.length,y=0,E=0,w=this.hasCustom?0:Math.floor(e.length/10),b=new Array(w),_=[],T=this.trackStartLines?1:void 0,A=this.trackStartLines?1:void 0,S=r.cloneEmptyGroups(this.emptyGroups),R=this.trackStartLines,M=this.config.lineTerminatorsPattern,C=0,L=[],P=[],k=[],N=[];Object.freeze(N);var H,z=void 0,D=function(e){if(1===k.length&&void 0===e.tokenType.PUSH_MODE){var t=m.config.errorMessageProvider.buildUnableToPopLexerModeMessage(e);_.push({offset:e.startOffset,line:void 0!==e.startLine?e.startLine:void 0,column:void 0!==e.startColumn?e.startColumn:void 0,length:e.image.length,message:t})}else{k.pop();var n=o.last(k);L=m.patternIdxToConfig[n],P=m.charCodeToPatternIdxToConfig[n],C=L.length;var r=m.canModeBeOptimized[n]&&!1===m.config.safeMode;z=P&&r?function(e){var t=P[e];return void 0===t?N:t}:function(){return L}}};function F(e){k.push(e),P=this.charCodeToPatternIdxToConfig[e],L=this.patternIdxToConfig[e],C=L.length,C=L.length;var t=this.canModeBeOptimized[e]&&!1===this.config.safeMode;z=P&&t?function(e){var t=P[e];return void 0===t?N:t}:function(){return L}}for(F.call(this,t);y<g;){l=null;var I=x.charCodeAt(y),O=z(I),U=O.length;for(n=0;n<U;n++){var G=(H=O[n]).pattern;if(!1!==(Z=H.short)?I===Z&&(l=G):!0===H.isCustom?l=null!==(v=G.exec(x,y,b,S))?v[0]:v:(this.updateLastIndex(G,y),l=this.match(G,e,y)),null!==l){if(void 0!==(s=H.longerAlt)){var B=L[s],V=B.pattern;!0===B.isCustom?i=null!==(v=V.exec(x,y,b,S))?v[0]:v:(this.updateLastIndex(V,y),i=this.match(V,e,y)),i&&i.length>l.length&&(l=i,H=B)}break}}if(null!==l){if(c=l.length,void 0!==(f=H.group)&&(u=H.tokenTypeIdx,d=this.createTokenInstance(l,y,u,H.tokenType,T,A,c),!1===f?E=this.addToken(b,E,d):S[f].push(d)),e=this.chopInput(e,c),y+=c,A=this.computeNewColumn(A,c),!0===R&&!0===H.canLineTerminator){var W=0,j=void 0,q=void 0;M.lastIndex=0;do{!0===(j=M.test(l))&&(q=M.lastIndex-1,W++)}while(j);0!==W&&(T+=W,A=c-q,this.updateTokenEndLineColumnLocation(d,f,q,W,T,A,c))}this.handleModes(H,D,F,d)}else{for(var X=y,Y=T,Q=A,K=!1;!K&&y<g;)for(x.charCodeAt(y),e=this.chopInput(e,1),y++,a=0;a<C;a++){var Z,J=L[a];if(G=J.pattern,!1!==(Z=J.short)?x.charCodeAt(y)===Z&&(K=!0):!0===J.isCustom?K=null!==G.exec(x,y,b,S):(this.updateLastIndex(G,y),K=null!==G.exec(e)),!0===K)break}p=y-X,h=this.config.errorMessageProvider.buildUnexpectedCharactersMessage(x,X,p,Y,Q),_.push({offset:X,line:Y,column:Q,length:p,message:h})}}return this.hasCustom||(b.length=E),{tokens:b,groups:S,errors:_}},e.prototype.handleModes=function(e,t,n,r){if(!0===e.pop){var o=e.push;t(r),void 0!==o&&n.call(this,o)}else void 0!==e.push&&n.call(this,e.push)},e.prototype.chopInput=function(e,t){return e.substring(t)},e.prototype.updateLastIndex=function(e,t){e.lastIndex=t},e.prototype.updateTokenEndLineColumnLocation=function(e,t,n,r,o,a,i){var s,l;void 0!==t&&(l=(s=n===i-1)?-1:0,1===r&&!0===s||(e.endLine=o+l,e.endColumn=a-1-l))},e.prototype.computeNewColumn=function(e,t){return e+t},e.prototype.createTokenInstance=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return null},e.prototype.createOffsetOnlyToken=function(e,t,n,r){return{image:e,startOffset:t,tokenTypeIdx:n,tokenType:r}},e.prototype.createStartOnlyToken=function(e,t,n,r,o,a){return{image:e,startOffset:t,startLine:o,startColumn:a,tokenTypeIdx:n,tokenType:r}},e.prototype.createFullToken=function(e,t,n,r,o,a,i){return{image:e,startOffset:t,endOffset:t+i-1,startLine:o,endLine:o,startColumn:a,endColumn:a+i-1,tokenTypeIdx:n,tokenType:r}},e.prototype.addToken=function(e,t,n){return 666},e.prototype.addTokenUsingPush=function(e,t,n){return e.push(n),t},e.prototype.addTokenUsingMemberAccess=function(e,t,n){return e[t]=n,++t},e.prototype.match=function(e,t,n){return null},e.prototype.matchWithTest=function(e,t,n){return!0===e.test(t)?t.substring(n,e.lastIndex):null},e.prototype.matchWithExec=function(e,t){var n=e.exec(t);return null!==n?n[0]:n},e.SKIPPED="This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.",e.NA=/NOT_APPLICABLE/,e}();t.Lexer=l},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(0),i=n(4),s=n(9),l=n(1),c=n(5);t.addTerminalToCst=function(e,t,n){void 0===e.children[n]?e.children[n]=[t]:e.children[n].push(t)},t.addNoneTerminalToCst=function(e,t,n){void 0===e.children[t]?e.children[t]=[n]:e.children[t].push(n)};var f=function(e){function t(t){var n=e.call(this)||this;return n.result=[],n.ruleIdx=t,n}return o(t,e),t.prototype.collectNamedDSLMethod=function(e,t,n){if(!a.isUndefined(e.name)){var r=void 0;if(e instanceof l.Option||e instanceof l.Repetition||e instanceof l.RepetitionMandatory||e instanceof l.Alternation)r=new t({definition:e.definition,idx:e.idx});else{if(!(e instanceof l.RepetitionMandatoryWithSeparator||e instanceof l.RepetitionWithSeparator))throw Error("non exhaustive match");r=new t({definition:e.definition,idx:e.idx,separator:e.separator})}var o=[r],i=s.getKeyForAutomaticLookahead(this.ruleIdx,n,e.idx);this.result.push({def:o,key:i,name:e.name,orgProd:e})}},t.prototype.visitOption=function(e){this.collectNamedDSLMethod(e,l.Option,s.OPTION_IDX)},t.prototype.visitRepetition=function(e){this.collectNamedDSLMethod(e,l.Repetition,s.MANY_IDX)},t.prototype.visitRepetitionMandatory=function(e){this.collectNamedDSLMethod(e,l.RepetitionMandatory,s.AT_LEAST_ONE_IDX)},t.prototype.visitRepetitionMandatoryWithSeparator=function(e){this.collectNamedDSLMethod(e,l.RepetitionMandatoryWithSeparator,s.AT_LEAST_ONE_SEP_IDX)},t.prototype.visitRepetitionWithSeparator=function(e){this.collectNamedDSLMethod(e,l.RepetitionWithSeparator,s.MANY_SEP_IDX)},t.prototype.visitAlternation=function(e){var t=this;this.collectNamedDSLMethod(e,l.Alternation,s.OR_IDX);var n=e.definition.length>1;a.forEach(e.definition,(function(r,o){if(!a.isUndefined(r.name)){var i=r.definition;i=n?[new l.Option({definition:r.definition})]:r.definition;var c=s.getKeyForAltIndex(t.ruleIdx,s.OR_IDX,e.idx,o);t.result.push({def:i,key:c,name:r.name,orgProd:r})}}))},t}(c.GAstVisitor);t.NamedDSLMethodsCollectorVisitor=f,t.analyzeCst=function(e,t){var n={dictDef:new i.HashTable,allRuleNames:[]};return a.forEach(e,(function(e){var r=t.get(e.name);n.allRuleNames.push(e.name);var o=new f(r);e.accept(o),a.forEach(o.result,(function(t){t.def,t.key;var r=t.name;n.allRuleNames.push(e.name+r)}))})),n}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VERSION="4.6.0"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(3),o=n(15),a=n(2),i=n(6),s=n(17),l=n(10),c=n(39),f=n(5),u=n(1),d=n(24),p=n(40),h=n(20),v={};v.VERSION=s.VERSION,v.Parser=r.Parser,v.CstParser=r.CstParser,v.EmbeddedActionsParser=r.EmbeddedActionsParser,v.ParserDefinitionErrorType=r.ParserDefinitionErrorType,v.Lexer=o.Lexer,v.LexerDefinitionErrorType=o.LexerDefinitionErrorType,v.EOF=a.EOF,v.tokenName=a.tokenName,v.tokenLabel=a.tokenLabel,v.tokenMatcher=a.tokenMatcher,v.createToken=a.createToken,v.createTokenInstance=a.createTokenInstance,v.EMPTY_ALT=r.EMPTY_ALT,v.defaultParserErrorProvider=l.defaultParserErrorProvider,v.isRecognitionException=i.isRecognitionException,v.EarlyExitException=i.EarlyExitException,v.MismatchedTokenException=i.MismatchedTokenException,v.NotAllInputParsedException=i.NotAllInputParsedException,v.NoViableAltException=i.NoViableAltException,v.defaultLexerErrorProvider=h.defaultLexerErrorProvider,v.Flat=u.Flat,v.Repetition=u.Repetition,v.RepetitionWithSeparator=u.RepetitionWithSeparator,v.RepetitionMandatory=u.RepetitionMandatory,v.RepetitionMandatoryWithSeparator=u.RepetitionMandatoryWithSeparator,v.Option=u.Option,v.Alternation=u.Alternation,v.NonTerminal=u.NonTerminal,v.Terminal=u.Terminal,v.Rule=u.Rule,v.GAstVisitor=f.GAstVisitor,v.serializeGrammar=u.serializeGrammar,v.serializeProduction=u.serializeProduction,v.resolveGrammar=d.resolveGrammar,v.defaultGrammarResolverErrorProvider=l.defaultGrammarResolverErrorProvider,v.validateGrammar=d.validateGrammar,v.defaultGrammarValidatorErrorProvider=l.defaultGrammarValidatorErrorProvider,v.assignOccurrenceIndices=d.assignOccurrenceIndices,v.clearCache=function(){console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n\t It performs no action other than printing this message.\n\t Please avoid using it as it will be completely removed in the future")},v.createSyntaxDiagramsCode=c.createSyntaxDiagramsCode,v.generateParserFactory=p.generateParserFactory,v.generateParserModule=p.generateParserModule,e.exports=v},function(e,t,n){var r,o,a;"undefined"!=typeof self&&self,o=[],void 0===(a="function"==typeof(r=function(){function e(){}e.prototype.saveState=function(){return{idx:this.idx,input:this.input,groupIdx:this.groupIdx}},e.prototype.restoreState=function(e){this.idx=e.idx,this.input=e.input,this.groupIdx=e.groupIdx},e.prototype.pattern=function(e){this.idx=0,this.input=e,this.groupIdx=0,this.consumeChar("/");var t=this.disjunction();this.consumeChar("/");for(var n={type:"Flags",global:!1,ignoreCase:!1,multiLine:!1,unicode:!1,sticky:!1};this.isRegExpFlag();)switch(this.popChar()){case"g":s(n,"global");break;case"i":s(n,"ignoreCase");break;case"m":s(n,"multiLine");break;case"u":s(n,"unicode");break;case"y":s(n,"sticky")}if(this.idx!==this.input.length)throw Error("Redundant input: "+this.input.substring(this.idx));return{type:"Pattern",flags:n,value:t}},e.prototype.disjunction=function(){var e=[];for(e.push(this.alternative());"|"===this.peekChar();)this.consumeChar("|"),e.push(this.alternative());return{type:"Disjunction",value:e}},e.prototype.alternative=function(){for(var e=[];this.isTerm();)e.push(this.term());return{type:"Alternative",value:e}},e.prototype.term=function(){return this.isAssertion()?this.assertion():this.atom()},e.prototype.assertion=function(){switch(this.popChar()){case"^":return{type:"StartAnchor"};case"$":return{type:"EndAnchor"};case"\\":switch(this.popChar()){case"b":return{type:"WordBoundary"};case"B":return{type:"NonWordBoundary"}}throw Error("Invalid Assertion Escape");case"(":var e;switch(this.consumeChar("?"),this.popChar()){case"=":e="Lookahead";break;case"!":e="NegativeLookahead"}l(e);var t=this.disjunction();return this.consumeChar(")"),{type:e,value:t}}!function(){throw Error("Internal Error - Should never get here!")}()},e.prototype.quantifier=function(e){var t;switch(this.popChar()){case"*":t={atLeast:0,atMost:1/0};break;case"+":t={atLeast:1,atMost:1/0};break;case"?":t={atLeast:0,atMost:1};break;case"{":var n=this.integerIncludingZero();switch(this.popChar()){case"}":t={atLeast:n,atMost:n};break;case",":t=this.isDigit()?{atLeast:n,atMost:this.integerIncludingZero()}:{atLeast:n,atMost:1/0},this.consumeChar("}")}if(!0===e&&void 0===t)return;l(t)}if(!0!==e||void 0!==t)return l(t),"?"===this.peekChar(0)?(this.consumeChar("?"),t.greedy=!1):t.greedy=!0,t.type="Quantifier",t},e.prototype.atom=function(){var e;switch(this.peekChar()){case".":e=this.dotAll();break;case"\\":e=this.atomEscape();break;case"[":e=this.characterClass();break;case"(":e=this.group()}return void 0===e&&this.isPatternCharacter()&&(e=this.patternCharacter()),l(e),this.isQuantifier()&&(e.quantifier=this.quantifier()),e},e.prototype.dotAll=function(){return this.consumeChar("."),{type:"Set",complement:!0,value:[a("\n"),a("\r"),a("\u2028"),a("\u2029")]}},e.prototype.atomEscape=function(){switch(this.consumeChar("\\"),this.peekChar()){case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return this.decimalEscapeAtom();case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},e.prototype.decimalEscapeAtom=function(){return{type:"GroupBackReference",value:this.positiveInteger()}},e.prototype.characterClassEscape=function(){var e,t=!1;switch(this.popChar()){case"d":e=c;break;case"D":e=c,t=!0;break;case"s":e=u;break;case"S":e=u,t=!0;break;case"w":e=f;break;case"W":e=f,t=!0}return l(e),{type:"Set",value:e,complement:t}},e.prototype.controlEscapeAtom=function(){var e;switch(this.popChar()){case"f":e=a("\f");break;case"n":e=a("\n");break;case"r":e=a("\r");break;case"t":e=a("\t");break;case"v":e=a("\v")}return l(e),{type:"Character",value:e}},e.prototype.controlLetterEscapeAtom=function(){this.consumeChar("c");var e=this.popChar();if(!1===/[a-zA-Z]/.test(e))throw Error("Invalid ");return{type:"Character",value:e.toUpperCase().charCodeAt(0)-64}},e.prototype.nulCharacterAtom=function(){return this.consumeChar("0"),{type:"Character",value:a("\0")}},e.prototype.hexEscapeSequenceAtom=function(){return this.consumeChar("x"),this.parseHexDigits(2)},e.prototype.regExpUnicodeEscapeSequenceAtom=function(){return this.consumeChar("u"),this.parseHexDigits(4)},e.prototype.identityEscapeAtom=function(){return{type:"Character",value:a(this.popChar())}},e.prototype.classPatternCharacterAtom=function(){switch(this.peekChar()){case"\n":case"\r":case"\u2028":case"\u2029":case"\\":case"]":throw Error("TBD");default:return{type:"Character",value:a(this.popChar())}}},e.prototype.characterClass=function(){var e=[],t=!1;for(this.consumeChar("["),"^"===this.peekChar(0)&&(this.consumeChar("^"),t=!0);this.isClassAtom();){var n=this.classAtom();if("Character"===n.type&&this.isRangeDash()){this.consumeChar("-");var r=this.classAtom();if("Character"===r.type){if(r.value<n.value)throw Error("Range out of order in character class");e.push({from:n.value,to:r.value})}else i(n.value,e),e.push(a("-")),i(r.value,e)}else i(n.value,e)}return this.consumeChar("]"),{type:"Set",complement:t,value:e}},e.prototype.classAtom=function(){switch(this.peekChar()){case"]":case"\n":case"\r":case"\u2028":case"\u2029":throw Error("TBD");case"\\":return this.classEscape();default:return this.classPatternCharacterAtom()}},e.prototype.classEscape=function(){switch(this.consumeChar("\\"),this.peekChar()){case"b":return this.consumeChar("b"),{type:"Character",value:a("\b")};case"d":case"D":case"s":case"S":case"w":case"W":return this.characterClassEscape();case"f":case"n":case"r":case"t":case"v":return this.controlEscapeAtom();case"c":return this.controlLetterEscapeAtom();case"0":return this.nulCharacterAtom();case"x":return this.hexEscapeSequenceAtom();case"u":return this.regExpUnicodeEscapeSequenceAtom();default:return this.identityEscapeAtom()}},e.prototype.group=function(){var e=!0;switch(this.consumeChar("("),this.peekChar(0)){case"?":this.consumeChar("?"),this.consumeChar(":"),e=!1;break;default:this.groupIdx++}var t=this.disjunction();this.consumeChar(")");var n={type:"Group",capturing:e,value:t};return e&&(n.idx=this.groupIdx),n},e.prototype.positiveInteger=function(){var e=this.popChar();if(!1===o.test(e))throw Error("Expecting a positive integer");for(;r.test(this.peekChar(0));)e+=this.popChar();return parseInt(e,10)},e.prototype.integerIncludingZero=function(){var e=this.popChar();if(!1===r.test(e))throw Error("Expecting an integer");for(;r.test(this.peekChar(0));)e+=this.popChar();return parseInt(e,10)},e.prototype.patternCharacter=function(){var e=this.popChar();switch(e){case"\n":case"\r":case"\u2028":case"\u2029":case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":throw Error("TBD");default:return{type:"Character",value:a(e)}}},e.prototype.isRegExpFlag=function(){switch(this.peekChar(0)){case"g":case"i":case"m":case"u":case"y":return!0;default:return!1}},e.prototype.isRangeDash=function(){return"-"===this.peekChar()&&this.isClassAtom(1)},e.prototype.isDigit=function(){return r.test(this.peekChar(0))},e.prototype.isClassAtom=function(e){switch(void 0===e&&(e=0),this.peekChar(e)){case"]":case"\n":case"\r":case"\u2028":case"\u2029":return!1;default:return!0}},e.prototype.isTerm=function(){return this.isAtom()||this.isAssertion()},e.prototype.isAtom=function(){if(this.isPatternCharacter())return!0;switch(this.peekChar(0)){case".":case"\\":case"[":case"(":return!0;default:return!1}},e.prototype.isAssertion=function(){switch(this.peekChar(0)){case"^":case"$":return!0;case"\\":switch(this.peekChar(1)){case"b":case"B":return!0;default:return!1}case"(":return"?"===this.peekChar(1)&&("="===this.peekChar(2)||"!"===this.peekChar(2));default:return!1}},e.prototype.isQuantifier=function(){var e=this.saveState();try{return void 0!==this.quantifier(!0)}catch(e){return!1}finally{this.restoreState(e)}},e.prototype.isPatternCharacter=function(){switch(this.peekChar()){case"^":case"$":case"\\":case".":case"*":case"+":case"?":case"(":case")":case"[":case"|":case"/":case"\n":case"\r":case"\u2028":case"\u2029":return!1;default:return!0}},e.prototype.parseHexDigits=function(e){for(var t="",r=0;r<e;r++){var o=this.popChar();if(!1===n.test(o))throw Error("Expecting a HexDecimal digits");t+=o}return{type:"Character",value:parseInt(t,16)}},e.prototype.peekChar=function(e){return void 0===e&&(e=0),this.input[this.idx+e]},e.prototype.popChar=function(){var e=this.peekChar(0);return this.consumeChar(),e},e.prototype.consumeChar=function(e){if(void 0!==e&&this.input[this.idx]!==e)throw Error("Expected: '"+e+"' but found: '"+this.input[this.idx]+"' at offset: "+this.idx);if(this.idx>=this.input.length)throw Error("Unexpected end of input");this.idx++};var t,n=/[0-9a-fA-F]/,r=/[0-9]/,o=/[1-9]/;function a(e){return e.charCodeAt(0)}function i(e,t){void 0!==e.length?e.forEach((function(e){t.push(e)})):t.push(e)}function s(e,t){if(!0===e[t])throw"duplicate flag "+t;e[t]=!0}function l(e){if(void 0===e)throw Error("Internal Error - Should never get here!")}var c=[];for(t=a("0");t<=a("9");t++)c.push(t);var f=[a("_")].concat(c);for(t=a("a");t<=a("z");t++)f.push(t);for(t=a("A");t<=a("Z");t++)f.push(t);var u=[a(" "),a("\f"),a("\n"),a("\r"),a("\t"),a("\v"),a("\t"),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a(""),a("\u2028"),a("\u2029"),a(""),a(""),a(""),a("\ufeff")];function d(){}return d.prototype.visitChildren=function(e){for(var t in e){var n=e[t];e.hasOwnProperty(t)&&(void 0!==n.type?this.visit(n):Array.isArray(n)&&n.forEach((function(e){this.visit(e)}),this))}},d.prototype.visit=function(e){switch(e.type){case"Pattern":this.visitPattern(e);break;case"Flags":this.visitFlags(e);break;case"Disjunction":this.visitDisjunction(e);break;case"Alternative":this.visitAlternative(e);break;case"StartAnchor":this.visitStartAnchor(e);break;case"EndAnchor":this.visitEndAnchor(e);break;case"WordBoundary":this.visitWordBoundary(e);break;case"NonWordBoundary":this.visitNonWordBoundary(e);break;case"Lookahead":this.visitLookahead(e);break;case"NegativeLookahead":this.visitNegativeLookahead(e);break;case"Character":this.visitCharacter(e);break;case"Set":this.visitSet(e);break;case"Group":this.visitGroup(e);break;case"GroupBackReference":this.visitGroupBackReference(e);break;case"Quantifier":this.visitQuantifier(e)}this.visitChildren(e)},d.prototype.visitPattern=function(e){},d.prototype.visitFlags=function(e){},d.prototype.visitDisjunction=function(e){},d.prototype.visitAlternative=function(e){},d.prototype.visitStartAnchor=function(e){},d.prototype.visitEndAnchor=function(e){},d.prototype.visitWordBoundary=function(e){},d.prototype.visitNonWordBoundary=function(e){},d.prototype.visitLookahead=function(e){},d.prototype.visitNegativeLookahead=function(e){},d.prototype.visitCharacter=function(e){},d.prototype.visitSet=function(e){},d.prototype.visitGroup=function(e){},d.prototype.visitGroupBackReference=function(e){},d.prototype.visitQuantifier=function(e){},{RegExpParser:e,BaseRegExpVisitor:d,VERSION:"0.4.0"}})?r.apply(t,o):r)||(e.exports=a)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.defaultLexerErrorProvider={buildUnableToPopLexerModeMessage:function(e){return"Unable to pop Lexer Mode after encountering Token ->"+e.image+"<- The Mode Stack is empty"},buildUnexpectedCharactersMessage:function(e,t,n,r,o){return"unexpected character: ->"+e.charAt(t)+"<- at offset: "+t+", skipped "+n+" characters."}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(1),a=n(8);function i(e){if(e instanceof o.NonTerminal)return i(e.referencedRule);if(e instanceof o.Terminal)return c(e);if(a.isSequenceProd(e))return s(e);if(a.isBranchingProd(e))return l(e);throw Error("non exhaustive match")}function s(e){for(var t,n=[],o=e.definition,s=0,l=o.length>s,c=!0;l&&c;)t=o[s],c=a.isOptionalProd(t),n=n.concat(i(t)),s+=1,l=o.length>s;return r.uniq(n)}function l(e){var t=r.map(e.definition,(function(e){return i(e)}));return r.uniq(r.flatten(t))}function c(e){return[e.terminalType]}t.first=i,t.firstForSequence=s,t.firstForBranching=l,t.firstForTerminal=c},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IN="_~IN~_"},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r,o=n(29),a=n(0),i=n(1);!function(e){e[e.OPTION=0]="OPTION",e[e.OR=1]="OR",e[e.MANY=2]="MANY",e[e.MANY_SEP=3]="MANY_SEP",e[e.AT_LEAST_ONE=4]="AT_LEAST_ONE",e[e.AT_LEAST_ONE_SEP=5]="AT_LEAST_ONE_SEP",e[e.REF=6]="REF",e[e.TERMINAL=7]="TERMINAL",e[e.FLAT=8]="FLAT"}(r=t.ProdType||(t.ProdType={}));var s=/(?:\s*{\s*NAME\s*:\s*["'`]([\w$]*)["'`])?/,l=new RegExp(s.source.replace("{","").replace(")?","\\s*,)?")),c=/\.\s*CONSUME(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,f=new RegExp(c.source,"g"),u=/\.\s*SUBRULE(\d+)?\s*\(\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,d=new RegExp(u.source,"g"),p=/\.\s*OPTION(\d+)?\s*\(/,h=new RegExp(p.source+s.source),v=new RegExp(p.source,"g"),m=/\.\s*MANY(\d+)?\s*\(/,x=new RegExp(m.source+s.source),g=new RegExp(m.source,"g"),y=/\s*SEP\s*:\s*(?:[a-zA-Z_$]\w*\s*\.\s*)*([a-zA-Z_$]\w*)/,E=new RegExp(/\.\s*MANY_SEP(\d+)?\s*\(\s*{/.source+l.source+y.source),w=new RegExp(E.source,"g"),b=new RegExp(/\.\s*AT_LEAST_ONE_SEP(\d+)?\s*\(\s*{/.source+l.source+y.source),_=new RegExp(b.source,"g"),T=/\.\s*AT_LEAST_ONE(\d+)?\s*\(/,A=new RegExp(T.source+s.source),S=new RegExp(T.source,"g"),R=/\.\s*OR(\d+)?\s*\(/,M=new RegExp(R.source+s.source),C=new RegExp(R.source,"g"),L=new RegExp(l.source+/\s*(ALT)\s*:/.source),P=new RegExp(L.source,"g");function k(e,n,o){switch(e.type){case r.AT_LEAST_ONE:return function(e,t,n){return N(A,new i.RepetitionMandatory({definition:[]}),e,t,n)}(e,n,o);case r.AT_LEAST_ONE_SEP:return function(e,t,n){return H(e,t,i.RepetitionMandatoryWithSeparator,b,n)}(e,n,o);case r.MANY_SEP:return function(e,t,n){return H(e,t,i.RepetitionWithSeparator,E,n)}(e,n,o);case r.MANY:return function(e,t,n){return N(x,new i.Repetition({definition:[]}),e,t,n)}(e,n,o);case r.OPTION:return function(e,t,n){return N(h,new i.Option({definition:[]}),e,t,n)}(e,n,o);case r.OR:return function(e,t,n){return N(M,new i.Alternation({definition:[]}),e,t,n)}(e,n,o);case r.FLAT:return function(e,t,n){var r=new i.Flat({definition:[]}),o=L.exec(e.text)[1];return a.isUndefined(o)||(r.name=o),z(r,e.range,t,n)}(e,n,o);case r.REF:return function(e){var t=u.exec(e.text),n=void 0===t[1]?0:parseInt(t[1],10),r=t[2];return new i.NonTerminal({nonTerminalName:r,idx:n})}(e);case r.TERMINAL:return function(e,n){var r=c.exec(e.text),o=void 0===r[1]?0:parseInt(r[1],10),a=r[2],s=t.terminalNameToConstructor[a];if(!s)throw Error("Terminal Token name: <"+a+"> not found in rule: <"+n+">  \n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_grammar_errors.html#TERMINAL_NAME_NOT_FOUND\n\tFor Further details.");return new i.Terminal({terminalType:s,idx:o})}(e,o);default:throw Error("non exhaustive match")}}function N(e,t,n,r,o){var i=e.exec(n.text),s=void 0===i[1];t.idx=s?0:parseInt(i[1],10);var l=i[2];return a.isUndefined(l)||(t.name=l),z(t,n.range,r,o)}function H(e,n,r,o,i){var s=o.exec(e.text),l=void 0===s[1]?0:parseInt(s[1],10),c=s[3],f=t.terminalNameToConstructor[c];if(!f)throw Error("Separator Terminal Token name: "+c+" not found");var u=new r({definition:[],separator:f,idx:l}),d=s[2];return a.isUndefined(d)||(u.name=d),z(u,e.range,n,i)}function z(e,t,n,r){var o=D(t,n),i=a.sortBy(o,(function(e){return e.range.start})),s=[];return a.forEach(i,(function(e){s.push(k(e,n,r))})),e.definition=s,e}function D(e,t){return a.filter(t,(function(n){var r=e.strictlyContainsRange(n.range),o=a.every(t,(function(t){var r=t.range.strictlyContainsRange(n.range),o=t.range.isStrictlyContainedInRange(e);return!(r&&o)}));return r&&o}))}t.terminalNameToConstructor={},t.buildTopProduction=function(e,n,r){t.terminalNameToConstructor=r;var a=W(V(G("  "+e)));return function(e,t,n,r){return z(new i.Rule({name:e,definition:[],orgText:r}),t,n,e)}(n,new o.Range(0,e.length+2),a,e)},t.buildProdGast=k,t.getDirectlyContainedRanges=D;var F=/\/\/.*/g,I=/\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\//g,O=/(NAME\s*:\s*)?"([^\\"]|\\([bfnrtv"\\\/]|u[0-9a-fA-F]{4}))*"/g,U=/(NAME\s*:\s*)?'([^\\']|\\([bfnrtv'\\\/]|u[0-9a-fA-F]{4}))*'/g;function G(e){return e.replace(F,"").replace(I,"")}function B(e,t){return void 0!==t?e:""}function V(e){return e.replace(O,B).replace(U,B)}function W(e){var t=j(e),n=q(e),r=X(e),o=Y(e),a=Q(e),i=K(e),s=Z(e),l=J(e);return[].concat(t,n,r,o,a,i,s,l)}function j(e){return ne(e,r.TERMINAL,f)}function q(e){return ne(e,r.REF,d)}function X(e){return re(e,r.AT_LEAST_ONE,S)}function Y(e){return re(e,r.AT_LEAST_ONE_SEP,_)}function Q(e){return re(e,r.MANY,g)}function K(e){return re(e,r.MANY_SEP,w)}function Z(e){return re(e,r.OPTION,v)}function J(e){var t=re(e,r.OR,C),n=te(t);return t.concat(n)}t.removeComments=G,t.removeStringLiterals=V,t.createRanges=W,t.createTerminalRanges=j,t.createRefsRanges=q,t.createAtLeastOneRanges=X,t.createAtLeastOneSepRanges=Y,t.createManyRanges=Q,t.createManySepRanges=K,t.createOptionRanges=Z,t.createOrRanges=J;var $=a.partial(ae,"{","}"),ee=a.partial(ae,"(",")");function te(e){var t=[];return a.forEach(e,(function(e){var n=oe(e.text,r.FLAT,P,$),o=e.range.start;a.forEach(n,(function(e){e.range.start+=o,e.range.end+=o})),t=t.concat(n)})),a.uniq(t,(function(e){return e.type+"~"+e.range.start+"~"+e.range.end+"~"+e.text}))}function ne(e,t,n){for(var r,a=[];r=n.exec(e);){var i=r.index,s=n.lastIndex,l=new o.Range(i,s),c=r[0];a.push({range:l,text:c,type:t})}return a}function re(e,t,n){return oe(e,t,n,ee)}function oe(e,t,n,r){for(var a,i=[];a=n.exec(e);){var s=a.index,l=r(s+a[0].length,e),c=new o.Range(s,l),f=e.substr(s,l-s+1);i.push({range:c,text:f,type:t})}return i}function ae(e,t,n,r){for(var o=[1],i=-1;!a.isEmpty(o)&&i+n<r.length;){i++;var s=r.charAt(n+i);s===e?o.push(1):s===t&&o.pop()}if(a.isEmpty(o))return i+n;throw new Error("INVALID INPUT TEXT, UNTERMINATED PARENTHESIS")}function ie(e,t){return a.map(e,(function(e){return se(e,t)}))}function se(e,t){switch(e.type){case"NonTerminal":return new i.NonTerminal({nonTerminalName:e.name,idx:e.idx});case"Flat":return new i.Flat({name:e.name,definition:ie(e.definition,t)});case"Option":return new i.Option({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"RepetitionMandatory":return new i.RepetitionMandatory({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"RepetitionMandatoryWithSeparator":return new i.RepetitionMandatoryWithSeparator({name:e.name,idx:e.idx,separator:t[e.separator.name],definition:ie(e.definition,t)});case"RepetitionWithSeparator":return new i.RepetitionWithSeparator({name:e.name,idx:e.idx,separator:t[e.separator.name],definition:ie(e.definition,t)});case"Repetition":return new i.Repetition({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"Alternation":return new i.Alternation({name:e.name,idx:e.idx,definition:ie(e.definition,t)});case"Terminal":return new i.Terminal({terminalType:t[e.name],idx:e.idx});case"Rule":return new i.Rule({name:e.name,orgText:e.orgText,definition:ie(e.definition,t)})}}t.createOrPartRanges=te,t.findClosingOffset=ae,t.deserializeGrammar=ie,t.deserializeProduction=se},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(4),a=n(30),i=n(11),s=n(10),l=n(8);t.resolveGrammar=function(e){e=r.defaults(e,{errMsgProvider:s.defaultGrammarResolverErrorProvider});var t=new o.HashTable;return r.forEach(e.rules,(function(e){t.put(e.name,e)})),a.resolveGrammar(t,e.errMsgProvider)},t.validateGrammar=function(e){return e=r.defaults(e,{errMsgProvider:s.defaultGrammarValidatorErrorProvider,ignoredIssues:{}}),i.validateGrammar(e.rules,e.maxLookahead,e.tokenTypes,e.ignoredIssues,e.errMsgProvider,e.grammarName)},t.assignOccurrenceIndices=function(e){r.forEach(e.rules,(function(e){var t=new l.DslMethodsCollectorVisitor;e.accept(t),r.forEach(t.dslMethods,(function(e){r.forEach(e,(function(e,t){e.idx=t+1}))}))}))}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(2),o=n(0),a=n(6),i=n(22),s=n(4),l=n(3);function c(e){this.name=t.IN_RULE_RECOVERY_EXCEPTION,this.message=e}t.EOF_FOLLOW_KEY={},t.IN_RULE_RECOVERY_EXCEPTION="InRuleRecoveryException",t.InRuleRecoveryException=c,c.prototype=Error.prototype;var f=function(){function e(){}return e.prototype.initRecoverable=function(e){this.firstAfterRepMap=new s.HashTable,this.resyncFollows=new s.HashTable,this.recoveryEnabled=o.has(e,"recoveryEnabled")?e.recoveryEnabled:l.DEFAULT_PARSER_CONFIG.recoveryEnabled,this.recoveryEnabled&&(this.attemptInRepetitionRecovery=u)},e.prototype.getTokenToInsert=function(e){var t=r.createTokenInstance(e,"",NaN,NaN,NaN,NaN,NaN,NaN);return t.isInsertedInRecovery=!0,t},e.prototype.canTokenTypeBeInsertedInRecovery=function(e){return!0},e.prototype.tryInRepetitionRecovery=function(e,t,n,r){for(var i=this,s=this.findReSyncTokenType(),l=this.exportLexerState(),c=[],f=!1,u=this.LA(1),d=this.LA(1),p=function(){var e=i.LA(0),t=i.errorMessageProvider.buildMismatchTokenMessage({expected:r,actual:u,previous:e,ruleName:i.getCurrRuleFullName()}),n=new a.MismatchedTokenException(t,u,i.LA(0));n.resyncedTokens=o.dropRight(c),i.SAVE_ERROR(n)};!f;){if(this.tokenMatcher(d,r))return void p();if(n.call(this))return p(),void e.apply(this,t);this.tokenMatcher(d,s)?f=!0:(d=this.SKIP_TOKEN(),this.addToResyncTokens(d,c))}this.importLexerState(l)},e.prototype.shouldInRepetitionRecoveryBeTried=function(e,t){return void 0!==e&&void 0!==t&&!this.tokenMatcher(this.LA(1),e)&&!this.isBackTracking()&&!this.canPerformInRuleRecovery(e,this.getFollowsForInRuleRecovery(e,t))},e.prototype.getFollowsForInRuleRecovery=function(e,t){var n=this.getCurrentGrammarPath(e,t);return this.getNextPossibleTokenTypes(n)},e.prototype.tryInRuleRecovery=function(e,t){if(this.canRecoverWithSingleTokenInsertion(e,t))return this.getTokenToInsert(e);if(this.canRecoverWithSingleTokenDeletion(e)){var n=this.SKIP_TOKEN();return this.consumeToken(),n}throw new c("sad sad panda")},e.prototype.canPerformInRuleRecovery=function(e,t){return this.canRecoverWithSingleTokenInsertion(e,t)||this.canRecoverWithSingleTokenDeletion(e)},e.prototype.canRecoverWithSingleTokenInsertion=function(e,t){var n=this;if(!this.canTokenTypeBeInsertedInRecovery(e))return!1;if(o.isEmpty(t))return!1;var r=this.LA(1);return void 0!==o.find(t,(function(e){return n.tokenMatcher(r,e)}))},e.prototype.canRecoverWithSingleTokenDeletion=function(e){return this.tokenMatcher(this.LA(2),e)},e.prototype.isInCurrentRuleReSyncSet=function(e){var t=this.getCurrFollowKey(),n=this.getFollowSetFromFollowKey(t);return o.contains(n,e)},e.prototype.findReSyncTokenType=function(){for(var e=this.flattenFollowSet(),t=this.LA(1),n=2;;){var r=t.tokenType;if(o.contains(e,r))return r;t=this.LA(n),n++}},e.prototype.getCurrFollowKey=function(){if(1===this.RULE_STACK.length)return t.EOF_FOLLOW_KEY;var e=this.getLastExplicitRuleShortName(),n=this.getLastExplicitRuleOccurrenceIndex(),r=this.getPreviousExplicitRuleShortName();return{ruleName:this.shortRuleNameToFullName(e),idxInCallingRule:n,inRule:this.shortRuleNameToFullName(r)}},e.prototype.buildFullFollowKeyStack=function(){var e=this,n=this.RULE_STACK,r=this.RULE_OCCURRENCE_STACK;return o.isEmpty(this.LAST_EXPLICIT_RULE_STACK)||(n=o.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.RULE_STACK[t]})),r=o.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.RULE_OCCURRENCE_STACK[t]}))),o.map(n,(function(o,a){return 0===a?t.EOF_FOLLOW_KEY:{ruleName:e.shortRuleNameToFullName(o),idxInCallingRule:r[a],inRule:e.shortRuleNameToFullName(n[a-1])}}))},e.prototype.flattenFollowSet=function(){var e=this,t=o.map(this.buildFullFollowKeyStack(),(function(t){return e.getFollowSetFromFollowKey(t)}));return o.flatten(t)},e.prototype.getFollowSetFromFollowKey=function(e){if(e===t.EOF_FOLLOW_KEY)return[r.EOF];var n=e.ruleName+e.idxInCallingRule+i.IN+e.inRule;return this.resyncFollows.get(n)},e.prototype.addToResyncTokens=function(e,t){return this.tokenMatcher(e,r.EOF)||t.push(e),t},e.prototype.reSyncTo=function(e){for(var t=[],n=this.LA(1);!1===this.tokenMatcher(n,e);)n=this.SKIP_TOKEN(),this.addToResyncTokens(n,t);return o.dropRight(t)},e.prototype.attemptInRepetitionRecovery=function(e,t,n,r,o,a){},e.prototype.getCurrentGrammarPath=function(e,t){return{ruleStack:this.getHumanReadableRuleStack(),occurrenceStack:o.cloneArr(this.RULE_OCCURRENCE_STACK),lastTok:e,lastTokOccurrence:t}},e.prototype.getHumanReadableRuleStack=function(){var e=this;return o.isEmpty(this.LAST_EXPLICIT_RULE_STACK)?o.map(this.RULE_STACK,(function(t){return e.shortRuleNameToFullName(t)})):o.map(this.LAST_EXPLICIT_RULE_STACK,(function(t){return e.shortRuleNameToFullName(e.RULE_STACK[t])}))},e}();function u(e,t,n,o,a,i){var s=this.getKeyForAutomaticLookahead(o,a),l=this.firstAfterRepMap.get(s);if(void 0===l){var c=this.getCurrRuleFullName();l=new i(this.getGAstProductions().get(c),a).startWalking(),this.firstAfterRepMap.put(s,l)}var f=l.token,u=l.occurrence,d=l.isEndOfRule;1===this.RULE_STACK.length&&d&&void 0===f&&(f=r.EOF,u=1),this.shouldInRepetitionRecoveryBeTried(f,u)&&this.tryInRepetitionRecovery(e,t,n,f)}t.Recoverable=f,t.attemptInRepetitionRecovery=u},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(14),i=n(4),s=n(21),l=n(0),c=n(22),f=n(2),u=n(1),d=function(e){function t(t){var n=e.call(this)||this;return n.topProd=t,n.follows=new i.HashTable,n}return o(t,e),t.prototype.startWalking=function(){return this.walk(this.topProd),this.follows},t.prototype.walkTerminal=function(e,t,n){},t.prototype.walkProdRef=function(e,t,n){var r=p(e.referencedRule,e.idx)+this.topProd.name,o=t.concat(n),a=new u.Flat({definition:o}),i=s.first(a);this.follows.put(r,i)},t}(a.RestWalker);function p(e,t){return e.name+t+c.IN}t.ResyncFollowsWalker=d,t.computeAllProdsFollows=function(e){var t=new i.HashTable;return l.forEach(e,(function(e){var n=new d(e).startWalking();t.putAll(n)})),t},t.buildBetweenProdsFollowPrefix=p,t.buildInProdFollowPrefix=function(e){return f.tokenName(e.terminalType)+e.idx+c.IN}},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(19),i=n(2),s=n(15),l=n(0),c=n(28),f=new a.RegExpParser,u="PATTERN";function d(e){var t=l.filter(e,(function(e){return!l.has(e,u)}));return{errors:l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- missing static 'PATTERN' property",type:s.LexerDefinitionErrorType.MISSING_PATTERN,tokenTypes:[e]}})),valid:l.difference(e,t)}}function p(e){var t=l.filter(e,(function(e){var t=e[u];return!(l.isRegExp(t)||l.isFunction(t)||l.has(t,"exec")||l.isString(t))}));return{errors:l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",type:s.LexerDefinitionErrorType.INVALID_PATTERN,tokenTypes:[e]}})),valid:l.difference(e,t)}}t.DEFAULT_MODE="defaultMode",t.MODES="modes",t.SUPPORT_STICKY="boolean"==typeof new RegExp("(?:)").sticky,t.disableSticky=function(){t.SUPPORT_STICKY=!1},t.enableSticky=function(){t.SUPPORT_STICKY=!0},t.analyzeTokenTypes=function(e,n){n=l.defaults(n,{useSticky:t.SUPPORT_STICKY,debug:!1,safeMode:!1,positionTracking:"full",lineTerminatorCharacters:["\r","\n"]});var r=l.reject(e,(function(e){return e[u]===s.Lexer.NA})),o=!1,a=l.map(r,(function(e){var t=e[u];if(l.isRegExp(t)){var r=t.source;return 1===r.length&&"^"!==r&&"$"!==r&&"."!==r?r:2!==r.length||"\\"!==r[0]||l.contains(["d","D","s","S","t","r","n","t","0","c","b","B","f","v","w","W"],r[1])?n.useSticky?A(t):T(t):r[1]}if(l.isFunction(t))return o=!0,{exec:t};if(l.has(t,"exec"))return o=!0,t;if("string"==typeof t){if(1===t.length)return t;var a=t.replace(/[\\^$.*+?()[\]{}|]/g,"\\$&"),i=new RegExp(a);return n.useSticky?A(i):T(i)}throw Error("non exhaustive match")})),f=l.map(r,(function(e){return e.tokenTypeIdx})),d=l.map(r,(function(e){var t=e.GROUP;if(t!==s.Lexer.SKIPPED){if(l.isString(t))return t;if(l.isUndefined(t))return!1;throw Error("non exhaustive match")}})),p=l.map(r,(function(e){var t=e.LONGER_ALT;if(t)return l.indexOf(r,t)})),h=l.map(r,(function(e){return e.PUSH_MODE})),v=l.map(r,(function(e){return l.has(e,"POP_MODE")})),m=L(n.lineTerminatorCharacters),x=l.map(r,(function(e){return!1}));"onlyOffset"!==n.positionTracking&&(x=l.map(r,(function(e){return l.has(e,"LINE_BREAKS")?e.LINE_BREAKS:!1===M(e,m)?c.canMatchCharCode(m,e.PATTERN):void 0})));var g=l.map(r,S),y=l.map(a,R),E=l.reduce(r,(function(e,t){var n=t.GROUP;return l.isString(n)&&n!==s.Lexer.SKIPPED&&(e[n]=[]),e}),{}),w=l.map(a,(function(e,t){return{pattern:a[t],longerAlt:p[t],canLineTerminator:x[t],isCustom:g[t],short:y[t],group:d[t],push:h[t],pop:v[t],tokenTypeIdx:f[t],tokenType:r[t]}}));function b(e,t,n){void 0===e[t]&&(e[t]=[]),e[t].push(n)}var _=!0,C=[];return n.safeMode||(C=l.reduce(r,(function(e,t,r){if("string"==typeof t.PATTERN){var o=t.PATTERN.charCodeAt(0);b(e,o,w[r])}else if(l.isArray(t.START_CHARS_HINT))l.forEach(t.START_CHARS_HINT,(function(t){var n="string"==typeof t?t.charCodeAt(0):t;b(e,n,w[r])}));else if(l.isRegExp(t.PATTERN))if(t.PATTERN.unicode)_=!1,n.ensureOptimizations&&l.PRINT_ERROR(c.failedOptimizationPrefixMsg+"\tUnable to analyze < "+t.PATTERN.toString()+" > pattern.\n\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");else{var a=c.getStartCodes(t.PATTERN,n.ensureOptimizations);l.isEmpty(a)&&(_=!1),l.forEach(a,(function(t){b(e,t,w[r])}))}else n.ensureOptimizations&&l.PRINT_ERROR(c.failedOptimizationPrefixMsg+"\tTokenType: <"+i.tokenName(t)+"> is using a custom token pattern without providing <start_chars_hint> parameter.\n\tThis will disable the lexer's first char optimizations.\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE"),_=!1;return e}),[])),_&&C.length<65536&&(C=l.packArray(C)),{emptyGroups:E,patternIdxToConfig:w,charCodeToPatternIdxToConfig:C,hasCustom:o,canBeOptimized:_}},t.validatePatterns=function(e,t){var n=[],r=d(e);n=n.concat(r.errors);var o=p(r.valid),a=o.valid;return(n=(n=(n=(n=n.concat(o.errors)).concat(function(e){var t=[],n=l.filter(e,(function(e){return l.isRegExp(e[u])}));return(t=(t=(t=(t=t.concat(v(n))).concat(g(n))).concat(y(n))).concat(E(n))).concat(m(n))}(a))).concat(w(a))).concat(b(a,t))).concat(_(a))},t.findMissingPatterns=d,t.findInvalidPatterns=p;var h=/[^\\][\$]/;function v(e){var t=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.found=!1,t}return o(t,e),t.prototype.visitEndAnchor=function(e){this.found=!0},t}(a.BaseRegExpVisitor),n=l.filter(e,(function(e){var n=e[u];try{var r=f.pattern(n.toString()),o=new t;return o.visit(r),o.found}catch(e){return h.test(n.source)}}));return l.map(n,(function(e){return{message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+i.tokenName(e)+"<- static 'PATTERN' cannot contain end of input anchor '$'\n\tSee sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:s.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,tokenTypes:[e]}}))}function m(e){var t=l.filter(e,(function(e){return e[u].test("")}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' must not match an empty string",type:s.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,tokenTypes:[e]}}))}t.findEndOfInputAnchor=v,t.findEmptyMatchRegExps=m;var x=/[^\\[][\^]|^\^/;function g(e){var t=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.found=!1,t}return o(t,e),t.prototype.visitStartAnchor=function(e){this.found=!0},t}(a.BaseRegExpVisitor),n=l.filter(e,(function(e){var n=e[u];try{var r=f.pattern(n.toString()),o=new t;return o.visit(r),o.found}catch(e){return x.test(n.source)}}));return l.map(n,(function(e){return{message:"Unexpected RegExp Anchor Error:\n\tToken Type: ->"+i.tokenName(e)+"<- static 'PATTERN' cannot contain start of input anchor '^'\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#ANCHORS\tfor details.",type:s.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,tokenTypes:[e]}}))}function y(e){var t=l.filter(e,(function(e){var t=e[u];return t instanceof RegExp&&(t.multiline||t.global)}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PATTERN' may NOT contain global('g') or multiline('m')",type:s.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,tokenTypes:[e]}}))}function E(e){var t=[],n=l.map(e,(function(n){return l.reduce(e,(function(e,r){return n.PATTERN.source!==r.PATTERN.source||l.contains(t,r)||r.PATTERN===s.Lexer.NA||(t.push(r),e.push(r)),e}),[])}));n=l.compact(n);var r=l.filter(n,(function(e){return e.length>1}));return l.map(r,(function(e){var t=l.map(e,(function(e){return i.tokenName(e)}));return{message:"The same RegExp pattern ->"+l.first(e).PATTERN+"<-has been used in all of the following Token Types: "+t.join(", ")+" <-",type:s.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,tokenTypes:e}}))}function w(e){var t=l.filter(e,(function(e){if(!l.has(e,"GROUP"))return!1;var t=e.GROUP;return t!==s.Lexer.SKIPPED&&t!==s.Lexer.NA&&!l.isString(t)}));return l.map(t,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",type:s.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,tokenTypes:[e]}}))}function b(e,t){var n=l.filter(e,(function(e){return void 0!==e.PUSH_MODE&&!l.contains(t,e.PUSH_MODE)}));return l.map(n,(function(e){return{message:"Token Type: ->"+i.tokenName(e)+"<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->"+e.PUSH_MODE+"<-which does not exist",type:s.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,tokenTypes:[e]}}))}function _(e){var t=[],n=l.reduce(e,(function(e,t,n){var r,o=t.PATTERN;return o===s.Lexer.NA||(l.isString(o)?e.push({str:o,idx:n,tokenType:t}):l.isRegExp(o)&&(r=o,void 0===l.find([".","\\","[","]","|","^","$","(",")","?","*","+","{"],(function(e){return-1!==r.source.indexOf(e)})))&&e.push({str:o.source,idx:n,tokenType:t})),e}),[]);return l.forEach(e,(function(e,r){l.forEach(n,(function(n){var o=n.str,a=n.idx,c=n.tokenType;if(r<a&&function(e,t){if(l.isRegExp(t)){var n=t.exec(e);return null!==n&&0===n.index}if(l.isFunction(t))return t(e,0,[],{});if(l.has(t,"exec"))return t.exec(e,0,[],{});if("string"==typeof t)return t===e;throw Error("non exhaustive match")}(o,e.PATTERN)){var f="Token: ->"+i.tokenName(c)+"<- can never be matched.\nBecause it appears AFTER the Token Type ->"+i.tokenName(e)+"<-in the lexer's definition.\nSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#UNREACHABLE";t.push({message:f,type:s.LexerDefinitionErrorType.UNREACHABLE_PATTERN,tokenTypes:[e,c]})}}))})),t}function T(e){var t=e.ignoreCase?"i":"";return new RegExp("^(?:"+e.source+")",t)}function A(e){var t=e.ignoreCase?"iy":"y";return new RegExp(""+e.source,t)}function S(e){var t=e.PATTERN;if(l.isRegExp(t))return!1;if(l.isFunction(t))return!0;if(l.has(t,"exec"))return!0;if(l.isString(t))return!1;throw Error("non exhaustive match")}function R(e){return!(!l.isString(e)||1!==e.length)&&e.charCodeAt(0)}function M(e,t){if(l.has(e,"LINE_BREAKS"))return!1;if(l.isRegExp(e.PATTERN)){try{c.canMatchCharCode(t,e.PATTERN)}catch(e){return{issue:s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,errMsg:e.message}}return!1}if(l.isString(e.PATTERN))return!1;if(S(e))return{issue:s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK};throw Error("non exhaustive match")}function C(e,t){if(t.issue===s.LexerDefinitionErrorType.IDENTIFY_TERMINATOR)return"Warning: unable to identify line terminator usage in pattern.\n\tThe problem is in the <"+e.name+"> Token Type\n\t Root cause: "+t.errMsg+".\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";if(t.issue===s.LexerDefinitionErrorType.CUSTOM_LINE_BREAK)return"Warning: A Custom Token Pattern should specify the <line_breaks> option.\n\tThe problem is in the <"+e.name+"> Token Type\n\tFor details See: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";throw Error("non exhaustive match")}function L(e){return l.map(e,(function(e){return l.isString(e)&&e.length>0?e.charCodeAt(0):e}))}t.findStartOfInputAnchor=g,t.findUnsupportedFlags=y,t.findDuplicatePatterns=E,t.findInvalidGroupType=w,t.findModesThatDoNotExist=b,t.findUnreachablePatterns=_,t.addStartOfInput=T,t.addStickyFlag=A,t.performRuntimeChecks=function(e,n,r){var o=[];return l.has(e,t.DEFAULT_MODE)||o.push({message:"A MultiMode Lexer cannot be initialized without a <"+t.DEFAULT_MODE+"> property in its definition\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE}),l.has(e,t.MODES)||o.push({message:"A MultiMode Lexer cannot be initialized without a <"+t.MODES+"> property in its definition\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY}),l.has(e,t.MODES)&&l.has(e,t.DEFAULT_MODE)&&!l.has(e.modes,e.defaultMode)&&o.push({message:"A MultiMode Lexer cannot be initialized with a "+t.DEFAULT_MODE+": <"+e.defaultMode+">which does not exist\n",type:s.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST}),l.has(e,t.MODES)&&l.forEach(e.modes,(function(e,t){l.forEach(e,(function(e,n){l.isUndefined(e)&&o.push({message:"A Lexer cannot be initialized using an undefined Token Type. Mode:<"+t+"> at index: <"+n+">\n",type:s.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED})}))})),o},t.performWarningRuntimeChecks=function(e,t,n){var r=[],o=!1,a=l.compact(l.flatten(l.mapValues(e.modes,(function(e){return e})))),i=l.reject(a,(function(e){return e[u]===s.Lexer.NA})),f=L(n);return t&&l.forEach(i,(function(e){var t=M(e,f);if(!1!==t){var n={message:C(e,t),type:t.issue,tokenType:e};r.push(n)}else l.has(e,"LINE_BREAKS")?!0===e.LINE_BREAKS&&(o=!0):c.canMatchCharCode(f,e.PATTERN)&&(o=!0)})),t&&!o&&r.push({message:"Warning: No LINE_BREAKS Found.\n\tThis Lexer has been defined to track line and column information,\n\tBut none of the Token Types can be identified as matching a line terminator.\n\tSee https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n\tfor details.",type:s.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS}),r},t.cloneEmptyGroups=function(e){var t={},n=l.keys(e);return l.forEach(n,(function(n){var r=e[n];if(!l.isArray(r))throw Error("non exhaustive match");t[n]=[]})),t},t.isCustomPattern=S,t.isShortPattern=R,t.LineTerminatorOptimizedTester={test:function(e){for(var t=e.length,n=this.lastIndex;n<t;n++){var r=e.charCodeAt(n);if(10===r)return this.lastIndex=n+1,!0;if(13===r)return 10===e.charCodeAt(n+1)?this.lastIndex=n+2:this.lastIndex=n+1,!0}return!1},lastIndex:0},t.buildLineBreakIssueMessage=C},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(19),i=n(0),s=new a.RegExpParser,l="Complement Sets are not supported for first char optimization";function c(e){switch(e.type){case"Disjunction":return i.flatten(i.map(e.value,c));case"Alternative":for(var t=[],n=e.value,r=0;r<n.length;r++){var o=n[r];if(!i.contains(["GroupBackReference","Lookahead","NegativeLookahead","StartAnchor","EndAnchor","WordBoundary","NonWordBoundary"],o.type)){var a=o;switch(a.type){case"Character":t.push(a.value);break;case"Set":if(!0===a.complement)throw Error(l);i.forEach(a.value,(function(e){if("number"==typeof e)t.push(e);else for(var n=e,r=n.from;r<=n.to;r++)t.push(r)}));break;case"Group":var s=c(a.value);i.forEach(s,(function(e){return t.push(e)}));break;default:throw Error("Non Exhaustive Match")}var f=void 0!==a.quantifier&&0===a.quantifier.atLeast;if("Group"===a.type&&!1===d(a)||"Group"!==a.type&&!1===f)break}}return t;default:throw Error("non exhaustive match!")}}function f(e){var t=[];return i.forEach(e,(function(e){t.push(e);var n=String.fromCharCode(e);n.toUpperCase()!==n?t.push(n.toUpperCase().charCodeAt(0)):n.toLowerCase()!==n&&t.push(n.toLowerCase().charCodeAt(0))})),t}function u(e,t){return i.find(e.value,(function(e){if("number"==typeof e)return i.contains(t,e);var n=e;return void 0!==i.find(t,(function(e){return n.from<=e&&e<=n.to}))}))}function d(e){return!(!e.quantifier||0!==e.quantifier.atLeast)||!!e.value&&(i.isArray(e.value)?i.every(e.value,d):d(e.value))}t.failedOptimizationPrefixMsg='Unable to use "first char" lexer optimizations:\n',t.getStartCodes=function(e,n){void 0===n&&(n=!1);try{var r=s.pattern(e.toString()),o=c(r.value);return r.flags.ignoreCase&&(o=f(o)),o}catch(r){if(r.message===l)n&&i.PRINT_WARNING(t.failedOptimizationPrefixMsg+"\tUnable to optimize: < "+e.toString()+" >\n\tComplement Sets cannot be automatically optimized.\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");else{var u="";n&&(u="\n\tThis will disable the lexer's first char optimizations.\n\tSee: https://sap.github.io/chevrotain/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details."),i.PRINT_ERROR(t.failedOptimizationPrefixMsg+"\n\tFailed parsing: < "+e.toString()+" >\n\tUsing the regexp-to-ast library version: "+a.VERSION+"\n\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues"+u)}}return[]},t.firstChar=c,t.applyIgnoreCase=f;var p=function(e){function t(t){var n=e.call(this)||this;return n.targetCharCodes=t,n.found=!1,n}return o(t,e),t.prototype.visitChildren=function(t){switch(t.type){case"Lookahead":return void this.visitLookahead(t);case"NegativeLookahead":return void this.visitNegativeLookahead(t)}e.prototype.visitChildren.call(this,t)},t.prototype.visitCharacter=function(e){i.contains(this.targetCharCodes,e.value)&&(this.found=!0)},t.prototype.visitSet=function(e){e.complement?void 0===u(e,this.targetCharCodes)&&(this.found=!0):void 0!==u(e,this.targetCharCodes)&&(this.found=!0)},t}(a.BaseRegExpVisitor);t.canMatchCharCode=function(e,t){if(t instanceof RegExp){var n=s.pattern(t.toString()),r=new p(e);return r.visit(n),r.found}return void 0!==i.find(t,(function(t){return i.contains(e,t.charCodeAt(0))}))}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(e,t){if(this.start=e,this.end=t,!o(e,t))throw new Error("INVALID RANGE")}return e.prototype.contains=function(e){return this.start<=e&&this.end>=e},e.prototype.containsRange=function(e){return this.start<=e.start&&this.end>=e.end},e.prototype.isContainedInRange=function(e){return e.containsRange(this)},e.prototype.strictlyContainsRange=function(e){return this.start<e.start&&this.end>e.end},e.prototype.isStrictlyContainedInRange=function(e){return e.strictlyContainsRange(this)},e}();function o(e,t){return!(e<0||t<e)}t.Range=r,t.isValidRange=o},function(e,t,n){"use strict";var r,o=this&&this.__extends||(r=function(e,t){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)},function(e,t){function n(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)});Object.defineProperty(t,"__esModule",{value:!0});var a=n(3),i=n(0),s=n(5);t.resolveGrammar=function(e,t){var n=new l(e,t);return n.resolveRefs(),n.errors};var l=function(e){function t(t,n){var r=e.call(this)||this;return r.nameToTopRule=t,r.errMsgProvider=n,r.errors=[],r}return o(t,e),t.prototype.resolveRefs=function(){var e=this;i.forEach(this.nameToTopRule.values(),(function(t){e.currTopLevel=t,t.accept(e)}))},t.prototype.visitNonTerminal=function(e){var t=this.nameToTopRule.get(e.nonTerminalName);if(t)e.referencedRule=t;else{var n=this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel,e);this.errors.push({message:n,type:a.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,ruleName:this.currTopLevel.name,unresolvedRefName:e.nonTerminalName})}},t}(s.GAstVisitor);t.GastRefResolverVisitor=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(12),o=n(0),a=n(3),i=n(9),s=function(){function e(){}return e.prototype.initLooksAhead=function(e){this.dynamicTokensEnabled=o.has(e,"dynamicTokensEnabled")?e.dynamicTokensEnabled:a.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled,this.maxLookahead=o.has(e,"maxLookahead")?e.maxLookahead:a.DEFAULT_PARSER_CONFIG.maxLookahead,this.lookAheadFuncsCache=o.isES2015MapSupported()?new Map:[],o.isES2015MapSupported()?(this.getLaFuncFromCache=this.getLaFuncFromMap,this.setLaFuncCache=this.setLaFuncCacheUsingMap):(this.getLaFuncFromCache=this.getLaFuncFromObj,this.setLaFuncCache=this.setLaFuncUsingObj)},e.prototype.lookAheadBuilderForOptional=function(e,t,n){return r.buildSingleAlternativeLookaheadFunction(e,t,n)},e.prototype.lookAheadBuilderForAlternatives=function(e,t,n,o){return r.buildAlternativesLookAheadFunc(e,t,n,o)},e.prototype.getKeyForAutomaticLookahead=function(e,t){var n=this.getLastExplicitRuleShortName();return i.getKeyForAutomaticLookahead(n,e,t)},e.prototype.getLookaheadFuncForOr=function(e,t){var n=this.getKeyForAutomaticLookahead(i.OR_IDX,e),a=this.getLaFuncFromCache(n);if(void 0===a){var s=this.getCurrRuleFullName(),l=this.getGAstProductions().get(s),c=o.some(t,(function(e){return o.isFunction(e.GATE)}));return a=r.buildLookaheadFuncForOr(e,l,this.maxLookahead,c,this.dynamicTokensEnabled,this.lookAheadBuilderForAlternatives),this.setLaFuncCache(n,a),a}return a},e.prototype.getLookaheadFuncForOption=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,r.PROD_TYPE.OPTION)},e.prototype.getLookaheadFuncForMany=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,r.PROD_TYPE.REPETITION)},e.prototype.getLookaheadFuncForManySep=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,r.PROD_TYPE.REPETITION_WITH_SEPARATOR)},e.prototype.getLookaheadFuncForAtLeastOne=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY)},e.prototype.getLookaheadFuncForAtLeastOneSep=function(e,t){return this.getLookaheadFuncFor(e,t,this.maxLookahead,r.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)},e.prototype.getLookaheadFuncFor=function(e,t,n,o){var a=this.getLaFuncFromCache(e);if(void 0===a){var i=this.getCurrRuleFullName(),s=this.getGAstProductions().get(i);return a=r.buildLookaheadFuncForOptionalProd(t,s,n,this.dynamicTokensEnabled,o,this.lookAheadBuilderForOptional),this.setLaFuncCache(e,a),a}return a},e.prototype.getLaFuncFromCache=function(e){},e.prototype.getLaFuncFromMap=function(e){return this.lookAheadFuncsCache.get(e)},e.prototype.getLaFuncFromObj=function(e){return this.lookAheadFuncsCache[e]},e.prototype.setLaFuncCache=function(e,t){},e.prototype.setLaFuncCacheUsingMap=function(e,t){this.lookAheadFuncsCache.set(e,t)},e.prototype.setLaFuncUsingObj=function(e,t){this.lookAheadFuncsCache[e]=t},e}();t.LooksAhead=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(16),o=n(0),a=n(33),i=n(9),s=n(3),l=function(){function e(){}return e.prototype.initTreeBuilder=function(e){this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.outputCst=o.has(e,"outputCst")?e.outputCst:s.DEFAULT_PARSER_CONFIG.outputCst,this.outputCst||(this.cstInvocationStateUpdate=o.NOOP,this.cstFinallyStateUpdate=o.NOOP,this.cstPostTerminal=o.NOOP,this.cstPostNonTerminal=o.NOOP,this.getLastExplicitRuleShortName=this.getLastExplicitRuleShortNameNoCst,this.getPreviousExplicitRuleShortName=this.getPreviousExplicitRuleShortNameNoCst,this.getLastExplicitRuleOccurrenceIndex=this.getLastExplicitRuleOccurrenceIndexNoCst,this.manyInternal=this.manyInternalNoCst,this.orInternal=this.orInternalNoCst,this.optionInternal=this.optionInternalNoCst,this.atLeastOneInternal=this.atLeastOneInternalNoCst,this.manySepFirstInternal=this.manySepFirstInternalNoCst,this.atLeastOneSepFirstInternal=this.atLeastOneSepFirstInternalNoCst)},e.prototype.cstNestedInvocationStateUpdate=function(e,t){this.CST_STACK.push({name:e,fullName:this.shortRuleNameToFull.get(this.getLastExplicitRuleShortName())+e,children:{}})},e.prototype.cstInvocationStateUpdate=function(e,t){this.LAST_EXPLICIT_RULE_STACK.push(this.RULE_STACK.length-1),this.CST_STACK.push({name:e,children:{}})},e.prototype.cstFinallyStateUpdate=function(){this.LAST_EXPLICIT_RULE_STACK.pop(),this.CST_STACK.pop()},e.prototype.cstNestedFinallyStateUpdate=function(){this.CST_STACK.pop()},e.prototype.cstPostTerminal=function(e,t){var n=this.CST_STACK[this.CST_STACK.length-1];r.addTerminalToCst(n,t,e)},e.prototype.cstPostNonTerminal=function(e,t){r.addNoneTerminalToCst(this.CST_STACK[this.CST_STACK.length-1],t,e)},e.prototype.getBaseCstVisitorConstructor=function(){if(o.isUndefined(this.baseCstVisitorConstructor)){var e=a.createBaseSemanticVisitorConstructor(this.className,this.allRuleNames);return this.baseCstVisitorConstructor=e,e}return this.baseCstVisitorConstructor},e.prototype.getBaseCstVisitorConstructorWithDefaults=function(){if(o.isUndefined(this.baseCstVisitorWithDefaultsConstructor)){var e=a.createBaseVisitorConstructorWithDefaults(this.className,this.allRuleNames,this.getBaseCstVisitorConstructor());return this.baseCstVisitorWithDefaultsConstructor=e,e}return this.baseCstVisitorWithDefaultsConstructor},e.prototype.nestedRuleBeforeClause=function(e,t){var n;return void 0!==e.NAME?(n=e.NAME,this.nestedRuleInvocationStateUpdate(n,t),n):void 0},e.prototype.nestedAltBeforeClause=function(e,t,n,r){var o,a=this.getLastExplicitRuleShortName(),s=i.getKeyForAltIndex(a,n,t,r);return void 0!==e.NAME?(o=e.NAME,this.nestedRuleInvocationStateUpdate(o,s),{shortName:s,nestedName:o}):void 0},e.prototype.nestedRuleFinallyClause=function(e,t){var n=this.CST_STACK,o=n[n.length-1];this.nestedRuleFinallyStateUpdate();var a=n[n.length-1];r.addNoneTerminalToCst(a,t,o)},e.prototype.getLastExplicitRuleShortName=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_STACK[e]},e.prototype.getLastExplicitRuleShortNameNoCst=function(){var e=this.RULE_STACK;return e[e.length-1]},e.prototype.getPreviousExplicitRuleShortName=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-2];return this.RULE_STACK[e]},e.prototype.getPreviousExplicitRuleShortNameNoCst=function(){var e=this.RULE_STACK;return e[e.length-2]},e.prototype.getLastExplicitRuleOccurrenceIndex=function(){var e=this.LAST_EXPLICIT_RULE_STACK[this.LAST_EXPLICIT_RULE_STACK.length-1];return this.RULE_OCCURRENCE_STACK[e]},e.prototype.getLastExplicitRuleOccurrenceIndexNoCst=function(){var e=this.RULE_OCCURRENCE_STACK;return e[e.length-1]},e.prototype.nestedRuleInvocationStateUpdate=function(e,t){this.RULE_OCCURRENCE_STACK.push(1),this.RULE_STACK.push(t),this.cstNestedInvocationStateUpdate(e,t)},e.prototype.nestedRuleFinallyStateUpdate=function(){this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstNestedFinallyStateUpdate()},e}();t.TreeBuilder=l},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r,o=n(0),a=n(4),i=n(11);function s(e,t){for(var n=o.keys(e),r=n.length,a=0;a<r;a++)for(var i=e[n[a]],s=i.length,l=0;l<s;l++){var c=i[l];void 0===c.tokenTypeIdx&&(void 0!==c.fullName?this[c.fullName](c.children,t):this[c.name](c.children,t))}}function l(e,t){var n=c(e,t),r=u(e,t);return n.concat(r)}function c(e,t){var n=o.map(t,(function(t){if(!o.isFunction(e[t]))return{msg:"Missing visitor method: <"+t+"> on "+a.functionName(e.constructor)+" CST Visitor.",type:r.MISSING_METHOD,methodName:t}}));return o.compact(n)}t.defaultVisit=s,t.createBaseSemanticVisitorConstructor=function(e,t){var n=function(){};return a.defineNameProp(n,e+"BaseSemantics"),(n.prototype={visit:function(e,t){if(o.isArray(e)&&(e=e[0]),!o.isUndefined(e))return void 0!==e.fullName?this[e.fullName](e.children,t):this[e.name](e.children,t)},validateVisitor:function(){var e=l(this,t);if(!o.isEmpty(e)){var n=o.map(e,(function(e){return e.msg}));throw Error("Errors Detected in CST Visitor <"+a.functionName(this.constructor)+">:\n\t"+n.join("\n\n").replace(/\n/g,"\n\t"))}}}).constructor=n,n._RULE_NAMES=t,n},t.createBaseVisitorConstructorWithDefaults=function(e,t,n){var r=function(){};a.defineNameProp(r,e+"BaseSemanticsWithDefaults");var i=Object.create(n.prototype);return o.forEach(t,(function(e){i[e]=s})),(r.prototype=i).constructor=r,r},function(e){e[e.REDUNDANT_METHOD=0]="REDUNDANT_METHOD",e[e.MISSING_METHOD=1]="MISSING_METHOD"}(r=t.CstVisitorDefinitionError||(t.CstVisitorDefinitionError={})),t.validateVisitor=l,t.validateMissingCstMethods=c;var f=["constructor","visit","validateVisitor"];function u(e,t){var n=[];for(var s in e)i.validTermsPattern.test(s)&&o.isFunction(e[s])&&!o.contains(f,s)&&!o.contains(t,s)&&n.push({msg:"Redundant visitor method: <"+s+"> on "+a.functionName(e.constructor)+" CST Visitor\nThere is no Grammar Rule corresponding to this method's name.\nFor utility methods on visitor classes use methods names that do not match /"+i.validTermsPattern.source+"/.",type:r.REDUNDANT_METHOD,methodName:s});return n}t.validateRedundantMethods=u},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(3),o=function(){function e(){}return e.prototype.initLexerAdapter=function(){this.tokVector=[],this.tokVectorLength=0,this.currIdx=-1},Object.defineProperty(e.prototype,"input",{get:function(){return this.tokVector},set:function(e){this.reset(),this.tokVector=e,this.tokVectorLength=e.length},enumerable:!0,configurable:!0}),e.prototype.SKIP_TOKEN=function(){return this.currIdx<=this.tokVector.length-2?(this.consumeToken(),this.LA(1)):r.END_OF_FILE},e.prototype.LA=function(e){return this.currIdx+e<0||this.tokVectorLength<=this.currIdx+e?r.END_OF_FILE:this.tokVector[this.currIdx+e]},e.prototype.consumeToken=function(){this.currIdx++},e.prototype.exportLexerState=function(){return this.currIdx},e.prototype.importLexerState=function(e){this.currIdx=e},e.prototype.resetLexerState=function(){this.currIdx=-1},e.prototype.moveToTerminatedState=function(){this.currIdx=this.tokVector.length-1},e.prototype.getLexerPosition=function(){return this.exportLexerState()},e}();t.LexerAdapter=o},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(6),a=n(3),i=n(10),s=n(23),l=n(11),c=n(1),f=function(){function e(){}return e.prototype.CONSUME=function(e,t){return this.consumeInternal(e,0,t)},e.prototype.CONSUME1=function(e,t){return this.consumeInternal(e,1,t)},e.prototype.CONSUME2=function(e,t){return this.consumeInternal(e,2,t)},e.prototype.CONSUME3=function(e,t){return this.consumeInternal(e,3,t)},e.prototype.CONSUME4=function(e,t){return this.consumeInternal(e,4,t)},e.prototype.CONSUME5=function(e,t){return this.consumeInternal(e,5,t)},e.prototype.CONSUME6=function(e,t){return this.consumeInternal(e,6,t)},e.prototype.CONSUME7=function(e,t){return this.consumeInternal(e,7,t)},e.prototype.CONSUME8=function(e,t){return this.consumeInternal(e,8,t)},e.prototype.CONSUME9=function(e,t){return this.consumeInternal(e,9,t)},e.prototype.SUBRULE=function(e,t){return this.subruleInternal(e,0,t)},e.prototype.SUBRULE1=function(e,t){return this.subruleInternal(e,1,t)},e.prototype.SUBRULE2=function(e,t){return this.subruleInternal(e,2,t)},e.prototype.SUBRULE3=function(e,t){return this.subruleInternal(e,3,t)},e.prototype.SUBRULE4=function(e,t){return this.subruleInternal(e,4,t)},e.prototype.SUBRULE5=function(e,t){return this.subruleInternal(e,5,t)},e.prototype.SUBRULE6=function(e,t){return this.subruleInternal(e,6,t)},e.prototype.SUBRULE7=function(e,t){return this.subruleInternal(e,7,t)},e.prototype.SUBRULE8=function(e,t){return this.subruleInternal(e,8,t)},e.prototype.SUBRULE9=function(e,t){return this.subruleInternal(e,9,t)},e.prototype.OPTION=function(e){return this.optionInternal(e,0)},e.prototype.OPTION1=function(e){return this.optionInternal(e,1)},e.prototype.OPTION2=function(e){return this.optionInternal(e,2)},e.prototype.OPTION3=function(e){return this.optionInternal(e,3)},e.prototype.OPTION4=function(e){return this.optionInternal(e,4)},e.prototype.OPTION5=function(e){return this.optionInternal(e,5)},e.prototype.OPTION6=function(e){return this.optionInternal(e,6)},e.prototype.OPTION7=function(e){return this.optionInternal(e,7)},e.prototype.OPTION8=function(e){return this.optionInternal(e,8)},e.prototype.OPTION9=function(e){return this.optionInternal(e,9)},e.prototype.OR=function(e){return this.orInternal(e,0)},e.prototype.OR1=function(e){return this.orInternal(e,1)},e.prototype.OR2=function(e){return this.orInternal(e,2)},e.prototype.OR3=function(e){return this.orInternal(e,3)},e.prototype.OR4=function(e){return this.orInternal(e,4)},e.prototype.OR5=function(e){return this.orInternal(e,5)},e.prototype.OR6=function(e){return this.orInternal(e,6)},e.prototype.OR7=function(e){return this.orInternal(e,7)},e.prototype.OR8=function(e){return this.orInternal(e,8)},e.prototype.OR9=function(e){return this.orInternal(e,9)},e.prototype.MANY=function(e){this.manyInternal(0,e)},e.prototype.MANY1=function(e){this.manyInternal(1,e)},e.prototype.MANY2=function(e){this.manyInternal(2,e)},e.prototype.MANY3=function(e){this.manyInternal(3,e)},e.prototype.MANY4=function(e){this.manyInternal(4,e)},e.prototype.MANY5=function(e){this.manyInternal(5,e)},e.prototype.MANY6=function(e){this.manyInternal(6,e)},e.prototype.MANY7=function(e){this.manyInternal(7,e)},e.prototype.MANY8=function(e){this.manyInternal(8,e)},e.prototype.MANY9=function(e){this.manyInternal(9,e)},e.prototype.MANY_SEP=function(e){this.manySepFirstInternal(0,e)},e.prototype.MANY_SEP1=function(e){this.manySepFirstInternal(1,e)},e.prototype.MANY_SEP2=function(e){this.manySepFirstInternal(2,e)},e.prototype.MANY_SEP3=function(e){this.manySepFirstInternal(3,e)},e.prototype.MANY_SEP4=function(e){this.manySepFirstInternal(4,e)},e.prototype.MANY_SEP5=function(e){this.manySepFirstInternal(5,e)},e.prototype.MANY_SEP6=function(e){this.manySepFirstInternal(6,e)},e.prototype.MANY_SEP7=function(e){this.manySepFirstInternal(7,e)},e.prototype.MANY_SEP8=function(e){this.manySepFirstInternal(8,e)},e.prototype.MANY_SEP9=function(e){this.manySepFirstInternal(9,e)},e.prototype.AT_LEAST_ONE=function(e){this.atLeastOneInternal(0,e)},e.prototype.AT_LEAST_ONE1=function(e){return this.atLeastOneInternal(1,e)},e.prototype.AT_LEAST_ONE2=function(e){this.atLeastOneInternal(2,e)},e.prototype.AT_LEAST_ONE3=function(e){this.atLeastOneInternal(3,e)},e.prototype.AT_LEAST_ONE4=function(e){this.atLeastOneInternal(4,e)},e.prototype.AT_LEAST_ONE5=function(e){this.atLeastOneInternal(5,e)},e.prototype.AT_LEAST_ONE6=function(e){this.atLeastOneInternal(6,e)},e.prototype.AT_LEAST_ONE7=function(e){this.atLeastOneInternal(7,e)},e.prototype.AT_LEAST_ONE8=function(e){this.atLeastOneInternal(8,e)},e.prototype.AT_LEAST_ONE9=function(e){this.atLeastOneInternal(9,e)},e.prototype.AT_LEAST_ONE_SEP=function(e){this.atLeastOneSepFirstInternal(0,e)},e.prototype.AT_LEAST_ONE_SEP1=function(e){this.atLeastOneSepFirstInternal(1,e)},e.prototype.AT_LEAST_ONE_SEP2=function(e){this.atLeastOneSepFirstInternal(2,e)},e.prototype.AT_LEAST_ONE_SEP3=function(e){this.atLeastOneSepFirstInternal(3,e)},e.prototype.AT_LEAST_ONE_SEP4=function(e){this.atLeastOneSepFirstInternal(4,e)},e.prototype.AT_LEAST_ONE_SEP5=function(e){this.atLeastOneSepFirstInternal(5,e)},e.prototype.AT_LEAST_ONE_SEP6=function(e){this.atLeastOneSepFirstInternal(6,e)},e.prototype.AT_LEAST_ONE_SEP7=function(e){this.atLeastOneSepFirstInternal(7,e)},e.prototype.AT_LEAST_ONE_SEP8=function(e){this.atLeastOneSepFirstInternal(8,e)},e.prototype.AT_LEAST_ONE_SEP9=function(e){this.atLeastOneSepFirstInternal(9,e)},e.prototype.RULE=function(e,t,n){if(void 0===n&&(n=a.DEFAULT_RULE_CONFIG),r.contains(this.definedRulesNames,e)){var o={message:i.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({topLevelRule:e,grammarName:this.className}),type:a.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,ruleName:e};this.definitionErrors.push(o)}if(this.definedRulesNames.push(e),!this.gastProductionsCache.containsKey(e)&&!this.serializedGrammar){var l=s.buildTopProduction(t.toString(),e,this.tokensMap);this.gastProductionsCache.put(e,l)}var c=this.defineRule(e,t,n);return this[e]=c,c},e.prototype.OVERRIDE_RULE=function(e,t,n){void 0===n&&(n=a.DEFAULT_RULE_CONFIG);var r=[];if(r=r.concat(l.validateRuleIsOverridden(e,this.definedRulesNames,this.className)),this.definitionErrors.push.apply(this.definitionErrors,r),!this.serializedGrammar){var o=s.buildTopProduction(t.toString(),e,this.tokensMap);this.gastProductionsCache.put(e,o)}var i=this.defineRule(e,t,n);return this[e]=i,i},e.prototype.BACKTRACK=function(e,t){return function(){this.isBackTrackingStack.push(1);var n=this.saveRecogState();try{return e.apply(this,t),!0}catch(e){if(o.isRecognitionException(e))return!1;throw e}finally{this.reloadRecogState(n),this.isBackTrackingStack.pop()}}},e.prototype.getGAstProductions=function(){return this.gastProductionsCache},e.prototype.getSerializedGastProductions=function(){return c.serializeGrammar(this.gastProductionsCache.values())},e}();t.RecognizerApi=f},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(9),a=n(6),i=n(12),s=n(13),l=n(3),c=n(25),f=n(2),u=n(7),d=n(4),p=function(){function e(){}return e.prototype.initRecognizerEngine=function(e,t){if(this.className=d.classNameFromInstance(this),this.shortRuleNameToFull=new d.HashTable,this.fullRuleNameToShort=new d.HashTable,this.ruleShortNameIdx=256,this.tokenMatcher=u.tokenStructuredMatcherNoCategories,this.definedRulesNames=[],this.tokensMap={},this.allRuleNames=[],this.isBackTrackingStack=[],this.RULE_STACK=[],this.RULE_OCCURRENCE_STACK=[],this.gastProductionsCache=new d.HashTable,this.serializedGrammar=r.has(t,"serializedGrammar")?t.serializedGrammar:l.DEFAULT_PARSER_CONFIG.serializedGrammar,r.isArray(e)){if(r.isEmpty(e))throw Error("A Token Vocabulary cannot be empty.\n\tNote that the first argument for the parser constructor\n\tis no longer a Token vector (since v4.0).");if("number"==typeof e[0].startOffset)throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n\tSee: https://sap.github.io/chevrotain/docs/changes/BREAKING_CHANGES.html#_4-0-0\n\tFor Further details.")}if(r.isArray(e))this.tokensMap=r.reduce(e,(function(e,t){return e[f.tokenName(t)]=t,e}),{});else if(r.has(e,"modes")&&r.every(r.flatten(r.values(e.modes)),u.isTokenType)){var n=r.flatten(r.values(e.modes)),o=r.uniq(n);this.tokensMap=r.reduce(o,(function(e,t){return e[f.tokenName(t)]=t,e}),{})}else{if(!r.isObject(e))throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");this.tokensMap=r.cloneObj(e)}this.tokensMap.EOF=f.EOF;var a=r.every(r.values(e),(function(e){return r.isEmpty(e.categoryMatches)}));this.tokenMatcher=a?u.tokenStructuredMatcherNoCategories:u.tokenStructuredMatcher,u.augmentTokenTypes(r.values(this.tokensMap))},e.prototype.defineRule=function(e,t,n){if(this.selfAnalysisDone)throw Error("Grammar rule <"+e+"> may not be defined after the 'performSelfAnalysis' method has been called'\nMake sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");var i,s=r.has(n,"resyncEnabled")?n.resyncEnabled:l.DEFAULT_RULE_CONFIG.resyncEnabled,c=r.has(n,"recoveryValueFunc")?n.recoveryValueFunc:l.DEFAULT_RULE_CONFIG.recoveryValueFunc,f=this.ruleShortNameIdx<<o.BITS_FOR_METHOD_IDX+o.BITS_FOR_OCCURRENCE_IDX;return this.ruleShortNameIdx++,this.shortRuleNameToFull.put(f,e),this.fullRuleNameToShort.put(e,f),(i=function(n,r){return void 0===n&&(n=0),this.ruleInvocationStateUpdate(f,e,n),function(e){try{return!0===this.outputCst?(t.apply(this,e),this.CST_STACK[this.CST_STACK.length-1]):t.apply(this,e)}catch(e){var n=1===this.RULE_STACK.length,r=s&&!this.isBackTracking()&&this.recoveryEnabled;if(a.isRecognitionException(e)){if(r){var o,i=this.findReSyncTokenType();if(this.isInCurrentRuleReSyncSet(i))return e.resyncedTokens=this.reSyncTo(i),this.outputCst?((o=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,o):c();throw this.outputCst&&((o=this.CST_STACK[this.CST_STACK.length-1]).recoveredNode=!0,e.partialCstResult=o),e}if(n)return this.moveToTerminatedState(),c();throw e}throw e}finally{this.ruleFinallyStateUpdate()}}.call(this,r)}).ruleName=e,i},e.prototype.optionInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.OPTION_IDX,t),r=this.nestedRuleBeforeClause(e,n);try{return this.optionInternalLogic(e,t,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r)}},e.prototype.optionInternalNoCst=function(e,t){var n=this.getKeyForAutomaticLookahead(o.OPTION_IDX,t);return this.optionInternalLogic(e,t,n)},e.prototype.optionInternalLogic=function(e,t,n){var r,o,a=this,i=this.getLookaheadFuncForOption(n,t);if(void 0!==e.DEF){if(r=e.DEF,void 0!==(o=e.GATE)){var s=i;i=function(){return o.call(a)&&s.call(a)}}}else r=e;if(!0===i.call(this))return r.call(this)},e.prototype.atLeastOneInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.AT_LEAST_ONE_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{return this.atLeastOneInternalLogic(e,t,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r)}},e.prototype.atLeastOneInternalNoCst=function(e,t){var n=this.getKeyForAutomaticLookahead(o.AT_LEAST_ONE_IDX,e);this.atLeastOneInternalLogic(e,t,n)},e.prototype.atLeastOneInternalLogic=function(e,t,n){var r,a,l=this,c=this.getLookaheadFuncForAtLeastOne(n,e);if(void 0!==t.DEF){if(r=t.DEF,void 0!==(a=t.GATE)){var f=c;c=function(){return a.call(l)&&f.call(l)}}}else r=t;if(!0!==c.call(this))throw this.raiseEarlyExitException(e,i.PROD_TYPE.REPETITION_MANDATORY,t.ERR_MSG);for(var u=this.doSingleRepetition(r);!0===c.call(this)&&!0===u;)u=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.atLeastOneInternal,[e,t],c,o.AT_LEAST_ONE_IDX,e,s.NextTerminalAfterAtLeastOneWalker)},e.prototype.atLeastOneSepFirstInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.AT_LEAST_ONE_SEP_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{this.atLeastOneSepFirstInternalLogic(e,t,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r)}},e.prototype.atLeastOneSepFirstInternalNoCst=function(e,t){var n=this.getKeyForAutomaticLookahead(o.AT_LEAST_ONE_SEP_IDX,e);this.atLeastOneSepFirstInternalLogic(e,t,n)},e.prototype.atLeastOneSepFirstInternalLogic=function(e,t,n){var r=this,a=t.DEF,l=t.SEP;if(!0!==this.getLookaheadFuncForAtLeastOneSep(n,e).call(this))throw this.raiseEarlyExitException(e,i.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,t.ERR_MSG);a.call(this);for(var c=function(){return r.tokenMatcher(r.LA(1),l)};!0===this.tokenMatcher(this.LA(1),l);)this.CONSUME(l),a.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,l,c,a,s.NextTerminalAfterAtLeastOneSepWalker],c,o.AT_LEAST_ONE_SEP_IDX,e,s.NextTerminalAfterAtLeastOneSepWalker)},e.prototype.manyInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.MANY_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{return this.manyInternalLogic(e,t,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r)}},e.prototype.manyInternalNoCst=function(e,t){var n=this.getKeyForAutomaticLookahead(o.MANY_IDX,e);return this.manyInternalLogic(e,t,n)},e.prototype.manyInternalLogic=function(e,t,n){var r,a,i=this,l=this.getLookaheadFuncForMany(n,e);if(void 0!==t.DEF){if(r=t.DEF,void 0!==(a=t.GATE)){var c=l;l=function(){return a.call(i)&&c.call(i)}}}else r=t;for(var f=!0;!0===l.call(this)&&!0===f;)f=this.doSingleRepetition(r);this.attemptInRepetitionRecovery(this.manyInternal,[e,t],l,o.MANY_IDX,e,s.NextTerminalAfterManyWalker)},e.prototype.manySepFirstInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.MANY_SEP_IDX,e),r=this.nestedRuleBeforeClause(t,n);try{this.manySepFirstInternalLogic(e,t,n)}finally{void 0!==r&&this.nestedRuleFinallyClause(n,r)}},e.prototype.manySepFirstInternalNoCst=function(e,t){var n=this.getKeyForAutomaticLookahead(o.MANY_SEP_IDX,e);this.manySepFirstInternalLogic(e,t,n)},e.prototype.manySepFirstInternalLogic=function(e,t,n){var r=this,a=t.DEF,i=t.SEP;if(!0===this.getLookaheadFuncForManySep(n,e).call(this)){a.call(this);for(var l=function(){return r.tokenMatcher(r.LA(1),i)};!0===this.tokenMatcher(this.LA(1),i);)this.CONSUME(i),a.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,i,l,a,s.NextTerminalAfterManySepWalker],l,o.MANY_SEP_IDX,e,s.NextTerminalAfterManySepWalker)}},e.prototype.repetitionSepSecondInternal=function(e,t,n,r,a){for(;n();)this.CONSUME(t),r.call(this);this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal,[e,t,n,r,a],n,o.AT_LEAST_ONE_SEP_IDX,e,a)},e.prototype.doSingleRepetition=function(e){var t=this.getLexerPosition();return e.call(this),this.getLexerPosition()>t},e.prototype.orInternalNoCst=function(e,t){var n=r.isArray(e)?e:e.DEF,o=this.getLookaheadFuncForOr(t,n).call(this,n);if(void 0!==o)return n[o].ALT.call(this);this.raiseNoAltException(t,e.ERR_MSG)},e.prototype.orInternal=function(e,t){var n=this.getKeyForAutomaticLookahead(o.OR_IDX,t),a=this.nestedRuleBeforeClause(e,n);try{var i=r.isArray(e)?e:e.DEF,s=this.getLookaheadFuncForOr(t,i).call(this,i);if(void 0!==s){var l=i[s],c=this.nestedAltBeforeClause(l,t,o.OR_IDX,s);try{return l.ALT.call(this)}finally{void 0!==c&&this.nestedRuleFinallyClause(c.shortName,c.nestedName)}}this.raiseNoAltException(t,e.ERR_MSG)}finally{void 0!==a&&this.nestedRuleFinallyClause(n,a)}},e.prototype.ruleFinallyStateUpdate=function(){if(this.RULE_STACK.pop(),this.RULE_OCCURRENCE_STACK.pop(),this.cstFinallyStateUpdate(),0===this.RULE_STACK.length&&!this.isAtEndOfInput()){var e=this.LA(1),t=this.errorMessageProvider.buildNotAllInputParsedMessage({firstRedundant:e,ruleName:this.getCurrRuleFullName()});this.SAVE_ERROR(new a.NotAllInputParsedException(t,e))}},e.prototype.subruleInternal=function(e,t,n){var r;try{var o=void 0!==n?n.ARGS:void 0;return r=e.call(this,t,o),this.cstPostNonTerminal(r,void 0!==n&&void 0!==n.LABEL?n.LABEL:e.ruleName),r}catch(t){throw a.isRecognitionException(t)&&void 0!==t.partialCstResult&&(this.cstPostNonTerminal(t.partialCstResult,void 0!==n&&void 0!==n.LABEL?n.LABEL:e.ruleName),delete t.partialCstResult),t}},e.prototype.consumeInternal=function(e,t,n){var r;try{var o=this.LA(1);if(!0!==this.tokenMatcher(o,e)){var i=void 0,s=this.LA(0);throw i=void 0!==n&&n.ERR_MSG?n.ERR_MSG:this.errorMessageProvider.buildMismatchTokenMessage({expected:e,actual:o,previous:s,ruleName:this.getCurrRuleFullName()}),this.SAVE_ERROR(new a.MismatchedTokenException(i,o,s))}this.consumeToken(),r=o}catch(n){if(!this.recoveryEnabled||"MismatchedTokenException"!==n.name||this.isBackTracking())throw n;var l=this.getFollowsForInRuleRecovery(e,t);try{r=this.tryInRuleRecovery(e,l)}catch(e){throw e.name===c.IN_RULE_RECOVERY_EXCEPTION?n:e}}return this.cstPostTerminal(void 0!==n&&void 0!==n.LABEL?n.LABEL:e.tokenName,r),r},e.prototype.saveRecogState=function(){var e=this.errors,t=r.cloneArr(this.RULE_STACK);return{errors:e,lexerState:this.exportLexerState(),RULE_STACK:t,CST_STACK:this.CST_STACK,LAST_EXPLICIT_RULE_STACK:this.LAST_EXPLICIT_RULE_STACK}},e.prototype.reloadRecogState=function(e){this.errors=e.errors,this.importLexerState(e.lexerState),this.RULE_STACK=e.RULE_STACK},e.prototype.ruleInvocationStateUpdate=function(e,t,n){this.RULE_OCCURRENCE_STACK.push(n),this.RULE_STACK.push(e),this.cstInvocationStateUpdate(t,e)},e.prototype.isBackTracking=function(){return!r.isEmpty(this.isBackTrackingStack)},e.prototype.getCurrRuleFullName=function(){var e=this.getLastExplicitRuleShortName();return this.shortRuleNameToFull.get(e)},e.prototype.shortRuleNameToFullName=function(e){return this.shortRuleNameToFull.get(e)},e.prototype.isAtEndOfInput=function(){return this.tokenMatcher(this.LA(1),f.EOF)},e.prototype.reset=function(){this.resetLexerState(),this.isBackTrackingStack=[],this.errors=[],this.RULE_STACK=[],this.LAST_EXPLICIT_RULE_STACK=[],this.CST_STACK=[],this.RULE_OCCURRENCE_STACK=[]},e}();t.RecognizerEngine=p},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(6),o=n(0),a=n(12),i=n(3),s=function(){function e(){}return e.prototype.initErrorHandler=function(e){this._errors=[],this.errorMessageProvider=o.defaults(e.errorMessageProvider,i.DEFAULT_PARSER_CONFIG.errorMessageProvider)},e.prototype.SAVE_ERROR=function(e){if(r.isRecognitionException(e))return e.context={ruleStack:this.getHumanReadableRuleStack(),ruleOccurrenceStack:o.cloneArr(this.RULE_OCCURRENCE_STACK)},this._errors.push(e),e;throw Error("Trying to save an Error which is not a RecognitionException")},Object.defineProperty(e.prototype,"errors",{get:function(){return o.cloneArr(this._errors)},set:function(e){this._errors=e},enumerable:!0,configurable:!0}),e.prototype.raiseEarlyExitException=function(e,t,n){for(var o=this.getCurrRuleFullName(),i=this.getGAstProductions().get(o),s=a.getLookaheadPathsForOptionalProd(e,i,t,this.maxLookahead)[0],l=[],c=1;c<this.maxLookahead;c++)l.push(this.LA(c));var f=this.errorMessageProvider.buildEarlyExitMessage({expectedIterationPaths:s,actual:l,previous:this.LA(0),customUserDescription:n,ruleName:o});throw this.SAVE_ERROR(new r.EarlyExitException(f,this.LA(1),this.LA(0)))},e.prototype.raiseNoAltException=function(e,t){for(var n=this.getCurrRuleFullName(),o=this.getGAstProductions().get(n),i=a.getLookaheadPathsForOr(e,o,this.maxLookahead),s=[],l=1;l<=this.maxLookahead;l++)s.push(this.LA(l));var c=this.LA(0),f=this.errorMessageProvider.buildNoViableAltMessage({expectedPathsPerAlt:i,actual:s,previous:c,customUserDescription:t,ruleName:this.getCurrRuleFullName()});throw this.SAVE_ERROR(new r.NoViableAltException(f,this.LA(1),c))},e}();t.ErrorHandler=s},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(13),o=n(0),a=function(){function e(){}return e.prototype.initContentAssist=function(){},e.prototype.computeContentAssist=function(e,t){var n=this.gastProductionsCache.get(e);if(o.isUndefined(n))throw Error("Rule ->"+e+"<- does not exist in this grammar.");return r.nextPossibleTokensAfter([n],t,this.tokenMatcher,this.maxLookahead)},e.prototype.getNextPossibleTokenTypes=function(e){var t=o.first(e.ruleStack),n=this.getGAstProductions().get(t);return new r.NextAfterTokenWalker(n,e).startWalking()},e}();t.ContentAssist=a},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(17);t.createSyntaxDiagramsCode=function(e,t){var n=void 0===t?{}:t,o=n.resourceBase,a=void 0===o?"https://unpkg.com/chevrotain@"+r.VERSION+"/diagrams/":o,i=n.css;return"\n\x3c!-- This is a generated file --\x3e\n<!DOCTYPE html>\n<meta charset=\"utf-8\">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n\n<link rel='stylesheet' href='"+(void 0===i?"https://unpkg.com/chevrotain@"+r.VERSION+"/diagrams/diagrams.css":i)+"'>\n\n<script src='"+a+"vendor/railroad-diagrams.js'><\/script>\n<script src='"+a+"src/diagrams_builder.js'><\/script>\n<script src='"+a+"src/diagrams_behavior.js'><\/script>\n<script src='"+a+'src/main.js\'><\/script>\n\n<div id="diagrams" align="center"></div>    \n\n<script>\n    window.serializedGrammar = '+JSON.stringify(e,null,"  ")+';\n<\/script>\n\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n<\/script>\n'}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(41);t.generateParserFactory=function(e){var t=r.genWrapperFunction({name:e.name,rules:e.rules}),o=new Function("tokenVocabulary","config","chevrotain",t);return function(t){return o(e.tokenVocabulary,t,n(18))}},t.generateParserModule=function(e){return r.genUmdModule({name:e.name,rules:e.rules})}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n(0),o=n(2),a=n(1),i="\n";function s(e){return"\nfunction "+e.name+"(tokenVocabulary, config) {\n    // invoke super constructor\n    // No support for embedded actions currently, so we can 'hardcode'\n    // The use of CstParser.\n    chevrotain.CstParser.call(this, tokenVocabulary, config)\n\n    const $ = this\n\n    "+l(e.rules)+"\n\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    this.performSelfAnalysis(this)\n}\n\n// inheritance as implemented in javascript in the previous decade... :(\n"+e.name+".prototype = Object.create(chevrotain.CstParser.prototype)\n"+e.name+".prototype.constructor = "+e.name+"    \n    "}function l(e){return r.map(e,(function(e){return c(e,1)})).join("\n")}function c(e,t){var n=x(t,'$.RULE("'+e.name+'", function() {')+i;return(n+=m(e.definition,t+1))+(x(t+1,"})")+i)}function f(e,t){var n=o.tokenName(e.terminalType);return x(t,"$.CONSUME"+e.idx+"(this.tokensMap."+n+")"+i)}function u(e,t){return x(t,"$.SUBRULE"+e.idx+"($."+e.nonTerminalName+")"+i)}function d(e,t){var n=x(t,"$.OR"+e.idx+"([")+i;return(n+=r.map(e.definition,(function(e){return p(e,t+1)})).join(","+i))+(i+x(t,"])"+i))}function p(e,t){var n=x(t,"{")+i;return e.name&&(n+=x(t+1,'NAME: "'+e.name+'",')+i),n+=x(t+1,"ALT: function() {")+i,n+=m(e.definition,t+1),(n+=x(t+1,"}")+i)+x(t,"}")}function h(e,t,n){var r=x(n,"$."+(e+t.idx)+"(");return t.name||t.separator?(r+="{"+i,t.name&&(r+=x(n+1,'NAME: "'+t.name+'"')+","+i),t.separator&&(r+=x(n+1,"SEP: this.tokensMap."+o.tokenName(t.separator))+","+i),r+="DEF: "+v(t.definition,n+2)+i,r+=x(n,"}")+i):r+=v(t.definition,n+1),r+(x(n,")")+i)}function v(e,t){var n="function() {"+i;return(n+=m(e,t))+(x(t,"}")+i)}function m(e,t){var n="";return r.forEach(e,(function(e){n+=function(e,t){if(e instanceof a.NonTerminal)return u(e,t);if(e instanceof a.Option)return h("OPTION",e,t);if(e instanceof a.RepetitionMandatory)return h("AT_LEAST_ONE",e,t);if(e instanceof a.RepetitionMandatoryWithSeparator)return h("AT_LEAST_ONE_SEP",e,t);if(e instanceof a.RepetitionWithSeparator)return h("MANY_SEP",e,t);if(e instanceof a.Repetition)return h("MANY",e,t);if(e instanceof a.Alternation)return d(e,t);if(e instanceof a.Terminal)return f(e,t);if(e instanceof a.Flat)return m(e.definition,t);throw Error("non exhaustive match")}(e,t+1)})),n}function x(e,t){return Array(4*e+1).join(" ")+t}t.genUmdModule=function(e){return"\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['chevrotain'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory(require('chevrotain'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.b);\n    }\n}(typeof self !== 'undefined' ? self : this, function (chevrotain) {\n\n"+s(e)+"\n    \nreturn {\n    "+e.name+": "+e.name+" \n}\n}));\n"},t.genWrapperFunction=function(e){return"    \n"+s(e)+"\nreturn new "+e.name+"(tokenVocabulary, config)    \n"},t.genClass=s,t.genAllRules=l,t.genRule=c,t.genTerminal=f,t.genNonTerminal=u,t.genAlternation=d,t.genSingleAlt=p}])},6549:function(e){e.exports=function(){"use strict";var e=Math.pow(2,-52),t=function(t){var i=t.length>>1;if(i>0&&"number"!=typeof t[0])throw new Error("Expected coords to contain numbers.");this.coords=t;var s=2*i-5,l=this.triangles=new Uint32Array(3*s),c=this.halfedges=new Int32Array(3*s);this._hashSize=Math.ceil(Math.sqrt(i));for(var f=this.hullPrev=new Uint32Array(i),u=this.hullNext=new Uint32Array(i),d=this.hullTri=new Uint32Array(i),p=new Int32Array(this._hashSize).fill(-1),h=new Uint32Array(i),v=1/0,m=1/0,x=-1/0,g=-1/0,y=0;y<i;y++){var E=t[2*y],w=t[2*y+1];E<v&&(v=E),w<m&&(m=w),E>x&&(x=E),w>g&&(g=w),h[y]=y}for(var b,_,T,A=(v+x)/2,S=(m+g)/2,R=1/0,M=0;M<i;M++){var C=n(A,S,t[2*M],t[2*M+1]);C<R&&(b=M,R=C)}var L=t[2*b],P=t[2*b+1];R=1/0;for(var k=0;k<i;k++)if(k!==b){var N=n(L,P,t[2*k],t[2*k+1]);N<R&&N>0&&(_=k,R=N)}for(var H=t[2*_],z=t[2*_+1],D=1/0,F=0;F<i;F++)if(F!==b&&F!==_){var I=o(L,P,H,z,t[2*F],t[2*F+1]);I<D&&(T=F,D=I)}var O=t[2*T],U=t[2*T+1];if(D===1/0)throw new Error("No Delaunay triangulation exists for this input.");if(r(L,P,H,z,O,U)){var G=_,B=H,V=z;_=T,H=O,z=U,T=G,O=B,U=V}var W=function(e,t,n,r,o,a){var i=n-e,s=r-t,l=o-e,c=a-t,f=i*i+s*s,u=l*l+c*c,d=.5/(i*c-s*l);return{x:e+(c*f-s*u)*d,y:t+(i*u-l*f)*d}}(L,P,H,z,O,U);this._cx=W.x,this._cy=W.y;for(var j=new Float64Array(i),q=0;q<i;q++)j[q]=n(t[2*q],t[2*q+1],W.x,W.y);!function e(t,n,r,o){if(o-r<=20)for(var i=r+1;i<=o;i++){for(var s=t[i],l=n[s],c=i-1;c>=r&&n[t[c]]>l;)t[c+1]=t[c--];t[c+1]=s}else{var f=r+1,u=o;a(t,r+o>>1,f),n[t[r]]>n[t[o]]&&a(t,r,o),n[t[f]]>n[t[o]]&&a(t,f,o),n[t[r]]>n[t[f]]&&a(t,r,f);for(var d=t[f],p=n[d];;){do{f++}while(n[t[f]]<p);do{u--}while(n[t[u]]>p);if(u<f)break;a(t,f,u)}t[r+1]=t[u],t[u]=d,o-f+1>=u-r?(e(t,n,f,o),e(t,n,r,u-1)):(e(t,n,r,u-1),e(t,n,f,o))}}(h,j,0,i-1),this.hullStart=b;var X=3;u[b]=f[T]=_,u[_]=f[b]=T,u[T]=f[_]=b,d[b]=0,d[_]=1,d[T]=2,p[this._hashKey(L,P)]=b,p[this._hashKey(H,z)]=_,p[this._hashKey(O,U)]=T,this.trianglesLen=0,this._addTriangle(b,_,T,-1,-1,-1);for(var Y=0,Q=void 0,K=void 0;Y<h.length;Y++){var Z=h[Y],J=t[2*Z],$=t[2*Z+1];if(!(Y>0&&Math.abs(J-Q)<=e&&Math.abs($-K)<=e)&&(Q=J,K=$,Z!==b&&Z!==_&&Z!==T)){for(var ee=0,te=0,ne=this._hashKey(J,$);te<this._hashSize&&(-1===(ee=p[(ne+te)%this._hashSize])||ee===u[ee]);te++);for(var re=ee=f[ee],oe=void 0;oe=u[re],!r(J,$,t[2*re],t[2*re+1],t[2*oe],t[2*oe+1]);)if((re=oe)===ee){re=-1;break}if(-1!==re){var ae=this._addTriangle(re,Z,u[re],-1,-1,d[re]);d[Z]=this._legalize(ae+2),d[re]=ae,X++;for(var ie=u[re];oe=u[ie],r(J,$,t[2*ie],t[2*ie+1],t[2*oe],t[2*oe+1]);)ae=this._addTriangle(ie,Z,oe,d[Z],-1,d[ie]),d[Z]=this._legalize(ae+2),u[ie]=ie,X--,ie=oe;if(re===ee)for(;r(J,$,t[2*(oe=f[re])],t[2*oe+1],t[2*re],t[2*re+1]);)ae=this._addTriangle(oe,Z,re,-1,d[re],d[oe]),this._legalize(ae+2),d[oe]=ae,u[re]=re,X--,re=oe;this.hullStart=f[Z]=re,u[re]=f[ie]=Z,u[Z]=ie,p[this._hashKey(J,$)]=Z,p[this._hashKey(t[2*re],t[2*re+1])]=re}}}this.hull=new Uint32Array(X);for(var se=0,le=this.hullStart;se<X;se++)this.hull[se]=le,le=u[le];this.hullPrev=this.hullNext=this.hullTri=null,this.triangles=l.subarray(0,this.trianglesLen),this.halfedges=c.subarray(0,this.trianglesLen)};function n(e,t,n,r){var o=e-n,a=t-r;return o*o+a*a}function r(e,t,n,r,o,a){return(r-t)*(o-n)-(n-e)*(a-r)<0}function o(e,t,n,r,o,a){var i=n-e,s=r-t,l=o-e,c=a-t,f=i*i+s*s,u=l*l+c*c,d=.5/(i*c-s*l),p=(c*f-s*u)*d,h=(i*u-l*f)*d;return p*p+h*h}function a(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function i(e){return e[0]}function s(e){return e[1]}return t.from=function(e,n,r){void 0===n&&(n=i),void 0===r&&(r=s);for(var o=e.length,a=new Float64Array(2*o),l=0;l<o;l++){var c=e[l];a[2*l]=n(c),a[2*l+1]=r(c)}return new t(a)},t.prototype._hashKey=function(e,t){return Math.floor((n=e-this._cx,r=t-this._cy,o=n/(Math.abs(n)+Math.abs(r)),(r>0?3-o:1+o)/4*this._hashSize))%this._hashSize;var n,r,o},t.prototype._legalize=function(e){var t=this.triangles,n=this.coords,r=this.halfedges,o=r[e],a=e-e%3,i=o-o%3,s=a+(e+1)%3,l=a+(e+2)%3,c=i+(o+2)%3;if(-1===o)return l;var f,u,d,p,h,v,m,x,g,y,E,w,b,_,T,A,S=t[l],R=t[e],M=t[s],C=t[c];if(f=n[2*S],u=n[2*S+1],d=n[2*R],p=n[2*R+1],h=n[2*M],v=n[2*M+1],(g=f-(m=n[2*C]))*((w=p-(x=n[2*C+1]))*(A=(b=h-m)*b+(_=v-x)*_)-(T=(E=d-m)*E+w*w)*_)-(y=u-x)*(E*A-T*b)+(g*g+y*y)*(E*_-w*b)<0){t[e]=C,t[o]=S;var L=r[c];if(-1===L){var P=this.hullStart;do{if(this.hullTri[P]===c){this.hullTri[P]=e;break}P=this.hullNext[P]}while(P!==this.hullStart)}this._link(e,L),this._link(o,r[l]),this._link(l,c);var k=i+(o+1)%3;return this._legalize(e),this._legalize(k)}return l},t.prototype._link=function(e,t){this.halfedges[e]=t,-1!==t&&(this.halfedges[t]=e)},t.prototype._addTriangle=function(e,t,n,r,o,a){var i=this.trianglesLen;return this.triangles[i]=e,this.triangles[i+1]=t,this.triangles[i+2]=n,this._link(i,r),this._link(i+1,o),this._link(i+2,a),this.trianglesLen+=3,i},t}()},16:(e,t,n)=>{var r;!function(){"use strict";var o=function(){this.init()};o.prototype={init:function(){var e=this||a;return e._counter=1e3,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.mobileAutoEnable=!0,e._setup(),e},volume:function(e){var t=this||a;if(e=parseFloat(e),t.ctx||p(),void 0!==e&&e>=0&&e<=1){if(t._volume=e,t._muted)return t;t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e,a.ctx.currentTime);for(var n=0;n<t._howls.length;n++)if(!t._howls[n]._webAudio)for(var r=t._howls[n]._getSoundIds(),o=0;o<r.length;o++){var i=t._howls[n]._soundById(r[o]);i&&i._node&&(i._node.volume=i._volume*e)}return t}return t._volume},mute:function(e){var t=this||a;t.ctx||p(),t._muted=e,t.usingWebAudio&&t.masterGain.gain.setValueAtTime(e?0:t._volume,a.ctx.currentTime);for(var n=0;n<t._howls.length;n++)if(!t._howls[n]._webAudio)for(var r=t._howls[n]._getSoundIds(),o=0;o<r.length;o++){var i=t._howls[n]._soundById(r[o]);i&&i._node&&(i._node.muted=!!e||i._muted)}return t},unload:function(){for(var e=this||a,t=e._howls.length-1;t>=0;t--)e._howls[t].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,p()),e},codecs:function(e){return(this||a)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||a;if(e.state=e.ctx&&e.ctx.state||"running",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{void 0===(new Audio).oncanplaythrough&&(e._canPlayEvent="canplay")}catch(t){e.noAudio=!0}else e.noAudio=!0;try{(new Audio).muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||a,t=null;try{t="undefined"!=typeof Audio?new Audio:null}catch(t){return e}if(!t||"function"!=typeof t.canPlayType)return e;var n=t.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator&&e._navigator.userAgent.match(/OPR\/([0-6].)/g),o=r&&parseInt(r[0].split("/")[1],10)<33;return e._codecs={mp3:!(o||!n&&!t.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!n,opus:!!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!t.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),aac:!!t.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!t.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(t.canPlayType("audio/x-m4a;")||t.canPlayType("audio/m4a;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(t.canPlayType("audio/x-mp4;")||t.canPlayType("audio/mp4;")||t.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),webm:!!t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,""),dolby:!!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(t.canPlayType("audio/x-flac;")||t.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_enableMobileAudio:function(){var e=this||a,t=/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(e._navigator&&e._navigator.userAgent),n=!!("ontouchend"in window||e._navigator&&e._navigator.maxTouchPoints>0||e._navigator&&e._navigator.msMaxTouchPoints>0);if(!e._mobileEnabled&&e.ctx&&(t||n)){e._mobileEnabled=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var r=function(){a._autoResume();var t=e.ctx.createBufferSource();t.buffer=e._scratchBuffer,t.connect(e.ctx.destination),void 0===t.start?t.noteOn(0):t.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),t.onended=function(){t.disconnect(0),e._mobileEnabled=!0,e.mobileAutoEnable=!1,document.removeEventListener("touchstart",r,!0),document.removeEventListener("touchend",r,!0)}};return document.addEventListener("touchstart",r,!0),document.addEventListener("touchend",r,!0),e}},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&a.usingWebAudio){for(var t=0;t<e._howls.length;t++)if(e._howls[t]._webAudio)for(var n=0;n<e._howls[t]._sounds.length;n++)if(!e._howls[t]._sounds[n]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout((function(){e.autoSuspend&&(e._suspendTimer=null,e.state="suspending",e.ctx.suspend().then((function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())})))}),3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&a.usingWebAudio)return"running"===e.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state?(e.ctx.resume().then((function(){e.state="running";for(var t=0;t<e._howls.length;t++)e._howls[t]._emit("resume")})),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var a=new o,i=function(e){e.src&&0!==e.src.length?this.init(e):console.error("An array of source files must be passed with any new Howl.")};i.prototype={init:function(e){var t=this;return a.ctx||p(),t._autoplay=e.autoplay||!1,t._format="string"!=typeof e.format?e.format:[e.format],t._html5=e.html5||!1,t._muted=e.mute||!1,t._loop=e.loop||!1,t._pool=e.pool||5,t._preload="boolean"!=typeof e.preload||e.preload,t._rate=e.rate||1,t._sprite=e.sprite||{},t._src="string"!=typeof e.src?e.src:[e.src],t._volume=void 0!==e.volume?e.volume:1,t._xhrWithCredentials=e.xhrWithCredentials||!1,t._duration=0,t._state="unloaded",t._sounds=[],t._endTimers={},t._queue=[],t._playLock=!1,t._onend=e.onend?[{fn:e.onend}]:[],t._onfade=e.onfade?[{fn:e.onfade}]:[],t._onload=e.onload?[{fn:e.onload}]:[],t._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],t._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],t._onpause=e.onpause?[{fn:e.onpause}]:[],t._onplay=e.onplay?[{fn:e.onplay}]:[],t._onstop=e.onstop?[{fn:e.onstop}]:[],t._onmute=e.onmute?[{fn:e.onmute}]:[],t._onvolume=e.onvolume?[{fn:e.onvolume}]:[],t._onrate=e.onrate?[{fn:e.onrate}]:[],t._onseek=e.onseek?[{fn:e.onseek}]:[],t._onresume=[],t._webAudio=a.usingWebAudio&&!t._html5,void 0!==a.ctx&&a.ctx&&a.mobileAutoEnable&&a._enableMobileAudio(),a._howls.push(t),t._autoplay&&t._queue.push({event:"play",action:function(){t.play()}}),t._preload&&t.load(),t},load:function(){var e=this,t=null;if(a.noAudio)e._emit("loaderror",null,"No audio support.");else{"string"==typeof e._src&&(e._src=[e._src]);for(var n=0;n<e._src.length;n++){var r,o;if(e._format&&e._format[n])r=e._format[n];else{if("string"!=typeof(o=e._src[n])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}(r=/^data:audio\/([^;,]+);/i.exec(o))||(r=/\.([^.]+)$/.exec(o.split("?",1)[0])),r&&(r=r[1].toLowerCase())}if(r||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),r&&a.codecs(r)){t=e._src[n];break}}if(t)return e._src=t,e._state="loading","https:"===window.location.protocol&&"http:"===t.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new s(e),e._webAudio&&c(e),e;e._emit("loaderror",null,"No codec support for selected audio sources.")}},play:function(e,t){var n=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===n._state&&!n._sprite[e])return null;if(void 0===e){e="__default";for(var o=0,i=0;i<n._sounds.length;i++)n._sounds[i]._paused&&!n._sounds[i]._ended&&(o++,r=n._sounds[i]._id);1===o?e=null:r=null}}var s=r?n._soundById(r):n._inactiveSound();if(!s)return null;if(r&&!e&&(e=s._sprite||"__default"),"loaded"!==n._state){s._sprite=e,s._ended=!1;var l=s._id;return n._queue.push({event:"play",action:function(){n.play(l)}}),l}if(r&&!s._paused)return t||setTimeout((function(){n._emit("play",s._id)}),0),s._id;n._webAudio&&a._autoResume();var c=Math.max(0,s._seek>0?s._seek:n._sprite[e][0]/1e3),f=Math.max(0,(n._sprite[e][0]+n._sprite[e][1])/1e3-c),u=1e3*f/Math.abs(s._rate);s._paused=!1,s._ended=!1,s._sprite=e,s._seek=c,s._start=n._sprite[e][0]/1e3,s._stop=(n._sprite[e][0]+n._sprite[e][1])/1e3,s._loop=!(!s._loop&&!n._sprite[e][2]);var d=s._node;if(n._webAudio){var p=function(){n._refreshBuffer(s);var e=s._muted||n._muted?0:s._volume;d.gain.setValueAtTime(e,a.ctx.currentTime),s._playStart=a.ctx.currentTime,void 0===d.bufferSource.start?s._loop?d.bufferSource.noteGrainOn(0,c,86400):d.bufferSource.noteGrainOn(0,c,f):s._loop?d.bufferSource.start(0,c,86400):d.bufferSource.start(0,c,f),u!==1/0&&(n._endTimers[s._id]=setTimeout(n._ended.bind(n,s),u)),t||setTimeout((function(){n._emit("play",s._id)}),0)};"running"===a.state?p():(n.once("resume",p),n._clearTimer(s._id))}else{var h=function(){d.currentTime=c,d.muted=s._muted||n._muted||a._muted||d.muted,d.volume=s._volume*a.volume(),d.playbackRate=s._rate;try{var e=d.play();if("undefined"!=typeof Promise&&e instanceof Promise&&(n._playLock=!0,e.then((function(){n._playLock=!1,n._loadQueue()}))),d.paused)return void n._emit("playerror",s._id,"Playback was unable to start. This is most commonly an issue on mobile devices where playback was not within a user interaction.");u!==1/0&&(n._endTimers[s._id]=setTimeout(n._ended.bind(n,s),u)),t||n._emit("play",s._id)}catch(e){n._emit("playerror",s._id,e)}},v=window&&window.ejecta||!d.readyState&&a._navigator.isCocoonJS;if(4===d.readyState||v)h();else{var m=function(){h(),d.removeEventListener(a._canPlayEvent,m,!1)};d.addEventListener(a._canPlayEvent,m,!1),n._clearTimer(s._id)}}return s._id},pause:function(e){var t=this;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"pause",action:function(){t.pause(e)}}),t;for(var n=t._getSoundIds(e),r=0;r<n.length;r++){t._clearTimer(n[r]);var o=t._soundById(n[r]);if(o&&!o._paused&&(o._seek=t.seek(n[r]),o._rateSeek=0,o._paused=!0,t._stopFade(n[r]),o._node))if(t._webAudio){if(!o._node.bufferSource)continue;void 0===o._node.bufferSource.stop?o._node.bufferSource.noteOff(0):o._node.bufferSource.stop(0),t._cleanBuffer(o._node)}else isNaN(o._node.duration)&&o._node.duration!==1/0||o._node.pause();arguments[1]||t._emit("pause",o?o._id:null)}return t},stop:function(e,t){var n=this;if("loaded"!==n._state)return n._queue.push({event:"stop",action:function(){n.stop(e)}}),n;for(var r=n._getSoundIds(e),o=0;o<r.length;o++){n._clearTimer(r[o]);var a=n._soundById(r[o]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,n._stopFade(r[o]),a._node&&(n._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),n._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause())),t||n._emit("stop",a._id))}return n},mute:function(e,t){var n=this;if("loaded"!==n._state)return n._queue.push({event:"mute",action:function(){n.mute(e,t)}}),n;if(void 0===t){if("boolean"!=typeof e)return n._muted;n._muted=e}for(var r=n._getSoundIds(t),o=0;o<r.length;o++){var i=n._soundById(r[o]);i&&(i._muted=e,i._interval&&n._stopFade(i._id),n._webAudio&&i._node?i._node.gain.setValueAtTime(e?0:i._volume,a.ctx.currentTime):i._node&&(i._node.muted=!!a._muted||e),n._emit("mute",i._id))}return n},volume:function(){var e,t,n,r=this,o=arguments;if(0===o.length)return r._volume;if(1===o.length||2===o.length&&void 0===o[1]){var i=r._getSoundIds(),s=i.indexOf(o[0]);s>=0?t=parseInt(o[0],10):e=parseFloat(o[0])}else o.length>=2&&(e=parseFloat(o[0]),t=parseInt(o[1],10));if(!(void 0!==e&&e>=0&&e<=1))return(n=t?r._soundById(t):r._sounds[0])?n._volume:0;if("loaded"!==r._state)return r._queue.push({event:"volume",action:function(){r.volume.apply(r,o)}}),r;void 0===t&&(r._volume=e),t=r._getSoundIds(t);for(var l=0;l<t.length;l++)(n=r._soundById(t[l]))&&(n._volume=e,o[2]||r._stopFade(t[l]),r._webAudio&&n._node&&!n._muted?n._node.gain.setValueAtTime(e,a.ctx.currentTime):n._node&&!n._muted&&(n._node.volume=e*a.volume()),r._emit("volume",n._id));return r},fade:function(e,t,n,r){var o=this;if("loaded"!==o._state)return o._queue.push({event:"fade",action:function(){o.fade(e,t,n,r)}}),o;o.volume(e,r);for(var i=o._getSoundIds(r),s=0;s<i.length;s++){var l=o._soundById(i[s]);if(l){if(r||o._stopFade(i[s]),o._webAudio&&!l._muted){var c=a.ctx.currentTime,f=c+n/1e3;l._volume=e,l._node.gain.setValueAtTime(e,c),l._node.gain.linearRampToValueAtTime(t,f)}o._startFadeInterval(l,e,t,n,i[s],void 0===r)}}return o},_startFadeInterval:function(e,t,n,r,o,a){var i=this,s=t,l=n-t,c=Math.abs(l/.01),f=Math.max(4,c>0?r/c:r),u=Date.now();e._fadeTo=n,e._interval=setInterval((function(){var o=(Date.now()-u)/r;u=Date.now(),s+=l*o,s=Math.max(0,s),s=Math.min(1,s),s=Math.round(100*s)/100,i._webAudio?e._volume=s:i.volume(s,e._id,!0),a&&(i._volume=s),(n<t&&s<=n||n>t&&s>=n)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,i.volume(n,e._id),i._emit("fade",e._id))}),f)},_stopFade:function(e){var t=this,n=t._soundById(e);return n&&n._interval&&(t._webAudio&&n._node.gain.cancelScheduledValues(a.ctx.currentTime),clearInterval(n._interval),n._interval=null,t.volume(n._fadeTo,e),n._fadeTo=null,t._emit("fade",e)),t},loop:function(){var e,t,n,r=this,o=arguments;if(0===o.length)return r._loop;if(1===o.length){if("boolean"!=typeof o[0])return!!(n=r._soundById(parseInt(o[0],10)))&&n._loop;e=o[0],r._loop=e}else 2===o.length&&(e=o[0],t=parseInt(o[1],10));for(var a=r._getSoundIds(t),i=0;i<a.length;i++)(n=r._soundById(a[i]))&&(n._loop=e,r._webAudio&&n._node&&n._node.bufferSource&&(n._node.bufferSource.loop=e,e&&(n._node.bufferSource.loopStart=n._start||0,n._node.bufferSource.loopEnd=n._stop)));return r},rate:function(){var e,t,n,r=this,o=arguments;if(0===o.length)t=r._sounds[0]._id;else if(1===o.length){var i=r._getSoundIds(),s=i.indexOf(o[0]);s>=0?t=parseInt(o[0],10):e=parseFloat(o[0])}else 2===o.length&&(e=parseFloat(o[0]),t=parseInt(o[1],10));if("number"!=typeof e)return(n=r._soundById(t))?n._rate:r._rate;if("loaded"!==r._state)return r._queue.push({event:"rate",action:function(){r.rate.apply(r,o)}}),r;void 0===t&&(r._rate=e),t=r._getSoundIds(t);for(var l=0;l<t.length;l++)if(n=r._soundById(t[l])){n._rateSeek=r.seek(t[l]),n._playStart=r._webAudio?a.ctx.currentTime:n._playStart,n._rate=e,r._webAudio&&n._node&&n._node.bufferSource?n._node.bufferSource.playbackRate.setValueAtTime(e,a.ctx.currentTime):n._node&&(n._node.playbackRate=e);var c=r.seek(t[l]),f=(r._sprite[n._sprite][0]+r._sprite[n._sprite][1])/1e3-c,u=1e3*f/Math.abs(n._rate);!r._endTimers[t[l]]&&n._paused||(r._clearTimer(t[l]),r._endTimers[t[l]]=setTimeout(r._ended.bind(r,n),u)),r._emit("rate",n._id)}return r},seek:function(){var e,t,n=this,r=arguments;if(0===r.length)t=n._sounds[0]._id;else if(1===r.length){var o=n._getSoundIds(),i=o.indexOf(r[0]);i>=0?t=parseInt(r[0],10):n._sounds.length&&(t=n._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),t=parseInt(r[1],10));if(void 0===t)return n;if("loaded"!==n._state)return n._queue.push({event:"seek",action:function(){n.seek.apply(n,r)}}),n;var s=n._soundById(t);if(s){if(!("number"==typeof e&&e>=0)){if(n._webAudio){var l=n.playing(t)?a.ctx.currentTime-s._playStart:0,c=s._rateSeek?s._rateSeek-s._seek:0;return s._seek+(c+l*Math.abs(s._rate))}return s._node.currentTime}var f=n.playing(t);f&&n.pause(t,!0),s._seek=e,s._ended=!1,n._clearTimer(t),f&&n.play(t,!0),!n._webAudio&&s._node&&(s._node.currentTime=e),n._emit("seek",t)}return n},playing:function(e){var t=this;if("number"==typeof e){var n=t._soundById(e);return!!n&&!n._paused}for(var r=0;r<t._sounds.length;r++)if(!t._sounds[r]._paused)return!0;return!1},duration:function(e){var t=this,n=t._duration,r=t._soundById(e);return r&&(n=t._sprite[r._sprite][1]/1e3),n},state:function(){return this._state},unload:function(){for(var e=this,t=e._sounds,n=0;n<t.length;n++){if(t[n]._paused||e.stop(t[n]._id),!e._webAudio)/MSIE |Trident\//.test(a._navigator&&a._navigator.userAgent)||(t[n]._node.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"),t[n]._node.removeEventListener("error",t[n]._errorFn,!1),t[n]._node.removeEventListener(a._canPlayEvent,t[n]._loadFn,!1);delete t[n]._node,e._clearTimer(t[n]._id);var r=a._howls.indexOf(e);r>=0&&a._howls.splice(r,1)}var o=!0;for(n=0;n<a._howls.length;n++)if(a._howls[n]._src===e._src){o=!1;break}return l&&o&&delete l[e._src],a.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,t,n,r){var o=this["_on"+e];return"function"==typeof t&&o.push(r?{id:n,fn:t,once:r}:{id:n,fn:t}),this},off:function(e,t,n){var r=this,o=r["_on"+e],a=0;if("number"==typeof t&&(n=t,t=null),t||n)for(a=0;a<o.length;a++){var i=n===o[a].id;if(t===o[a].fn&&i||!t&&i){o.splice(a,1);break}}else if(e)r["_on"+e]=[];else{var s=Object.keys(r);for(a=0;a<s.length;a++)0===s[a].indexOf("_on")&&Array.isArray(r[s[a]])&&(r[s[a]]=[])}return r},once:function(e,t,n){return this.on(e,t,n,1),this},_emit:function(e,t,n){for(var r=this,o=r["_on"+e],a=o.length-1;a>=0;a--)o[a].id&&o[a].id!==t&&"load"!==e||(setTimeout(function(e){e.call(this,t,n)}.bind(r,o[a].fn),0),o[a].once&&r.off(e,o[a].fn,o[a].id));return r},_loadQueue:function(){var e=this;if(e._queue.length>0){var t=e._queue[0];e.once(t.event,(function(){e._queue.shift(),e._loadQueue()})),t.action()}return e},_ended:function(e){var t=this,n=e._sprite;if(!t._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(t._ended.bind(t,e),100),t;var r=!(!e._loop&&!t._sprite[n][2]);if(t._emit("end",e._id),!t._webAudio&&r&&t.stop(e._id,!0).play(e._id),t._webAudio&&r){t._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=a.ctx.currentTime;var o=1e3*(e._stop-e._start)/Math.abs(e._rate);t._endTimers[e._id]=setTimeout(t._ended.bind(t,e),o)}return t._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,t._clearTimer(e._id),t._cleanBuffer(e._node),a._autoSuspend()),t._webAudio||r||t.stop(e._id),t},_clearTimer:function(e){var t=this;return t._endTimers[e]&&(clearTimeout(t._endTimers[e]),delete t._endTimers[e]),t},_soundById:function(e){for(var t=this,n=0;n<t._sounds.length;n++)if(e===t._sounds[n]._id)return t._sounds[n];return null},_inactiveSound:function(){var e=this;e._drain();for(var t=0;t<e._sounds.length;t++)if(e._sounds[t]._ended)return e._sounds[t].reset();return new s(e)},_drain:function(){var e=this,t=e._pool,n=0,r=0;if(!(e._sounds.length<t)){for(r=0;r<e._sounds.length;r++)e._sounds[r]._ended&&n++;for(r=e._sounds.length-1;r>=0;r--){if(n<=t)return;e._sounds[r]._ended&&(e._webAudio&&e._sounds[r]._node&&e._sounds[r]._node.disconnect(0),e._sounds.splice(r,1),n--)}}},_getSoundIds:function(e){if(void 0===e){for(var t=[],n=0;n<this._sounds.length;n++)t.push(this._sounds[n]._id);return t}return[e]},_refreshBuffer:function(e){return e._node.bufferSource=a.ctx.createBufferSource(),e._node.bufferSource.buffer=l[this._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,a.ctx.currentTime),this},_cleanBuffer:function(e){if(a._scratchBuffer){e.bufferSource.onended=null,e.bufferSource.disconnect(0);try{e.bufferSource.buffer=a._scratchBuffer}catch(e){}}return e.bufferSource=null,this}};var s=function(e){this._parent=e,this.init()};s.prototype={init:function(){var e=this,t=e._parent;return e._muted=t._muted,e._loop=t._loop,e._volume=t._volume,e._rate=t._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++a._counter,t._sounds.push(e),e.create(),e},create:function(){var e=this,t=e._parent,n=a._muted||e._muted||e._parent._muted?0:e._volume;return t._webAudio?(e._node=void 0===a.ctx.createGain?a.ctx.createGainNode():a.ctx.createGain(),e._node.gain.setValueAtTime(n,a.ctx.currentTime),e._node.paused=!0,e._node.connect(a.masterGain)):(e._node=new Audio,e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(a._canPlayEvent,e._loadFn,!1),e._node.src=t._src,e._node.preload="auto",e._node.volume=n*a.volume(),e._node.load()),e},reset:function(){var e=this,t=e._parent;return e._muted=t._muted,e._loop=t._loop,e._volume=t._volume,e._rate=t._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++a._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,t=e._parent;t._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(t._sprite).length&&(t._sprite={__default:[0,1e3*t._duration]}),"loaded"!==t._state&&(t._state="loaded",t._emit("load"),t._loadQueue()),e._node.removeEventListener(a._canPlayEvent,e._loadFn,!1)}};var l={},c=function(e){var t=e._src;if(l[t])return e._duration=l[t].duration,void d(e);if(/^data:[^;]+;base64,/.test(t)){for(var n=atob(t.split(",")[1]),r=new Uint8Array(n.length),o=0;o<n.length;++o)r[o]=n.charCodeAt(o);u(r.buffer,e)}else{var a=new XMLHttpRequest;a.open("GET",t,!0),a.withCredentials=e._xhrWithCredentials,a.responseType="arraybuffer",a.onload=function(){var t=(a.status+"")[0];"0"===t||"2"===t||"3"===t?u(a.response,e):e._emit("loaderror",null,"Failed loading audio file with status: "+a.status+".")},a.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete l[t],e.load())},f(a)}},f=function(e){try{e.send()}catch(t){e.onerror()}},u=function(e,t){a.ctx.decodeAudioData(e,(function(e){e&&t._sounds.length>0&&(l[t._src]=e,d(t,e))}),(function(){t._emit("loaderror",null,"Decoding audio data failed.")}))},d=function(e,t){t&&!e._duration&&(e._duration=t.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},p=function(){try{"undefined"!=typeof AudioContext?a.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?a.ctx=new webkitAudioContext:a.usingWebAudio=!1}catch(e){a.usingWebAudio=!1}var e=/iP(hone|od|ad)/.test(a._navigator&&a._navigator.platform),t=a._navigator&&a._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),n=t?parseInt(t[1],10):null;if(e&&n&&n<9){var r=/safari/.test(a._navigator&&a._navigator.userAgent.toLowerCase());(a._navigator&&a._navigator.standalone&&!r||a._navigator&&!a._navigator.standalone&&!r)&&(a.usingWebAudio=!1)}a.usingWebAudio&&(a.masterGain=void 0===a.ctx.createGain?a.ctx.createGainNode():a.ctx.createGain(),a.masterGain.gain.setValueAtTime(a._muted?0:1,a.ctx.currentTime),a.masterGain.connect(a.ctx.destination)),a._setup()};void 0===(r=function(){return{Howler:a,Howl:i}}.apply(t,[]))||(e.exports=r),t.Howler=a,t.Howl=i,"undefined"!=typeof window?(window.HowlerGlobal=o,window.Howler=a,window.Howl=i,window.Sound=s):void 0!==n.g&&(n.g.HowlerGlobal=o,n.g.Howler=a,n.g.Howl=i,n.g.Sound=s)}(),function(){"use strict";var e;HowlerGlobal.prototype._pos=[0,0,0],HowlerGlobal.prototype._orientation=[0,0,-1,0,1,0],HowlerGlobal.prototype.stereo=function(e){var t=this;if(!t.ctx||!t.ctx.listener)return t;for(var n=t._howls.length-1;n>=0;n--)t._howls[n].stereo(e);return t},HowlerGlobal.prototype.pos=function(e,t,n){var r=this;return r.ctx&&r.ctx.listener?(t="number"!=typeof t?r._pos[1]:t,n="number"!=typeof n?r._pos[2]:n,"number"!=typeof e?r._pos:(r._pos=[e,t,n],r.ctx.listener.setPosition(r._pos[0],r._pos[1],r._pos[2]),r)):r},HowlerGlobal.prototype.orientation=function(e,t,n,r,o,a){var i=this;if(!i.ctx||!i.ctx.listener)return i;var s=i._orientation;return t="number"!=typeof t?s[1]:t,n="number"!=typeof n?s[2]:n,r="number"!=typeof r?s[3]:r,o="number"!=typeof o?s[4]:o,a="number"!=typeof a?s[5]:a,"number"!=typeof e?s:(i._orientation=[e,t,n,r,o,a],i.ctx.listener.setOrientation(e,t,n,r,o,a),i)},Howl.prototype.init=(e=Howl.prototype.init,function(t){var n=this;return n._orientation=t.orientation||[1,0,0],n._stereo=t.stereo||null,n._pos=t.pos||null,n._pannerAttr={coneInnerAngle:void 0!==t.coneInnerAngle?t.coneInnerAngle:360,coneOuterAngle:void 0!==t.coneOuterAngle?t.coneOuterAngle:360,coneOuterGain:void 0!==t.coneOuterGain?t.coneOuterGain:0,distanceModel:void 0!==t.distanceModel?t.distanceModel:"inverse",maxDistance:void 0!==t.maxDistance?t.maxDistance:1e4,panningModel:void 0!==t.panningModel?t.panningModel:"HRTF",refDistance:void 0!==t.refDistance?t.refDistance:1,rolloffFactor:void 0!==t.rolloffFactor?t.rolloffFactor:1},n._onstereo=t.onstereo?[{fn:t.onstereo}]:[],n._onpos=t.onpos?[{fn:t.onpos}]:[],n._onorientation=t.onorientation?[{fn:t.onorientation}]:[],e.call(this,t)}),Howl.prototype.stereo=function(e,n){var r=this;if(!r._webAudio)return r;if("loaded"!==r._state)return r._queue.push({event:"stereo",action:function(){r.stereo(e,n)}}),r;var o=void 0===Howler.ctx.createStereoPanner?"spatial":"stereo";if(void 0===n){if("number"!=typeof e)return r._stereo;r._stereo=e,r._pos=[e,0,0]}for(var a=r._getSoundIds(n),i=0;i<a.length;i++){var s=r._soundById(a[i]);if(s){if("number"!=typeof e)return s._stereo;s._stereo=e,s._pos=[e,0,0],s._node&&(s._pannerAttr.panningModel="equalpower",s._panner&&s._panner.pan||t(s,o),"spatial"===o?s._panner.setPosition(e,0,0):s._panner.pan.setValueAtTime(e,Howler.ctx.currentTime)),r._emit("stereo",s._id)}}return r},Howl.prototype.pos=function(e,n,r,o){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"pos",action:function(){a.pos(e,n,r,o)}}),a;if(n="number"!=typeof n?0:n,r="number"!=typeof r?-.5:r,void 0===o){if("number"!=typeof e)return a._pos;a._pos=[e,n,r]}for(var i=a._getSoundIds(o),s=0;s<i.length;s++){var l=a._soundById(i[s]);if(l){if("number"!=typeof e)return l._pos;l._pos=[e,n,r],l._node&&(l._panner&&!l._panner.pan||t(l,"spatial"),l._panner.setPosition(e,n,r)),a._emit("pos",l._id)}}return a},Howl.prototype.orientation=function(e,n,r,o){var a=this;if(!a._webAudio)return a;if("loaded"!==a._state)return a._queue.push({event:"orientation",action:function(){a.orientation(e,n,r,o)}}),a;if(n="number"!=typeof n?a._orientation[1]:n,r="number"!=typeof r?a._orientation[2]:r,void 0===o){if("number"!=typeof e)return a._orientation;a._orientation=[e,n,r]}for(var i=a._getSoundIds(o),s=0;s<i.length;s++){var l=a._soundById(i[s]);if(l){if("number"!=typeof e)return l._orientation;l._orientation=[e,n,r],l._node&&(l._panner||(l._pos||(l._pos=a._pos||[0,0,-.5]),t(l,"spatial")),l._panner.setOrientation(e,n,r)),a._emit("orientation",l._id)}}return a},Howl.prototype.pannerAttr=function(){var e,n,r,o=this,a=arguments;if(!o._webAudio)return o;if(0===a.length)return o._pannerAttr;if(1===a.length){if("object"!=typeof a[0])return(r=o._soundById(parseInt(a[0],10)))?r._pannerAttr:o._pannerAttr;e=a[0],void 0===n&&(e.pannerAttr||(e.pannerAttr={coneInnerAngle:e.coneInnerAngle,coneOuterAngle:e.coneOuterAngle,coneOuterGain:e.coneOuterGain,distanceModel:e.distanceModel,maxDistance:e.maxDistance,refDistance:e.refDistance,rolloffFactor:e.rolloffFactor,panningModel:e.panningModel}),o._pannerAttr={coneInnerAngle:void 0!==e.pannerAttr.coneInnerAngle?e.pannerAttr.coneInnerAngle:o._coneInnerAngle,coneOuterAngle:void 0!==e.pannerAttr.coneOuterAngle?e.pannerAttr.coneOuterAngle:o._coneOuterAngle,coneOuterGain:void 0!==e.pannerAttr.coneOuterGain?e.pannerAttr.coneOuterGain:o._coneOuterGain,distanceModel:void 0!==e.pannerAttr.distanceModel?e.pannerAttr.distanceModel:o._distanceModel,maxDistance:void 0!==e.pannerAttr.maxDistance?e.pannerAttr.maxDistance:o._maxDistance,refDistance:void 0!==e.pannerAttr.refDistance?e.pannerAttr.refDistance:o._refDistance,rolloffFactor:void 0!==e.pannerAttr.rolloffFactor?e.pannerAttr.rolloffFactor:o._rolloffFactor,panningModel:void 0!==e.pannerAttr.panningModel?e.pannerAttr.panningModel:o._panningModel})}else 2===a.length&&(e=a[0],n=parseInt(a[1],10));for(var i=o._getSoundIds(n),s=0;s<i.length;s++)if(r=o._soundById(i[s])){var l=r._pannerAttr;l={coneInnerAngle:void 0!==e.coneInnerAngle?e.coneInnerAngle:l.coneInnerAngle,coneOuterAngle:void 0!==e.coneOuterAngle?e.coneOuterAngle:l.coneOuterAngle,coneOuterGain:void 0!==e.coneOuterGain?e.coneOuterGain:l.coneOuterGain,distanceModel:void 0!==e.distanceModel?e.distanceModel:l.distanceModel,maxDistance:void 0!==e.maxDistance?e.maxDistance:l.maxDistance,refDistance:void 0!==e.refDistance?e.refDistance:l.refDistance,rolloffFactor:void 0!==e.rolloffFactor?e.rolloffFactor:l.rolloffFactor,panningModel:void 0!==e.panningModel?e.panningModel:l.panningModel};var c=r._panner;c?(c.coneInnerAngle=l.coneInnerAngle,c.coneOuterAngle=l.coneOuterAngle,c.coneOuterGain=l.coneOuterGain,c.distanceModel=l.distanceModel,c.maxDistance=l.maxDistance,c.refDistance=l.refDistance,c.rolloffFactor=l.rolloffFactor,c.panningModel=l.panningModel):(r._pos||(r._pos=o._pos||[0,0,-.5]),t(r,"spatial"))}return o},Sound.prototype.init=function(e){return function(){var t=this,n=t._parent;t._orientation=n._orientation,t._stereo=n._stereo,t._pos=n._pos,t._pannerAttr=n._pannerAttr,e.call(this),t._stereo?n.stereo(t._stereo):t._pos&&n.pos(t._pos[0],t._pos[1],t._pos[2],t._id)}}(Sound.prototype.init),Sound.prototype.reset=function(e){return function(){var t=this,n=t._parent;return t._orientation=n._orientation,t._pos=n._pos,t._pannerAttr=n._pannerAttr,e.call(this)}}(Sound.prototype.reset);var t=function(e,t){"spatial"===(t=t||"spatial")?(e._panner=Howler.ctx.createPanner(),e._panner.coneInnerAngle=e._pannerAttr.coneInnerAngle,e._panner.coneOuterAngle=e._pannerAttr.coneOuterAngle,e._panner.coneOuterGain=e._pannerAttr.coneOuterGain,e._panner.distanceModel=e._pannerAttr.distanceModel,e._panner.maxDistance=e._pannerAttr.maxDistance,e._panner.refDistance=e._pannerAttr.refDistance,e._panner.rolloffFactor=e._pannerAttr.rolloffFactor,e._panner.panningModel=e._pannerAttr.panningModel,e._panner.setPosition(e._pos[0],e._pos[1],e._pos[2]),e._panner.setOrientation(e._orientation[0],e._orientation[1],e._orientation[2])):(e._panner=Howler.ctx.createStereoPanner(),e._panner.pan.setValueAtTime(e._stereo,Howler.ctx.currentTime)),e._panner.connect(e._node),e._paused||e._parent.pause(e._id,!0).play(e._id,!0)}}()},3108:(e,t,n)=>{e.exports=function e(t,n,r){function o(i,s){if(!n[i]){if(!t[i]){if(a)return a(i,!0);var l=new Error("Cannot find module '"+i+"'");throw l.code="MODULE_NOT_FOUND",l}var c=n[i]={exports:{}};t[i][0].call(c.exports,(function(e){return o(t[i][1][e]||e)}),c,c.exports,e,t,n,r)}return n[i].exports}for(var a=void 0,i=0;i<r.length;i++)o(r[i]);return o}({1:[function(e,t,n){t.exports={version:"1.5.0"}},{}],2:[function(e,t,n){"use strict";var r=function(e,t){this.point=e,this.triangle=t||null,this.next=null,this.prev=null,this.value=e.x},o=function(e,t){this.head_=e,this.tail_=t,this.search_node_=e};o.prototype.head=function(){return this.head_},o.prototype.setHead=function(e){this.head_=e},o.prototype.tail=function(){return this.tail_},o.prototype.setTail=function(e){this.tail_=e},o.prototype.search=function(){return this.search_node_},o.prototype.setSearch=function(e){this.search_node_=e},o.prototype.findSearchNode=function(){return this.search_node_},o.prototype.locateNode=function(e){var t=this.search_node_;if(e<t.value){for(;t=t.prev;)if(e>=t.value)return this.search_node_=t,t}else for(;t=t.next;)if(e<t.value)return this.search_node_=t.prev,t.prev;return null},o.prototype.locatePoint=function(e){var t=e.x,n=this.findSearchNode(t),r=n.point.x;if(t===r){if(e!==n.point)if(e===n.prev.point)n=n.prev;else{if(e!==n.next.point)throw new Error("poly2tri Invalid AdvancingFront.locatePoint() call");n=n.next}}else if(t<r)for(;(n=n.prev)&&e!==n.point;);else for(;(n=n.next)&&e!==n.point;);return n&&(this.search_node_=n),n},t.exports=o,t.exports.Node=r},{}],3:[function(e,t,n){"use strict";function r(e,t){if(!e)throw new Error(t||"Assert Failed")}t.exports=r},{}],4:[function(e,t,n){"use strict";var r=e("./xy"),o=function(e,t){this.x=+e||0,this.y=+t||0,this._p2t_edge_list=null};o.prototype.toString=function(){return r.toStringBase(this)},o.prototype.toJSON=function(){return{x:this.x,y:this.y}},o.prototype.clone=function(){return new o(this.x,this.y)},o.prototype.set_zero=function(){return this.x=0,this.y=0,this},o.prototype.set=function(e,t){return this.x=+e||0,this.y=+t||0,this},o.prototype.negate=function(){return this.x=-this.x,this.y=-this.y,this},o.prototype.add=function(e){return this.x+=e.x,this.y+=e.y,this},o.prototype.sub=function(e){return this.x-=e.x,this.y-=e.y,this},o.prototype.mul=function(e){return this.x*=e,this.y*=e,this},o.prototype.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y)},o.prototype.normalize=function(){var e=this.length();return this.x/=e,this.y/=e,e},o.prototype.equals=function(e){return this.x===e.x&&this.y===e.y},o.negate=function(e){return new o(-e.x,-e.y)},o.add=function(e,t){return new o(e.x+t.x,e.y+t.y)},o.sub=function(e,t){return new o(e.x-t.x,e.y-t.y)},o.mul=function(e,t){return new o(e*t.x,e*t.y)},o.cross=function(e,t){return"number"==typeof e?"number"==typeof t?e*t:new o(-e*t.y,e*t.x):"number"==typeof t?new o(t*e.y,-t*e.x):e.x*t.y-e.y*t.x},o.toString=r.toString,o.compare=r.compare,o.cmp=r.compare,o.equals=r.equals,o.dot=function(e,t){return e.x*t.x+e.y*t.y},t.exports=o},{"./xy":11}],5:[function(e,t,n){"use strict";var r=e("./xy"),o=function(e,t){this.name="PointError",this.points=t=t||[],this.message=e||"Invalid Points!";for(var n=0;n<t.length;n++)this.message+=" "+r.toString(t[n])};o.prototype=new Error,o.prototype.constructor=o,t.exports=o},{"./xy":11}],6:[function(e,t,r){(function(t){"use strict";var n=t.poly2tri;r.noConflict=function(){return t.poly2tri=n,r},r.VERSION=e("../dist/version.json").version,r.PointError=e("./pointerror"),r.Point=e("./point"),r.Triangle=e("./triangle"),r.SweepContext=e("./sweepcontext");var o=e("./sweep");r.triangulate=o.triangulate,r.sweep={Triangulate:o.triangulate}}).call(this,void 0!==n.g?n.g:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"../dist/version.json":1,"./point":4,"./pointerror":5,"./sweep":7,"./sweepcontext":8,"./triangle":9}],7:[function(e,t,n){"use strict";function r(e){e.initTriangulation(),e.createAdvancingFront(),o(e),a(e)}function o(e){var t,n=e.pointCount();for(t=1;t<n;++t)for(var r=e.getPoint(t),o=i(e,r),a=r._p2t_edge_list,l=0;a&&l<a.length;++l)s(e,a[l],o)}function a(e){for(var t=e.front().head().next.triangle,n=e.front().head().next.point;!t.getConstrainedEdgeCW(n);)t=t.neighborCCW(n);e.meshClean(t)}function i(e,t){var n=e.locateNode(t),r=f(e,t,n);return t.x<=n.point.x+I&&u(e,n),d(e,r),r}function s(e,t,n){e.edge_event.constrained_edge=t,e.edge_event.right=t.p.x>t.q.x,c(n.triangle,t.p,t.q)||(E(e,t,n),l(e,t.p,t.q,n.triangle,t.q))}function l(e,t,n,r,o){if(!c(r,t,n)){var a=r.pointCCW(o),i=U(n,a,t);if(i===O.COLLINEAR)throw new H("poly2tri EdgeEvent: Collinear not supported!",[n,a,t]);var s=r.pointCW(o),f=U(n,s,t);if(f===O.COLLINEAR)throw new H("poly2tri EdgeEvent: Collinear not supported!",[n,s,t]);i===f?l(e,t,n,r=i===O.CW?r.neighborCCW(o):r.neighborCW(o),o):C(e,t,n,r,o)}}function c(e,t,n){var r=e.edgeIndex(t,n);if(-1!==r){e.markConstrainedEdgeByIndex(r);var o=e.getNeighbor(r);return o&&o.markConstrainedEdgeByPoints(t,n),!0}return!1}function f(e,t,n){var r=new z(t,n.point,n.next.point);r.markNeighbor(n.triangle),e.addToMap(r);var o=new D(t);return o.next=n.next,o.prev=n,n.next.prev=o,n.next=o,h(e,r)||e.mapTriangleToNodes(r),o}function u(e,t){var n=new z(t.prev.point,t.point,t.next.point);n.markNeighbor(t.prev.triangle),n.markNeighbor(t.triangle),e.addToMap(n),t.prev.next=t.next,t.next.prev=t.prev,h(e,n)||e.mapTriangleToNodes(n)}function d(e,t){for(var n=t.next;n.next&&!B(n.point,n.next.point,n.prev.point);)u(e,n),n=n.next;for(n=t.prev;n.prev&&!B(n.point,n.next.point,n.prev.point);)u(e,n),n=n.prev;t.next&&t.next.next&&p(t)&&x(e,t)}function p(e){var t=e.point.x-e.next.next.point.x,n=e.point.y-e.next.next.point.y;return N(n>=0,"unordered y"),t>=0||Math.abs(t)<n}function h(e,t){for(var n=0;n<3;++n)if(!t.delaunay_edge[n]){var r=t.getNeighbor(n);if(r){var o=t.getPoint(n),a=r.oppositePoint(t,o),i=r.index(a);if(r.constrained_edge[i]||r.delaunay_edge[i]){t.constrained_edge[n]=r.constrained_edge[i];continue}if(v(o,t.pointCCW(o),t.pointCW(o),a)){t.delaunay_edge[n]=!0,r.delaunay_edge[i]=!0,m(t,o,r,a);var s=!h(e,t);return s&&e.mapTriangleToNodes(t),(s=!h(e,r))&&e.mapTriangleToNodes(r),t.delaunay_edge[n]=!1,r.delaunay_edge[i]=!1,!0}}}return!1}function v(e,t,n,r){var o=e.x-r.x,a=e.y-r.y,i=t.x-r.x,s=t.y-r.y,l=o*s-i*a;if(l<=0)return!1;var c=n.x-r.x,f=n.y-r.y,u=c*a-o*f;return!(u<=0)&&(o*o+a*a)*(i*f-c*s)+(i*i+s*s)*u+(c*c+f*f)*l>0}function m(e,t,n,r){var o,a,i,s,l,c,f,u,d,p,h,v;o=e.neighborCCW(t),a=e.neighborCW(t),i=n.neighborCCW(r),s=n.neighborCW(r),l=e.getConstrainedEdgeCCW(t),c=e.getConstrainedEdgeCW(t),f=n.getConstrainedEdgeCCW(r),u=n.getConstrainedEdgeCW(r),d=e.getDelaunayEdgeCCW(t),p=e.getDelaunayEdgeCW(t),h=n.getDelaunayEdgeCCW(r),v=n.getDelaunayEdgeCW(r),e.legalize(t,r),n.legalize(r,t),n.setDelaunayEdgeCCW(t,d),e.setDelaunayEdgeCW(t,p),e.setDelaunayEdgeCCW(r,h),n.setDelaunayEdgeCW(r,v),n.setConstrainedEdgeCCW(t,l),e.setConstrainedEdgeCW(t,c),e.setConstrainedEdgeCCW(r,f),n.setConstrainedEdgeCW(r,u),e.clearNeighbors(),n.clearNeighbors(),o&&n.markNeighbor(o),a&&e.markNeighbor(a),i&&e.markNeighbor(i),s&&n.markNeighbor(s),e.markNeighbor(n)}function x(e,t){for(U(t.point,t.next.point,t.next.next.point)===O.CCW?e.basin.left_node=t.next.next:e.basin.left_node=t.next,e.basin.bottom_node=e.basin.left_node;e.basin.bottom_node.next&&e.basin.bottom_node.point.y>=e.basin.bottom_node.next.point.y;)e.basin.bottom_node=e.basin.bottom_node.next;if(e.basin.bottom_node!==e.basin.left_node){for(e.basin.right_node=e.basin.bottom_node;e.basin.right_node.next&&e.basin.right_node.point.y<e.basin.right_node.next.point.y;)e.basin.right_node=e.basin.right_node.next;e.basin.right_node!==e.basin.bottom_node&&(e.basin.width=e.basin.right_node.point.x-e.basin.left_node.point.x,e.basin.left_highest=e.basin.left_node.point.y>e.basin.right_node.point.y,g(e,e.basin.bottom_node))}}function g(e,t){if(!y(e,t)&&(u(e,t),t.prev!==e.basin.left_node||t.next!==e.basin.right_node)){if(t.prev===e.basin.left_node){if(U(t.point,t.next.point,t.next.next.point)===O.CW)return;t=t.next}else if(t.next===e.basin.right_node){if(U(t.point,t.prev.point,t.prev.prev.point)===O.CCW)return;t=t.prev}else t=t.prev.point.y<t.next.point.y?t.prev:t.next;g(e,t)}}function y(e,t){var n;return n=e.basin.left_highest?e.basin.left_node.point.y-t.point.y:e.basin.right_node.point.y-t.point.y,e.basin.width>n}function E(e,t,n){e.edge_event.right?w(e,t,n):A(e,t,n)}function w(e,t,n){for(;n.next.point.x<t.p.x;)U(t.q,n.next.point,t.p)===O.CCW?b(e,t,n):n=n.next}function b(e,t,n){n.point.x<t.p.x&&(U(n.point,n.next.point,n.next.next.point)===O.CCW?_(e,t,n):(T(e,t,n),b(e,t,n)))}function _(e,t,n){u(e,n.next),n.next.point!==t.p&&U(t.q,n.next.point,t.p)===O.CCW&&U(n.point,n.next.point,n.next.next.point)===O.CCW&&_(e,t,n)}function T(e,t,n){U(n.next.point,n.next.next.point,n.next.next.next.point)===O.CCW?_(e,t,n.next):U(t.q,n.next.next.point,t.p)===O.CCW&&T(e,t,n.next)}function A(e,t,n){for(;n.prev.point.x>t.p.x;)U(t.q,n.prev.point,t.p)===O.CW?S(e,t,n):n=n.prev}function S(e,t,n){n.point.x>t.p.x&&(U(n.point,n.prev.point,n.prev.prev.point)===O.CW?M(e,t,n):(R(e,t,n),S(e,t,n)))}function R(e,t,n){U(n.prev.point,n.prev.prev.point,n.prev.prev.prev.point)===O.CW?M(e,t,n.prev):U(t.q,n.prev.prev.point,t.p)===O.CW&&R(e,t,n.prev)}function M(e,t,n){u(e,n.prev),n.prev.point!==t.p&&U(t.q,n.prev.point,t.p)===O.CW&&U(n.point,n.prev.point,n.prev.prev.point)===O.CW&&M(e,t,n)}function C(e,t,n,r,o){var a=r.neighborAcross(o);N(a,"FLIP failed due to missing triangle!");var i=a.oppositePoint(r,o);if(r.getConstrainedEdgeAcross(o)){var s=r.index(o);throw new H("poly2tri Intersecting Constraints",[o,i,r.getPoint((s+1)%3),r.getPoint((s+2)%3)])}G(o,r.pointCCW(o),r.pointCW(o),i)?(m(r,o,a,i),e.mapTriangleToNodes(r),e.mapTriangleToNodes(a),o===n&&i===t?n===e.edge_event.constrained_edge.q&&t===e.edge_event.constrained_edge.p&&(r.markConstrainedEdgeByPoints(t,n),a.markConstrainedEdgeByPoints(t,n),h(e,r),h(e,a)):C(e,t,n,r=L(e,U(n,i,t),r,a,o,i),o)):(k(e,t,n,r,a,P(t,n,a,i)),l(e,t,n,r,o))}function L(e,t,n,r,o,a){var i;return t===O.CCW?(i=r.edgeIndex(o,a),r.delaunay_edge[i]=!0,h(e,r),r.clearDelaunayEdges(),n):(i=n.edgeIndex(o,a),n.delaunay_edge[i]=!0,h(e,n),n.clearDelaunayEdges(),r)}function P(e,t,n,r){var o=U(t,r,e);if(o===O.CW)return n.pointCCW(r);if(o===O.CCW)return n.pointCW(r);throw new H("poly2tri [Unsupported] nextFlipPoint: opposing point on constrained edge!",[t,r,e])}function k(e,t,n,r,o,a){var i=o.neighborAcross(a);N(i,"FLIP failed due to missing triangle");var s=i.oppositePoint(o,a);G(n,r.pointCCW(n),r.pointCW(n),s)?C(e,n,s,i,s):k(e,t,n,r,i,P(t,n,i,s))}var N=e("./assert"),H=e("./pointerror"),z=e("./triangle"),D=e("./advancingfront").Node,F=e("./utils"),I=F.EPSILON,O=F.Orientation,U=F.orient2d,G=F.inScanArea,B=F.isAngleObtuse;n.triangulate=r},{"./advancingfront":2,"./assert":3,"./pointerror":5,"./triangle":9,"./utils":10}],8:[function(e,t,n){"use strict";var r=e("./pointerror"),o=e("./point"),a=e("./triangle"),i=e("./sweep"),s=e("./advancingfront"),l=s.Node,c=function(e,t){if(this.p=e,this.q=t,e.y>t.y)this.q=e,this.p=t;else if(e.y===t.y)if(e.x>t.x)this.q=e,this.p=t;else if(e.x===t.x)throw new r("poly2tri Invalid Edge constructor: repeated points!",[e]);this.q._p2t_edge_list||(this.q._p2t_edge_list=[]),this.q._p2t_edge_list.push(this)},f=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};f.prototype.clear=function(){this.left_node=null,this.bottom_node=null,this.right_node=null,this.width=0,this.left_highest=!1};var u=function(){this.constrained_edge=null,this.right=!1},d=function(e,t){t=t||{},this.triangles_=[],this.map_=[],this.points_=t.cloneArrays?e.slice(0):e,this.edge_list=[],this.pmin_=this.pmax_=null,this.front_=null,this.head_=null,this.tail_=null,this.af_head_=null,this.af_middle_=null,this.af_tail_=null,this.basin=new f,this.edge_event=new u,this.initEdges(this.points_)};d.prototype.addHole=function(e){this.initEdges(e);var t,n=e.length;for(t=0;t<n;t++)this.points_.push(e[t]);return this},d.prototype.AddHole=d.prototype.addHole,d.prototype.addHoles=function(e){var t,n=e.length;for(t=0;t<n;t++)this.initEdges(e[t]);return this.points_=this.points_.concat.apply(this.points_,e),this},d.prototype.addPoint=function(e){return this.points_.push(e),this},d.prototype.AddPoint=d.prototype.addPoint,d.prototype.addPoints=function(e){return this.points_=this.points_.concat(e),this},d.prototype.triangulate=function(){return i.triangulate(this),this},d.prototype.getBoundingBox=function(){return{min:this.pmin_,max:this.pmax_}},d.prototype.getTriangles=function(){return this.triangles_},d.prototype.GetTriangles=d.prototype.getTriangles,d.prototype.front=function(){return this.front_},d.prototype.pointCount=function(){return this.points_.length},d.prototype.head=function(){return this.head_},d.prototype.setHead=function(e){this.head_=e},d.prototype.tail=function(){return this.tail_},d.prototype.setTail=function(e){this.tail_=e},d.prototype.getMap=function(){return this.map_},d.prototype.initTriangulation=function(){var e,t=this.points_[0].x,n=this.points_[0].x,r=this.points_[0].y,a=this.points_[0].y,i=this.points_.length;for(e=1;e<i;e++){var s=this.points_[e];s.x>t&&(t=s.x),s.x<n&&(n=s.x),s.y>r&&(r=s.y),s.y<a&&(a=s.y)}this.pmin_=new o(n,a),this.pmax_=new o(t,r);var l=.3*(t-n),c=.3*(r-a);this.head_=new o(t+l,a-c),this.tail_=new o(n-l,a-c),this.points_.sort(o.compare)},d.prototype.initEdges=function(e){var t,n=e.length;for(t=0;t<n;++t)this.edge_list.push(new c(e[t],e[(t+1)%n]))},d.prototype.getPoint=function(e){return this.points_[e]},d.prototype.addToMap=function(e){this.map_.push(e)},d.prototype.locateNode=function(e){return this.front_.locateNode(e.x)},d.prototype.createAdvancingFront=function(){var e,t,n,r=new a(this.points_[0],this.tail_,this.head_);this.map_.push(r),e=new l(r.getPoint(1),r),t=new l(r.getPoint(0),r),n=new l(r.getPoint(2)),this.front_=new s(e,n),e.next=t,t.next=n,t.prev=e,n.prev=t},d.prototype.removeNode=function(e){},d.prototype.mapTriangleToNodes=function(e){for(var t=0;t<3;++t)if(!e.getNeighbor(t)){var n=this.front_.locatePoint(e.pointCW(e.getPoint(t)));n&&(n.triangle=e)}},d.prototype.removeFromMap=function(e){var t,n=this.map_,r=n.length;for(t=0;t<r;t++)if(n[t]===e){n.splice(t,1);break}},d.prototype.meshClean=function(e){for(var t,n,r=[e];t=r.pop();)if(!t.isInterior())for(t.setInterior(!0),this.triangles_.push(t),n=0;n<3;n++)t.constrained_edge[n]||r.push(t.getNeighbor(n))},t.exports=d},{"./advancingfront":2,"./point":4,"./pointerror":5,"./sweep":7,"./triangle":9}],9:[function(e,t,n){"use strict";var r=function(e,t,n){this.points_=[e,t,n],this.neighbors_=[null,null,null],this.interior_=!1,this.constrained_edge=[!1,!1,!1],this.delaunay_edge=[!1,!1,!1]},o=e("./xy").toString;r.prototype.toString=function(){return"["+o(this.points_[0])+o(this.points_[1])+o(this.points_[2])+"]"},r.prototype.getPoint=function(e){return this.points_[e]},r.prototype.GetPoint=r.prototype.getPoint,r.prototype.getPoints=function(){return this.points_},r.prototype.getNeighbor=function(e){return this.neighbors_[e]},r.prototype.containsPoint=function(e){var t=this.points_;return e===t[0]||e===t[1]||e===t[2]},r.prototype.containsEdge=function(e){return this.containsPoint(e.p)&&this.containsPoint(e.q)},r.prototype.containsPoints=function(e,t){return this.containsPoint(e)&&this.containsPoint(t)},r.prototype.isInterior=function(){return this.interior_},r.prototype.setInterior=function(e){return this.interior_=e,this},r.prototype.markNeighborPointers=function(e,t,n){var r=this.points_;if(e===r[2]&&t===r[1]||e===r[1]&&t===r[2])this.neighbors_[0]=n;else if(e===r[0]&&t===r[2]||e===r[2]&&t===r[0])this.neighbors_[1]=n;else{if(!(e===r[0]&&t===r[1]||e===r[1]&&t===r[0]))throw new Error("poly2tri Invalid Triangle.markNeighborPointers() call");this.neighbors_[2]=n}},r.prototype.markNeighbor=function(e){var t=this.points_;e.containsPoints(t[1],t[2])?(this.neighbors_[0]=e,e.markNeighborPointers(t[1],t[2],this)):e.containsPoints(t[0],t[2])?(this.neighbors_[1]=e,e.markNeighborPointers(t[0],t[2],this)):e.containsPoints(t[0],t[1])&&(this.neighbors_[2]=e,e.markNeighborPointers(t[0],t[1],this))},r.prototype.clearNeighbors=function(){this.neighbors_[0]=null,this.neighbors_[1]=null,this.neighbors_[2]=null},r.prototype.clearDelaunayEdges=function(){this.delaunay_edge[0]=!1,this.delaunay_edge[1]=!1,this.delaunay_edge[2]=!1},r.prototype.pointCW=function(e){var t=this.points_;return e===t[0]?t[2]:e===t[1]?t[0]:e===t[2]?t[1]:null},r.prototype.pointCCW=function(e){var t=this.points_;return e===t[0]?t[1]:e===t[1]?t[2]:e===t[2]?t[0]:null},r.prototype.neighborCW=function(e){return e===this.points_[0]?this.neighbors_[1]:e===this.points_[1]?this.neighbors_[2]:this.neighbors_[0]},r.prototype.neighborCCW=function(e){return e===this.points_[0]?this.neighbors_[2]:e===this.points_[1]?this.neighbors_[0]:this.neighbors_[1]},r.prototype.getConstrainedEdgeCW=function(e){return e===this.points_[0]?this.constrained_edge[1]:e===this.points_[1]?this.constrained_edge[2]:this.constrained_edge[0]},r.prototype.getConstrainedEdgeCCW=function(e){return e===this.points_[0]?this.constrained_edge[2]:e===this.points_[1]?this.constrained_edge[0]:this.constrained_edge[1]},r.prototype.getConstrainedEdgeAcross=function(e){return e===this.points_[0]?this.constrained_edge[0]:e===this.points_[1]?this.constrained_edge[1]:this.constrained_edge[2]},r.prototype.setConstrainedEdgeCW=function(e,t){e===this.points_[0]?this.constrained_edge[1]=t:e===this.points_[1]?this.constrained_edge[2]=t:this.constrained_edge[0]=t},r.prototype.setConstrainedEdgeCCW=function(e,t){e===this.points_[0]?this.constrained_edge[2]=t:e===this.points_[1]?this.constrained_edge[0]=t:this.constrained_edge[1]=t},r.prototype.getDelaunayEdgeCW=function(e){return e===this.points_[0]?this.delaunay_edge[1]:e===this.points_[1]?this.delaunay_edge[2]:this.delaunay_edge[0]},r.prototype.getDelaunayEdgeCCW=function(e){return e===this.points_[0]?this.delaunay_edge[2]:e===this.points_[1]?this.delaunay_edge[0]:this.delaunay_edge[1]},r.prototype.setDelaunayEdgeCW=function(e,t){e===this.points_[0]?this.delaunay_edge[1]=t:e===this.points_[1]?this.delaunay_edge[2]=t:this.delaunay_edge[0]=t},r.prototype.setDelaunayEdgeCCW=function(e,t){e===this.points_[0]?this.delaunay_edge[2]=t:e===this.points_[1]?this.delaunay_edge[0]=t:this.delaunay_edge[1]=t},r.prototype.neighborAcross=function(e){return e===this.points_[0]?this.neighbors_[0]:e===this.points_[1]?this.neighbors_[1]:this.neighbors_[2]},r.prototype.oppositePoint=function(e,t){var n=e.pointCW(t);return this.pointCW(n)},r.prototype.legalize=function(e,t){var n=this.points_;if(e===n[0])n[1]=n[0],n[0]=n[2],n[2]=t;else if(e===n[1])n[2]=n[1],n[1]=n[0],n[0]=t;else{if(e!==n[2])throw new Error("poly2tri Invalid Triangle.legalize() call");n[0]=n[2],n[2]=n[1],n[1]=t}},r.prototype.index=function(e){var t=this.points_;if(e===t[0])return 0;if(e===t[1])return 1;if(e===t[2])return 2;throw new Error("poly2tri Invalid Triangle.index() call")},r.prototype.edgeIndex=function(e,t){var n=this.points_;if(e===n[0]){if(t===n[1])return 2;if(t===n[2])return 1}else if(e===n[1]){if(t===n[2])return 0;if(t===n[0])return 2}else if(e===n[2]){if(t===n[0])return 1;if(t===n[1])return 0}return-1},r.prototype.markConstrainedEdgeByIndex=function(e){this.constrained_edge[e]=!0},r.prototype.markConstrainedEdgeByEdge=function(e){this.markConstrainedEdgeByPoints(e.p,e.q)},r.prototype.markConstrainedEdgeByPoints=function(e,t){var n=this.points_;t===n[0]&&e===n[1]||t===n[1]&&e===n[0]?this.constrained_edge[2]=!0:t===n[0]&&e===n[2]||t===n[2]&&e===n[0]?this.constrained_edge[1]=!0:(t===n[1]&&e===n[2]||t===n[2]&&e===n[1])&&(this.constrained_edge[0]=!0)},t.exports=r},{"./xy":11}],10:[function(e,t,n){"use strict";function r(e,t,n){var r=(e.x-n.x)*(t.y-n.y)-(e.y-n.y)*(t.x-n.x);return r>-i&&r<i?s.COLLINEAR:r>0?s.CCW:s.CW}function o(e,t,n,r){return!((e.x-t.x)*(r.y-t.y)-(r.x-t.x)*(e.y-t.y)>=-i||(e.x-n.x)*(r.y-n.y)-(r.x-n.x)*(e.y-n.y)<=i)}function a(e,t,n){var r=t.x-e.x,o=t.y-e.y;return r*(n.x-e.x)+o*(n.y-e.y)<0}var i=1e-12;n.EPSILON=i;var s={CW:1,CCW:-1,COLLINEAR:0};n.Orientation=s,n.orient2d=r,n.inScanArea=o,n.isAngleObtuse=a},{}],11:[function(e,t,n){"use strict";function r(e){return"("+e.x+";"+e.y+")"}function o(e){var t=e.toString();return"[object Object]"===t?r(e):t}function a(e,t){return e.y===t.y?e.x-t.x:e.y-t.y}function i(e,t){return e.x===t.x&&e.y===t.y}t.exports={toString:o,toStringBase:r,compare:a,equals:i}},{}]},{},[6])(6)},5744:function(e,t,n){var r;!function(o){function a(e,t,n,r,o){this._listener=t,this._isOnce=n,this.context=r,this._signal=e,this._priority=o||0}function i(e,t){if("function"!=typeof e)throw Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}",t))}function s(){this._bindings=[],this._prevParams=null;var e=this;this.dispatch=function(){s.prototype.dispatch.apply(e,arguments)}}a.prototype={active:!0,params:null,execute:function(e){var t;return this.active&&this._listener&&(e=this.params?this.params.concat(e):e,t=this._listener.apply(this.context,e),this._isOnce&&this.detach()),t},detach:function(){return this.isBound()?this._signal.remove(this._listener,this.context):null},isBound:function(){return!!this._signal&&!!this._listener},isOnce:function(){return this._isOnce},getListener:function(){return this._listener},getSignal:function(){return this._signal},_destroy:function(){delete this._signal,delete this._listener,delete this.context},toString:function(){return"[SignalBinding isOnce:"+this._isOnce+", isBound:"+this.isBound()+", active:"+this.active+"]"}},s.prototype={VERSION:"1.0.0",memorize:!1,_shouldPropagate:!0,active:!0,_registerListener:function(e,t,n,r){var o=this._indexOfListener(e,n);if(-1!==o){if((e=this._bindings[o]).isOnce()!==t)throw Error("You cannot add"+(t?"":"Once")+"() then add"+(t?"Once":"")+"() the same listener without removing the relationship first.")}else e=new a(this,e,t,n,r),this._addBinding(e);return this.memorize&&this._prevParams&&e.execute(this._prevParams),e},_addBinding:function(e){var t=this._bindings.length;do{--t}while(this._bindings[t]&&e._priority<=this._bindings[t]._priority);this._bindings.splice(t+1,0,e)},_indexOfListener:function(e,t){for(var n,r=this._bindings.length;r--;)if((n=this._bindings[r])._listener===e&&n.context===t)return r;return-1},has:function(e,t){return-1!==this._indexOfListener(e,t)},add:function(e,t,n){return i(e,"add"),this._registerListener(e,!1,t,n)},addOnce:function(e,t,n){return i(e,"addOnce"),this._registerListener(e,!0,t,n)},remove:function(e,t){i(e,"remove");var n=this._indexOfListener(e,t);return-1!==n&&(this._bindings[n]._destroy(),this._bindings.splice(n,1)),e},removeAll:function(){for(var e=this._bindings.length;e--;)this._bindings[e]._destroy();this._bindings.length=0},getNumListeners:function(){return this._bindings.length},halt:function(){this._shouldPropagate=!1},dispatch:function(e){if(this.active){var t,n=Array.prototype.slice.call(arguments),r=this._bindings.length;if(this.memorize&&(this._prevParams=n),r){t=this._bindings.slice(),this._shouldPropagate=!0;do{r--}while(t[r]&&this._shouldPropagate&&!1!==t[r].execute(n))}}},forget:function(){this._prevParams=null},dispose:function(){this.removeAll(),delete this._bindings,delete this._prevParams},toString:function(){return"[Signal active:"+this.active+" numListeners:"+this.getNumListeners()+"]"}};var l=s;l.Signal=s,void 0===(r=function(){return l}.call(t,n,t,e))||(e.exports=r)}()},2865:(e,t)=>{"use strict";var n,r,o,a;function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}a=function(e){var t=Math.round,n=Math.abs,r=Math.min,o=Math.max,a=Math.sqrt;function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function l(e,t){for(var n,r=0;r<t.length;r++)(n=t[r]).enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}function c(e,t,n){return t&&l(e.prototype,t),n&&l(e,n),e}function f(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&d(e,t)}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,t){return(d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}function h(e,t,n){return(h="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=u(e)););return e}(e,t);if(r){var o=Object.getOwnPropertyDescriptor(r,t);return o.get?o.get.call(n):o.value}})(e,t,n||e)}function v(e){return function(e){if(Array.isArray(e)){for(var t=0,n=Array(e.length);t<e.length;t++)n[t]=e[t];return n}}(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function m(e,t,n){var r,o,i,s,l,c,f,u,d,p,h,v=t.params.Points.threshold;for(l=0,f=e.length;l<f;++l)if(null!==(p=(d=e[l]).points))for(c=0,u=p.length;c<u;++c)h=p[c],(s=t.ray.distanceSqToPoint(h))<v*v&&(r=t.ray.closestPointToPoint(h,new N),(o=t.ray.origin.distanceTo(r))>=t.near&&o<=t.far&&(i=a(s),n.push(new V(o,i,r,d.data[c]))))}function x(e,t,n,r,o,a){var i=0;return e>t&&e>n?(o<e&&(i|=2),a<e&&(i|=1)):t>n?(r<t&&(i|=4),a<t&&(i|=1)):(r<n&&(i|=4),o<n&&(i|=2)),i}function g(e,t,n,r){var o,a=0;return t<n?(o=t,a=0):(o=n,a=1),r<o&&(a=2),j[e][a]}function y(e,t,n){var a,i,s,l,c,f,u,d,p,h=X.min.set(0,0,0),v=X.max.subVectors(e.max,e.min),m=e.getDimensions(Y.min),x=Y.max.copy(m).multiplyScalar(.5),g=Q.origin.copy(t.origin),y=Q.direction.copy(t.direction);return g.sub(e.getCenter(q)).add(x),n.value=0,0>y.x&&(g.x=m.x-g.x,y.x=-y.x,n.value|=4),0>y.y&&(g.y=m.y-g.y,y.y=-y.y,n.value|=2),0>y.z&&(g.z=m.z-g.z,y.z=-y.z,n.value|=1),a=1/y.x,i=1/y.y,s=1/y.z,l=(h.x-g.x)*a,c=(v.x-g.x)*a,f=(h.y-g.y)*i,u=(v.y-g.y)*i,d=(h.z-g.z)*s,p=(v.z-g.z)*s,o(o(l,f),d)<r(r(c,u),p)?[l,f,d,c,u,p]:null}function E(e,t,n,r,o,a,i,s){if(0<=o&&0<=a&&0<=i){var l=e.children;if(null===l)s.push(e);else{var c=.5*(t+o),f=.5*(n+a),u=.5*(r+i),d=K.value,p=x(t,n,r,c,f,u);do{0===p?(E(l[d],t,n,r,c,f,u,s),p=g(p,c,f,u)):1===p?(E(l[1^d],t,n,u,c,f,i,s),p=g(p,c,f,i)):2===p?(E(l[2^d],t,f,r,c,a,u,s),p=g(p,c,a,u)):3===p?(E(l[3^d],t,f,u,c,a,i,s),p=g(p,c,a,i)):4===p?(E(l[4^d],c,n,r,o,f,u,s),p=g(p,o,f,u)):5===p?(E(l[5^d],c,n,u,o,f,i,s),p=g(p,o,f,i)):6===p?(E(l[6^d],c,f,r,o,a,u,s),p=g(p,o,a,u)):7===p&&(E(l[7^d],c,f,u,o,a,i,s),p=8)}while(8>p)}}}function w(e){var t,n,r,o=e.children,a=0;if(null!==o)for(t=0,n=o.length;t<n;++t)(r=1+w(o[t]))>a&&(a=r);return a}function b(e,t,n){var r,o,a=e.children;if(te.min=e.min,te.max=e.max,t.intersectsBox(te))if(null!==a)for(r=0,o=a.length;r<o;++r)b(a[r],t,n);else n.push(e)}function _(e,t,n,r){var o,a,i=e.children;if(n===t)r.push(e);else if(null!==i)for(++n,o=0,a=i.length;o<a;++o)_(i[o],t,n,r)}function T(e){var t,n,r=e.children,o=0;if(null!==r)for(t=0,n=r.length;t<n;++t)o+=T(r[t]);else null!==e.points&&(o=e.points.length);return o}function A(e,t,n,r,o){var a,i,s=r.children,l=!1,c=!1;if(r.contains(e,n.bias)){if(null===s){if(null===r.points)r.points=[],r.data=[];else for(a=0,i=r.points.length;!l&&a<i;++a)l=r.points[a].equals(e);l?(r.data[a-1]=t,c=!0):r.points.length<n.maxPoints||o===n.maxDepth?(r.points.push(e.clone()),r.data.push(t),++n.pointCount,c=!0):(r.split(),r.redistribute(n.bias),s=r.children)}if(null!==s)for(++o,a=0,i=s.length;!c&&a<i;++a)c=A(e,t,n,s[a],o)}return c}function S(e,t,n,r){var o,a,i,s,l,c=n.children,f=null;if(n.contains(e,t.bias))if(null!==c)for(o=0,a=c.length;null===f&&o<a;++o)f=S(e,t,c[o],n);else if(null!==n.points)for(i=n.points,s=n.data,o=0,a=i.length;o<a;++o)if(i[o].equals(e)){l=a-1,f=s[o],o<l&&(i[o]=i[l],s[o]=s[l]),i.pop(),s.pop(),--t.pointCount,null!==r&&T(r)<=t.maxPoints&&r.merge();break}return f}function R(e,t,n){var r,o,a,i=n.children,s=null;if(n.contains(e,t.bias))if(null!==i)for(r=0,o=i.length;null===s&&r<o;++r)s=R(e,t,i[r]);else if(null!==n.points)for(r=0,o=(a=n.points).length;null===s&&r<o;++r)e.equals(a[r])&&(s=n.data[r]);return s}function M(e,t,n,r,o,a){var i,s,l,c=r.children,f=null;if(r.contains(e,n.bias))if(r.contains(t,n.bias)){if(null!==c)for(++a,i=0,s=c.length;null===f&&i<s;++i)f=M(e,t,n,c[i],r,a);else if(null!==r.points)for(i=0,s=(l=r.points).length;i<s;++i)if(e.equals(l[i])){l[i].copy(t),f=r.data[i];break}}else A(t,f=S(e,n,r,o),n,o,a-1);return f}function C(e,t,n,r){var o,a,i=null,s=t;if(null!==r.children){var l,c,f=r.children.map((function(t){return{octant:t,distance:t.distanceToCenterSquared(e)}})).sort((function(e,t){return e.distance-t.distance}));for(o=0,a=f.length;o<a&&(!(l=f[o].octant).contains(e,s)||null===(c=C(e,s,n,l))||(i=c,0!==(s=c.distance)));++o);}else if(null!==r.points){var u,d=r.points,p=-1;for(o=0,a=d.length;o<a;++o)if(d[o].equals(e)){if(!n){s=0,p=o;break}}else(u=e.distanceTo(d[o]))<s&&(s=u,p=o);0<=p&&(i={point:d[p],data:r.data[p],distance:s})}return i}function L(e,t,n,r,o){var a,i,s,l=r.children;if(null!==l)for(a=0,i=l.length;a<i;++a)(s=l[a]).contains(e,t)&&L(e,t,n,s,o);else if(null!==r.points){var c,f=r.points;for(a=0,i=f.length;a<i;++a)(c=f[a]).equals(e)?!n&&o.push({point:c.clone(),data:r.data[a]}):c.distanceToSquared(e)<=t*t&&o.push({point:c.clone(),data:r.data[a]})}}var P=[new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7]),new Uint8Array([0,2]),new Uint8Array([1,3]),new Uint8Array([4,6]),new Uint8Array([5,7]),new Uint8Array([0,1]),new Uint8Array([2,3]),new Uint8Array([4,5]),new Uint8Array([6,7])],k=[new Uint8Array([0,0,0]),new Uint8Array([0,0,1]),new Uint8Array([0,1,0]),new Uint8Array([0,1,1]),new Uint8Array([1,0,0]),new Uint8Array([1,0,1]),new Uint8Array([1,1,0]),new Uint8Array([1,1,1])],N=function(){var e=Math.cos,i=Math.sin;function l(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:0,t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0;s(this,l),this.x=e,this.y=t,this.z=n}return c(l,[{key:"set",value:function(e,t,n){return this.x=e,this.y=t,this.z=n,this}},{key:"copy",value:function(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}},{key:"clone",value:function(){return new this.constructor(this.x,this.y,this.z)}},{key:"fromArray",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}},{key:"toArray",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[],t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}},{key:"setFromSpherical",value:function(e){this.setFromSphericalCoords(e.radius,e.phi,e.theta)}},{key:"setFromSphericalCoords",value:function(t,n,r){var o=i(n)*t;return this.x=o*i(r),this.y=e(n)*t,this.z=o*e(r),this}},{key:"setFromCylindrical",value:function(e){this.setFromCylindricalCoords(e.radius,e.theta,e.y)}},{key:"setFromCylindricalCoords",value:function(t,n,r){return this.x=t*i(n),this.y=r,this.z=t*e(n),this}},{key:"setFromMatrixColumn",value:function(e,t){return this.fromArray(e.elements,4*t)}},{key:"setFromMatrixPosition",value:function(e){var t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}},{key:"setFromMatrixScale",value:function(e){var t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}},{key:"add",value:function(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}},{key:"addScalar",value:function(e){return this.x+=e,this.y+=e,this.z+=e,this}},{key:"addVectors",value:function(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}},{key:"addScaledVector",value:function(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}},{key:"sub",value:function(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}},{key:"subScalar",value:function(e){return this.x-=e,this.y-=e,this.z-=e,this}},{key:"subVectors",value:function(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}},{key:"multiply",value:function(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}},{key:"multiplyScalar",value:function(e){return this.x*=e,this.y*=e,this.z*=e,this}},{key:"multiplyVectors",value:function(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}},{key:"divide",value:function(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}},{key:"divideScalar",value:function(e){return this.x/=e,this.y/=e,this.z/=e,this}},{key:"crossVectors",value:function(e,t){var n=e.x,r=e.y,o=e.z,a=t.x,i=t.y,s=t.z;return this.x=r*s-o*i,this.y=o*a-n*s,this.z=n*i-r*a,this}},{key:"cross",value:function(e){return this.crossVectors(this,e)}},{key:"transformDirection",value:function(e){var t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r,this.y=o[1]*t+o[5]*n+o[9]*r,this.z=o[2]*t+o[6]*n+o[10]*r,this.normalize()}},{key:"applyMatrix3",value:function(e){var t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6]*r,this.y=o[1]*t+o[4]*n+o[7]*r,this.z=o[2]*t+o[5]*n+o[8]*r,this}},{key:"applyMatrix4",value:function(e){var t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r+o[12],this.y=o[1]*t+o[5]*n+o[9]*r+o[13],this.z=o[2]*t+o[6]*n+o[10]*r+o[14],this}},{key:"applyQuaternion",value:function(e){var t=this.x,n=this.y,r=this.z,o=e.x,a=e.y,i=e.z,s=e.w,l=s*t+a*r-i*n,c=s*n+i*t-o*r,f=s*r+o*n-a*t,u=-o*t-a*n-i*r;return this.x=l*s+u*-o+c*-i-f*-a,this.y=c*s+u*-a+f*-o-l*-i,this.z=f*s+u*-i+l*-a-c*-o,this}},{key:"negate",value:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}},{key:"dot",value:function(e){return this.x*e.x+this.y*e.y+this.z*e.z}},{key:"reflect",value:function(e){var t=e.x,n=e.y,r=e.z;return this.sub(e.multiplyScalar(2*this.dot(e))),e.set(t,n,r),this}},{key:"angleTo",value:function(e){var t=Math.acos,n=this.dot(e)/a(this.lengthSquared()*e.lengthSquared());return t(r(o(n,-1),1))}},{key:"manhattanLength",value:function(){return n(this.x)+n(this.y)+n(this.z)}},{key:"lengthSquared",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"length",value:function(){return a(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"manhattanDistanceTo",value:function(e){return n(this.x-e.x)+n(this.y-e.y)+n(this.z-e.z)}},{key:"distanceToSquared",value:function(e){var t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}},{key:"distanceTo",value:function(e){return a(this.distanceToSquared(e))}},{key:"normalize",value:function(){return this.divideScalar(this.length())}},{key:"setLength",value:function(e){return this.normalize().multiplyScalar(e)}},{key:"min",value:function(e){return this.x=r(this.x,e.x),this.y=r(this.y,e.y),this.z=r(this.z,e.z),this}},{key:"max",value:function(e){return this.x=o(this.x,e.x),this.y=o(this.y,e.y),this.z=o(this.z,e.z),this}},{key:"clamp",value:function(e,t){return this.x=o(e.x,r(t.x,this.x)),this.y=o(e.y,r(t.y,this.y)),this.z=o(e.z,r(t.z,this.z)),this}},{key:"floor",value:function(){var e=Math.floor;return this.x=e(this.x),this.y=e(this.y),this.z=e(this.z),this}},{key:"ceil",value:function(){var e=Math.ceil;return this.x=e(this.x),this.y=e(this.y),this.z=e(this.z),this}},{key:"round",value:function(){return this.x=t(this.x),this.y=t(this.y),this.z=t(this.z),this}},{key:"lerp",value:function(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}},{key:"lerpVectors",value:function(e,t,n){return this.subVectors(t,e).multiplyScalar(n).add(e)}},{key:"equals",value:function(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}}]),l}(),H=new N,z=[new N,new N,new N,new N,new N,new N,new N,new N],D=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N(1/0,1/0,1/0),n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N(-1/0,-1/0,-1/0);s(this,e),this.min=t,this.max=n}return c(e,[{key:"set",value:function(e,t){return this.min.copy(e),this.max.copy(t),this}},{key:"copy",value:function(e){return this.min.copy(e.min),this.max.copy(e.max),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"makeEmpty",value:function(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}},{key:"isEmpty",value:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}},{key:"getCenter",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N;return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getSize",value:function(){var e=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N;return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}},{key:"setFromSphere",value:function(e){return this.set(e.center,e.center),this.expandByScalar(e.radius),this}},{key:"expandByPoint",value:function(e){return this.min.min(e),this.max.max(e),this}},{key:"expandByVector",value:function(e){return this.min.sub(e),this.max.add(e),this}},{key:"expandByScalar",value:function(e){return this.min.addScalar(-e),this.max.addScalar(e),this}},{key:"setFromPoints",value:function(e){var t,n;for(this.min.set(0,0,0),this.max.set(0,0,0),t=0,n=e.length;t<n;++t)this.expandByPoint(e[t]);return this}},{key:"setFromCenterAndSize",value:function(e,t){var n=H.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}},{key:"clampPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N;return t.copy(e).clamp(this.min,this.max)}},{key:"distanceToPoint",value:function(e){return H.copy(e).clamp(this.min,this.max).sub(e).length()}},{key:"applyMatrix4",value:function(e){var t=this.min,n=this.max;return this.isEmpty()||(z[0].set(t.x,t.y,t.z).applyMatrix4(e),z[1].set(t.x,t.y,n.z).applyMatrix4(e),z[2].set(t.x,n.y,t.z).applyMatrix4(e),z[3].set(t.x,n.y,n.z).applyMatrix4(e),z[4].set(n.x,t.y,t.z).applyMatrix4(e),z[5].set(n.x,t.y,n.z).applyMatrix4(e),z[6].set(n.x,n.y,t.z).applyMatrix4(e),z[7].set(n.x,n.y,n.z).applyMatrix4(e),this.setFromPoints(z)),this}},{key:"translate",value:function(e){return this.min.add(e),this.max.add(e),this}},{key:"intersect",value:function(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}},{key:"union",value:function(e){return this.min.min(e.min),this.max.max(e.max),this}},{key:"containsPoint",value:function(e){var t=this.min,n=this.max;return e.x>=t.x&&e.y>=t.y&&e.z>=t.z&&e.x<=n.x&&e.y<=n.y&&e.z<=n.z}},{key:"containsBox",value:function(e){var t=this.min,n=this.max,r=e.min,o=e.max;return t.x<=r.x&&o.x<=n.x&&t.y<=r.y&&o.y<=n.y&&t.z<=r.z&&o.z<=n.z}},{key:"intersectsBox",value:function(e){var t=this.min,n=this.max,r=e.min,o=e.max;return o.x>=t.x&&o.y>=t.y&&o.z>=t.z&&r.x<=n.x&&r.y<=n.y&&r.z<=n.z}},{key:"intersectsSphere",value:function(e){return this.clampPoint(e.center,H).distanceToSquared(e.center)<=e.radius*e.radius}},{key:"intersectsPlane",value:function(e){var t,n;return 0<e.normal.x?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),0<e.normal.y?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),0<e.normal.z?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}},{key:"equals",value:function(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}]),e}(),F=[new N,new N,new N,new N],I=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N;s(this,e),this.origin=t,this.direction=n}return c(e,[{key:"set",value:function(e,t){return this.origin.copy(e),this.direction.copy(t),this}},{key:"copy",value:function(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}},{key:"clone",value:function(){return(new this.constructor).copy(this)}},{key:"at",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N;return t.copy(this.direction).multiplyScalar(e).add(this.origin)}},{key:"lookAt",value:function(e){return this.direction.copy(e).sub(this.origin).normalize(),this}},{key:"recast",value:function(e){return this.origin.copy(this.at(e,F[0])),this}},{key:"closestPointToPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N,n=t.subVectors(e,this.origin).dot(this.direction);return 0<=n?t.copy(this.direction).multiplyScalar(n).add(this.origin):t.copy(this.origin)}},{key:"distanceSquaredToPoint",value:function(e){var t=F[0].subVectors(e,this.origin).dot(this.direction);return 0>t?this.origin.distanceToSquared(e):F[0].copy(this.direction).multiplyScalar(t).add(this.origin).distanceToSquared(e)}},{key:"distanceToPoint",value:function(e){return a(this.distanceSquaredToPoint(e))}},{key:"distanceToPlane",value:function(e){var t=e.normal.dot(this.direction),n=0===t?0===e.distanceToPoint(this.origin)?0:-1:-(this.origin.dot(e.normal)+e.constant)/t;return 0<=n?n:null}},{key:"distanceSquaredToSegment",value:function(e,t,a,i){var s,l,c,f,u,d=F[0].copy(e).add(t).multiplyScalar(.5),p=F[1].copy(t).sub(e).normalize(),h=F[2].copy(this.origin).sub(d),v=.5*e.distanceTo(t),m=-this.direction.dot(p),x=h.dot(this.direction),g=-h.dot(p),y=h.lengthSq(),E=n(1-m*m);return 0<E?(l=m*x-g,c=v*E,0<=(s=m*g-x)?u=l>=-c?l<=c?(s*=f=1/E)*(s+m*(l*=f)+2*x)+l*(m*s+l+2*g)+y:-(s=o(0,-(m*(l=v)+x)))*s+l*(l+2*g)+y:-(s=o(0,-(m*(l=-v)+x)))*s+l*(l+2*g)+y:l<=-c?u=-(s=o(0,-(-m*v+x)))*s+(l=0<s?-v:r(o(-v,-g),v))*(l+2*g)+y:l<=c?(s=0,u=(l=r(o(-v,-g),v))*(l+2*g)+y):u=-(s=o(0,-(m*v+x)))*s+(l=0<s?v:r(o(-v,-g),v))*(l+2*g)+y):u=-(s=o(0,-(m*(l=0<m?-v:v)+x)))*s+l*(l+2*g)+y,void 0!==a&&a.copy(this.direction).multiplyScalar(s).add(this.origin),void 0!==i&&i.copy(p).multiplyScalar(l).add(d),u}},{key:"intersectSphere",value:function(e){var t,n,r,o=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N,i=F[0].subVectors(e.center,this.origin),s=i.dot(this.direction),l=i.dot(i)-s*s,c=e.radius*e.radius,f=null;return l<=c&&(r=s+(t=a(c-l)),(0<=(n=s-t)||0<=r)&&(f=0>n?this.at(r,o):this.at(n,o))),f}},{key:"intersectsSphere",value:function(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}},{key:"intersectPlane",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N,n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}},{key:"intersectsPlane",value:function(e){var t=e.distanceToPoint(this.origin);return 0===t||0>e.normal.dot(this.direction)*t}},{key:"intersectBox",value:function(e){var t,n,r,o,a,i,s=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N,l=this.origin,c=this.direction,f=e.min,u=e.max,d=1/c.x,p=1/c.y,h=1/c.z,v=null;return 0<=d?(t=(f.x-l.x)*d,n=(u.x-l.x)*d):(t=(u.x-l.x)*d,n=(f.x-l.x)*d),0<=p?(r=(f.y-l.y)*p,o=(u.y-l.y)*p):(r=(u.y-l.y)*p,o=(f.y-l.y)*p),t<=o&&r<=n&&((r>t||t!=t)&&(t=r),(o<n||n!=n)&&(n=o),0<=h?(a=(f.z-l.z)*h,i=(u.z-l.z)*h):(a=(u.z-l.z)*h,i=(f.z-l.z)*h),t<=i&&a<=n&&((a>t||t!=t)&&(t=a),(i<n||n!=n)&&(n=i),0<=n&&(v=this.at(0<=t?t:n,s)))),v}},{key:"intersectsBox",value:function(e){return null!==this.intersectBox(e,F[0])}},{key:"intersectTriangle",value:function(e,t,n,r,o){var a,i,s,l,c,f=this.direction,u=F[0],d=F[1],p=F[2],h=F[3],v=null;return d.subVectors(t,e),p.subVectors(n,e),h.crossVectors(d,p),0===(a=f.dot(h))||r&&0<a||(0<a?i=1:(i=-1,a=-a),u.subVectors(this.origin,e),0<=(s=i*f.dot(p.crossVectors(u,p)))&&0<=(l=i*f.dot(d.cross(u)))&&s+l<=a&&0<=(c=-i*u.dot(h))&&(v=this.at(c/a,o))),v}},{key:"applyMatrix4",value:function(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}},{key:"equals",value:function(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}}]),e}(),O=new N,U=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0;s(this,e),this.min=t,this.size=n,this.children=null}return c(e,[{key:"getCenter",value:function(e){return e.copy(this.min).addScalar(.5*this.size)}},{key:"getDimensions",value:function(e){return e.set(this.size,this.size,this.size)}},{key:"split",value:function(){var e,t,n=this.min,r=this.getCenter(O),o=.5*this.size,a=this.children=[null,null,null,null,null,null,null,null];for(e=0;8>e;++e)t=k[e],a[e]=new this.constructor(new N(0===t[0]?n.x:r.x,0===t[1]?n.y:r.y,0===t[2]?n.z:r.z),o)}},{key:"max",get:function(){return this.min.clone().addScalar(this.size)}}]),e}(),G=new N,B=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:new N,n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:new N;s(this,e),this.min=t,this.max=n,this.children=null}return c(e,[{key:"getCenter",value:function(e){return e.addVectors(this.min,this.max).multiplyScalar(.5)}},{key:"getDimensions",value:function(e){return e.subVectors(this.max,this.min)}},{key:"split",value:function(){var e,t,n=this.min,r=this.max,o=this.getCenter(G),a=this.children=[null,null,null,null,null,null,null,null];for(e=0;8>e;++e)t=k[e],a[e]=new this.constructor(new N(0===t[0]?n.x:o.x,0===t[1]?n.y:o.y,0===t[2]?n.z:o.z),new N(0===t[0]?o.x:r.x,0===t[1]?o.y:r.y,0===t[2]?o.z:r.z))}}]),e}(),V=function e(t,n,r){var o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s(this,e),this.distance=t,this.distanceToRay=n,this.point=r,this.object=o},W=function e(){s(this,e),this.value=0},j=[new Uint8Array([4,2,1]),new Uint8Array([5,3,8]),new Uint8Array([6,8,3]),new Uint8Array([7,8,8]),new Uint8Array([8,6,5]),new Uint8Array([8,7,8]),new Uint8Array([8,8,7]),new Uint8Array([8,8,8])],q=new N,X=new D,Y=new D,Q=new I,K=new W,Z=function(){function e(){s(this,e)}return c(e,null,[{key:"intersectOctree",value:function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:[],r=y(e,t,K);null!==r&&E.apply(void 0,[e.root].concat(v(r),[n]))}}]),e}(),J=function(){function e(){var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null,n=!!(1<arguments.length&&void 0!==arguments[1])&&arguments[1];s(this,e),this.value=t,this.done=n}return c(e,[{key:"reset",value:function(){this.value=null,this.done=!1}}]),e}(),$=new D,ee=function(){function e(t){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;s(this,e),this.octree=t,this.region=n,this.cull=null!==n,this.result=new J,this.trace=null,this.indices=null,this.reset()}return c(e,[{key:"reset",value:function(){var e=this.octree.root;return this.trace=[],this.indices=[],null!==e&&($.min=e.min,$.max=e.max,(!this.cull||this.region.intersectsBox($))&&(this.trace.push(e),this.indices.push(0))),this.result.reset(),this}},{key:"next",value:function(){for(var e,t,n,r=this.cull,o=this.region,a=this.indices,i=this.trace,s=null,l=i.length-1;null===s&&0<=l;)if(e=a[l]++,t=i[l].children,8>e)if(null!==t){if(n=t[e],r&&($.min=n.min,$.max=n.max,!o.intersectsBox($)))continue;i.push(n),a.push(0),++l}else s=i.pop(),a.pop();else i.pop(),a.pop(),--l;return this.result.value=s,this.result.done=null===s,this.result}},{key:"return",value:function(e){return this.result.value=e,this.result.done=!0,this.result}},{key:Symbol.iterator,value:function(){return this}}]),e}(),te=new D,ne=function(){function e(t){s(this,e),this.root=t}return c(e,[{key:"getCenter",value:function(e){return this.root.getCenter(e)}},{key:"getDimensions",value:function(e){return this.root.getDimensions(e)}},{key:"cull",value:function(e){var t=[];return b(this.root,e,t),t}},{key:"getDepth",value:function(){return w(this.root)}},{key:"findNodesByLevel",value:function(e){var t=[];return _(this.root,e,0,t),t}},{key:"raycast",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[];return Z.intersectOctree(this,e.ray,t),t}},{key:"leaves",value:function(e){return new ee(this,e)}},{key:Symbol.iterator,value:function(){return new ee(this)}},{key:"min",get:function(){return this.root.min}},{key:"max",get:function(){return this.root.max}},{key:"children",get:function(){return this.root.children}}]),e}(),re=new N,oe=function(e){function t(e,n){var r;return s(this,t),(r=p(this,u(t).call(this,e,n))).points=null,r.data=null,r}return f(t,e),c(t,[{key:"distanceToSquared",value:function(e){return re.copy(e).clamp(this.min,this.max).sub(e).lengthSquared()}},{key:"distanceToCenterSquared",value:function(e){var t=this.getCenter(re),n=e.x-t.x,r=e.y-t.x,o=e.z-t.z;return n*n+r*r+o*o}},{key:"contains",value:function(e,t){var n=this.min,r=this.max;return e.x>=n.x-t&&e.y>=n.y-t&&e.z>=n.z-t&&e.x<=r.x+t&&e.y<=r.y+t&&e.z<=r.z+t}},{key:"redistribute",value:function(e){var t,n,r,o,a,i,s,l=this.children,c=this.points,f=this.data;if(null!==l&&null!==c){for(t=0,r=c.length;t<r;++t)for(i=c[t],s=f[t],n=0,o=l.length;n<o;++n)if((a=l[n]).contains(i,e)){null===a.points&&(a.points=[],a.data=[]),a.points.push(i),a.data.push(s);break}this.points=null,this.data=null}}},{key:"merge",value:function(){var e=this.children;if(null!==e){var t,n,r,o=[],a=[];for(t=0,n=e.length;t<n;++t)null!==(r=e[t]).points&&(o=o.concat(r.points),a=a.concat(r.data));this.children=null,this.points=o,this.data=a}}}]),t}(B),ae=function(e){function n(e,r){var a,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,l=3<arguments.length&&void 0!==arguments[3]?arguments[3]:8,c=4<arguments.length&&void 0!==arguments[4]?arguments[4]:8;return s(this,n),(a=p(this,u(n).call(this,new oe(e,r)))).bias=o(0,i),a.maxPoints=o(1,t(l)),a.maxDepth=o(0,t(c)),a.pointCount=0,a}return f(n,e),c(n,[{key:"countPoints",value:function(e){return T(e)}},{key:"insert",value:function(e,t){return A(e,t,this,this.root,0)}},{key:"remove",value:function(e){return S(e,this,this.root,null)}},{key:"get",value:function(e){return R(e,this,this.root)}},{key:"move",value:function(e,t){return M(e,t,this,this.root,null,0)}},{key:"findNearestPoint",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1/0,n=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],r=C(e,t,n,this.root);return null!==r&&(r.point=r.point.clone()),r}},{key:"findPoints",value:function(e,t){var n=!!(2<arguments.length&&void 0!==arguments[2])&&arguments[2],r=[];return L(e,t,n,this.root,r),r}},{key:"raycast",value:function(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[],r=h(u(n.prototype),"raycast",this).call(this,e);return 0<r.length&&m(r,e,t),t}}]),n}(ne);e.CubicOctant=U,e.Flags=W,e.Octant=B,e.Octree=ne,e.OctreeIterator=ee,e.OctreeRaycaster=Z,e.PointOctant=oe,e.PointOctree=ae,e.RayPointIntersection=V,e.edges=P,e.findEntryOctant=x,e.findNextOctant=g,e.intersectOctree=y,e.layout=k,e.testPoints=m,Object.defineProperty(e,"__esModule",{value:!0})},"object"===i(t)?a(t):(r=[t],void 0===(o="function"==typeof(n=a)?n.apply(t,r):n)||(e.exports=o))},9756:e=>{var t=function(){function e(e){return o.appendChild(e.dom),e}function n(e){for(var t=0;t<o.children.length;t++)o.children[t].style.display=t===e?"block":"none";r=e}var r=0,o=document.createElement("div");o.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",o.addEventListener("click",(function(e){e.preventDefault(),n(++r%o.children.length)}),!1);var a=(performance||Date).now(),i=a,s=0,l=e(new t.Panel("FPS","#0ff","#002")),c=e(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var f=e(new t.Panel("MB","#f08","#201"));return n(0),{REVISION:16,dom:o,addPanel:e,showPanel:n,begin:function(){a=(performance||Date).now()},end:function(){s++;var e=(performance||Date).now();if(c.update(e-a,200),e>i+1e3&&(l.update(1e3*s/(e-i),100),i=e,s=0,f)){var t=performance.memory;f.update(t.usedJSHeapSize/1048576,t.jsHeapSizeLimit/1048576)}return e},update:function(){a=this.end()},domElement:o,setMode:n}};t.Panel=function(e,t,n){var r=1/0,o=0,a=Math.round,i=a(window.devicePixelRatio||1),s=80*i,l=48*i,c=3*i,f=2*i,u=3*i,d=15*i,p=74*i,h=30*i,v=document.createElement("canvas");v.width=s,v.height=l,v.style.cssText="width:80px;height:48px";var m=v.getContext("2d");return m.font="bold "+9*i+"px Helvetica,Arial,sans-serif",m.textBaseline="top",m.fillStyle=n,m.fillRect(0,0,s,l),m.fillStyle=t,m.fillText(e,c,f),m.fillRect(u,d,p,h),m.fillStyle=n,m.globalAlpha=.9,m.fillRect(u,d,p,h),{dom:v,update:function(l,x){r=Math.min(r,l),o=Math.max(o,l),m.fillStyle=n,m.globalAlpha=1,m.fillRect(0,0,s,d),m.fillStyle=t,m.fillText(a(l)+" "+e+" ("+a(r)+"-"+a(o)+")",c,f),m.drawImage(v,u+i,d,p-i,h,u,d,p-i,h),m.fillRect(u+p-i,d,i,h),m.fillStyle=n,m.globalAlpha=.9,m.fillRect(u+p-i,d,i,a((1-l/x)*h))}}},e.exports=t},5370:function(e,t){!function(e){"use strict";const t="128",n={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},r={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},o=0,a=1,i=2,s=3,l=0,c=1,f=2,u=3,d=0,p=1,h=2,v=1,m=2,x=0,g=1,y=2,E=3,w=4,b=5,_=100,T=101,A=102,S=103,R=104,M=200,C=201,L=202,P=203,k=204,N=205,H=206,z=207,D=208,F=209,I=210,O=0,U=1,G=2,B=3,V=4,W=5,j=6,q=7,X=0,Y=1,Q=2,K=0,Z=1,J=2,$=3,ee=4,te=5,ne=300,re=301,oe=302,ae=303,ie=304,se=306,le=307,ce=1e3,fe=1001,ue=1002,de=1003,pe=1004,he=1004,ve=1005,me=1005,xe=1006,ge=1007,ye=1007,Ee=1008,we=1008,be=1009,_e=1010,Te=1011,Ae=1012,Se=1013,Re=1014,Me=1015,Ce=1016,Le=1017,Pe=1018,ke=1019,Ne=1020,He=1021,ze=1022,De=1023,Fe=1024,Ie=1025,Oe=De,Ue=1026,Ge=1027,Be=1028,Ve=1029,We=1030,je=1031,qe=1032,Xe=1033,Ye=33776,Qe=33777,Ke=33778,Ze=33779,Je=35840,$e=35841,et=35842,tt=35843,nt=36196,rt=37492,ot=37496,at=37808,it=37809,st=37810,lt=37811,ct=37812,ft=37813,ut=37814,dt=37815,pt=37816,ht=37817,vt=37818,mt=37819,xt=37820,gt=37821,yt=36492,Et=37840,wt=37841,bt=37842,_t=37843,Tt=37844,At=37845,St=37846,Rt=37847,Mt=37848,Ct=37849,Lt=37850,Pt=37851,kt=37852,Nt=37853,Ht=2200,zt=2201,Dt=2202,Ft=2300,It=2301,Ot=2302,Ut=2400,Gt=2401,Bt=2402,Vt=2500,Wt=2501,jt=0,qt=1,Xt=2,Yt=3e3,Qt=3001,Kt=3007,Zt=3002,Jt=3003,$t=3004,en=3005,tn=3006,nn=3200,rn=3201,on=0,an=1,sn=0,ln=7680,cn=7681,fn=7682,un=7683,dn=34055,pn=34056,hn=5386,vn=512,mn=513,xn=514,gn=515,yn=516,En=517,wn=518,bn=519,_n=35044,Tn=35048,An=35040,Sn=35045,Rn=35049,Mn=35041,Cn=35046,Ln=35050,Pn=35042,kn="100",Nn="300 es";class Hn{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const n=this._listeners;void 0===n[e]&&(n[e]=[]),-1===n[e].indexOf(t)&&n[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;const n=this._listeners;return void 0!==n[e]&&-1!==n[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const n=this._listeners[e];if(void 0!==n){const e=n.indexOf(t);-1!==e&&n.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const n=t.slice(0);for(let t=0,r=n.length;t<r;t++)n[t].call(this,e);e.target=null}}}const zn=[];for(let e=0;e<256;e++)zn[e]=(e<16?"0":"")+e.toString(16);let Dn=1234567;const Fn=Math.PI/180,In=180/Math.PI;function On(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,n=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(zn[255&e]+zn[e>>8&255]+zn[e>>16&255]+zn[e>>24&255]+"-"+zn[255&t]+zn[t>>8&255]+"-"+zn[t>>16&15|64]+zn[t>>24&255]+"-"+zn[63&n|128]+zn[n>>8&255]+"-"+zn[n>>16&255]+zn[n>>24&255]+zn[255&r]+zn[r>>8&255]+zn[r>>16&255]+zn[r>>24&255]).toUpperCase()}function Un(e,t,n){return Math.max(t,Math.min(n,e))}function Gn(e,t){return(e%t+t)%t}function Bn(e,t,n,r,o){return r+(e-t)*(o-r)/(n-t)}function Vn(e,t,n){return e!==t?(n-e)/(t-e):0}function Wn(e,t,n){return(1-n)*e+n*t}function jn(e,t,n,r){return Wn(e,t,1-Math.exp(-n*r))}function qn(e,t=1){return t-Math.abs(Gn(e,2*t)-t)}function Xn(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*(3-2*e)}function Yn(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t))*e*e*(e*(6*e-15)+10)}function Qn(e,t){return e+Math.floor(Math.random()*(t-e+1))}function Kn(e,t){return e+Math.random()*(t-e)}function Zn(e){return e*(.5-Math.random())}function Jn(e){return void 0!==e&&(Dn=e%2147483647),Dn=16807*Dn%2147483647,(Dn-1)/2147483646}function $n(e){return e*Fn}function er(e){return e*In}function tr(e){return 0==(e&e-1)&&0!==e}function nr(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function rr(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}function or(e,t,n,r,o){const a=Math.cos,i=Math.sin,s=a(n/2),l=i(n/2),c=a((t+r)/2),f=i((t+r)/2),u=a((t-r)/2),d=i((t-r)/2),p=a((r-t)/2),h=i((r-t)/2);switch(o){case"XYX":e.set(s*f,l*u,l*d,s*c);break;case"YZY":e.set(l*d,s*f,l*u,s*c);break;case"ZXZ":e.set(l*u,l*d,s*f,s*c);break;case"XZX":e.set(s*f,l*h,l*p,s*c);break;case"YXY":e.set(l*p,s*f,l*h,s*c);break;case"ZYZ":e.set(l*h,l*p,s*f,s*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+o)}}var ar=Object.freeze({__proto__:null,DEG2RAD:Fn,RAD2DEG:In,generateUUID:On,clamp:Un,euclideanModulo:Gn,mapLinear:Bn,inverseLerp:Vn,lerp:Wn,damp:jn,pingpong:qn,smoothstep:Xn,smootherstep:Yn,randInt:Qn,randFloat:Kn,randFloatSpread:Zn,seededRandom:Jn,degToRad:$n,radToDeg:er,isPowerOfTwo:tr,ceilPowerOfTwo:nr,floorPowerOfTwo:rr,setQuaternionFromProperEuler:or});class ir{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6],this.y=r[1]*t+r[4]*n+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),r=Math.sin(t),o=this.x-e.x,a=this.y-e.y;return this.x=o*n-a*r+e.x,this.y=o*r+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}ir.prototype.isVector2=!0;class sr{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,o,a,i,s,l){const c=this.elements;return c[0]=e,c[1]=r,c[2]=i,c[3]=t,c[4]=o,c[5]=s,c[6]=n,c[7]=a,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,o=this.elements,a=n[0],i=n[3],s=n[6],l=n[1],c=n[4],f=n[7],u=n[2],d=n[5],p=n[8],h=r[0],v=r[3],m=r[6],x=r[1],g=r[4],y=r[7],E=r[2],w=r[5],b=r[8];return o[0]=a*h+i*x+s*E,o[3]=a*v+i*g+s*w,o[6]=a*m+i*y+s*b,o[1]=l*h+c*x+f*E,o[4]=l*v+c*g+f*w,o[7]=l*m+c*y+f*b,o[2]=u*h+d*x+p*E,o[5]=u*v+d*g+p*w,o[8]=u*m+d*y+p*b,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*a*c-t*i*l-n*o*c+n*i*s+r*o*l-r*a*s}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],f=c*a-i*l,u=i*s-c*o,d=l*o-a*s,p=t*f+n*u+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const h=1/p;return e[0]=f*h,e[1]=(r*l-c*n)*h,e[2]=(i*n-r*a)*h,e[3]=u*h,e[4]=(c*t-r*s)*h,e[5]=(r*o-i*t)*h,e[6]=d*h,e[7]=(n*s-l*t)*h,e[8]=(a*t-n*o)*h,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,r,o,a,i){const s=Math.cos(o),l=Math.sin(o);return this.set(n*s,n*l,-n*(s*a+l*i)+a+e,-r*l,r*s,-r*(-l*a+s*i)+i+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),r=this.elements,o=r[0],a=r[3],i=r[6],s=r[1],l=r[4],c=r[7];return r[0]=t*o+n*s,r[3]=t*a+n*l,r[6]=t*i+n*c,r[1]=-n*o+t*s,r[4]=-n*a+t*l,r[7]=-n*i+t*c,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<9;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}let lr;sr.prototype.isMatrix3=!0;class cr{static getDataURL(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===lr&&(lr=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),lr.width=e.width,lr.height=e.height;const n=lr.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=lr}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let fr=0;class ur extends Hn{constructor(e=ur.DEFAULT_IMAGE,t=ur.DEFAULT_MAPPING,n=fe,r=fe,o=xe,a=Ee,i=De,s=be,l=1,c=Yt){super(),Object.defineProperty(this,"id",{value:fr++}),this.uuid=On(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=r,this.magFilter=o,this.minFilter=a,this.anisotropy=l,this.format=i,this.internalFormat=null,this.type=s,this.offset=new ir(0,0),this.repeat=new ir(1,1),this.center=new ir(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new sr,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this}toJSON(e){const t=void 0===e||"string"==typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const r=this.image;if(this.isDataTexture&&(r=document.createElement("canvas").getContext("2d").getImageData(0,0,r.width,r.height)),void 0===r.uuid&&(r.uuid=On()),!t&&void 0===e.images[r.uuid]){let t;if(Array.isArray(r)){t=[];for(let e=0,n=r.length;e<n;e++)r[e].isDataTexture?t.push(dr(r[e].image)):t.push(dr(r[e]))}else t=dr(r);e.images[r.uuid]={uuid:r.uuid,url:t}}n.image=r.uuid}return t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==ne)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ce:e.x=e.x-Math.floor(e.x);break;case fe:e.x=e.x<0?0:1;break;case ue:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case ce:e.y=e.y-Math.floor(e.y);break;case fe:e.y=e.y<0?0:1;break;case ue:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&this.version++}}function dr(e){return"undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap?cr.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}ur.DEFAULT_IMAGE=void 0,ur.DEFAULT_MAPPING=ne,ur.prototype.isTexture=!0;class pr{constructor(e=0,t=0,n=0,r=1){this.x=e,this.y=t,this.z=n,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,r){return this.x=e,this.y=t,this.z=n,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,o=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*r+a[12]*o,this.y=a[1]*t+a[5]*n+a[9]*r+a[13]*o,this.z=a[2]*t+a[6]*n+a[10]*r+a[14]*o,this.w=a[3]*t+a[7]*n+a[11]*r+a[15]*o,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,r,o;const a=.01,i=.1,s=e.elements,l=s[0],c=s[4],f=s[8],u=s[1],d=s[5],p=s[9],h=s[2],v=s[6],m=s[10];if(Math.abs(c-u)<a&&Math.abs(f-h)<a&&Math.abs(p-v)<a){if(Math.abs(c+u)<i&&Math.abs(f+h)<i&&Math.abs(p+v)<i&&Math.abs(l+d+m-3)<i)return this.set(1,0,0,0),this;t=Math.PI;const e=(l+1)/2,s=(d+1)/2,x=(m+1)/2,g=(c+u)/4,y=(f+h)/4,E=(p+v)/4;return e>s&&e>x?e<a?(n=0,r=.707106781,o=.707106781):(n=Math.sqrt(e),r=g/n,o=y/n):s>x?s<a?(n=.707106781,r=0,o=.707106781):(r=Math.sqrt(s),n=g/r,o=E/r):x<a?(n=.707106781,r=.707106781,o=0):(o=Math.sqrt(x),n=y/o,r=E/o),this.set(n,r,o,t),this}let x=Math.sqrt((v-p)*(v-p)+(f-h)*(f-h)+(u-c)*(u-c));return Math.abs(x)<.001&&(x=1),this.x=(v-p)/x,this.y=(f-h)/x,this.z=(u-c)/x,this.w=Math.acos((l+d+m-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}pr.prototype.isVector4=!0;class hr extends Hn{constructor(e,t,n){super(),this.width=e,this.height=t,this.depth=1,this.scissor=new pr(0,0,e,t),this.scissorTest=!1,this.viewport=new pr(0,0,e,t),n=n||{},this.texture=new ur(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=1,this.texture.generateMipmaps=void 0!==n.generateMipmaps&&n.generateMipmaps,this.texture.minFilter=void 0!==n.minFilter?n.minFilter:xe,this.depthBuffer=void 0===n.depthBuffer||n.depthBuffer,this.stencilBuffer=void 0!==n.stencilBuffer&&n.stencilBuffer,this.depthTexture=void 0!==n.depthTexture?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){this.width===e&&this.height===t&&this.depth===n||(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}hr.prototype.isWebGLRenderTarget=!0;class vr extends hr{constructor(e,t,n){super(e,t,n),this.samples=4}copy(e){return super.copy.call(this,e),this.samples=e.samples,this}}vr.prototype.isWebGLMultisampleRenderTarget=!0;class mr{constructor(e=0,t=0,n=0,r=1){this._x=e,this._y=t,this._z=n,this._w=r}static slerp(e,t,n,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,r)}static slerpFlat(e,t,n,r,o,a,i){let s=n[r+0],l=n[r+1],c=n[r+2],f=n[r+3];const u=o[a+0],d=o[a+1],p=o[a+2],h=o[a+3];if(0===i)return e[t+0]=s,e[t+1]=l,e[t+2]=c,void(e[t+3]=f);if(1===i)return e[t+0]=u,e[t+1]=d,e[t+2]=p,void(e[t+3]=h);if(f!==h||s!==u||l!==d||c!==p){let e=1-i;const t=s*u+l*d+c*p+f*h,n=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const o=Math.sqrt(r),a=Math.atan2(o,t*n);e=Math.sin(e*a)/o,i=Math.sin(i*a)/o}const o=i*n;if(s=s*e+u*o,l=l*e+d*o,c=c*e+p*o,f=f*e+h*o,e===1-i){const e=1/Math.sqrt(s*s+l*l+c*c+f*f);s*=e,l*=e,c*=e,f*=e}}e[t]=s,e[t+1]=l,e[t+2]=c,e[t+3]=f}static multiplyQuaternionsFlat(e,t,n,r,o,a){const i=n[r],s=n[r+1],l=n[r+2],c=n[r+3],f=o[a],u=o[a+1],d=o[a+2],p=o[a+3];return e[t]=i*p+c*f+s*d-l*u,e[t+1]=s*p+c*u+l*f-i*d,e[t+2]=l*p+c*d+i*u-s*f,e[t+3]=c*p-i*f-s*u-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,r=e._y,o=e._z,a=e._order,i=Math.cos,s=Math.sin,l=i(n/2),c=i(r/2),f=i(o/2),u=s(n/2),d=s(r/2),p=s(o/2);switch(a){case"XYZ":this._x=u*c*f+l*d*p,this._y=l*d*f-u*c*p,this._z=l*c*p+u*d*f,this._w=l*c*f-u*d*p;break;case"YXZ":this._x=u*c*f+l*d*p,this._y=l*d*f-u*c*p,this._z=l*c*p-u*d*f,this._w=l*c*f+u*d*p;break;case"ZXY":this._x=u*c*f-l*d*p,this._y=l*d*f+u*c*p,this._z=l*c*p+u*d*f,this._w=l*c*f-u*d*p;break;case"ZYX":this._x=u*c*f-l*d*p,this._y=l*d*f+u*c*p,this._z=l*c*p-u*d*f,this._w=l*c*f+u*d*p;break;case"YZX":this._x=u*c*f+l*d*p,this._y=l*d*f+u*c*p,this._z=l*c*p-u*d*f,this._w=l*c*f-u*d*p;break;case"XZY":this._x=u*c*f-l*d*p,this._y=l*d*f-u*c*p,this._z=l*c*p+u*d*f,this._w=l*c*f+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,r=Math.sin(n);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],r=t[4],o=t[8],a=t[1],i=t[5],s=t[9],l=t[2],c=t[6],f=t[10],u=n+i+f;if(u>0){const e=.5/Math.sqrt(u+1);this._w=.25/e,this._x=(c-s)*e,this._y=(o-l)*e,this._z=(a-r)*e}else if(n>i&&n>f){const e=2*Math.sqrt(1+n-i-f);this._w=(c-s)/e,this._x=.25*e,this._y=(r+a)/e,this._z=(o+l)/e}else if(i>f){const e=2*Math.sqrt(1+i-n-f);this._w=(o-l)/e,this._x=(r+a)/e,this._y=.25*e,this._z=(s+c)/e}else{const e=2*Math.sqrt(1+f-n-i);this._w=(a-r)/e,this._x=(o+l)/e,this._y=(s+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Un(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(0===n)return this;const r=Math.min(1,t/n);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return void 0!==t?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,r=e._y,o=e._z,a=e._w,i=t._x,s=t._y,l=t._z,c=t._w;return this._x=n*c+a*i+r*l-o*s,this._y=r*c+a*s+o*i-n*l,this._z=o*c+a*l+n*s-r*i,this._w=a*c-n*i-r*s-o*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const n=this._x,r=this._y,o=this._z,a=this._w;let i=a*e._w+n*e._x+r*e._y+o*e._z;if(i<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,i=-i):this.copy(e),i>=1)return this._w=a,this._x=n,this._y=r,this._z=o,this;const s=1-i*i;if(s<=Number.EPSILON){const e=1-t;return this._w=e*a+t*this._w,this._x=e*n+t*this._x,this._y=e*r+t*this._y,this._z=e*o+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(s),c=Math.atan2(l,i),f=Math.sin((1-t)*c)/l,u=Math.sin(t*c)/l;return this._w=a*f+this._w*u,this._x=n*f+this._x*u,this._y=r*f+this._y*u,this._z=o*f+this._z*u,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}mr.prototype.isQuaternion=!0;class xr{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return void 0===n&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return void 0!==t?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return void 0!==t?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(yr.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(yr.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[3]*n+o[6]*r,this.y=o[1]*t+o[4]*n+o[7]*r,this.z=o[2]*t+o[5]*n+o[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,r=this.z,o=e.elements,a=1/(o[3]*t+o[7]*n+o[11]*r+o[15]);return this.x=(o[0]*t+o[4]*n+o[8]*r+o[12])*a,this.y=(o[1]*t+o[5]*n+o[9]*r+o[13])*a,this.z=(o[2]*t+o[6]*n+o[10]*r+o[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,r=this.z,o=e.x,a=e.y,i=e.z,s=e.w,l=s*t+a*r-i*n,c=s*n+i*t-o*r,f=s*r+o*n-a*t,u=-o*t-a*n-i*r;return this.x=l*s+u*-o+c*-i-f*-a,this.y=c*s+u*-a+f*-o-l*-i,this.z=f*s+u*-i+l*-a-c*-o,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,r=this.z,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*r,this.y=o[1]*t+o[5]*n+o[9]*r,this.z=o[2]*t+o[6]*n+o[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return void 0!==t?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,r=e.y,o=e.z,a=t.x,i=t.y,s=t.z;return this.x=r*s-o*i,this.y=o*a-n*s,this.z=n*i-r*a,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return gr.copy(this).projectOnVector(e),this.sub(gr)}reflect(e){return this.sub(gr.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Un(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,r=this.z-e.z;return t*t+n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const r=Math.sin(t)*e;return this.x=r*Math.sin(n),this.y=Math.cos(t)*e,this.z=r*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return void 0!==n&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}xr.prototype.isVector3=!0;const gr=new xr,yr=new mr;class Er{constructor(e=new xr(1/0,1/0,1/0),t=new xr(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,r=1/0,o=-1/0,a=-1/0,i=-1/0;for(let s=0,l=e.length;s<l;s+=3){const l=e[s],c=e[s+1],f=e[s+2];l<t&&(t=l),c<n&&(n=c),f<r&&(r=f),l>o&&(o=l),c>a&&(a=c),f>i&&(i=f)}return this.min.set(t,n,r),this.max.set(o,a,i),this}setFromBufferAttribute(e){let t=1/0,n=1/0,r=1/0,o=-1/0,a=-1/0,i=-1/0;for(let s=0,l=e.count;s<l;s++){const l=e.getX(s),c=e.getY(s),f=e.getZ(s);l<t&&(t=l),c<n&&(n=c),f<r&&(r=f),l>o&&(o=l),c>a&&(a=c),f>i&&(i=f)}return this.min.set(t,n,r),this.max.set(o,a,i),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=br.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return void 0===e&&(console.warn("THREE.Box3: .getCenter() target is now required"),e=new xr),this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box3: .getSize() target is now required"),e=new xr),this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;void 0!==t&&(null===t.boundingBox&&t.computeBoundingBox(),_r.copy(t.boundingBox),_r.applyMatrix4(e.matrixWorld),this.union(_r));const n=e.children;for(let e=0,t=n.length;e<t;e++)this.expandByObject(n[e]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box3: .getParameter() target is now required"),t=new xr),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,br),br.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Lr),Pr.subVectors(this.max,Lr),Tr.subVectors(e.a,Lr),Ar.subVectors(e.b,Lr),Sr.subVectors(e.c,Lr),Rr.subVectors(Ar,Tr),Mr.subVectors(Sr,Ar),Cr.subVectors(Tr,Sr);let t=[0,-Rr.z,Rr.y,0,-Mr.z,Mr.y,0,-Cr.z,Cr.y,Rr.z,0,-Rr.x,Mr.z,0,-Mr.x,Cr.z,0,-Cr.x,-Rr.y,Rr.x,0,-Mr.y,Mr.x,0,-Cr.y,Cr.x,0];return!!Hr(t,Tr,Ar,Sr,Pr)&&(t=[1,0,0,0,1,0,0,0,1],!!Hr(t,Tr,Ar,Sr,Pr)&&(kr.crossVectors(Rr,Mr),t=[kr.x,kr.y,kr.z],Hr(t,Tr,Ar,Sr,Pr)))}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box3: .clampPoint() target is now required"),t=new xr),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return br.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return void 0===e&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(e.center),e.radius=.5*this.getSize(br).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(wr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),wr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),wr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),wr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),wr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),wr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),wr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),wr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(wr)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Er.prototype.isBox3=!0;const wr=[new xr,new xr,new xr,new xr,new xr,new xr,new xr,new xr],br=new xr,_r=new Er,Tr=new xr,Ar=new xr,Sr=new xr,Rr=new xr,Mr=new xr,Cr=new xr,Lr=new xr,Pr=new xr,kr=new xr,Nr=new xr;function Hr(e,t,n,r,o){for(let a=0,i=e.length-3;a<=i;a+=3){Nr.fromArray(e,a);const i=o.x*Math.abs(Nr.x)+o.y*Math.abs(Nr.y)+o.z*Math.abs(Nr.z),s=t.dot(Nr),l=n.dot(Nr),c=r.dot(Nr);if(Math.max(-Math.max(s,l,c),Math.min(s,l,c))>i)return!1}return!0}const zr=new Er,Dr=new xr,Fr=new xr,Ir=new xr;class Or{constructor(e=new xr,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;void 0!==t?n.copy(t):zr.setFromPoints(e).getCenter(n);let r=0;for(let t=0,o=e.length;t<o;t++)r=Math.max(r,n.distanceToSquared(e[t]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return void 0===t&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),t=new xr),t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return void 0===e&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),e=new Er),this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){Ir.subVectors(e,this.center);const t=Ir.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),n=.5*(e-this.radius);this.center.add(Ir.multiplyScalar(n/e)),this.radius+=n}return this}union(e){return Fr.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(Dr.copy(e.center).add(Fr)),this.expandByPoint(Dr.copy(e.center).sub(Fr)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Ur=new xr,Gr=new xr,Br=new xr,Vr=new xr,Wr=new xr,jr=new xr,qr=new xr;class Xr{constructor(e=new xr,t=new xr(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return void 0===t&&(console.warn("THREE.Ray: .at() target is now required"),t=new xr),t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Ur)),this}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),t=new xr),t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Ur.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Ur.copy(this.direction).multiplyScalar(t).add(this.origin),Ur.distanceToSquared(e))}distanceSqToSegment(e,t,n,r){Gr.copy(e).add(t).multiplyScalar(.5),Br.copy(t).sub(e).normalize(),Vr.copy(this.origin).sub(Gr);const o=.5*e.distanceTo(t),a=-this.direction.dot(Br),i=Vr.dot(this.direction),s=-Vr.dot(Br),l=Vr.lengthSq(),c=Math.abs(1-a*a);let f,u,d,p;if(c>0)if(f=a*s-i,u=a*i-s,p=o*c,f>=0)if(u>=-p)if(u<=p){const e=1/c;f*=e,u*=e,d=f*(f+a*u+2*i)+u*(a*f+u+2*s)+l}else u=o,f=Math.max(0,-(a*u+i)),d=-f*f+u*(u+2*s)+l;else u=-o,f=Math.max(0,-(a*u+i)),d=-f*f+u*(u+2*s)+l;else u<=-p?(f=Math.max(0,-(-a*o+i)),u=f>0?-o:Math.min(Math.max(-o,-s),o),d=-f*f+u*(u+2*s)+l):u<=p?(f=0,u=Math.min(Math.max(-o,-s),o),d=u*(u+2*s)+l):(f=Math.max(0,-(a*o+i)),u=f>0?o:Math.min(Math.max(-o,-s),o),d=-f*f+u*(u+2*s)+l);else u=a>0?-o:o,f=Math.max(0,-(a*u+i)),d=-f*f+u*(u+2*s)+l;return n&&n.copy(this.direction).multiplyScalar(f).add(this.origin),r&&r.copy(Br).multiplyScalar(u).add(Gr),d}intersectSphere(e,t){Ur.subVectors(e.center,this.origin);const n=Ur.dot(this.direction),r=Ur.dot(Ur)-n*n,o=e.radius*e.radius;if(r>o)return null;const a=Math.sqrt(o-r),i=n-a,s=n+a;return i<0&&s<0?null:i<0?this.at(s,t):this.at(i,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return null===n?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return 0===t||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,r,o,a,i,s;const l=1/this.direction.x,c=1/this.direction.y,f=1/this.direction.z,u=this.origin;return l>=0?(n=(e.min.x-u.x)*l,r=(e.max.x-u.x)*l):(n=(e.max.x-u.x)*l,r=(e.min.x-u.x)*l),c>=0?(o=(e.min.y-u.y)*c,a=(e.max.y-u.y)*c):(o=(e.max.y-u.y)*c,a=(e.min.y-u.y)*c),n>a||o>r?null:((o>n||n!=n)&&(n=o),(a<r||r!=r)&&(r=a),f>=0?(i=(e.min.z-u.z)*f,s=(e.max.z-u.z)*f):(i=(e.max.z-u.z)*f,s=(e.min.z-u.z)*f),n>s||i>r?null:((i>n||n!=n)&&(n=i),(s<r||r!=r)&&(r=s),r<0?null:this.at(n>=0?n:r,t)))}intersectsBox(e){return null!==this.intersectBox(e,Ur)}intersectTriangle(e,t,n,r,o){Wr.subVectors(t,e),jr.subVectors(n,e),qr.crossVectors(Wr,jr);let a,i=this.direction.dot(qr);if(i>0){if(r)return null;a=1}else{if(!(i<0))return null;a=-1,i=-i}Vr.subVectors(this.origin,e);const s=a*this.direction.dot(jr.crossVectors(Vr,jr));if(s<0)return null;const l=a*this.direction.dot(Wr.cross(Vr));if(l<0)return null;if(s+l>i)return null;const c=-a*Vr.dot(qr);return c<0?null:this.at(c/i,o)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Yr{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,r,o,a,i,s,l,c,f,u,d,p,h,v){const m=this.elements;return m[0]=e,m[4]=t,m[8]=n,m[12]=r,m[1]=o,m[5]=a,m[9]=i,m[13]=s,m[2]=l,m[6]=c,m[10]=f,m[14]=u,m[3]=d,m[7]=p,m[11]=h,m[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Yr).fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,r=1/Qr.setFromMatrixColumn(e,0).length(),o=1/Qr.setFromMatrixColumn(e,1).length(),a=1/Qr.setFromMatrixColumn(e,2).length();return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=0,t[4]=n[4]*o,t[5]=n[5]*o,t[6]=n[6]*o,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,r=e.y,o=e.z,a=Math.cos(n),i=Math.sin(n),s=Math.cos(r),l=Math.sin(r),c=Math.cos(o),f=Math.sin(o);if("XYZ"===e.order){const e=a*c,n=a*f,r=i*c,o=i*f;t[0]=s*c,t[4]=-s*f,t[8]=l,t[1]=n+r*l,t[5]=e-o*l,t[9]=-i*s,t[2]=o-e*l,t[6]=r+n*l,t[10]=a*s}else if("YXZ"===e.order){const e=s*c,n=s*f,r=l*c,o=l*f;t[0]=e+o*i,t[4]=r*i-n,t[8]=a*l,t[1]=a*f,t[5]=a*c,t[9]=-i,t[2]=n*i-r,t[6]=o+e*i,t[10]=a*s}else if("ZXY"===e.order){const e=s*c,n=s*f,r=l*c,o=l*f;t[0]=e-o*i,t[4]=-a*f,t[8]=r+n*i,t[1]=n+r*i,t[5]=a*c,t[9]=o-e*i,t[2]=-a*l,t[6]=i,t[10]=a*s}else if("ZYX"===e.order){const e=a*c,n=a*f,r=i*c,o=i*f;t[0]=s*c,t[4]=r*l-n,t[8]=e*l+o,t[1]=s*f,t[5]=o*l+e,t[9]=n*l-r,t[2]=-l,t[6]=i*s,t[10]=a*s}else if("YZX"===e.order){const e=a*s,n=a*l,r=i*s,o=i*l;t[0]=s*c,t[4]=o-e*f,t[8]=r*f+n,t[1]=f,t[5]=a*c,t[9]=-i*c,t[2]=-l*c,t[6]=n*f+r,t[10]=e-o*f}else if("XZY"===e.order){const e=a*s,n=a*l,r=i*s,o=i*l;t[0]=s*c,t[4]=-f,t[8]=l*c,t[1]=e*f+o,t[5]=a*c,t[9]=n*f-r,t[2]=r*f-n,t[6]=i*c,t[10]=o*f+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Zr,e,Jr)}lookAt(e,t,n){const r=this.elements;return to.subVectors(e,t),0===to.lengthSq()&&(to.z=1),to.normalize(),$r.crossVectors(n,to),0===$r.lengthSq()&&(1===Math.abs(n.z)?to.x+=1e-4:to.z+=1e-4,to.normalize(),$r.crossVectors(n,to)),$r.normalize(),eo.crossVectors(to,$r),r[0]=$r.x,r[4]=eo.x,r[8]=to.x,r[1]=$r.y,r[5]=eo.y,r[9]=to.y,r[2]=$r.z,r[6]=eo.z,r[10]=to.z,this}multiply(e,t){return void 0!==t?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,r=t.elements,o=this.elements,a=n[0],i=n[4],s=n[8],l=n[12],c=n[1],f=n[5],u=n[9],d=n[13],p=n[2],h=n[6],v=n[10],m=n[14],x=n[3],g=n[7],y=n[11],E=n[15],w=r[0],b=r[4],_=r[8],T=r[12],A=r[1],S=r[5],R=r[9],M=r[13],C=r[2],L=r[6],P=r[10],k=r[14],N=r[3],H=r[7],z=r[11],D=r[15];return o[0]=a*w+i*A+s*C+l*N,o[4]=a*b+i*S+s*L+l*H,o[8]=a*_+i*R+s*P+l*z,o[12]=a*T+i*M+s*k+l*D,o[1]=c*w+f*A+u*C+d*N,o[5]=c*b+f*S+u*L+d*H,o[9]=c*_+f*R+u*P+d*z,o[13]=c*T+f*M+u*k+d*D,o[2]=p*w+h*A+v*C+m*N,o[6]=p*b+h*S+v*L+m*H,o[10]=p*_+h*R+v*P+m*z,o[14]=p*T+h*M+v*k+m*D,o[3]=x*w+g*A+y*C+E*N,o[7]=x*b+g*S+y*L+E*H,o[11]=x*_+g*R+y*P+E*z,o[15]=x*T+g*M+y*k+E*D,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],r=e[8],o=e[12],a=e[1],i=e[5],s=e[9],l=e[13],c=e[2],f=e[6],u=e[10],d=e[14];return e[3]*(+o*s*f-r*l*f-o*i*u+n*l*u+r*i*d-n*s*d)+e[7]*(+t*s*d-t*l*u+o*a*u-r*a*d+r*l*c-o*s*c)+e[11]*(+t*l*f-t*i*d-o*a*f+n*a*d+o*i*c-n*l*c)+e[15]*(-r*i*c-t*s*f+t*i*u+r*a*f-n*a*u+n*s*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],f=e[9],u=e[10],d=e[11],p=e[12],h=e[13],v=e[14],m=e[15],x=f*v*l-h*u*l+h*s*d-i*v*d-f*s*m+i*u*m,g=p*u*l-c*v*l-p*s*d+a*v*d+c*s*m-a*u*m,y=c*h*l-p*f*l+p*i*d-a*h*d-c*i*m+a*f*m,E=p*f*s-c*h*s-p*i*u+a*h*u+c*i*v-a*f*v,w=t*x+n*g+r*y+o*E;if(0===w)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const b=1/w;return e[0]=x*b,e[1]=(h*u*o-f*v*o-h*r*d+n*v*d+f*r*m-n*u*m)*b,e[2]=(i*v*o-h*s*o+h*r*l-n*v*l-i*r*m+n*s*m)*b,e[3]=(f*s*o-i*u*o-f*r*l+n*u*l+i*r*d-n*s*d)*b,e[4]=g*b,e[5]=(c*v*o-p*u*o+p*r*d-t*v*d-c*r*m+t*u*m)*b,e[6]=(p*s*o-a*v*o-p*r*l+t*v*l+a*r*m-t*s*m)*b,e[7]=(a*u*o-c*s*o+c*r*l-t*u*l-a*r*d+t*s*d)*b,e[8]=y*b,e[9]=(p*f*o-c*h*o-p*n*d+t*h*d+c*n*m-t*f*m)*b,e[10]=(a*h*o-p*i*o+p*n*l-t*h*l-a*n*m+t*i*m)*b,e[11]=(c*i*o-a*f*o-c*n*l+t*f*l+a*n*d-t*i*d)*b,e[12]=E*b,e[13]=(c*h*r-p*f*r+p*n*u-t*h*u-c*n*v+t*f*v)*b,e[14]=(p*i*r-a*h*r-p*n*s+t*h*s+a*n*v-t*i*v)*b,e[15]=(a*f*r-c*i*r+c*n*s-t*f*s-a*n*u+t*i*u)*b,this}scale(e){const t=this.elements,n=e.x,r=e.y,o=e.z;return t[0]*=n,t[4]*=r,t[8]*=o,t[1]*=n,t[5]*=r,t[9]*=o,t[2]*=n,t[6]*=r,t[10]*=o,t[3]*=n,t[7]*=r,t[11]*=o,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,r))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),r=Math.sin(t),o=1-n,a=e.x,i=e.y,s=e.z,l=o*a,c=o*i;return this.set(l*a+n,l*i-r*s,l*s+r*i,0,l*i+r*s,c*i+n,c*s-r*a,0,l*s-r*i,c*s+r*a,o*s*s+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n){return this.set(1,t,n,0,e,1,n,0,e,t,1,0,0,0,0,1),this}compose(e,t,n){const r=this.elements,o=t._x,a=t._y,i=t._z,s=t._w,l=o+o,c=a+a,f=i+i,u=o*l,d=o*c,p=o*f,h=a*c,v=a*f,m=i*f,x=s*l,g=s*c,y=s*f,E=n.x,w=n.y,b=n.z;return r[0]=(1-(h+m))*E,r[1]=(d+y)*E,r[2]=(p-g)*E,r[3]=0,r[4]=(d-y)*w,r[5]=(1-(u+m))*w,r[6]=(v+x)*w,r[7]=0,r[8]=(p+g)*b,r[9]=(v-x)*b,r[10]=(1-(u+h))*b,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,n){const r=this.elements;let o=Qr.set(r[0],r[1],r[2]).length();const a=Qr.set(r[4],r[5],r[6]).length(),i=Qr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(o=-o),e.x=r[12],e.y=r[13],e.z=r[14],Kr.copy(this);const s=1/o,l=1/a,c=1/i;return Kr.elements[0]*=s,Kr.elements[1]*=s,Kr.elements[2]*=s,Kr.elements[4]*=l,Kr.elements[5]*=l,Kr.elements[6]*=l,Kr.elements[8]*=c,Kr.elements[9]*=c,Kr.elements[10]*=c,t.setFromRotationMatrix(Kr),n.x=o,n.y=a,n.z=i,this}makePerspective(e,t,n,r,o,a){void 0===a&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const i=this.elements,s=2*o/(t-e),l=2*o/(n-r),c=(t+e)/(t-e),f=(n+r)/(n-r),u=-(a+o)/(a-o),d=-2*a*o/(a-o);return i[0]=s,i[4]=0,i[8]=c,i[12]=0,i[1]=0,i[5]=l,i[9]=f,i[13]=0,i[2]=0,i[6]=0,i[10]=u,i[14]=d,i[3]=0,i[7]=0,i[11]=-1,i[15]=0,this}makeOrthographic(e,t,n,r,o,a){const i=this.elements,s=1/(t-e),l=1/(n-r),c=1/(a-o),f=(t+e)*s,u=(n+r)*l,d=(a+o)*c;return i[0]=2*s,i[4]=0,i[8]=0,i[12]=-f,i[1]=0,i[5]=2*l,i[9]=0,i[13]=-u,i[2]=0,i[6]=0,i[10]=-2*c,i[14]=-d,i[3]=0,i[7]=0,i[11]=0,i[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let e=0;e<16;e++)if(t[e]!==n[e])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Yr.prototype.isMatrix4=!0;const Qr=new xr,Kr=new Yr,Zr=new xr(0,0,0),Jr=new xr(1,1,1),$r=new xr,eo=new xr,to=new xr,no=new Yr,ro=new mr;class oo{constructor(e=0,t=0,n=0,r=oo.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,r){return this._x=e,this._y=t,this._z=n,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t,n){const r=e.elements,o=r[0],a=r[4],i=r[8],s=r[1],l=r[5],c=r[9],f=r[2],u=r[6],d=r[10];switch(t=t||this._order){case"XYZ":this._y=Math.asin(Un(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-Un(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(i,d),this._z=Math.atan2(s,l)):(this._y=Math.atan2(-f,o),this._z=0);break;case"ZXY":this._x=Math.asin(Un(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-f,d),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(s,o));break;case"ZYX":this._y=Math.asin(-Un(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(s,o)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(Un(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-f,o)):(this._x=0,this._y=Math.atan2(i,d));break;case"XZY":this._z=Math.asin(-Un(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(i,o)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!1!==n&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return no.makeRotationFromQuaternion(e),this.setFromRotationMatrix(no,t,n)}setFromVector3(e,t){return this.set(e.x,e.y,e.z,t||this._order)}reorder(e){return ro.setFromEuler(this),this.setFromQuaternion(ro,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new xr(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}oo.prototype.isEuler=!0,oo.DefaultOrder="XYZ",oo.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class ao{constructor(){this.mask=1}set(e){this.mask=1<<e|0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!=(this.mask&e.mask)}}let io=0;const so=new xr,lo=new mr,co=new Yr,fo=new xr,uo=new xr,po=new xr,ho=new mr,vo=new xr(1,0,0),mo=new xr(0,1,0),xo=new xr(0,0,1),go={type:"added"},yo={type:"removed"};class Eo extends Hn{constructor(){super(),Object.defineProperty(this,"id",{value:io++}),this.uuid=On(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Eo.DefaultUp.clone();const e=new xr,t=new oo,n=new mr,r=new xr(1,1,1);function o(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(o),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Yr},normalMatrix:{value:new sr}}),this.matrix=new Yr,this.matrixWorld=new Yr,this.matrixAutoUpdate=Eo.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new ao,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return lo.setFromAxisAngle(e,t),this.quaternion.multiply(lo),this}rotateOnWorldAxis(e,t){return lo.setFromAxisAngle(e,t),this.quaternion.premultiply(lo),this}rotateX(e){return this.rotateOnAxis(vo,e)}rotateY(e){return this.rotateOnAxis(mo,e)}rotateZ(e){return this.rotateOnAxis(xo,e)}translateOnAxis(e,t){return so.copy(e).applyQuaternion(this.quaternion),this.position.add(so.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(vo,e)}translateY(e){return this.translateOnAxis(mo,e)}translateZ(e){return this.translateOnAxis(xo,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(co.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?fo.copy(e):fo.set(e,t,n);const r=this.parent;this.updateWorldMatrix(!0,!1),uo.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?co.lookAt(uo,fo,this.up):co.lookAt(fo,uo,this.up),this.quaternion.setFromRotationMatrix(co),r&&(co.extractRotation(r.matrixWorld),lo.setFromRotationMatrix(co),this.quaternion.premultiply(lo.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(go)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(yo)),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(yo)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),co.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),co.multiply(e.parent.matrixWorld)),e.applyMatrix4(co),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,r=this.children.length;n<r;n++){const r=this.children[n].getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new xr),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new mr),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uo,e,po),e}getWorldScale(e){return void 0===e&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new xr),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uo,ho,e),e}getWorldDirection(e){void 0===e&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new xr),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,r=t.length;n<r;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(!0===e&&null!==n&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"==typeof e,n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function o(t,n){return void 0===t[n.uuid]&&(t[n.uuid]=n.toJSON(e)),n.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isMesh||this.isLine||this.isPoints){r.geometry=o(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const n=t.shapes;if(Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const r=n[t];o(e.shapes,r)}else o(e.shapes,n)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(o(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let n=0,r=this.material.length;n<r;n++)t.push(o(e.materials,this.material[n]));r.material=t}else r.material=o(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const n=this.animations[t];r.animations.push(o(e.animations,n))}}if(t){const t=a(e.geometries),r=a(e.materials),o=a(e.textures),i=a(e.images),s=a(e.shapes),l=a(e.skeletons),c=a(e.animations);t.length>0&&(n.geometries=t),r.length>0&&(n.materials=r),o.length>0&&(n.textures=o),i.length>0&&(n.images=i),s.length>0&&(n.shapes=s),l.length>0&&(n.skeletons=l),c.length>0&&(n.animations=c)}return n.object=r,n;function a(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let t=0;t<e.children.length;t++){const n=e.children[t];this.add(n.clone())}return this}}Eo.DefaultUp=new xr(0,1,0),Eo.DefaultMatrixAutoUpdate=!0,Eo.prototype.isObject3D=!0;const wo=new xr,bo=new xr,_o=new sr;class To{constructor(e=new xr(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,r){return this.normal.set(e,t,n),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const r=wo.subVectors(n,t).cross(bo.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return void 0===t&&(console.warn("THREE.Plane: .projectPoint() target is now required"),t=new xr),t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){void 0===t&&(console.warn("THREE.Plane: .intersectLine() target is now required"),t=new xr);const n=e.delta(wo),r=this.normal.dot(n);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const o=-(e.start.dot(this.normal)+this.constant)/r;return o<0||o>1?null:t.copy(n).multiplyScalar(o).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return void 0===e&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),e=new xr),e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||_o.getNormalMatrix(e),r=this.coplanarPoint(wo).applyMatrix4(e),o=this.normal.applyMatrix3(n).normalize();return this.constant=-r.dot(o),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}To.prototype.isPlane=!0;const Ao=new xr,So=new xr,Ro=new xr,Mo=new xr,Co=new xr,Lo=new xr,Po=new xr,ko=new xr,No=new xr,Ho=new xr;class zo{constructor(e=new xr,t=new xr,n=new xr){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,r){void 0===r&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new xr),r.subVectors(n,t),Ao.subVectors(e,t),r.cross(Ao);const o=r.lengthSq();return o>0?r.multiplyScalar(1/Math.sqrt(o)):r.set(0,0,0)}static getBarycoord(e,t,n,r,o){Ao.subVectors(r,t),So.subVectors(n,t),Ro.subVectors(e,t);const a=Ao.dot(Ao),i=Ao.dot(So),s=Ao.dot(Ro),l=So.dot(So),c=So.dot(Ro),f=a*l-i*i;if(void 0===o&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),o=new xr),0===f)return o.set(-2,-1,-1);const u=1/f,d=(l*s-i*c)*u,p=(a*c-i*s)*u;return o.set(1-d-p,p,d)}static containsPoint(e,t,n,r){return this.getBarycoord(e,t,n,r,Mo),Mo.x>=0&&Mo.y>=0&&Mo.x+Mo.y<=1}static getUV(e,t,n,r,o,a,i,s){return this.getBarycoord(e,t,n,r,Mo),s.set(0,0),s.addScaledVector(o,Mo.x),s.addScaledVector(a,Mo.y),s.addScaledVector(i,Mo.z),s}static isFrontFacing(e,t,n,r){return Ao.subVectors(n,t),So.subVectors(e,t),Ao.cross(So).dot(r)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,r){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[r]),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ao.subVectors(this.c,this.b),So.subVectors(this.a,this.b),.5*Ao.cross(So).length()}getMidpoint(e){return void 0===e&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),e=new xr),e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return zo.getNormal(this.a,this.b,this.c,e)}getPlane(e){return void 0===e&&(console.warn("THREE.Triangle: .getPlane() target is now required"),e=new To),e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return zo.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,r,o){return zo.getUV(e,this.a,this.b,this.c,t,n,r,o)}containsPoint(e){return zo.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return zo.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){void 0===t&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),t=new xr);const n=this.a,r=this.b,o=this.c;let a,i;Co.subVectors(r,n),Lo.subVectors(o,n),ko.subVectors(e,n);const s=Co.dot(ko),l=Lo.dot(ko);if(s<=0&&l<=0)return t.copy(n);No.subVectors(e,r);const c=Co.dot(No),f=Lo.dot(No);if(c>=0&&f<=c)return t.copy(r);const u=s*f-c*l;if(u<=0&&s>=0&&c<=0)return a=s/(s-c),t.copy(n).addScaledVector(Co,a);Ho.subVectors(e,o);const d=Co.dot(Ho),p=Lo.dot(Ho);if(p>=0&&d<=p)return t.copy(o);const h=d*l-s*p;if(h<=0&&l>=0&&p<=0)return i=l/(l-p),t.copy(n).addScaledVector(Lo,i);const v=c*p-d*f;if(v<=0&&f-c>=0&&d-p>=0)return Po.subVectors(o,r),i=(f-c)/(f-c+(d-p)),t.copy(r).addScaledVector(Po,i);const m=1/(v+h+u);return a=h*m,i=u*m,t.copy(n).addScaledVector(Co,a).addScaledVector(Lo,i)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Do=0;function Fo(){Object.defineProperty(this,"id",{value:Do++}),this.uuid=On(),this.name="",this.type="Material",this.fog=!0,this.blending=g,this.side=d,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=k,this.blendDst=N,this.blendEquation=_,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=B,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=bn,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ln,this.stencilZFail=ln,this.stencilZPass=ln,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}Fo.prototype=Object.assign(Object.create(Hn.prototype),{constructor:Fo,isMaterial:!0,onBuild:function(){},onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(void 0!==e)for(const t in e){const n=e[t];if(void 0===n){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===v;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(n):r&&r.isVector3&&n&&n.isVector3?r.copy(n):this[t]=n:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}},toJSON:function(e){const t=void 0===e||"string"==typeof e;t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function r(e){const t=[];for(const n in e){const r=e[n];delete r.metadata,t.push(r)}return t}if(n.uuid=this.uuid,n.type=this.type,""!==this.name&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),void 0!==this.roughness&&(n.roughness=this.roughness),void 0!==this.metalness&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),void 0!==this.shininess&&(n.shininess=this.shininess),void 0!==this.clearcoat&&(n.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(n.combine=this.combine)),void 0!==this.envMapIntensity&&(n.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(n.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.size&&(n.size=this.size),null!==this.shadowSide&&(n.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==g&&(n.blending=this.blending),this.side!==d&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),!0===this.transparent&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&(n.rotation=this.rotation),!0===this.polygonOffset&&(n.polygonOffset=!0),0!==this.polygonOffsetFactor&&(n.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&(n.linewidth=this.linewidth),void 0!==this.dashSize&&(n.dashSize=this.dashSize),void 0!==this.gapSize&&(n.gapSize=this.gapSize),void 0!==this.scale&&(n.scale=this.scale),!0===this.dithering&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(n.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(n.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(n.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(n.wireframeLinejoin=this.wireframeLinejoin),!0===this.morphTargets&&(n.morphTargets=!0),!0===this.morphNormals&&(n.morphNormals=!0),!0===this.skinning&&(n.skinning=!0),!0===this.flatShading&&(n.flatShading=this.flatShading),!1===this.visible&&(n.visible=!1),!1===this.toneMapped&&(n.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&(n.userData=this.userData),t){const t=r(e.textures),o=r(e.images);t.length>0&&(n.textures=t),o.length>0&&(n.images=o)}return n},clone:function(){return(new this.constructor).copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(null!==t){const e=t.length;n=new Array(e);for(let r=0;r!==e;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Fo.prototype,"needsUpdate",{set:function(e){!0===e&&this.version++}});const Io={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Oo={h:0,s:0,l:0},Uo={h:0,s:0,l:0};function Go(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}function Bo(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function Vo(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}class Wo{constructor(e,t,n){return void 0===t&&void 0===n?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):"number"==typeof e?this.setHex(e):"string"==typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Gn(e,1),t=Un(t,0,1),n=Un(n,0,1),0===t)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,o=2*n-r;this.r=Go(o,r,e+1/3),this.g=Go(o,r,e),this.b=Go(o,r,e-1/3)}return this}setStyle(e){function t(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const r=n[1],o=n[2];switch(r){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,t(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,t(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const n=parseFloat(e[1])/360,r=parseInt(e[2],10)/100,o=parseInt(e[3],10)/100;return t(e[4]),this.setHSL(n,r,o)}}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=n[1],t=e.length;if(3===t)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,this;if(6===t)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Io[e.toLowerCase()];return void 0!==t?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=Bo(e.r),this.g=Bo(e.g),this.b=Bo(e.b),this}copyLinearToSRGB(e){return this.r=Vo(e.r),this.g=Vo(e.g),this.b=Vo(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){void 0===e&&(console.warn("THREE.Color: .getHSL() target is now required"),e={h:0,s:0,l:0});const t=this.r,n=this.g,r=this.b,o=Math.max(t,n,r),a=Math.min(t,n,r);let i,s;const l=(a+o)/2;if(a===o)i=0,s=0;else{const e=o-a;switch(s=l<=.5?e/(o+a):e/(2-o-a),o){case t:i=(n-r)/e+(n<r?6:0);break;case n:i=(r-t)/e+2;break;case r:i=(t-n)/e+4}i/=6}return e.h=i,e.s=s,e.l=l,e}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(e,t,n){return this.getHSL(Oo),Oo.h+=e,Oo.s+=t,Oo.l+=n,this.setHSL(Oo.h,Oo.s,Oo.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Oo),e.getHSL(Uo);const n=Wn(Oo.h,Uo.h,t),r=Wn(Oo.s,Uo.s,t),o=Wn(Oo.l,Uo.l,t);return this.setHSL(n,r,o),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Wo.NAMES=Io,Wo.prototype.isColor=!0,Wo.prototype.r=1,Wo.prototype.g=1,Wo.prototype.b=1;class jo extends Fo{constructor(e){super(),this.type="MeshBasicMaterial",this.color=new Wo(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this}}jo.prototype.isMeshBasicMaterial=!0;const qo=new xr,Xo=new ir;class Yo{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===n,this.usage=_n,this.updateRange={offset:0,count:-1},this.version=0,this.onUploadCallback=function(){}}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let r=0,o=this.itemSize;r<o;r++)this.array[e+r]=t.array[n+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let r=0,o=e.length;r<o;r++){let o=e[r];void 0===o&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new Wo),t[n++]=o.r,t[n++]=o.g,t[n++]=o.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let r=0,o=e.length;r<o;r++){let o=e[r];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new ir),t[n++]=o.x,t[n++]=o.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let r=0,o=e.length;r<o;r++){let o=e[r];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new xr),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let r=0,o=e.length;r<o;r++){let o=e[r];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new pr),t[n++]=o.x,t[n++]=o.y,t[n++]=o.z,t[n++]=o.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,n=this.count;t<n;t++)Xo.fromBufferAttribute(this,t),Xo.applyMatrix3(e),this.setXY(t,Xo.x,Xo.y);else if(3===this.itemSize)for(let t=0,n=this.count;t<n;t++)qo.fromBufferAttribute(this,t),qo.applyMatrix3(e),this.setXYZ(t,qo.x,qo.y,qo.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)qo.x=this.getX(t),qo.y=this.getY(t),qo.z=this.getZ(t),qo.applyMatrix4(e),this.setXYZ(t,qo.x,qo.y,qo.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)qo.x=this.getX(t),qo.y=this.getY(t),qo.z=this.getZ(t),qo.applyNormalMatrix(e),this.setXYZ(t,qo.x,qo.y,qo.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)qo.x=this.getX(t),qo.y=this.getY(t),qo.z=this.getZ(t),qo.transformDirection(e),this.setXYZ(t,qo.x,qo.y,qo.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this}setXYZW(e,t,n,r,o){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=r,this.array[e+3]=o,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),this.usage!==_n&&(e.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(e.updateRange=this.updateRange),e}}Yo.prototype.isBufferAttribute=!0;class Qo extends Yo{constructor(e,t,n){super(new Int8Array(e),t,n)}}class Ko extends Yo{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class Zo extends Yo{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class Jo extends Yo{constructor(e,t,n){super(new Int16Array(e),t,n)}}class $o extends Yo{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class ea extends Yo{constructor(e,t,n){super(new Int32Array(e),t,n)}}class ta extends Yo{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class na extends Yo{constructor(e,t,n){super(new Uint16Array(e),t,n)}}na.prototype.isFloat16BufferAttribute=!0;class ra extends Yo{constructor(e,t,n){super(new Float32Array(e),t,n)}}class oa extends Yo{constructor(e,t,n){super(new Float64Array(e),t,n)}}function aa(e){if(0===e.length)return-1/0;let t=e[0];for(let n=1,r=e.length;n<r;++n)e[n]>t&&(t=e[n]);return t}const ia={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function sa(e,t){return new ia[e](t)}let la=0;const ca=new Yr,fa=new Eo,ua=new xr,da=new Er,pa=new Er,ha=new xr;class va extends Hn{constructor(){super(),Object.defineProperty(this,"id",{value:la++}),this.uuid=On(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(aa(e)>65535?ta:$o)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(void 0!==n){const t=(new sr).getNormalMatrix(e);n.applyNormalMatrix(t),n.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(e),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}rotateX(e){return ca.makeRotationX(e),this.applyMatrix4(ca),this}rotateY(e){return ca.makeRotationY(e),this.applyMatrix4(ca),this}rotateZ(e){return ca.makeRotationZ(e),this.applyMatrix4(ca),this}translate(e,t,n){return ca.makeTranslation(e,t,n),this.applyMatrix4(ca),this}scale(e,t,n){return ca.makeScale(e,t,n),this.applyMatrix4(ca),this}lookAt(e){return fa.lookAt(e),fa.updateMatrix(),this.applyMatrix4(fa.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ua).negate(),this.translate(ua.x,ua.y,ua.z),this}setFromPoints(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new ra(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Er);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new xr(-1/0,-1/0,-1/0),new xr(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];da.setFromBufferAttribute(n),this.morphTargetsRelative?(ha.addVectors(this.boundingBox.min,da.min),this.boundingBox.expandByPoint(ha),ha.addVectors(this.boundingBox.max,da.max),this.boundingBox.expandByPoint(ha)):(this.boundingBox.expandByPoint(da.min),this.boundingBox.expandByPoint(da.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Or);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new xr,1/0);if(e){const n=this.boundingSphere.center;if(da.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const n=t[e];pa.setFromBufferAttribute(n),this.morphTargetsRelative?(ha.addVectors(da.min,pa.min),da.expandByPoint(ha),ha.addVectors(da.max,pa.max),da.expandByPoint(ha)):(da.expandByPoint(pa.min),da.expandByPoint(pa.max))}da.getCenter(n);let r=0;for(let t=0,o=e.count;t<o;t++)ha.fromBufferAttribute(e,t),r=Math.max(r,n.distanceToSquared(ha));if(t)for(let o=0,a=t.length;o<a;o++){const a=t[o],i=this.morphTargetsRelative;for(let t=0,o=a.count;t<o;t++)ha.fromBufferAttribute(a,t),i&&(ua.fromBufferAttribute(e,t),ha.add(ua)),r=Math.max(r,n.distanceToSquared(ha))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeFaceNormals(){}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const n=e.array,r=t.position.array,o=t.normal.array,a=t.uv.array,i=r.length/3;void 0===t.tangent&&this.setAttribute("tangent",new Yo(new Float32Array(4*i),4));const s=t.tangent.array,l=[],c=[];for(let e=0;e<i;e++)l[e]=new xr,c[e]=new xr;const f=new xr,u=new xr,d=new xr,p=new ir,h=new ir,v=new ir,m=new xr,x=new xr;function g(e,t,n){f.fromArray(r,3*e),u.fromArray(r,3*t),d.fromArray(r,3*n),p.fromArray(a,2*e),h.fromArray(a,2*t),v.fromArray(a,2*n),u.sub(f),d.sub(f),h.sub(p),v.sub(p);const o=1/(h.x*v.y-v.x*h.y);isFinite(o)&&(m.copy(u).multiplyScalar(v.y).addScaledVector(d,-h.y).multiplyScalar(o),x.copy(d).multiplyScalar(h.x).addScaledVector(u,-v.x).multiplyScalar(o),l[e].add(m),l[t].add(m),l[n].add(m),c[e].add(x),c[t].add(x),c[n].add(x))}let y=this.groups;0===y.length&&(y=[{start:0,count:n.length}]);for(let e=0,t=y.length;e<t;++e){const t=y[e],r=t.start;for(let e=r,o=r+t.count;e<o;e+=3)g(n[e+0],n[e+1],n[e+2])}const E=new xr,w=new xr,b=new xr,_=new xr;function T(e){b.fromArray(o,3*e),_.copy(b);const t=l[e];E.copy(t),E.sub(b.multiplyScalar(b.dot(t))).normalize(),w.crossVectors(_,t);const n=w.dot(c[e])<0?-1:1;s[4*e]=E.x,s[4*e+1]=E.y,s[4*e+2]=E.z,s[4*e+3]=n}for(let e=0,t=y.length;e<t;++e){const t=y[e],r=t.start;for(let e=r,o=r+t.count;e<o;e+=3)T(n[e+0]),T(n[e+1]),T(n[e+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let n=this.getAttribute("normal");if(void 0===n)n=new Yo(new Float32Array(3*t.count),3),this.setAttribute("normal",n);else for(let e=0,t=n.count;e<t;e++)n.setXYZ(e,0,0,0);const r=new xr,o=new xr,a=new xr,i=new xr,s=new xr,l=new xr,c=new xr,f=new xr;if(e)for(let u=0,d=e.count;u<d;u+=3){const d=e.getX(u+0),p=e.getX(u+1),h=e.getX(u+2);r.fromBufferAttribute(t,d),o.fromBufferAttribute(t,p),a.fromBufferAttribute(t,h),c.subVectors(a,o),f.subVectors(r,o),c.cross(f),i.fromBufferAttribute(n,d),s.fromBufferAttribute(n,p),l.fromBufferAttribute(n,h),i.add(c),s.add(c),l.add(c),n.setXYZ(d,i.x,i.y,i.z),n.setXYZ(p,s.x,s.y,s.z),n.setXYZ(h,l.x,l.y,l.z)}else for(let e=0,i=t.count;e<i;e+=3)r.fromBufferAttribute(t,e+0),o.fromBufferAttribute(t,e+1),a.fromBufferAttribute(t,e+2),c.subVectors(a,o),f.subVectors(r,o),c.cross(f),n.setXYZ(e+0,c.x,c.y,c.z),n.setXYZ(e+1,c.x,c.y,c.z),n.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const r in n){if(void 0===e.attributes[r])continue;const o=n[r].array,a=e.attributes[r],i=a.array,s=a.itemSize*t,l=Math.min(i.length,o.length-s);for(let e=0,t=s;e<l;e++,t++)o[t]=i[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)ha.fromBufferAttribute(e,t),ha.normalize(),e.setXYZ(t,ha.x,ha.y,ha.z)}toNonIndexed(){function e(e,t){const n=e.array,r=e.itemSize,o=e.normalized,a=new n.constructor(t.length*r);let i=0,s=0;for(let e=0,o=t.length;e<o;e++){i=t[e]*r;for(let e=0;e<r;e++)a[s++]=n[i++]}return new Yo(a,r,o)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new va,n=this.index.array,r=this.attributes;for(const o in r){const a=e(r[o],n);t.setAttribute(o,a)}const o=this.morphAttributes;for(const r in o){const a=[],i=o[r];for(let t=0,r=i.length;t<r;t++){const r=e(i[t],n);a.push(r)}t.morphAttributes[r]=a}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let e=0,n=a.length;e<n;e++){const n=a[e];t.addGroup(n.start,n.count,n.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const n in t)void 0!==t[n]&&(e[n]=t[n]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const t in n){const r=n[t];e.data.attributes[t]=r.toJSON(e.data)}const r={};let o=!1;for(const t in this.morphAttributes){const n=this.morphAttributes[t],a=[];for(let t=0,r=n.length;t<r;t++){const r=n[t];a.push(r.toJSON(e.data))}a.length>0&&(r[t]=a,o=!0)}o&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const i=this.boundingSphere;return null!==i&&(e.data.boundingSphere={center:i.center.toArray(),radius:i.radius}),e}clone(){return(new va).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;null!==n&&this.setIndex(n.clone(t));const r=e.attributes;for(const e in r){const n=r[e];this.setAttribute(e,n.clone(t))}const o=e.morphAttributes;for(const e in o){const n=[],r=o[e];for(let e=0,o=r.length;e<o;e++)n.push(r[e].clone(t));this.morphAttributes[e]=n}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let e=0,t=a.length;e<t;e++){const t=a[e];this.addGroup(t.start,t.count,t.materialIndex)}const i=e.boundingBox;null!==i&&(this.boundingBox=i.clone());const s=e.boundingSphere;return null!==s&&(this.boundingSphere=s.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}va.prototype.isBufferGeometry=!0;const ma=new Yr,xa=new Xr,ga=new Or,ya=new xr,Ea=new xr,wa=new xr,ba=new xr,_a=new xr,Ta=new xr,Aa=new xr,Sa=new xr,Ra=new xr,Ma=new ir,Ca=new ir,La=new ir,Pa=new xr,ka=new xr;class Na extends Eo{constructor(e=new va,t=new jo){super(),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,r=this.material,o=this.matrixWorld;if(void 0===r)return;if(null===n.boundingSphere&&n.computeBoundingSphere(),ga.copy(n.boundingSphere),ga.applyMatrix4(o),!1===e.ray.intersectsSphere(ga))return;if(ma.copy(o).invert(),xa.copy(e.ray).applyMatrix4(ma),null!==n.boundingBox&&!1===xa.intersectsBox(n.boundingBox))return;let a;if(n.isBufferGeometry){const o=n.index,i=n.attributes.position,s=n.morphAttributes.position,l=n.morphTargetsRelative,c=n.attributes.uv,f=n.attributes.uv2,u=n.groups,d=n.drawRange;if(null!==o)if(Array.isArray(r))for(let n=0,p=u.length;n<p;n++){const p=u[n],h=r[p.materialIndex];for(let n=Math.max(p.start,d.start),r=Math.min(p.start+p.count,d.start+d.count);n<r;n+=3){const r=o.getX(n),u=o.getX(n+1),d=o.getX(n+2);a=za(this,h,e,xa,i,s,l,c,f,r,u,d),a&&(a.faceIndex=Math.floor(n/3),a.face.materialIndex=p.materialIndex,t.push(a))}}else for(let n=Math.max(0,d.start),u=Math.min(o.count,d.start+d.count);n<u;n+=3){const u=o.getX(n),d=o.getX(n+1),p=o.getX(n+2);a=za(this,r,e,xa,i,s,l,c,f,u,d,p),a&&(a.faceIndex=Math.floor(n/3),t.push(a))}else if(void 0!==i)if(Array.isArray(r))for(let n=0,o=u.length;n<o;n++){const o=u[n],p=r[o.materialIndex];for(let n=Math.max(o.start,d.start),r=Math.min(o.start+o.count,d.start+d.count);n<r;n+=3)a=za(this,p,e,xa,i,s,l,c,f,n,n+1,n+2),a&&(a.faceIndex=Math.floor(n/3),a.face.materialIndex=o.materialIndex,t.push(a))}else for(let n=Math.max(0,d.start),o=Math.min(i.count,d.start+d.count);n<o;n+=3)a=za(this,r,e,xa,i,s,l,c,f,n,n+1,n+2),a&&(a.faceIndex=Math.floor(n/3),t.push(a))}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function Ha(e,t,n,r,o,a,i,s){let l;if(l=t.side===p?r.intersectTriangle(i,a,o,!0,s):r.intersectTriangle(o,a,i,t.side!==h,s),null===l)return null;ka.copy(s),ka.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(ka);return c<n.near||c>n.far?null:{distance:c,point:ka.clone(),object:e}}function za(e,t,n,r,o,a,i,s,l,c,f,u){ya.fromBufferAttribute(o,c),Ea.fromBufferAttribute(o,f),wa.fromBufferAttribute(o,u);const d=e.morphTargetInfluences;if(t.morphTargets&&a&&d){Aa.set(0,0,0),Sa.set(0,0,0),Ra.set(0,0,0);for(let e=0,t=a.length;e<t;e++){const t=d[e],n=a[e];0!==t&&(ba.fromBufferAttribute(n,c),_a.fromBufferAttribute(n,f),Ta.fromBufferAttribute(n,u),i?(Aa.addScaledVector(ba,t),Sa.addScaledVector(_a,t),Ra.addScaledVector(Ta,t)):(Aa.addScaledVector(ba.sub(ya),t),Sa.addScaledVector(_a.sub(Ea),t),Ra.addScaledVector(Ta.sub(wa),t)))}ya.add(Aa),Ea.add(Sa),wa.add(Ra)}e.isSkinnedMesh&&t.skinning&&(e.boneTransform(c,ya),e.boneTransform(f,Ea),e.boneTransform(u,wa));const p=Ha(e,t,n,r,ya,Ea,wa,Pa);if(p){s&&(Ma.fromBufferAttribute(s,c),Ca.fromBufferAttribute(s,f),La.fromBufferAttribute(s,u),p.uv=zo.getUV(Pa,ya,Ea,wa,Ma,Ca,La,new ir)),l&&(Ma.fromBufferAttribute(l,c),Ca.fromBufferAttribute(l,f),La.fromBufferAttribute(l,u),p.uv2=zo.getUV(Pa,ya,Ea,wa,Ma,Ca,La,new ir));const e={a:c,b:f,c:u,normal:new xr,materialIndex:0};zo.getNormal(ya,Ea,wa,e.normal),p.face=e}return p}Na.prototype.isMesh=!0;class Da extends va{constructor(e=1,t=1,n=1,r=1,o=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:r,heightSegments:o,depthSegments:a};const i=this;r=Math.floor(r),o=Math.floor(o),a=Math.floor(a);const s=[],l=[],c=[],f=[];let u=0,d=0;function p(e,t,n,r,o,a,p,h,v,m,x){const g=a/v,y=p/m,E=a/2,w=p/2,b=h/2,_=v+1,T=m+1;let A=0,S=0;const R=new xr;for(let a=0;a<T;a++){const i=a*y-w;for(let s=0;s<_;s++){const u=s*g-E;R[e]=u*r,R[t]=i*o,R[n]=b,l.push(R.x,R.y,R.z),R[e]=0,R[t]=0,R[n]=h>0?1:-1,c.push(R.x,R.y,R.z),f.push(s/v),f.push(1-a/m),A+=1}}for(let e=0;e<m;e++)for(let t=0;t<v;t++){const n=u+t+_*e,r=u+t+_*(e+1),o=u+(t+1)+_*(e+1),a=u+(t+1)+_*e;s.push(n,r,a),s.push(r,o,a),S+=6}i.addGroup(d,S,x),d+=S,u+=A}p("z","y","x",-1,-1,n,t,e,a,o,0),p("z","y","x",1,-1,n,t,-e,a,o,1),p("x","z","y",1,1,e,n,t,r,a,2),p("x","z","y",1,-1,e,n,-t,r,a,3),p("x","y","z",1,-1,e,t,n,r,o,4),p("x","y","z",-1,-1,e,t,-n,r,o,5),this.setIndex(s),this.setAttribute("position",new ra(l,3)),this.setAttribute("normal",new ra(c,3)),this.setAttribute("uv",new ra(f,2))}}function Fa(e){const t={};for(const n in e){t[n]={};for(const r in e[n]){const o=e[n][r];o&&(o.isColor||o.isMatrix3||o.isMatrix4||o.isVector2||o.isVector3||o.isVector4||o.isTexture||o.isQuaternion)?t[n][r]=o.clone():Array.isArray(o)?t[n][r]=o.slice():t[n][r]=o}}return t}function Ia(e){const t={};for(let n=0;n<e.length;n++){const r=Fa(e[n]);for(const e in r)t[e]=r[e]}return t}const Oa={clone:Fa,merge:Ia};var Ua="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",Ga="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";class Ba extends Fo{constructor(e){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=Ua,this.fragmentShader=Ga,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Fa(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const n in this.uniforms){const r=this.uniforms[n].value;r&&r.isTexture?t.uniforms[n]={type:"t",value:r.toJSON(e).uuid}:r&&r.isColor?t.uniforms[n]={type:"c",value:r.getHex()}:r&&r.isVector2?t.uniforms[n]={type:"v2",value:r.toArray()}:r&&r.isVector3?t.uniforms[n]={type:"v3",value:r.toArray()}:r&&r.isVector4?t.uniforms[n]={type:"v4",value:r.toArray()}:r&&r.isMatrix3?t.uniforms[n]={type:"m3",value:r.toArray()}:r&&r.isMatrix4?t.uniforms[n]={type:"m4",value:r.toArray()}:t.uniforms[n]={value:r}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const e in this.extensions)!0===this.extensions[e]&&(n[e]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}Ba.prototype.isShaderMaterial=!0;class Va extends Eo{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new Yr,this.projectionMatrix=new Yr,this.projectionMatrixInverse=new Yr}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){void 0===e&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new xr),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}Va.prototype.isCamera=!0;class Wa extends Va{constructor(e=50,t=1,n=.1,r=2e3){super(),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*In*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*Fn*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*In*Math.atan(Math.tan(.5*Fn*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,r,o,a){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=o,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*Fn*this.fov)/this.zoom,n=2*t,r=this.aspect*n,o=-.5*r;const a=this.view;if(null!==this.view&&this.view.enabled){const e=a.fullWidth,i=a.fullHeight;o+=a.offsetX*r/e,t-=a.offsetY*n/i,r*=a.width/e,n*=a.height/i}const i=this.filmOffset;0!==i&&(o+=e*i/this.getFilmWidth()),this.projectionMatrix.makePerspective(o,o+r,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Wa.prototype.isPerspectiveCamera=!0;const ja=90,qa=1;class Xa extends Eo{constructor(e,t,n){if(super(),this.type="CubeCamera",!0!==n.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=n;const r=new Wa(ja,qa,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new xr(1,0,0)),this.add(r);const o=new Wa(ja,qa,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new xr(-1,0,0)),this.add(o);const a=new Wa(ja,qa,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new xr(0,1,0)),this.add(a);const i=new Wa(ja,qa,e,t);i.layers=this.layers,i.up.set(0,0,-1),i.lookAt(new xr(0,-1,0)),this.add(i);const s=new Wa(ja,qa,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new xr(0,0,1)),this.add(s);const l=new Wa(ja,qa,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new xr(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const n=this.renderTarget,[r,o,a,i,s,l]=this.children,c=e.xr.enabled,f=e.getRenderTarget();e.xr.enabled=!1;const u=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,r),e.setRenderTarget(n,1),e.render(t,o),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,i),e.setRenderTarget(n,4),e.render(t,s),n.texture.generateMipmaps=u,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(f),e.xr.enabled=c}}class Ya extends ur{constructor(e,t,n,r,o,a,i,s,l,c){super(e=void 0!==e?e:[],t=void 0!==t?t:re,n,r,o,a,i=void 0!==i?i:ze,s,l,c),this._needsFlipEnvMap=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}Ya.prototype.isCubeTexture=!0;class Qa extends hr{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),super(e,e,t),t=t||{},this.texture=new Ya(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:xe,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=De,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},r=new Da(5,5,5),o=new Ba({name:"CubemapFromEquirect",uniforms:Fa(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:p,blending:x});o.uniforms.tEquirect.value=t;const a=new Na(r,o),i=t.minFilter;return t.minFilter===Ee&&(t.minFilter=xe),new Xa(1,10,this).update(e,a),t.minFilter=i,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,r){const o=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,r);e.setRenderTarget(o)}}Qa.prototype.isWebGLCubeRenderTarget=!0;class Ka extends ur{constructor(e,t,n,r,o,a,i,s,l,c,f,u){super(null,a,i,s,l,c,r,o,f,u),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=void 0!==l?l:de,this.minFilter=void 0!==c?c:de,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ka.prototype.isDataTexture=!0;const Za=new Or,Ja=new xr;class $a{constructor(e=new To,t=new To,n=new To,r=new To,o=new To,a=new To){this.planes=[e,t,n,r,o,a]}set(e,t,n,r,o,a){const i=this.planes;return i[0].copy(e),i[1].copy(t),i[2].copy(n),i[3].copy(r),i[4].copy(o),i[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,r=n[0],o=n[1],a=n[2],i=n[3],s=n[4],l=n[5],c=n[6],f=n[7],u=n[8],d=n[9],p=n[10],h=n[11],v=n[12],m=n[13],x=n[14],g=n[15];return t[0].setComponents(i-r,f-s,h-u,g-v).normalize(),t[1].setComponents(i+r,f+s,h+u,g+v).normalize(),t[2].setComponents(i+o,f+l,h+d,g+m).normalize(),t[3].setComponents(i-o,f-l,h-d,g-m).normalize(),t[4].setComponents(i-a,f-c,h-p,g-x).normalize(),t[5].setComponents(i+a,f+c,h+p,g+x).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),Za.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(Za)}intersectsSprite(e){return Za.center.set(0,0,0),Za.radius=.7071067811865476,Za.applyMatrix4(e.matrixWorld),this.intersectsSphere(Za)}intersectsSphere(e){const t=this.planes,n=e.center,r=-e.radius;for(let e=0;e<6;e++)if(t[e].distanceToPoint(n)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const r=t[n];if(Ja.x=r.normal.x>0?e.max.x:e.min.x,Ja.y=r.normal.y>0?e.max.y:e.min.y,Ja.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(Ja)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function ei(){let e=null,t=!1,n=null,r=null;function o(t,a){n(t,a),r=e.requestAnimationFrame(o)}return{start:function(){!0!==t&&null!==n&&(r=e.requestAnimationFrame(o),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(e){n=e},setContext:function(t){e=t}}}function ti(e,t){const n=t.isWebGL2,r=new WeakMap;function o(t,r){const o=t.array,a=t.usage,i=e.createBuffer();e.bindBuffer(r,i),e.bufferData(r,o,a),t.onUploadCallback();let s=e.FLOAT;return o instanceof Float32Array?s=e.FLOAT:o instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):o instanceof Uint16Array?t.isFloat16BufferAttribute?n?s=e.HALF_FLOAT:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):s=e.UNSIGNED_SHORT:o instanceof Int16Array?s=e.SHORT:o instanceof Uint32Array?s=e.UNSIGNED_INT:o instanceof Int32Array?s=e.INT:o instanceof Int8Array?s=e.BYTE:o instanceof Uint8Array&&(s=e.UNSIGNED_BYTE),{buffer:i,type:s,bytesPerElement:o.BYTES_PER_ELEMENT,version:t.version}}function a(t,r,o){const a=r.array,i=r.updateRange;e.bindBuffer(o,t),-1===i.count?e.bufferSubData(o,0,a):(n?e.bufferSubData(o,i.offset*a.BYTES_PER_ELEMENT,a,i.offset,i.count):e.bufferSubData(o,i.offset*a.BYTES_PER_ELEMENT,a.subarray(i.offset,i.offset+i.count)),i.count=-1)}function i(e){return e.isInterleavedBufferAttribute&&(e=e.data),r.get(e)}function s(t){t.isInterleavedBufferAttribute&&(t=t.data);const n=r.get(t);n&&(e.deleteBuffer(n.buffer),r.delete(t))}function l(e,t){if(e.isGLBufferAttribute){const t=r.get(e);return void((!t||t.version<e.version)&&r.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version}))}e.isInterleavedBufferAttribute&&(e=e.data);const n=r.get(e);void 0===n?r.set(e,o(e,t)):n.version<e.version&&(a(n.buffer,e,t),n.version=e.version)}return{get:i,remove:s,update:l}}class ni extends va{constructor(e=1,t=1,n=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:r};const o=e/2,a=t/2,i=Math.floor(n),s=Math.floor(r),l=i+1,c=s+1,f=e/i,u=t/s,d=[],p=[],h=[],v=[];for(let e=0;e<c;e++){const t=e*u-a;for(let n=0;n<l;n++){const r=n*f-o;p.push(r,-t,0),h.push(0,0,1),v.push(n/i),v.push(1-e/s)}}for(let e=0;e<s;e++)for(let t=0;t<i;t++){const n=t+l*e,r=t+l*(e+1),o=t+1+l*(e+1),a=t+1+l*e;d.push(n,r,a),d.push(r,o,a)}this.setIndex(d),this.setAttribute("position",new ra(p,3)),this.setAttribute("normal",new ra(h,3)),this.setAttribute("uv",new ra(v,2))}}const ri={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},oi={common:{diffuse:{value:new Wo(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new sr},uv2Transform:{value:new sr},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new ir(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Wo(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Wo(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new sr}},sprite:{diffuse:{value:new Wo(15658734)},opacity:{value:1},center:{value:new ir(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new sr}}},ai={basic:{uniforms:Ia([oi.common,oi.specularmap,oi.envmap,oi.aomap,oi.lightmap,oi.fog]),vertexShader:ri.meshbasic_vert,fragmentShader:ri.meshbasic_frag},lambert:{uniforms:Ia([oi.common,oi.specularmap,oi.envmap,oi.aomap,oi.lightmap,oi.emissivemap,oi.fog,oi.lights,{emissive:{value:new Wo(0)}}]),vertexShader:ri.meshlambert_vert,fragmentShader:ri.meshlambert_frag},phong:{uniforms:Ia([oi.common,oi.specularmap,oi.envmap,oi.aomap,oi.lightmap,oi.emissivemap,oi.bumpmap,oi.normalmap,oi.displacementmap,oi.fog,oi.lights,{emissive:{value:new Wo(0)},specular:{value:new Wo(1118481)},shininess:{value:30}}]),vertexShader:ri.meshphong_vert,fragmentShader:ri.meshphong_frag},standard:{uniforms:Ia([oi.common,oi.envmap,oi.aomap,oi.lightmap,oi.emissivemap,oi.bumpmap,oi.normalmap,oi.displacementmap,oi.roughnessmap,oi.metalnessmap,oi.fog,oi.lights,{emissive:{value:new Wo(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ri.meshphysical_vert,fragmentShader:ri.meshphysical_frag},toon:{uniforms:Ia([oi.common,oi.aomap,oi.lightmap,oi.emissivemap,oi.bumpmap,oi.normalmap,oi.displacementmap,oi.gradientmap,oi.fog,oi.lights,{emissive:{value:new Wo(0)}}]),vertexShader:ri.meshtoon_vert,fragmentShader:ri.meshtoon_frag},matcap:{uniforms:Ia([oi.common,oi.bumpmap,oi.normalmap,oi.displacementmap,oi.fog,{matcap:{value:null}}]),vertexShader:ri.meshmatcap_vert,fragmentShader:ri.meshmatcap_frag},points:{uniforms:Ia([oi.points,oi.fog]),vertexShader:ri.points_vert,fragmentShader:ri.points_frag},dashed:{uniforms:Ia([oi.common,oi.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ri.linedashed_vert,fragmentShader:ri.linedashed_frag},depth:{uniforms:Ia([oi.common,oi.displacementmap]),vertexShader:ri.depth_vert,fragmentShader:ri.depth_frag},normal:{uniforms:Ia([oi.common,oi.bumpmap,oi.normalmap,oi.displacementmap,{opacity:{value:1}}]),vertexShader:ri.normal_vert,fragmentShader:ri.normal_frag},sprite:{uniforms:Ia([oi.sprite,oi.fog]),vertexShader:ri.sprite_vert,fragmentShader:ri.sprite_frag},background:{uniforms:{uvTransform:{value:new sr},t2D:{value:null}},vertexShader:ri.background_vert,fragmentShader:ri.background_frag},cube:{uniforms:Ia([oi.envmap,{opacity:{value:1}}]),vertexShader:ri.cube_vert,fragmentShader:ri.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ri.equirect_vert,fragmentShader:ri.equirect_frag},distanceRGBA:{uniforms:Ia([oi.common,oi.displacementmap,{referencePosition:{value:new xr},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ri.distanceRGBA_vert,fragmentShader:ri.distanceRGBA_frag},shadow:{uniforms:Ia([oi.lights,oi.fog,{color:{value:new Wo(0)},opacity:{value:1}}]),vertexShader:ri.shadow_vert,fragmentShader:ri.shadow_frag}};function ii(e,t,n,r,o){const a=new Wo(0);let i,s,l=0,c=null,f=0,u=null;function h(n,o,h,m){let x=!0===o.isScene?o.background:null;x&&x.isTexture&&(x=t.get(x));const g=e.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(x=null),null===x?v(a,l):x&&x.isColor&&(v(x,1),m=!0),(e.autoClear||m)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),x&&(x.isCubeTexture||x.mapping===se)?(void 0===s&&(s=new Na(new Da(1,1,1),new Ba({name:"BackgroundCubeMaterial",uniforms:Fa(ai.cube.uniforms),vertexShader:ai.cube.vertexShader,fragmentShader:ai.cube.fragmentShader,side:p,depthTest:!1,depthWrite:!1,fog:!1})),s.geometry.deleteAttribute("normal"),s.geometry.deleteAttribute("uv"),s.onBeforeRender=function(e,t,n){this.matrixWorld.copyPosition(n.matrixWorld)},Object.defineProperty(s.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(s)),s.material.uniforms.envMap.value=x,s.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x._needsFlipEnvMap?-1:1,c===x&&f===x.version&&u===e.toneMapping||(s.material.needsUpdate=!0,c=x,f=x.version,u=e.toneMapping),n.unshift(s,s.geometry,s.material,0,0,null)):x&&x.isTexture&&(void 0===i&&(i=new Na(new ni(2,2),new Ba({name:"BackgroundMaterial",uniforms:Fa(ai.background.uniforms),vertexShader:ai.background.vertexShader,fragmentShader:ai.background.fragmentShader,side:d,depthTest:!1,depthWrite:!1,fog:!1})),i.geometry.deleteAttribute("normal"),Object.defineProperty(i.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(i)),i.material.uniforms.t2D.value=x,!0===x.matrixAutoUpdate&&x.updateMatrix(),i.material.uniforms.uvTransform.value.copy(x.matrix),c===x&&f===x.version&&u===e.toneMapping||(i.material.needsUpdate=!0,c=x,f=x.version,u=e.toneMapping),n.unshift(i,i.geometry,i.material,0,0,null))}function v(e,t){n.buffers.color.setClear(e.r,e.g,e.b,t,o)}return{getClearColor:function(){return a},setClearColor:function(e,t=1){a.set(e),l=t,v(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(e){l=e,v(a,l)},render:h}}function si(e,t,n,r){const o=e.getParameter(e.MAX_VERTEX_ATTRIBS),a=r.isWebGL2?null:t.get("OES_vertex_array_object"),i=r.isWebGL2||null!==a,s={},l=v(null);let c=l;function f(t,r,o,a,s){let l=!1;if(i){const e=h(a,o,r);c!==e&&(c=e,d(c.object)),l=m(a,s),l&&x(a,s)}else{const e=!0===r.wireframe;c.geometry===a.id&&c.program===o.id&&c.wireframe===e||(c.geometry=a.id,c.program=o.id,c.wireframe=e,l=!0)}!0===t.isInstancedMesh&&(l=!0),null!==s&&n.update(s,e.ELEMENT_ARRAY_BUFFER),l&&(_(t,r,o,a),null!==s&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n.get(s).buffer))}function u(){return r.isWebGL2?e.createVertexArray():a.createVertexArrayOES()}function d(t){return r.isWebGL2?e.bindVertexArray(t):a.bindVertexArrayOES(t)}function p(t){return r.isWebGL2?e.deleteVertexArray(t):a.deleteVertexArrayOES(t)}function h(e,t,n){const r=!0===n.wireframe;let o=s[e.id];void 0===o&&(o={},s[e.id]=o);let a=o[t.id];void 0===a&&(a={},o[t.id]=a);let i=a[r];return void 0===i&&(i=v(u()),a[r]=i),i}function v(e){const t=[],n=[],r=[];for(let e=0;e<o;e++)t[e]=0,n[e]=0,r[e]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:n,attributeDivisors:r,object:e,attributes:{},index:null}}function m(e,t){const n=c.attributes,r=e.attributes;let o=0;for(const e in r){const t=n[e],a=r[e];if(void 0===t)return!0;if(t.attribute!==a)return!0;if(t.data!==a.data)return!0;o++}return c.attributesNum!==o||c.index!==t}function x(e,t){const n={},r=e.attributes;let o=0;for(const e in r){const t=r[e],a={};a.attribute=t,t.data&&(a.data=t.data),n[e]=a,o++}c.attributes=n,c.attributesNum=o,c.index=t}function g(){const e=c.newAttributes;for(let t=0,n=e.length;t<n;t++)e[t]=0}function y(e){E(e,0)}function E(n,o){const a=c.newAttributes,i=c.enabledAttributes,s=c.attributeDivisors;a[n]=1,0===i[n]&&(e.enableVertexAttribArray(n),i[n]=1),s[n]!==o&&((r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](n,o),s[n]=o)}function w(){const t=c.newAttributes,n=c.enabledAttributes;for(let r=0,o=n.length;r<o;r++)n[r]!==t[r]&&(e.disableVertexAttribArray(r),n[r]=0)}function b(t,n,o,a,i,s){!0!==r.isWebGL2||o!==e.INT&&o!==e.UNSIGNED_INT?e.vertexAttribPointer(t,n,o,a,i,s):e.vertexAttribIPointer(t,n,o,i,s)}function _(o,a,i,s){if(!1===r.isWebGL2&&(o.isInstancedMesh||s.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;g();const l=s.attributes,c=i.getAttributes(),f=a.defaultAttributeValues;for(const t in c){const r=c[t];if(r>=0){const a=l[t];if(void 0!==a){const t=a.normalized,o=a.itemSize,i=n.get(a);if(void 0===i)continue;const l=i.buffer,c=i.type,f=i.bytesPerElement;if(a.isInterleavedBufferAttribute){const n=a.data,i=n.stride,u=a.offset;n&&n.isInstancedInterleavedBuffer?(E(r,n.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=n.meshPerAttribute*n.count)):y(r),e.bindBuffer(e.ARRAY_BUFFER,l),b(r,o,c,t,i*f,u*f)}else a.isInstancedBufferAttribute?(E(r,a.meshPerAttribute),void 0===s._maxInstanceCount&&(s._maxInstanceCount=a.meshPerAttribute*a.count)):y(r),e.bindBuffer(e.ARRAY_BUFFER,l),b(r,o,c,t,0,0)}else if("instanceMatrix"===t){const t=n.get(o.instanceMatrix);if(void 0===t)continue;const a=t.buffer,i=t.type;E(r+0,1),E(r+1,1),E(r+2,1),E(r+3,1),e.bindBuffer(e.ARRAY_BUFFER,a),e.vertexAttribPointer(r+0,4,i,!1,64,0),e.vertexAttribPointer(r+1,4,i,!1,64,16),e.vertexAttribPointer(r+2,4,i,!1,64,32),e.vertexAttribPointer(r+3,4,i,!1,64,48)}else if("instanceColor"===t){const t=n.get(o.instanceColor);if(void 0===t)continue;const a=t.buffer,i=t.type;E(r,1),e.bindBuffer(e.ARRAY_BUFFER,a),e.vertexAttribPointer(r,3,i,!1,12,0)}else if(void 0!==f){const n=f[t];if(void 0!==n)switch(n.length){case 2:e.vertexAttrib2fv(r,n);break;case 3:e.vertexAttrib3fv(r,n);break;case 4:e.vertexAttrib4fv(r,n);break;default:e.vertexAttrib1fv(r,n)}}}}w()}function T(){R();for(const e in s){const t=s[e];for(const e in t){const n=t[e];for(const e in n)p(n[e].object),delete n[e];delete t[e]}delete s[e]}}function A(e){if(void 0===s[e.id])return;const t=s[e.id];for(const e in t){const n=t[e];for(const e in n)p(n[e].object),delete n[e];delete t[e]}delete s[e.id]}function S(e){for(const t in s){const n=s[t];if(void 0===n[e.id])continue;const r=n[e.id];for(const e in r)p(r[e].object),delete r[e];delete n[e.id]}}function R(){M(),c!==l&&(c=l,d(c.object))}function M(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:f,reset:R,resetDefaultState:M,dispose:T,releaseStatesOfGeometry:A,releaseStatesOfProgram:S,initAttributes:g,enableAttribute:y,disableUnusedAttributes:w}}function li(e,t,n,r){const o=r.isWebGL2;let a;function i(e){a=e}function s(t,r){e.drawArrays(a,t,r),n.update(r,a,1)}function l(r,i,s){if(0===s)return;let l,c;if(o)l=e,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](a,r,i,s),n.update(i,a,s)}this.setMode=i,this.render=s,this.renderInstances=l}function ci(e,t,n){let r;function o(){if(void 0!==r)return r;if(!0===t.has("EXT_texture_filter_anisotropic")){const n=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function a(t){if("highp"===t){if(e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision>0&&e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const i="undefined"!=typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let s=void 0!==n.precision?n.precision:"highp";const l=a(s);l!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",l,"instead."),s=l);const c=!0===n.logarithmicDepthBuffer,f=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),u=e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=e.getParameter(e.MAX_TEXTURE_SIZE),p=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),h=e.getParameter(e.MAX_VERTEX_ATTRIBS),v=e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),m=e.getParameter(e.MAX_VARYING_VECTORS),x=e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),g=u>0,y=i||t.has("OES_texture_float");return{isWebGL2:i,getMaxAnisotropy:o,getMaxPrecision:a,precision:s,logarithmicDepthBuffer:c,maxTextures:f,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:p,maxAttributes:h,maxVertexUniforms:v,maxVaryings:m,maxFragmentUniforms:x,vertexTextures:g,floatFragmentTextures:y,floatVertexTextures:g&&y,maxSamples:i?e.getParameter(e.MAX_SAMPLES):0}}function fi(e){const t=this;let n=null,r=0,o=!1,a=!1;const i=new To,s=new sr,l={value:null,needsUpdate:!1};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function f(e,n,r,o){const a=null!==e?e.length:0;let c=null;if(0!==a){if(c=l.value,!0!==o||null===c){const t=r+4*a,o=n.matrixWorldInverse;s.getNormalMatrix(o),(null===c||c.length<t)&&(c=new Float32Array(t));for(let t=0,n=r;t!==a;++t,n+=4)i.copy(e[t]).applyMatrix4(o,s),i.normal.toArray(c,n),c[n+3]=i.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=a,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,a){const i=0!==e.length||t||0!==r||o;return o=t,n=f(e,a,0),r=e.length,i},this.beginShadows=function(){a=!0,f(null)},this.endShadows=function(){a=!1,c()},this.setState=function(t,i,s){const u=t.clippingPlanes,d=t.clipIntersection,p=t.clipShadows,h=e.get(t);if(!o||null===u||0===u.length||a&&!p)a?f(null):c();else{const e=a?0:r,t=4*e;let o=h.clippingState||null;l.value=o,o=f(u,i,t,s);for(let e=0;e!==t;++e)o[e]=n[e];h.clippingState=o,this.numIntersection=d?this.numPlanes:0,this.numPlanes+=e}}}function ui(e){let t=new WeakMap;function n(e,t){return t===ae?e.mapping=re:t===ie&&(e.mapping=oe),e}function r(r){if(r&&r.isTexture){const a=r.mapping;if(a===ae||a===ie){if(t.has(r))return n(t.get(r).texture,r.mapping);{const a=r.image;if(a&&a.height>0){const i=e.getRenderTarget(),s=new Qa(a.height/2);return s.fromEquirectangularTexture(e,r),t.set(r,s),e.setRenderTarget(i),r.addEventListener("dispose",o),n(s.texture,r.mapping)}return null}}}return r}function o(e){const n=e.target;n.removeEventListener("dispose",o);const r=t.get(n);void 0!==r&&(t.delete(n),r.dispose())}function a(){t=new WeakMap}return{get:r,dispose:a}}function di(e){const t={};function n(n){if(void 0!==t[n])return t[n];let r;switch(n){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(n)}return t[n]=r,r}return{has:function(e){return null!==n(e)},init:function(e){e.isWebGL2?n("EXT_color_buffer_float"):(n("WEBGL_depth_texture"),n("OES_texture_float"),n("OES_texture_half_float"),n("OES_texture_half_float_linear"),n("OES_standard_derivatives"),n("OES_element_index_uint"),n("OES_vertex_array_object"),n("ANGLE_instanced_arrays")),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float")},get:function(e){const t=n(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function pi(e,t,n,r){const o={},a=new WeakMap;function i(e){const s=e.target;null!==s.index&&t.remove(s.index);for(const e in s.attributes)t.remove(s.attributes[e]);s.removeEventListener("dispose",i),delete o[s.id];const l=a.get(s);l&&(t.remove(l),a.delete(s)),r.releaseStatesOfGeometry(s),!0===s.isInstancedBufferGeometry&&delete s._maxInstanceCount,n.memory.geometries--}function s(e,t){return!0===o[t.id]||(t.addEventListener("dispose",i),o[t.id]=!0,n.memory.geometries++),t}function l(n){const r=n.attributes;for(const n in r)t.update(r[n],e.ARRAY_BUFFER);const o=n.morphAttributes;for(const n in o){const r=o[n];for(let n=0,o=r.length;n<o;n++)t.update(r[n],e.ARRAY_BUFFER)}}function c(e){const n=[],r=e.index,o=e.attributes.position;let i=0;if(null!==r){const e=r.array;i=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],o=e[t+1],a=e[t+2];n.push(r,o,o,a,a,r)}}else{const e=o.array;i=o.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,o=t+2;n.push(e,r,r,o,o,e)}}const s=new(aa(n)>65535?ta:$o)(n,1);s.version=i;const l=a.get(e);l&&t.remove(l),a.set(e,s)}function f(e){const t=a.get(e);if(t){const n=e.index;null!==n&&t.version<n.version&&c(e)}else c(e);return a.get(e)}return{get:s,update:l,getWireframeAttribute:f}}function hi(e,t,n,r){const o=r.isWebGL2;let a,i,s;function l(e){a=e}function c(e){i=e.type,s=e.bytesPerElement}function f(t,r){e.drawElements(a,r,i,t*s),n.update(r,a,1)}function u(r,l,c){if(0===c)return;let f,u;if(o)f=e,u="drawElementsInstanced";else if(f=t.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===f)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");f[u](a,l,i,r*s,c),n.update(l,a,c)}this.setMode=l,this.setIndex=c,this.render=f,this.renderInstances=u}function vi(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(n,r,o){switch(t.calls++,r){case e.TRIANGLES:t.triangles+=o*(n/3);break;case e.LINES:t.lines+=o*(n/2);break;case e.LINE_STRIP:t.lines+=o*(n-1);break;case e.LINE_LOOP:t.lines+=o*n;break;case e.POINTS:t.points+=o*n;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",r)}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:r,update:n}}function mi(e,t){return e[0]-t[0]}function xi(e,t){return Math.abs(t[1])-Math.abs(e[1])}function gi(e){const t={},n=new Float32Array(8),r=[];for(let e=0;e<8;e++)r[e]=[e,0];function o(o,a,i,s){const l=o.morphTargetInfluences,c=void 0===l?0:l.length;let f=t[a.id];if(void 0===f){f=[];for(let e=0;e<c;e++)f[e]=[e,0];t[a.id]=f}for(let e=0;e<c;e++){const t=f[e];t[0]=e,t[1]=l[e]}f.sort(xi);for(let e=0;e<8;e++)e<c&&f[e][1]?(r[e][0]=f[e][0],r[e][1]=f[e][1]):(r[e][0]=Number.MAX_SAFE_INTEGER,r[e][1]=0);r.sort(mi);const u=i.morphTargets&&a.morphAttributes.position,d=i.morphNormals&&a.morphAttributes.normal;let p=0;for(let e=0;e<8;e++){const t=r[e],o=t[0],i=t[1];o!==Number.MAX_SAFE_INTEGER&&i?(u&&a.getAttribute("morphTarget"+e)!==u[o]&&a.setAttribute("morphTarget"+e,u[o]),d&&a.getAttribute("morphNormal"+e)!==d[o]&&a.setAttribute("morphNormal"+e,d[o]),n[e]=i,p+=i):(u&&!0===a.hasAttribute("morphTarget"+e)&&a.deleteAttribute("morphTarget"+e),d&&!0===a.hasAttribute("morphNormal"+e)&&a.deleteAttribute("morphNormal"+e),n[e]=0)}const h=a.morphTargetsRelative?1:1-p;s.getUniforms().setValue(e,"morphTargetBaseInfluence",h),s.getUniforms().setValue(e,"morphTargetInfluences",n)}return{update:o}}function yi(e,t,n,r){let o=new WeakMap;function a(a){const i=r.render.frame,l=a.geometry,c=t.get(a,l);return o.get(c)!==i&&(t.update(c),o.set(c,i)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",s)&&a.addEventListener("dispose",s),n.update(a.instanceMatrix,e.ARRAY_BUFFER),null!==a.instanceColor&&n.update(a.instanceColor,e.ARRAY_BUFFER)),c}function i(){o=new WeakMap}function s(e){const t=e.target;t.removeEventListener("dispose",s),n.remove(t.instanceMatrix),null!==t.instanceColor&&n.remove(t.instanceColor)}return{update:a,dispose:i}}ai.physical={uniforms:Ia([ai.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new ir(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Wo(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:ri.meshphysical_vert,fragmentShader:ri.meshphysical_frag};class Ei extends ur{constructor(e=null,t=1,n=1,r=1){super(null),this.image={data:e,width:t,height:n,depth:r},this.magFilter=de,this.minFilter=de,this.wrapR=fe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Ei.prototype.isDataTexture2DArray=!0;class wi extends ur{constructor(e=null,t=1,n=1,r=1){super(null),this.image={data:e,width:t,height:n,depth:r},this.magFilter=de,this.minFilter=de,this.wrapR=fe,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}wi.prototype.isDataTexture3D=!0;const bi=new ur,_i=new Ei,Ti=new wi,Ai=new Ya,Si=[],Ri=[],Mi=new Float32Array(16),Ci=new Float32Array(9),Li=new Float32Array(4);function Pi(e,t,n){const r=e[0];if(r<=0||r>0)return e;const o=t*n;let a=Si[o];if(void 0===a&&(a=new Float32Array(o),Si[o]=a),0!==t){r.toArray(a,0);for(let r=1,o=0;r!==t;++r)o+=n,e[r].toArray(a,o)}return a}function ki(e,t){if(e.length!==t.length)return!1;for(let n=0,r=e.length;n<r;n++)if(e[n]!==t[n])return!1;return!0}function Ni(e,t){for(let n=0,r=t.length;n<r;n++)e[n]=t[n]}function Hi(e,t){let n=Ri[t];void 0===n&&(n=new Int32Array(t),Ri[t]=n);for(let r=0;r!==t;++r)n[r]=e.allocateTextureUnit();return n}function zi(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function Di(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(ki(n,t))return;e.uniform2fv(this.addr,t),Ni(n,t)}}function Fi(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(void 0!==t.r)n[0]===t.r&&n[1]===t.g&&n[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(ki(n,t))return;e.uniform3fv(this.addr,t),Ni(n,t)}}function Ii(e,t){const n=this.cache;if(void 0!==t.x)n[0]===t.x&&n[1]===t.y&&n[2]===t.z&&n[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(ki(n,t))return;e.uniform4fv(this.addr,t),Ni(n,t)}}function Oi(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(ki(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),Ni(n,t)}else{if(ki(n,r))return;Li.set(r),e.uniformMatrix2fv(this.addr,!1,Li),Ni(n,r)}}function Ui(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(ki(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),Ni(n,t)}else{if(ki(n,r))return;Ci.set(r),e.uniformMatrix3fv(this.addr,!1,Ci),Ni(n,r)}}function Gi(e,t){const n=this.cache,r=t.elements;if(void 0===r){if(ki(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),Ni(n,t)}else{if(ki(n,r))return;Mi.set(r),e.uniformMatrix4fv(this.addr,!1,Mi),Ni(n,r)}}function Bi(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function Vi(e,t){const n=this.cache;ki(n,t)||(e.uniform2iv(this.addr,t),Ni(n,t))}function Wi(e,t){const n=this.cache;ki(n,t)||(e.uniform3iv(this.addr,t),Ni(n,t))}function ji(e,t){const n=this.cache;ki(n,t)||(e.uniform4iv(this.addr,t),Ni(n,t))}function qi(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function Xi(e,t){const n=this.cache;ki(n,t)||(e.uniform2uiv(this.addr,t),Ni(n,t))}function Yi(e,t){const n=this.cache;ki(n,t)||(e.uniform3uiv(this.addr,t),Ni(n,t))}function Qi(e,t){const n=this.cache;ki(n,t)||(e.uniform4uiv(this.addr,t),Ni(n,t))}function Ki(e,t,n){const r=this.cache,o=n.allocateTextureUnit();r[0]!==o&&(e.uniform1i(this.addr,o),r[0]=o),n.safeSetTexture2D(t||bi,o)}function Zi(e,t,n){const r=this.cache,o=n.allocateTextureUnit();r[0]!==o&&(e.uniform1i(this.addr,o),r[0]=o),n.setTexture3D(t||Ti,o)}function Ji(e,t,n){const r=this.cache,o=n.allocateTextureUnit();r[0]!==o&&(e.uniform1i(this.addr,o),r[0]=o),n.safeSetTextureCube(t||Ai,o)}function $i(e,t,n){const r=this.cache,o=n.allocateTextureUnit();r[0]!==o&&(e.uniform1i(this.addr,o),r[0]=o),n.setTexture2DArray(t||_i,o)}function es(e){switch(e){case 5126:return zi;case 35664:return Di;case 35665:return Fi;case 35666:return Ii;case 35674:return Oi;case 35675:return Ui;case 35676:return Gi;case 5124:case 35670:return Bi;case 35667:case 35671:return Vi;case 35668:case 35672:return Wi;case 35669:case 35673:return ji;case 5125:return qi;case 36294:return Xi;case 36295:return Yi;case 36296:return Qi;case 35678:case 36198:case 36298:case 36306:case 35682:return Ki;case 35679:case 36299:case 36307:return Zi;case 35680:case 36300:case 36308:case 36293:return Ji;case 36289:case 36303:case 36311:case 36292:return $i}}function ts(e,t){e.uniform1fv(this.addr,t)}function ns(e,t){const n=Pi(t,this.size,2);e.uniform2fv(this.addr,n)}function rs(e,t){const n=Pi(t,this.size,3);e.uniform3fv(this.addr,n)}function os(e,t){const n=Pi(t,this.size,4);e.uniform4fv(this.addr,n)}function as(e,t){const n=Pi(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function is(e,t){const n=Pi(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function ss(e,t){const n=Pi(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function ls(e,t){e.uniform1iv(this.addr,t)}function cs(e,t){e.uniform2iv(this.addr,t)}function fs(e,t){e.uniform3iv(this.addr,t)}function us(e,t){e.uniform4iv(this.addr,t)}function ds(e,t){e.uniform1uiv(this.addr,t)}function ps(e,t){e.uniform2uiv(this.addr,t)}function hs(e,t){e.uniform3uiv(this.addr,t)}function vs(e,t){e.uniform4uiv(this.addr,t)}function ms(e,t,n){const r=t.length,o=Hi(n,r);e.uniform1iv(this.addr,o);for(let e=0;e!==r;++e)n.safeSetTexture2D(t[e]||bi,o[e])}function xs(e,t,n){const r=t.length,o=Hi(n,r);e.uniform1iv(this.addr,o);for(let e=0;e!==r;++e)n.safeSetTextureCube(t[e]||Ai,o[e])}function gs(e){switch(e){case 5126:return ts;case 35664:return ns;case 35665:return rs;case 35666:return os;case 35674:return as;case 35675:return is;case 35676:return ss;case 5124:case 35670:return ls;case 35667:case 35671:return cs;case 35668:case 35672:return fs;case 35669:case 35673:return us;case 5125:return ds;case 36294:return ps;case 36295:return hs;case 36296:return vs;case 35678:case 36198:case 36298:case 36306:case 35682:return ms;case 35680:case 36300:case 36308:case 36293:return xs}}function ys(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=es(t.type)}function Es(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=gs(t.type)}function ws(e){this.id=e,this.seq=[],this.map={}}Es.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),Ni(t,e)},ws.prototype.setValue=function(e,t,n){const r=this.seq;for(let o=0,a=r.length;o!==a;++o){const a=r[o];a.setValue(e,t[a.id],n)}};const bs=/(\w+)(\])?(\[|\.)?/g;function _s(e,t){e.seq.push(t),e.map[t.id]=t}function Ts(e,t,n){const r=e.name,o=r.length;for(bs.lastIndex=0;;){const a=bs.exec(r),i=bs.lastIndex;let s=a[1];const l="]"===a[2],c=a[3];if(l&&(s|=0),void 0===c||"["===c&&i+2===o){_s(n,void 0===c?new ys(s,e,t):new Es(s,e,t));break}{let e=n.map[s];void 0===e&&(e=new ws(s),_s(n,e)),n=e}}}function As(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let r=0;r<n;++r){const n=e.getActiveUniform(t,r);Ts(n,e.getUniformLocation(t,n.name),this)}}function Ss(e,t,n){const r=e.createShader(t);return e.shaderSource(r,n),e.compileShader(r),r}As.prototype.setValue=function(e,t,n,r){const o=this.map[t];void 0!==o&&o.setValue(e,n,r)},As.prototype.setOptional=function(e,t,n){const r=t[n];void 0!==r&&this.setValue(e,n,r)},As.upload=function(e,t,n,r){for(let o=0,a=t.length;o!==a;++o){const a=t[o],i=n[a.id];!1!==i.needsUpdate&&a.setValue(e,i.value,r)}},As.seqWithValue=function(e,t){const n=[];for(let r=0,o=e.length;r!==o;++r){const o=e[r];o.id in t&&n.push(o)}return n};let Rs=0;function Ms(e){const t=e.split("\n");for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join("\n")}function Cs(e){switch(e){case Yt:return["Linear","( value )"];case Qt:return["sRGB","( value )"];case Zt:return["RGBE","( value )"];case $t:return["RGBM","( value, 7.0 )"];case en:return["RGBM","( value, 16.0 )"];case tn:return["RGBD","( value, 256.0 )"];case Kt:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Jt:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function Ls(e,t,n){const r=e.getShaderParameter(t,e.COMPILE_STATUS),o=e.getShaderInfoLog(t).trim();return r&&""===o?"":"THREE.WebGLShader: gl.getShaderInfoLog() "+n+"\n"+o+Ms(e.getShaderSource(t))}function Ps(e,t){const n=Cs(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function ks(e,t){const n=Cs(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Ns(e,t){let n;switch(t){case Z:n="Linear";break;case J:n="Reinhard";break;case $:n="OptimizedCineon";break;case ee:n="ACESFilmic";break;case te:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Hs(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Fs).join("\n")}function zs(e){const t=[];for(const n in e){const r=e[n];!1!==r&&t.push("#define "+n+" "+r)}return t.join("\n")}function Ds(e,t){const n={},r=e.getProgramParameter(t,e.ACTIVE_ATTRIBUTES);for(let o=0;o<r;o++){const r=e.getActiveAttrib(t,o).name;n[r]=e.getAttribLocation(t,r)}return n}function Fs(e){return""!==e}function Is(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Os(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Us=/^[ \t]*#include +<([\w\d./]+)>/gm;function Gs(e){return e.replace(Us,Bs)}function Bs(e,t){const n=ri[t];if(void 0===n)throw new Error("Can not resolve #include <"+t+">");return Gs(n)}const Vs=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Ws=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function js(e){return e.replace(Ws,Xs).replace(Vs,qs)}function qs(e,t,n,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Xs(e,t,n,r)}function Xs(e,t,n,r){let o="";for(let e=parseInt(t);e<parseInt(n);e++)o+=r.replace(/\[\s*i\s*\]/g,"[ "+e+" ]").replace(/UNROLLED_LOOP_INDEX/g,e);return o}function Ys(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function Qs(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===c?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===f?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===u&&(t="SHADOWMAP_TYPE_VSM"),t}function Ks(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case re:case oe:t="ENVMAP_TYPE_CUBE";break;case se:case le:t="ENVMAP_TYPE_CUBE_UV"}return t}function Zs(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case oe:case le:t="ENVMAP_MODE_REFRACTION"}return t}function Js(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case X:t="ENVMAP_BLENDING_MULTIPLY";break;case Y:t="ENVMAP_BLENDING_MIX";break;case Q:t="ENVMAP_BLENDING_ADD"}return t}function $s(e,t,n,r){const o=e.getContext(),a=n.defines;let i=n.vertexShader,s=n.fragmentShader;const l=Qs(n),c=Ks(n),f=Zs(n),u=Js(n),d=e.gammaFactor>0?e.gammaFactor:1,p=n.isWebGL2?"":Hs(n),h=zs(a),v=o.createProgram();let m,x,g=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?(m=[h].filter(Fs).join("\n"),m.length>0&&(m+="\n"),x=[p,h].filter(Fs).join("\n"),x.length>0&&(x+="\n")):(m=[Ys(n),"#define SHADER_NAME "+n.shaderName,h,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+f:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Fs).join("\n"),x=[p,Ys(n),"#define SHADER_NAME "+n.shaderName,h,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+f:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==K?"#define TONE_MAPPING":"",n.toneMapping!==K?ri.tonemapping_pars_fragment:"",n.toneMapping!==K?Ns("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",ri.encodings_pars_fragment,n.map?Ps("mapTexelToLinear",n.mapEncoding):"",n.matcap?Ps("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Ps("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Ps("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?Ps("lightMapTexelToLinear",n.lightMapEncoding):"",ks("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Fs).join("\n")),i=Gs(i),i=Is(i,n),i=Os(i,n),s=Gs(s),s=Is(s,n),s=Os(s,n),i=js(i),s=js(s),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(g="#version 300 es\n",m=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+m,x=["#define varying in",n.glslVersion===Nn?"":"out highp vec4 pc_fragColor;",n.glslVersion===Nn?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+x);const y=g+m+i,E=g+x+s,w=Ss(o,o.VERTEX_SHADER,y),b=Ss(o,o.FRAGMENT_SHADER,E);if(o.attachShader(v,w),o.attachShader(v,b),void 0!==n.index0AttributeName?o.bindAttribLocation(v,0,n.index0AttributeName):!0===n.morphTargets&&o.bindAttribLocation(v,0,"position"),o.linkProgram(v),e.debug.checkShaderErrors){const e=o.getProgramInfoLog(v).trim(),t=o.getShaderInfoLog(w).trim(),n=o.getShaderInfoLog(b).trim();let r=!0,a=!0;if(!1===o.getProgramParameter(v,o.LINK_STATUS)){r=!1;const t=Ls(o,w,"vertex"),n=Ls(o,b,"fragment");console.error("THREE.WebGLProgram: shader error: ",o.getError(),"gl.VALIDATE_STATUS",o.getProgramParameter(v,o.VALIDATE_STATUS),"gl.getProgramInfoLog",e,t,n)}else""!==e?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",e):""!==t&&""!==n||(a=!1);a&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:m},fragmentShader:{log:n,prefix:x}})}let _,T;return o.deleteShader(w),o.deleteShader(b),this.getUniforms=function(){return void 0===_&&(_=new As(o,v)),_},this.getAttributes=function(){return void 0===T&&(T=Ds(o,v)),T},this.destroy=function(){r.releaseStatesOfProgram(this),o.deleteProgram(v),this.program=void 0},this.name=n.shaderName,this.id=Rs++,this.cacheKey=t,this.usedTimes=1,this.program=v,this.vertexShader=w,this.fragmentShader=b,this}function el(e,t,n,r,o,a){const i=[],s=r.isWebGL2,l=r.logarithmicDepthBuffer,c=r.floatVertexTextures,f=r.maxVertexUniforms,u=r.vertexTextures;let d=r.precision;const v={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function x(e){const t=e.skeleton.bones;if(c)return 1024;{const e=f,n=Math.floor((e-20)/4),r=Math.min(n,t.length);return r<t.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+t.length+" bones. This GPU supports "+r+"."),0):r}}function g(e){let t;return e&&e.isTexture?t=e.encoding:e&&e.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),t=e.texture.encoding):t=Yt,t}function y(o,i,f,m,y){const E=m.fog,w=o.isMeshStandardMaterial?m.environment:null,b=t.get(o.envMap||w),_=v[o.type],T=y.isSkinnedMesh?x(y):0;let A,S;if(null!==o.precision&&(d=r.getMaxPrecision(o.precision),d!==o.precision&&console.warn("THREE.WebGLProgram.getParameters:",o.precision,"not supported, using",d,"instead.")),_){const e=ai[_];A=e.vertexShader,S=e.fragmentShader}else A=o.vertexShader,S=o.fragmentShader;const R=e.getRenderTarget();return{isWebGL2:s,shaderID:_,shaderName:o.type,vertexShader:A,fragmentShader:S,defines:o.defines,isRawShaderMaterial:!0===o.isRawShaderMaterial,glslVersion:o.glslVersion,precision:d,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:u,outputEncoding:null!==R?g(R.texture):e.outputEncoding,map:!!o.map,mapEncoding:g(o.map),matcap:!!o.matcap,matcapEncoding:g(o.matcap),envMap:!!b,envMapMode:b&&b.mapping,envMapEncoding:g(b),envMapCubeUV:!!b&&(b.mapping===se||b.mapping===le),lightMap:!!o.lightMap,lightMapEncoding:g(o.lightMap),aoMap:!!o.aoMap,emissiveMap:!!o.emissiveMap,emissiveMapEncoding:g(o.emissiveMap),bumpMap:!!o.bumpMap,normalMap:!!o.normalMap,objectSpaceNormalMap:o.normalMapType===an,tangentSpaceNormalMap:o.normalMapType===on,clearcoatMap:!!o.clearcoatMap,clearcoatRoughnessMap:!!o.clearcoatRoughnessMap,clearcoatNormalMap:!!o.clearcoatNormalMap,displacementMap:!!o.displacementMap,roughnessMap:!!o.roughnessMap,metalnessMap:!!o.metalnessMap,specularMap:!!o.specularMap,alphaMap:!!o.alphaMap,gradientMap:!!o.gradientMap,sheen:!!o.sheen,transmissionMap:!!o.transmissionMap,combine:o.combine,vertexTangents:o.normalMap&&o.vertexTangents,vertexColors:o.vertexColors,vertexAlphas:!0===o.vertexColors&&y.geometry&&y.geometry.attributes.color&&4===y.geometry.attributes.color.itemSize,vertexUvs:!!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatMap||o.clearcoatRoughnessMap||o.clearcoatNormalMap||o.displacementMap||o.transmissionMap),uvsVertexOnly:!(o.map||o.bumpMap||o.normalMap||o.specularMap||o.alphaMap||o.emissiveMap||o.roughnessMap||o.metalnessMap||o.clearcoatNormalMap||o.transmissionMap||!o.displacementMap),fog:!!E,useFog:o.fog,fogExp2:E&&E.isFogExp2,flatShading:!!o.flatShading,sizeAttenuation:o.sizeAttenuation,logarithmicDepthBuffer:l,skinning:o.skinning&&T>0,maxBones:T,useVertexTexture:c,morphTargets:o.morphTargets,morphNormals:o.morphNormals,numDirLights:i.directional.length,numPointLights:i.point.length,numSpotLights:i.spot.length,numRectAreaLights:i.rectArea.length,numHemiLights:i.hemi.length,numDirLightShadows:i.directionalShadowMap.length,numPointLightShadows:i.pointShadowMap.length,numSpotLightShadows:i.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:o.dithering,shadowMapEnabled:e.shadowMap.enabled&&f.length>0,shadowMapType:e.shadowMap.type,toneMapping:o.toneMapped?e.toneMapping:K,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:o.premultipliedAlpha,alphaTest:o.alphaTest,doubleSided:o.side===h,flipSided:o.side===p,depthPacking:void 0!==o.depthPacking&&o.depthPacking,index0AttributeName:o.index0AttributeName,extensionDerivatives:o.extensions&&o.extensions.derivatives,extensionFragDepth:o.extensions&&o.extensions.fragDepth,extensionDrawBuffers:o.extensions&&o.extensions.drawBuffers,extensionShaderTextureLOD:o.extensions&&o.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||n.has("EXT_shader_texture_lod"),customProgramCacheKey:o.customProgramCacheKey()}}function E(t){const n=[];if(t.shaderID?n.push(t.shaderID):(n.push(t.fragmentShader),n.push(t.vertexShader)),void 0!==t.defines)for(const e in t.defines)n.push(e),n.push(t.defines[e]);if(!1===t.isRawShaderMaterial){for(let e=0;e<m.length;e++)n.push(t[m[e]]);n.push(e.outputEncoding),n.push(e.gammaFactor)}return n.push(t.customProgramCacheKey),n.join()}function w(e){const t=v[e.type];let n;if(t){const e=ai[t];n=Oa.clone(e.uniforms)}else n=e.uniforms;return n}function b(t,n){let r;for(let e=0,t=i.length;e<t;e++){const t=i[e];if(t.cacheKey===n){r=t,++r.usedTimes;break}}return void 0===r&&(r=new $s(e,n,t,o),i.push(r)),r}function _(e){if(0==--e.usedTimes){const t=i.indexOf(e);i[t]=i[i.length-1],i.pop(),e.destroy()}}return{getParameters:y,getProgramCacheKey:E,getUniforms:w,acquireProgram:b,releaseProgram:_,programs:i}}function tl(){let e=new WeakMap;function t(t){let n=e.get(t);return void 0===n&&(n={},e.set(t,n)),n}function n(t){e.delete(t)}function r(t,n,r){e.get(t)[n]=r}function o(){e=new WeakMap}return{get:t,remove:n,update:r,dispose:o}}function nl(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function rl(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function ol(e){const t=[];let n=0;const r=[],o=[],a={id:-1};function i(){n=0,r.length=0,o.length=0}function s(r,o,i,s,l,c){let f=t[n];const u=e.get(i);return void 0===f?(f={id:r.id,object:r,geometry:o,material:i,program:u.program||a,groupOrder:s,renderOrder:r.renderOrder,z:l,group:c},t[n]=f):(f.id=r.id,f.object=r,f.geometry=o,f.material=i,f.program=u.program||a,f.groupOrder=s,f.renderOrder=r.renderOrder,f.z=l,f.group=c),n++,f}function l(e,t,n,a,i,l){const c=s(e,t,n,a,i,l);(!0===n.transparent?o:r).push(c)}function c(e,t,n,a,i,l){const c=s(e,t,n,a,i,l);(!0===n.transparent?o:r).unshift(c)}function f(e,t){r.length>1&&r.sort(e||nl),o.length>1&&o.sort(t||rl)}function u(){for(let e=n,r=t.length;e<r;e++){const n=t[e];if(null===n.id)break;n.id=null,n.object=null,n.geometry=null,n.material=null,n.program=null,n.group=null}}return{opaque:r,transparent:o,init:i,push:l,unshift:c,finish:u,sort:f}}function al(e){let t=new WeakMap;function n(n,r){let o;return!1===t.has(n)?(o=new ol(e),t.set(n,[o])):r>=t.get(n).length?(o=new ol(e),t.get(n).push(o)):o=t.get(n)[r],o}function r(){t=new WeakMap}return{get:n,dispose:r}}function il(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new xr,color:new Wo};break;case"SpotLight":n={position:new xr,direction:new xr,color:new Wo,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new xr,color:new Wo,distance:0,decay:0};break;case"HemisphereLight":n={direction:new xr,skyColor:new Wo,groundColor:new Wo};break;case"RectAreaLight":n={color:new Wo,position:new xr,halfWidth:new xr,halfHeight:new xr}}return e[t.id]=n,n}}}function sl(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let n;switch(t.type){case"DirectionalLight":case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ir};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new ir,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=n,n}}}let ll=0;function cl(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function fl(e,t){const n=new il,r=sl(),o={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let e=0;e<9;e++)o.probe.push(new xr);const a=new xr,i=new Yr,s=new Yr;function l(a){let i=0,s=0,l=0;for(let e=0;e<9;e++)o.probe[e].set(0,0,0);let c=0,f=0,u=0,d=0,p=0,h=0,v=0,m=0;a.sort(cl);for(let e=0,t=a.length;e<t;e++){const t=a[e],x=t.color,g=t.intensity,y=t.distance,E=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)i+=x.r*g,s+=x.g*g,l+=x.b*g;else if(t.isLightProbe)for(let e=0;e<9;e++)o.probe[e].addScaledVector(t.sh.coefficients[e],g);else if(t.isDirectionalLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,o.directionalShadow[c]=n,o.directionalShadowMap[c]=E,o.directionalShadowMatrix[c]=t.shadow.matrix,h++}o.directional[c]=e,c++}else if(t.isSpotLight){const e=n.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(x).multiplyScalar(g),e.distance=y,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,o.spotShadow[u]=n,o.spotShadowMap[u]=E,o.spotShadowMatrix[u]=t.shadow.matrix,m++}o.spot[u]=e,u++}else if(t.isRectAreaLight){const e=n.get(t);e.color.copy(x).multiplyScalar(g),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),o.rectArea[d]=e,d++}else if(t.isPointLight){const e=n.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,n=r.get(t);n.shadowBias=e.bias,n.shadowNormalBias=e.normalBias,n.shadowRadius=e.radius,n.shadowMapSize=e.mapSize,n.shadowCameraNear=e.camera.near,n.shadowCameraFar=e.camera.far,o.pointShadow[f]=n,o.pointShadowMap[f]=E,o.pointShadowMatrix[f]=t.shadow.matrix,v++}o.point[f]=e,f++}else if(t.isHemisphereLight){const e=n.get(t);e.skyColor.copy(t.color).multiplyScalar(g),e.groundColor.copy(t.groundColor).multiplyScalar(g),o.hemi[p]=e,p++}}d>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(o.rectAreaLTC1=oi.LTC_FLOAT_1,o.rectAreaLTC2=oi.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(o.rectAreaLTC1=oi.LTC_HALF_1,o.rectAreaLTC2=oi.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),o.ambient[0]=i,o.ambient[1]=s,o.ambient[2]=l;const x=o.hash;x.directionalLength===c&&x.pointLength===f&&x.spotLength===u&&x.rectAreaLength===d&&x.hemiLength===p&&x.numDirectionalShadows===h&&x.numPointShadows===v&&x.numSpotShadows===m||(o.directional.length=c,o.spot.length=u,o.rectArea.length=d,o.point.length=f,o.hemi.length=p,o.directionalShadow.length=h,o.directionalShadowMap.length=h,o.pointShadow.length=v,o.pointShadowMap.length=v,o.spotShadow.length=m,o.spotShadowMap.length=m,o.directionalShadowMatrix.length=h,o.pointShadowMatrix.length=v,o.spotShadowMatrix.length=m,x.directionalLength=c,x.pointLength=f,x.spotLength=u,x.rectAreaLength=d,x.hemiLength=p,x.numDirectionalShadows=h,x.numPointShadows=v,x.numSpotShadows=m,o.version=ll++)}function c(e,t){let n=0,r=0,l=0,c=0,f=0;const u=t.matrixWorldInverse;for(let t=0,d=e.length;t<d;t++){const d=e[t];if(d.isDirectionalLight){const e=o.directional[n];e.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(a),e.direction.transformDirection(u),n++}else if(d.isSpotLight){const e=o.spot[l];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(d.matrixWorld),a.setFromMatrixPosition(d.target.matrixWorld),e.direction.sub(a),e.direction.transformDirection(u),l++}else if(d.isRectAreaLight){const e=o.rectArea[c];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),s.identity(),i.copy(d.matrixWorld),i.premultiply(u),s.extractRotation(i),e.halfWidth.set(.5*d.width,0,0),e.halfHeight.set(0,.5*d.height,0),e.halfWidth.applyMatrix4(s),e.halfHeight.applyMatrix4(s),c++}else if(d.isPointLight){const e=o.point[r];e.position.setFromMatrixPosition(d.matrixWorld),e.position.applyMatrix4(u),r++}else if(d.isHemisphereLight){const e=o.hemi[f];e.direction.setFromMatrixPosition(d.matrixWorld),e.direction.transformDirection(u),e.direction.normalize(),f++}}}return{setup:l,setupView:c,state:o}}function ul(e,t){const n=new fl(e,t),r=[],o=[];function a(){r.length=0,o.length=0}function i(e){r.push(e)}function s(e){o.push(e)}function l(){n.setup(r)}function c(e){n.setupView(r,e)}return{init:a,state:{lightsArray:r,shadowsArray:o,lights:n},setupLights:l,setupLightsView:c,pushLight:i,pushShadow:s}}function dl(e,t){let n=new WeakMap;function r(r,o=0){let a;return!1===n.has(r)?(a=new ul(e,t),n.set(r,[a])):o>=n.get(r).length?(a=new ul(e,t),n.get(r).push(a)):a=n.get(r)[o],a}function o(){n=new WeakMap}return{get:r,dispose:o}}class pl extends Fo{constructor(e){super(),this.type="MeshDepthMaterial",this.depthPacking=nn,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}pl.prototype.isMeshDepthMaterial=!0;class hl extends Fo{constructor(e){super(),this.type="MeshDistanceMaterial",this.referencePosition=new xr,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}hl.prototype.isMeshDistanceMaterial=!0;var vl="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",ml="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";function xl(e,t,n){let r=new $a;const o=new ir,a=new ir,i=new pr,s=[],l=[],f={},v=n.maxTextureSize,m={0:p,1:d,2:h},g=new Ba({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new ir},radius:{value:4}},vertexShader:ml,fragmentShader:vl}),y=g.clone();y.defines.HORIZONTAL_PASS=1;const E=new va;E.setAttribute("position",new Yo(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const w=new Na(E,g),b=this;function _(n,r){const o=t.update(w);g.uniforms.shadow_pass.value=n.map.texture,g.uniforms.resolution.value=n.mapSize,g.uniforms.radius.value=n.radius,e.setRenderTarget(n.mapPass),e.clear(),e.renderBufferDirect(r,null,o,g,w,null),y.uniforms.shadow_pass.value=n.mapPass.texture,y.uniforms.resolution.value=n.mapSize,y.uniforms.radius.value=n.radius,e.setRenderTarget(n.map),e.clear(),e.renderBufferDirect(r,null,o,y,w,null)}function T(e,t,n){const r=e<<0|t<<1|n<<2;let o=s[r];return void 0===o&&(o=new pl({depthPacking:rn,morphTargets:e,skinning:t}),s[r]=o),o}function A(e,t,n){const r=e<<0|t<<1|n<<2;let o=l[r];return void 0===o&&(o=new hl({morphTargets:e,skinning:t}),l[r]=o),o}function S(t,n,r,o,a,i,s){let l=null,c=T,d=t.customDepthMaterial;if(!0===o.isPointLight&&(c=A,d=t.customDistanceMaterial),void 0===d){let e=!1;!0===r.morphTargets&&(e=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);let o=!1;!0===t.isSkinnedMesh&&(!0===r.skinning?o=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",t)),l=c(e,o,!0===t.isInstancedMesh)}else l=d;if(e.localClippingEnabled&&!0===r.clipShadows&&0!==r.clippingPlanes.length){const e=l.uuid,t=r.uuid;let n=f[e];void 0===n&&(n={},f[e]=n);let o=n[t];void 0===o&&(o=l.clone(),n[t]=o),l=o}return l.visible=r.visible,l.wireframe=r.wireframe,l.side=s===u?null!==r.shadowSide?r.shadowSide:r.side:null!==r.shadowSide?r.shadowSide:m[r.side],l.clipShadows=r.clipShadows,l.clippingPlanes=r.clippingPlanes,l.clipIntersection=r.clipIntersection,l.wireframeLinewidth=r.wireframeLinewidth,l.linewidth=r.linewidth,!0===o.isPointLight&&!0===l.isMeshDistanceMaterial&&(l.referencePosition.setFromMatrixPosition(o.matrixWorld),l.nearDistance=a,l.farDistance=i),l}function R(n,o,a,i,s){if(!1===n.visible)return;if(n.layers.test(o.layers)&&(n.isMesh||n.isLine||n.isPoints)&&(n.castShadow||n.receiveShadow&&s===u)&&(!n.frustumCulled||r.intersectsObject(n))){n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse,n.matrixWorld);const r=t.update(n),o=n.material;if(Array.isArray(o)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l],f=o[c.materialIndex];if(f&&f.visible){const t=S(n,r,f,i,a.near,a.far,s);e.renderBufferDirect(a,null,r,t,n,c)}}}else if(o.visible){const t=S(n,r,o,i,a.near,a.far,s);e.renderBufferDirect(a,null,r,t,n,null)}}const l=n.children;for(let e=0,t=l.length;e<t;e++)R(l[e],o,a,i,s)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=c,this.render=function(t,n,s){if(!1===b.enabled)return;if(!1===b.autoUpdate&&!1===b.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),c=e.getActiveCubeFace(),f=e.getActiveMipmapLevel(),d=e.state;d.setBlending(x),d.buffers.color.setClear(1,1,1,1),d.buffers.depth.setTest(!0),d.setScissorTest(!1);for(let l=0,c=t.length;l<c;l++){const c=t[l],f=c.shadow;if(void 0===f){console.warn("THREE.WebGLShadowMap:",c,"has no shadow.");continue}if(!1===f.autoUpdate&&!1===f.needsUpdate)continue;o.copy(f.mapSize);const p=f.getFrameExtents();if(o.multiply(p),a.copy(f.mapSize),(o.x>v||o.y>v)&&(o.x>v&&(a.x=Math.floor(v/p.x),o.x=a.x*p.x,f.mapSize.x=a.x),o.y>v&&(a.y=Math.floor(v/p.y),o.y=a.y*p.y,f.mapSize.y=a.y)),null===f.map&&!f.isPointLightShadow&&this.type===u){const e={minFilter:xe,magFilter:xe,format:De};f.map=new hr(o.x,o.y,e),f.map.texture.name=c.name+".shadowMap",f.mapPass=new hr(o.x,o.y,e),f.camera.updateProjectionMatrix()}if(null===f.map){const e={minFilter:de,magFilter:de,format:De};f.map=new hr(o.x,o.y,e),f.map.texture.name=c.name+".shadowMap",f.camera.updateProjectionMatrix()}e.setRenderTarget(f.map),e.clear();const h=f.getViewportCount();for(let e=0;e<h;e++){const t=f.getViewport(e);i.set(a.x*t.x,a.y*t.y,a.x*t.z,a.y*t.w),d.viewport(i),f.updateMatrices(c,e),r=f.getFrustum(),R(n,s,f.camera,c,this.type)}f.isPointLightShadow||this.type!==u||_(f,s),f.needsUpdate=!1}b.needsUpdate=!1,e.setRenderTarget(l,c,f)}}function gl(e,t,n){const r=n.isWebGL2;function s(){let t=!1;const n=new pr;let r=null;const o=new pr(0,0,0,0);return{setMask:function(n){r===n||t||(e.colorMask(n,n,n,n),r=n)},setLocked:function(e){t=e},setClear:function(t,r,a,i,s){!0===s&&(t*=i,r*=i,a*=i),n.set(t,r,a,i),!1===o.equals(n)&&(e.clearColor(t,r,a,i),o.copy(n))},reset:function(){t=!1,r=null,o.set(-1,0,0,0)}}}function l(){let t=!1,n=null,r=null,o=null;return{setTest:function(t){t?ye(e.DEPTH_TEST):Ee(e.DEPTH_TEST)},setMask:function(r){n===r||t||(e.depthMask(r),n=r)},setFunc:function(t){if(r!==t){if(t)switch(t){case O:e.depthFunc(e.NEVER);break;case U:e.depthFunc(e.ALWAYS);break;case G:e.depthFunc(e.LESS);break;case B:e.depthFunc(e.LEQUAL);break;case V:e.depthFunc(e.EQUAL);break;case W:e.depthFunc(e.GEQUAL);break;case j:e.depthFunc(e.GREATER);break;case q:e.depthFunc(e.NOTEQUAL);break;default:e.depthFunc(e.LEQUAL)}else e.depthFunc(e.LEQUAL);r=t}},setLocked:function(e){t=e},setClear:function(t){o!==t&&(e.clearDepth(t),o=t)},reset:function(){t=!1,n=null,r=null,o=null}}}function c(){let t=!1,n=null,r=null,o=null,a=null,i=null,s=null,l=null,c=null;return{setTest:function(n){t||(n?ye(e.STENCIL_TEST):Ee(e.STENCIL_TEST))},setMask:function(r){n===r||t||(e.stencilMask(r),n=r)},setFunc:function(t,n,i){r===t&&o===n&&a===i||(e.stencilFunc(t,n,i),r=t,o=n,a=i)},setOp:function(t,n,r){i===t&&s===n&&l===r||(e.stencilOp(t,n,r),i=t,s=n,l=r)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,n=null,r=null,o=null,a=null,i=null,s=null,l=null,c=null}}}const f=new s,u=new l,d=new c;let v={},m=null,X={},Y=null,Q=!1,K=null,Z=null,J=null,$=null,ee=null,te=null,ne=null,re=!1,oe=null,ae=null,ie=null,se=null,le=null;const ce=e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let fe=!1,ue=0;const de=e.getParameter(e.VERSION);-1!==de.indexOf("WebGL")?(ue=parseFloat(/^WebGL (\d)/.exec(de)[1]),fe=ue>=1):-1!==de.indexOf("OpenGL ES")&&(ue=parseFloat(/^OpenGL ES (\d)/.exec(de)[1]),fe=ue>=2);let pe=null,he={};const ve=new pr(0,0,e.canvas.width,e.canvas.height),me=new pr(0,0,e.canvas.width,e.canvas.height);function xe(t,n,r){const o=new Uint8Array(4),a=e.createTexture();e.bindTexture(t,a),e.texParameteri(t,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(t,e.TEXTURE_MAG_FILTER,e.NEAREST);for(let t=0;t<r;t++)e.texImage2D(n+t,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,o);return a}const ge={};function ye(t){!0!==v[t]&&(e.enable(t),v[t]=!0)}function Ee(t){!1!==v[t]&&(e.disable(t),v[t]=!1)}function we(t){t!==m&&(e.bindFramebuffer(e.FRAMEBUFFER,t),m=t)}function be(t,n){null===n&&null!==m&&(n=m),X[t]!==n&&(e.bindFramebuffer(t,n),X[t]=n,r&&(t===e.DRAW_FRAMEBUFFER&&(X[e.FRAMEBUFFER]=n),t===e.FRAMEBUFFER&&(X[e.DRAW_FRAMEBUFFER]=n)))}function _e(t){return Y!==t&&(e.useProgram(t),Y=t,!0)}ge[e.TEXTURE_2D]=xe(e.TEXTURE_2D,e.TEXTURE_2D,1),ge[e.TEXTURE_CUBE_MAP]=xe(e.TEXTURE_CUBE_MAP,e.TEXTURE_CUBE_MAP_POSITIVE_X,6),f.setClear(0,0,0,1),u.setClear(1),d.setClear(0),ye(e.DEPTH_TEST),u.setFunc(B),Me(!1),Ce(a),ye(e.CULL_FACE),Se(x);const Te={[_]:e.FUNC_ADD,[T]:e.FUNC_SUBTRACT,[A]:e.FUNC_REVERSE_SUBTRACT};if(r)Te[S]=e.MIN,Te[R]=e.MAX;else{const e=t.get("EXT_blend_minmax");null!==e&&(Te[S]=e.MIN_EXT,Te[R]=e.MAX_EXT)}const Ae={[M]:e.ZERO,[C]:e.ONE,[L]:e.SRC_COLOR,[k]:e.SRC_ALPHA,[I]:e.SRC_ALPHA_SATURATE,[D]:e.DST_COLOR,[H]:e.DST_ALPHA,[P]:e.ONE_MINUS_SRC_COLOR,[N]:e.ONE_MINUS_SRC_ALPHA,[F]:e.ONE_MINUS_DST_COLOR,[z]:e.ONE_MINUS_DST_ALPHA};function Se(t,n,r,o,a,i,s,l){if(t!==x){if(!1===Q&&(ye(e.BLEND),Q=!0),t===b)a=a||n,i=i||r,s=s||o,n===Z&&a===ee||(e.blendEquationSeparate(Te[n],Te[a]),Z=n,ee=a),r===J&&o===$&&i===te&&s===ne||(e.blendFuncSeparate(Ae[r],Ae[o],Ae[i],Ae[s]),J=r,$=o,te=i,ne=s),K=t,re=null;else if(t!==K||l!==re){if(Z===_&&ee===_||(e.blendEquation(e.FUNC_ADD),Z=_,ee=_),l)switch(t){case g:e.blendFuncSeparate(e.ONE,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case y:e.blendFunc(e.ONE,e.ONE);break;case E:e.blendFuncSeparate(e.ZERO,e.ZERO,e.ONE_MINUS_SRC_COLOR,e.ONE_MINUS_SRC_ALPHA);break;case w:e.blendFuncSeparate(e.ZERO,e.SRC_COLOR,e.ZERO,e.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case g:e.blendFuncSeparate(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA,e.ONE,e.ONE_MINUS_SRC_ALPHA);break;case y:e.blendFunc(e.SRC_ALPHA,e.ONE);break;case E:e.blendFunc(e.ZERO,e.ONE_MINUS_SRC_COLOR);break;case w:e.blendFunc(e.ZERO,e.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}J=null,$=null,te=null,ne=null,K=t,re=l}}else!0===Q&&(Ee(e.BLEND),Q=!1)}function Re(t,n){t.side===h?Ee(e.CULL_FACE):ye(e.CULL_FACE);let r=t.side===p;n&&(r=!r),Me(r),t.blending===g&&!1===t.transparent?Se(x):Se(t.blending,t.blendEquation,t.blendSrc,t.blendDst,t.blendEquationAlpha,t.blendSrcAlpha,t.blendDstAlpha,t.premultipliedAlpha),u.setFunc(t.depthFunc),u.setTest(t.depthTest),u.setMask(t.depthWrite),f.setMask(t.colorWrite);const o=t.stencilWrite;d.setTest(o),o&&(d.setMask(t.stencilWriteMask),d.setFunc(t.stencilFunc,t.stencilRef,t.stencilFuncMask),d.setOp(t.stencilFail,t.stencilZFail,t.stencilZPass)),Pe(t.polygonOffset,t.polygonOffsetFactor,t.polygonOffsetUnits),!0===t.alphaToCoverage?ye(e.SAMPLE_ALPHA_TO_COVERAGE):Ee(e.SAMPLE_ALPHA_TO_COVERAGE)}function Me(t){oe!==t&&(t?e.frontFace(e.CW):e.frontFace(e.CCW),oe=t)}function Ce(t){t!==o?(ye(e.CULL_FACE),t!==ae&&(t===a?e.cullFace(e.BACK):t===i?e.cullFace(e.FRONT):e.cullFace(e.FRONT_AND_BACK))):Ee(e.CULL_FACE),ae=t}function Le(t){t!==ie&&(fe&&e.lineWidth(t),ie=t)}function Pe(t,n,r){t?(ye(e.POLYGON_OFFSET_FILL),se===n&&le===r||(e.polygonOffset(n,r),se=n,le=r)):Ee(e.POLYGON_OFFSET_FILL)}function ke(t){t?ye(e.SCISSOR_TEST):Ee(e.SCISSOR_TEST)}function Ne(t){void 0===t&&(t=e.TEXTURE0+ce-1),pe!==t&&(e.activeTexture(t),pe=t)}function He(t,n){null===pe&&Ne();let r=he[pe];void 0===r&&(r={type:void 0,texture:void 0},he[pe]=r),r.type===t&&r.texture===n||(e.bindTexture(t,n||ge[t]),r.type=t,r.texture=n)}function ze(){const t=he[pe];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)}function De(){try{e.compressedTexImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function Fe(){try{e.texImage2D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function Ie(){try{e.texImage3D.apply(e,arguments)}catch(e){console.error("THREE.WebGLState:",e)}}function Oe(t){!1===ve.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),ve.copy(t))}function Ue(t){!1===me.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),me.copy(t))}function Ge(){e.disable(e.BLEND),e.disable(e.CULL_FACE),e.disable(e.DEPTH_TEST),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SCISSOR_TEST),e.disable(e.STENCIL_TEST),e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),e.blendEquation(e.FUNC_ADD),e.blendFunc(e.ONE,e.ZERO),e.blendFuncSeparate(e.ONE,e.ZERO,e.ONE,e.ZERO),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(e.LESS),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(e.ALWAYS,0,4294967295),e.stencilOp(e.KEEP,e.KEEP,e.KEEP),e.clearStencil(0),e.cullFace(e.BACK),e.frontFace(e.CCW),e.polygonOffset(0,0),e.activeTexture(e.TEXTURE0),e.bindFramebuffer(e.FRAMEBUFFER,null),!0===r&&(e.bindFramebuffer(e.DRAW_FRAMEBUFFER,null),e.bindFramebuffer(e.READ_FRAMEBUFFER,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),v={},pe=null,he={},m=null,X={},Y=null,Q=!1,K=null,Z=null,J=null,$=null,ee=null,te=null,ne=null,re=!1,oe=null,ae=null,ie=null,se=null,le=null,ve.set(0,0,e.canvas.width,e.canvas.height),me.set(0,0,e.canvas.width,e.canvas.height),f.reset(),u.reset(),d.reset()}return{buffers:{color:f,depth:u,stencil:d},enable:ye,disable:Ee,bindFramebuffer:be,bindXRFramebuffer:we,useProgram:_e,setBlending:Se,setMaterial:Re,setFlipSided:Me,setCullFace:Ce,setLineWidth:Le,setPolygonOffset:Pe,setScissorTest:ke,activeTexture:Ne,bindTexture:He,unbindTexture:ze,compressedTexImage2D:De,texImage2D:Fe,texImage3D:Ie,scissor:Oe,viewport:Ue,reset:Ge}}function yl(e,t,n,r,o,a,i){const s=o.isWebGL2,l=o.maxTextures,c=o.maxCubemapSize,f=o.maxTextureSize,u=o.maxSamples,d=new WeakMap;let p,h=!1;try{h="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(e){}function v(e,t){return h?new OffscreenCanvas(e,t):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function m(e,t,n,r){let o=1;if((e.width>r||e.height>r)&&(o=r/Math.max(e.width,e.height)),o<1||!0===t){if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap){const r=t?rr:Math.floor,a=r(o*e.width),i=r(o*e.height);void 0===p&&(p=v(a,i));const s=n?v(a,i):p;return s.width=a,s.height=i,s.getContext("2d").drawImage(e,0,0,a,i),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+a+"x"+i+")."),s}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function x(e){return tr(e.width)&&tr(e.height)}function g(e){return!s&&(e.wrapS!==fe||e.wrapT!==fe||e.minFilter!==de&&e.minFilter!==xe)}function y(e,t){return e.generateMipmaps&&t&&e.minFilter!==de&&e.minFilter!==xe}function E(t,n,o,a){e.generateMipmap(t),r.get(n).__maxMipLevel=Math.log2(Math.max(o,a))}function w(n,r,o){if(!1===s)return r;if(null!==n){if(void 0!==e[n])return e[n];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+n+"'")}let a=r;return r===e.RED&&(o===e.FLOAT&&(a=e.R32F),o===e.HALF_FLOAT&&(a=e.R16F),o===e.UNSIGNED_BYTE&&(a=e.R8)),r===e.RGB&&(o===e.FLOAT&&(a=e.RGB32F),o===e.HALF_FLOAT&&(a=e.RGB16F),o===e.UNSIGNED_BYTE&&(a=e.RGB8)),r===e.RGBA&&(o===e.FLOAT&&(a=e.RGBA32F),o===e.HALF_FLOAT&&(a=e.RGBA16F),o===e.UNSIGNED_BYTE&&(a=e.RGBA8)),a!==e.R16F&&a!==e.R32F&&a!==e.RGBA16F&&a!==e.RGBA32F||t.get("EXT_color_buffer_float"),a}function b(t){return t===de||t===pe||t===ve?e.NEAREST:e.LINEAR}function _(e){const t=e.target;t.removeEventListener("dispose",_),A(t),t.isVideoTexture&&d.delete(t),i.memory.textures--}function T(e){const t=e.target;t.removeEventListener("dispose",T),S(t),i.memory.textures--}function A(t){const n=r.get(t);void 0!==n.__webglInit&&(e.deleteTexture(n.__webglTexture),r.remove(t))}function S(t){const n=t.texture,o=r.get(t),a=r.get(n);if(t){if(void 0!==a.__webglTexture&&e.deleteTexture(a.__webglTexture),t.depthTexture&&t.depthTexture.dispose(),t.isWebGLCubeRenderTarget)for(let t=0;t<6;t++)e.deleteFramebuffer(o.__webglFramebuffer[t]),o.__webglDepthbuffer&&e.deleteRenderbuffer(o.__webglDepthbuffer[t]);else e.deleteFramebuffer(o.__webglFramebuffer),o.__webglDepthbuffer&&e.deleteRenderbuffer(o.__webglDepthbuffer),o.__webglMultisampledFramebuffer&&e.deleteFramebuffer(o.__webglMultisampledFramebuffer),o.__webglColorRenderbuffer&&e.deleteRenderbuffer(o.__webglColorRenderbuffer),o.__webglDepthRenderbuffer&&e.deleteRenderbuffer(o.__webglDepthRenderbuffer);r.remove(n),r.remove(t)}}let R=0;function M(){R=0}function C(){const e=R;return e>=l&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+l),R+=1,e}function L(t,o){const a=r.get(t);if(t.isVideoTexture&&Y(t),t.version>0&&a.__version!==t.version){const e=t.image;if(void 0===e)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else{if(!1!==e.complete)return void I(a,t,o);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}n.activeTexture(e.TEXTURE0+o),n.bindTexture(e.TEXTURE_2D,a.__webglTexture)}function P(t,o){const a=r.get(t);t.version>0&&a.__version!==t.version?I(a,t,o):(n.activeTexture(e.TEXTURE0+o),n.bindTexture(e.TEXTURE_2D_ARRAY,a.__webglTexture))}function k(t,o){const a=r.get(t);t.version>0&&a.__version!==t.version?I(a,t,o):(n.activeTexture(e.TEXTURE0+o),n.bindTexture(e.TEXTURE_3D,a.__webglTexture))}function N(t,o){const a=r.get(t);t.version>0&&a.__version!==t.version?O(a,t,o):(n.activeTexture(e.TEXTURE0+o),n.bindTexture(e.TEXTURE_CUBE_MAP,a.__webglTexture))}const H={[ce]:e.REPEAT,[fe]:e.CLAMP_TO_EDGE,[ue]:e.MIRRORED_REPEAT},z={[de]:e.NEAREST,[pe]:e.NEAREST_MIPMAP_NEAREST,[ve]:e.NEAREST_MIPMAP_LINEAR,[xe]:e.LINEAR,[ge]:e.LINEAR_MIPMAP_NEAREST,[Ee]:e.LINEAR_MIPMAP_LINEAR};function D(n,a,i){if(i?(e.texParameteri(n,e.TEXTURE_WRAP_S,H[a.wrapS]),e.texParameteri(n,e.TEXTURE_WRAP_T,H[a.wrapT]),n!==e.TEXTURE_3D&&n!==e.TEXTURE_2D_ARRAY||e.texParameteri(n,e.TEXTURE_WRAP_R,H[a.wrapR]),e.texParameteri(n,e.TEXTURE_MAG_FILTER,z[a.magFilter]),e.texParameteri(n,e.TEXTURE_MIN_FILTER,z[a.minFilter])):(e.texParameteri(n,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(n,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),n!==e.TEXTURE_3D&&n!==e.TEXTURE_2D_ARRAY||e.texParameteri(n,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),a.wrapS===fe&&a.wrapT===fe||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(n,e.TEXTURE_MAG_FILTER,b(a.magFilter)),e.texParameteri(n,e.TEXTURE_MIN_FILTER,b(a.minFilter)),a.minFilter!==de&&a.minFilter!==xe&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const i=t.get("EXT_texture_filter_anisotropic");if(a.type===Me&&!1===t.has("OES_texture_float_linear"))return;if(!1===s&&a.type===Ce&&!1===t.has("OES_texture_half_float_linear"))return;(a.anisotropy>1||r.get(a).__currentAnisotropy)&&(e.texParameterf(n,i.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(a.anisotropy,o.getMaxAnisotropy())),r.get(a).__currentAnisotropy=a.anisotropy)}}function F(t,n){void 0===t.__webglInit&&(t.__webglInit=!0,n.addEventListener("dispose",_),t.__webglTexture=e.createTexture(),i.memory.textures++)}function I(t,r,o){let i=e.TEXTURE_2D;r.isDataTexture2DArray&&(i=e.TEXTURE_2D_ARRAY),r.isDataTexture3D&&(i=e.TEXTURE_3D),F(t,r),n.activeTexture(e.TEXTURE0+o),n.bindTexture(i,t.__webglTexture),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,r.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE);const l=g(r)&&!1===x(r.image),c=m(r.image,l,!1,f),u=x(c)||s,d=a.convert(r.format);let p,h=a.convert(r.type),v=w(r.internalFormat,d,h);D(i,r,u);const b=r.mipmaps;if(r.isDepthTexture)v=e.DEPTH_COMPONENT,s?v=r.type===Me?e.DEPTH_COMPONENT32F:r.type===Re?e.DEPTH_COMPONENT24:r.type===Ne?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT16:r.type===Me&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Ue&&v===e.DEPTH_COMPONENT&&r.type!==Ae&&r.type!==Re&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Ae,h=a.convert(r.type)),r.format===Ge&&v===e.DEPTH_COMPONENT&&(v=e.DEPTH_STENCIL,r.type!==Ne&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=Ne,h=a.convert(r.type))),n.texImage2D(e.TEXTURE_2D,0,v,c.width,c.height,0,d,h,null);else if(r.isDataTexture)if(b.length>0&&u){for(let t=0,r=b.length;t<r;t++)p=b[t],n.texImage2D(e.TEXTURE_2D,t,v,p.width,p.height,0,d,h,p.data);r.generateMipmaps=!1,t.__maxMipLevel=b.length-1}else n.texImage2D(e.TEXTURE_2D,0,v,c.width,c.height,0,d,h,c.data),t.__maxMipLevel=0;else if(r.isCompressedTexture){for(let t=0,o=b.length;t<o;t++)p=b[t],r.format!==De&&r.format!==ze?null!==d?n.compressedTexImage2D(e.TEXTURE_2D,t,v,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(e.TEXTURE_2D,t,v,p.width,p.height,0,d,h,p.data);t.__maxMipLevel=b.length-1}else if(r.isDataTexture2DArray)n.texImage3D(e.TEXTURE_2D_ARRAY,0,v,c.width,c.height,c.depth,0,d,h,c.data),t.__maxMipLevel=0;else if(r.isDataTexture3D)n.texImage3D(e.TEXTURE_3D,0,v,c.width,c.height,c.depth,0,d,h,c.data),t.__maxMipLevel=0;else if(b.length>0&&u){for(let t=0,r=b.length;t<r;t++)p=b[t],n.texImage2D(e.TEXTURE_2D,t,v,d,h,p);r.generateMipmaps=!1,t.__maxMipLevel=b.length-1}else n.texImage2D(e.TEXTURE_2D,0,v,d,h,c),t.__maxMipLevel=0;y(r,u)&&E(i,r,c.width,c.height),t.__version=r.version,r.onUpdate&&r.onUpdate(r)}function O(t,r,o){if(6!==r.image.length)return;F(t,r),n.activeTexture(e.TEXTURE0+o),n.bindTexture(e.TEXTURE_CUBE_MAP,t.__webglTexture),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r.flipY),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),e.pixelStorei(e.UNPACK_ALIGNMENT,r.unpackAlignment),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE);const i=r&&(r.isCompressedTexture||r.image[0].isCompressedTexture),l=r.image[0]&&r.image[0].isDataTexture,f=[];for(let e=0;e<6;e++)f[e]=i||l?l?r.image[e].image:r.image[e]:m(r.image[e],!1,!0,c);const u=f[0],d=x(u)||s,p=a.convert(r.format),h=a.convert(r.type),v=w(r.internalFormat,p,h);let g;if(D(e.TEXTURE_CUBE_MAP,r,d),i){for(let t=0;t<6;t++){g=f[t].mipmaps;for(let o=0;o<g.length;o++){const a=g[o];r.format!==De&&r.format!==ze?null!==p?n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,o,v,a.width,a.height,0,a.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,o,v,a.width,a.height,0,p,h,a.data)}}t.__maxMipLevel=g.length-1}else{g=r.mipmaps;for(let t=0;t<6;t++)if(l){n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,v,f[t].width,f[t].height,0,p,h,f[t].data);for(let r=0;r<g.length;r++){const o=g[r].image[t].image;n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,v,o.width,o.height,0,p,h,o.data)}}else{n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,v,p,h,f[t]);for(let r=0;r<g.length;r++){const o=g[r];n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,r+1,v,p,h,o.image[t])}}t.__maxMipLevel=g.length}y(r,d)&&E(e.TEXTURE_CUBE_MAP,r,u.width,u.height),t.__version=r.version,r.onUpdate&&r.onUpdate(r)}function U(t,o,i,s){const l=o.texture,c=a.convert(l.format),f=a.convert(l.type),u=w(l.internalFormat,c,f);s===e.TEXTURE_3D||s===e.TEXTURE_2D_ARRAY?n.texImage3D(s,0,u,o.width,o.height,o.depth,0,c,f,null):n.texImage2D(s,0,u,o.width,o.height,0,c,f,null),n.bindFramebuffer(e.FRAMEBUFFER,t),e.framebufferTexture2D(e.FRAMEBUFFER,i,s,r.get(l).__webglTexture,0),n.bindFramebuffer(e.FRAMEBUFFER,null)}function G(t,n,r){if(e.bindRenderbuffer(e.RENDERBUFFER,t),n.depthBuffer&&!n.stencilBuffer){let o=e.DEPTH_COMPONENT16;if(r){const t=n.depthTexture;t&&t.isDepthTexture&&(t.type===Me?o=e.DEPTH_COMPONENT32F:t.type===Re&&(o=e.DEPTH_COMPONENT24));const r=X(n);e.renderbufferStorageMultisample(e.RENDERBUFFER,r,o,n.width,n.height)}else e.renderbufferStorage(e.RENDERBUFFER,o,n.width,n.height);e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,t)}else if(n.depthBuffer&&n.stencilBuffer){if(r){const t=X(n);e.renderbufferStorageMultisample(e.RENDERBUFFER,t,e.DEPTH24_STENCIL8,n.width,n.height)}else e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,n.width,n.height);e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,t)}else{const t=n.texture,o=a.convert(t.format),i=a.convert(t.type),s=w(t.internalFormat,o,i);if(r){const t=X(n);e.renderbufferStorageMultisample(e.RENDERBUFFER,t,s,n.width,n.height)}else e.renderbufferStorage(e.RENDERBUFFER,s,n.width,n.height)}e.bindRenderbuffer(e.RENDERBUFFER,null)}function B(t,o){if(o&&o.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(e.FRAMEBUFFER,t),!o.depthTexture||!o.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(o.depthTexture).__webglTexture&&o.depthTexture.image.width===o.width&&o.depthTexture.image.height===o.height||(o.depthTexture.image.width=o.width,o.depthTexture.image.height=o.height,o.depthTexture.needsUpdate=!0),L(o.depthTexture,0);const a=r.get(o.depthTexture).__webglTexture;if(o.depthTexture.format===Ue)e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,a,0);else{if(o.depthTexture.format!==Ge)throw new Error("Unknown depthTexture format");e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,a,0)}}function V(t){const o=r.get(t),a=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture){if(a)throw new Error("target.depthTexture not supported in Cube render targets");B(o.__webglFramebuffer,t)}else if(a){o.__webglDepthbuffer=[];for(let r=0;r<6;r++)n.bindFramebuffer(e.FRAMEBUFFER,o.__webglFramebuffer[r]),o.__webglDepthbuffer[r]=e.createRenderbuffer(),G(o.__webglDepthbuffer[r],t,!1)}else n.bindFramebuffer(e.FRAMEBUFFER,o.__webglFramebuffer),o.__webglDepthbuffer=e.createRenderbuffer(),G(o.__webglDepthbuffer,t,!1);n.bindFramebuffer(e.FRAMEBUFFER,null)}function W(t){const o=t.texture,l=r.get(t),c=r.get(o);t.addEventListener("dispose",T),c.__webglTexture=e.createTexture(),c.__version=o.version,i.memory.textures++;const f=!0===t.isWebGLCubeRenderTarget,u=!0===t.isWebGLMultisampleRenderTarget,d=o.isDataTexture3D||o.isDataTexture2DArray,p=x(t)||s;if(!s||o.format!==ze||o.type!==Me&&o.type!==Ce||(o.format=De,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),f){l.__webglFramebuffer=[];for(let t=0;t<6;t++)l.__webglFramebuffer[t]=e.createFramebuffer()}else if(l.__webglFramebuffer=e.createFramebuffer(),u)if(s){l.__webglMultisampledFramebuffer=e.createFramebuffer(),l.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,l.__webglColorRenderbuffer);const r=a.convert(o.format),i=a.convert(o.type),s=w(o.internalFormat,r,i),c=X(t);e.renderbufferStorageMultisample(e.RENDERBUFFER,c,s,t.width,t.height),n.bindFramebuffer(e.FRAMEBUFFER,l.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,l.__webglColorRenderbuffer),e.bindRenderbuffer(e.RENDERBUFFER,null),t.depthBuffer&&(l.__webglDepthRenderbuffer=e.createRenderbuffer(),G(l.__webglDepthRenderbuffer,t,!0)),n.bindFramebuffer(e.FRAMEBUFFER,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(f){n.bindTexture(e.TEXTURE_CUBE_MAP,c.__webglTexture),D(e.TEXTURE_CUBE_MAP,o,p);for(let n=0;n<6;n++)U(l.__webglFramebuffer[n],t,e.COLOR_ATTACHMENT0,e.TEXTURE_CUBE_MAP_POSITIVE_X+n);y(o,p)&&E(e.TEXTURE_CUBE_MAP,o,t.width,t.height),n.bindTexture(e.TEXTURE_CUBE_MAP,null)}else{let r=e.TEXTURE_2D;d&&(s?r=o.isDataTexture3D?e.TEXTURE_3D:e.TEXTURE_2D_ARRAY:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),n.bindTexture(r,c.__webglTexture),D(r,o,p),U(l.__webglFramebuffer,t,e.COLOR_ATTACHMENT0,r),y(o,p)&&E(e.TEXTURE_2D,o,t.width,t.height),n.bindTexture(e.TEXTURE_2D,null)}t.depthBuffer&&V(t)}function j(t){const o=t.texture;if(y(o,x(t)||s)){const a=t.isWebGLCubeRenderTarget?e.TEXTURE_CUBE_MAP:e.TEXTURE_2D,i=r.get(o).__webglTexture;n.bindTexture(a,i),E(a,o,t.width,t.height),n.bindTexture(a,null)}}function q(t){if(t.isWebGLMultisampleRenderTarget)if(s){const o=t.width,a=t.height;let i=e.COLOR_BUFFER_BIT;t.depthBuffer&&(i|=e.DEPTH_BUFFER_BIT),t.stencilBuffer&&(i|=e.STENCIL_BUFFER_BIT);const s=r.get(t);n.bindFramebuffer(e.READ_FRAMEBUFFER,s.__webglMultisampledFramebuffer),n.bindFramebuffer(e.DRAW_FRAMEBUFFER,s.__webglFramebuffer),e.blitFramebuffer(0,0,o,a,0,0,o,a,i,e.NEAREST),n.bindFramebuffer(e.READ_FRAMEBUFFER,null),n.bindFramebuffer(e.DRAW_FRAMEBUFFER,s.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function X(e){return s&&e.isWebGLMultisampleRenderTarget?Math.min(u,e.samples):0}function Y(e){const t=i.render.frame;d.get(e)!==t&&(d.set(e,t),e.update())}let Q=!1,K=!1;function Z(e,t){e&&e.isWebGLRenderTarget&&(!1===Q&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Q=!0),e=e.texture),L(e,t)}function J(e,t){e&&e.isWebGLCubeRenderTarget&&(!1===K&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),K=!0),e=e.texture),N(e,t)}this.allocateTextureUnit=C,this.resetTextureUnits=M,this.setTexture2D=L,this.setTexture2DArray=P,this.setTexture3D=k,this.setTextureCube=N,this.setupRenderTarget=W,this.updateRenderTargetMipmap=j,this.updateMultisampleRenderTarget=q,this.safeSetTexture2D=Z,this.safeSetTextureCube=J}function El(e,t,n){const r=n.isWebGL2;function o(n){let o;if(n===be)return e.UNSIGNED_BYTE;if(n===Le)return e.UNSIGNED_SHORT_4_4_4_4;if(n===Pe)return e.UNSIGNED_SHORT_5_5_5_1;if(n===ke)return e.UNSIGNED_SHORT_5_6_5;if(n===_e)return e.BYTE;if(n===Te)return e.SHORT;if(n===Ae)return e.UNSIGNED_SHORT;if(n===Se)return e.INT;if(n===Re)return e.UNSIGNED_INT;if(n===Me)return e.FLOAT;if(n===Ce)return r?e.HALF_FLOAT:(o=t.get("OES_texture_half_float"),null!==o?o.HALF_FLOAT_OES:null);if(n===He)return e.ALPHA;if(n===ze)return e.RGB;if(n===De)return e.RGBA;if(n===Fe)return e.LUMINANCE;if(n===Ie)return e.LUMINANCE_ALPHA;if(n===Ue)return e.DEPTH_COMPONENT;if(n===Ge)return e.DEPTH_STENCIL;if(n===Be)return e.RED;if(n===Ve)return e.RED_INTEGER;if(n===We)return e.RG;if(n===je)return e.RG_INTEGER;if(n===qe)return e.RGB_INTEGER;if(n===Xe)return e.RGBA_INTEGER;if(n===Ye||n===Qe||n===Ke||n===Ze){if(o=t.get("WEBGL_compressed_texture_s3tc"),null===o)return null;if(n===Ye)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===Qe)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===Ke)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===Ze)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(n===Je||n===$e||n===et||n===tt){if(o=t.get("WEBGL_compressed_texture_pvrtc"),null===o)return null;if(n===Je)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===$e)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===et)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===tt)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(n===nt)return o=t.get("WEBGL_compressed_texture_etc1"),null!==o?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((n===rt||n===ot)&&(o=t.get("WEBGL_compressed_texture_etc"),null!==o)){if(n===rt)return o.COMPRESSED_RGB8_ETC2;if(n===ot)return o.COMPRESSED_RGBA8_ETC2_EAC}return n===at||n===it||n===st||n===lt||n===ct||n===ft||n===ut||n===dt||n===pt||n===ht||n===vt||n===mt||n===xt||n===gt||n===Et||n===wt||n===bt||n===_t||n===Tt||n===At||n===St||n===Rt||n===Mt||n===Ct||n===Lt||n===Pt||n===kt||n===Nt?(o=t.get("WEBGL_compressed_texture_astc"),null!==o?n:null):n===yt?(o=t.get("EXT_texture_compression_bptc"),null!==o?n:null):n===Ne?r?e.UNSIGNED_INT_24_8:(o=t.get("WEBGL_depth_texture"),null!==o?o.UNSIGNED_INT_24_8_WEBGL:null):void 0}return{convert:o}}class wl extends Wa{constructor(e=[]){super(),this.cameras=e}}wl.prototype.isArrayCamera=!0;class bl extends Eo{constructor(){super(),this.type="Group"}}bl.prototype.isGroup=!0;const _l={type:"move"};class Tl{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new bl,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new bl,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new xr,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new xr),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new bl,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new xr,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new xr),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,n){let r=null,o=null,a=null;const i=this._targetRay,s=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState)if(null!==i&&(r=t.getPose(e.targetRaySpace,n),null!==r&&(i.matrix.fromArray(r.transform.matrix),i.matrix.decompose(i.position,i.rotation,i.scale),r.linearVelocity?(i.hasLinearVelocity=!0,i.linearVelocity.copy(r.linearVelocity)):i.hasLinearVelocity=!1,r.angularVelocity?(i.hasAngularVelocity=!0,i.angularVelocity.copy(r.angularVelocity)):i.hasAngularVelocity=!1,this.dispatchEvent(_l))),l&&e.hand){a=!0;for(const r of e.hand.values()){const e=t.getJointPose(r,n);if(void 0===l.joints[r.jointName]){const e=new bl;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[r.jointName]=e,l.add(e)}const o=l.joints[r.jointName];null!==e&&(o.matrix.fromArray(e.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.jointRadius=e.radius),o.visible=null!==e}const r=l.joints["index-finger-tip"],o=l.joints["thumb-tip"],i=r.position.distanceTo(o.position),s=.02,c=.005;l.inputState.pinching&&i>s+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&i<=s-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==s&&e.gripSpace&&(o=t.getPose(e.gripSpace,n),null!==o&&(s.matrix.fromArray(o.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),o.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(o.linearVelocity)):s.hasLinearVelocity=!1,o.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(o.angularVelocity)):s.hasAngularVelocity=!1));return null!==i&&(i.visible=null!==r),null!==s&&(s.visible=null!==o),null!==l&&(l.visible=null!==a),this}}class Al extends Hn{constructor(e,t){super();const n=this,r=e.state;let o=null,a=1,i=null,s="local-floor",l=null;const c=[],f=new Map,u=new Wa;u.layers.enable(1),u.viewport=new pr;const d=new Wa;d.layers.enable(2),d.viewport=new pr;const p=[u,d],h=new wl;h.layers.enable(1),h.layers.enable(2);let v=null,m=null;function x(e){const t=f.get(e.inputSource);t&&t.dispatchEvent({type:e.type,data:e.inputSource})}function g(){f.forEach((function(e,t){e.disconnect(t)})),f.clear(),v=null,m=null,r.bindXRFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),S.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function y(e){const t=o.inputSources;for(let e=0;e<c.length;e++)f.set(t[e],c[e]);for(let t=0;t<e.removed.length;t++){const n=e.removed[t],r=f.get(n);r&&(r.dispatchEvent({type:"disconnected",data:n}),f.delete(n))}for(let t=0;t<e.added.length;t++){const n=e.added[t],r=f.get(n);r&&r.dispatchEvent({type:"connected",data:n})}}this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=c[e];return void 0===t&&(t=new Tl,c[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=c[e];return void 0===t&&(t=new Tl,c[e]=t),t.getGripSpace()},this.getHand=function(e){let t=c[e];return void 0===t&&(t=new Tl,c[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){a=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){s=e,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return i},this.getSession=function(){return o},this.setSession=async function(e){if(o=e,null!==o){o.addEventListener("select",x),o.addEventListener("selectstart",x),o.addEventListener("selectend",x),o.addEventListener("squeeze",x),o.addEventListener("squeezestart",x),o.addEventListener("squeezeend",x),o.addEventListener("end",g),o.addEventListener("inputsourceschange",y);const e=t.getContextAttributes();!0!==e.xrCompatible&&await t.makeXRCompatible();const r={antialias:e.antialias,alpha:e.alpha,depth:e.depth,stencil:e.stencil,framebufferScaleFactor:a},l=new XRWebGLLayer(o,t,r);o.updateRenderState({baseLayer:l}),i=await o.requestReferenceSpace(s),S.setContext(o),S.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};const E=new xr,w=new xr;function b(e,t,n){E.setFromMatrixPosition(t.matrixWorld),w.setFromMatrixPosition(n.matrixWorld);const r=E.distanceTo(w),o=t.projectionMatrix.elements,a=n.projectionMatrix.elements,i=o[14]/(o[10]-1),s=o[14]/(o[10]+1),l=(o[9]+1)/o[5],c=(o[9]-1)/o[5],f=(o[8]-1)/o[0],u=(a[8]+1)/a[0],d=i*f,p=i*u,h=r/(-f+u),v=h*-f;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(v),e.translateZ(h),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const m=i+h,x=s+h,g=d-v,y=p+(r-v),b=l*s/x*m,_=c*s/x*m;e.projectionMatrix.makePerspective(g,y,b,_,m,x)}function _(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.getCamera=function(e){h.near=d.near=u.near=e.near,h.far=d.far=u.far=e.far,v===h.near&&m===h.far||(o.updateRenderState({depthNear:h.near,depthFar:h.far}),v=h.near,m=h.far);const t=e.parent,n=h.cameras;_(h,t);for(let e=0;e<n.length;e++)_(n[e],t);e.matrixWorld.copy(h.matrixWorld),e.matrix.copy(h.matrix),e.matrix.decompose(e.position,e.quaternion,e.scale);const r=e.children;for(let e=0,t=r.length;e<t;e++)r[e].updateMatrixWorld(!0);return 2===n.length?b(h,u,d):h.projectionMatrix.copy(u.projectionMatrix),h};let T=null;function A(e,t){if(l=t.getViewerPose(i),null!==l){const e=l.views,t=o.renderState.baseLayer;r.bindXRFramebuffer(t.framebuffer);let n=!1;e.length!==h.cameras.length&&(h.cameras.length=0,n=!0);for(let r=0;r<e.length;r++){const o=e[r],a=t.getViewport(o),i=p[r];i.matrix.fromArray(o.transform.matrix),i.projectionMatrix.fromArray(o.projectionMatrix),i.viewport.set(a.x,a.y,a.width,a.height),0===r&&h.matrix.copy(i.matrix),!0===n&&h.cameras.push(i)}}const n=o.inputSources;for(let e=0;e<c.length;e++){const r=c[e],o=n[e];r.update(o,t,i)}T&&T(e,t)}const S=new ei;S.setAnimationLoop(A),this.setAnimationLoop=function(e){T=e},this.dispose=function(){}}}function Sl(e){function t(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)}function n(e,t,n,p){t.isMeshBasicMaterial?r(e,t):t.isMeshLambertMaterial?(r(e,t),l(e,t)):t.isMeshToonMaterial?(r(e,t),f(e,t)):t.isMeshPhongMaterial?(r(e,t),c(e,t)):t.isMeshStandardMaterial?(r(e,t),t.isMeshPhysicalMaterial?d(e,t):u(e,t)):t.isMeshMatcapMaterial?(r(e,t),h(e,t)):t.isMeshDepthMaterial?(r(e,t),v(e,t)):t.isMeshDistanceMaterial?(r(e,t),m(e,t)):t.isMeshNormalMaterial?(r(e,t),x(e,t)):t.isLineBasicMaterial?(o(e,t),t.isLineDashedMaterial&&a(e,t)):t.isPointsMaterial?i(e,t,n,p):t.isSpriteMaterial?s(e,t):t.isShadowMaterial?(e.color.value.copy(t.color),e.opacity.value=t.opacity):t.isShaderMaterial&&(t.uniformsNeedUpdate=!1)}function r(t,n){t.opacity.value=n.opacity,n.color&&t.diffuse.value.copy(n.color),n.emissive&&t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),n.map&&(t.map.value=n.map),n.alphaMap&&(t.alphaMap.value=n.alphaMap),n.specularMap&&(t.specularMap.value=n.specularMap);const r=e.get(n).envMap;if(r){t.envMap.value=r,t.flipEnvMap.value=r.isCubeTexture&&r._needsFlipEnvMap?-1:1,t.reflectivity.value=n.reflectivity,t.refractionRatio.value=n.refractionRatio;const o=e.get(r).__maxMipLevel;void 0!==o&&(t.maxMipLevel.value=o)}let o,a;n.lightMap&&(t.lightMap.value=n.lightMap,t.lightMapIntensity.value=n.lightMapIntensity),n.aoMap&&(t.aoMap.value=n.aoMap,t.aoMapIntensity.value=n.aoMapIntensity),n.map?o=n.map:n.specularMap?o=n.specularMap:n.displacementMap?o=n.displacementMap:n.normalMap?o=n.normalMap:n.bumpMap?o=n.bumpMap:n.roughnessMap?o=n.roughnessMap:n.metalnessMap?o=n.metalnessMap:n.alphaMap?o=n.alphaMap:n.emissiveMap?o=n.emissiveMap:n.clearcoatMap?o=n.clearcoatMap:n.clearcoatNormalMap?o=n.clearcoatNormalMap:n.clearcoatRoughnessMap&&(o=n.clearcoatRoughnessMap),void 0!==o&&(o.isWebGLRenderTarget&&(o=o.texture),!0===o.matrixAutoUpdate&&o.updateMatrix(),t.uvTransform.value.copy(o.matrix)),n.aoMap?a=n.aoMap:n.lightMap&&(a=n.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),t.uv2Transform.value.copy(a.matrix))}function o(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}function a(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}function i(e,t,n,r){let o;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*n,e.scale.value=.5*r,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?o=t.map:t.alphaMap&&(o=t.alphaMap),void 0!==o&&(!0===o.matrixAutoUpdate&&o.updateMatrix(),e.uvTransform.value.copy(o.matrix))}function s(e,t){let n;e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map),t.alphaMap&&(e.alphaMap.value=t.alphaMap),t.map?n=t.map:t.alphaMap&&(n=t.alphaMap),void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}function l(e,t){t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap)}function c(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===p&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===p&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function f(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap),t.emissiveMap&&(e.emissiveMap.value=t.emissiveMap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===p&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===p&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function u(t,n){t.roughness.value=n.roughness,t.metalness.value=n.metalness,n.roughnessMap&&(t.roughnessMap.value=n.roughnessMap),n.metalnessMap&&(t.metalnessMap.value=n.metalnessMap),n.emissiveMap&&(t.emissiveMap.value=n.emissiveMap),n.bumpMap&&(t.bumpMap.value=n.bumpMap,t.bumpScale.value=n.bumpScale,n.side===p&&(t.bumpScale.value*=-1)),n.normalMap&&(t.normalMap.value=n.normalMap,t.normalScale.value.copy(n.normalScale),n.side===p&&t.normalScale.value.negate()),n.displacementMap&&(t.displacementMap.value=n.displacementMap,t.displacementScale.value=n.displacementScale,t.displacementBias.value=n.displacementBias),e.get(n).envMap&&(t.envMapIntensity.value=n.envMapIntensity)}function d(e,t){u(e,t),e.reflectivity.value=t.reflectivity,e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.sheen&&e.sheen.value.copy(t.sheen),t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,t.side===p&&e.clearcoatNormalScale.value.negate()),e.transmission.value=t.transmission,t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap)}function h(e,t){t.matcap&&(e.matcap.value=t.matcap),t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===p&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===p&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function v(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}function m(e,t){t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias),e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}function x(e,t){t.bumpMap&&(e.bumpMap.value=t.bumpMap,e.bumpScale.value=t.bumpScale,t.side===p&&(e.bumpScale.value*=-1)),t.normalMap&&(e.normalMap.value=t.normalMap,e.normalScale.value.copy(t.normalScale),t.side===p&&e.normalScale.value.negate()),t.displacementMap&&(e.displacementMap.value=t.displacementMap,e.displacementScale.value=t.displacementScale,e.displacementBias.value=t.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function Rl(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}function Ml(e){const t=void 0!==(e=e||{}).canvas?e.canvas:Rl(),n=void 0!==e.context?e.context:null,r=void 0!==e.alpha&&e.alpha,o=void 0===e.depth||e.depth,a=void 0===e.stencil||e.stencil,i=void 0!==e.antialias&&e.antialias,s=void 0===e.premultipliedAlpha||e.premultipliedAlpha,l=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,c=void 0!==e.powerPreference?e.powerPreference:"default",f=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u=null,d=null;const p=[],h=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Yt,this.physicallyCorrectLights=!1,this.toneMapping=K,this.toneMappingExposure=1;const v=this;let m=!1,x=0,g=0,y=null,E=-1,w=null;const b=new pr,_=new pr;let T=null,A=t.width,S=t.height,R=1,M=null,C=null;const L=new pr(0,0,A,S),P=new pr(0,0,A,S);let k=!1;const N=new $a;let H=!1,z=!1;const D=new Yr,F=new xr,I={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function O(){return null===y?R:1}let U,G,B,V,W,j,q,X,Y,Q,Z,J,$,ee,te,ne,re,oe,ae,ie,se,le,ce=n;function fe(e,n){for(let r=0;r<e.length;r++){const o=e[r],a=t.getContext(o,n);if(null!==a)return a}return null}try{const e={alpha:r,depth:o,stencil:a,antialias:i,premultipliedAlpha:s,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:f};if(t.addEventListener("webglcontextlost",pe,!1),t.addEventListener("webglcontextrestored",he,!1),null===ce){const t=["webgl2","webgl","experimental-webgl"];if(!0===v.isWebGL1Renderer&&t.shift(),ce=fe(t,e),null===ce)throw fe(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ce.getShaderPrecisionFormat&&(ce.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(e){throw console.error("THREE.WebGLRenderer: "+e.message),e}function ue(){U=new di(ce),G=new ci(ce,U,e),U.init(G),se=new El(ce,U,G),B=new gl(ce,U,G),V=new vi(ce),W=new tl,j=new yl(ce,U,B,W,G,se,V),q=new ui(v),X=new ti(ce,G),le=new si(ce,U,X,G),Y=new pi(ce,X,V,le),Q=new yi(ce,Y,X,V),oe=new gi(ce),te=new fi(W),Z=new el(v,q,U,G,le,te),J=new Sl(W),$=new al(W),ee=new dl(U,G),re=new ii(v,q,B,Q,s),ne=new xl(v,Q,G),ae=new li(ce,U,V,G),ie=new hi(ce,U,V,G),V.programs=Z.programs,v.capabilities=G,v.extensions=U,v.properties=W,v.renderLists=$,v.shadowMap=ne,v.state=B,v.info=V}ue();const de=new Al(v,ce);function pe(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),m=!0}function he(){console.log("THREE.WebGLRenderer: Context Restored."),m=!1;const e=V.autoReset,t=ne.enabled,n=ne.autoUpdate,r=ne.needsUpdate,o=ne.type;ue(),V.autoReset=e,ne.enabled=t,ne.autoUpdate=n,ne.needsUpdate=r,ne.type=o}function ve(e){const t=e.target;t.removeEventListener("dispose",ve),me(t)}function me(e){xe(e),W.remove(e)}function xe(e){const t=W.get(e).programs;void 0!==t&&t.forEach((function(e){Z.releaseProgram(e)}))}function ge(e,t){e.render((function(e){v.renderBufferImmediate(e,t)}))}this.xr=de,this.getContext=function(){return ce},this.getContextAttributes=function(){return ce.getContextAttributes()},this.forceContextLoss=function(){const e=U.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=U.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(e){void 0!==e&&(R=e,this.setSize(A,S,!1))},this.getSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),e=new ir),e.set(A,S)},this.setSize=function(e,n,r){de.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(A=e,S=n,t.width=Math.floor(e*R),t.height=Math.floor(n*R),!1!==r&&(t.style.width=e+"px",t.style.height=n+"px"),this.setViewport(0,0,e,n))},this.getDrawingBufferSize=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),e=new ir),e.set(A*R,S*R).floor()},this.setDrawingBufferSize=function(e,n,r){A=e,S=n,R=r,t.width=Math.floor(e*r),t.height=Math.floor(n*r),this.setViewport(0,0,e,n)},this.getCurrentViewport=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),e=new pr),e.copy(b)},this.getViewport=function(e){return e.copy(L)},this.setViewport=function(e,t,n,r){e.isVector4?L.set(e.x,e.y,e.z,e.w):L.set(e,t,n,r),B.viewport(b.copy(L).multiplyScalar(R).floor())},this.getScissor=function(e){return e.copy(P)},this.setScissor=function(e,t,n,r){e.isVector4?P.set(e.x,e.y,e.z,e.w):P.set(e,t,n,r),B.scissor(_.copy(P).multiplyScalar(R).floor())},this.getScissorTest=function(){return k},this.setScissorTest=function(e){B.setScissorTest(k=e)},this.setOpaqueSort=function(e){M=e},this.setTransparentSort=function(e){C=e},this.getClearColor=function(e){return void 0===e&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),e=new Wo),e.copy(re.getClearColor())},this.setClearColor=function(){re.setClearColor.apply(re,arguments)},this.getClearAlpha=function(){return re.getClearAlpha()},this.setClearAlpha=function(){re.setClearAlpha.apply(re,arguments)},this.clear=function(e,t,n){let r=0;(void 0===e||e)&&(r|=ce.COLOR_BUFFER_BIT),(void 0===t||t)&&(r|=ce.DEPTH_BUFFER_BIT),(void 0===n||n)&&(r|=ce.STENCIL_BUFFER_BIT),ce.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",pe,!1),t.removeEventListener("webglcontextrestored",he,!1),$.dispose(),ee.dispose(),W.dispose(),q.dispose(),Q.dispose(),le.dispose(),de.dispose(),de.removeEventListener("sessionstart",we),de.removeEventListener("sessionend",_e),Te.stop()},this.renderBufferImmediate=function(e,t){le.initAttributes();const n=W.get(e);e.hasPositions&&!n.position&&(n.position=ce.createBuffer()),e.hasNormals&&!n.normal&&(n.normal=ce.createBuffer()),e.hasUvs&&!n.uv&&(n.uv=ce.createBuffer()),e.hasColors&&!n.color&&(n.color=ce.createBuffer());const r=t.getAttributes();e.hasPositions&&(ce.bindBuffer(ce.ARRAY_BUFFER,n.position),ce.bufferData(ce.ARRAY_BUFFER,e.positionArray,ce.DYNAMIC_DRAW),le.enableAttribute(r.position),ce.vertexAttribPointer(r.position,3,ce.FLOAT,!1,0,0)),e.hasNormals&&(ce.bindBuffer(ce.ARRAY_BUFFER,n.normal),ce.bufferData(ce.ARRAY_BUFFER,e.normalArray,ce.DYNAMIC_DRAW),le.enableAttribute(r.normal),ce.vertexAttribPointer(r.normal,3,ce.FLOAT,!1,0,0)),e.hasUvs&&(ce.bindBuffer(ce.ARRAY_BUFFER,n.uv),ce.bufferData(ce.ARRAY_BUFFER,e.uvArray,ce.DYNAMIC_DRAW),le.enableAttribute(r.uv),ce.vertexAttribPointer(r.uv,2,ce.FLOAT,!1,0,0)),e.hasColors&&(ce.bindBuffer(ce.ARRAY_BUFFER,n.color),ce.bufferData(ce.ARRAY_BUFFER,e.colorArray,ce.DYNAMIC_DRAW),le.enableAttribute(r.color),ce.vertexAttribPointer(r.color,3,ce.FLOAT,!1,0,0)),le.disableUnusedAttributes(),ce.drawArrays(ce.TRIANGLES,0,e.count),e.count=0},this.renderBufferDirect=function(e,t,n,r,o,a){null===t&&(t=I);const i=o.isMesh&&o.matrixWorld.determinant()<0,s=ke(e,t,r,o);B.setMaterial(r,i);let l=n.index;const c=n.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let f,u=1;!0===r.wireframe&&(l=Y.getWireframeAttribute(n),u=2),(r.morphTargets||r.morphNormals)&&oe.update(o,n,r,s),le.setup(o,r,s,n,l);let d=ae;null!==l&&(f=X.get(l),d=ie,d.setIndex(f));const p=null!==l?l.count:c.count,h=n.drawRange.start*u,v=n.drawRange.count*u,m=null!==a?a.start*u:0,x=null!==a?a.count*u:1/0,g=Math.max(h,m),y=Math.min(p,h+v,m+x)-1,E=Math.max(0,y-g+1);if(0!==E){if(o.isMesh)!0===r.wireframe?(B.setLineWidth(r.wireframeLinewidth*O()),d.setMode(ce.LINES)):d.setMode(ce.TRIANGLES);else if(o.isLine){let e=r.linewidth;void 0===e&&(e=1),B.setLineWidth(e*O()),o.isLineSegments?d.setMode(ce.LINES):o.isLineLoop?d.setMode(ce.LINE_LOOP):d.setMode(ce.LINE_STRIP)}else o.isPoints?d.setMode(ce.POINTS):o.isSprite&&d.setMode(ce.TRIANGLES);if(o.isInstancedMesh)d.renderInstances(g,E,o.count);else if(n.isInstancedBufferGeometry){const e=Math.min(n.instanceCount,n._maxInstanceCount);d.renderInstances(g,E,e)}else d.render(g,E)}},this.compile=function(e,t){d=ee.get(e),d.init(),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(d.pushLight(e),e.castShadow&&d.pushShadow(e))})),d.setupLights(),e.traverse((function(t){const n=t.material;if(n)if(Array.isArray(n))for(let r=0;r<n.length;r++)Le(n[r],e,t);else Le(n,e,t)}))};let ye=null;function Ee(e){ye&&ye(e)}function we(){Te.stop()}function _e(){Te.start()}const Te=new ei;function Ae(e,t,n,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)n=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)d.pushLight(e),e.castShadow&&d.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||N.intersectsSprite(e)){r&&F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(D);const t=Q.update(e),o=e.material;o.visible&&u.push(e,t,o,n,F.z,null)}}else if(e.isImmediateRenderObject)r&&F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(D),u.push(e,null,e.material,n,F.z,null);else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==V.render.frame&&(e.skeleton.update(),e.skeleton.frame=V.render.frame),!e.frustumCulled||N.intersectsObject(e))){r&&F.setFromMatrixPosition(e.matrixWorld).applyMatrix4(D);const t=Q.update(e),o=e.material;if(Array.isArray(o)){const r=t.groups;for(let a=0,i=r.length;a<i;a++){const i=r[a],s=o[i.materialIndex];s&&s.visible&&u.push(e,t,s,n,F.z,i)}}else o.visible&&u.push(e,t,o,n,F.z,null)}const o=e.children;for(let e=0,a=o.length;e<a;e++)Ae(o[e],t,n,r)}function Se(e,t,n){const r=!0===t.isScene?t.overrideMaterial:null;for(let o=0,a=e.length;o<a;o++){const a=e[o],i=a.object,s=a.geometry,l=null===r?a.material:r,c=a.group;if(n.isArrayCamera){const e=n.cameras;for(let n=0,r=e.length;n<r;n++){const r=e[n];i.layers.test(r.layers)&&(B.viewport(b.copy(r.viewport)),d.setupLightsView(r),Re(i,t,r,s,l,c))}}else Re(i,t,n,s,l,c)}}function Re(e,t,n,r,o,a){if(e.onBeforeRender(v,t,n,r,o,a),e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),e.isImmediateRenderObject){const r=ke(n,t,o,e);B.setMaterial(o),le.reset(),ge(e,r)}else v.renderBufferDirect(n,t,r,o,e,a);e.onAfterRender(v,t,n,r,o,a)}function Le(e,t,n){!0!==t.isScene&&(t=I);const r=W.get(e),o=d.state.lights,a=d.state.shadowsArray,i=o.state.version,s=Z.getParameters(e,o.state,a,t,n),l=Z.getProgramCacheKey(s);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=q.get(e.envMap||r.environment),void 0===c&&(e.addEventListener("dispose",ve),c=new Map,r.programs=c);let f=c.get(l);if(void 0!==f){if(r.currentProgram===f&&r.lightsStateVersion===i)return Pe(e,s),f}else s.uniforms=Z.getUniforms(e),e.onBuild(s,v),e.onBeforeCompile(s,v),f=Z.acquireProgram(s,l),c.set(l,f),r.uniforms=s.uniforms;const u=r.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(u.clippingPlanes=te.uniform),Pe(e,s),r.needsLights=He(e),r.lightsStateVersion=i,r.needsLights&&(u.ambientLightColor.value=o.state.ambient,u.lightProbe.value=o.state.probe,u.directionalLights.value=o.state.directional,u.directionalLightShadows.value=o.state.directionalShadow,u.spotLights.value=o.state.spot,u.spotLightShadows.value=o.state.spotShadow,u.rectAreaLights.value=o.state.rectArea,u.ltc_1.value=o.state.rectAreaLTC1,u.ltc_2.value=o.state.rectAreaLTC2,u.pointLights.value=o.state.point,u.pointLightShadows.value=o.state.pointShadow,u.hemisphereLights.value=o.state.hemi,u.directionalShadowMap.value=o.state.directionalShadowMap,u.directionalShadowMatrix.value=o.state.directionalShadowMatrix,u.spotShadowMap.value=o.state.spotShadowMap,u.spotShadowMatrix.value=o.state.spotShadowMatrix,u.pointShadowMap.value=o.state.pointShadowMap,u.pointShadowMatrix.value=o.state.pointShadowMatrix);const p=f.getUniforms(),h=As.seqWithValue(p.seq,u);return r.currentProgram=f,r.uniformsList=h,f}function Pe(e,t){const n=W.get(e);n.outputEncoding=t.outputEncoding,n.instancing=t.instancing,n.numClippingPlanes=t.numClippingPlanes,n.numIntersection=t.numClipIntersection,n.vertexAlphas=t.vertexAlphas}function ke(e,t,n,r){!0!==t.isScene&&(t=I),j.resetTextureUnits();const o=t.fog,a=n.isMeshStandardMaterial?t.environment:null,i=null===y?v.outputEncoding:y.texture.encoding,s=q.get(n.envMap||a),l=!0===n.vertexColors&&r.geometry&&r.geometry.attributes.color&&4===r.geometry.attributes.color.itemSize,c=W.get(n),f=d.state.lights;if(!0===H&&(!0===z||e!==w)){const t=e===w&&n.id===E;te.setState(n,e,t)}let u=!1;n.version===c.__version?c.needsLights&&c.lightsStateVersion!==f.state.version||c.outputEncoding!==i||r.isInstancedMesh&&!1===c.instancing?u=!0:r.isInstancedMesh||!0!==c.instancing?c.envMap!==s||n.fog&&c.fog!==o?u=!0:void 0===c.numClippingPlanes||c.numClippingPlanes===te.numPlanes&&c.numIntersection===te.numIntersection?c.vertexAlphas!==l&&(u=!0):u=!0:u=!0:(u=!0,c.__version=n.version);let p=c.currentProgram;!0===u&&(p=Le(n,t,r));let h=!1,m=!1,x=!1;const g=p.getUniforms(),b=c.uniforms;if(B.useProgram(p.program)&&(h=!0,m=!0,x=!0),n.id!==E&&(E=n.id,m=!0),h||w!==e){if(g.setValue(ce,"projectionMatrix",e.projectionMatrix),G.logarithmicDepthBuffer&&g.setValue(ce,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),w!==e&&(w=e,m=!0,x=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){const t=g.map.cameraPosition;void 0!==t&&t.setValue(ce,F.setFromMatrixPosition(e.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&g.setValue(ce,"isOrthographic",!0===e.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&g.setValue(ce,"viewMatrix",e.matrixWorldInverse)}if(n.skinning){g.setOptional(ce,r,"bindMatrix"),g.setOptional(ce,r,"bindMatrixInverse");const e=r.skeleton;if(e){const t=e.bones;if(G.floatVertexTextures){if(null===e.boneTexture){let n=Math.sqrt(4*t.length);n=nr(n),n=Math.max(n,4);const r=new Float32Array(n*n*4);r.set(e.boneMatrices);const o=new Ka(r,n,n,De,Me);e.boneMatrices=r,e.boneTexture=o,e.boneTextureSize=n}g.setValue(ce,"boneTexture",e.boneTexture,j),g.setValue(ce,"boneTextureSize",e.boneTextureSize)}else g.setOptional(ce,e,"boneMatrices")}}return(m||c.receiveShadow!==r.receiveShadow)&&(c.receiveShadow=r.receiveShadow,g.setValue(ce,"receiveShadow",r.receiveShadow)),m&&(g.setValue(ce,"toneMappingExposure",v.toneMappingExposure),c.needsLights&&Ne(b,x),o&&n.fog&&J.refreshFogUniforms(b,o),J.refreshMaterialUniforms(b,n,R,S),As.upload(ce,c.uniformsList,b,j)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(As.upload(ce,c.uniformsList,b,j),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&g.setValue(ce,"center",r.center),g.setValue(ce,"modelViewMatrix",r.modelViewMatrix),g.setValue(ce,"normalMatrix",r.normalMatrix),g.setValue(ce,"modelMatrix",r.matrixWorld),p}function Ne(e,t){e.ambientLightColor.needsUpdate=t,e.lightProbe.needsUpdate=t,e.directionalLights.needsUpdate=t,e.directionalLightShadows.needsUpdate=t,e.pointLights.needsUpdate=t,e.pointLightShadows.needsUpdate=t,e.spotLights.needsUpdate=t,e.spotLightShadows.needsUpdate=t,e.rectAreaLights.needsUpdate=t,e.hemisphereLights.needsUpdate=t}function He(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}Te.setAnimationLoop(Ee),"undefined"!=typeof window&&Te.setContext(window),this.setAnimationLoop=function(e){ye=e,de.setAnimationLoop(e),null===e?Te.stop():Te.start()},de.addEventListener("sessionstart",we),de.addEventListener("sessionend",_e),this.render=function(e,t){let n,r;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),r=arguments[3]),void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===m)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===de.enabled&&!0===de.isPresenting&&(t=de.getCamera(t)),!0===e.isScene&&e.onBeforeRender(v,e,t,n||y),d=ee.get(e,h.length),d.init(),h.push(d),D.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),N.setFromProjectionMatrix(D),z=this.localClippingEnabled,H=te.init(this.clippingPlanes,z,t),u=$.get(e,p.length),u.init(),p.push(u),Ae(e,t,0,v.sortObjects),u.finish(),!0===v.sortObjects&&u.sort(M,C),!0===H&&te.beginShadows();const o=d.state.shadowsArray;ne.render(o,e,t),d.setupLights(),d.setupLightsView(t),!0===H&&te.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),re.render(u,e,t,r);const a=u.opaque,i=u.transparent;a.length>0&&Se(a,e,t),i.length>0&&Se(i,e,t),null!==y&&(j.updateRenderTargetMipmap(y),j.updateMultisampleRenderTarget(y)),!0===e.isScene&&e.onAfterRender(v,e,t),B.buffers.depth.setTest(!0),B.buffers.depth.setMask(!0),B.buffers.color.setMask(!0),B.setPolygonOffset(!1),le.resetDefaultState(),E=-1,w=null,h.pop(),d=h.length>0?h[h.length-1]:null,p.pop(),u=p.length>0?p[p.length-1]:null},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return y},this.setRenderTarget=function(e,t=0,n=0){y=e,x=t,g=n,e&&void 0===W.get(e).__webglFramebuffer&&j.setupRenderTarget(e);let r=null,o=!1,a=!1;if(e){const n=e.texture;(n.isDataTexture3D||n.isDataTexture2DArray)&&(a=!0);const i=W.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(r=i[t],o=!0):r=e.isWebGLMultisampleRenderTarget?W.get(e).__webglMultisampledFramebuffer:i,b.copy(e.viewport),_.copy(e.scissor),T=e.scissorTest}else b.copy(L).multiplyScalar(R).floor(),_.copy(P).multiplyScalar(R).floor(),T=k;if(B.bindFramebuffer(ce.FRAMEBUFFER,r),B.viewport(b),B.scissor(_),B.setScissorTest(T),o){const r=W.get(e.texture);ce.framebufferTexture2D(ce.FRAMEBUFFER,ce.COLOR_ATTACHMENT0,ce.TEXTURE_CUBE_MAP_POSITIVE_X+t,r.__webglTexture,n)}else if(a){const r=W.get(e.texture),o=t||0;ce.framebufferTextureLayer(ce.FRAMEBUFFER,ce.COLOR_ATTACHMENT0,r.__webglTexture,n||0,o)}},this.readRenderTargetPixels=function(e,t,n,r,o,a,i){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let s=W.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==i&&(s=s[i]),s){B.bindFramebuffer(ce.FRAMEBUFFER,s);try{const i=e.texture,s=i.format,l=i.type;if(s!==De&&se.convert(s)!==ce.getParameter(ce.IMPLEMENTATION_COLOR_READ_FORMAT))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===Ce&&(U.has("EXT_color_buffer_half_float")||G.isWebGL2&&U.has("EXT_color_buffer_float"));if(!(l===be||se.convert(l)===ce.getParameter(ce.IMPLEMENTATION_COLOR_READ_TYPE)||l===Me&&(G.isWebGL2||U.has("OES_texture_float")||U.has("WEBGL_color_buffer_float"))||c))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");ce.checkFramebufferStatus(ce.FRAMEBUFFER)===ce.FRAMEBUFFER_COMPLETE?t>=0&&t<=e.width-r&&n>=0&&n<=e.height-o&&ce.readPixels(t,n,r,o,se.convert(s),se.convert(l),a):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const e=null!==y?W.get(y).__webglFramebuffer:null;B.bindFramebuffer(ce.FRAMEBUFFER,e)}}},this.copyFramebufferToTexture=function(e,t,n=0){const r=Math.pow(2,-n),o=Math.floor(t.image.width*r),a=Math.floor(t.image.height*r),i=se.convert(t.format);j.setTexture2D(t,0),ce.copyTexImage2D(ce.TEXTURE_2D,n,i,e.x,e.y,o,a,0),B.unbindTexture()},this.copyTextureToTexture=function(e,t,n,r=0){const o=t.image.width,a=t.image.height,i=se.convert(n.format),s=se.convert(n.type);j.setTexture2D(n,0),ce.pixelStorei(ce.UNPACK_FLIP_Y_WEBGL,n.flipY),ce.pixelStorei(ce.UNPACK_PREMULTIPLY_ALPHA_WEBGL,n.premultiplyAlpha),ce.pixelStorei(ce.UNPACK_ALIGNMENT,n.unpackAlignment),t.isDataTexture?ce.texSubImage2D(ce.TEXTURE_2D,r,e.x,e.y,o,a,i,s,t.image.data):t.isCompressedTexture?ce.compressedTexSubImage2D(ce.TEXTURE_2D,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,i,t.mipmaps[0].data):ce.texSubImage2D(ce.TEXTURE_2D,r,e.x,e.y,i,s,t.image),0===r&&n.generateMipmaps&&ce.generateMipmap(ce.TEXTURE_2D),B.unbindTexture()},this.copyTextureToTexture3D=function(e,t,n,r,o=0){if(v.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const{width:a,height:i,data:s}=n.image,l=se.convert(r.format),c=se.convert(r.type);let f;if(r.isDataTexture3D)j.setTexture3D(r,0),f=ce.TEXTURE_3D;else{if(!r.isDataTexture2DArray)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");j.setTexture2DArray(r,0),f=ce.TEXTURE_2D_ARRAY}ce.pixelStorei(ce.UNPACK_FLIP_Y_WEBGL,r.flipY),ce.pixelStorei(ce.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.premultiplyAlpha),ce.pixelStorei(ce.UNPACK_ALIGNMENT,r.unpackAlignment);const u=ce.getParameter(ce.UNPACK_ROW_LENGTH),d=ce.getParameter(ce.UNPACK_IMAGE_HEIGHT),p=ce.getParameter(ce.UNPACK_SKIP_PIXELS),h=ce.getParameter(ce.UNPACK_SKIP_ROWS),m=ce.getParameter(ce.UNPACK_SKIP_IMAGES);ce.pixelStorei(ce.UNPACK_ROW_LENGTH,a),ce.pixelStorei(ce.UNPACK_IMAGE_HEIGHT,i),ce.pixelStorei(ce.UNPACK_SKIP_PIXELS,e.min.x),ce.pixelStorei(ce.UNPACK_SKIP_ROWS,e.min.y),ce.pixelStorei(ce.UNPACK_SKIP_IMAGES,e.min.z),ce.texSubImage3D(f,o,t.x,t.y,t.z,e.max.x-e.min.x+1,e.max.y-e.min.y+1,e.max.z-e.min.z+1,l,c,s),ce.pixelStorei(ce.UNPACK_ROW_LENGTH,u),ce.pixelStorei(ce.UNPACK_IMAGE_HEIGHT,d),ce.pixelStorei(ce.UNPACK_SKIP_PIXELS,p),ce.pixelStorei(ce.UNPACK_SKIP_ROWS,h),ce.pixelStorei(ce.UNPACK_SKIP_IMAGES,m),0===o&&r.generateMipmaps&&ce.generateMipmap(f),B.unbindTexture()},this.initTexture=function(e){j.setTexture2D(e,0),B.unbindTexture()},this.resetState=function(){x=0,g=0,y=null,B.reset(),le.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class Cl extends Ml{}Cl.prototype.isWebGL1Renderer=!0;class Ll{constructor(e,t=25e-5){this.name="",this.color=new Wo(e),this.density=t}clone(){return new Ll(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}Ll.prototype.isFogExp2=!0;class Pl{constructor(e,t=1,n=1e3){this.name="",this.color=new Wo(e),this.near=t,this.far=n}clone(){return new Pl(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}Pl.prototype.isFog=!0;class kl extends Eo{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.background&&(t.object.background=this.background.toJSON(e)),null!==this.environment&&(t.object.environment=this.environment.toJSON(e)),null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}kl.prototype.isScene=!0;class Nl{constructor(e,t){this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=_n,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=On(),this.onUploadCallback=function(){}}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let r=0,o=this.stride;r<o;r++)this.array[e+r]=t.array[n+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=On()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new Nl(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=On()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Nl.prototype.isInterleavedBuffer=!0;const Hl=new xr;class zl{constructor(e,t,n,r){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Hl.x=this.getX(t),Hl.y=this.getY(t),Hl.z=this.getZ(t),Hl.applyMatrix4(e),this.setXYZ(t,Hl.x,Hl.y,Hl.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Hl.x=this.getX(t),Hl.y=this.getY(t),Hl.z=this.getZ(t),Hl.applyNormalMatrix(e),this.setXYZ(t,Hl.x,Hl.y,Hl.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Hl.x=this.getX(t),Hl.y=this.getY(t),Hl.z=this.getZ(t),Hl.transformDirection(e),this.setXYZ(t,Hl.x,Hl.y,Hl.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this}setXYZW(e,t,n,r,o){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=r,this.data.array[e+3]=o,this}clone(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return new Yo(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new zl(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[n+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}zl.prototype.isInterleavedBufferAttribute=!0;class Dl extends Fo{constructor(e){super(),this.type="SpriteMaterial",this.color=new Wo(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}let Fl;Dl.prototype.isSpriteMaterial=!0;const Il=new xr,Ol=new xr,Ul=new xr,Gl=new ir,Bl=new ir,Vl=new Yr,Wl=new xr,jl=new xr,ql=new xr,Xl=new ir,Yl=new ir,Ql=new ir;class Kl extends Eo{constructor(e){if(super(),this.type="Sprite",void 0===Fl){Fl=new va;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new Nl(e,5);Fl.setIndex([0,1,2,0,2,3]),Fl.setAttribute("position",new zl(t,3,0,!1)),Fl.setAttribute("uv",new zl(t,2,3,!1))}this.geometry=Fl,this.material=void 0!==e?e:new Dl,this.center=new ir(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Ol.setFromMatrixScale(this.matrixWorld),Vl.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ul.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Ol.multiplyScalar(-Ul.z);const n=this.material.rotation;let r,o;0!==n&&(o=Math.cos(n),r=Math.sin(n));const a=this.center;Zl(Wl.set(-.5,-.5,0),Ul,a,Ol,r,o),Zl(jl.set(.5,-.5,0),Ul,a,Ol,r,o),Zl(ql.set(.5,.5,0),Ul,a,Ol,r,o),Xl.set(0,0),Yl.set(1,0),Ql.set(1,1);let i=e.ray.intersectTriangle(Wl,jl,ql,!1,Il);if(null===i&&(Zl(jl.set(-.5,.5,0),Ul,a,Ol,r,o),Yl.set(0,1),i=e.ray.intersectTriangle(Wl,ql,jl,!1,Il),null===i))return;const s=e.ray.origin.distanceTo(Il);s<e.near||s>e.far||t.push({distance:s,point:Il.clone(),uv:zo.getUV(Il,Wl,jl,ql,Xl,Yl,Ql,new ir),face:null,object:this})}copy(e){return super.copy(e),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function Zl(e,t,n,r,o,a){Gl.subVectors(e,n).addScalar(.5).multiply(r),void 0!==o?(Bl.x=a*Gl.x-o*Gl.y,Bl.y=o*Gl.x+a*Gl.y):Bl.copy(Gl),e.copy(t),e.x+=Bl.x,e.y+=Bl.y,e.applyMatrix4(Vl)}Kl.prototype.isSprite=!0;const Jl=new xr,$l=new xr;class ec extends Eo{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let e=0,n=t.length;e<n;e++){const n=t[e];this.addLevel(n.object.clone(),n.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const n=this.levels;let r;for(r=0;r<n.length&&!(t<n[r].distance);r++);return n.splice(r,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,r;for(n=1,r=t.length;n<r&&!(e<t[n].distance);n++);return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){Jl.setFromMatrixPosition(this.matrixWorld);const n=e.ray.origin.distanceTo(Jl);this.getObjectForDistance(n).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){Jl.setFromMatrixPosition(e.matrixWorld),$l.setFromMatrixPosition(this.matrixWorld);const n=Jl.distanceTo($l)/e.zoom;let r,o;for(t[0].object.visible=!0,r=1,o=t.length;r<o&&n>=t[r].distance;r++)t[r-1].object.visible=!1,t[r].object.visible=!0;for(this._currentLevel=r-1;r<o;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let e=0,r=n.length;e<r;e++){const r=n[e];t.object.levels.push({object:r.object.uuid,distance:r.distance})}return t}}const tc=new xr,nc=new pr,rc=new pr,oc=new xr,ac=new Yr;class ic extends Na{constructor(e,t){super(e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Yr,this.bindMatrixInverse=new Yr}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new pr,t=this.geometry.attributes.skinWeight;for(let n=0,r=t.count;n<r;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,r=this.geometry;nc.fromBufferAttribute(r.attributes.skinIndex,e),rc.fromBufferAttribute(r.attributes.skinWeight,e),tc.fromBufferAttribute(r.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let e=0;e<4;e++){const r=rc.getComponent(e);if(0!==r){const o=nc.getComponent(e);ac.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(oc.copy(tc).applyMatrix4(ac),r)}}return t.applyMatrix4(this.bindMatrixInverse)}}ic.prototype.isSkinnedMesh=!0;class sc extends Eo{constructor(){super(),this.type="Bone"}}sc.prototype.isBone=!0;const lc=new Yr,cc=new Yr;class fc{constructor(e=[],t=[]){this.uuid=On(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Yr)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Yr;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,r=this.boneTexture;for(let r=0,o=e.length;r<o;r++){const o=e[r]?e[r].matrixWorld:cc;lc.multiplyMatrices(o,t[r]),lc.toArray(n,16*r)}null!==r&&(r.needsUpdate=!0)}clone(){return new fc(this.bones,this.boneInverses)}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const n=this.bones[t];if(n.name===e)return n}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,r=e.bones.length;n<r;n++){const r=e.bones[n];let o=t[r];void 0===o&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),o=new sc),this.bones.push(o),this.boneInverses.push((new Yr).fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let r=0,o=t.length;r<o;r++){const o=t[r];e.bones.push(o.uuid);const a=n[r];e.boneInverses.push(a.toArray())}return e}}const uc=new Yr,dc=new Yr,pc=[],hc=new Na;class vc extends Na{constructor(e,t,n){super(e,t),this.instanceMatrix=new Yo(new Float32Array(16*n),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const n=this.matrixWorld,r=this.count;if(hc.geometry=this.geometry,hc.material=this.material,void 0!==hc.material)for(let o=0;o<r;o++){this.getMatrixAt(o,uc),dc.multiplyMatrices(n,uc),hc.matrixWorld=dc,hc.raycast(e,pc);for(let e=0,n=pc.length;e<n;e++){const n=pc[e];n.instanceId=o,n.object=this,t.push(n)}pc.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new Yo(new Float32Array(3*this.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}vc.prototype.isInstancedMesh=!0;class mc extends Fo{constructor(e){super(),this.type="LineBasicMaterial",this.color=new Wo(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this}}mc.prototype.isLineBasicMaterial=!0;const xc=new xr,gc=new xr,yc=new Yr,Ec=new Xr,wc=new Or;class bc extends Eo{constructor(e=new va,t=new mc){super(),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[0];for(let e=1,r=t.count;e<r;e++)xc.fromBufferAttribute(t,e-1),gc.fromBufferAttribute(t,e),n[e]=n[e-1],n[e]+=xc.distanceTo(gc);e.setAttribute("lineDistance",new ra(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,o=e.params.Line.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),wc.copy(n.boundingSphere),wc.applyMatrix4(r),wc.radius+=o,!1===e.ray.intersectsSphere(wc))return;yc.copy(r).invert(),Ec.copy(e.ray).applyMatrix4(yc);const i=o/((this.scale.x+this.scale.y+this.scale.z)/3),s=i*i,l=new xr,c=new xr,f=new xr,u=new xr,d=this.isLineSegments?2:1;if(n.isBufferGeometry){const r=n.index,o=n.attributes.position;if(null!==r)for(let n=Math.max(0,a.start),i=Math.min(r.count,a.start+a.count)-1;n<i;n+=d){const a=r.getX(n),i=r.getX(n+1);if(l.fromBufferAttribute(o,a),c.fromBufferAttribute(o,i),Ec.distanceSqToSegment(l,c,u,f)>s)continue;u.applyMatrix4(this.matrixWorld);const d=e.ray.origin.distanceTo(u);d<e.near||d>e.far||t.push({distance:d,point:f.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}else for(let n=Math.max(0,a.start),r=Math.min(o.count,a.start+a.count)-1;n<r;n+=d){if(l.fromBufferAttribute(o,n),c.fromBufferAttribute(o,n+1),Ec.distanceSqToSegment(l,c,u,f)>s)continue;u.applyMatrix4(this.matrixWorld);const r=e.ray.origin.distanceTo(u);r<e.near||r>e.far||t.push({distance:r,point:f.clone().applyMatrix4(this.matrixWorld),index:n,face:null,faceIndex:null,object:this})}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}bc.prototype.isLine=!0;const _c=new xr,Tc=new xr;class Ac extends bc{constructor(e,t){super(e,t),this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(null===e.index){const t=e.attributes.position,n=[];for(let e=0,r=t.count;e<r;e+=2)_c.fromBufferAttribute(t,e),Tc.fromBufferAttribute(t,e+1),n[e]=0===e?0:n[e-1],n[e+1]=n[e]+_c.distanceTo(Tc);e.setAttribute("lineDistance",new ra(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Ac.prototype.isLineSegments=!0;class Sc extends bc{constructor(e,t){super(e,t),this.type="LineLoop"}}Sc.prototype.isLineLoop=!0;class Rc extends Fo{constructor(e){super(),this.type="PointsMaterial",this.color=new Wo(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this}}Rc.prototype.isPointsMaterial=!0;const Mc=new Yr,Cc=new Xr,Lc=new Or,Pc=new xr;class kc extends Eo{constructor(e=new va,t=new Rc){super(),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,r=this.matrixWorld,o=e.params.Points.threshold,a=n.drawRange;if(null===n.boundingSphere&&n.computeBoundingSphere(),Lc.copy(n.boundingSphere),Lc.applyMatrix4(r),Lc.radius+=o,!1===e.ray.intersectsSphere(Lc))return;Mc.copy(r).invert(),Cc.copy(e.ray).applyMatrix4(Mc);const i=o/((this.scale.x+this.scale.y+this.scale.z)/3),s=i*i;if(n.isBufferGeometry){const o=n.index,i=n.attributes.position;if(null!==o)for(let n=Math.max(0,a.start),l=Math.min(o.count,a.start+a.count);n<l;n++){const a=o.getX(n);Pc.fromBufferAttribute(i,a),Nc(Pc,a,s,r,e,t,this)}else for(let n=Math.max(0,a.start),o=Math.min(i.count,a.start+a.count);n<o;n++)Pc.fromBufferAttribute(i,n),Nc(Pc,n,s,r,e,t,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const e=t[n[0]];if(void 0!==e){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++){const n=e[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=t}}}}else{const t=e.morphTargets;void 0!==t&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function Nc(e,t,n,r,o,a,i){const s=Cc.distanceSqToPoint(e);if(s<n){const n=new xr;Cc.closestPointToPoint(e,n),n.applyMatrix4(r);const l=o.ray.origin.distanceTo(n);if(l<o.near||l>o.far)return;a.push({distance:l,distanceToRay:Math.sqrt(s),point:n,index:t,face:null,object:i})}}kc.prototype.isPoints=!0;class Hc extends ur{constructor(e,t,n,r,o,a,i,s,l){super(e,t,n,r,o,a,i,s,l),this.format=void 0!==i?i:ze,this.minFilter=void 0!==a?a:xe,this.magFilter=void 0!==o?o:xe,this.generateMipmaps=!1;const c=this;function f(){c.needsUpdate=!0,e.requestVideoFrameCallback(f)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(f)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!1=="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}Hc.prototype.isVideoTexture=!0;class zc extends ur{constructor(e,t,n,r,o,a,i,s,l,c,f,u){super(null,a,i,s,l,c,r,o,f,u),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}zc.prototype.isCompressedTexture=!0;class Dc extends ur{constructor(e,t,n,r,o,a,i,s,l){super(e,t,n,r,o,a,i,s,l),this.needsUpdate=!0}}Dc.prototype.isCanvasTexture=!0;class Fc extends ur{constructor(e,t,n,r,o,a,i,s,l,c){if((c=void 0!==c?c:Ue)!==Ue&&c!==Ge)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===n&&c===Ue&&(n=Ae),void 0===n&&c===Ge&&(n=Ne),super(null,r,o,a,i,s,c,n,l),this.image={width:e,height:t},this.magFilter=void 0!==i?i:de,this.minFilter=void 0!==s?s:de,this.flipY=!1,this.generateMipmaps=!1}}Fc.prototype.isDepthTexture=!0;class Ic extends va{constructor(e=1,t=8,n=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:r},t=Math.max(3,t);const o=[],a=[],i=[],s=[],l=new xr,c=new ir;a.push(0,0,0),i.push(0,0,1),s.push(.5,.5);for(let o=0,f=3;o<=t;o++,f+=3){const u=n+o/t*r;l.x=e*Math.cos(u),l.y=e*Math.sin(u),a.push(l.x,l.y,l.z),i.push(0,0,1),c.x=(a[f]/e+1)/2,c.y=(a[f+1]/e+1)/2,s.push(c.x,c.y)}for(let e=1;e<=t;e++)o.push(e,e+1,0);this.setIndex(o),this.setAttribute("position",new ra(a,3)),this.setAttribute("normal",new ra(i,3)),this.setAttribute("uv",new ra(s,2))}}class Oc extends va{constructor(e=1,t=1,n=1,r=8,o=1,a=!1,i=0,s=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:r,heightSegments:o,openEnded:a,thetaStart:i,thetaLength:s};const l=this;r=Math.floor(r),o=Math.floor(o);const c=[],f=[],u=[],d=[];let p=0;const h=[],v=n/2;let m=0;function x(){const a=new xr,x=new xr;let g=0;const y=(t-e)/n;for(let l=0;l<=o;l++){const c=[],m=l/o,g=m*(t-e)+e;for(let e=0;e<=r;e++){const t=e/r,o=t*s+i,l=Math.sin(o),h=Math.cos(o);x.x=g*l,x.y=-m*n+v,x.z=g*h,f.push(x.x,x.y,x.z),a.set(l,y,h).normalize(),u.push(a.x,a.y,a.z),d.push(t,1-m),c.push(p++)}h.push(c)}for(let e=0;e<r;e++)for(let t=0;t<o;t++){const n=h[t][e],r=h[t+1][e],o=h[t+1][e+1],a=h[t][e+1];c.push(n,r,a),c.push(r,o,a),g+=6}l.addGroup(m,g,0),m+=g}function g(n){const o=p,a=new ir,h=new xr;let x=0;const g=!0===n?e:t,y=!0===n?1:-1;for(let e=1;e<=r;e++)f.push(0,v*y,0),u.push(0,y,0),d.push(.5,.5),p++;const E=p;for(let e=0;e<=r;e++){const t=e/r*s+i,n=Math.cos(t),o=Math.sin(t);h.x=g*o,h.y=v*y,h.z=g*n,f.push(h.x,h.y,h.z),u.push(0,y,0),a.x=.5*n+.5,a.y=.5*o*y+.5,d.push(a.x,a.y),p++}for(let e=0;e<r;e++){const t=o+e,r=E+e;!0===n?c.push(r,r+1,t):c.push(r+1,r,t),x+=3}l.addGroup(m,x,!0===n?1:2),m+=x}x(),!1===a&&(e>0&&g(!0),t>0&&g(!1)),this.setIndex(c),this.setAttribute("position",new ra(f,3)),this.setAttribute("normal",new ra(u,3)),this.setAttribute("uv",new ra(d,2))}}class Uc extends Oc{constructor(e=1,t=1,n=8,r=1,o=!1,a=0,i=2*Math.PI){super(0,e,t,n,r,o,a,i),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:r,openEnded:o,thetaStart:a,thetaLength:i}}}class Gc extends va{constructor(e,t,n=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:r};const o=[],a=[];function i(e){const n=new xr,r=new xr,o=new xr;for(let a=0;a<t.length;a+=3)d(t[a+0],n),d(t[a+1],r),d(t[a+2],o),s(n,r,o,e)}function s(e,t,n,r){const o=r+1,a=[];for(let r=0;r<=o;r++){a[r]=[];const i=e.clone().lerp(n,r/o),s=t.clone().lerp(n,r/o),l=o-r;for(let e=0;e<=l;e++)a[r][e]=0===e&&r===o?i:i.clone().lerp(s,e/l)}for(let e=0;e<o;e++)for(let t=0;t<2*(o-e)-1;t++){const n=Math.floor(t/2);t%2==0?(u(a[e][n+1]),u(a[e+1][n]),u(a[e][n])):(u(a[e][n+1]),u(a[e+1][n+1]),u(a[e+1][n]))}}function l(e){const t=new xr;for(let n=0;n<o.length;n+=3)t.x=o[n+0],t.y=o[n+1],t.z=o[n+2],t.normalize().multiplyScalar(e),o[n+0]=t.x,o[n+1]=t.y,o[n+2]=t.z}function c(){const e=new xr;for(let t=0;t<o.length;t+=3){e.x=o[t+0],e.y=o[t+1],e.z=o[t+2];const n=v(e)/2/Math.PI+.5,r=m(e)/Math.PI+.5;a.push(n,1-r)}p(),f()}function f(){for(let e=0;e<a.length;e+=6){const t=a[e+0],n=a[e+2],r=a[e+4],o=Math.max(t,n,r),i=Math.min(t,n,r);o>.9&&i<.1&&(t<.2&&(a[e+0]+=1),n<.2&&(a[e+2]+=1),r<.2&&(a[e+4]+=1))}}function u(e){o.push(e.x,e.y,e.z)}function d(t,n){const r=3*t;n.x=e[r+0],n.y=e[r+1],n.z=e[r+2]}function p(){const e=new xr,t=new xr,n=new xr,r=new xr,i=new ir,s=new ir,l=new ir;for(let c=0,f=0;c<o.length;c+=9,f+=6){e.set(o[c+0],o[c+1],o[c+2]),t.set(o[c+3],o[c+4],o[c+5]),n.set(o[c+6],o[c+7],o[c+8]),i.set(a[f+0],a[f+1]),s.set(a[f+2],a[f+3]),l.set(a[f+4],a[f+5]),r.copy(e).add(t).add(n).divideScalar(3);const u=v(r);h(i,f+0,e,u),h(s,f+2,t,u),h(l,f+4,n,u)}}function h(e,t,n,r){r<0&&1===e.x&&(a[t]=e.x-1),0===n.x&&0===n.z&&(a[t]=r/2/Math.PI+.5)}function v(e){return Math.atan2(e.z,-e.x)}function m(e){return Math.atan2(-e.y,Math.sqrt(e.x*e.x+e.z*e.z))}i(r),l(n),c(),this.setAttribute("position",new ra(o,3)),this.setAttribute("normal",new ra(o.slice(),3)),this.setAttribute("uv",new ra(a,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}}class Bc extends Gc{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,r=1/n;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-n,0,-r,n,0,r,-n,0,r,n,-r,-n,0,-r,n,0,r,-n,0,r,n,0,-n,0,-r,n,0,-r,-n,0,r,n,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}}const Vc=new xr,Wc=new xr,jc=new xr,qc=new zo;class Xc extends va{constructor(e,t){if(super(),this.type="EdgesGeometry",this.parameters={thresholdAngle:t},t=void 0!==t?t:1,!0===e.isGeometry)return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const n=4,r=Math.pow(10,n),o=Math.cos(Fn*t),a=e.getIndex(),i=e.getAttribute("position"),s=a?a.count:i.count,l=[0,0,0],c=["a","b","c"],f=new Array(3),u={},d=[];for(let e=0;e<s;e+=3){a?(l[0]=a.getX(e),l[1]=a.getX(e+1),l[2]=a.getX(e+2)):(l[0]=e,l[1]=e+1,l[2]=e+2);const{a:t,b:n,c:s}=qc;if(t.fromBufferAttribute(i,l[0]),n.fromBufferAttribute(i,l[1]),s.fromBufferAttribute(i,l[2]),qc.getNormal(jc),f[0]=`${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`,f[1]=`${Math.round(n.x*r)},${Math.round(n.y*r)},${Math.round(n.z*r)}`,f[2]=`${Math.round(s.x*r)},${Math.round(s.y*r)},${Math.round(s.z*r)}`,f[0]!==f[1]&&f[1]!==f[2]&&f[2]!==f[0])for(let e=0;e<3;e++){const t=(e+1)%3,n=f[e],r=f[t],a=qc[c[e]],i=qc[c[t]],s=`${n}_${r}`,p=`${r}_${n}`;p in u&&u[p]?(jc.dot(u[p].normal)<=o&&(d.push(a.x,a.y,a.z),d.push(i.x,i.y,i.z)),u[p]=null):s in u||(u[s]={index0:l[e],index1:l[t],normal:jc.clone()})}}for(const e in u)if(u[e]){const{index0:t,index1:n}=u[e];Vc.fromBufferAttribute(i,t),Wc.fromBufferAttribute(i,n),d.push(Vc.x,Vc.y,Vc.z),d.push(Wc.x,Wc.y,Wc.z)}this.setAttribute("position",new ra(d,3))}}const Yc={triangulate:function(e,t,n){n=n||2;const r=t&&t.length,o=r?t[0]*n:e.length;let a=Qc(e,0,o,n,!0);const i=[];if(!a||a.next===a.prev)return i;let s,l,c,f,u,d,p;if(r&&(a=nf(e,t,a,n)),e.length>80*n){s=c=e[0],l=f=e[1];for(let t=n;t<o;t+=n)u=e[t],d=e[t+1],u<s&&(s=u),d<l&&(l=d),u>c&&(c=u),d>f&&(f=d);p=Math.max(c-s,f-l),p=0!==p?1/p:0}return Zc(a,i,n,s,l,p),i}};function Qc(e,t,n,r,o){let a,i;if(o===Sf(e,t,n,r)>0)for(a=t;a<n;a+=r)i=_f(a,e[a],e[a+1],i);else for(a=n-r;a>=t;a-=r)i=_f(a,e[a],e[a+1],i);return i&&vf(i,i.next)&&(Tf(i),i=i.next),i}function Kc(e,t){if(!e)return e;t||(t=e);let n,r=e;do{if(n=!1,r.steiner||!vf(r,r.next)&&0!==hf(r.prev,r,r.next))r=r.next;else{if(Tf(r),r=t=r.prev,r===r.next)break;n=!0}}while(n||r!==t);return t}function Zc(e,t,n,r,o,a,i){if(!e)return;!i&&a&&lf(e,r,o,a);let s,l,c=e;for(;e.prev!==e.next;)if(s=e.prev,l=e.next,a?$c(e,r,o,a):Jc(e))t.push(s.i/n),t.push(e.i/n),t.push(l.i/n),Tf(e),e=l.next,c=l.next;else if((e=l)===c){i?1===i?Zc(e=ef(Kc(e),t,n),t,n,r,o,a,2):2===i&&tf(e,t,n,r,o,a):Zc(Kc(e),t,n,r,o,a,1);break}}function Jc(e){const t=e.prev,n=e,r=e.next;if(hf(t,n,r)>=0)return!1;let o=e.next.next;for(;o!==e.prev;){if(df(t.x,t.y,n.x,n.y,r.x,r.y,o.x,o.y)&&hf(o.prev,o,o.next)>=0)return!1;o=o.next}return!0}function $c(e,t,n,r){const o=e.prev,a=e,i=e.next;if(hf(o,a,i)>=0)return!1;const s=o.x<a.x?o.x<i.x?o.x:i.x:a.x<i.x?a.x:i.x,l=o.y<a.y?o.y<i.y?o.y:i.y:a.y<i.y?a.y:i.y,c=o.x>a.x?o.x>i.x?o.x:i.x:a.x>i.x?a.x:i.x,f=o.y>a.y?o.y>i.y?o.y:i.y:a.y>i.y?a.y:i.y,u=ff(s,l,t,n,r),d=ff(c,f,t,n,r);let p=e.prevZ,h=e.nextZ;for(;p&&p.z>=u&&h&&h.z<=d;){if(p!==e.prev&&p!==e.next&&df(o.x,o.y,a.x,a.y,i.x,i.y,p.x,p.y)&&hf(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,h!==e.prev&&h!==e.next&&df(o.x,o.y,a.x,a.y,i.x,i.y,h.x,h.y)&&hf(h.prev,h,h.next)>=0)return!1;h=h.nextZ}for(;p&&p.z>=u;){if(p!==e.prev&&p!==e.next&&df(o.x,o.y,a.x,a.y,i.x,i.y,p.x,p.y)&&hf(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;h&&h.z<=d;){if(h!==e.prev&&h!==e.next&&df(o.x,o.y,a.x,a.y,i.x,i.y,h.x,h.y)&&hf(h.prev,h,h.next)>=0)return!1;h=h.nextZ}return!0}function ef(e,t,n){let r=e;do{const o=r.prev,a=r.next.next;!vf(o,a)&&mf(o,r,r.next,a)&&Ef(o,a)&&Ef(a,o)&&(t.push(o.i/n),t.push(r.i/n),t.push(a.i/n),Tf(r),Tf(r.next),r=e=a),r=r.next}while(r!==e);return Kc(r)}function tf(e,t,n,r,o,a){let i=e;do{let e=i.next.next;for(;e!==i.prev;){if(i.i!==e.i&&pf(i,e)){let s=bf(i,e);return i=Kc(i,i.next),s=Kc(s,s.next),Zc(i,t,n,r,o,a),void Zc(s,t,n,r,o,a)}e=e.next}i=i.next}while(i!==e)}function nf(e,t,n,r){const o=[];let a,i,s,l,c;for(a=0,i=t.length;a<i;a++)s=t[a]*r,l=a<i-1?t[a+1]*r:e.length,c=Qc(e,s,l,r,!1),c===c.next&&(c.steiner=!0),o.push(uf(c));for(o.sort(rf),a=0;a<o.length;a++)of(o[a],n),n=Kc(n,n.next);return n}function rf(e,t){return e.x-t.x}function of(e,t){if(t=af(e,t)){const n=bf(t,e);Kc(t,t.next),Kc(n,n.next)}}function af(e,t){let n=t;const r=e.x,o=e.y;let a,i=-1/0;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){const e=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(e<=r&&e>i){if(i=e,e===r){if(o===n.y)return n;if(o===n.next.y)return n.next}a=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!a)return null;if(r===i)return a;const s=a,l=a.x,c=a.y;let f,u=1/0;n=a;do{r>=n.x&&n.x>=l&&r!==n.x&&df(o<c?r:i,o,l,c,o<c?i:r,o,n.x,n.y)&&(f=Math.abs(o-n.y)/(r-n.x),Ef(n,e)&&(f<u||f===u&&(n.x>a.x||n.x===a.x&&sf(a,n)))&&(a=n,u=f)),n=n.next}while(n!==s);return a}function sf(e,t){return hf(e.prev,e,t.prev)<0&&hf(t.next,e,e.next)<0}function lf(e,t,n,r){let o=e;do{null===o.z&&(o.z=ff(o.x,o.y,t,n,r)),o.prevZ=o.prev,o.nextZ=o.next,o=o.next}while(o!==e);o.prevZ.nextZ=null,o.prevZ=null,cf(o)}function cf(e){let t,n,r,o,a,i,s,l,c=1;do{for(n=e,e=null,a=null,i=0;n;){for(i++,r=n,s=0,t=0;t<c&&(s++,r=r.nextZ,r);t++);for(l=c;s>0||l>0&&r;)0!==s&&(0===l||!r||n.z<=r.z)?(o=n,n=n.nextZ,s--):(o=r,r=r.nextZ,l--),a?a.nextZ=o:e=o,o.prevZ=a,a=o;n=r}a.nextZ=null,c*=2}while(i>1);return e}function ff(e,t,n,r,o){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-n)*o)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*o)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function uf(e){let t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function df(e,t,n,r,o,a,i,s){return(o-i)*(t-s)-(e-i)*(a-s)>=0&&(e-i)*(r-s)-(n-i)*(t-s)>=0&&(n-i)*(a-s)-(o-i)*(r-s)>=0}function pf(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!yf(e,t)&&(Ef(e,t)&&Ef(t,e)&&wf(e,t)&&(hf(e.prev,e,t.prev)||hf(e,t.prev,t))||vf(e,t)&&hf(e.prev,e,e.next)>0&&hf(t.prev,t,t.next)>0)}function hf(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function vf(e,t){return e.x===t.x&&e.y===t.y}function mf(e,t,n,r){const o=gf(hf(e,t,n)),a=gf(hf(e,t,r)),i=gf(hf(n,r,e)),s=gf(hf(n,r,t));return o!==a&&i!==s||!(0!==o||!xf(e,n,t))||!(0!==a||!xf(e,r,t))||!(0!==i||!xf(n,e,r))||!(0!==s||!xf(n,t,r))}function xf(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function gf(e){return e>0?1:e<0?-1:0}function yf(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&mf(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}function Ef(e,t){return hf(e.prev,e,e.next)<0?hf(e,t,e.next)>=0&&hf(e,e.prev,t)>=0:hf(e,t,e.prev)<0||hf(e,e.next,t)<0}function wf(e,t){let n=e,r=!1;const o=(e.x+t.x)/2,a=(e.y+t.y)/2;do{n.y>a!=n.next.y>a&&n.next.y!==n.y&&o<(n.next.x-n.x)*(a-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}function bf(e,t){const n=new Af(e.i,e.x,e.y),r=new Af(t.i,t.x,t.y),o=e.next,a=t.prev;return e.next=t,t.prev=e,n.next=o,o.prev=n,r.next=n,n.prev=r,a.next=r,r.prev=a,r}function _f(e,t,n,r){const o=new Af(e,t,n);return r?(o.next=r.next,o.prev=r,r.next.prev=o,r.next=o):(o.prev=o,o.next=o),o}function Tf(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Af(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Sf(e,t,n,r){let o=0;for(let a=t,i=n-r;a<n;a+=r)o+=(e[i]-e[a])*(e[a+1]+e[i+1]),i=a;return o}class Rf{static area(e){const t=e.length;let n=0;for(let r=t-1,o=0;o<t;r=o++)n+=e[r].x*e[o].y-e[o].x*e[r].y;return.5*n}static isClockWise(e){return Rf.area(e)<0}static triangulateShape(e,t){const n=[],r=[],o=[];Mf(e),Cf(n,e);let a=e.length;t.forEach(Mf);for(let e=0;e<t.length;e++)r.push(a),a+=t[e].length,Cf(n,t[e]);const i=Yc.triangulate(n,r);for(let e=0;e<i.length;e+=3)o.push(i.slice(e,e+3));return o}}function Mf(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function Cf(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class Lf extends va{constructor(e,t){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,r=[],o=[];for(let t=0,n=e.length;t<n;t++)a(e[t]);function a(e){const a=[],i=void 0!==t.curveSegments?t.curveSegments:12,s=void 0!==t.steps?t.steps:1;let l=void 0!==t.depth?t.depth:100,c=void 0===t.bevelEnabled||t.bevelEnabled,f=void 0!==t.bevelThickness?t.bevelThickness:6,u=void 0!==t.bevelSize?t.bevelSize:f-2,d=void 0!==t.bevelOffset?t.bevelOffset:0,p=void 0!==t.bevelSegments?t.bevelSegments:3;const h=t.extrudePath,v=void 0!==t.UVGenerator?t.UVGenerator:Pf;void 0!==t.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),l=t.amount);let m,x,g,y,E,w=!1;h&&(m=h.getSpacedPoints(s),w=!0,c=!1,x=h.computeFrenetFrames(s,!1),g=new xr,y=new xr,E=new xr),c||(p=0,f=0,u=0,d=0);const b=e.extractPoints(i);let _=b.shape;const T=b.holes;if(!Rf.isClockWise(_)){_=_.reverse();for(let e=0,t=T.length;e<t;e++){const t=T[e];Rf.isClockWise(t)&&(T[e]=t.reverse())}}const A=Rf.triangulateShape(_,T),S=_;for(let e=0,t=T.length;e<t;e++){const t=T[e];_=_.concat(t)}function R(e,t,n){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(n).add(e)}const M=_.length,C=A.length;function L(e,t,n){let r,o,a;const i=e.x-t.x,s=e.y-t.y,l=n.x-e.x,c=n.y-e.y,f=i*i+s*s,u=i*c-s*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(f),d=Math.sqrt(l*l+c*c),p=t.x-s/u,h=t.y+i/u,v=((n.x-c/d-p)*c-(n.y+l/d-h)*l)/(i*c-s*l);r=p+i*v-e.x,o=h+s*v-e.y;const m=r*r+o*o;if(m<=2)return new ir(r,o);a=Math.sqrt(m/2)}else{let e=!1;i>Number.EPSILON?l>Number.EPSILON&&(e=!0):i<-Number.EPSILON?l<-Number.EPSILON&&(e=!0):Math.sign(s)===Math.sign(c)&&(e=!0),e?(r=-s,o=i,a=Math.sqrt(f)):(r=i,o=s,a=Math.sqrt(f/2))}return new ir(r/a,o/a)}const P=[];for(let e=0,t=S.length,n=t-1,r=e+1;e<t;e++,n++,r++)n===t&&(n=0),r===t&&(r=0),P[e]=L(S[e],S[n],S[r]);const k=[];let N,H=P.concat();for(let e=0,t=T.length;e<t;e++){const t=T[e];N=[];for(let e=0,n=t.length,r=n-1,o=e+1;e<n;e++,r++,o++)r===n&&(r=0),o===n&&(o=0),N[e]=L(t[e],t[r],t[o]);k.push(N),H=H.concat(N)}for(let e=0;e<p;e++){const t=e/p,n=f*Math.cos(t*Math.PI/2),r=u*Math.sin(t*Math.PI/2)+d;for(let e=0,t=S.length;e<t;e++){const t=R(S[e],P[e],r);O(t.x,t.y,-n)}for(let e=0,t=T.length;e<t;e++){const t=T[e];N=k[e];for(let e=0,o=t.length;e<o;e++){const o=R(t[e],N[e],r);O(o.x,o.y,-n)}}}const z=u+d;for(let e=0;e<M;e++){const t=c?R(_[e],H[e],z):_[e];w?(y.copy(x.normals[0]).multiplyScalar(t.x),g.copy(x.binormals[0]).multiplyScalar(t.y),E.copy(m[0]).add(y).add(g),O(E.x,E.y,E.z)):O(t.x,t.y,0)}for(let e=1;e<=s;e++)for(let t=0;t<M;t++){const n=c?R(_[t],H[t],z):_[t];w?(y.copy(x.normals[e]).multiplyScalar(n.x),g.copy(x.binormals[e]).multiplyScalar(n.y),E.copy(m[e]).add(y).add(g),O(E.x,E.y,E.z)):O(n.x,n.y,l/s*e)}for(let e=p-1;e>=0;e--){const t=e/p,n=f*Math.cos(t*Math.PI/2),r=u*Math.sin(t*Math.PI/2)+d;for(let e=0,t=S.length;e<t;e++){const t=R(S[e],P[e],r);O(t.x,t.y,l+n)}for(let e=0,t=T.length;e<t;e++){const t=T[e];N=k[e];for(let e=0,o=t.length;e<o;e++){const o=R(t[e],N[e],r);w?O(o.x,o.y+m[s-1].y,m[s-1].x+n):O(o.x,o.y,l+n)}}}function D(){const e=r.length/3;if(c){let e=0,t=M*e;for(let e=0;e<C;e++){const n=A[e];U(n[2]+t,n[1]+t,n[0]+t)}e=s+2*p,t=M*e;for(let e=0;e<C;e++){const n=A[e];U(n[0]+t,n[1]+t,n[2]+t)}}else{for(let e=0;e<C;e++){const t=A[e];U(t[2],t[1],t[0])}for(let e=0;e<C;e++){const t=A[e];U(t[0]+M*s,t[1]+M*s,t[2]+M*s)}}n.addGroup(e,r.length/3-e,0)}function F(){const e=r.length/3;let t=0;I(S,t),t+=S.length;for(let e=0,n=T.length;e<n;e++){const n=T[e];I(n,t),t+=n.length}n.addGroup(e,r.length/3-e,1)}function I(e,t){let n=e.length;for(;--n>=0;){const r=n;let o=n-1;o<0&&(o=e.length-1);for(let e=0,n=s+2*p;e<n;e++){const n=M*e,a=M*(e+1);G(t+r+n,t+o+n,t+o+a,t+r+a)}}}function O(e,t,n){a.push(e),a.push(t),a.push(n)}function U(e,t,o){B(e),B(t),B(o);const a=r.length/3,i=v.generateTopUV(n,r,a-3,a-2,a-1);V(i[0]),V(i[1]),V(i[2])}function G(e,t,o,a){B(e),B(t),B(a),B(t),B(o),B(a);const i=r.length/3,s=v.generateSideWallUV(n,r,i-6,i-3,i-2,i-1);V(s[0]),V(s[1]),V(s[3]),V(s[1]),V(s[2]),V(s[3])}function B(e){r.push(a[3*e+0]),r.push(a[3*e+1]),r.push(a[3*e+2])}function V(e){o.push(e.x),o.push(e.y)}D(),F()}this.setAttribute("position",new ra(r,3)),this.setAttribute("uv",new ra(o,2)),this.computeVertexNormals()}toJSON(){const e=va.prototype.toJSON.call(this);return kf(this.parameters.shapes,this.parameters.options,e)}}const Pf={generateTopUV:function(e,t,n,r,o){const a=t[3*n],i=t[3*n+1],s=t[3*r],l=t[3*r+1],c=t[3*o],f=t[3*o+1];return[new ir(a,i),new ir(s,l),new ir(c,f)]},generateSideWallUV:function(e,t,n,r,o,a){const i=t[3*n],s=t[3*n+1],l=t[3*n+2],c=t[3*r],f=t[3*r+1],u=t[3*r+2],d=t[3*o],p=t[3*o+1],h=t[3*o+2],v=t[3*a],m=t[3*a+1],x=t[3*a+2];return Math.abs(s-f)<.01?[new ir(i,1-l),new ir(c,1-u),new ir(d,1-h),new ir(v,1-x)]:[new ir(s,1-l),new ir(f,1-u),new ir(p,1-h),new ir(m,1-x)]}};function kf(e,t,n){if(n.shapes=[],Array.isArray(e))for(let t=0,r=e.length;t<r;t++){const r=e[t];n.shapes.push(r.uuid)}else n.shapes.push(e.uuid);return void 0!==t.extrudePath&&(n.options.extrudePath=t.extrudePath.toJSON()),n}class Nf extends Gc{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2;super([-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}}class Hf extends va{constructor(e,t=12,n=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:r},t=Math.floor(t),r=Un(r,0,2*Math.PI);const o=[],a=[],i=[],s=1/t,l=new xr,c=new ir;for(let o=0;o<=t;o++){const f=n+o*s*r,u=Math.sin(f),d=Math.cos(f);for(let n=0;n<=e.length-1;n++)l.x=e[n].x*u,l.y=e[n].y,l.z=e[n].x*d,a.push(l.x,l.y,l.z),c.x=o/t,c.y=n/(e.length-1),i.push(c.x,c.y)}for(let n=0;n<t;n++)for(let t=0;t<e.length-1;t++){const r=t+n*e.length,a=r,i=r+e.length,s=r+e.length+1,l=r+1;o.push(a,i,l),o.push(i,s,l)}if(this.setIndex(o),this.setAttribute("position",new ra(a,3)),this.setAttribute("uv",new ra(i,2)),this.computeVertexNormals(),r===2*Math.PI){const n=this.attributes.normal.array,r=new xr,o=new xr,a=new xr,i=t*e.length*3;for(let t=0,s=0;t<e.length;t++,s+=3)r.x=n[s+0],r.y=n[s+1],r.z=n[s+2],o.x=n[i+s+0],o.y=n[i+s+1],o.z=n[i+s+2],a.addVectors(r,o).normalize(),n[s+0]=n[i+s+0]=a.x,n[s+1]=n[i+s+1]=a.y,n[s+2]=n[i+s+2]=a.z}}}class zf extends Gc{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}}class Df extends va{constructor(e,t,n){super(),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n};const r=[],o=[],a=[],i=[],s=1e-5,l=new xr,c=new xr,f=new xr,u=new xr,d=new xr;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const p=t+1;for(let r=0;r<=n;r++){const p=r/n;for(let n=0;n<=t;n++){const r=n/t;e(r,p,c),o.push(c.x,c.y,c.z),r-s>=0?(e(r-s,p,f),u.subVectors(c,f)):(e(r+s,p,f),u.subVectors(f,c)),p-s>=0?(e(r,p-s,f),d.subVectors(c,f)):(e(r,p+s,f),d.subVectors(f,c)),l.crossVectors(u,d).normalize(),a.push(l.x,l.y,l.z),i.push(r,p)}}for(let e=0;e<n;e++)for(let n=0;n<t;n++){const t=e*p+n,o=e*p+n+1,a=(e+1)*p+n+1,i=(e+1)*p+n;r.push(t,o,i),r.push(o,a,i)}this.setIndex(r),this.setAttribute("position",new ra(o,3)),this.setAttribute("normal",new ra(a,3)),this.setAttribute("uv",new ra(i,2))}}class Ff extends va{constructor(e=.5,t=1,n=8,r=1,o=0,a=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:r,thetaStart:o,thetaLength:a},n=Math.max(3,n);const i=[],s=[],l=[],c=[];let f=e;const u=(t-e)/(r=Math.max(1,r)),d=new xr,p=new ir;for(let e=0;e<=r;e++){for(let e=0;e<=n;e++){const r=o+e/n*a;d.x=f*Math.cos(r),d.y=f*Math.sin(r),s.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,c.push(p.x,p.y)}f+=u}for(let e=0;e<r;e++){const t=e*(n+1);for(let e=0;e<n;e++){const r=e+t,o=r,a=r+n+1,s=r+n+2,l=r+1;i.push(o,a,l),i.push(a,s,l)}}this.setIndex(i),this.setAttribute("position",new ra(s,3)),this.setAttribute("normal",new ra(l,3)),this.setAttribute("uv",new ra(c,2))}}class If extends va{constructor(e,t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],r=[],o=[],a=[];let i=0,s=0;if(!1===Array.isArray(e))l(e);else for(let t=0;t<e.length;t++)l(e[t]),this.addGroup(i,s,t),i+=s,s=0;function l(e){const i=r.length/3,l=e.extractPoints(t);let c=l.shape;const f=l.holes;!1===Rf.isClockWise(c)&&(c=c.reverse());for(let e=0,t=f.length;e<t;e++){const t=f[e];!0===Rf.isClockWise(t)&&(f[e]=t.reverse())}const u=Rf.triangulateShape(c,f);for(let e=0,t=f.length;e<t;e++){const t=f[e];c=c.concat(t)}for(let e=0,t=c.length;e<t;e++){const t=c[e];r.push(t.x,t.y,0),o.push(0,0,1),a.push(t.x,t.y)}for(let e=0,t=u.length;e<t;e++){const t=u[e],r=t[0]+i,o=t[1]+i,a=t[2]+i;n.push(r,o,a),s+=3}}this.setIndex(n),this.setAttribute("position",new ra(r,3)),this.setAttribute("normal",new ra(o,3)),this.setAttribute("uv",new ra(a,2))}toJSON(){const e=va.prototype.toJSON.call(this);return Of(this.parameters.shapes,e)}}function Of(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,r=e.length;n<r;n++){const r=e[n];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}class Uf extends va{constructor(e=1,t=8,n=6,r=0,o=2*Math.PI,a=0,i=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:r,phiLength:o,thetaStart:a,thetaLength:i},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const s=Math.min(a+i,Math.PI);let l=0;const c=[],f=new xr,u=new xr,d=[],p=[],h=[],v=[];for(let d=0;d<=n;d++){const m=[],x=d/n;let g=0;0==d&&0==a?g=.5/t:d==n&&s==Math.PI&&(g=-.5/t);for(let n=0;n<=t;n++){const s=n/t;f.x=-e*Math.cos(r+s*o)*Math.sin(a+x*i),f.y=e*Math.cos(a+x*i),f.z=e*Math.sin(r+s*o)*Math.sin(a+x*i),p.push(f.x,f.y,f.z),u.copy(f).normalize(),h.push(u.x,u.y,u.z),v.push(s+g,1-x),m.push(l++)}c.push(m)}for(let e=0;e<n;e++)for(let r=0;r<t;r++){const t=c[e][r+1],o=c[e][r],i=c[e+1][r],l=c[e+1][r+1];(0!==e||a>0)&&d.push(t,o,l),(e!==n-1||s<Math.PI)&&d.push(o,i,l)}this.setIndex(d),this.setAttribute("position",new ra(p,3)),this.setAttribute("normal",new ra(h,3)),this.setAttribute("uv",new ra(v,2))}}class Gf extends Gc{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}}class Bf extends Lf{constructor(e,t={}){const n=t.font;if(!n||!n.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new va;const r=n.generateShapes(e,t.size);t.depth=void 0!==t.height?t.height:50,void 0===t.bevelThickness&&(t.bevelThickness=10),void 0===t.bevelSize&&(t.bevelSize=8),void 0===t.bevelEnabled&&(t.bevelEnabled=!1),super(r,t),this.type="TextGeometry"}}class Vf extends va{constructor(e=1,t=.4,n=8,r=6,o=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:r,arc:o},n=Math.floor(n),r=Math.floor(r);const a=[],i=[],s=[],l=[],c=new xr,f=new xr,u=new xr;for(let a=0;a<=n;a++)for(let d=0;d<=r;d++){const p=d/r*o,h=a/n*Math.PI*2;f.x=(e+t*Math.cos(h))*Math.cos(p),f.y=(e+t*Math.cos(h))*Math.sin(p),f.z=t*Math.sin(h),i.push(f.x,f.y,f.z),c.x=e*Math.cos(p),c.y=e*Math.sin(p),u.subVectors(f,c).normalize(),s.push(u.x,u.y,u.z),l.push(d/r),l.push(a/n)}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*e+t-1,o=(r+1)*(e-1)+t-1,i=(r+1)*(e-1)+t,s=(r+1)*e+t;a.push(n,o,s),a.push(o,i,s)}this.setIndex(a),this.setAttribute("position",new ra(i,3)),this.setAttribute("normal",new ra(s,3)),this.setAttribute("uv",new ra(l,2))}}class Wf extends va{constructor(e=1,t=.4,n=64,r=8,o=2,a=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:r,p:o,q:a},n=Math.floor(n),r=Math.floor(r);const i=[],s=[],l=[],c=[],f=new xr,u=new xr,d=new xr,p=new xr,h=new xr,v=new xr,m=new xr;for(let i=0;i<=n;++i){const g=i/n*o*Math.PI*2;x(g,o,a,e,d),x(g+.01,o,a,e,p),v.subVectors(p,d),m.addVectors(p,d),h.crossVectors(v,m),m.crossVectors(h,v),h.normalize(),m.normalize();for(let e=0;e<=r;++e){const o=e/r*Math.PI*2,a=-t*Math.cos(o),p=t*Math.sin(o);f.x=d.x+(a*m.x+p*h.x),f.y=d.y+(a*m.y+p*h.y),f.z=d.z+(a*m.z+p*h.z),s.push(f.x,f.y,f.z),u.subVectors(f,d).normalize(),l.push(u.x,u.y,u.z),c.push(i/n),c.push(e/r)}}for(let e=1;e<=n;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1),o=(r+1)*e+(t-1),a=(r+1)*e+t,s=(r+1)*(e-1)+t;i.push(n,o,s),i.push(o,a,s)}function x(e,t,n,r,o){const a=Math.cos(e),i=Math.sin(e),s=n/t*e,l=Math.cos(s);o.x=r*(2+l)*.5*a,o.y=r*(2+l)*i*.5,o.z=r*Math.sin(s)*.5}this.setIndex(i),this.setAttribute("position",new ra(s,3)),this.setAttribute("normal",new ra(l,3)),this.setAttribute("uv",new ra(c,2))}}class jf extends va{constructor(e,t=64,n=1,r=8,o=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:r,closed:o};const a=e.computeFrenetFrames(t,o);this.tangents=a.tangents,this.normals=a.normals,this.binormals=a.binormals;const i=new xr,s=new xr,l=new ir;let c=new xr;const f=[],u=[],d=[],p=[];function h(){for(let e=0;e<t;e++)v(e);v(!1===o?t:0),x(),m()}function v(o){c=e.getPointAt(o/t,c);const l=a.normals[o],d=a.binormals[o];for(let e=0;e<=r;e++){const t=e/r*Math.PI*2,o=Math.sin(t),a=-Math.cos(t);s.x=a*l.x+o*d.x,s.y=a*l.y+o*d.y,s.z=a*l.z+o*d.z,s.normalize(),u.push(s.x,s.y,s.z),i.x=c.x+n*s.x,i.y=c.y+n*s.y,i.z=c.z+n*s.z,f.push(i.x,i.y,i.z)}}function m(){for(let e=1;e<=t;e++)for(let t=1;t<=r;t++){const n=(r+1)*(e-1)+(t-1),o=(r+1)*e+(t-1),a=(r+1)*e+t,i=(r+1)*(e-1)+t;p.push(n,o,i),p.push(o,a,i)}}function x(){for(let e=0;e<=t;e++)for(let n=0;n<=r;n++)l.x=e/t,l.y=n/r,d.push(l.x,l.y)}h(),this.setIndex(p),this.setAttribute("position",new ra(f,3)),this.setAttribute("normal",new ra(u,3)),this.setAttribute("uv",new ra(d,2))}toJSON(){const e=va.prototype.toJSON.call(this);return e.path=this.parameters.path.toJSON(),e}}class qf extends va{constructor(e){if(super(),this.type="WireframeGeometry",!0===e.isGeometry)return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");const t=[],n=[0,0],r={},o=new xr;if(null!==e.index){const a=e.attributes.position,i=e.index;let s=e.groups;0===s.length&&(s=[{start:0,count:i.count,materialIndex:0}]);for(let e=0,t=s.length;e<t;++e){const t=s[e],o=t.start;for(let e=o,a=o+t.count;e<a;e+=3)for(let t=0;t<3;t++){const o=i.getX(e+t),a=i.getX(e+(t+1)%3);n[0]=Math.min(o,a),n[1]=Math.max(o,a);const s=n[0]+","+n[1];void 0===r[s]&&(r[s]={index1:n[0],index2:n[1]})}}for(const e in r){const n=r[e];o.fromBufferAttribute(a,n.index1),t.push(o.x,o.y,o.z),o.fromBufferAttribute(a,n.index2),t.push(o.x,o.y,o.z)}}else{const n=e.attributes.position;for(let e=0,r=n.count/3;e<r;e++)for(let r=0;r<3;r++){const a=3*e+r;o.fromBufferAttribute(n,a),t.push(o.x,o.y,o.z);const i=3*e+(r+1)%3;o.fromBufferAttribute(n,i),t.push(o.x,o.y,o.z)}}this.setAttribute("position",new ra(t,3))}}var Xf=Object.freeze({__proto__:null,BoxGeometry:Da,BoxBufferGeometry:Da,CircleGeometry:Ic,CircleBufferGeometry:Ic,ConeGeometry:Uc,ConeBufferGeometry:Uc,CylinderGeometry:Oc,CylinderBufferGeometry:Oc,DodecahedronGeometry:Bc,DodecahedronBufferGeometry:Bc,EdgesGeometry:Xc,ExtrudeGeometry:Lf,ExtrudeBufferGeometry:Lf,IcosahedronGeometry:Nf,IcosahedronBufferGeometry:Nf,LatheGeometry:Hf,LatheBufferGeometry:Hf,OctahedronGeometry:zf,OctahedronBufferGeometry:zf,ParametricGeometry:Df,ParametricBufferGeometry:Df,PlaneGeometry:ni,PlaneBufferGeometry:ni,PolyhedronGeometry:Gc,PolyhedronBufferGeometry:Gc,RingGeometry:Ff,RingBufferGeometry:Ff,ShapeGeometry:If,ShapeBufferGeometry:If,SphereGeometry:Uf,SphereBufferGeometry:Uf,TetrahedronGeometry:Gf,TetrahedronBufferGeometry:Gf,TextGeometry:Bf,TextBufferGeometry:Bf,TorusGeometry:Vf,TorusBufferGeometry:Vf,TorusKnotGeometry:Wf,TorusKnotBufferGeometry:Wf,TubeGeometry:jf,TubeBufferGeometry:jf,WireframeGeometry:qf});class Yf extends Fo{constructor(e){super(),this.type="ShadowMaterial",this.color=new Wo(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}Yf.prototype.isShadowMaterial=!0;class Qf extends Ba{constructor(e){super(e),this.type="RawShaderMaterial"}}Qf.prototype.isRawShaderMaterial=!0;class Kf extends Fo{constructor(e){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Wo(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Wo(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=on,this.normalScale=new ir(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.vertexTangents=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this.vertexTangents=e.vertexTangents,this}}Kf.prototype.isMeshStandardMaterial=!0;class Zf extends Kf{constructor(e){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new ir(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(e){this.reflectivity=Un(2.5*(e-1)/(e+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new Wo).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this}}Zf.prototype.isMeshPhysicalMaterial=!0;class Jf extends Fo{constructor(e){super(),this.type="MeshPhongMaterial",this.color=new Wo(16777215),this.specular=new Wo(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Wo(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=on,this.normalScale=new ir(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}Jf.prototype.isMeshPhongMaterial=!0;class $f extends Fo{constructor(e){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Wo(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Wo(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=on,this.normalScale=new ir(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}$f.prototype.isMeshToonMaterial=!0;class eu extends Fo{constructor(e){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=on,this.normalScale=new ir(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}eu.prototype.isMeshNormalMaterial=!0;class tu extends Fo{constructor(e){super(),this.type="MeshLambertMaterial",this.color=new Wo(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Wo(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=X,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this}}tu.prototype.isMeshLambertMaterial=!0;class nu extends Fo{constructor(e){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Wo(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=on,this.normalScale=new ir(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.flatShading=e.flatShading,this}}nu.prototype.isMeshMatcapMaterial=!0;class ru extends mc{constructor(e){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}ru.prototype.isLineDashedMaterial=!0;var ou=Object.freeze({__proto__:null,ShadowMaterial:Yf,SpriteMaterial:Dl,RawShaderMaterial:Qf,ShaderMaterial:Ba,PointsMaterial:Rc,MeshPhysicalMaterial:Zf,MeshStandardMaterial:Kf,MeshPhongMaterial:Jf,MeshToonMaterial:$f,MeshNormalMaterial:eu,MeshLambertMaterial:tu,MeshDepthMaterial:pl,MeshDistanceMaterial:hl,MeshBasicMaterial:jo,MeshMatcapMaterial:nu,LineDashedMaterial:ru,LineBasicMaterial:mc,Material:Fo});const au={arraySlice:function(e,t,n){return au.isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==n?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:"number"==typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function t(t,n){return e[t]-e[n]}const n=e.length,r=new Array(n);for(let e=0;e!==n;++e)r[e]=e;return r.sort(t),r},sortedArray:function(e,t,n){const r=e.length,o=new e.constructor(r);for(let a=0,i=0;i!==r;++a){const r=n[a]*t;for(let n=0;n!==t;++n)o[i++]=e[r+n]}return o},flattenJSON:function(e,t,n,r){let o=1,a=e[0];for(;void 0!==a&&void 0===a[r];)a=e[o++];if(void 0===a)return;let i=a[r];if(void 0!==i)if(Array.isArray(i))do{i=a[r],void 0!==i&&(t.push(a.time),n.push.apply(n,i)),a=e[o++]}while(void 0!==a);else if(void 0!==i.toArray)do{i=a[r],void 0!==i&&(t.push(a.time),i.toArray(n,n.length)),a=e[o++]}while(void 0!==a);else do{i=a[r],void 0!==i&&(t.push(a.time),n.push(i)),a=e[o++]}while(void 0!==a)},subclip:function(e,t,n,r,o=30){const a=e.clone();a.name=t;const i=[];for(let e=0;e<a.tracks.length;++e){const t=a.tracks[e],s=t.getValueSize(),l=[],c=[];for(let e=0;e<t.times.length;++e){const a=t.times[e]*o;if(!(a<n||a>=r)){l.push(t.times[e]);for(let n=0;n<s;++n)c.push(t.values[e*s+n])}}0!==l.length&&(t.times=au.convertArray(l,t.times.constructor),t.values=au.convertArray(c,t.values.constructor),i.push(t))}a.tracks=i;let s=1/0;for(let e=0;e<a.tracks.length;++e)s>a.tracks[e].times[0]&&(s=a.tracks[e].times[0]);for(let e=0;e<a.tracks.length;++e)a.tracks[e].shift(-1*s);return a.resetDuration(),a},makeClipAdditive:function(e,t=0,n=e,r=30){r<=0&&(r=30);const o=n.tracks.length,a=t/r;for(let t=0;t<o;++t){const r=n.tracks[t],o=r.ValueTypeName;if("bool"===o||"string"===o)continue;const i=e.tracks.find((function(e){return e.name===r.name&&e.ValueTypeName===o}));if(void 0===i)continue;let s=0;const l=r.getValueSize();r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(s=l/3);let c=0;const f=i.getValueSize();i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=f/3);const u=r.times.length-1;let d;if(a<=r.times[0]){const e=s,t=l-s;d=au.arraySlice(r.values,e,t)}else if(a>=r.times[u]){const e=u*l+s,t=e+l-s;d=au.arraySlice(r.values,e,t)}else{const e=r.createInterpolant(),t=s,n=l-s;e.evaluate(a),d=au.arraySlice(e.resultBuffer,t,n)}"quaternion"===o&&(new mr).fromArray(d).normalize().conjugate().toArray(d);const p=i.times.length;for(let e=0;e<p;++e){const t=e*f+c;if("quaternion"===o)mr.multiplyQuaternionsFlat(i.values,t,d,0,i.values,t);else{const e=f-2*c;for(let n=0;n<e;++n)i.values[t+n]-=d[n]}}}return e.blendMode=Wt,e}};class iu{constructor(e,t,n,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,r=t[n],o=t[n-1];e:{t:{let a;n:{r:if(!(e<r)){for(let a=n+2;;){if(void 0===r){if(e<o)break r;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,o)}if(n===a)break;if(o=r,r=t[++n],e<r)break t}a=t.length;break n}if(e>=o)break e;{const i=t[1];e<i&&(n=2,o=i);for(let a=n-2;;){if(void 0===o)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(n===a)break;if(r=o,o=t[--n-1],e>=o)break t}a=n,n=0}}for(;n<a;){const r=n+a>>>1;e<t[r]?a=r:n=r+1}if(r=t[n],o=t[n-1],void 0===o)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(void 0===r)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,o,e)}this._cachedIndex=n,this.intervalChanged_(n,o,r)}return this.interpolate_(n,o,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,r=this.valueSize,o=e*r;for(let e=0;e!==r;++e)t[e]=n[o+e];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}iu.prototype.beforeStart_=iu.prototype.copySampleValue_,iu.prototype.afterEnd_=iu.prototype.copySampleValue_;class su extends iu{constructor(e,t,n,r){super(e,t,n,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ut,endingEnd:Ut}}intervalChanged_(e,t,n){const r=this.parameterPositions;let o=e-2,a=e+1,i=r[o],s=r[a];if(void 0===i)switch(this.getSettings_().endingStart){case Gt:o=e,i=2*t-n;break;case Bt:o=r.length-2,i=t+r[o]-r[o+1];break;default:o=e,i=n}if(void 0===s)switch(this.getSettings_().endingEnd){case Gt:a=e,s=2*n-t;break;case Bt:a=1,s=n+r[1]-r[0];break;default:a=e-1,s=t}const l=.5*(n-t),c=this.valueSize;this._weightPrev=l/(t-i),this._weightNext=l/(s-n),this._offsetPrev=o*c,this._offsetNext=a*c}interpolate_(e,t,n,r){const o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,s=e*i,l=s-i,c=this._offsetPrev,f=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(n-t)/(r-t),h=p*p,v=h*p,m=-u*v+2*u*h-u*p,x=(1+u)*v+(-1.5-2*u)*h+(-.5+u)*p+1,g=(-1-d)*v+(1.5+d)*h+.5*p,y=d*v-d*h;for(let e=0;e!==i;++e)o[e]=m*a[c+e]+x*a[l+e]+g*a[s+e]+y*a[f+e];return o}}class lu extends iu{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,s=e*i,l=s-i,c=(n-t)/(r-t),f=1-c;for(let e=0;e!==i;++e)o[e]=a[l+e]*f+a[s+e]*c;return o}}class cu extends iu{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class fu{constructor(e,t,n,r){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=au.convertArray(t,this.TimeBufferType),this.values=au.convertArray(n,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:au.convertArray(e.times,Array),values:au.convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(n.interpolation=t)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new cu(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new lu(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new su(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Ft:t=this.InterpolantFactoryMethodDiscrete;break;case It:t=this.InterpolantFactoryMethodLinear;break;case Ot:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ft;case this.InterpolantFactoryMethodLinear:return It;case this.InterpolantFactoryMethodSmooth:return Ot}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let n=0,r=t.length;n!==r;++n)t[n]*=e}return this}trim(e,t){const n=this.times,r=n.length;let o=0,a=r-1;for(;o!==r&&n[o]<e;)++o;for(;-1!==a&&n[a]>t;)--a;if(++a,0!==o||a!==r){o>=a&&(a=Math.max(a,1),o=a-1);const e=this.getValueSize();this.times=au.arraySlice(n,o,a),this.values=au.arraySlice(this.values,o*e,a*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,r=this.values,o=n.length;0===o&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let t=0;t!==o;t++){const r=n[t];if("number"==typeof r&&isNaN(r)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,t,r),e=!1;break}if(null!==a&&a>r){console.error("THREE.KeyframeTrack: Out of order keys.",this,t,r,a),e=!1;break}a=r}if(void 0!==r&&au.isTypedArray(r))for(let t=0,n=r.length;t!==n;++t){const n=r[t];if(isNaN(n)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,t,n),e=!1;break}}return e}optimize(){const e=au.arraySlice(this.times),t=au.arraySlice(this.values),n=this.getValueSize(),r=this.getInterpolation()===Ot,o=e.length-1;let a=1;for(let i=1;i<o;++i){let o=!1;const s=e[i];if(s!==e[i+1]&&(1!==i||s!==e[0]))if(r)o=!0;else{const e=i*n,r=e-n,a=e+n;for(let i=0;i!==n;++i){const n=t[e+i];if(n!==t[r+i]||n!==t[a+i]){o=!0;break}}}if(o){if(i!==a){e[a]=e[i];const r=i*n,o=a*n;for(let e=0;e!==n;++e)t[o+e]=t[r+e]}++a}}if(o>0){e[a]=e[o];for(let e=o*n,r=a*n,i=0;i!==n;++i)t[r+i]=t[e+i];++a}return a!==e.length?(this.times=au.arraySlice(e,0,a),this.values=au.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=au.arraySlice(this.times,0),t=au.arraySlice(this.values,0),n=new(0,this.constructor)(this.name,e,t);return n.createInterpolant=this.createInterpolant,n}}fu.prototype.TimeBufferType=Float32Array,fu.prototype.ValueBufferType=Float32Array,fu.prototype.DefaultInterpolation=It;class uu extends fu{}uu.prototype.ValueTypeName="bool",uu.prototype.ValueBufferType=Array,uu.prototype.DefaultInterpolation=Ft,uu.prototype.InterpolantFactoryMethodLinear=void 0,uu.prototype.InterpolantFactoryMethodSmooth=void 0;class du extends fu{}du.prototype.ValueTypeName="color";class pu extends fu{}pu.prototype.ValueTypeName="number";class hu extends iu{constructor(e,t,n,r){super(e,t,n,r)}interpolate_(e,t,n,r){const o=this.resultBuffer,a=this.sampleValues,i=this.valueSize,s=(n-t)/(r-t);let l=e*i;for(let e=l+i;l!==e;l+=4)mr.slerpFlat(o,0,a,l-i,a,l,s);return o}}class vu extends fu{InterpolantFactoryMethodLinear(e){return new hu(this.times,this.values,this.getValueSize(),e)}}vu.prototype.ValueTypeName="quaternion",vu.prototype.DefaultInterpolation=It,vu.prototype.InterpolantFactoryMethodSmooth=void 0;class mu extends fu{}mu.prototype.ValueTypeName="string",mu.prototype.ValueBufferType=Array,mu.prototype.DefaultInterpolation=Ft,mu.prototype.InterpolantFactoryMethodLinear=void 0,mu.prototype.InterpolantFactoryMethodSmooth=void 0;class xu extends fu{}xu.prototype.ValueTypeName="vector";class gu{constructor(e,t=-1,n,r=Vt){this.name=e,this.tracks=n,this.duration=t,this.blendMode=r,this.uuid=On(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,r=1/(e.fps||1);for(let e=0,o=n.length;e!==o;++e)t.push(Eu(n[e]).scale(r));const o=new this(e.name,e.duration,t,e.blendMode);return o.uuid=e.uuid,o}static toJSON(e){const t=[],n=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let e=0,r=n.length;e!==r;++e)t.push(fu.toJSON(n[e]));return r}static CreateFromMorphTargetSequence(e,t,n,r){const o=t.length,a=[];for(let e=0;e<o;e++){let i=[],s=[];i.push((e+o-1)%o,e,(e+1)%o),s.push(0,1,0);const l=au.getKeyframeOrder(i);i=au.sortedArray(i,1,l),s=au.sortedArray(s,1,l),r||0!==i[0]||(i.push(o),s.push(s[0])),a.push(new pu(".morphTargetInfluences["+t[e].name+"]",i,s).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const t=e;n=t.geometry&&t.geometry.animations||t.animations}for(let e=0;e<n.length;e++)if(n[e].name===t)return n[e];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const r={},o=/^([\w-]*?)([\d]+)$/;for(let t=0,n=e.length;t<n;t++){const n=e[t],a=n.name.match(o);if(a&&a.length>1){const e=a[1];let t=r[e];t||(r[e]=t=[]),t.push(n)}}const a=[];for(const e in r)a.push(this.CreateFromMorphTargetSequence(e,r[e],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(e,t,n,r,o){if(0!==n.length){const a=[],i=[];au.flattenJSON(n,a,i,r),0!==a.length&&o.push(new e(t,a,i))}},r=[],o=e.name||"default",a=e.fps||30,i=e.blendMode;let s=e.length||-1;const l=e.hierarchy||[];for(let e=0;e<l.length;e++){const o=l[e].keys;if(o&&0!==o.length)if(o[0].morphTargets){const e={};let t;for(t=0;t<o.length;t++)if(o[t].morphTargets)for(let n=0;n<o[t].morphTargets.length;n++)e[o[t].morphTargets[n]]=-1;for(const n in e){const e=[],a=[];for(let r=0;r!==o[t].morphTargets.length;++r){const r=o[t];e.push(r.time),a.push(r.morphTarget===n?1:0)}r.push(new pu(".morphTargetInfluence["+n+"]",e,a))}s=e.length*(a||1)}else{const a=".bones["+t[e].name+"]";n(xu,a+".position",o,"pos",r),n(vu,a+".quaternion",o,"rot",r),n(xu,a+".scale",o,"scl",r)}}return 0===r.length?null:new this(o,s,r,i)}resetDuration(){let e=0;for(let t=0,n=this.tracks.length;t!==n;++t){const n=this.tracks[t];e=Math.max(e,n.times[n.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function yu(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return pu;case"vector":case"vector2":case"vector3":case"vector4":return xu;case"color":return du;case"quaternion":return vu;case"bool":case"boolean":return uu;case"string":return mu}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function Eu(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=yu(e.type);if(void 0===e.times){const t=[],n=[];au.flattenJSON(e.keys,t,n,"value"),e.times=t,e.values=n}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const wu={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class bu{constructor(e,t,n){const r=this;let o,a=!1,i=0,s=0;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(e){s++,!1===a&&void 0!==r.onStart&&r.onStart(e,i,s),a=!0},this.itemEnd=function(e){i++,void 0!==r.onProgress&&r.onProgress(e,i,s),i===s&&(a=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(e){void 0!==r.onError&&r.onError(e)},this.resolveURL=function(e){return o?o(e):e},this.setURLModifier=function(e){return o=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){const t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,n=l.length;t<n;t+=2){const n=l[t],r=l[t+1];if(n.global&&(n.lastIndex=0),n.test(e))return r}return null}}}const _u=new bu;class Tu{constructor(e){this.manager=void 0!==e?e:_u,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise((function(r,o){n.load(e,r,t,o)}))}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Au={};class Su extends Tu{constructor(e){super(e)}load(e,t,n,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,a=wu.get(e);if(void 0!==a)return o.manager.itemStart(e),setTimeout((function(){t&&t(a),o.manager.itemEnd(e)}),0),a;if(void 0!==Au[e])return void Au[e].push({onLoad:t,onProgress:n,onError:r});const i=/^data:(.*?)(;base64)?,(.*)$/,s=e.match(i);let l;if(s){const n=s[1],a=!!s[2];let i=s[3];i=decodeURIComponent(i),a&&(i=atob(i));try{let r;const a=(this.responseType||"").toLowerCase();switch(a){case"arraybuffer":case"blob":const e=new Uint8Array(i.length);for(let t=0;t<i.length;t++)e[t]=i.charCodeAt(t);r="blob"===a?new Blob([e.buffer],{type:n}):e.buffer;break;case"document":const t=new DOMParser;r=t.parseFromString(i,n);break;case"json":r=JSON.parse(i);break;default:r=i}setTimeout((function(){t&&t(r),o.manager.itemEnd(e)}),0)}catch(t){setTimeout((function(){r&&r(t),o.manager.itemError(e),o.manager.itemEnd(e)}),0)}}else{Au[e]=[],Au[e].push({onLoad:t,onProgress:n,onError:r}),l=new XMLHttpRequest,l.open("GET",e,!0),l.addEventListener("load",(function(t){const n=this.response,r=Au[e];if(delete Au[e],200===this.status||0===this.status){0===this.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),wu.add(e,n);for(let e=0,t=r.length;e<t;e++){const t=r[e];t.onLoad&&t.onLoad(n)}o.manager.itemEnd(e)}else{for(let e=0,n=r.length;e<n;e++){const n=r[e];n.onError&&n.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}}),!1),l.addEventListener("progress",(function(t){const n=Au[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onProgress&&r.onProgress(t)}}),!1),l.addEventListener("error",(function(t){const n=Au[e];delete Au[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onError&&r.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}),!1),l.addEventListener("abort",(function(t){const n=Au[e];delete Au[e];for(let e=0,r=n.length;e<r;e++){const r=n[e];r.onError&&r.onError(t)}o.manager.itemError(e),o.manager.itemEnd(e)}),!1),void 0!==this.responseType&&(l.responseType=this.responseType),void 0!==this.withCredentials&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(void 0!==this.mimeType?this.mimeType:"text/plain");for(const e in this.requestHeader)l.setRequestHeader(e,this.requestHeader[e]);l.send(null)}return o.manager.itemStart(e),l}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Ru extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new Su(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t=[];for(let n=0;n<e.length;n++){const r=gu.parse(e[n]);t.push(r)}return t}}class Mu extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=[],i=new zc,s=new Su(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(o.withCredentials);let l=0;function c(c){s.load(e[c],(function(e){const n=o.parse(e,!0);a[c]={width:n.width,height:n.height,format:n.format,mipmaps:n.mipmaps},l+=1,6===l&&(1===n.mipmapCount&&(i.minFilter=xe),i.image=a,i.format=n.format,i.needsUpdate=!0,t&&t(i))}),n,r)}if(Array.isArray(e))for(let t=0,n=e.length;t<n;++t)c(t);else s.load(e,(function(e){const n=o.parse(e,!0);if(n.isCubemap){const e=n.mipmaps.length/n.mipmapCount;for(let t=0;t<e;t++){a[t]={mipmaps:[]};for(let e=0;e<n.mipmapCount;e++)a[t].mipmaps.push(n.mipmaps[t*n.mipmapCount+e]),a[t].format=n.format,a[t].width=n.width,a[t].height=n.height}i.image=a}else i.image.width=n.width,i.image.height=n.height,i.mipmaps=n.mipmaps;1===n.mipmapCount&&(i.minFilter=xe),i.format=n.format,i.needsUpdate=!0,t&&t(i)}),n,r);return i}}class Cu extends Tu{constructor(e){super(e)}load(e,t,n,r){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,a=wu.get(e);if(void 0!==a)return o.manager.itemStart(e),setTimeout((function(){t&&t(a),o.manager.itemEnd(e)}),0),a;const i=document.createElementNS("http://www.w3.org/1999/xhtml","img");function s(){i.removeEventListener("load",s,!1),i.removeEventListener("error",l,!1),wu.add(e,this),t&&t(this),o.manager.itemEnd(e)}function l(t){i.removeEventListener("load",s,!1),i.removeEventListener("error",l,!1),r&&r(t),o.manager.itemError(e),o.manager.itemEnd(e)}return i.addEventListener("load",s,!1),i.addEventListener("error",l,!1),"data:"!==e.substr(0,5)&&void 0!==this.crossOrigin&&(i.crossOrigin=this.crossOrigin),o.manager.itemStart(e),i.src=e,i}}class Lu extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=new Ya,a=new Cu(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let i=0;function s(n){a.load(e[n],(function(e){o.images[n]=e,i++,6===i&&(o.needsUpdate=!0,t&&t(o))}),void 0,r)}for(let t=0;t<e.length;++t)s(t);return o}}class Pu extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new Ka,i=new Su(this.manager);return i.setResponseType("arraybuffer"),i.setRequestHeader(this.requestHeader),i.setPath(this.path),i.setWithCredentials(o.withCredentials),i.load(e,(function(e){const n=o.parse(e);n&&(void 0!==n.image?a.image=n.image:void 0!==n.data&&(a.image.width=n.width,a.image.height=n.height,a.image.data=n.data),a.wrapS=void 0!==n.wrapS?n.wrapS:fe,a.wrapT=void 0!==n.wrapT?n.wrapT:fe,a.magFilter=void 0!==n.magFilter?n.magFilter:xe,a.minFilter=void 0!==n.minFilter?n.minFilter:xe,a.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(a.encoding=n.encoding),void 0!==n.flipY&&(a.flipY=n.flipY),void 0!==n.format&&(a.format=n.format),void 0!==n.type&&(a.type=n.type),void 0!==n.mipmaps&&(a.mipmaps=n.mipmaps,a.minFilter=Ee),1===n.mipmapCount&&(a.minFilter=xe),void 0!==n.generateMipmaps&&(a.generateMipmaps=n.generateMipmaps),a.needsUpdate=!0,t&&t(a,n))}),n,r),a}}class ku extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=new ur,a=new Cu(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,(function(n){o.image=n;const r=e.search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/);o.format=r?ze:De,o.needsUpdate=!0,void 0!==t&&t(o)}),n,r),o}}class Nu{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,r=this.getPoint(0),o=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),o+=n.distanceTo(r),t.push(o),r=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let r=0;const o=n.length;let a;a=t||e*n[o-1];let i,s=0,l=o-1;for(;s<=l;)if(r=Math.floor(s+(l-s)/2),i=n[r]-a,i<0)s=r+1;else{if(!(i>0)){l=r;break}l=r-1}if(r=l,n[r]===a)return r/(o-1);const c=n[r];return(r+(a-c)/(n[r+1]-c))/(o-1)}getTangent(e,t){const n=1e-4;let r=e-n,o=e+n;r<0&&(r=0),o>1&&(o=1);const a=this.getPoint(r),i=this.getPoint(o),s=t||(a.isVector2?new ir:new xr);return s.copy(i).sub(a).normalize(),s}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new xr,r=[],o=[],a=[],i=new xr,s=new Yr;for(let t=0;t<=e;t++){const n=t/e;r[t]=this.getTangentAt(n,new xr),r[t].normalize()}o[0]=new xr,a[0]=new xr;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),f=Math.abs(r[0].y),u=Math.abs(r[0].z);c<=l&&(l=c,n.set(1,0,0)),f<=l&&(l=f,n.set(0,1,0)),u<=l&&n.set(0,0,1),i.crossVectors(r[0],n).normalize(),o[0].crossVectors(r[0],i),a[0].crossVectors(r[0],o[0]);for(let t=1;t<=e;t++){if(o[t]=o[t-1].clone(),a[t]=a[t-1].clone(),i.crossVectors(r[t-1],r[t]),i.length()>Number.EPSILON){i.normalize();const e=Math.acos(Un(r[t-1].dot(r[t]),-1,1));o[t].applyMatrix4(s.makeRotationAxis(i,e))}a[t].crossVectors(r[t],o[t])}if(!0===t){let t=Math.acos(Un(o[0].dot(o[e]),-1,1));t/=e,r[0].dot(i.crossVectors(o[0],o[e]))>0&&(t=-t);for(let n=1;n<=e;n++)o[n].applyMatrix4(s.makeRotationAxis(r[n],t*n)),a[n].crossVectors(r[n],o[n])}return{tangents:r,normals:o,binormals:a}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Hu extends Nu{constructor(e=0,t=0,n=1,r=1,o=0,a=2*Math.PI,i=!1,s=0){super(),this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=r,this.aStartAngle=o,this.aEndAngle=a,this.aClockwise=i,this.aRotation=s}getPoint(e,t){const n=t||new ir,r=2*Math.PI;let o=this.aEndAngle-this.aStartAngle;const a=Math.abs(o)<Number.EPSILON;for(;o<0;)o+=r;for(;o>r;)o-=r;o<Number.EPSILON&&(o=a?0:r),!0!==this.aClockwise||a||(o===r?o=-r:o-=r);const i=this.aStartAngle+e*o;let s=this.aX+this.xRadius*Math.cos(i),l=this.aY+this.yRadius*Math.sin(i);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),n=s-this.aX,r=l-this.aY;s=n*e-r*t+this.aX,l=n*t+r*e+this.aY}return n.set(s,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Hu.prototype.isEllipseCurve=!0;class zu extends Hu{constructor(e,t,n,r,o,a){super(e,t,n,n,r,o,a),this.type="ArcCurve"}}function Du(){let e=0,t=0,n=0,r=0;function o(o,a,i,s){e=o,t=i,n=-3*o+3*a-2*i-s,r=2*o-2*a+i+s}return{initCatmullRom:function(e,t,n,r,a){o(t,n,a*(n-e),a*(r-t))},initNonuniformCatmullRom:function(e,t,n,r,a,i,s){let l=(t-e)/a-(n-e)/(a+i)+(n-t)/i,c=(n-t)/i-(r-t)/(i+s)+(r-n)/s;l*=i,c*=i,o(t,n,l,c)},calc:function(o){const a=o*o;return e+t*o+n*a+r*(a*o)}}}zu.prototype.isArcCurve=!0;const Fu=new xr,Iu=new Du,Ou=new Du,Uu=new Du;class Gu extends Nu{constructor(e=[],t=!1,n="centripetal",r=.5){super(),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=r}getPoint(e,t=new xr){const n=t,r=this.points,o=r.length,a=(o-(this.closed?0:1))*e;let i,s,l=Math.floor(a),c=a-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/o)+1)*o:0===c&&l===o-1&&(l=o-2,c=1),this.closed||l>0?i=r[(l-1)%o]:(Fu.subVectors(r[0],r[1]).add(r[0]),i=Fu);const f=r[l%o],u=r[(l+1)%o];if(this.closed||l+2<o?s=r[(l+2)%o]:(Fu.subVectors(r[o-1],r[o-2]).add(r[o-1]),s=Fu),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(i.distanceToSquared(f),e),n=Math.pow(f.distanceToSquared(u),e),r=Math.pow(u.distanceToSquared(s),e);n<1e-4&&(n=1),t<1e-4&&(t=n),r<1e-4&&(r=n),Iu.initNonuniformCatmullRom(i.x,f.x,u.x,s.x,t,n,r),Ou.initNonuniformCatmullRom(i.y,f.y,u.y,s.y,t,n,r),Uu.initNonuniformCatmullRom(i.z,f.z,u.z,s.z,t,n,r)}else"catmullrom"===this.curveType&&(Iu.initCatmullRom(i.x,f.x,u.x,s.x,this.tension),Ou.initCatmullRom(i.y,f.y,u.y,s.y,this.tension),Uu.initCatmullRom(i.z,f.z,u.z,s.z,this.tension));return n.set(Iu.calc(c),Ou.calc(c),Uu.calc(c)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new xr).fromArray(n))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function Bu(e,t,n,r,o){const a=.5*(r-t),i=.5*(o-n),s=e*e;return(2*n-2*r+a+i)*(e*s)+(-3*n+3*r-2*a-i)*s+a*e+n}function Vu(e,t){const n=1-e;return n*n*t}function Wu(e,t){return 2*(1-e)*e*t}function ju(e,t){return e*e*t}function qu(e,t,n,r){return Vu(e,t)+Wu(e,n)+ju(e,r)}function Xu(e,t){const n=1-e;return n*n*n*t}function Yu(e,t){const n=1-e;return 3*n*n*e*t}function Qu(e,t){return 3*(1-e)*e*e*t}function Ku(e,t){return e*e*e*t}function Zu(e,t,n,r,o){return Xu(e,t)+Yu(e,n)+Qu(e,r)+Ku(e,o)}Gu.prototype.isCatmullRomCurve3=!0;class Ju extends Nu{constructor(e=new ir,t=new ir,n=new ir,r=new ir){super(),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new ir){const n=t,r=this.v0,o=this.v1,a=this.v2,i=this.v3;return n.set(Zu(e,r.x,o.x,a.x,i.x),Zu(e,r.y,o.y,a.y,i.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Ju.prototype.isCubicBezierCurve=!0;class $u extends Nu{constructor(e=new xr,t=new xr,n=new xr,r=new xr){super(),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=r}getPoint(e,t=new xr){const n=t,r=this.v0,o=this.v1,a=this.v2,i=this.v3;return n.set(Zu(e,r.x,o.x,a.x,i.x),Zu(e,r.y,o.y,a.y,i.y),Zu(e,r.z,o.z,a.z,i.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}$u.prototype.isCubicBezierCurve3=!0;class ed extends Nu{constructor(e=new ir,t=new ir){super(),this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new ir){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new ir;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}ed.prototype.isLineCurve=!0;class td extends Nu{constructor(e=new xr,t=new xr){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new xr){const n=t;return 1===e?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class nd extends Nu{constructor(e=new ir,t=new ir,n=new ir){super(),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new ir){const n=t,r=this.v0,o=this.v1,a=this.v2;return n.set(qu(e,r.x,o.x,a.x),qu(e,r.y,o.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}nd.prototype.isQuadraticBezierCurve=!0;class rd extends Nu{constructor(e=new xr,t=new xr,n=new xr){super(),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new xr){const n=t,r=this.v0,o=this.v1,a=this.v2;return n.set(qu(e,r.x,o.x,a.x),qu(e,r.y,o.y,a.y),qu(e,r.z,o.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}rd.prototype.isQuadraticBezierCurve3=!0;class od extends Nu{constructor(e=[]){super(),this.type="SplineCurve",this.points=e}getPoint(e,t=new ir){const n=t,r=this.points,o=(r.length-1)*e,a=Math.floor(o),i=o-a,s=r[0===a?a:a-1],l=r[a],c=r[a>r.length-2?r.length-1:a+1],f=r[a>r.length-3?r.length-1:a+2];return n.set(Bu(i,s.x,l.x,c.x,f.x),Bu(i,s.y,l.y,c.y,f.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const n=this.points[t];e.points.push(n.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const n=e.points[t];this.points.push((new ir).fromArray(n))}return this}}od.prototype.isSplineCurve=!0;var ad=Object.freeze({__proto__:null,ArcCurve:zu,CatmullRomCurve3:Gu,CubicBezierCurve:Ju,CubicBezierCurve3:$u,EllipseCurve:Hu,LineCurve:ed,LineCurve3:td,QuadraticBezierCurve:nd,QuadraticBezierCurve3:rd,SplineCurve:od});class id extends Nu{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new ed(t,e))}getPoint(e){const t=e*this.getLength(),n=this.getCurveLengths();let r=0;for(;r<n.length;){if(n[r]>=t){const e=n[r]-t,o=this.curves[r],a=o.getLength(),i=0===a?0:1-e/a;return o.getPointAt(i)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,r=this.curves.length;n<r;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let r=0,o=this.curves;r<o.length;r++){const a=o[r],i=a&&a.isEllipseCurve?2*e:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,s=a.getPoints(i);for(let e=0;e<s.length;e++){const r=s[e];n&&n.equals(r)||(t.push(r),n=r)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push(n.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const n=this.curves[t];e.curves.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const n=e.curves[t];this.curves.push((new ad[n.type]).fromJSON(n))}return this}}class sd extends id{constructor(e){super(),this.type="Path",this.currentPoint=new ir,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new ed(this.currentPoint.clone(),new ir(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,r){const o=new nd(this.currentPoint.clone(),new ir(e,t),new ir(n,r));return this.curves.push(o),this.currentPoint.set(n,r),this}bezierCurveTo(e,t,n,r,o,a){const i=new Ju(this.currentPoint.clone(),new ir(e,t),new ir(n,r),new ir(o,a));return this.curves.push(i),this.currentPoint.set(o,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new od(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,r,o,a){const i=this.currentPoint.x,s=this.currentPoint.y;return this.absarc(e+i,t+s,n,r,o,a),this}absarc(e,t,n,r,o,a){return this.absellipse(e,t,n,n,r,o,a),this}ellipse(e,t,n,r,o,a,i,s){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,n,r,o,a,i,s),this}absellipse(e,t,n,r,o,a,i,s){const l=new Hu(e,t,n,r,o,a,i,s);if(this.curves.length>0){const e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class ld extends sd{constructor(e){super(e),this.uuid=On(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,r=this.holes.length;n<r;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push(n.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const n=this.holes[t];e.holes.push(n.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const n=e.holes[t];this.holes.push((new sd).fromJSON(n))}return this}}class cd extends Eo{constructor(e,t=1){super(),this.type="Light",this.color=new Wo(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}cd.prototype.isLight=!0;class fd extends cd{constructor(e,t,n){super(e,n),this.type="HemisphereLight",this.position.copy(Eo.DefaultUp),this.updateMatrix(),this.groundColor=new Wo(t)}copy(e){return cd.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}fd.prototype.isHemisphereLight=!0;const ud=new Yr,dd=new xr,pd=new xr;class hd{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new ir(512,512),this.map=null,this.mapPass=null,this.matrix=new Yr,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new $a,this._frameExtents=new ir(1,1),this._viewportCount=1,this._viewports=[new pr(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;dd.setFromMatrixPosition(e.matrixWorld),t.position.copy(dd),pd.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(pd),t.updateMatrixWorld(),ud.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(ud),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class vd extends hd{constructor(){super(new Wa(50,1,.5,500)),this.focus=1}updateMatrices(e){const t=this.camera,n=2*In*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,o=e.distance||t.far;n===t.fov&&r===t.aspect&&o===t.far||(t.fov=n,t.aspect=r,t.far=o,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}vd.prototype.isSpotLightShadow=!0;class md extends cd{constructor(e,t,n=0,r=Math.PI/3,o=0,a=1){super(e,t),this.type="SpotLight",this.position.copy(Eo.DefaultUp),this.updateMatrix(),this.target=new Eo,this.distance=n,this.angle=r,this.penumbra=o,this.decay=a,this.shadow=new vd}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}md.prototype.isSpotLight=!0;const xd=new Yr,gd=new xr,yd=new xr;class Ed extends hd{constructor(){super(new Wa(90,1,.5,500)),this._frameExtents=new ir(4,2),this._viewportCount=6,this._viewports=[new pr(2,1,1,1),new pr(0,1,1,1),new pr(3,1,1,1),new pr(1,1,1,1),new pr(3,0,1,1),new pr(1,0,1,1)],this._cubeDirections=[new xr(1,0,0),new xr(-1,0,0),new xr(0,0,1),new xr(0,0,-1),new xr(0,1,0),new xr(0,-1,0)],this._cubeUps=[new xr(0,1,0),new xr(0,1,0),new xr(0,1,0),new xr(0,1,0),new xr(0,0,1),new xr(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,r=this.matrix,o=e.distance||n.far;o!==n.far&&(n.far=o,n.updateProjectionMatrix()),gd.setFromMatrixPosition(e.matrixWorld),n.position.copy(gd),yd.copy(n.position),yd.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(yd),n.updateMatrixWorld(),r.makeTranslation(-gd.x,-gd.y,-gd.z),xd.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(xd)}}Ed.prototype.isPointLightShadow=!0;class wd extends cd{constructor(e,t,n=0,r=1){super(e,t),this.type="PointLight",this.distance=n,this.decay=r,this.shadow=new Ed}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}wd.prototype.isPointLight=!0;class bd extends Va{constructor(e=-1,t=1,n=1,r=-1,o=.1,a=2e3){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=r,this.near=o,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,n,r,o,a){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=r,this.view.width=o,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let o=n-e,a=n+e,i=r+t,s=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;o+=e*this.view.offsetX,a=o+e*this.view.width,i-=t*this.view.offsetY,s=i-t*this.view.height}this.projectionMatrix.makeOrthographic(o,a,i,s,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}bd.prototype.isOrthographicCamera=!0;class _d extends hd{constructor(){super(new bd(-5,5,5,-5,.5,500))}}_d.prototype.isDirectionalLightShadow=!0;class Td extends cd{constructor(e,t){super(e,t),this.type="DirectionalLight",this.position.copy(Eo.DefaultUp),this.updateMatrix(),this.target=new Eo,this.shadow=new _d}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}Td.prototype.isDirectionalLight=!0;class Ad extends cd{constructor(e,t){super(e,t),this.type="AmbientLight"}}Ad.prototype.isAmbientLight=!0;class Sd extends cd{constructor(e,t,n=10,r=10){super(e,t),this.type="RectAreaLight",this.width=n,this.height=r}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}Sd.prototype.isRectAreaLight=!0;class Rd{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new xr)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,r=e.y,o=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*r),t.addScaledVector(a[2],.488603*o),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],n*r*1.092548),t.addScaledVector(a[5],r*o*1.092548),t.addScaledVector(a[6],.315392*(3*o*o-1)),t.addScaledVector(a[7],n*o*1.092548),t.addScaledVector(a[8],.546274*(n*n-r*r)),t}getIrradianceAt(e,t){const n=e.x,r=e.y,o=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],1.023328*r),t.addScaledVector(a[2],1.023328*o),t.addScaledVector(a[3],1.023328*n),t.addScaledVector(a[4],.858086*n*r),t.addScaledVector(a[5],.858086*r*o),t.addScaledVector(a[6],.743125*o*o-.247708),t.addScaledVector(a[7],.858086*n*o),t.addScaledVector(a[8],.429043*(n*n-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].fromArray(e,t+3*r);return this}toArray(e=[],t=0){const n=this.coefficients;for(let r=0;r<9;r++)n[r].toArray(e,t+3*r);return e}static getBasisAt(e,t){const n=e.x,r=e.y,o=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*o,t[3]=.488603*n,t[4]=1.092548*n*r,t[5]=1.092548*r*o,t[6]=.315392*(3*o*o-1),t[7]=1.092548*n*o,t[8]=.546274*(n*n-r*r)}}Rd.prototype.isSphericalHarmonics3=!0;class Md extends cd{constructor(e=new Rd,t=1){super(void 0,t),this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}Md.prototype.isLightProbe=!0;class Cd extends Tu{constructor(e){super(e),this.textures={}}load(e,t,n,r){const o=this,a=new Su(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t=this.textures;function n(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const r=new ou[e.type];if(void 0!==e.uuid&&(r.uuid=e.uuid),void 0!==e.name&&(r.name=e.name),void 0!==e.color&&void 0!==r.color&&r.color.setHex(e.color),void 0!==e.roughness&&(r.roughness=e.roughness),void 0!==e.metalness&&(r.metalness=e.metalness),void 0!==e.sheen&&(r.sheen=(new Wo).setHex(e.sheen)),void 0!==e.emissive&&void 0!==r.emissive&&r.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==r.specular&&r.specular.setHex(e.specular),void 0!==e.shininess&&(r.shininess=e.shininess),void 0!==e.clearcoat&&(r.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(r.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.fog&&(r.fog=e.fog),void 0!==e.flatShading&&(r.flatShading=e.flatShading),void 0!==e.blending&&(r.blending=e.blending),void 0!==e.combine&&(r.combine=e.combine),void 0!==e.side&&(r.side=e.side),void 0!==e.shadowSide&&(r.shadowSide=e.shadowSide),void 0!==e.opacity&&(r.opacity=e.opacity),void 0!==e.transparent&&(r.transparent=e.transparent),void 0!==e.alphaTest&&(r.alphaTest=e.alphaTest),void 0!==e.depthTest&&(r.depthTest=e.depthTest),void 0!==e.depthWrite&&(r.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(r.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(r.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(r.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(r.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(r.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(r.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(r.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(r.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(r.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(r.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(r.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(r.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(r.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(r.rotation=e.rotation),1!==e.linewidth&&(r.linewidth=e.linewidth),void 0!==e.dashSize&&(r.dashSize=e.dashSize),void 0!==e.gapSize&&(r.gapSize=e.gapSize),void 0!==e.scale&&(r.scale=e.scale),void 0!==e.polygonOffset&&(r.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(r.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(r.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.skinning&&(r.skinning=e.skinning),void 0!==e.morphTargets&&(r.morphTargets=e.morphTargets),void 0!==e.morphNormals&&(r.morphNormals=e.morphNormals),void 0!==e.dithering&&(r.dithering=e.dithering),void 0!==e.alphaToCoverage&&(r.alphaToCoverage=e.alphaToCoverage),void 0!==e.premultipliedAlpha&&(r.premultipliedAlpha=e.premultipliedAlpha),void 0!==e.vertexTangents&&(r.vertexTangents=e.vertexTangents),void 0!==e.visible&&(r.visible=e.visible),void 0!==e.toneMapped&&(r.toneMapped=e.toneMapped),void 0!==e.userData&&(r.userData=e.userData),void 0!==e.vertexColors&&("number"==typeof e.vertexColors?r.vertexColors=e.vertexColors>0:r.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const t in e.uniforms){const o=e.uniforms[t];switch(r.uniforms[t]={},o.type){case"t":r.uniforms[t].value=n(o.value);break;case"c":r.uniforms[t].value=(new Wo).setHex(o.value);break;case"v2":r.uniforms[t].value=(new ir).fromArray(o.value);break;case"v3":r.uniforms[t].value=(new xr).fromArray(o.value);break;case"v4":r.uniforms[t].value=(new pr).fromArray(o.value);break;case"m3":r.uniforms[t].value=(new sr).fromArray(o.value);break;case"m4":r.uniforms[t].value=(new Yr).fromArray(o.value);break;default:r.uniforms[t].value=o.value}}if(void 0!==e.defines&&(r.defines=e.defines),void 0!==e.vertexShader&&(r.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(r.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const t in e.extensions)r.extensions[t]=e.extensions[t];if(void 0!==e.shading&&(r.flatShading=1===e.shading),void 0!==e.size&&(r.size=e.size),void 0!==e.sizeAttenuation&&(r.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(r.map=n(e.map)),void 0!==e.matcap&&(r.matcap=n(e.matcap)),void 0!==e.alphaMap&&(r.alphaMap=n(e.alphaMap)),void 0!==e.bumpMap&&(r.bumpMap=n(e.bumpMap)),void 0!==e.bumpScale&&(r.bumpScale=e.bumpScale),void 0!==e.normalMap&&(r.normalMap=n(e.normalMap)),void 0!==e.normalMapType&&(r.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),r.normalScale=(new ir).fromArray(t)}return void 0!==e.displacementMap&&(r.displacementMap=n(e.displacementMap)),void 0!==e.displacementScale&&(r.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(r.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(r.roughnessMap=n(e.roughnessMap)),void 0!==e.metalnessMap&&(r.metalnessMap=n(e.metalnessMap)),void 0!==e.emissiveMap&&(r.emissiveMap=n(e.emissiveMap)),void 0!==e.emissiveIntensity&&(r.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(r.specularMap=n(e.specularMap)),void 0!==e.envMap&&(r.envMap=n(e.envMap)),void 0!==e.envMapIntensity&&(r.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(r.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(r.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(r.lightMap=n(e.lightMap)),void 0!==e.lightMapIntensity&&(r.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(r.aoMap=n(e.aoMap)),void 0!==e.aoMapIntensity&&(r.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(r.gradientMap=n(e.gradientMap)),void 0!==e.clearcoatMap&&(r.clearcoatMap=n(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(r.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(r.clearcoatNormalMap=n(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(r.clearcoatNormalScale=(new ir).fromArray(e.clearcoatNormalScale)),void 0!==e.transmission&&(r.transmission=e.transmission),void 0!==e.transmissionMap&&(r.transmissionMap=n(e.transmissionMap)),r}setTextures(e){return this.textures=e,this}}class Ld{static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let n=0,r=e.length;n<r;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return-1===t?"./":e.substr(0,t+1)}}class Pd extends va{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}Pd.prototype.isInstancedBufferGeometry=!0;class kd extends Yo{constructor(e,t,n,r){"number"==typeof n&&(r=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,n),this.meshPerAttribute=r||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}kd.prototype.isInstancedBufferAttribute=!0;class Nd extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new Su(o.manager);a.setPath(o.path),a.setRequestHeader(o.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(n){try{t(o.parse(JSON.parse(n)))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}parse(e){const t={},n={};function r(e,n){if(void 0!==t[n])return t[n];const r=e.interleavedBuffers[n],a=o(e,r.buffer),i=sa(r.type,a),s=new Nl(i,r.stride);return s.uuid=r.uuid,t[n]=s,s}function o(e,t){if(void 0!==n[t])return n[t];const r=e.arrayBuffers[t],o=new Uint32Array(r).buffer;return n[t]=o,o}const a=e.isInstancedBufferGeometry?new Pd:new va,i=e.data.index;if(void 0!==i){const e=sa(i.type,i.array);a.setIndex(new Yo(e,1))}const s=e.data.attributes;for(const t in s){const n=s[t];let o;if(n.isInterleavedBufferAttribute){const t=r(e.data,n.data);o=new zl(t,n.itemSize,n.offset,n.normalized)}else{const e=sa(n.type,n.array);o=new(n.isInstancedBufferAttribute?kd:Yo)(e,n.itemSize,n.normalized)}void 0!==n.name&&(o.name=n.name),void 0!==n.usage&&o.setUsage(n.usage),void 0!==n.updateRange&&(o.updateRange.offset=n.updateRange.offset,o.updateRange.count=n.updateRange.count),a.setAttribute(t,o)}const l=e.data.morphAttributes;if(l)for(const t in l){const n=l[t],o=[];for(let t=0,a=n.length;t<a;t++){const a=n[t];let i;if(a.isInterleavedBufferAttribute){const t=r(e.data,a.data);i=new zl(t,a.itemSize,a.offset,a.normalized)}else{const e=sa(a.type,a.array);i=new Yo(e,a.itemSize,a.normalized)}void 0!==a.name&&(i.name=a.name),o.push(i)}a.morphAttributes[t]=o}e.data.morphTargetsRelative&&(a.morphTargetsRelative=!0);const c=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==c)for(let e=0,t=c.length;e!==t;++e){const t=c[e];a.addGroup(t.start,t.count,t.materialIndex)}const f=e.data.boundingSphere;if(void 0!==f){const e=new xr;void 0!==f.center&&e.fromArray(f.center),a.boundingSphere=new Or(e,f.radius)}return e.name&&(a.name=e.name),e.userData&&(a.userData=e.userData),a}}class Hd extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=""===this.path?Ld.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||a;const i=new Su(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(e,(function(n){let a=null;try{a=JSON.parse(n)}catch(t){return void 0!==r&&r(t),void console.error("THREE:ObjectLoader: Can't parse "+e+".",t.message)}const i=a.metadata;void 0!==i&&void 0!==i.type&&"geometry"!==i.type.toLowerCase()?o.parse(a,t):console.error("THREE.ObjectLoader: Can't load "+e)}),n,r)}parse(e,t){const n=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),o=this.parseGeometries(e.geometries,r),a=this.parseImages(e.images,(function(){void 0!==t&&t(l)})),i=this.parseTextures(e.textures,a),s=this.parseMaterials(e.materials,i),l=this.parseObject(e.object,o,s,n),c=this.parseSkeletons(e.skeletons,l);if(this.bindSkeletons(l,c),void 0!==t){let e=!1;for(const t in a)if(a[t]instanceof HTMLImageElement){e=!0;break}!1===e&&t(l)}return l}parseShapes(e){const t={};if(void 0!==e)for(let n=0,r=e.length;n<r;n++){const r=(new ld).fromJSON(e[n]);t[r.uuid]=r}return t}parseSkeletons(e,t){const n={},r={};if(t.traverse((function(e){e.isBone&&(r[e.uuid]=e)})),void 0!==e)for(let t=0,o=e.length;t<o;t++){const o=(new fc).fromJSON(e[t],r);n[o.uuid]=o}return n}parseGeometries(e,t){const n={};let r;if(void 0!==e){const o=new Nd;for(let a=0,i=e.length;a<i;a++){let i;const s=e[a];switch(s.type){case"PlaneGeometry":case"PlaneBufferGeometry":i=new Xf[s.type](s.width,s.height,s.widthSegments,s.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":i=new Xf[s.type](s.width,s.height,s.depth,s.widthSegments,s.heightSegments,s.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":i=new Xf[s.type](s.radius,s.segments,s.thetaStart,s.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":i=new Xf[s.type](s.radiusTop,s.radiusBottom,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":i=new Xf[s.type](s.radius,s.height,s.radialSegments,s.heightSegments,s.openEnded,s.thetaStart,s.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":i=new Xf[s.type](s.radius,s.widthSegments,s.heightSegments,s.phiStart,s.phiLength,s.thetaStart,s.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":i=new Xf[s.type](s.radius,s.detail);break;case"RingGeometry":case"RingBufferGeometry":i=new Xf[s.type](s.innerRadius,s.outerRadius,s.thetaSegments,s.phiSegments,s.thetaStart,s.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":i=new Xf[s.type](s.radius,s.tube,s.radialSegments,s.tubularSegments,s.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":i=new Xf[s.type](s.radius,s.tube,s.tubularSegments,s.radialSegments,s.p,s.q);break;case"TubeGeometry":case"TubeBufferGeometry":i=new Xf[s.type]((new ad[s.path.type]).fromJSON(s.path),s.tubularSegments,s.radius,s.radialSegments,s.closed);break;case"LatheGeometry":case"LatheBufferGeometry":i=new Xf[s.type](s.points,s.segments,s.phiStart,s.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":i=new Xf[s.type](s.vertices,s.indices,s.radius,s.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":r=[];for(let e=0,n=s.shapes.length;e<n;e++){const n=t[s.shapes[e]];r.push(n)}i=new Xf[s.type](r,s.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":r=[];for(let e=0,n=s.shapes.length;e<n;e++){const n=t[s.shapes[e]];r.push(n)}const e=s.options.extrudePath;void 0!==e&&(s.options.extrudePath=(new ad[e.type]).fromJSON(e)),i=new Xf[s.type](r,s.options);break;case"BufferGeometry":case"InstancedBufferGeometry":i=o.parse(s);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+s.type+'"');continue}i.uuid=s.uuid,void 0!==s.name&&(i.name=s.name),!0===i.isBufferGeometry&&void 0!==s.userData&&(i.userData=s.userData),n[s.uuid]=i}}return n}parseMaterials(e,t){const n={},r={};if(void 0!==e){const o=new Cd;o.setTextures(t);for(let t=0,a=e.length;t<a;t++){const a=e[t];if("MultiMaterial"===a.type){const e=[];for(let t=0;t<a.materials.length;t++){const r=a.materials[t];void 0===n[r.uuid]&&(n[r.uuid]=o.parse(r)),e.push(n[r.uuid])}r[a.uuid]=e}else void 0===n[a.uuid]&&(n[a.uuid]=o.parse(a)),r[a.uuid]=n[a.uuid]}}return r}parseAnimations(e){const t={};if(void 0!==e)for(let n=0;n<e.length;n++){const r=e[n],o=gu.parse(r);t[o.uuid]=o}return t}parseImages(e,t){const n=this,r={};let o;function a(e){return n.manager.itemStart(e),o.load(e,(function(){n.manager.itemEnd(e)}),void 0,(function(){n.manager.itemError(e),n.manager.itemEnd(e)}))}function i(e){if("string"==typeof e){const t=e;return a(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:n.resourcePath+t)}return e.data?{data:sa(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const n=new bu(t);o=new Cu(n),o.setCrossOrigin(this.crossOrigin);for(let t=0,n=e.length;t<n;t++){const n=e[t],o=n.url;if(Array.isArray(o)){r[n.uuid]=[];for(let e=0,t=o.length;e<t;e++){const t=i(o[e]);null!==t&&(t instanceof HTMLImageElement?r[n.uuid].push(t):r[n.uuid].push(new Ka(t.data,t.width,t.height)))}}else{const e=i(n.url);null!==e&&(r[n.uuid]=e)}}}return r}parseTextures(e,t){function n(e,t){return"number"==typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const r={};if(void 0!==e)for(let o=0,a=e.length;o<a;o++){const a=e[o];let i;void 0===a.image&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),void 0===t[a.image]&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const s=t[a.image];Array.isArray(s)?(i=new Ya(s),6===s.length&&(i.needsUpdate=!0)):(i=s&&s.data?new Ka(s.data,s.width,s.height):new ur(s),s&&(i.needsUpdate=!0)),i.uuid=a.uuid,void 0!==a.name&&(i.name=a.name),void 0!==a.mapping&&(i.mapping=n(a.mapping,zd)),void 0!==a.offset&&i.offset.fromArray(a.offset),void 0!==a.repeat&&i.repeat.fromArray(a.repeat),void 0!==a.center&&i.center.fromArray(a.center),void 0!==a.rotation&&(i.rotation=a.rotation),void 0!==a.wrap&&(i.wrapS=n(a.wrap[0],Dd),i.wrapT=n(a.wrap[1],Dd)),void 0!==a.format&&(i.format=a.format),void 0!==a.type&&(i.type=a.type),void 0!==a.encoding&&(i.encoding=a.encoding),void 0!==a.minFilter&&(i.minFilter=n(a.minFilter,Fd)),void 0!==a.magFilter&&(i.magFilter=n(a.magFilter,Fd)),void 0!==a.anisotropy&&(i.anisotropy=a.anisotropy),void 0!==a.flipY&&(i.flipY=a.flipY),void 0!==a.premultiplyAlpha&&(i.premultiplyAlpha=a.premultiplyAlpha),void 0!==a.unpackAlignment&&(i.unpackAlignment=a.unpackAlignment),r[a.uuid]=i}return r}parseObject(e,t,n,r){let o,a,i;function s(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function l(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let r=0,o=e.length;r<o;r++){const o=e[r];void 0===n[o]&&console.warn("THREE.ObjectLoader: Undefined material",o),t.push(n[o])}return t}return void 0===n[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),n[e]}}switch(e.type){case"Scene":o=new kl,void 0!==e.background&&Number.isInteger(e.background)&&(o.background=new Wo(e.background)),void 0!==e.fog&&("Fog"===e.fog.type?o.fog=new Pl(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(o.fog=new Ll(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":o=new Wa(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(o.focus=e.focus),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.filmGauge&&(o.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(o.filmOffset=e.filmOffset),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new bd(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(o.zoom=e.zoom),void 0!==e.view&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new Ad(e.color,e.intensity);break;case"DirectionalLight":o=new Td(e.color,e.intensity);break;case"PointLight":o=new wd(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new Sd(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new md(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new fd(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=(new Md).fromJSON(e);break;case"SkinnedMesh":a=s(e.geometry),i=l(e.material),o=new ic(a,i),void 0!==e.bindMode&&(o.bindMode=e.bindMode),void 0!==e.bindMatrix&&o.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(o.skeleton=e.skeleton);break;case"Mesh":a=s(e.geometry),i=l(e.material),o=new Na(a,i);break;case"InstancedMesh":a=s(e.geometry),i=l(e.material);const t=e.count,n=e.instanceMatrix,r=e.instanceColor;o=new vc(a,i,t),o.instanceMatrix=new Yo(new Float32Array(n.array),16),void 0!==r&&(o.instanceColor=new Yo(new Float32Array(r.array),r.itemSize));break;case"LOD":o=new ec;break;case"Line":o=new bc(s(e.geometry),l(e.material));break;case"LineLoop":o=new Sc(s(e.geometry),l(e.material));break;case"LineSegments":o=new Ac(s(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new kc(s(e.geometry),l(e.material));break;case"Sprite":o=new Kl(l(e.material));break;case"Group":o=new bl;break;case"Bone":o=new sc;break;default:o=new Eo}if(o.uuid=e.uuid,void 0!==e.name&&(o.name=e.name),void 0!==e.matrix?(o.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(void 0!==e.position&&o.position.fromArray(e.position),void 0!==e.rotation&&o.rotation.fromArray(e.rotation),void 0!==e.quaternion&&o.quaternion.fromArray(e.quaternion),void 0!==e.scale&&o.scale.fromArray(e.scale)),void 0!==e.castShadow&&(o.castShadow=e.castShadow),void 0!==e.receiveShadow&&(o.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(o.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(o.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(o.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&o.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(o.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(o.visible=e.visible),void 0!==e.frustumCulled&&(o.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(o.renderOrder=e.renderOrder),void 0!==e.userData&&(o.userData=e.userData),void 0!==e.layers&&(o.layers.mask=e.layers),void 0!==e.children){const a=e.children;for(let e=0;e<a.length;e++)o.add(this.parseObject(a[e],t,n,r))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const n=t[e];o.animations.push(r[n])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(o.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const n=t[e],r=o.getObjectByProperty("uuid",n.object);void 0!==r&&o.addLevel(r,n.distance)}}return o}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(!0===e.isSkinnedMesh&&void 0!==e.skeleton){const n=t[e.skeleton];void 0===n?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(n,e.bindMatrix)}}))}setTexturePath(e){return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),this.setResourcePath(e)}}const zd={UVMapping:ne,CubeReflectionMapping:re,CubeRefractionMapping:oe,EquirectangularReflectionMapping:ae,EquirectangularRefractionMapping:ie,CubeUVReflectionMapping:se,CubeUVRefractionMapping:le},Dd={RepeatWrapping:ce,ClampToEdgeWrapping:fe,MirroredRepeatWrapping:ue},Fd={NearestFilter:de,NearestMipmapNearestFilter:pe,NearestMipmapLinearFilter:ve,LinearFilter:xe,LinearMipmapNearestFilter:ge,LinearMipmapLinearFilter:Ee};class Id extends Tu{constructor(e){super(e),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const o=this,a=wu.get(e);if(void 0!==a)return o.manager.itemStart(e),setTimeout((function(){t&&t(a),o.manager.itemEnd(e)}),0),a;const i={};i.credentials="anonymous"===this.crossOrigin?"same-origin":"include",i.headers=this.requestHeader,fetch(e,i).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(o.options,{colorSpaceConversion:"none"}))})).then((function(n){wu.add(e,n),t&&t(n),o.manager.itemEnd(e)})).catch((function(t){r&&r(t),o.manager.itemError(e),o.manager.itemEnd(e)})),o.manager.itemStart(e)}}Id.prototype.isImageBitmapLoader=!0;class Od{constructor(){this.type="ShapePath",this.color=new Wo,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new sd,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,r){return this.currentPath.quadraticCurveTo(e,t,n,r),this}bezierCurveTo(e,t,n,r,o,a){return this.currentPath.bezierCurveTo(e,t,n,r,o,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function n(e){const t=[];for(let n=0,r=e.length;n<r;n++){const r=e[n],o=new ld;o.curves=r.curves,t.push(o)}return t}function r(e,t){const n=t.length;let r=!1;for(let o=n-1,a=0;a<n;o=a++){let n=t[o],i=t[a],s=i.x-n.x,l=i.y-n.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(n=t[a],s=-s,i=t[o],l=-l),e.y<n.y||e.y>i.y)continue;if(e.y===n.y){if(e.x===n.x)return!0}else{const t=l*(e.x-n.x)-s*(e.y-n.y);if(0===t)return!0;if(t<0)continue;r=!r}}else{if(e.y!==n.y)continue;if(i.x<=e.x&&e.x<=n.x||n.x<=e.x&&e.x<=i.x)return!0}}return r}const o=Rf.isClockWise,a=this.subPaths;if(0===a.length)return[];if(!0===t)return n(a);let i,s,l;const c=[];if(1===a.length)return s=a[0],l=new ld,l.curves=s.curves,c.push(l),c;let f=!o(a[0].getPoints());f=e?!f:f;const u=[],d=[];let p,h,v=[],m=0;d[m]=void 0,v[m]=[];for(let t=0,n=a.length;t<n;t++)s=a[t],p=s.getPoints(),i=o(p),i=e?!i:i,i?(!f&&d[m]&&m++,d[m]={s:new ld,p},d[m].s.curves=s.curves,f&&m++,v[m]=[]):v[m].push({h:s,p:p[0]});if(!d[0])return n(a);if(d.length>1){let e=!1;const t=[];for(let e=0,t=d.length;e<t;e++)u[e]=[];for(let n=0,o=d.length;n<o;n++){const o=v[n];for(let a=0;a<o.length;a++){const i=o[a];let s=!0;for(let o=0;o<d.length;o++)r(i.p,d[o].p)&&(n!==o&&t.push({froms:n,tos:o,hole:a}),s?(s=!1,u[o].push(i)):e=!0);s&&u[n].push(i)}}t.length>0&&(e||(v=u))}for(let e=0,t=d.length;e<t;e++){l=d[e].s,c.push(l),h=v[e];for(let e=0,t=h.length;e<t;e++)l.holes.push(h[e].h)}return c}}class Ud{constructor(e){this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],r=Gd(e,t,this.data);for(let e=0,t=r.length;e<t;e++)Array.prototype.push.apply(n,r[e].toShapes());return n}}function Gd(e,t,n){const r=Array.from(e),o=t/n.resolution,a=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*o,i=[];let s=0,l=0;for(let e=0;e<r.length;e++){const t=r[e];if("\n"===t)s=0,l-=a;else{const e=Bd(t,o,s,l,n);s+=e.offsetX,i.push(e.path)}}return i}function Bd(e,t,n,r,o){const a=o.glyphs[e]||o.glyphs["?"];if(!a)return void console.error('THREE.Font: character "'+e+'" does not exists in font family '+o.familyName+".");const i=new Od;let s,l,c,f,u,d,p,h;if(a.o){const e=a._cachedOutline||(a._cachedOutline=a.o.split(" "));for(let o=0,a=e.length;o<a;)switch(e[o++]){case"m":s=e[o++]*t+n,l=e[o++]*t+r,i.moveTo(s,l);break;case"l":s=e[o++]*t+n,l=e[o++]*t+r,i.lineTo(s,l);break;case"q":c=e[o++]*t+n,f=e[o++]*t+r,u=e[o++]*t+n,d=e[o++]*t+r,i.quadraticCurveTo(u,d,c,f);break;case"b":c=e[o++]*t+n,f=e[o++]*t+r,u=e[o++]*t+n,d=e[o++]*t+r,p=e[o++]*t+n,h=e[o++]*t+r,i.bezierCurveTo(u,d,p,h,c,f)}}return{offsetX:a.ha*t,path:i}}Ud.prototype.isFont=!0;class Vd extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new Su(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(o.withCredentials),a.load(e,(function(e){let n;try{n=JSON.parse(e)}catch(t){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),n=JSON.parse(e.substring(65,e.length-2))}const r=o.parse(n);t&&t(r)}),n,r)}parse(e){return new Ud(e)}}let Wd;const jd={getContext:function(){return void 0===Wd&&(Wd=new(window.AudioContext||window.webkitAudioContext)),Wd},setContext:function(e){Wd=e}};class qd extends Tu{constructor(e){super(e)}load(e,t,n,r){const o=this,a=new Su(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(n){try{const e=n.slice(0);jd.getContext().decodeAudioData(e,(function(e){t(e)}))}catch(t){r?r(t):console.error(t),o.manager.itemError(e)}}),n,r)}}class Xd extends Md{constructor(e,t,n=1){super(void 0,n);const r=(new Wo).set(e),o=(new Wo).set(t),a=new xr(r.r,r.g,r.b),i=new xr(o.r,o.g,o.b),s=Math.sqrt(Math.PI),l=s*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(i).multiplyScalar(s),this.sh.coefficients[1].copy(a).sub(i).multiplyScalar(l)}}Xd.prototype.isHemisphereLightProbe=!0;class Yd extends Md{constructor(e,t=1){super(void 0,t);const n=(new Wo).set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}Yd.prototype.isAmbientLightProbe=!0;const Qd=new Yr,Kd=new Yr;class Zd{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Wa,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Wa,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const n=e.projectionMatrix.clone(),r=t.eyeSep/2,o=r*t.near/t.focus,a=t.near*Math.tan(Fn*t.fov*.5)/t.zoom;let i,s;Kd.elements[12]=-r,Qd.elements[12]=r,i=-a*t.aspect+o,s=a*t.aspect+o,n.elements[0]=2*t.near/(s-i),n.elements[8]=(s+i)/(s-i),this.cameraL.projectionMatrix.copy(n),i=-a*t.aspect-o,s=a*t.aspect-o,n.elements[0]=2*t.near/(s-i),n.elements[8]=(s+i)/(s-i),this.cameraR.projectionMatrix.copy(n)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Kd),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Qd)}}class Jd{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=$d(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=$d();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function $d(){return("undefined"==typeof performance?Date:performance).now()}const ep=new xr,tp=new mr,np=new xr,rp=new xr;class op extends Eo{constructor(){super(),this.type="AudioListener",this.context=jd.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Jd}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(ep,tp,np),rp.set(0,0,-1).applyQuaternion(tp),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(ep.x,e),t.positionY.linearRampToValueAtTime(ep.y,e),t.positionZ.linearRampToValueAtTime(ep.z,e),t.forwardX.linearRampToValueAtTime(rp.x,e),t.forwardY.linearRampToValueAtTime(rp.y,e),t.forwardZ.linearRampToValueAtTime(rp.z,e),t.upX.linearRampToValueAtTime(n.x,e),t.upY.linearRampToValueAtTime(n.y,e),t.upZ.linearRampToValueAtTime(n.z,e)}else t.setPosition(ep.x,ep.y,ep.z),t.setOrientation(rp.x,rp.y,rp.z,n.x,n.y,n.z)}}class ap extends Eo{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const ip=new xr,sp=new mr,lp=new xr,cp=new xr;class fp extends ap{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(ip,sp,lp),cp.set(0,0,1).applyQuaternion(sp);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(ip.x,e),t.positionY.linearRampToValueAtTime(ip.y,e),t.positionZ.linearRampToValueAtTime(ip.z,e),t.orientationX.linearRampToValueAtTime(cp.x,e),t.orientationY.linearRampToValueAtTime(cp.y,e),t.orientationZ.linearRampToValueAtTime(cp.z,e)}else t.setPosition(ip.x,ip.y,ip.z),t.setOrientation(cp.x,cp.y,cp.z)}}class up{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class dp{constructor(e,t,n){let r,o,a;switch(this.binding=e,this.valueSize=n,t){case"quaternion":r=this._slerp,o=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*n),this._workIndex=5;break;case"string":case"bool":r=this._select,o=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(5*n);break;default:r=this._lerp,o=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*n)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=o,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,r=this.valueSize,o=e*r+r;let a=this.cumulativeWeight;if(0===a){for(let e=0;e!==r;++e)n[o+e]=n[e];a=t}else{a+=t;const e=t/a;this._mixBufferRegion(n,o,0,e,r)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,r=n*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,r=e*t+t,o=this.cumulativeWeight,a=this.cumulativeWeightAdditive,i=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,o<1){const e=t*this._origIndex;this._mixBufferRegion(n,r,e,1-o,t)}a>0&&this._mixBufferRegionAdditive(n,r,this._addIndex*t,1,t);for(let e=t,o=t+t;e!==o;++e)if(n[e]!==n[e+t]){i.setValue(n,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,r=n*this._origIndex;e.getValue(t,r);for(let e=n,o=r;e!==o;++e)t[e]=t[r+e%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,r,o){if(r>=.5)for(let r=0;r!==o;++r)e[t+r]=e[n+r]}_slerp(e,t,n,r){mr.slerpFlat(e,t,e,t,e,n,r)}_slerpAdditive(e,t,n,r,o){const a=this._workIndex*o;mr.multiplyQuaternionsFlat(e,a,e,t,e,n),mr.slerpFlat(e,t,e,t,e,a,r)}_lerp(e,t,n,r,o){const a=1-r;for(let i=0;i!==o;++i){const o=t+i;e[o]=e[o]*a+e[n+i]*r}}_lerpAdditive(e,t,n,r,o){for(let a=0;a!==o;++a){const o=t+a;e[o]=e[o]+e[n+a]*r}}}const pp="\\[\\]\\.:\\/",hp=new RegExp("["+pp+"]","g"),vp="[^"+pp+"]",mp="[^"+pp.replace("\\.","")+"]",xp=/((?:WC+[\/:])*)/.source.replace("WC",vp),gp=/(WCOD+)?/.source.replace("WCOD",mp),yp=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",vp),Ep=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",vp),wp=new RegExp("^"+xp+gp+yp+Ep+"$"),bp=["material","materials","bones"];class _p{constructor(e,t,n){const r=n||Tp.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,r=this._bindings[n];void 0!==r&&r.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let r=this._targetGroup.nCachedObjects_,o=n.length;r!==o;++r)n[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class Tp{constructor(e,t,n){this.path=t,this.parsedPath=n||Tp.parseTrackName(t),this.node=Tp.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new Tp.Composite(e,t,n):new Tp(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(hp,"")}static parseTrackName(e){const t=wp.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=n.nodeName&&n.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const e=n.nodeName.substring(r+1);-1!==bp.indexOf(e)&&(n.nodeName=n.nodeName.substring(0,r),n.objectName=e)}if(null===n.propertyName||0===n.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(void 0!==n)return n}if(e.children){const n=function(e){for(let r=0;r<e.length;r++){const o=e[r];if(o.name===t||o.uuid===t)return o;const a=n(o.children);if(a)return a}return null},r=n(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.node[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let r=0,o=n.length;r!==o;++r)e[t++]=n[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let r=0,o=n.length;r!==o;++r)n[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,o=n.length;r!==o;++r)n[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let r=0,o=n.length;r!==o;++r)n[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,r=t.propertyName;let o=t.propertyIndex;if(e||(e=Tp.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(n){let r=t.objectIndex;switch(n){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===r){r=t;break}break;default:if(void 0===e[n])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[n]}if(void 0!==r){if(void 0===e[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[r]}}const a=e[r];if(void 0===a){const n=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+n+"."+r+" but it wasn't found.",e)}let i=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?i=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(i=this.Versioning.MatrixWorldNeedsUpdate);let s=this.BindingType.Direct;if(void 0!==o){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.isBufferGeometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[o]&&(o=e.morphTargetDictionary[o])}s=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=o}else void 0!==a.fromArray&&void 0!==a.toArray?(s=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(s=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=r;this.getValue=this.GetterByBindingType[s],this.setValue=this.SetterByBindingTypeAndVersioning[s][i]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Tp.Composite=_p,Tp.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Tp.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Tp.prototype.GetterByBindingType=[Tp.prototype._getValue_direct,Tp.prototype._getValue_array,Tp.prototype._getValue_arrayElement,Tp.prototype._getValue_toArray],Tp.prototype.SetterByBindingTypeAndVersioning=[[Tp.prototype._setValue_direct,Tp.prototype._setValue_direct_setNeedsUpdate,Tp.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Tp.prototype._setValue_array,Tp.prototype._setValue_array_setNeedsUpdate,Tp.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Tp.prototype._setValue_arrayElement,Tp.prototype._setValue_arrayElement_setNeedsUpdate,Tp.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Tp.prototype._setValue_fromArray,Tp.prototype._setValue_fromArray_setNeedsUpdate,Tp.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Ap{constructor(){this.uuid=On(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let t=0,n=arguments.length;t!==n;++t)e[arguments[t].uuid]=t;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,r=this._parsedPaths,o=this._bindings,a=o.length;let i,s=e.length,l=this.nCachedObjects_;for(let c=0,f=arguments.length;c!==f;++c){const f=arguments[c],u=f.uuid;let d=t[u];if(void 0===d){d=s++,t[u]=d,e.push(f);for(let e=0,t=a;e!==t;++e)o[e].push(new Tp(f,n[e],r[e]))}else if(d<l){i=e[d];const s=--l,c=e[s];t[c.uuid]=d,e[d]=c,t[u]=s,e[s]=f;for(let e=0,t=a;e!==t;++e){const t=o[e],a=t[s];let i=t[d];t[d]=a,void 0===i&&(i=new Tp(f,n[e],r[e])),t[s]=i}}else e[d]!==i&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let o=this.nCachedObjects_;for(let a=0,i=arguments.length;a!==i;++a){const i=arguments[a],s=i.uuid,l=t[s];if(void 0!==l&&l>=o){const a=o++,c=e[a];t[c.uuid]=l,e[l]=c,t[s]=a,e[a]=i;for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[a],o=t[l];t[l]=r,t[a]=o}}}this.nCachedObjects_=o}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,r=n.length;let o=this.nCachedObjects_,a=e.length;for(let i=0,s=arguments.length;i!==s;++i){const s=arguments[i].uuid,l=t[s];if(void 0!==l)if(delete t[s],l<o){const i=--o,s=e[i],c=--a,f=e[c];t[s.uuid]=l,e[l]=s,t[f.uuid]=i,e[i]=f,e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e],r=t[i],o=t[c];t[l]=r,t[i]=o,t.pop()}}else{const o=--a,i=e[o];o>0&&(t[i.uuid]=l),e[l]=i,e.pop();for(let e=0,t=r;e!==t;++e){const t=n[e];t[l]=t[o],t.pop()}}}this.nCachedObjects_=o}subscribe_(e,t){const n=this._bindingsIndicesByPath;let r=n[e];const o=this._bindings;if(void 0!==r)return o[r];const a=this._paths,i=this._parsedPaths,s=this._objects,l=s.length,c=this.nCachedObjects_,f=new Array(l);r=o.length,n[e]=r,a.push(e),i.push(t),o.push(f);for(let n=c,r=s.length;n!==r;++n){const r=s[n];f[n]=new Tp(r,e,t)}return f}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(void 0!==n){const r=this._paths,o=this._parsedPaths,a=this._bindings,i=a.length-1,s=a[i];t[e[i]]=n,a[n]=s,a.pop(),o[n]=o[i],o.pop(),r[n]=r[i],r.pop()}}}Ap.prototype.isAnimationObjectGroup=!0;class Sp{constructor(e,t,n=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=r;const o=t.tracks,a=o.length,i=new Array(a),s={endingStart:Ut,endingEnd:Ut};for(let e=0;e!==a;++e){const t=o[e].createInterpolant(null);i[e]=t,t.settings=s}this._interpolantSettings=s,this._interpolants=i,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=zt,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const n=this._clip.duration,r=e._clip.duration,o=r/n,a=n/r;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const r=this._mixer,o=r.time,a=this.timeScale;let i=this._timeScaleInterpolant;null===i&&(i=r._lendControlInterpolant(),this._timeScaleInterpolant=i);const s=i.parameterPositions,l=i.sampleValues;return s[0]=o,s[1]=o+n,l[0]=e/a,l[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,r){if(!this.enabled)return void this._updateWeight(e);const o=this._startTime;if(null!==o){const r=(e-o)*n;if(r<0||0===n)return;this._startTime=null,t=n*r}t*=this._updateTimeScale(e);const a=this._updateTime(t),i=this._updateWeight(e);if(i>0){const e=this._interpolants,t=this._propertyBindings;switch(this.blendMode){case Wt:for(let n=0,r=e.length;n!==r;++n)e[n].evaluate(a),t[n].accumulateAdditive(i);break;case Vt:default:for(let n=0,o=e.length;n!==o;++n)e[n].evaluate(a),t[n].accumulate(r,i)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(null!==n){const r=n.evaluate(e)[0];t*=r,e>n.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;null!==n&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let r=this.time+e,o=this._loopCount;const a=n===Dt;if(0===e)return-1===o?r:a&&1==(1&o)?t-r:r;if(n===Ht){-1===o&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===o&&(e>=0?(o=0,this._setEndings(!0,0===this.repetitions,a)):this._setEndings(0===this.repetitions,!0,a)),r>=t||r<0){const n=Math.floor(r/t);r-=t*n,o+=Math.abs(n);const i=this.repetitions-o;if(i<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===i){const t=e<0;this._setEndings(t,!t,a)}else this._setEndings(!1,!1,a);this._loopCount=o,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:n})}}else this.time=r;if(a&&1==(1&o))return t-r}return r}_setEndings(e,t,n){const r=this._interpolantSettings;n?(r.endingStart=Gt,r.endingEnd=Gt):(r.endingStart=e?this.zeroSlopeAtStart?Gt:Ut:Bt,r.endingEnd=t?this.zeroSlopeAtEnd?Gt:Ut:Bt)}_scheduleFading(e,t,n){const r=this._mixer,o=r.time;let a=this._weightInterpolant;null===a&&(a=r._lendControlInterpolant(),this._weightInterpolant=a);const i=a.parameterPositions,s=a.sampleValues;return i[0]=o,s[0]=t,i[1]=o+e,s[1]=n,this}}class Rp extends Hn{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,r=e._clip.tracks,o=r.length,a=e._propertyBindings,i=e._interpolants,s=n.uuid,l=this._bindingsByRootAndName;let c=l[s];void 0===c&&(c={},l[s]=c);for(let e=0;e!==o;++e){const o=r[e],l=o.name;let f=c[l];if(void 0!==f)a[e]=f;else{if(f=a[e],void 0!==f){null===f._cacheIndex&&(++f.referenceCount,this._addInactiveBinding(f,s,l));continue}const r=t&&t._propertyBindings[e].binding.parsedPath;f=new dp(Tp.create(n,l,r),o.ValueTypeName,o.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,s,l),a[e]=f}i[e].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,n=e._clip.uuid,r=this._actionsByClip[n];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,n,t)}const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==n.useCount++&&(this._lendBinding(n),n.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.useCount&&(n.restoreOriginalState(),this._takeBackBinding(n))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,n){const r=this._actions,o=this._actionsByClip;let a=o[t];if(void 0===a)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,o[t]=a;else{const t=a.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=r.length,r.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],r=e._cacheIndex;n._cacheIndex=r,t[r]=n,t.pop(),e._cacheIndex=null;const o=e._clip.uuid,a=this._actionsByClip,i=a[o],s=i.knownActions,l=s[s.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c,s[c]=l,s.pop(),e._byClipCacheIndex=null,delete i.actionByRoot[(e._localRoot||this._root).uuid],0===s.length&&delete a[o],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let e=0,n=t.length;e!==n;++e){const n=t[e];0==--n.referenceCount&&this._removeInactiveBinding(n)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,r=this._nActiveActions++,o=t[r];e._cacheIndex=r,t[r]=e,o._cacheIndex=n,t[n]=o}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,r=--this._nActiveActions,o=t[r];e._cacheIndex=r,t[r]=e,o._cacheIndex=n,t[n]=o}_addInactiveBinding(e,t,n){const r=this._bindingsByRootAndName,o=this._bindings;let a=r[t];void 0===a&&(a={},r[t]=a),a[n]=e,e._cacheIndex=o.length,o.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,r=n.rootNode.uuid,o=n.path,a=this._bindingsByRootAndName,i=a[r],s=t[t.length-1],l=e._cacheIndex;s._cacheIndex=l,t[l]=s,t.pop(),delete i[o],0===Object.keys(i).length&&delete a[r]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,r=this._nActiveBindings++,o=t[r];e._cacheIndex=r,t[r]=e,o._cacheIndex=n,t[n]=o}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,r=--this._nActiveBindings,o=t[r];e._cacheIndex=r,t[r]=e,o._cacheIndex=n,t[n]=o}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return void 0===n&&(n=new lu(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,r=--this._nActiveControlInterpolants,o=t[r];e.__cacheIndex=r,t[r]=e,o.__cacheIndex=n,t[n]=o}clipAction(e,t,n){const r=t||this._root,o=r.uuid;let a="string"==typeof e?gu.findByName(r,e):e;const i=null!==a?a.uuid:e,s=this._actionsByClip[i];let l=null;if(void 0===n&&(n=null!==a?a.blendMode:Vt),void 0!==s){const e=s.actionByRoot[o];if(void 0!==e&&e.blendMode===n)return e;l=s.knownActions[0],null===a&&(a=l._clip)}if(null===a)return null;const c=new Sp(this,a,t,n);return this._bindAction(c,l),this._addInactiveAction(c,i,o),c}existingAction(e,t){const n=t||this._root,r=n.uuid,o="string"==typeof e?gu.findByName(n,e):e,a=o?o.uuid:e,i=this._actionsByClip[a];return void 0!==i&&i.actionByRoot[r]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,r=this.time+=e,o=Math.sign(e),a=this._accuIndex^=1;for(let i=0;i!==n;++i)t[i]._update(r,e,o,a);const i=this._bindings,s=this._nActiveBindings;for(let e=0;e!==s;++e)i[e].apply(a);return this}setTime(e){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,r=this._actionsByClip,o=r[n];if(void 0!==o){const e=o.knownActions;for(let n=0,r=e.length;n!==r;++n){const r=e[n];this._deactivateAction(r);const o=r._cacheIndex,a=t[t.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,a._cacheIndex=o,t[o]=a,t.pop(),this._removeInactiveBindingsForAction(r)}delete r[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const e in n){const r=n[e].actionByRoot[t];void 0!==r&&(this._deactivateAction(r),this._removeInactiveAction(r))}const r=this._bindingsByRootAndName[t];if(void 0!==r)for(const e in r){const t=r[e];t.restoreOriginalState(),this._removeInactiveBinding(t)}}uncacheAction(e,t){const n=this.existingAction(e,t);null!==n&&(this._deactivateAction(n),this._removeInactiveAction(n))}}Rp.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class Mp{constructor(e){"string"==typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Mp(void 0===this.value.clone?this.value:this.value.clone())}}class Cp extends Nl{constructor(e,t,n=1){super(e,t),this.meshPerAttribute=n||1}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}Cp.prototype.isInstancedInterleavedBuffer=!0;class Lp{constructor(e,t,n,r,o){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=r,this.count=o,this.version=0}set needsUpdate(e){!0===e&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}Lp.prototype.isGLBufferAttribute=!0;class Pp{constructor(e,t,n=0,r=1/0){this.ray=new Xr(e,t),this.near=n,this.far=r,this.camera=null,this.layers=new ao,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!1,n=[]){return Np(e,this,n,t),n.sort(kp),n}intersectObjects(e,t=!1,n=[]){for(let r=0,o=e.length;r<o;r++)Np(e[r],this,n,t);return n.sort(kp),n}}function kp(e,t){return e.distance-t.distance}function Np(e,t,n,r){if(e.layers.test(t.layers)&&e.raycast(t,n),!0===r){const r=e.children;for(let e=0,o=r.length;e<o;e++)Np(r[e],t,n,!0)}}class Hp{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Un(t/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class zp{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return(new this.constructor).copy(this)}}const Dp=new ir;class Fp{constructor(e=new ir(1/0,1/0),t=new ir(-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Dp.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return void 0===e&&(console.warn("THREE.Box2: .getCenter() target is now required"),e=new ir),this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return void 0===e&&(console.warn("THREE.Box2: .getSize() target is now required"),e=new ir),this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return void 0===t&&(console.warn("THREE.Box2: .getParameter() target is now required"),t=new ir),t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return void 0===t&&(console.warn("THREE.Box2: .clampPoint() target is now required"),t=new ir),t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Dp.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Fp.prototype.isBox2=!0;const Ip=new xr,Op=new xr;class Up{constructor(e=new xr,t=new xr){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return void 0===e&&(console.warn("THREE.Line3: .getCenter() target is now required"),e=new xr),e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return void 0===e&&(console.warn("THREE.Line3: .delta() target is now required"),e=new xr),e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return void 0===t&&(console.warn("THREE.Line3: .at() target is now required"),t=new xr),this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Ip.subVectors(e,this.start),Op.subVectors(this.end,this.start);const n=Op.dot(Op);let r=Op.dot(Ip)/n;return t&&(r=Un(r,0,1)),r}closestPointToPoint(e,t,n){const r=this.closestPointToPointParameter(e,t);return void 0===n&&(console.warn("THREE.Line3: .closestPointToPoint() target is now required"),n=new xr),this.delta(n).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}class Gp extends Eo{constructor(e){super(),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}}Gp.prototype.isImmediateRenderObject=!0;const Bp=new xr;class Vp extends Eo{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const n=new va,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let e=0,t=1,n=32;e<n;e++,t++){const o=e/n*Math.PI*2,a=t/n*Math.PI*2;r.push(Math.cos(o),Math.sin(o),1,Math.cos(a),Math.sin(a),1)}n.setAttribute("position",new ra(r,3));const o=new mc({fog:!1,toneMapped:!1});this.cone=new Ac(n,o),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Bp.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Bp),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Wp=new xr,jp=new Yr,qp=new Yr;class Xp extends Ac{constructor(e){const t=Yp(e),n=new va,r=[],o=[],a=new Wo(0,0,1),i=new Wo(0,1,0);for(let e=0;e<t.length;e++){const n=t[e];n.parent&&n.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),o.push(a.r,a.g,a.b),o.push(i.r,i.g,i.b))}n.setAttribute("position",new ra(r,3)),n.setAttribute("color",new ra(o,3)),super(n,new mc({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,r=n.getAttribute("position");qp.copy(this.root.matrixWorld).invert();for(let e=0,n=0;e<t.length;e++){const o=t[e];o.parent&&o.parent.isBone&&(jp.multiplyMatrices(qp,o.matrixWorld),Wp.setFromMatrixPosition(jp),r.setXYZ(n,Wp.x,Wp.y,Wp.z),jp.multiplyMatrices(qp,o.parent.matrixWorld),Wp.setFromMatrixPosition(jp),r.setXYZ(n+1,Wp.x,Wp.y,Wp.z),n+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function Yp(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,Yp(e.children[n]));return t}class Qp extends Na{constructor(e,t,n){super(new Uf(t,4,2),new jo({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.light.updateMatrixWorld(),this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Kp=new xr,Zp=new Wo,Jp=new Wo;class $p extends Eo{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n;const r=new zf(t);r.rotateY(.5*Math.PI),this.material=new jo({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const o=r.getAttribute("position"),a=new Float32Array(3*o.count);r.setAttribute("color",new Yo(a,3)),this.add(new Na(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Zp.copy(this.light.color),Jp.copy(this.light.groundColor);for(let e=0,n=t.count;e<n;e++){const r=e<n/2?Zp:Jp;t.setXYZ(e,r.r,r.g,r.b)}t.needsUpdate=!0}e.lookAt(Kp.setFromMatrixPosition(this.light.matrixWorld).negate())}}class eh extends Ac{constructor(e=10,t=10,n=4473924,r=8947848){n=new Wo(n),r=new Wo(r);const o=t/2,a=e/t,i=e/2,s=[],l=[];for(let e=0,c=0,f=-i;e<=t;e++,f+=a){s.push(-i,0,f,i,0,f),s.push(f,0,-i,f,0,i);const t=e===o?n:r;t.toArray(l,c),c+=3,t.toArray(l,c),c+=3,t.toArray(l,c),c+=3,t.toArray(l,c),c+=3}const c=new va;c.setAttribute("position",new ra(s,3)),c.setAttribute("color",new ra(l,3)),super(c,new mc({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class th extends Ac{constructor(e=10,t=16,n=8,r=64,o=4473924,a=8947848){o=new Wo(o),a=new Wo(a);const i=[],s=[];for(let n=0;n<=t;n++){const r=n/t*(2*Math.PI),l=Math.sin(r)*e,c=Math.cos(r)*e;i.push(0,0,0),i.push(l,0,c);const f=1&n?o:a;s.push(f.r,f.g,f.b),s.push(f.r,f.g,f.b)}for(let t=0;t<=n;t++){const l=1&t?o:a,c=e-e/n*t;for(let e=0;e<r;e++){let t=e/r*(2*Math.PI),n=Math.sin(t)*c,o=Math.cos(t)*c;i.push(n,0,o),s.push(l.r,l.g,l.b),t=(e+1)/r*(2*Math.PI),n=Math.sin(t)*c,o=Math.cos(t)*c,i.push(n,0,o),s.push(l.r,l.g,l.b)}}const l=new va;l.setAttribute("position",new ra(i,3)),l.setAttribute("color",new ra(s,3)),super(l,new mc({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const nh=new xr,rh=new xr,oh=new xr;class ah extends Eo{constructor(e,t,n){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,void 0===t&&(t=1);let r=new va;r.setAttribute("position",new ra([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const o=new mc({fog:!1,toneMapped:!1});this.lightPlane=new bc(r,o),this.add(this.lightPlane),r=new va,r.setAttribute("position",new ra([0,0,0,0,0,1],3)),this.targetLine=new bc(r,o),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){nh.setFromMatrixPosition(this.light.matrixWorld),rh.setFromMatrixPosition(this.light.target.matrixWorld),oh.subVectors(rh,nh),this.lightPlane.lookAt(rh),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(rh),this.targetLine.scale.z=oh.length()}}const ih=new xr,sh=new Va;class lh extends Ac{constructor(e){const t=new va,n=new mc({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],o=[],a={},i=new Wo(16755200),s=new Wo(16711680),l=new Wo(43775),c=new Wo(16777215),f=new Wo(3355443);function u(e,t,n){d(e,n),d(t,n)}function d(e,t){r.push(0,0,0),o.push(t.r,t.g,t.b),void 0===a[e]&&(a[e]=[]),a[e].push(r.length/3-1)}u("n1","n2",i),u("n2","n4",i),u("n4","n3",i),u("n3","n1",i),u("f1","f2",i),u("f2","f4",i),u("f4","f3",i),u("f3","f1",i),u("n1","f1",i),u("n2","f2",i),u("n3","f3",i),u("n4","f4",i),u("p","n1",s),u("p","n2",s),u("p","n3",s),u("p","n4",s),u("u1","u2",l),u("u2","u3",l),u("u3","u1",l),u("c","t",c),u("p","c",f),u("cn1","cn2",f),u("cn3","cn4",f),u("cf1","cf2",f),u("cf3","cf4",f),t.setAttribute("position",new ra(r,3)),t.setAttribute("color",new ra(o,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=a,this.update()}update(){const e=this.geometry,t=this.pointMap,n=1,r=1;sh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),ch("c",t,e,sh,0,0,-1),ch("t",t,e,sh,0,0,1),ch("n1",t,e,sh,-n,-r,-1),ch("n2",t,e,sh,n,-r,-1),ch("n3",t,e,sh,-n,r,-1),ch("n4",t,e,sh,n,r,-1),ch("f1",t,e,sh,-n,-r,1),ch("f2",t,e,sh,n,-r,1),ch("f3",t,e,sh,-n,r,1),ch("f4",t,e,sh,n,r,1),ch("u1",t,e,sh,.7*n,1.1*r,-1),ch("u2",t,e,sh,.7*-n,1.1*r,-1),ch("u3",t,e,sh,0,2*r,-1),ch("cf1",t,e,sh,-n,0,1),ch("cf2",t,e,sh,n,0,1),ch("cf3",t,e,sh,0,-r,1),ch("cf4",t,e,sh,0,r,1),ch("cn1",t,e,sh,-n,0,-1),ch("cn2",t,e,sh,n,0,-1),ch("cn3",t,e,sh,0,-r,-1),ch("cn4",t,e,sh,0,r,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function ch(e,t,n,r,o,a,i){ih.set(o,a,i).unproject(r);const s=t[e];if(void 0!==s){const e=n.getAttribute("position");for(let t=0,n=s.length;t<n;t++)e.setXYZ(s[t],ih.x,ih.y,ih.z)}}const fh=new Er;class uh extends Ac{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),o=new va;o.setIndex(new Yo(n,1)),o.setAttribute("position",new Yo(r,3)),super(o,new mc({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&fh.setFromObject(this.object),fh.isEmpty())return;const t=fh.min,n=fh.max,r=this.geometry.attributes.position,o=r.array;o[0]=n.x,o[1]=n.y,o[2]=n.z,o[3]=t.x,o[4]=n.y,o[5]=n.z,o[6]=t.x,o[7]=t.y,o[8]=n.z,o[9]=n.x,o[10]=t.y,o[11]=n.z,o[12]=n.x,o[13]=n.y,o[14]=t.z,o[15]=t.x,o[16]=n.y,o[17]=t.z,o[18]=t.x,o[19]=t.y,o[20]=t.z,o[21]=n.x,o[22]=t.y,o[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e){return Ac.prototype.copy.call(this,e),this.object=e.object,this}}class dh extends Ac{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],o=new va;o.setIndex(new Yo(n,1)),o.setAttribute("position",new ra(r,3)),super(o,new mc({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class ph extends bc{constructor(e,t=1,n=16776960){const r=n,o=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],a=new va;a.setAttribute("position",new ra(o,3)),a.computeBoundingSphere(),super(a,new mc({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const i=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],s=new va;s.setAttribute("position",new ra(i,3)),s.computeBoundingSphere(),this.add(new Na(s,new jo({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){let t=-this.plane.constant;Math.abs(t)<1e-8&&(t=1e-8),this.scale.set(.5*this.size,.5*this.size,t),this.children[0].material.side=t<0?p:d,this.lookAt(this.plane.normal),super.updateMatrixWorld(e)}}const hh=new xr;let vh,mh;class xh extends Eo{constructor(e=new xr(0,0,1),t=new xr(0,0,0),n=1,r=16776960,o=.2*n,a=.2*o){super(),this.type="ArrowHelper",void 0===vh&&(vh=new va,vh.setAttribute("position",new ra([0,0,0,0,1,0],3)),mh=new Oc(0,.5,1,5,1),mh.translate(0,-.5,0)),this.position.copy(t),this.line=new bc(vh,new mc({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Na(mh,new jo({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,o,a)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{hh.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(hh,t)}}setLength(e,t=.2*e,n=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class gh extends Ac{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new va;r.setAttribute("position",new ra(t,3)),r.setAttribute("color",new ra(n,3)),super(r,new mc({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const yh=new Float32Array(1),Eh=new Int32Array(yh.buffer);class wh{static toHalfFloat(e){yh[0]=e;const t=Eh[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255==o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}}const bh=4,_h=8,Th=Math.pow(2,_h),Ah=[.125,.215,.35,.446,.526,.582],Sh=_h-bh+1+Ah.length,Rh=20,Mh={[Yt]:0,[Qt]:1,[Zt]:2,[$t]:3,[en]:4,[tn]:5,[Kt]:6},Ch=new jo({side:p,depthWrite:!1,depthTest:!1}),Lh=new Na(new Da,Ch),Ph=new bd,{_lodPlanes:kh,_sizeLods:Nh,_sigmas:Hh}=Vh(),zh=new Wo;let Dh=null;const Fh=(1+Math.sqrt(5))/2,Ih=1/Fh,Oh=[new xr(1,1,1),new xr(-1,1,1),new xr(1,1,-1),new xr(-1,1,-1),new xr(0,Fh,Ih),new xr(0,Fh,-Ih),new xr(Ih,0,Fh),new xr(-Ih,0,Fh),new xr(Fh,Ih,0),new xr(-Fh,Ih,0)];function Uh(e){const t=Math.max(e.r,e.g,e.b),n=Math.min(Math.max(Math.ceil(Math.log2(t)),-128),127);return e.multiplyScalar(Math.pow(2,-n)),(n+128)/255}class Gh{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=qh(Rh),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,r=100){Dh=this._renderer.getRenderTarget();const o=this._allocateTargets();return this._sceneToCubeUV(e,n,r,o),t>0&&this._blur(o,0,0,t),this._applyPMREM(o),this._cleanup(o),o}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=Yh(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=Xh(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let e=0;e<kh.length;e++)kh[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Dh),e.scissorTest=!1,jh(e,0,0,e.width,e.height)}_fromTexture(e){Dh=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:de,minFilter:de,generateMipmaps:!1,type:be,format:Oe,encoding:Bh(e)?e.encoding:Zt,depthBuffer:!1},n=Wh(t);return n.depthBuffer=!e,this._pingPongRenderTarget=Wh(t),n}_compileMaterial(e){const t=new Na(kh[0],e);this._renderer.compile(t,Ph)}_sceneToCubeUV(e,t,n,r){const o=new Wa(90,1,t,n),a=[1,-1,1,1,1,1],i=[1,1,1,-1,-1,-1],s=this._renderer,l=s.autoClear,c=s.outputEncoding,f=s.toneMapping;s.getClearColor(zh),s.toneMapping=K,s.outputEncoding=Yt,s.autoClear=!1;let u=!1;const d=e.background;if(d){if(d.isColor){Ch.color.copy(d).convertSRGBToLinear(),e.background=null;const t=Uh(Ch.color);Ch.opacity=t,u=!0}}else{Ch.color.copy(zh).convertSRGBToLinear();const e=Uh(Ch.color);Ch.opacity=e,u=!0}for(let t=0;t<6;t++){const n=t%3;0==n?(o.up.set(0,a[t],0),o.lookAt(i[t],0,0)):1==n?(o.up.set(0,0,a[t]),o.lookAt(0,i[t],0)):(o.up.set(0,a[t],0),o.lookAt(0,0,i[t])),jh(r,n*Th,t>2?Th:0,Th,Th),s.setRenderTarget(r),u&&s.render(Lh,o),s.render(e,o)}s.toneMapping=f,s.outputEncoding=c,s.autoClear=l}_textureToCubeUV(e,t){const n=this._renderer;e.isCubeTexture?null==this._cubemapShader&&(this._cubemapShader=Yh()):null==this._equirectShader&&(this._equirectShader=Xh());const r=e.isCubeTexture?this._cubemapShader:this._equirectShader,o=new Na(kh[0],r),a=r.uniforms;a.envMap.value=e,e.isCubeTexture||a.texelSize.value.set(1/e.image.width,1/e.image.height),a.inputEncoding.value=Mh[e.encoding],a.outputEncoding.value=Mh[t.texture.encoding],jh(t,0,0,3*Th,2*Th),n.setRenderTarget(t),n.render(o,Ph)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let t=1;t<Sh;t++){const n=Math.sqrt(Hh[t]*Hh[t]-Hh[t-1]*Hh[t-1]),r=Oh[(t-1)%Oh.length];this._blur(e,t-1,t,n,r)}t.autoClear=n}_blur(e,t,n,r,o){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,r,"latitudinal",o),this._halfBlur(a,e,n,n,r,"longitudinal",o)}_halfBlur(e,t,n,r,o,a,i){const s=this._renderer,l=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,f=new Na(kh[r],l),u=l.uniforms,d=Nh[n]-1,p=isFinite(o)?Math.PI/(2*d):2*Math.PI/(2*Rh-1),h=o/p,v=isFinite(o)?1+Math.floor(c*h):Rh;v>Rh&&console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Rh}`);const m=[];let x=0;for(let e=0;e<Rh;++e){const t=e/h,n=Math.exp(-t*t/2);m.push(n),0==e?x+=n:e<v&&(x+=2*n)}for(let e=0;e<m.length;e++)m[e]=m[e]/x;u.envMap.value=e.texture,u.samples.value=v,u.weights.value=m,u.latitudinal.value="latitudinal"===a,i&&(u.poleAxis.value=i),u.dTheta.value=p,u.mipInt.value=_h-n,u.inputEncoding.value=Mh[e.texture.encoding],u.outputEncoding.value=Mh[e.texture.encoding];const g=Nh[r];jh(t,3*Math.max(0,Th-2*g),(0===r?0:2*Th)+2*g*(r>_h-bh?r-_h+bh:0),3*g,2*g),s.setRenderTarget(t),s.render(f,Ph)}}function Bh(e){return void 0!==e&&e.type===be&&(e.encoding===Yt||e.encoding===Qt||e.encoding===Kt)}function Vh(){const e=[],t=[],n=[];let r=_h;for(let o=0;o<Sh;o++){const a=Math.pow(2,r);t.push(a);let i=1/a;o>_h-bh?i=Ah[o-_h+bh-1]:0==o&&(i=0),n.push(i);const s=1/(a-1),l=-s/2,c=1+s/2,f=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,d=6,p=3,h=2,v=1,m=new Float32Array(p*d*u),x=new Float32Array(h*d*u),g=new Float32Array(v*d*u);for(let e=0;e<u;e++){const t=e%3*2/3-1,n=e>2?0:-1,r=[t,n,0,t+2/3,n,0,t+2/3,n+1,0,t,n,0,t+2/3,n+1,0,t,n+1,0];m.set(r,p*d*e),x.set(f,h*d*e);const o=[e,e,e,e,e,e];g.set(o,v*d*e)}const y=new va;y.setAttribute("position",new Yo(m,p)),y.setAttribute("uv",new Yo(x,h)),y.setAttribute("faceIndex",new Yo(g,v)),e.push(y),r>bh&&r--}return{_lodPlanes:e,_sizeLods:t,_sigmas:n}}function Wh(e){const t=new hr(3*Th,3*Th,e);return t.texture.mapping=se,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function jh(e,t,n,r,o){e.viewport.set(t,n,r,o),e.scissor.set(t,n,r,o)}function qh(e){const t=new Float32Array(e),n=new xr(0,1,0);return new Qf({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n},inputEncoding:{value:Mh[Yt]},outputEncoding:{value:Mh[Yt]}},vertexShader:Qh(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${Kh()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:x,depthTest:!1,depthWrite:!1})}function Xh(){const e=new ir(1,1);return new Qf({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:e},inputEncoding:{value:Mh[Yt]},outputEncoding:{value:Mh[Yt]}},vertexShader:Qh(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${Kh()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:x,depthTest:!1,depthWrite:!1})}function Yh(){return new Qf({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Mh[Yt]},outputEncoding:{value:Mh[Yt]}},vertexShader:Qh(),fragmentShader:`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${Kh()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,blending:x,depthTest:!1,depthWrite:!1})}function Qh(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function Kh(){return"\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"}const Zh=0,Jh=1,$h=0,ev=1,tv=2;function nv(e){return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),e}function rv(e=[]){return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),e.isMultiMaterial=!0,e.materials=e,e.clone=function(){return e.slice()},e}function ov(e,t){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new kc(e,t)}function av(e){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Kl(e)}function iv(e,t){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new kc(e,t)}function sv(e){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new Rc(e)}function lv(e){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new Rc(e)}function cv(e){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new Rc(e)}function fv(e,t,n){return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),new xr(e,t,n)}function uv(e,t){return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."),new Yo(e,t).setUsage(Tn)}function dv(e,t){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new Qo(e,t)}function pv(e,t){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new Ko(e,t)}function hv(e,t){return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),new Zo(e,t)}function vv(e,t){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new Jo(e,t)}function mv(e,t){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new $o(e,t)}function xv(e,t){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new ea(e,t)}function gv(e,t){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new ta(e,t)}function yv(e,t){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new ra(e,t)}function Ev(e,t){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new oa(e,t)}function wv(e){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new gh(e)}function bv(e,t){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new uh(e,t)}function _v(e,t){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new Ac(new Xc(e.geometry),new mc({color:void 0!==t?t:16777215}))}function Tv(e,t){return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),new Ac(new qf(e.geometry),new mc({color:void 0!==t?t:16777215}))}function Av(e){return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),new Su(e)}function Sv(e){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new Pu(e)}function Rv(e,t,n){return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."),new Qa(e,n)}function Mv(){console.error("THREE.CanvasRenderer has been removed")}function Cv(){console.error("THREE.JSONLoader has been removed.")}Nu.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(Nu.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e},sd.prototype.fromPoints=function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)},eh.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},Xp.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Tu.prototype.extractUrlBase=function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Ld.extractUrlBase(e)},Tu.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Fp.prototype.center=function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},Fp.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Fp.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},Fp.prototype.size=function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)},Er.prototype.center=function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},Er.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},Er.prototype.isIntersectionBox=function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},Er.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},Er.prototype.size=function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)},Or.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},$a.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)},Up.prototype.center=function(e){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(e)},sr.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},sr.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},sr.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},sr.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},sr.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},sr.prototype.getInverse=function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},Yr.prototype.extractPosition=function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},Yr.prototype.flattenToArrayOffset=function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},Yr.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),(new xr).setFromMatrixColumn(this,3)},Yr.prototype.setRotationFromQuaternion=function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},Yr.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},Yr.prototype.multiplyVector3=function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Yr.prototype.multiplyVector4=function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Yr.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},Yr.prototype.rotateAxis=function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},Yr.prototype.crossVector=function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Yr.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},Yr.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},Yr.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},Yr.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},Yr.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},Yr.prototype.applyToBufferAttribute=function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},Yr.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},Yr.prototype.makeFrustum=function(e,t,n,r,o,a){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,r,n,o,a)},Yr.prototype.getInverse=function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()},To.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)},mr.prototype.multiplyVector3=function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},mr.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Xr.prototype.isIntersectionBox=function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},Xr.prototype.isIntersectionPlane=function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},Xr.prototype.isIntersectionSphere=function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},zo.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},zo.prototype.barycoordFromPoint=function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},zo.prototype.midpoint=function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},zo.prototypenormal=function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},zo.prototype.plane=function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)},zo.barycoordFromPoint=function(e,t,n,r,o){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),zo.getBarycoord(e,t,n,r,o)},zo.normal=function(e,t,n,r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),zo.getNormal(e,t,n,r)},ld.prototype.extractAllPoints=function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},ld.prototype.extrude=function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Lf(this,e)},ld.prototype.makeGeometry=function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new If(this,e)},ir.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},ir.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},ir.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},xr.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},xr.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},xr.prototype.getPositionFromMatrix=function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},xr.prototype.getScaleFromMatrix=function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},xr.prototype.getColumnFromMatrix=function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},xr.prototype.applyProjection=function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},xr.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},xr.prototype.distanceToManhattan=function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},xr.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},pr.prototype.fromAttribute=function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},pr.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Eo.prototype.getChildByName=function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},Eo.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},Eo.prototype.translate=function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},Eo.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},Eo.prototype.applyMatrix=function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(Eo.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Na.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(Na.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),jt},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),ic.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Wa.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==t&&(this.filmGauge=t),this.setFocalLength(e)},Object.defineProperties(cd.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}}),Object.defineProperties(Yo.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Tn},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Tn)}}}),Yo.prototype.setDynamic=function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Tn:_n),this},Yo.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},Yo.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},va.prototype.addIndex=function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},va.prototype.addAttribute=function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),t&&t.isBufferAttribute||t&&t.isInterleavedBufferAttribute?"index"===e?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Yo(arguments[1],arguments[2])))},va.prototype.addDrawCall=function(e,t,n){void 0!==n&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},va.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},va.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},va.prototype.removeAttribute=function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},va.prototype.applyMatrix=function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)},Object.defineProperties(va.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Nl.prototype.setDynamic=function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===e?Tn:_n),this},Nl.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},Lf.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},Lf.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},Lf.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},kl.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},Mp.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Fo.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Wo}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===v}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}}),Object.defineProperties(Ba.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}}),Ml.prototype.clearTarget=function(e,t,n,r){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,r)},Ml.prototype.animate=function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},Ml.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},Ml.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},Ml.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},Ml.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},Ml.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},Ml.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},Ml.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},Ml.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},Ml.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},Ml.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},Ml.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},Ml.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},Ml.prototype.enableScissorTest=function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},Ml.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},Ml.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},Ml.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},Ml.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},Ml.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},Ml.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},Ml.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},Ml.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},Ml.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},Ml.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(Ml.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===e?Qt:Yt}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(xl.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(hr.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}}),ap.prototype.load=function(e){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return(new qd).load(e,(function(e){t.setBuffer(e)})),this},up.prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},Xa.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)},Xa.prototype.clear=function(e,t,n,r){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,r)},cr.crossOrigin=void 0,cr.loadTexture=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const o=new ku;o.setCrossOrigin(this.crossOrigin);const a=o.load(e,n,void 0,r);return t&&(a.mapping=t),a},cr.loadTextureCube=function(e,t,n,r){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const o=new Lu;o.setCrossOrigin(this.crossOrigin);const a=o.load(e,n,void 0,r);return t&&(a.mapping=t),a},cr.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},cr.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};const Lv={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};function Pv(){console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:t}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=t),e.ACESFilmicToneMapping=ee,e.AddEquation=_,e.AddOperation=Q,e.AdditiveAnimationBlendMode=Wt,e.AdditiveBlending=y,e.AlphaFormat=He,e.AlwaysDepth=U,e.AlwaysStencilFunc=bn,e.AmbientLight=Ad,e.AmbientLightProbe=Yd,e.AnimationClip=gu,e.AnimationLoader=Ru,e.AnimationMixer=Rp,e.AnimationObjectGroup=Ap,e.AnimationUtils=au,e.ArcCurve=zu,e.ArrayCamera=wl,e.ArrowHelper=xh,e.Audio=ap,e.AudioAnalyser=up,e.AudioContext=jd,e.AudioListener=op,e.AudioLoader=qd,e.AxesHelper=gh,e.AxisHelper=wv,e.BackSide=p,e.BasicDepthPacking=nn,e.BasicShadowMap=l,e.BinaryTextureLoader=Sv,e.Bone=sc,e.BooleanKeyframeTrack=uu,e.BoundingBoxHelper=bv,e.Box2=Fp,e.Box3=Er,e.Box3Helper=dh,e.BoxBufferGeometry=Da,e.BoxGeometry=Da,e.BoxHelper=uh,e.BufferAttribute=Yo,e.BufferGeometry=va,e.BufferGeometryLoader=Nd,e.ByteType=_e,e.Cache=wu,e.Camera=Va,e.CameraHelper=lh,e.CanvasRenderer=Mv,e.CanvasTexture=Dc,e.CatmullRomCurve3=Gu,e.CineonToneMapping=$,e.CircleBufferGeometry=Ic,e.CircleGeometry=Ic,e.ClampToEdgeWrapping=fe,e.Clock=Jd,e.Color=Wo,e.ColorKeyframeTrack=du,e.CompressedTexture=zc,e.CompressedTextureLoader=Mu,e.ConeBufferGeometry=Uc,e.ConeGeometry=Uc,e.CubeCamera=Xa,e.CubeReflectionMapping=re,e.CubeRefractionMapping=oe,e.CubeTexture=Ya,e.CubeTextureLoader=Lu,e.CubeUVReflectionMapping=se,e.CubeUVRefractionMapping=le,e.CubicBezierCurve=Ju,e.CubicBezierCurve3=$u,e.CubicInterpolant=su,e.CullFaceBack=a,e.CullFaceFront=i,e.CullFaceFrontBack=s,e.CullFaceNone=o,e.Curve=Nu,e.CurvePath=id,e.CustomBlending=b,e.CustomToneMapping=te,e.CylinderBufferGeometry=Oc,e.CylinderGeometry=Oc,e.Cylindrical=zp,e.DataTexture=Ka,e.DataTexture2DArray=Ei,e.DataTexture3D=wi,e.DataTextureLoader=Pu,e.DataUtils=wh,e.DecrementStencilOp=un,e.DecrementWrapStencilOp=pn,e.DefaultLoadingManager=_u,e.DepthFormat=Ue,e.DepthStencilFormat=Ge,e.DepthTexture=Fc,e.DirectionalLight=Td,e.DirectionalLightHelper=ah,e.DiscreteInterpolant=cu,e.DodecahedronBufferGeometry=Bc,e.DodecahedronGeometry=Bc,e.DoubleSide=h,e.DstAlphaFactor=H,e.DstColorFactor=D,e.DynamicBufferAttribute=uv,e.DynamicCopyUsage=Ln,e.DynamicDrawUsage=Tn,e.DynamicReadUsage=Rn,e.EdgesGeometry=Xc,e.EdgesHelper=_v,e.EllipseCurve=Hu,e.EqualDepth=V,e.EqualStencilFunc=xn,e.EquirectangularReflectionMapping=ae,e.EquirectangularRefractionMapping=ie,e.Euler=oo,e.EventDispatcher=Hn,e.ExtrudeBufferGeometry=Lf,e.ExtrudeGeometry=Lf,e.FaceColors=ev,e.FileLoader=Su,e.FlatShading=v,e.Float16BufferAttribute=na,e.Float32Attribute=yv,e.Float32BufferAttribute=ra,e.Float64Attribute=Ev,e.Float64BufferAttribute=oa,e.FloatType=Me,e.Fog=Pl,e.FogExp2=Ll,e.Font=Ud,e.FontLoader=Vd,e.FrontSide=d,e.Frustum=$a,e.GLBufferAttribute=Lp,e.GLSL1=kn,e.GLSL3=Nn,e.GammaEncoding=Kt,e.GreaterDepth=j,e.GreaterEqualDepth=W,e.GreaterEqualStencilFunc=wn,e.GreaterStencilFunc=yn,e.GridHelper=eh,e.Group=bl,e.HalfFloatType=Ce,e.HemisphereLight=fd,e.HemisphereLightHelper=$p,e.HemisphereLightProbe=Xd,e.IcosahedronBufferGeometry=Nf,e.IcosahedronGeometry=Nf,e.ImageBitmapLoader=Id,e.ImageLoader=Cu,e.ImageUtils=cr,e.ImmediateRenderObject=Gp,e.IncrementStencilOp=fn,e.IncrementWrapStencilOp=dn,e.InstancedBufferAttribute=kd,e.InstancedBufferGeometry=Pd,e.InstancedInterleavedBuffer=Cp,e.InstancedMesh=vc,e.Int16Attribute=vv,e.Int16BufferAttribute=Jo,e.Int32Attribute=xv,e.Int32BufferAttribute=ea,e.Int8Attribute=dv,e.Int8BufferAttribute=Qo,e.IntType=Se,e.InterleavedBuffer=Nl,e.InterleavedBufferAttribute=zl,e.Interpolant=iu,e.InterpolateDiscrete=Ft,e.InterpolateLinear=It,e.InterpolateSmooth=Ot,e.InvertStencilOp=hn,e.JSONLoader=Cv,e.KeepStencilOp=ln,e.KeyframeTrack=fu,e.LOD=ec,e.LatheBufferGeometry=Hf,e.LatheGeometry=Hf,e.Layers=ao,e.LensFlare=Pv,e.LessDepth=G,e.LessEqualDepth=B,e.LessEqualStencilFunc=gn,e.LessStencilFunc=mn,e.Light=cd,e.LightProbe=Md,e.Line=bc,e.Line3=Up,e.LineBasicMaterial=mc,e.LineCurve=ed,e.LineCurve3=td,e.LineDashedMaterial=ru,e.LineLoop=Sc,e.LinePieces=Jh,e.LineSegments=Ac,e.LineStrip=Zh,e.LinearEncoding=Yt,e.LinearFilter=xe,e.LinearInterpolant=lu,e.LinearMipMapLinearFilter=we,e.LinearMipMapNearestFilter=ye,e.LinearMipmapLinearFilter=Ee,e.LinearMipmapNearestFilter=ge,e.LinearToneMapping=Z,e.Loader=Tu,e.LoaderUtils=Ld,e.LoadingManager=bu,e.LogLuvEncoding=Jt,e.LoopOnce=Ht,e.LoopPingPong=Dt,e.LoopRepeat=zt,e.LuminanceAlphaFormat=Ie,e.LuminanceFormat=Fe,e.MOUSE=n,e.Material=Fo,e.MaterialLoader=Cd,e.Math=ar,e.MathUtils=ar,e.Matrix3=sr,e.Matrix4=Yr,e.MaxEquation=R,e.Mesh=Na,e.MeshBasicMaterial=jo,e.MeshDepthMaterial=pl,e.MeshDistanceMaterial=hl,e.MeshFaceMaterial=nv,e.MeshLambertMaterial=tu,e.MeshMatcapMaterial=nu,e.MeshNormalMaterial=eu,e.MeshPhongMaterial=Jf,e.MeshPhysicalMaterial=Zf,e.MeshStandardMaterial=Kf,e.MeshToonMaterial=$f,e.MinEquation=S,e.MirroredRepeatWrapping=ue,e.MixOperation=Y,e.MultiMaterial=rv,e.MultiplyBlending=w,e.MultiplyOperation=X,e.NearestFilter=de,e.NearestMipMapLinearFilter=me,e.NearestMipMapNearestFilter=he,e.NearestMipmapLinearFilter=ve,e.NearestMipmapNearestFilter=pe,e.NeverDepth=O,e.NeverStencilFunc=vn,e.NoBlending=x,e.NoColors=$h,e.NoToneMapping=K,e.NormalAnimationBlendMode=Vt,e.NormalBlending=g,e.NotEqualDepth=q,e.NotEqualStencilFunc=En,e.NumberKeyframeTrack=pu,e.Object3D=Eo,e.ObjectLoader=Hd,e.ObjectSpaceNormalMap=an,e.OctahedronBufferGeometry=zf,e.OctahedronGeometry=zf,e.OneFactor=C,e.OneMinusDstAlphaFactor=z,e.OneMinusDstColorFactor=F,e.OneMinusSrcAlphaFactor=N,e.OneMinusSrcColorFactor=P,e.OrthographicCamera=bd,e.PCFShadowMap=c,e.PCFSoftShadowMap=f,e.PMREMGenerator=Gh,e.ParametricBufferGeometry=Df,e.ParametricGeometry=Df,e.Particle=av,e.ParticleBasicMaterial=lv,e.ParticleSystem=iv,e.ParticleSystemMaterial=cv,e.Path=sd,e.PerspectiveCamera=Wa,e.Plane=To,e.PlaneBufferGeometry=ni,e.PlaneGeometry=ni,e.PlaneHelper=ph,e.PointCloud=ov,e.PointCloudMaterial=sv,e.PointLight=wd,e.PointLightHelper=Qp,e.Points=kc,e.PointsMaterial=Rc,e.PolarGridHelper=th,e.PolyhedronBufferGeometry=Gc,e.PolyhedronGeometry=Gc,e.PositionalAudio=fp,e.PropertyBinding=Tp,e.PropertyMixer=dp,e.QuadraticBezierCurve=nd,e.QuadraticBezierCurve3=rd,e.Quaternion=mr,e.QuaternionKeyframeTrack=vu,e.QuaternionLinearInterpolant=hu,e.REVISION=t,e.RGBADepthPacking=rn,e.RGBAFormat=De,e.RGBAIntegerFormat=Xe,e.RGBA_ASTC_10x10_Format=mt,e.RGBA_ASTC_10x5_Format=pt,e.RGBA_ASTC_10x6_Format=ht,e.RGBA_ASTC_10x8_Format=vt,e.RGBA_ASTC_12x10_Format=xt,e.RGBA_ASTC_12x12_Format=gt,e.RGBA_ASTC_4x4_Format=at,e.RGBA_ASTC_5x4_Format=it,e.RGBA_ASTC_5x5_Format=st,e.RGBA_ASTC_6x5_Format=lt,e.RGBA_ASTC_6x6_Format=ct,e.RGBA_ASTC_8x5_Format=ft,e.RGBA_ASTC_8x6_Format=ut,e.RGBA_ASTC_8x8_Format=dt,e.RGBA_BPTC_Format=yt,e.RGBA_ETC2_EAC_Format=ot,e.RGBA_PVRTC_2BPPV1_Format=tt,e.RGBA_PVRTC_4BPPV1_Format=et,e.RGBA_S3TC_DXT1_Format=Qe,e.RGBA_S3TC_DXT3_Format=Ke,e.RGBA_S3TC_DXT5_Format=Ze,e.RGBDEncoding=tn,e.RGBEEncoding=Zt,e.RGBEFormat=Oe,e.RGBFormat=ze,e.RGBIntegerFormat=qe,e.RGBM16Encoding=en,e.RGBM7Encoding=$t,e.RGB_ETC1_Format=nt,e.RGB_ETC2_Format=rt,e.RGB_PVRTC_2BPPV1_Format=$e,e.RGB_PVRTC_4BPPV1_Format=Je,e.RGB_S3TC_DXT1_Format=Ye,e.RGFormat=We,e.RGIntegerFormat=je,e.RawShaderMaterial=Qf,e.Ray=Xr,e.Raycaster=Pp,e.RectAreaLight=Sd,e.RedFormat=Be,e.RedIntegerFormat=Ve,e.ReinhardToneMapping=J,e.RepeatWrapping=ce,e.ReplaceStencilOp=cn,e.ReverseSubtractEquation=A,e.RingBufferGeometry=Ff,e.RingGeometry=Ff,e.SRGB8_ALPHA8_ASTC_10x10_Format=Pt,e.SRGB8_ALPHA8_ASTC_10x5_Format=Mt,e.SRGB8_ALPHA8_ASTC_10x6_Format=Ct,e.SRGB8_ALPHA8_ASTC_10x8_Format=Lt,e.SRGB8_ALPHA8_ASTC_12x10_Format=kt,e.SRGB8_ALPHA8_ASTC_12x12_Format=Nt,e.SRGB8_ALPHA8_ASTC_4x4_Format=Et,e.SRGB8_ALPHA8_ASTC_5x4_Format=wt,e.SRGB8_ALPHA8_ASTC_5x5_Format=bt,e.SRGB8_ALPHA8_ASTC_6x5_Format=_t,e.SRGB8_ALPHA8_ASTC_6x6_Format=Tt,e.SRGB8_ALPHA8_ASTC_8x5_Format=At,e.SRGB8_ALPHA8_ASTC_8x6_Format=St,e.SRGB8_ALPHA8_ASTC_8x8_Format=Rt,e.Scene=kl,e.SceneUtils=Lv,e.ShaderChunk=ri,e.ShaderLib=ai,e.ShaderMaterial=Ba,e.ShadowMaterial=Yf,e.Shape=ld,e.ShapeBufferGeometry=If,e.ShapeGeometry=If,e.ShapePath=Od,e.ShapeUtils=Rf,e.ShortType=Te,e.Skeleton=fc,e.SkeletonHelper=Xp,e.SkinnedMesh=ic,e.SmoothShading=m,e.Sphere=Or,e.SphereBufferGeometry=Uf,e.SphereGeometry=Uf,e.Spherical=Hp,e.SphericalHarmonics3=Rd,e.SplineCurve=od,e.SpotLight=md,e.SpotLightHelper=Vp,e.Sprite=Kl,e.SpriteMaterial=Dl,e.SrcAlphaFactor=k,e.SrcAlphaSaturateFactor=I,e.SrcColorFactor=L,e.StaticCopyUsage=Cn,e.StaticDrawUsage=_n,e.StaticReadUsage=Sn,e.StereoCamera=Zd,e.StreamCopyUsage=Pn,e.StreamDrawUsage=An,e.StreamReadUsage=Mn,e.StringKeyframeTrack=mu,e.SubtractEquation=T,e.SubtractiveBlending=E,e.TOUCH=r,e.TangentSpaceNormalMap=on,e.TetrahedronBufferGeometry=Gf,e.TetrahedronGeometry=Gf,e.TextBufferGeometry=Bf,e.TextGeometry=Bf,e.Texture=ur,e.TextureLoader=ku,e.TorusBufferGeometry=Vf,e.TorusGeometry=Vf,e.TorusKnotBufferGeometry=Wf,e.TorusKnotGeometry=Wf,e.Triangle=zo,e.TriangleFanDrawMode=Xt,e.TriangleStripDrawMode=qt,e.TrianglesDrawMode=jt,e.TubeBufferGeometry=jf,e.TubeGeometry=jf,e.UVMapping=ne,e.Uint16Attribute=mv,e.Uint16BufferAttribute=$o,e.Uint32Attribute=gv,e.Uint32BufferAttribute=ta,e.Uint8Attribute=pv,e.Uint8BufferAttribute=Ko,e.Uint8ClampedAttribute=hv,e.Uint8ClampedBufferAttribute=Zo,e.Uniform=Mp,e.UniformsLib=oi,e.UniformsUtils=Oa,e.UnsignedByteType=be,e.UnsignedInt248Type=Ne,e.UnsignedIntType=Re,e.UnsignedShort4444Type=Le,e.UnsignedShort5551Type=Pe,e.UnsignedShort565Type=ke,e.UnsignedShortType=Ae,e.VSMShadowMap=u,e.Vector2=ir,e.Vector3=xr,e.Vector4=pr,e.VectorKeyframeTrack=xu,e.Vertex=fv,e.VertexColors=tv,e.VideoTexture=Hc,e.WebGL1Renderer=Cl,e.WebGLCubeRenderTarget=Qa,e.WebGLMultisampleRenderTarget=vr,e.WebGLRenderTarget=hr,e.WebGLRenderTargetCube=Rv,e.WebGLRenderer=Ml,e.WebGLUtils=El,e.WireframeGeometry=qf,e.WireframeHelper=Tv,e.WrapAroundEnding=Bt,e.XHRLoader=Av,e.ZeroCurvatureEnding=Ut,e.ZeroFactor=M,e.ZeroSlopeEnding=Gt,e.ZeroStencilOp=sn,e.sRGBEncoding=Qt,Object.defineProperty(e,"__esModule",{value:!0})}(t)},743:(e,t,n)=>{"use strict";n.r(t),n.d(t,{Deflate:()=>Ee,AsyncDeflate:()=>we,deflate:()=>be,deflateSync:()=>_e,Inflate:()=>Te,AsyncInflate:()=>Ae,inflate:()=>Se,inflateSync:()=>Re,Gzip:()=>Me,AsyncGzip:()=>Ce,gzip:()=>Le,gzipSync:()=>Pe,Gunzip:()=>ke,AsyncGunzip:()=>Ne,gunzip:()=>He,gunzipSync:()=>ze,Zlib:()=>De,AsyncZlib:()=>Fe,zlib:()=>Ie,zlibSync:()=>Oe,Unzlib:()=>Ue,AsyncUnzlib:()=>Ge,unzlib:()=>Be,unzlibSync:()=>Ve,compress:()=>Le,AsyncCompress:()=>Ce,compressSync:()=>Pe,Compress:()=>Me,Decompress:()=>We,AsyncDecompress:()=>je,decompress:()=>qe,decompressSync:()=>Xe,DecodeUTF8:()=>$e,EncodeUTF8:()=>et,strToU8:()=>tt,strFromU8:()=>nt,ZipPassThrough:()=>ft,ZipDeflate:()=>ut,AsyncZipDeflate:()=>dt,Zip:()=>pt,zip:()=>ht,zipSync:()=>vt,UnzipPassThrough:()=>mt,UnzipInflate:()=>xt,AsyncUnzipInflate:()=>gt,Unzip:()=>yt,unzip:()=>Et,unzipSync:()=>wt});var r={},o=Uint8Array,a=Uint16Array,i=Uint32Array,s=new o([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),l=new o([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),c=new o([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(e,t){for(var n=new a(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new i(n[30]);for(r=1;r<30;++r)for(var s=n[r];s<n[r+1];++s)o[s]=s-n[r]<<5|r;return[n,o]},u=f(s,2),d=u[0],p=u[1];d[28]=258,p[258]=28;for(var h=f(l,0),v=h[0],m=h[1],x=new a(32768),g=0;g<32768;++g){var y=(43690&g)>>>1|(21845&g)<<1;y=(61680&(y=(52428&y)>>>2|(13107&y)<<2))>>>4|(3855&y)<<4,x[g]=((65280&y)>>>8|(255&y)<<8)>>>1}var E=function(e,t,n){for(var r=e.length,o=0,i=new a(t);o<r;++o)++i[e[o]-1];var s,l=new a(t);for(o=0;o<t;++o)l[o]=l[o-1]+i[o-1]<<1;if(n){s=new a(1<<t);var c=15-t;for(o=0;o<r;++o)if(e[o])for(var f=o<<4|e[o],u=t-e[o],d=l[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)s[x[d]>>>c]=f}else for(s=new a(r),o=0;o<r;++o)e[o]&&(s[o]=x[l[e[o]-1]++]>>>15-e[o]);return s},w=new o(288);for(g=0;g<144;++g)w[g]=8;for(g=144;g<256;++g)w[g]=9;for(g=256;g<280;++g)w[g]=7;for(g=280;g<288;++g)w[g]=8;var b=new o(32);for(g=0;g<32;++g)b[g]=5;var _=E(w,9,0),T=E(w,9,1),A=E(b,5,0),S=E(b,5,1),R=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},M=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},C=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},L=function(e){return(e/8|0)+(7&e&&1)},P=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(e instanceof a?a:e instanceof i?i:o)(n-t);return r.set(e.subarray(t,n)),r},k=function(e,t,n){var r=e.length;if(!r||n&&!n.l&&r<5)return t||new o(0);var a=!t||n,i=!n||n.i;n||(n={}),t||(t=new o(3*r));var f=function(e){var n=t.length;if(e>n){var r=new o(Math.max(2*n,e));r.set(t),t=r}},u=n.f||0,p=n.p||0,h=n.b||0,m=n.l,x=n.d,g=n.m,y=n.n,w=8*r;do{if(!m){n.f=u=M(e,p,1);var b=M(e,p+1,3);if(p+=3,!b){var _=e[(G=L(p)+4)-4]|e[G-3]<<8,A=G+_;if(A>r){if(i)throw"unexpected EOF";break}a&&f(h+_),t.set(e.subarray(G,A),h),n.b=h+=_,n.p=p=8*A;continue}if(1==b)m=T,x=S,g=9,y=5;else{if(2!=b)throw"invalid block type";var k=M(e,p,31)+257,N=M(e,p+10,15)+4,H=k+M(e,p+5,31)+1;p+=14;for(var z=new o(H),D=new o(19),F=0;F<N;++F)D[c[F]]=M(e,p+3*F,7);p+=3*N;var I=R(D),O=(1<<I)-1,U=E(D,I,1);for(F=0;F<H;){var G,B=U[M(e,p,O)];if(p+=15&B,(G=B>>>4)<16)z[F++]=G;else{var V=0,W=0;for(16==G?(W=3+M(e,p,3),p+=2,V=z[F-1]):17==G?(W=3+M(e,p,7),p+=3):18==G&&(W=11+M(e,p,127),p+=7);W--;)z[F++]=V}}var j=z.subarray(0,k),q=z.subarray(k);g=R(j),y=R(q),m=E(j,g,1),x=E(q,y,1)}if(p>w){if(i)throw"unexpected EOF";break}}a&&f(h+131072);for(var X=(1<<g)-1,Y=(1<<y)-1,Q=p;;Q=p){var K=(V=m[C(e,p)&X])>>>4;if((p+=15&V)>w){if(i)throw"unexpected EOF";break}if(!V)throw"invalid length/literal";if(K<256)t[h++]=K;else{if(256==K){Q=p,m=null;break}var Z=K-254;if(K>264){var J=s[F=K-257];Z=M(e,p,(1<<J)-1)+d[F],p+=J}var $=x[C(e,p)&Y],ee=$>>>4;if(!$)throw"invalid distance";p+=15&$;q=v[ee];if(ee>3){J=l[ee];q+=C(e,p)&(1<<J)-1,p+=J}if(p>w){if(i)throw"unexpected EOF";break}a&&f(h+131072);for(var te=h+Z;h<te;h+=4)t[h]=t[h-q],t[h+1]=t[h+1-q],t[h+2]=t[h+2-q],t[h+3]=t[h+3-q];h=te}}n.l=m,n.p=Q,n.b=h,m&&(u=1,n.m=g,n.d=x,n.n=y)}while(!u);return h==t.length?t:P(t,0,h)},N=function(e,t,n){n<<=7&t;var r=t/8|0;e[r]|=n,e[r+1]|=n>>>8},H=function(e,t,n){n<<=7&t;var r=t/8|0;e[r]|=n,e[r+1]|=n>>>8,e[r+2]|=n>>>16},z=function(e,t){for(var n=[],r=0;r<e.length;++r)e[r]&&n.push({s:r,f:e[r]});var i=n.length,s=n.slice();if(!i)return[B,0];if(1==i){var l=new o(n[0].s+1);return l[n[0].s]=1,[l,1]}n.sort((function(e,t){return e.f-t.f})),n.push({s:-1,f:25001});var c=n[0],f=n[1],u=0,d=1,p=2;for(n[0]={s:-1,f:c.f+f.f,l:c,r:f};d!=i-1;)c=n[n[u].f<n[p].f?u++:p++],f=n[u!=d&&n[u].f<n[p].f?u++:p++],n[d++]={s:-1,f:c.f+f.f,l:c,r:f};var h=s[0].s;for(r=1;r<i;++r)s[r].s>h&&(h=s[r].s);var v=new a(h+1),m=D(n[d-1],v,0);if(m>t){r=0;var x=0,g=m-t,y=1<<g;for(s.sort((function(e,t){return v[t.s]-v[e.s]||e.f-t.f}));r<i;++r){var E=s[r].s;if(!(v[E]>t))break;x+=y-(1<<m-v[E]),v[E]=t}for(x>>>=g;x>0;){var w=s[r].s;v[w]<t?x-=1<<t-v[w]++-1:++r}for(;r>=0&&x;--r){var b=s[r].s;v[b]==t&&(--v[b],++x)}m=t}return[new o(v),m]},D=function(e,t,n){return-1==e.s?Math.max(D(e.l,t,n+1),D(e.r,t,n+1)):t[e.s]=n},F=function(e){for(var t=e.length;t&&!e[--t];);for(var n=new a(++t),r=0,o=e[0],i=1,s=function(e){n[r++]=e},l=1;l<=t;++l)if(e[l]==o&&l!=t)++i;else{if(!o&&i>2){for(;i>138;i-=138)s(32754);i>2&&(s(i>10?i-11<<5|28690:i-3<<5|12305),i=0)}else if(i>3){for(s(o),--i;i>6;i-=6)s(8304);i>2&&(s(i-3<<5|8208),i=0)}for(;i--;)s(o);i=1,o=e[l]}return[n.subarray(0,r),t]},I=function(e,t){for(var n=0,r=0;r<t.length;++r)n+=e[r]*t[r];return n},O=function(e,t,n){var r=n.length,o=L(t+2);e[o]=255&r,e[o+1]=r>>>8,e[o+2]=255^e[o],e[o+3]=255^e[o+1];for(var a=0;a<r;++a)e[o+a+4]=n[a];return 8*(o+4+r)},U=function(e,t,n,r,o,i,f,u,d,p,h){N(t,h++,n),++o[256];for(var v=z(o,15),m=v[0],x=v[1],g=z(i,15),y=g[0],T=g[1],S=F(m),R=S[0],M=S[1],C=F(y),L=C[0],P=C[1],k=new a(19),D=0;D<R.length;++D)k[31&R[D]]++;for(D=0;D<L.length;++D)k[31&L[D]]++;for(var U=z(k,7),G=U[0],B=U[1],V=19;V>4&&!G[c[V-1]];--V);var W,j,q,X,Y=p+5<<3,Q=I(o,w)+I(i,b)+f,K=I(o,m)+I(i,y)+f+14+3*V+I(k,G)+(2*k[16]+3*k[17]+7*k[18]);if(Y<=Q&&Y<=K)return O(t,h,e.subarray(d,d+p));if(N(t,h,1+(K<Q)),h+=2,K<Q){W=E(m,x,0),j=m,q=E(y,T,0),X=y;var Z=E(G,B,0);N(t,h,M-257),N(t,h+5,P-1),N(t,h+10,V-4),h+=14;for(D=0;D<V;++D)N(t,h+3*D,G[c[D]]);h+=3*V;for(var J=[R,L],$=0;$<2;++$){var ee=J[$];for(D=0;D<ee.length;++D){var te=31&ee[D];N(t,h,Z[te]),h+=G[te],te>15&&(N(t,h,ee[D]>>>5&127),h+=ee[D]>>>12)}}}else W=_,j=w,q=A,X=b;for(D=0;D<u;++D)if(r[D]>255){te=r[D]>>>18&31;H(t,h,W[te+257]),h+=j[te+257],te>7&&(N(t,h,r[D]>>>23&31),h+=s[te]);var ne=31&r[D];H(t,h,q[ne]),h+=X[ne],ne>3&&(H(t,h,r[D]>>>5&8191),h+=l[ne])}else H(t,h,W[r[D]]),h+=j[r[D]];return H(t,h,W[256]),h+j[256]},G=new i([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),B=new o(0),V=function(e,t,n,r,c,f){var u=e.length,d=new o(r+u+5*(1+Math.ceil(u/7e3))+c),h=d.subarray(r,d.length-c),v=0;if(!t||u<8)for(var x=0;x<=u;x+=65535){var g=x+65535;g<u?v=O(h,v,e.subarray(x,g)):(h[x]=f,v=O(h,v,e.subarray(x,u)))}else{for(var y=G[t-1],E=y>>>13,w=8191&y,b=(1<<n)-1,_=new a(32768),T=new a(b+1),A=Math.ceil(n/3),S=2*A,R=function(t){return(e[t]^e[t+1]<<A^e[t+2]<<S)&b},M=new i(25e3),C=new a(288),k=new a(32),N=0,H=0,z=(x=0,0),D=0,F=0;x<u;++x){var I=R(x),V=32767&x,W=T[I];if(_[V]=W,T[I]=V,D<=x){var j=u-x;if((N>7e3||z>24576)&&j>423){v=U(e,h,0,M,C,k,H,z,F,x-F,v),z=N=H=0,F=x;for(var q=0;q<286;++q)C[q]=0;for(q=0;q<30;++q)k[q]=0}var X=2,Y=0,Q=w,K=V-W&32767;if(j>2&&I==R(x-K))for(var Z=Math.min(E,j)-1,J=Math.min(32767,x),$=Math.min(258,j);K<=J&&--Q&&V!=W;){if(e[x+X]==e[x+X-K]){for(var ee=0;ee<$&&e[x+ee]==e[x+ee-K];++ee);if(ee>X){if(X=ee,Y=K,ee>Z)break;var te=Math.min(K,ee-2),ne=0;for(q=0;q<te;++q){var re=x-K+q+32768&32767,oe=re-_[re]+32768&32767;oe>ne&&(ne=oe,W=re)}}}K+=(V=W)-(W=_[V])+32768&32767}if(Y){M[z++]=268435456|p[X]<<18|m[Y];var ae=31&p[X],ie=31&m[Y];H+=s[ae]+l[ie],++C[257+ae],++k[ie],D=x+X,++N}else M[z++]=e[x],++C[e[x]]}}v=U(e,h,f,M,C,k,H,z,F,x-F,v),!f&&7&v&&(v=O(h,v+1,B))}return P(d,0,r+L(v)+c)},W=function(){for(var e=new Int32Array(256),t=0;t<256;++t){for(var n=t,r=9;--r;)n=(1&n&&-306674912)^n>>>1;e[t]=n}return e}(),j=function(){var e=-1;return{p:function(t){for(var n=e,r=0;r<t.length;++r)n=W[255&n^t[r]]^n>>>8;e=n},d:function(){return~e}}},q=function(){var e=1,t=0;return{p:function(n){for(var r=e,o=t,a=n.length,i=0;i!=a;){for(var s=Math.min(i+2655,a);i<s;++i)o+=r+=n[i];r=(65535&r)+15*(r>>16),o=(65535&o)+15*(o>>16)}e=r,t=o},d:function(){return(255&(e%=65521))<<24|e>>>8<<16|(255&(t%=65521))<<8|t>>>8}}},X=function(e,t,n,r,o){return V(e,null==t.level?6:t.level,null==t.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(e.length)))):12+t.mem,n,r,!o)},Y=function(e,t){var n={};for(var r in e)n[r]=e[r];for(var r in t)n[r]=t[r];return n},Q=function(e,t,n){for(var r=e(),o=e.toString(),a=o.slice(o.indexOf("[")+1,o.lastIndexOf("]")).replace(/ /g,"").split(","),i=0;i<r.length;++i){var s=r[i],l=a[i];if("function"==typeof s){t+=";"+l+"=";var c=s.toString();if(s.prototype)if(-1!=c.indexOf("[native code]")){var f=c.indexOf(" ",8)+1;t+=c.slice(f,c.indexOf("(",f))}else for(var u in t+=c,s.prototype)t+=";"+l+".prototype."+u+"="+s.prototype[u].toString();else t+=c}else n[l]=s}return[t,n]},K=[],Z=function(e,t,n,s){var l;if(!K[n]){for(var c="",f={},u=e.length-1,d=0;d<u;++d)c=(l=Q(e[d],c,f))[0],f=l[1];K[n]=Q(e[u],c,f)}var p=Y({},K[n][1]);return function(e,t,n,o,a){var i=new Worker(r[t]||(r[t]=URL.createObjectURL(new Blob([e],{type:"text/javascript"}))));return i.onerror=function(e){return a(e.error,null)},i.onmessage=function(e){return a(null,e.data)},i.postMessage(n,o),i}(K[n][0]+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+t.toString()+"}",n,p,function(e){var t=[];for(var n in e)(e[n]instanceof o||e[n]instanceof a||e[n]instanceof i)&&t.push((e[n]=new e[n].constructor(e[n])).buffer);return t}(p),s)},J=function(){return[o,a,i,s,l,c,d,v,T,S,x,E,R,M,C,L,P,k,Re,oe,ae]},$=function(){return[o,a,i,s,l,c,p,m,_,w,A,b,x,G,B,E,N,H,z,D,F,I,O,U,L,P,V,X,_e,oe]},ee=function(){return[pe,me,de,j,W]},te=function(){return[he,ve]},ne=function(){return[xe,de,q]},re=function(){return[ge]},oe=function(e){return postMessage(e,[e.buffer])},ae=function(e){return e&&e.size&&new o(e.size)},ie=function(e,t,n,r,o,a){var i=Z(n,r,o,(function(e,t){i.terminate(),a(e,t)}));return i.postMessage([e,t],t.consume?[e.buffer]:[]),function(){i.terminate()}},se=function(e){return e.ondata=function(e,t){return postMessage([e,t],[e.buffer])},function(t){return e.push(t.data[0],t.data[1])}},le=function(e,t,n,r,o){var a,i=Z(e,r,o,(function(e,n){e?(i.terminate(),t.ondata.call(t,e)):(n[1]&&i.terminate(),t.ondata.call(t,e,n[0],n[1]))}));i.postMessage(n),t.push=function(e,n){if(a)throw"stream finished";if(!t.ondata)throw"no stream handler";i.postMessage([e,a=n],[e.buffer])},t.terminate=function(){i.terminate()}},ce=function(e,t){return e[t]|e[t+1]<<8},fe=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},ue=function(e,t){return fe(e,t)+4294967296*fe(e,t+4)},de=function(e,t,n){for(;n;++t)e[t]=n,n>>>=8},pe=function(e,t){var n=t.filename;if(e[0]=31,e[1]=139,e[2]=8,e[8]=t.level<2?4:9==t.level?2:0,e[9]=3,0!=t.mtime&&de(e,4,Math.floor(new Date(t.mtime||Date.now())/1e3)),n){e[3]=8;for(var r=0;r<=n.length;++r)e[r+10]=n.charCodeAt(r)}},he=function(e){if(31!=e[0]||139!=e[1]||8!=e[2])throw"invalid gzip data";var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)},ve=function(e){var t=e.length;return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0},me=function(e){return 10+(e.filename&&e.filename.length+1||0)},xe=function(e,t){var n=t.level,r=0==n?0:n<6?1:9==n?3:2;e[0]=120,e[1]=r<<6|(r?32-2*r:1)},ge=function(e){if(8!=(15&e[0])||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(32&e[1])throw"invalid zlib data: preset dictionaries not supported"};function ye(e,t){return t||"function"!=typeof e||(t=e,e={}),this.ondata=t,e}var Ee=function(){function e(e,t){t||"function"!=typeof e||(t=e,e={}),this.ondata=t,this.o=e||{}}return e.prototype.p=function(e,t){this.ondata(X(e,this.o,0,0,!t),t)},e.prototype.push=function(e,t){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";this.d=t,this.p(e,t||!1)},e}(),we=function(){return function(e,t){le([$,function(){return[se,Ee]}],this,ye.call(this,e,t),(function(e){var t=new Ee(e.data);onmessage=se(t)}),6)}}();function be(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[$],(function(e){return oe(_e(e.data[0],e.data[1]))}),0,n)}function _e(e,t){return X(e,t||{},0,0)}var Te=function(){function e(e){this.s={},this.p=new o(0),this.ondata=e}return e.prototype.e=function(e){if(this.d)throw"stream finished";if(!this.ondata)throw"no stream handler";var t=this.p.length,n=new o(t+e.length);n.set(this.p),n.set(e,t),this.p=n},e.prototype.c=function(e){this.d=this.s.i=e||!1;var t=this.s.b,n=k(this.p,this.o,this.s);this.ondata(P(n,t,this.s.b),this.d),this.o=P(n,this.s.b-32768),this.s.b=this.o.length,this.p=P(this.p,this.s.p/8|0),this.s.p&=7},e.prototype.push=function(e,t){this.e(e),this.c(t)},e}(),Ae=function(){return function(e){this.ondata=e,le([J,function(){return[se,Te]}],this,0,(function(){var e=new Te;onmessage=se(e)}),7)}}();function Se(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[J],(function(e){return oe(Re(e.data[0],ae(e.data[1])))}),1,n)}function Re(e,t){return k(e,t)}var Me=function(){function e(e,t){this.c=j(),this.l=0,this.v=1,Ee.call(this,e,t)}return e.prototype.push=function(e,t){Ee.prototype.push.call(this,e,t)},e.prototype.p=function(e,t){this.c.p(e),this.l+=e.length;var n=X(e,this.o,this.v&&me(this.o),t&&8,!t);this.v&&(pe(n,this.o),this.v=0),t&&(de(n,n.length-8,this.c.d()),de(n,n.length-4,this.l)),this.ondata(n,t)},e}(),Ce=function(){return function(e,t){le([$,ee,function(){return[se,Ee,Me]}],this,ye.call(this,e,t),(function(e){var t=new Me(e.data);onmessage=se(t)}),8)}}();function Le(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[$,ee,function(){return[Pe]}],(function(e){return oe(Pe(e.data[0],e.data[1]))}),2,n)}function Pe(e,t){t||(t={});var n=j(),r=e.length;n.p(e);var o=X(e,t,me(t),8),a=o.length;return pe(o,t),de(o,a-8,n.d()),de(o,a-4,r),o}var ke=function(){function e(e){this.v=1,Te.call(this,e)}return e.prototype.push=function(e,t){if(Te.prototype.e.call(this,e),this.v){var n=this.p.length>3?he(this.p):4;if(n>=this.p.length&&!t)return;this.p=this.p.subarray(n),this.v=0}if(t){if(this.p.length<8)throw"invalid gzip stream";this.p=this.p.subarray(0,-8)}Te.prototype.c.call(this,t)},e}(),Ne=function(){return function(e){this.ondata=e,le([J,te,function(){return[se,Te,ke]}],this,0,(function(){var e=new ke;onmessage=se(e)}),9)}}();function He(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[J,te,function(){return[ze]}],(function(e){return oe(ze(e.data[0]))}),3,n)}function ze(e,t){return k(e.subarray(he(e),-8),t||new o(ve(e)))}var De=function(){function e(e,t){this.c=q(),this.v=1,Ee.call(this,e,t)}return e.prototype.push=function(e,t){Ee.prototype.push.call(this,e,t)},e.prototype.p=function(e,t){this.c.p(e);var n=X(e,this.o,this.v&&2,t&&4,!t);this.v&&(xe(n,this.o),this.v=0),t&&de(n,n.length-4,this.c.d()),this.ondata(n,t)},e}(),Fe=function(){return function(e,t){le([$,ne,function(){return[se,Ee,De]}],this,ye.call(this,e,t),(function(e){var t=new De(e.data);onmessage=se(t)}),10)}}();function Ie(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[$,ne,function(){return[Oe]}],(function(e){return oe(Oe(e.data[0],e.data[1]))}),4,n)}function Oe(e,t){t||(t={});var n=q();n.p(e);var r=X(e,t,2,4);return xe(r,t),de(r,r.length-4,n.d()),r}var Ue=function(){function e(e){this.v=1,Te.call(this,e)}return e.prototype.push=function(e,t){if(Te.prototype.e.call(this,e),this.v){if(this.p.length<2&&!t)return;this.p=this.p.subarray(2),this.v=0}if(t){if(this.p.length<4)throw"invalid zlib stream";this.p=this.p.subarray(0,-4)}Te.prototype.c.call(this,t)},e}(),Ge=function(){return function(e){this.ondata=e,le([J,re,function(){return[se,Te,Ue]}],this,0,(function(){var e=new Ue;onmessage=se(e)}),11)}}();function Be(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return ie(e,t,[J,re,function(){return[Ve]}],(function(e){return oe(Ve(e.data[0],ae(e.data[1])))}),5,n)}function Ve(e,t){return k((ge(e),e.subarray(2,-4)),t)}var We=function(){function e(e){this.G=ke,this.I=Te,this.Z=Ue,this.ondata=e}return e.prototype.push=function(e,t){if(!this.ondata)throw"no stream handler";if(this.s)this.s.push(e,t);else{if(this.p&&this.p.length){var n=new o(this.p.length+e.length);n.set(this.p),n.set(e,this.p.length)}else this.p=e;if(this.p.length>2){var r=this,a=function(){r.ondata.apply(r,arguments)};this.s=31==this.p[0]&&139==this.p[1]&&8==this.p[2]?new this.G(a):8!=(15&this.p[0])||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(a):new this.Z(a),this.s.push(this.p,t),this.p=null}}},e}(),je=function(){function e(e){this.G=Ne,this.I=Ae,this.Z=Ge,this.ondata=e}return e.prototype.push=function(e,t){We.prototype.push.call(this,e,t)},e}();function qe(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";return 31==e[0]&&139==e[1]&&8==e[2]?He(e,t,n):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Se(e,t,n):Be(e,t,n)}function Xe(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?ze(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Re(e,t):Ve(e,t)}var Ye=function(e,t,n,r){for(var a in e){var i=e[a],s=t+a;i instanceof o?n[s]=[i,r]:Array.isArray(i)?n[s]=[i[0],Y(r,i[1])]:Ye(i,s+"/",n,r)}},Qe="undefined"!=typeof TextEncoder&&new TextEncoder,Ke="undefined"!=typeof TextDecoder&&new TextDecoder,Ze=0;try{Ke.decode(B,{stream:!0}),Ze=1}catch(e){}var Je=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,P(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}},$e=function(){function e(e){this.ondata=e,Ze?this.t=new TextDecoder:this.p=B}return e.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(t=!!t,this.t){if(this.ondata(this.t.decode(e,{stream:!0}),t),t){if(this.t.decode().length)throw"invalid utf-8 data";this.t=null}}else{if(!this.p)throw"stream finished";var n=new o(this.p.length+e.length);n.set(this.p),n.set(e,this.p.length);var r=Je(n),a=r[0],i=r[1];if(t){if(i.length)throw"invalid utf-8 data";this.p=null}else this.p=i;this.ondata(a,t)}},e}(),et=function(){function e(e){this.ondata=e}return e.prototype.push=function(e,t){if(!this.ondata)throw"no callback";if(this.d)throw"stream finished";this.ondata(tt(e),this.d=t||!1)},e}();function tt(e,t){if(t){for(var n=new o(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Qe)return Qe.encode(e);var a=e.length,i=new o(e.length+(e.length>>1)),s=0,l=function(e){i[s++]=e};for(r=0;r<a;++r){if(s+5>i.length){var c=new o(s+8+(a-r<<1));c.set(i),i=c}var f=e.charCodeAt(r);f<128||t?l(f):f<2048?(l(192|f>>6),l(128|63&f)):f>55295&&f<57344?(l(240|(f=65536+(1047552&f)|1023&e.charCodeAt(++r))>>18),l(128|f>>12&63),l(128|f>>6&63),l(128|63&f)):(l(224|f>>12),l(128|f>>6&63),l(128|63&f))}return P(i,0,s)}function nt(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Ke)return Ke.decode(e);var o=Je(e),a=o[0];if(o[1].length)throw"invalid utf-8 data";return a}var rt=function(e){return 1==e?3:e<6?2:9==e?1:0},ot=function(e,t){return t+30+ce(e,t+26)+ce(e,t+28)},at=function(e,t,n){var r=ce(e,t+28),o=nt(e.subarray(t+46,t+46+r),!(2048&ce(e,t+8))),a=t+46+r,i=fe(e,t+20),s=n&&4294967295==i?it(e,a):[i,fe(e,t+24),fe(e,t+42)],l=s[0],c=s[1],f=s[2];return[ce(e,t+10),l,c,o,a+ce(e,t+30)+ce(e,t+32),f]},it=function(e,t){for(;1!=ce(e,t);t+=4+ce(e,t+2));return[ue(e,t+12),ue(e,t+4),ue(e,t+20)]},st=function(e){var t=0;if(e)for(var n in e){var r=e[n].length;if(r>65535)throw"extra field too long";t+=r+4}return t},lt=function(e,t,n,r,o,a,i,s){var l=r.length,c=n.extra,f=s&&s.length,u=st(c);de(e,t,null!=i?33639248:67324752),t+=4,null!=i&&(e[t++]=20,e[t++]=n.os),e[t]=20,t+=2,e[t++]=n.flag<<1|(null==a&&8),e[t++]=o&&8,e[t++]=255&n.compression,e[t++]=n.compression>>8;var d=new Date(null==n.mtime?Date.now():n.mtime),p=d.getFullYear()-1980;if(p<0||p>119)throw"date not in range 1980-2099";if(de(e,t,p<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>>1),t+=4,null!=a&&(de(e,t,n.crc),de(e,t+4,a),de(e,t+8,n.size)),de(e,t+12,l),de(e,t+14,u),t+=16,null!=i&&(de(e,t,f),de(e,t+6,n.attrs),de(e,t+10,i),t+=14),e.set(r,t),t+=l,u)for(var h in c){var v=c[h],m=v.length;de(e,t,+h),de(e,t+2,m),e.set(v,t+4),t+=4+m}return f&&(e.set(s,t),t+=f),t},ct=function(e,t,n,r,o){de(e,t,101010256),de(e,t+8,n),de(e,t+10,n),de(e,t+12,r),de(e,t+16,o)},ft=function(){function e(e){this.filename=e,this.c=j(),this.size=0,this.compression=0}return e.prototype.process=function(e,t){this.ondata(null,e,t)},e.prototype.push=function(e,t){if(!this.ondata)throw"no callback - add to ZIP archive before pushing";this.c.p(e),this.size+=e.length,t&&(this.crc=this.c.d()),this.process(e,t||!1)},e}(),ut=function(){function e(e,t){var n=this;t||(t={}),ft.call(this,e),this.d=new Ee(t,(function(e,t){n.ondata(null,e,t)})),this.compression=8,this.flag=rt(t.level)}return e.prototype.process=function(e,t){try{this.d.push(e,t)}catch(e){this.ondata(e,null,t)}},e.prototype.push=function(e,t){ft.prototype.push.call(this,e,t)},e}(),dt=function(){function e(e,t){var n=this;t||(t={}),ft.call(this,e),this.d=new we(t,(function(e,t,r){n.ondata(e,t,r)})),this.compression=8,this.flag=rt(t.level),this.terminate=this.d.terminate}return e.prototype.process=function(e,t){this.d.push(e,t)},e.prototype.push=function(e,t){ft.prototype.push.call(this,e,t)},e}(),pt=function(){function e(e){this.ondata=e,this.u=[],this.d=1}return e.prototype.add=function(e){var t=this;if(2&this.d)throw"stream finished";var n=tt(e.filename),r=n.length,a=e.comment,i=a&&tt(a),s=r!=e.filename.length||i&&a.length!=i.length,l=r+st(e.extra)+30;if(r>65535)throw"filename too long";var c=new o(l);lt(c,0,e,n,s);var f=[c],u=function(){for(var e=0,n=f;e<n.length;e++){var r=n[e];t.ondata(null,r,!1)}f=[]},d=this.d;this.d=0;var p=this.u.length,h=Y(e,{f:n,u:s,o:i,t:function(){e.terminate&&e.terminate()},r:function(){if(u(),d){var e=t.u[p+1];e?e.r():t.d=1}d=1}}),v=0;e.ondata=function(n,r,a){if(n)t.ondata(n,r,a),t.terminate();else if(v+=r.length,f.push(r),a){var i=new o(16);de(i,0,134695760),de(i,4,e.crc),de(i,8,v),de(i,12,e.size),f.push(i),h.c=v,h.b=l+v+16,h.crc=e.crc,h.size=e.size,d&&h.r(),d=1}else d&&u()},this.u.push(h)},e.prototype.end=function(){var e=this;if(2&this.d){if(1&this.d)throw"stream finishing";throw"stream finished"}this.d?this.e():this.u.push({r:function(){1&e.d&&(e.u.splice(-1,1),e.e())},t:function(){}}),this.d=3},e.prototype.e=function(){for(var e=0,t=0,n=0,r=0,a=this.u;r<a.length;r++){n+=46+(c=a[r]).f.length+st(c.extra)+(c.o?c.o.length:0)}for(var i=new o(n+22),s=0,l=this.u;s<l.length;s++){var c=l[s];lt(i,e,c,c.f,c.u,c.c,t,c.o),e+=46+c.f.length+st(c.extra)+(c.o?c.o.length:0),t+=c.b}ct(i,e,this.u.length,n,t),this.ondata(null,i,!0),this.d=2},e.prototype.terminate=function(){for(var e=0,t=this.u;e<t.length;e++){t[e].t()}this.d=2},e}();function ht(e,t,n){if(n||(n=t,t={}),"function"!=typeof n)throw"no callback";var r={};Ye(e,"",r,t);var a=Object.keys(r),i=a.length,s=0,l=0,c=i,f=new Array(i),u=[],d=function(){for(var e=0;e<u.length;++e)u[e]()},p=function(){var e=new o(l+22),t=s,r=l-s;l=0;for(var a=0;a<c;++a){var i=f[a];try{var u=i.c.length;lt(e,l,i,i.f,i.u,u);var d=30+i.f.length+st(i.extra),p=l+d;e.set(i.c,p),lt(e,s,i,i.f,i.u,u,l,i.m),s+=16+d+(i.m?i.m.length:0),l=p+u}catch(e){return n(e,null)}}ct(e,s,f.length,r,t),n(null,e)};i||p();for(var h=function(e){var t=a[e],o=r[t],c=o[0],h=o[1],v=j(),m=c.length;v.p(c);var x=tt(t),g=x.length,y=h.comment,E=y&&tt(y),w=E&&E.length,b=st(h.extra),_=0==h.level?0:8,T=function(r,o){if(r)d(),n(r,null);else{var a=o.length;f[e]=Y(h,{size:m,crc:v.d(),c:o,f:x,m:E,u:g!=t.length||E&&y.length!=w,compression:_}),s+=30+g+b+a,l+=76+2*(g+b)+(w||0)+a,--i||p()}};if(g>65535&&T("filename too long",null),_)if(m<16e4)try{T(null,_e(c,h))}catch(e){T(e,null)}else u.push(be(c,h,T));else T(null,c)},v=0;v<c;++v)h(v);return d}function vt(e,t){t||(t={});var n={},r=[];Ye(e,"",n,t);var a=0,i=0;for(var s in n){var l=n[s],c=l[0],f=l[1],u=0==f.level?0:8,d=(T=tt(s)).length,p=f.comment,h=p&&tt(p),v=h&&h.length,m=st(f.extra);if(d>65535)throw"filename too long";var x=u?_e(c,f):c,g=x.length,y=j();y.p(c),r.push(Y(f,{size:c.length,crc:y.d(),c:x,f:T,m:h,u:d!=s.length||h&&p.length!=v,o:a,compression:u})),a+=30+d+m+g,i+=76+2*(d+m)+(v||0)+g}for(var E=new o(i+22),w=a,b=i-a,_=0;_<r.length;++_){var T=r[_];lt(E,T.o,T,T.f,T.u,T.c.length);var A=30+T.f.length+st(T.extra);E.set(T.c,T.o+A),lt(E,a,T,T.f,T.u,T.c.length,T.o,T.m),a+=16+A+(T.m?T.m.length:0)}return ct(E,a,r.length,b,w),E}var mt=function(){function e(){}return e.prototype.push=function(e,t){this.ondata(null,e,t)},e.compression=0,e}(),xt=function(){function e(){var e=this;this.i=new Te((function(t,n){e.ondata(null,t,n)}))}return e.prototype.push=function(e,t){try{this.i.push(e,t)}catch(n){this.ondata(n,e,t)}},e.compression=8,e}(),gt=function(){function e(e,t){var n=this;t<32e4?this.i=new Te((function(e,t){n.ondata(null,e,t)})):(this.i=new Ae((function(e,t,r){n.ondata(e,t,r)})),this.terminate=this.i.terminate)}return e.prototype.push=function(e,t){this.i.terminate&&(e=P(e,0)),this.i.push(e,t)},e.compression=8,e}(),yt=function(){function e(e){this.onfile=e,this.k=[],this.o={0:mt},this.p=B}return e.prototype.push=function(e,t){var n=this;if(!this.onfile)throw"no callback";if(!this.p)throw"stream finished";if(this.c>0){var r=Math.min(this.c,e.length),a=e.subarray(0,r);if(this.c-=r,this.d?this.d.push(a,!this.c):this.k[0].push(a),(e=e.subarray(r)).length)return this.push(e,t)}else{var i=0,s=0,l=void 0,c=void 0;this.p.length?e.length?((c=new o(this.p.length+e.length)).set(this.p),c.set(e,this.p.length)):c=this.p:c=e;for(var f=c.length,u=this.c,d=u&&this.d,p=function(){var e,t=fe(c,s);if(67324752==t){i=1,l=s,h.d=null,h.c=0;var r=ce(c,s+6),o=ce(c,s+8),a=2048&r,d=8&r,p=ce(c,s+26),v=ce(c,s+28);if(f>s+30+p+v){var m=[];h.k.unshift(m),i=2;var x,g=fe(c,s+18),y=fe(c,s+22),E=nt(c.subarray(s+30,s+=30+p),!a);4294967295==g?(e=d?[-2]:it(c,s),g=e[0],y=e[1]):d&&(g=-1),s+=v,h.c=g;var w={name:E,compression:o,start:function(){if(!w.ondata)throw"no callback";if(g){var e=n.o[o];if(!e)throw"unknown compression type "+o;(x=g<0?new e(E):new e(E,g,y)).ondata=function(e,t,n){w.ondata(e,t,n)};for(var t=0,r=m;t<r.length;t++){var a=r[t];x.push(a,!1)}n.k[0]==m&&n.c?n.d=x:x.push(B,!0)}else w.ondata(null,B,!0)},terminate:function(){x&&x.terminate&&x.terminate()}};g>=0&&(w.size=g,w.originalSize=y),h.onfile(w)}return"break"}if(u){if(134695760==t)return l=s+=12+(-2==u&&8),i=3,h.c=0,"break";if(33639248==t)return l=s-=4,i=3,h.c=0,"break"}},h=this;s<f-4;++s){if("break"===p())break}if(this.p=B,u<0){var v=i?c.subarray(0,l-12-(-2==u&&8)-(134695760==fe(c,l-16)&&4)):c.subarray(0,s);d?d.push(v,!!i):this.k[+(2==i)].push(v)}if(2&i)return this.push(c.subarray(s),t);this.p=c.subarray(s)}if(t){if(this.c)throw"invalid zip file";this.p=null}},e.prototype.register=function(e){this.o[e.compression]=e},e}();function Et(e,t){if("function"!=typeof t)throw"no callback";for(var n=[],r=function(){for(var e=0;e<n.length;++e)n[e]()},a={},i=e.length-22;101010256!=fe(e,i);--i)if(!i||e.length-i>65558)return void t("invalid zip file",null);var s=ce(e,i+8);s||t(null,{});var l=s,c=fe(e,i+16),f=4294967295==c;if(f){if(i=fe(e,i-12),101075792!=fe(e,i))return void t("invalid zip file",null);l=s=fe(e,i+32),c=fe(e,i+48)}for(var u=function(i){var l=at(e,c,f),u=l[0],d=l[1],p=l[2],h=l[3],v=l[4],m=l[5],x=ot(e,m);c=v;var g=function(e,n){e?(r(),t(e,null)):(a[h]=n,--s||t(null,a))};if(u)if(8==u){var y=e.subarray(x,x+d);if(d<32e4)try{g(null,Re(y,new o(p)))}catch(e){g(e,null)}else n.push(Se(y,{size:p},g))}else g("unknown compression type "+u,null);else g(null,P(e,x,x+d))},d=0;d<l;++d)u();return r}function wt(e){for(var t={},n=e.length-22;101010256!=fe(e,n);--n)if(!n||e.length-n>65558)throw"invalid zip file";var r=ce(e,n+8);if(!r)return{};var a=fe(e,n+16),i=4294967295==a;if(i){if(n=fe(e,n-12),101075792!=fe(e,n))throw"invalid zip file";r=fe(e,n+32),a=fe(e,n+48)}for(var s=0;s<r;++s){var l=at(e,a,i),c=l[0],f=l[1],u=l[2],d=l[3],p=l[4],h=l[5],v=ot(e,h);if(a=p,c){if(8!=c)throw"unknown compression type "+c;t[d]=Re(e.subarray(v,v+f),new o(u))}else t[d]=P(e,v,v+f)}return t}},2176:e=>{"use strict";var t=Math.abs,n=Math.min;function r(e,o,a,i){var s=t(e-o);return null==a&&(a=r.DBL_EPSILON),null==i&&(i=a),s<=a||(s<=i*n(t(e),t(o))||e===o)}r.FLT_EPSILON=1.1920929e-7,r.DBL_EPSILON=2220446049250313e-31,e.exports=r},4750:(e,t,n)=>{"use strict";e.exports=function(e,t){return r(t).filter((function(n){for(var r=new Array(n.length),a=0;a<n.length;++a)r[a]=t[n[a]];return o(r)*e<1}))};var r=n(4124),o=n(7623)},1591:(e,t,n)=>{e.exports=function(e,t){return o(r(e,t))};var r=n(4750),o=n(8979)},19:(e,t)=>{"use strict";function n(e){var t=32;return(e&=-e)&&t--,65535&e&&(t-=16),16711935&e&&(t-=8),252645135&e&&(t-=4),858993459&e&&(t-=2),1431655765&e&&(t-=1),t}t.INT_BITS=32,t.INT_MAX=2147483647,t.INT_MIN=-1<<31,t.sign=function(e){return(e>0)-(e<0)},t.abs=function(e){var t=e>>31;return(e^t)-t},t.min=function(e,t){return t^(e^t)&-(e<t)},t.max=function(e,t){return e^(e^t)&-(e<t)},t.isPow2=function(e){return!(e&e-1||!e)},t.log2=function(e){var t,n;return t=(e>65535)<<4,t|=n=((e>>>=t)>255)<<3,t|=n=((e>>>=n)>15)<<2,(t|=n=((e>>>=n)>3)<<1)|(e>>>=n)>>1},t.log10=function(e){return e>=1e9?9:e>=1e8?8:e>=1e7?7:e>=1e6?6:e>=1e5?5:e>=1e4?4:e>=1e3?3:e>=100?2:e>=10?1:0},t.popCount=function(e){return 16843009*((e=(858993459&(e-=e>>>1&1431655765))+(e>>>2&858993459))+(e>>>4)&252645135)>>>24},t.countTrailingZeros=n,t.nextPow2=function(e){return e+=0===e,--e,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,(e|=e>>>16)+1},t.prevPow2=function(e){return e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,(e|=e>>>16)-(e>>>1)},t.parity=function(e){return e^=e>>>16,e^=e>>>8,e^=e>>>4,27030>>>(e&=15)&1};var r=new Array(256);!function(e){for(var t=0;t<256;++t){var n=t,r=t,o=7;for(n>>>=1;n;n>>>=1)r<<=1,r|=1&n,--o;e[t]=r<<o&255}}(r),t.reverse=function(e){return r[255&e]<<24|r[e>>>8&255]<<16|r[e>>>16&255]<<8|r[e>>>24&255]},t.interleave2=function(e,t){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e&=65535)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t&=65535)|t<<8))|t<<4))|t<<2))|t<<1))<<1},t.deinterleave2=function(e,t){return(e=65535&((e=16711935&((e=252645135&((e=858993459&((e=e>>>t&1431655765)|e>>>1))|e>>>2))|e>>>4))|e>>>16))<<16>>16},t.interleave3=function(e,t,n){return e=1227133513&((e=3272356035&((e=251719695&((e=4278190335&((e&=1023)|e<<16))|e<<8))|e<<4))|e<<2),(e|=(t=1227133513&((t=3272356035&((t=251719695&((t=4278190335&((t&=1023)|t<<16))|t<<8))|t<<4))|t<<2))<<1)|(n=1227133513&((n=3272356035&((n=251719695&((n=4278190335&((n&=1023)|n<<16))|n<<8))|n<<4))|n<<2))<<2},t.deinterleave3=function(e,t){return(e=1023&((e=4278190335&((e=251719695&((e=3272356035&((e=e>>>t&1227133513)|e>>>2))|e>>>4))|e>>>8))|e>>>16))<<22>>22},t.nextCombination=function(e){var t=e|e-1;return t+1|(~t&-~t)-1>>>n(e)+1}},4966:e=>{"use strict";e.exports=function(e){var t,n,r,o=e.length,a=0;for(t=0;t<o;++t)a+=e[t].length;var i=new Array(a),s=0;for(t=0;t<o;++t){var l=e[t],c=l.length;for(n=0;n<c;++n){var f=i[s++]=new Array(c-1),u=0;for(r=0;r<c;++r)r!==n&&(f[u++]=l[r]);if(1&n){var d=f[1];f[1]=f[0],f[0]=d}}}return i}},5297:e=>{"use strict";e.exports=function(e){for(var t=1,n=1;n<e.length;++n)for(var r=0;r<n;++r)if(e[n]<e[r])t=-t;else if(e[r]===e[n])return 0;return t}},2174:(e,t,n)=>{"use strict";var r=n(6951),o=n(4857);function a(e,t){for(var n=0,r=e.length,o=0;o<r;++o)n+=e[o]*t[o];return n}function i(e){var t=e.length;if(0===t)return[];e[0].length;var n=r([e.length+1,e.length+1],1),i=r([e.length+1],1);n[t][t]=0;for(var s=0;s<t;++s){for(var l=0;l<=s;++l)n[l][s]=n[s][l]=2*a(e[s],e[l]);i[s]=a(e[s],e[s])}var c=o(n,i),f=0,u=c[t+1];for(s=0;s<u.length;++s)f+=u[s];var d=new Array(t);for(s=0;s<t;++s){u=c[s];var p=0;for(l=0;l<u.length;++l)p+=u[l];d[s]=p/f}return d}function s(e){if(0===e.length)return[];for(var t=e[0].length,n=r([t]),o=i(e),a=0;a<e.length;++a)for(var s=0;s<t;++s)n[s]+=e[a][s]*o[a];return n}s.barycenetric=i,e.exports=s},7623:(e,t,n)=>{e.exports=function(e){for(var t=r(e),n=0,o=0;o<e.length;++o)for(var a=e[o],i=0;i<t.length;++i)n+=Math.pow(a[i]-t[i],2);return Math.sqrt(n/e.length)};var r=n(2174)},8743:e=>{e.exports=function(e,r){var o=e.length,a=e.length-r.length;if(a)return a;switch(o){case 0:return 0;case 1:return e[0]-r[0];case 2:return e[0]+e[1]-r[0]-r[1]||t(e[0],e[1])-t(r[0],r[1]);case 3:var i=e[0]+e[1],s=r[0]+r[1];if(a=i+e[2]-(s+r[2]))return a;var l=t(e[0],e[1]),c=t(r[0],r[1]);return t(l,e[2])-t(c,r[2])||t(l+e[2],i)-t(c+r[2],s);case 4:var f=e[0],u=e[1],d=e[2],p=e[3],h=r[0],v=r[1],m=r[2],x=r[3];return f+u+d+p-(h+v+m+x)||t(f,u,d,p)-t(h,v,m,x,h)||t(f+u,f+d,f+p,u+d,u+p,d+p)-t(h+v,h+m,h+x,v+m,v+x,m+x)||t(f+u+d,f+u+p,f+d+p,u+d+p)-t(h+v+m,h+v+x,h+m+x,v+m+x);default:for(var g=e.slice().sort(n),y=r.slice().sort(n),E=0;E<o;++E)if(a=g[E]-y[E])return a;return 0}};var t=Math.min;function n(e,t){return e-t}},67:(e,t,n)=>{"use strict";var r=n(8743),o=n(5297);e.exports=function(e,t){return r(e,t)||o(e)-o(t)}},1690:(e,t,n)=>{"use strict";var r=n(639);e.exports=function(e){var t=e.length;if(0===t)return[];if(1===t)return[[0]];var n=e[0].length;return 0===n?[]:1===n?function(e){for(var t=0,n=0,r=1;r<e.length;++r)e[r][0]<e[t][0]&&(t=r),e[r][0]>e[n][0]&&(n=r);return t<n?[[t],[n]]:t>n?[[n],[t]]:[[t]]}(e):2===n?function(e){var t=r(e),n=t.length;if(n<=2)return[];for(var o=new Array(n),a=t[n-1],i=0;i<n;++i){var s=t[i];o[i]=[a,s],a=s}return o}(e):[]}},202:(e,t,n)=>{"use strict";var r=n(2176),o=n(6951);e.exports={fromList:c,fromDictionary:function(e,t,n){return c(Object.keys(e).map((function(t){var n=t.split(",");return[0|n[0],0|n[1],e[t]]})),t,n)},fromDense:function(e){var t=[],n=e.length;if(0===n)return c([],0,0);for(var r=e[0].length,o=0;o<n;++o)for(var i=e[o],s=0;s<r;++s){var l=i[s];Math.abs(l)>a&&t.push([o,s,l])}return c(t,n,r)},fromNDArray:function(e){var t=[],n=e.shape[0],r=e.shape[1];if(e.stride[1]>e.stride[0])for(var o=0;o<r;++o)for(var a=0;a<n;++a)t.push([a,o,e.get(a,o)]);else for(a=0;a<n;++a)for(o=0;o<r;++o)t.push([a,o,e.get(a,o)]);return c(t,n,r)}};var a=r.DBL_EPSILON;function i(e,t,n,r,o){this.rows=e,this.row_ptrs=t,this.columns=n,this.column_ptrs=r,this.data=o}var s=i.prototype;function l(e,t){return e[0]-t[0]||e[1]-t[1]}function c(e,t,n){e=function(e,t,n){var r=0,o=0;for(e.sort(l);r<e.length;){var i=e[r++];if(!(i[0]>=t||i[1]>=n)){for(;r<e.length&&0===l(e[r],i);)i[2]+=e[r++][2];Math.abs(i[2])>a&&(e[o++]=i)}}return e.length=o,e}(e,t||1/0,n||1/0);var r=[],o=[],s=[],c=[],f=new Float64Array(e.length);t=t||0,n=n||0;for(var u=0;u<e.length;++u){var d=e[u];0===u||d[0]!==e[u-1][0]?(r.push(d[0]),o.push(s.length),s.push(d[1]),c.push(u)):d[1]!==e[u-1][1]+1&&(s.push(d[1]),c.push(u)),t=Math.max(t,d[0]+1),n=Math.max(n,d[1]+1),f[u]=d[2]}return r.push(t),o.push(s.length),s.push(n),c.push(f.length),new i(new Uint32Array(r),new Uint32Array(o),new Uint32Array(s),new Uint32Array(c),f)}Object.defineProperty(s,"rowCount",{get:function(){return this.rows[this.rows.length-1]}}),Object.defineProperty(s,"columnCount",{get:function(){return this.columns[this.columns.length-1]}}),s.apply=function(e,t){return function(e,t,n,r,o,a,i){for(var s=0,l=0,c=0,f=0,u=e.length-1;f<u;++f){for(var d=e[f],p=t[f+1],h=0;++c<d;)i[c]=0;for(;s<p;)for(var v=n[s],m=r[++s];l<m;)h+=o[l++]*a[v++];i[d]=h}for(var x=i.length;++c<x;)i[c]=0}(this.rows,this.row_ptrs,this.columns,this.column_ptrs,this.data,e,t),t},s.transpose=function(){for(var e=this.toList(),t=0;t<e.length;++t){var n=e[t],r=n[0];n[0]=n[1],n[1]=r}return c(e,this.columnCount,this.rowCount)},s.toList=function(){for(var e=[],t=0,n=this.rows.length-1;t<n;++t)for(var r=this.rows[t],o=this.row_ptrs[t],a=this.row_ptrs[t+1];o<a;++o)for(var i=this.columns[o],s=this.column_ptrs[o],l=this.column_ptrs[o+1];s<l;++s){var c=this.data[s];e.push([r,i++,c])}return e},s.toDictionary=function(){for(var e={},t=0,n=this.rows.length-1;t<n;++t)for(var r=this.rows[t],o=this.row_ptrs[t],a=this.row_ptrs[t+1];o<a;++o)for(var i=this.columns[o],s=this.column_ptrs[o],l=this.column_ptrs[o+1];s<l;++s){var c=this.data[s];e[[r,i++]]=c}return e},s.toDense=function(){for(var e=o([this.rowCount,this.columnCount],0),t=0,n=this.rows.length-1;t<n;++t)for(var r=this.rows[t],a=this.row_ptrs[t],i=this.row_ptrs[t+1];a<i;++a)for(var s=this.columns[a],l=this.column_ptrs[a],c=this.column_ptrs[a+1];l<c;++l){var f=this.data[l];e[r][s++]=f}return e},i.prototype.toNDArray=function(e){for(var t=0,n=this.rows.length-1;t<n;++t)for(var r=this.rows[t],o=this.row_ptrs[t],a=this.row_ptrs[t+1];o<a;++o)for(var i=this.columns[o],s=this.column_ptrs[o],l=this.column_ptrs[o+1];s<l;++s){var c=this.data[s];e.set(r,i++,c)}return e}},9245:(e,t,n)=>{"use strict";var r=n(8506);function o(e,t,n){var r,o,a=e.length,i=t.arrayArgs.length,s=t.indexArgs.length>0,l=[],c=[],f=0,u=0;for(r=0;r<a;++r)c.push(["i",r,"=0"].join(""));for(o=0;o<i;++o)for(r=0;r<a;++r)u=f,f=e[r],0===r?c.push(["d",o,"s",r,"=t",o,"p",f].join("")):c.push(["d",o,"s",r,"=(t",o,"p",f,"-s",u,"*t",o,"p",u,")"].join(""));for(c.length>0&&l.push("var "+c.join(",")),r=a-1;r>=0;--r)f=e[r],l.push(["for(i",r,"=0;i",r,"<s",f,";++i",r,"){"].join(""));for(l.push(n),r=0;r<a;++r){for(u=f,f=e[r],o=0;o<i;++o)l.push(["p",o,"+=d",o,"s",r].join(""));s&&(r>0&&l.push(["index[",u,"]-=s",u].join("")),l.push(["++index[",f,"]"].join(""))),l.push("}")}return l.join("\n")}function a(e,t,n){for(var r=e.body,o=[],a=[],i=0;i<e.args.length;++i){var s=e.args[i];if(!(s.count<=0)){var l=new RegExp(s.name,"g"),c="",f=t.arrayArgs.indexOf(i);switch(t.argTypes[i]){case"offset":var u=t.offsetArgIndex.indexOf(i);f=t.offsetArgs[u].array,c="+q"+u;case"array":c="p"+f+c;var d="l"+i,p="a"+f;if(0===t.arrayBlockIndices[f])1===s.count?"generic"===n[f]?s.lvalue?(o.push(["var ",d,"=",p,".get(",c,")"].join("")),r=r.replace(l,d),a.push([p,".set(",c,",",d,")"].join(""))):r=r.replace(l,[p,".get(",c,")"].join("")):r=r.replace(l,[p,"[",c,"]"].join("")):"generic"===n[f]?(o.push(["var ",d,"=",p,".get(",c,")"].join("")),r=r.replace(l,d),s.lvalue&&a.push([p,".set(",c,",",d,")"].join(""))):(o.push(["var ",d,"=",p,"[",c,"]"].join("")),r=r.replace(l,d),s.lvalue&&a.push([p,"[",c,"]=",d].join("")));else{for(var h=[s.name],v=[c],m=0;m<Math.abs(t.arrayBlockIndices[f]);m++)h.push("\\s*\\[([^\\]]+)\\]"),v.push("$"+(m+1)+"*t"+f+"b"+m);if(l=new RegExp(h.join(""),"g"),c=v.join("+"),"generic"===n[f])throw new Error("cwise: Generic arrays not supported in combination with blocks!");r=r.replace(l,[p,"[",c,"]"].join(""))}break;case"scalar":r=r.replace(l,"Y"+t.scalarArgs.indexOf(i));break;case"index":r=r.replace(l,"index");break;case"shape":r=r.replace(l,"shape")}}}return[o.join("\n"),r,a.join("\n")].join("\n").trim()}function i(e){for(var t=new Array(e.length),n=!0,r=0;r<e.length;++r){var o=e[r],a=o.match(/\d+/);a=a?a[0]:"",0===o.charAt(0)?t[r]="u"+o.charAt(1)+a:t[r]=o.charAt(0)+a,r>0&&(n=n&&t[r]===t[r-1])}return n?t[0]:t.join("")}var s=function(e,t){for(var n=t[1].length-Math.abs(e.arrayBlockIndices[0])|0,s=new Array(e.arrayArgs.length),l=new Array(e.arrayArgs.length),c=0;c<e.arrayArgs.length;++c)l[c]=t[2*c],s[c]=t[2*c+1];var f=[],u=[],d=[],p=[],h=[];for(c=0;c<e.arrayArgs.length;++c){e.arrayBlockIndices[c]<0?(d.push(0),p.push(n),f.push(n),u.push(n+e.arrayBlockIndices[c])):(d.push(e.arrayBlockIndices[c]),p.push(e.arrayBlockIndices[c]+n),f.push(0),u.push(e.arrayBlockIndices[c]));for(var v=[],m=0;m<s[c].length;m++)d[c]<=s[c][m]&&s[c][m]<p[c]&&v.push(s[c][m]-d[c]);h.push(v)}var x=["SS"],g=["'use strict'"],y=[];for(m=0;m<n;++m)y.push(["s",m,"=SS[",m,"]"].join(""));for(c=0;c<e.arrayArgs.length;++c){x.push("a"+c),x.push("t"+c),x.push("p"+c);for(m=0;m<n;++m)y.push(["t",c,"p",m,"=t",c,"[",d[c]+m,"]"].join(""));for(m=0;m<Math.abs(e.arrayBlockIndices[c]);++m)y.push(["t",c,"b",m,"=t",c,"[",f[c]+m,"]"].join(""))}for(c=0;c<e.scalarArgs.length;++c)x.push("Y"+c);if(e.shapeArgs.length>0&&y.push("shape=SS.slice(0)"),e.indexArgs.length>0){var E=new Array(n);for(c=0;c<n;++c)E[c]="0";y.push(["index=[",E.join(","),"]"].join(""))}for(c=0;c<e.offsetArgs.length;++c){var w=e.offsetArgs[c],b=[];for(m=0;m<w.offset.length;++m)0!==w.offset[m]&&(1===w.offset[m]?b.push(["t",w.array,"p",m].join("")):b.push([w.offset[m],"*t",w.array,"p",m].join("")));0===b.length?y.push("q"+c+"=0"):y.push(["q",c,"=",b.join("+")].join(""))}var _=r([].concat(e.pre.thisVars).concat(e.body.thisVars).concat(e.post.thisVars));for((y=y.concat(_)).length>0&&g.push("var "+y.join(",")),c=0;c<e.arrayArgs.length;++c)g.push("p"+c+"|=0");e.pre.body.length>3&&g.push(a(e.pre,e,l));var T=a(e.body,e,l),A=function(e){for(var t=0,n=e[0].length;t<n;){for(var r=1;r<e.length;++r)if(e[r][t]!==e[0][t])return t;++t}return t}(h);A<n?g.push(function(e,t,n,r){for(var a=t.length,i=n.arrayArgs.length,s=n.blockSize,l=n.indexArgs.length>0,c=[],f=0;f<i;++f)c.push(["var offset",f,"=p",f].join(""));for(f=e;f<a;++f)c.push(["for(var j"+f+"=SS[",t[f],"]|0;j",f,">0;){"].join("")),c.push(["if(j",f,"<",s,"){"].join("")),c.push(["s",t[f],"=j",f].join("")),c.push(["j",f,"=0"].join("")),c.push(["}else{s",t[f],"=",s].join("")),c.push(["j",f,"-=",s,"}"].join("")),l&&c.push(["index[",t[f],"]=j",f].join(""));for(f=0;f<i;++f){for(var u=["offset"+f],d=e;d<a;++d)u.push(["j",d,"*t",f,"p",t[d]].join(""));c.push(["p",f,"=(",u.join("+"),")"].join(""))}for(c.push(o(t,n,r)),f=e;f<a;++f)c.push("}");return c.join("\n")}(A,h[0],e,T)):g.push(o(h[0],e,T)),e.post.body.length>3&&g.push(a(e.post,e,l)),e.debug&&console.log("-----Generated cwise routine for ",t,":\n"+g.join("\n")+"\n----------");var S=[e.funcName||"unnamed","_cwise_loop_",s[0].join("s"),"m",A,i(l)].join("");return new Function(["function ",S,"(",x.join(","),"){",g.join("\n"),"} return ",S].join(""))()};function l(){this.argTypes=[],this.shimArgs=[],this.arrayArgs=[],this.arrayBlockIndices=[],this.scalarArgs=[],this.offsetArgs=[],this.offsetArgIndex=[],this.indexArgs=[],this.shapeArgs=[],this.funcName="",this.pre=null,this.body=null,this.post=null,this.debug=!1}e.exports=function(e){var t=new l;t.pre=e.pre,t.body=e.body,t.post=e.post;var n=e.args.slice(0);t.argTypes=n;for(var r=0;r<n.length;++r){var o=n[r];if("array"===o||"object"==typeof o&&o.blockIndices){if(t.argTypes[r]="array",t.arrayArgs.push(r),t.arrayBlockIndices.push(o.blockIndices?o.blockIndices:0),t.shimArgs.push("array"+r),r<t.pre.args.length&&t.pre.args[r].count>0)throw new Error("cwise: pre() block may not reference array args");if(r<t.post.args.length&&t.post.args[r].count>0)throw new Error("cwise: post() block may not reference array args")}else if("scalar"===o)t.scalarArgs.push(r),t.shimArgs.push("scalar"+r);else if("index"===o){if(t.indexArgs.push(r),r<t.pre.args.length&&t.pre.args[r].count>0)throw new Error("cwise: pre() block may not reference array index");if(r<t.body.args.length&&t.body.args[r].lvalue)throw new Error("cwise: body() block may not write to array index");if(r<t.post.args.length&&t.post.args[r].count>0)throw new Error("cwise: post() block may not reference array index")}else if("shape"===o){if(t.shapeArgs.push(r),r<t.pre.args.length&&t.pre.args[r].lvalue)throw new Error("cwise: pre() block may not write to array shape");if(r<t.body.args.length&&t.body.args[r].lvalue)throw new Error("cwise: body() block may not write to array shape");if(r<t.post.args.length&&t.post.args[r].lvalue)throw new Error("cwise: post() block may not write to array shape")}else{if("object"!=typeof o||!o.offset)throw new Error("cwise: Unknown argument type "+n[r]);t.argTypes[r]="offset",t.offsetArgs.push({array:o.array,offset:o.offset}),t.offsetArgIndex.push(r)}}if(t.arrayArgs.length<=0)throw new Error("cwise: No array arguments specified");if(t.pre.args.length>n.length)throw new Error("cwise: Too many arguments in pre() block");if(t.body.args.length>n.length)throw new Error("cwise: Too many arguments in body() block");if(t.post.args.length>n.length)throw new Error("cwise: Too many arguments in post() block");return t.debug=!!e.printCode||!!e.debug,t.funcName=e.funcName||"cwise",t.blockSize=e.blockSize||64,function(e){var t=["'use strict'","var CACHED={}"],n=[],r=e.funcName+"_cwise_thunk";t.push(["return function ",r,"(",e.shimArgs.join(","),"){"].join(""));for(var o=[],a=[],i=[["array",e.arrayArgs[0],".shape.slice(",Math.max(0,e.arrayBlockIndices[0]),e.arrayBlockIndices[0]<0?","+e.arrayBlockIndices[0]+")":")"].join("")],l=[],c=[],f=0;f<e.arrayArgs.length;++f){var u=e.arrayArgs[f];n.push(["t",u,"=array",u,".dtype,","r",u,"=array",u,".order"].join("")),o.push("t"+u),o.push("r"+u),a.push("t"+u),a.push("r"+u+".join()"),i.push("array"+u+".data"),i.push("array"+u+".stride"),i.push("array"+u+".offset|0"),f>0&&(l.push("array"+e.arrayArgs[0]+".shape.length===array"+u+".shape.length+"+(Math.abs(e.arrayBlockIndices[0])-Math.abs(e.arrayBlockIndices[f]))),c.push("array"+e.arrayArgs[0]+".shape[shapeIndex+"+Math.max(0,e.arrayBlockIndices[0])+"]===array"+u+".shape[shapeIndex+"+Math.max(0,e.arrayBlockIndices[f])+"]"))}for(e.arrayArgs.length>1&&(t.push("if (!("+l.join(" && ")+")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"),t.push("for(var shapeIndex=array"+e.arrayArgs[0]+".shape.length-"+Math.abs(e.arrayBlockIndices[0])+"; shapeIndex--\x3e0;) {"),t.push("if (!("+c.join(" && ")+")) throw new Error('cwise: Arrays do not all have the same shape!')"),t.push("}")),f=0;f<e.scalarArgs.length;++f)i.push("scalar"+e.scalarArgs[f]);return n.push(["type=[",a.join(","),"].join()"].join("")),n.push("proc=CACHED[type]"),t.push("var "+n.join(",")),t.push(["if(!proc){","CACHED[type]=proc=compile([",o.join(","),"])}","return proc(",i.join(","),")}"].join("")),e.debug&&console.log("-----Generated thunk:\n"+t.join("\n")+"\n----------"),new Function("compile",t.join("\n"))(s.bind(void 0,e))}(t)}},7065:(e,t,n)=>{var r,o,a,i,s,l=n(3794).angleNormals,c=null,f=null,u=null,d=null,p=!1,h=!1;function v(){if(!p)throw new Error("Must call initModule() before calling this function!")}function m(e){a=e;for(var t=new Int32Array(3*a.cells.length),n=0,i=0;i<a.cells.length;++i){var s=a.cells[i];t[n++]=s[0],t[n++]=s[1],t[n++]=s[2]}var l=t.length*t.BYTES_PER_ELEMENT;d=Module._malloc(l),(r=new Uint8Array(Module.HEAPU8.buffer,d,l)).set(new Uint8Array(t.buffer));var c=new Float64Array(3*a.positions.length);for(n=0,i=0;i<a.positions.length;++i){s=a.positions[i];c[n++]=s[0],c[n++]=s[1],c[n++]=s[2]}l=c.length*c.BYTES_PER_ELEMENT;u=Module._malloc(l),(o=new Uint8Array(Module.HEAPU8.buffer,u,l)).set(new Uint8Array(c.buffer)),p=!0}function x(e,t){v(),i=[];var n=0;for(const t of e)i[n++]=t;s=n;for(const e of t)i[n++]=e;var l=new Int32Array(i),f=l.length*l.BYTES_PER_ELEMENT;null!==c&&(Module._free(c),c=null),c=Module._malloc(f);var u=new Uint8Array(Module.HEAPU8.buffer,c,f);u.set(new Uint8Array(l.buffer)),prepareDeformWrap(r.byteOffset,3*a.cells.length,o.byteOffset,3*a.positions.length,u.byteOffset,i.length,s,!0),h=!0}function g(e){!function(){if(!h)throw new Error("Must call prepareDeform() before calling this function!")}();for(var t=s,n=new Float64Array(3*t),r=0,i=0;i<e.length;++i)n[r++]=e[i][0],n[r++]=e[i][1],n[r++]=e[i][2];var l=n.length*n.BYTES_PER_ELEMENT;null!==f&&(Module._free(f),f=null),f=Module._malloc(l);var c=new Uint8Array(Module.HEAPU8.buffer,f,l);c.set(new Uint8Array(n.buffer)),doDeformWrap(c.byteOffset,t,o.byteOffset);var u=new Float64Array(o.buffer,o.byteOffset,3*a.positions.length),d=[];for(i=0;i<a.positions.length;++i)d[i]=[u[3*i+0],u[3*i+1],u[3*i+2]];return d}function y(){v(),Module._free(u),Module._free(d),null!==c&&(Module._free(c),c=null),null!==f&&(Module._free(f),f=null),freeDeformWrap(),p=!1}e.exports={msh:null,adj:[],roi:{},_getOneRing:function(e){for(var t=[],n=0,r=e.positions.length;n<r;n++)t[n]=[];for(n=0,r=e.cells.length;n<r;n++)for(var o=e.cells[n],a=0;a<3;a++){var i=o[a+0],s=o[(a+1)%3];t[i].push(s)}return t},setMesh:function(e,t){if(this.msh===e&&p)t&&t();else{var n=this;n.dispose(),function(e){Module={},new Promise((t=>{fetch("./trimesh/laplacian_deformation.wasm").then((e=>e.arrayBuffer())).then((n=>{Module.wasmBinary=n;const r=document.createElement("script");r.src="./trimesh/laplacian_deformation.js",Module.onRuntimeInitialized=function(){prepareDeformWrap=Module.cwrap("prepareDeform",null,["number","number","number","number","number","number","number","number"]),doDeformWrap=Module.cwrap("doDeform",null,["number","number","number"]),freeDeformWrap=Module.cwrap("freeDeform",null,[]),e(m,x,g,y)},r.onload=()=>{t(Module)},document.body.appendChild(r)}))})).then((e=>{}))}((function(r,o,a,i){n._initModule=r,n._prepareDeform=o,n._doDeform=a,n._freeModule=i,n.msh=e,void 0===e.normals&&(e.normals=l(e.cells,e.positions)),n.adj=n._getOneRing(e),n._initModule(e),t&&t()}))}},setROI:function(e,t,n,r){var o=this.adj,a=this.roi;a.handles=[],a.unconstrained=[];for(var i=[e],s=[],l=0,c=this.msh.positions.length;l<c;l++)s[l]=!1;for(var f=0;f<t;f++){var u=[];for(l=0;l<i.length;l++){if(!s[h=i[l]]){a.handles.push(h),s[h]=!0;for(var d=o[h],p=0;p<d.length;p++)u.push(d[p])}}i=u}for(f=0;f<n;f++){for(u=[],l=0;l<i.length;l++){if(!s[h=i[l]]){a.unconstrained.push(h),s[h]=!0;for(d=o[h],p=0;p<d.length;p++)u.push(d[p])}}i=u}a.boundaryIndices=a.handles.length;for(l=0;l<i.length;l++){var h;s[h=i[l]]||(a.handles.push(h),s[h]=!0)}this._prepareDeform(a.handles,a.unconstrained),r&&r()},deform:function(e,t){var n=this.roi;if(n.handles&&0!==n.handles.length){for(var r=n.handles,o=n.boundaryIndices,a=[],i=this.msh.positions,s=0,l=r.length;s<l;s++)s>=o?a.push([i[r[s]][0],i[r[s]][1],i[r[s]][2]]):a.push([i[r[s]][0]+e[0],i[r[s]][1]+e[1],i[r[s]][2]+e[2]]);var c=this._doDeform(a);for(s=0,l=c.length;s<l;s++)i[s]=c[s];if(!t)return this.msh;t(this.msh)}},dispose:function(){this.msh=null,this.adj=[],this.roi={},p&&this._freeModule()},run:function(e,t,n,r,o,a){var i=this;i.setMesh(e,(function(){i.setROI(t,r,o,(function(){i.deform(n,(function(e){a&&a(e)}))}))}))}}},4124:(e,t,n)=>{"use strict";var r=n(3477),o=n(8506);function a(e,t){this.point=e,this.index=t}function i(e,t){for(var n=e.point,r=t.point,o=n.length,a=0;a<o;++a){var i=r[a]-n[a];if(i)return i}return 0}e.exports=function(e,t){var n=e.length;if(0===n)return[];var s=e[0].length;if(s<1)return[];if(1===s)return function(e,t,n){if(1===e)return n?[[-1,0]]:[];var r=t.map((function(e,t){return[e[0],t]}));r.sort((function(e,t){return e[0]-t[0]}));for(var o=new Array(e-1),a=1;a<e;++a){var i=r[a-1],s=r[a];o[a-1]=[i[1],s[1]]}n&&o.push([-1,o[0][1]],[o[e-1][1],-1]);return o}(n,e,t);for(var l=new Array(n),c=1,f=0;f<n;++f){for(var u=e[f],d=new Array(s+1),p=0,h=0;h<s;++h){var v=u[h];d[h]=v,p+=v*v}d[s]=p,l[f]=new a(d,f),c=Math.max(p,c)}o(l,i),n=l.length;var m=new Array(n+s+1),x=new Array(n+s+1),g=(s+1)*(s+1)*c,y=new Array(s+1);for(f=0;f<=s;++f)y[f]=0;y[s]=g,m[0]=y.slice(),x[0]=-1;for(f=0;f<=s;++f){(d=y.slice())[f]=1,m[f+1]=d,x[f+1]=-1}for(f=0;f<n;++f){var E=l[f];m[f+s+1]=E.point,x[f+s+1]=E.index}var w=r(m,!1);w=t?w.filter((function(e){for(var t=0,n=0;n<=s;++n){var r=x[e[n]];if(r<0&&++t>=2)return!1;e[n]=r}return!0})):w.filter((function(e){for(var t=0;t<=s;++t){var n=x[e[t]];if(n<0)return!1;e[t]=n}return!0}));if(1&s)for(f=0;f<w.length;++f){d=(E=w[f])[0];E[0]=E[1],E[1]=d}return w}},6951:e=>{"use strict";function t(e,n,r){var o=0|e[r];if(o<=0)return[];var a,i=new Array(o);if(r===e.length-1)for(a=0;a<o;++a)i[a]=n;else for(a=0;a<o;++a)i[a]=t(e,n,r+1);return i}e.exports=function(e,n){switch(void 0===n&&(n=0),typeof e){case"number":if(e>0)return function(e,t){var n,r;for(n=new Array(e),r=0;r<e;++r)n[r]=t;return n}(0|e,n);break;case"object":if("number"==typeof e.length)return t(e,n,0)}return[]}},579:(e,t)=>{function n(e){var t=1023&e;return t=1227133513&((t=3272356035&((t=251719695&((t=4278190335&(t|t<<16))|t<<8))|t<<4))|t<<2)}function r(e,t,r){return n(e)|n(t)<<1|n(r)<<2}function o(e,t){this.coeffs=e,this.children=t}function a(e,t,n,r){this.bounds=e,this.coeff=t,this.root=n,this.depth=r}function i(){return new o([0,0,0,0,0,0,0],[null,null,null,null,null,null,null,null])}var s={HaarNode:o,HaarTree:a,createEmptyNode:i,createEmptyTree:function(e,t){return new a(e,0,i(),t)}};function l(e,t,n,o,a){var i=30-a,s=this.x=t<<i,l=this.y=n<<i,c=this.z=o<<i;this.c0=r(s>>20,l>>20,c>>20),this.c1=r(s>>10,l>>10,c>>10),this.c2=r(s,l,c),this.w=e,this.l=a}var c=[];function f(e,t,n,r,o,a){if(e)for(var i=e.coeffs,s=i[0],u=i[1],d=i[2],p=i[3],h=i[4],v=i[5],m=i[6],x=e.children,g=n<<1,y=r<<1,E=o<<1,w=0,b=0;b<2;++b)for(var _=0;_<2;++_)for(var T=0;T<2;++T,++w){var A=1-2*T,S=1-2*_,R=1-2*b,M=A*s+S*u+A*S*d+R*p+A*R*h+S*R*v+A*S*R*m;f(x[w],t+M,g+T,y+_,E+b,a+1)}else c.push(new l(t,n,r,o,a))}function u(e){f(e.root,e.coeff,0,0,0,0);var t=c.slice();return c.length=0,t}var d=32;function p(e,t,n,r){this.c0=e,this.c1=t,this.c2=n,this.children=r}function h(e,t){this.root=e,this.cells=t}function v(e,t){return Math.floor((t-e)/33)}function m(e){return 0|Math.min(Math.max(e,0),(1<<30)-1)}var x={create:function(e){return new h(function t(n,r){if(r-n<=d)return null;for(var o=v(n,r),a=new Array(d),i=new Array(d),s=new Array(d),l=new Array(33),c=0;c<d;++c){var f=n+o*c,u=n+o*(c+1),h=e[u];a[c]=h.c0,i[c]=h.c1,s[c]=h.c2,l[c]=t(f,u)}return l[d]=t(n+o*d,r),new p(a,i,s,l)}(0,e.length),e)},search:function(e,t,n,o){for(var a=m(t),i=m(n),s=m(o),l=r(a>>20,i>>20,s>>20),c=r(a>>10,i>>10,s>>10),f=r(a,i,s),u=e.cells,p=0,h=u.length,x=e.root;x;){var g,y=v(p,h),E=x.c0,w=x.c1,b=x.c2,_=x.children;for(g=0;g<d;++g){if((E[g]-l||w[g]-c||b[g]-f)>0)break}g<d&&(h=p+(g+1)*y),p+=g*y,x=_[g]}for(var T=p+1;T<h;++T){var A=u[T],S=1<<30-A.l;if(A.x<=a&&a<A.x+S&&A.y<=i&&i<A.y+S&&A.z<=s&&s<A.z+S)return T}return p}};function g(e,t){var n,r=t||{};if(!e||!e.length)throw new Error("haar-rasterize: must specify positions");var o=(n="bounds"in r?function(e){var t=.5*Math.max(e[1][0]-e[0][0],e[1][1]-e[0][1],e[1][2]-e[0][2]),n=.5*(e[0][0]+e[1][0]),r=.5*(e[0][1]+e[1][1]),o=.5*(e[0][2]+e[1][2]);return[[n-t,r-t,o-t],[n+t,r+t,o+t]]}(r.bounds):function(e){var t,n=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];for(t=0;t<e.length;++t)for(var o=e[t],a=0;a<3;++a)n[a]=Math.min(o[a],n[a]),r[a]=Math.max(o[a],r[a]);var i=Math.max(r[0]-n[0],r[1]-n[1],r[2]-n[2]);for(t=0;t<3;++t){var s=.5*(n[t]+r[t]);n[t]=s-i,r[t]=s+i}return[n,r]}(e))[1][0]-n[0][0],a=0|r.depth;if(a||(a=r.resolution?Math.ceil(Math.log2(o/r.resolution)):8),!a)throw new Error("haar-rasterize: invalid depth");return s.createEmptyTree(n,a)}function y(e,t,n){this.tree=e,this.bounds=t,this.depth=n}var i=s.createEmptyNode,E=[];var w=[];function b(e,t,n){if(t<=e+6)return E.length;var r,o,a,i;w.length=0;for(var s=E.length,l=e,c=t-3;l<t;l+=3){var f=E[l+n],u=E[c+n];if(f<=.5!=u<=.5){for(((o=(.5-u)/(f-u))<0||o>1)&&(o=.5),a=1-o,r=0;r<3;++r)i=a*E[c+r]+o*E[l+r],E.push(i),w.push(i);E[E.length-3+n]=1,w[w.length-3+n]=0}if(f<.5){for(r=0;r<3;++r)E.push(E[l+r]);E[E.length-3+n]=2*f}else if(f>.5){for(r=0;r<3;++r)w.push(E[l+r]);w[w.length-3+n]=2*(f-.5)}else{for(r=0;r<3;++r)E.push(E[l+r]),w.push(E[l+r]);E[E.length-3+n]=1,w[w.length-3+n]=0}c=l}var d=E.length;if(s>=d+6&&(d=E.length=s),w.length>6)for(var p=0;p<w.length;++p)E.push(w[p]);return d}function _(e,t,n,r){if(n[0]=n[1]=n[2]=r[0]=r[1]=r[2]=0,!(e>=t)){for(var o=E[e],a=E[e+1],i=E[e+2],s=e+6;s<t;s+=3){var l=E[s-3],c=E[s-2],f=E[s-1],u=E[s],d=E[s+1],p=E[s+2],h=l-o,v=c-a,m=f-i,x=u-o,g=d-a,y=p-i,w=v*y-m*g,b=m*x-h*y,_=h*g-v*x,T=o+l+u,A=a+c+d,S=i+f+p;n[0]+=w,n[1]+=b,n[2]+=_,r[0]+=T*w,r[1]+=A*b,r[2]+=S*_}for(var R=0;R<3;++R)n[R]/=16,r[R]/=48}}var T=[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]],A=[[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]];function S(e,t,n,r){var o=E.length,a=b(t,n,0),s=E.length,l=E.length,c=b(o,a,1),f=E.length,u=E.length,d=b(a,s,1),p=E.length,h=E.length,v=b(l,c,2),m=E.length,x=E.length,g=b(c,f,2),y=E.length,w=E.length,R=b(u,d,2),M=E.length,C=E.length,L=b(d,p,2),P=E.length;_(h,v,T[0],A[0]),_(w,R,T[1],A[1]),_(x,g,T[2],A[2]),_(C,L,T[3],A[3]),_(v,m,T[4],A[4]),_(R,M,T[5],A[5]),_(g,y,T[6],A[6]),_(L,P,T[7],A[7]);var k=T,N=A,H=e.coeffs;if(H[0]+=N[0][0]+k[1][0]-N[1][0]+N[2][0]+k[3][0]-N[3][0]+N[4][0]+k[5][0]-N[5][0]+N[6][0]+k[7][0]-N[7][0],H[1]+=N[0][1]+N[1][1]+k[2][1]-N[2][1]+k[3][1]-N[3][1]+N[4][1]+N[5][1]+k[6][1]-N[6][1]+k[7][1]-N[7][1],H[2]+=.5*(N[0][0]+N[0][1]+k[1][0]-N[1][0]-N[1][1]-N[2][0]+k[2][1]-N[2][1]+N[3][0]-k[3][0]+N[3][1]-k[3][1]+N[4][0]+N[4][1]+k[5][0]-N[5][0]-N[5][1]-N[6][0]+k[6][1]-N[6][1]+N[7][0]-k[7][0]+N[7][1]-k[7][1]),H[3]+=N[0][2]+N[1][2]+N[2][2]+N[3][2]+k[4][2]-N[4][2]+k[5][2]-N[5][2]+k[6][2]-N[6][2]+k[7][2]-N[7][2],H[4]+=.5*(N[0][0]+N[0][2]+k[1][0]-N[1][0]-N[1][2]+N[2][0]+N[2][2]+k[3][0]-N[3][0]-N[3][2]-N[4][0]+k[4][2]-N[4][2]+N[5][0]-k[5][0]+N[5][2]-k[5][2]-N[6][0]+k[6][2]-N[6][2]+N[7][0]-k[7][0]+N[7][2]-k[7][2]),H[5]+=.5*(N[0][1]+N[0][2]+N[1][1]+N[1][2]+k[2][1]-N[2][1]-N[2][2]+k[3][1]-N[3][1]-N[3][2]-N[4][1]+k[4][2]-N[4][2]-N[5][1]+k[5][2]-N[5][2]+N[6][1]-k[6][1]+N[6][2]-k[6][2]+N[7][1]-k[7][1]+N[7][2]-k[7][2]),H[6]+=1/3*(N[0][0]+N[0][1]+N[0][2]+k[1][0]-N[1][0]-N[1][1]-N[1][2]-N[2][0]+k[2][1]-N[2][1]-N[2][2]+N[3][0]-k[3][0]+N[3][1]-k[3][1]+N[3][2]+-N[4][0]-N[4][1]+k[4][2]-N[4][2]+N[5][0]-k[5][0]+N[5][1]+N[5][2]-k[5][2]+N[6][0]+N[6][1]-k[6][1]+N[6][2]-k[6][2]+k[7][0]-N[7][0]+k[7][1]-N[7][1]+k[7][2]-N[7][2]),r>1){var z=e.children;h<v&&S(z[0]||(z[0]=i()),h,v,r-1),w<R&&S(z[1]||(z[1]=i()),w,R,r-1),x<g&&S(z[2]||(z[2]=i()),x,g,r-1),C<L&&S(z[3]||(z[3]=i()),C,L,r-1),v<m&&S(z[4]||(z[4]=i()),v,m,r-1),R<M&&S(z[5]||(z[5]=i()),R,M,r-1),g<y&&S(z[6]||(z[6]=i()),g,y,r-1),L<P&&S(z[7]||(z[7]=i()),L,P,r-1)}E.length=o}t.rasterize=function(e,t,n){if(!e)throw new Error("haar-rasterize-cells: missing cells");var r=g(t,n);return function(e,t,n,r){var o,a,i,s,l,c,f,u,d,p,h,v,m=e.bounds,x=m[0],g=m[1][0]-x[0];for(o=0;o<t.length;++o){var y=t[o];if(3===y.length){for(E.length=0,a=0;a<3;++a){var w=n[y[a]];for(i=0;i<3;++i)E.push((w[i]-x[i])/g)}e.coeff+=(s=void 0,l=void 0,c=void 0,f=void 0,u=void 0,d=void 0,p=void 0,h=void 0,v=void 0,s=E[0],l=E[1],c=E[2],f=E[3],u=E[4],d=E[5],p=E[6],h=E[7],(s*(u*(v=E[8])-d*h)+l*(d*p-f*v)+c*(f*h-u*p))/6),S(e.root,0,9,r)}}}(r,e,t,r.depth),function(e){var t=u(e);return new y(x.create(t),e.bounds,e.depth)}(r)},t.sample=function(e,t,n,r){var o=e.bounds,a=o[0][0],i=o[0][1],s=o[0][2],l=o[1][0],c=o[1][1],f=o[1][2],u=0|Math.round((t-a)/(l-a)*(1<<30)),d=0|Math.round((n-i)/(c-i)*(1<<30)),p=0|Math.round((r-s)/(f-s)*(1<<30)),h=x.search(e.tree,u,d,p);return h?h.w:0};var R=x.search;function M(e,t){this.opp=e,this.idx=t}function C(e,t,n,r,o,a,i){for(var s=a.adj,l=0;l<s.length;++l)if(s[l].opp===i)return s[l].idx;var c=e.length;a.adj.push(new M(i,c)),i.adj.push(new M(a,c));var f=a.w,u=i.w,d=-u/(f-u),p=1-d;return e.push([(p*i.x+d*a.x)*t+n,(p*i.y+d*a.y)*t+r,(p*i.z+d*a.z)*t+o]),c}function L(e,t,n,r){this.x=e,this.y=t,this.z=n,this.w=0,this.l=r,this.adj=[],this.steiner=[]}function P(e,t,n,r){for(var o=0,a=e.length-1;o<a;){var i=o+a>>1,s=e[i],l=s.x-t||s.y-n||s.z-r;if(l>0)a=i-1;else{if(!(l<0))return s;o=i+1}}var c=e[o];return c.x===t&&c.y===n&&c.z===r?c:null}function k(e,t,n,r,o){for(var a=(t.x>>1)+(n.x>>1),i=(t.y>>1)+(n.y>>1),s=(t.z>>1)+(n.z>>1),l=t.steiner,c=0;c<l.length;++c){var f=l[c];if(f.x===a&&f.y===i&&f.z===s)return f}var u=new L(a,i,s,t.l);return u.w=D(e,a,i,s,o)-r,t.steiner.push(u),n.steiner.push(u),u}function N(e,t,n,r,o,a,i){for(var s=0|Math.floor(.25*(t.x+n.x+r.x+o.x)),l=0|Math.floor(.25*(t.y+n.y+r.y+o.y)),c=0|Math.floor(.25*(t.z+n.z+r.z+o.z)),f=t.steiner,u=0;u<f.length;++u){var d=f[u];if(d.x===s&&d.y===l&&d.z===c)return d}var p=new L(s,l,c,t.l);return p.w=.5*(a+i),t.steiner.push(p),n.steiner.push(p),r.steiner.push(p),o.steiner.push(p),p}function H(e,t,n,r,o,a,i,s,l,c){var f,u,d,p;switch(i.w<0|(s.w<0)<<1|(l.w<0)<<2|(c.w<0)<<3){case 0:break;case 1:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,l),d=C(e,n,r,o,a,i,c),t.push([f,u,d]);break;case 2:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,s,l),d=C(e,n,r,o,a,s,c),t.push([u,f,d]);break;case 3:f=C(e,n,r,o,a,i,l),u=C(e,n,r,o,a,i,c),d=C(e,n,r,o,a,s,l),p=C(e,n,r,o,a,s,c),t.push([d,f,u]),t.push([p,d,u]);break;case 4:f=C(e,n,r,o,a,i,l),u=C(e,n,r,o,a,s,l),d=C(e,n,r,o,a,l,c),t.push([f,u,d]);break;case 5:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,c),d=C(e,n,r,o,a,s,l),p=C(e,n,r,o,a,l,c),t.push([f,d,u]),t.push([d,p,u]);break;case 6:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,l),d=C(e,n,r,o,a,s,c),p=C(e,n,r,o,a,l,c),t.push([u,f,d]),t.push([p,u,d]);break;case 7:f=C(e,n,r,o,a,i,c),u=C(e,n,r,o,a,s,c),d=C(e,n,r,o,a,l,c),t.push([u,d,f]);break;case 8:f=C(e,n,r,o,a,i,c),u=C(e,n,r,o,a,s,c),d=C(e,n,r,o,a,l,c),t.push([u,f,d]);break;case 9:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,l),d=C(e,n,r,o,a,s,c),p=C(e,n,r,o,a,l,c),t.push([d,f,u]),t.push([p,d,u]);break;case 10:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,c),d=C(e,n,r,o,a,s,l),p=C(e,n,r,o,a,l,c),t.push([f,u,d]),t.push([u,p,d]);break;case 11:f=C(e,n,r,o,a,i,l),u=C(e,n,r,o,a,s,l),d=C(e,n,r,o,a,l,c),t.push([d,u,f]);break;case 12:f=C(e,n,r,o,a,i,l),u=C(e,n,r,o,a,i,c),d=C(e,n,r,o,a,s,l),p=C(e,n,r,o,a,s,c),t.push([u,f,d]),t.push([p,u,d]);break;case 13:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,s,l),d=C(e,n,r,o,a,s,c),t.push([u,d,f]);break;case 14:f=C(e,n,r,o,a,i,s),u=C(e,n,r,o,a,i,l),d=C(e,n,r,o,a,i,c),t.push([d,u,f])}}function z(e,t,n,r,o,a,i,s,l,c,f,u,d,p,h,v,m,x){for(var g=u;g!==d;){for(var y=1<<30-g.l,E=null;!E;)E=P(s,g.x+y*p,g.y+y*h,g.z+y*v),y<<=1;var w=k(e,E,g,m,x);H(t,n,r,o,a,i,f,l,E,w),H(t,n,r,o,a,i,f,l,w,g),H(t,n,r,o,a,i,f,c,g,w),H(t,n,r,o,a,i,f,c,w,E),g=E}}function D(e,t,n,r,o){return function(e,t,n,r){for(var o=0,a=0;a<2;++a)for(var i=0;i<2;++i)for(var s=0;s<2;++s)o+=e.cells[R(e,t-a,n-i,r-s)].w;return o/8}(e,t,n,r)}function F(e,t){return e.x-t.x||e.y-t.y||e.z-t.z}t.contour=function(e,t){var n,r="number"==typeof t?+t:-.5,o=e.tree,a=o.cells,i=(e.depth,0),s=new Array(8*a.length),l=new Array(a.length);for(n=0;n<a.length;++n){var c=a[n],f=c.x,u=c.y,d=c.z,p=c.l,h=1<<30-p;s[i++]=new L(f,u,d,p),s[i++]=new L(f+h,u,d,p),s[i++]=new L(f,u+h,d,p),s[i++]=new L(f+h,u+h,d,p),s[i++]=new L(f,u,d+h,p),s[i++]=new L(f+h,u,d+h,p),s[i++]=new L(f,u+h,d+h,p),s[i++]=new L(f+h,u+h,d+h,p);var v=new L(f+(h>>1),u+(h>>1),d+(h>>1),p);v.w=D(o,v.x,v.y,v.z)-r,l[n]=v}s.sort(F);var m=0;for(n=0;n<s.length;++n){for(var x=s[n].l;n+1<s.length&&0===F(s[n],s[n+1]);)x=Math.max(x,s[++n].l);var g=s[n];s[m++]=g,g.l=x,g.w=D(o,g.x,g.y,g.z)-r}return s.length=m,function(e,t,n,r){for(var o=e.tree,a=1<<30-e.depth,i=e.bounds,s=i[0],l=i[1],c=s[0],f=s[1],u=s[2],d=(l[0]-c)/(1<<30),p=[],h=[],v=o.cells,m=0;m<v.length;++m){var x,g,y,E=n[m],w=v[m],b=w.x,_=w.y,T=w.z,A=w.l,S=1<<30-A,M=null,C=null,L=null,k=null,H=null,D=null,F=null,I=null;v[x=R(o,b-1,_,T)].l<=A&&x!==m&&(M=M||P(t,b,_,T),L=L||P(t,b,_+S,T),H=H||P(t,b,_,T+S),F=F||P(t,b,_+S,T+S),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,M,L,H,F,g.w,E.w),M,L,0,1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,L,F,0,0,1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,F,H,0,-1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,H,M,0,0,-1,r,a)),v[x=R(o,b+S,_,T)].l<A&&(C=C||P(t,b+S,_,T),D=D||P(t,b+S,_,T+S),k=k||P(t,b+S,_+S,T),I=I||P(t,b+S,_+S,T+S),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,C,D,k,I,g.w,E.w),C,D,0,0,1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,D,I,0,1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,I,k,0,0,-1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,k,C,0,-1,0,r,a)),v[x=R(o,b,_-1,T)].l<=A&&x!==m&&(M=M||P(t,b,_,T),H=H||P(t,b,_,T+S),C=C||P(t,b+S,_,T),D=D||P(t,b+S,_,T+S),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,M,H,C,D,g.w,E.w),M,H,0,0,1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,H,D,1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,D,C,0,0,-1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,C,M,-1,0,0,r,a)),v[x=R(o,b,_+S,T)].l<A&&(L=L||P(t,b,_+S,T),k=k||P(t,b+S,_+S,T),F=F||P(t,b,_+S,T+S),I=I||P(t,b+S,_+S,T+S),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,L,k,F,I,g.w,E.w),L,k,1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,k,I,0,0,1,r,a),z(o,p,h,d,c,f,u,t,E,g,y,I,F,-1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,F,L,0,0,-1,r,a)),v[x=R(o,b,_,T-1)].l<=A&&x!==m&&(M=M||P(t,b,_,T),C=C||P(t,b+S,_,T),L=L||P(t,b,_+S,T),k=k||P(t,b+S,_+S,T),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,M,C,L,k,g.w,E.w),M,C,1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,C,k,0,1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,k,L,-1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,L,M,0,-1,0,r,a)),v[x=R(o,b,_,T+S)].l<A&&(H=H||P(t,b,_,T+S),F=F||P(t,b,_+S,T+S),D=D||P(t,b+S,_,T+S),I=I||P(t,b+S,_+S,T+S),z(o,p,h,d,c,f,u,t,E,g=n[x],y=N(0,H,F,D,I,g.w,E.w),H,F,0,1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,F,I,1,0,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,I,D,0,-1,0,r,a),z(o,p,h,d,c,f,u,t,E,g,y,D,H,-1,0,0,r,a))}return{positions:p,cells:h}}(e,s,l,r)}},3930:function(e,t){var n,r,o;(function(){var a,i,s,l,c,f,u,d,p,h,v,m,x,g,y;s=Math.floor,h=Math.min,i=function(e,t){return e<t?-1:e>t?1:0},p=function(e,t,n,r,o){var a;if(null==n&&(n=0),null==o&&(o=i),n<0)throw new Error("lo must be non-negative");for(null==r&&(r=e.length);n<r;)o(t,e[a=s((n+r)/2)])<0?r=a:n=a+1;return[].splice.apply(e,[n,n-n].concat(t)),t},f=function(e,t,n){return null==n&&(n=i),e.push(t),g(e,0,e.length-1,n)},c=function(e,t){var n,r;return null==t&&(t=i),n=e.pop(),e.length?(r=e[0],e[0]=n,y(e,0,t)):r=n,r},d=function(e,t,n){var r;return null==n&&(n=i),r=e[0],e[0]=t,y(e,0,n),r},u=function(e,t,n){var r;return null==n&&(n=i),e.length&&n(e[0],t)<0&&(t=(r=[e[0],t])[0],e[0]=r[1],y(e,0,n)),t},l=function(e,t){var n,r,o,a,l,c;for(null==t&&(t=i),l=[],r=0,o=(a=function(){c=[];for(var t=0,n=s(e.length/2);0<=n?t<n:t>n;0<=n?t++:t--)c.push(t);return c}.apply(this).reverse()).length;r<o;r++)n=a[r],l.push(y(e,n,t));return l},x=function(e,t,n){var r;if(null==n&&(n=i),-1!==(r=e.indexOf(t)))return g(e,0,r,n),y(e,r,n)},v=function(e,t,n){var r,o,a,s,c;if(null==n&&(n=i),!(o=e.slice(0,t)).length)return o;for(l(o,n),a=0,s=(c=e.slice(t)).length;a<s;a++)r=c[a],u(o,r,n);return o.sort(n).reverse()},m=function(e,t,n){var r,o,a,s,f,u,d,v,m;if(null==n&&(n=i),10*t<=e.length){if(!(a=e.slice(0,t).sort(n)).length)return a;for(o=a[a.length-1],s=0,u=(d=e.slice(t)).length;s<u;s++)n(r=d[s],o)<0&&(p(a,r,0,null,n),a.pop(),o=a[a.length-1]);return a}for(l(e,n),m=[],f=0,v=h(t,e.length);0<=v?f<v:f>v;0<=v?++f:--f)m.push(c(e,n));return m},g=function(e,t,n,r){var o,a,s;for(null==r&&(r=i),o=e[n];n>t&&r(o,a=e[s=n-1>>1])<0;)e[n]=a,n=s;return e[n]=o},y=function(e,t,n){var r,o,a,s,l;for(null==n&&(n=i),o=e.length,l=t,a=e[t],r=2*t+1;r<o;)(s=r+1)<o&&!(n(e[r],e[s])<0)&&(r=s),e[t]=e[r],r=2*(t=r)+1;return e[t]=a,g(e,l,t,n)},a=function(){function e(e){this.cmp=null!=e?e:i,this.nodes=[]}return e.push=f,e.pop=c,e.replace=d,e.pushpop=u,e.heapify=l,e.updateItem=x,e.nlargest=v,e.nsmallest=m,e.prototype.push=function(e){return f(this.nodes,e,this.cmp)},e.prototype.pop=function(){return c(this.nodes,this.cmp)},e.prototype.peek=function(){return this.nodes[0]},e.prototype.contains=function(e){return-1!==this.nodes.indexOf(e)},e.prototype.replace=function(e){return d(this.nodes,e,this.cmp)},e.prototype.pushpop=function(e){return u(this.nodes,e,this.cmp)},e.prototype.heapify=function(){return l(this.nodes,this.cmp)},e.prototype.updateItem=function(e){return x(this.nodes,e,this.cmp)},e.prototype.clear=function(){return this.nodes=[]},e.prototype.empty=function(){return 0===this.nodes.length},e.prototype.size=function(){return this.nodes.length},e.prototype.clone=function(){var t;return(t=new e).nodes=this.nodes.slice(0),t},e.prototype.toArray=function(){return this.nodes.slice(0)},e.prototype.insert=e.prototype.push,e.prototype.top=e.prototype.peek,e.prototype.front=e.prototype.peek,e.prototype.has=e.prototype.contains,e.prototype.copy=e.prototype.clone,e}(),r=[],void 0===(o="function"==typeof(n=function(){return a})?n.apply(t,r):n)||(e.exports=o)}).call(this)},4787:e=>{e.exports=function(){function e(t,n,r){function o(i,s){if(!n[i]){if(!t[i]){if(a)return a(i,!0);var l=new Error("Cannot find module '"+i+"'");throw l.code="MODULE_NOT_FOUND",l}var c=n[i]={exports:{}};t[i][0].call(c.exports,(function(e){return o(t[i][1][e]||e)}),c,c.exports,e,t,n,r)}return n[i].exports}for(var a=void 0,i=0;i<r.length;i++)o(r[i]);return o}return e}()({1:[function(e,t,n){function r(e,t,n){return(t[0]-e[0])*(n[1]-e[1])-(t[1]-e[1])*(n[0]-e[0])}function o(e){const t=[];for(let n=0;n<e.length;n++){for(;t.length>=2&&r(t[t.length-2],t[t.length-1],e[n])<=0;)t.pop();t.push(e[n])}return t.pop(),t}function a(e){const t=e.reverse(),n=[];for(let e=0;e<t.length;e++){for(;n.length>=2&&r(n[n.length-2],n[n.length-1],t[e])<=0;)n.pop();n.push(t[e])}return n.pop(),n}function i(e){const t=o(e),n=a(e).concat(t);return n.push(e[0]),n}t.exports=i},{}],2:[function(e,t,n){t.exports={toXy:function(e,t){return void 0===t?e.slice():e.map((function(e){return new Function("pt","return [pt"+t[0]+",pt"+t[1]+"];")(e)}))},fromXy:function(e,t){return void 0===t?e.slice():e.map((function(e){return new Function("pt","const o = {}; o"+t[0]+"= pt[0]; o"+t[1]+"= pt[1]; return o;")(e)}))}}},{}],3:[function(e,t,n){function r(e,t){this._cells=[],this._cellSize=t,this._reverseCellSize=1/t;for(let t=0;t<e.length;t++){const n=e[t],r=this.coordToCellNum(n[0]),o=this.coordToCellNum(n[1]);if(this._cells[r])this._cells[r][o]?this._cells[r][o].push(n):this._cells[r][o]=[n];else{const e=[];e[o]=[n],this._cells[r]=e}}}function o(e,t){return new r(e,t)}r.prototype={cellPoints:function(e,t){return void 0!==this._cells[e]&&void 0!==this._cells[e][t]?this._cells[e][t]:[]},rangePoints:function(e){const t=this.coordToCellNum(e[0]),n=this.coordToCellNum(e[1]),r=this.coordToCellNum(e[2]),o=this.coordToCellNum(e[3]),a=[];for(let e=t;e<=r;e++)for(let t=n;t<=o;t++)Array.prototype.push.apply(a,this.cellPoints(e,t));return a},removePoint:function(e){const t=this.coordToCellNum(e[0]),n=this.coordToCellNum(e[1]),r=this._cells[t][n];let o;for(let t=0;t<r.length;t++)if(r[t][0]===e[0]&&r[t][1]===e[1]){o=t;break}return r.splice(o,1),r},trunc:Math.trunc||function(e){return e-e%1},coordToCellNum:function(e){return this.trunc(e*this._reverseCellSize)},extendBbox:function(e,t){return[e[0]-t*this._cellSize,e[1]-t*this._cellSize,e[2]+t*this._cellSize,e[3]+t*this._cellSize]}},t.exports=o},{}],4:[function(e,t,n){"use strict";const r=e("./intersect.js"),o=e("./grid.js"),a=e("./format.js"),i=e("./convex.js");function s(e){const t=[e[0]];let n=e[0];for(let r=1;r<e.length;r++){const o=e[r];n[0]===o[0]&&n[1]===o[1]||t.push(o),n=o}return t}function l(e){return e.sort((function(e,t){return e[0]-t[0]||e[1]-t[1]}))}function c(e,t){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function f(e,t,n){const r=[t[0]-e[0],t[1]-e[1]],o=[n[0]-e[0],n[1]-e[1]],a=c(e,t),i=c(e,n);return(r[0]*o[0]+r[1]*o[1])/Math.sqrt(a*i)}function u(e,t){for(let n=0;n<t.length-1;n++){const o=[t[n],t[n+1]];if(!(e[0][0]===o[0][0]&&e[0][1]===o[0][1]||e[0][0]===o[1][0]&&e[0][1]===o[1][1])&&r(e,o))return!0}return!1}function d(e){let t=1/0,n=1/0,r=-1/0,o=-1/0;for(let a=e.length-1;a>=0;a--)e[a][0]<t&&(t=e[a][0]),e[a][1]<n&&(n=e[a][1]),e[a][0]>r&&(r=e[a][0]),e[a][1]>o&&(o=e[a][1]);return[r-t,o-n]}function p(e){return[Math.min(e[0][0],e[1][0]),Math.min(e[0][1],e[1][1]),Math.max(e[0][0],e[1][0]),Math.max(e[0][1],e[1][1])]}function h(e,t,n){let r,o,a=null,i=x,s=x;for(let l=0;l<t.length;l++)r=f(e[0],e[1],t[l]),o=f(e[1],e[0],t[l]),r>i&&o>s&&!u([e[0],t[l]],n)&&!u([e[1],t[l]],n)&&(i=r,s=o,a=t[l]);return a}function v(e,t,n,r,o){let a=!1;for(let i=0;i<e.length-1;i++){const s=[e[i],e[i+1]],l=s[0][0]+","+s[0][1]+","+s[1][0]+","+s[1][1];if(c(s[0],s[1])<t||o.has(l))continue;let f,u,d,v=0,m=p(s);do{m=r.extendBbox(m,v),f=m[2]-m[0],u=m[3]-m[1],d=h(s,r.rangePoints(m),e),v++}while(null===d&&(n[0]>f||n[1]>u));f>=n[0]&&u>=n[1]&&o.add(l),null!==d&&(e.splice(i+1,0,d),r.removePoint(d),a=!0)}return a?v(e,t,n,r,o):e}function m(e,t,n){let r=t||20;const c=s(l(a.toXy(e,n)));if(c.length<4)return c.concat([c[0]]);const f=d(c),u=[f[0]*g,f[1]*g],p=i(c),h=c.filter((function(e){return p.indexOf(e)<0})),m=Math.ceil(1/(c.length/(f[0]*f[1]))),x=v(p,Math.pow(r,2),u,o(h,m),new Set);return n?a.fromXy(x,n):x}const x=Math.cos(90/(180/Math.PI)),g=.6;t.exports=m},{"./convex.js":1,"./format.js":2,"./grid.js":3,"./intersect.js":5}],5:[function(e,t,n){function r(e,t,n,r,o,a){const i=(a-t)*(n-e)-(r-t)*(o-e);return i>0||!(i<0)}function o(e,t){const n=e[0][0],o=e[0][1],a=e[1][0],i=e[1][1],s=t[0][0],l=t[0][1],c=t[1][0],f=t[1][1];return r(n,o,s,l,c,f)!==r(a,i,s,l,c,f)&&r(n,o,a,i,s,l)!==r(n,o,a,i,c,f)}t.exports=o},{}]},{},[4])(4)},3477:(e,t,n)=>{"use strict";e.exports=function(e,t){var n=e.length;if(0===n)throw new Error("Must have at least d+1 points");var o=e[0].length;if(n<=o)throw new Error("Must input at least d+1 points");var i=e.slice(0,o+1),s=r.apply(void 0,i);if(0===s)throw new Error("Input not in general position");for(var l=new Array(o+1),f=0;f<=o;++f)l[f]=f;s<0&&(l[0]=1,l[1]=0);var u=new a(l,new Array(o+1),!1),d=u.adjacent,p=new Array(o+2);for(f=0;f<=o;++f){for(var h=l.slice(),v=0;v<=o;++v)v===f&&(h[v]=-1);var m=h[0];h[0]=h[1],h[1]=m;var x=new a(h,new Array(o+1),!0);d[f]=x,p[f]=x}p[o+1]=u;for(f=0;f<=o;++f){h=d[f].vertices;var g=d[f].adjacent;for(v=0;v<=o;++v){var y=h[v];if(y<0)g[v]=u;else for(var E=0;E<=o;++E)d[E].vertices.indexOf(y)<0&&(g[v]=d[E])}}var w=new c(o,i,p),b=!!t;for(f=o+1;f<n;++f)w.insert(e[f],b);return w.boundary()};var r=n(6651),o=n(8966).compareCells;function a(e,t,n){this.vertices=e,this.adjacent=t,this.boundary=n,this.lastVisited=-1}function i(e,t,n){this.vertices=e,this.cell=t,this.index=n}function s(e,t){return o(e.vertices,t.vertices)}a.prototype.flip=function(){var e=this.vertices[0];this.vertices[0]=this.vertices[1],this.vertices[1]=e;var t=this.adjacent[0];this.adjacent[0]=this.adjacent[1],this.adjacent[1]=t};var l=[];function c(e,t,n){this.dimension=e,this.vertices=t,this.simplices=n,this.interior=n.filter((function(e){return!e.boundary})),this.tuple=new Array(e+1);for(var o=0;o<=e;++o)this.tuple[o]=this.vertices[o];var a=l[e];a||(a=l[e]=function(e){for(var t=["function orient(){var tuple=this.tuple;return test("],n=0;n<=e;++n)n>0&&t.push(","),t.push("tuple[",n,"]");t.push(")}return orient");var o=new Function("test",t.join("")),a=r[e+1];return a||(a=r),o(a)}(e)),this.orient=a}var f=c.prototype;f.handleBoundaryDegeneracy=function(e,t){var n=this.dimension,r=this.vertices.length-1,o=this.tuple,a=this.vertices,i=[e];for(e.lastVisited=-r;i.length>0;){(e=i.pop()).vertices;for(var s=e.adjacent,l=0;l<=n;++l){var c=s[l];if(c.boundary&&!(c.lastVisited<=-r)){for(var f=c.vertices,u=0;u<=n;++u){var d=f[u];o[u]=d<0?t:a[d]}var p=this.orient();if(p>0)return c;c.lastVisited=-r,0===p&&i.push(c)}}}return null},f.walk=function(e,t){var n=this.vertices.length-1,r=this.dimension,o=this.vertices,a=this.tuple,i=t?this.interior.length*Math.random()|0:this.interior.length-1,s=this.interior[i];e:for(;!s.boundary;){for(var l=s.vertices,c=s.adjacent,f=0;f<=r;++f)a[f]=o[l[f]];s.lastVisited=n;for(f=0;f<=r;++f){var u=c[f];if(!(u.lastVisited>=n)){var d=a[f];a[f]=e;var p=this.orient();if(a[f]=d,p<0){s=u;continue e}u.boundary?u.lastVisited=-n:u.lastVisited=n}}return}return s},f.addPeaks=function(e,t){var n=this.vertices.length-1,r=this.dimension,o=this.vertices,l=this.tuple,c=this.interior,f=this.simplices,u=[t];t.lastVisited=n,t.vertices[t.vertices.indexOf(-1)]=n,t.boundary=!1,c.push(t);for(var d=[];u.length>0;){var p=(t=u.pop()).vertices,h=t.adjacent,v=p.indexOf(n);if(!(v<0))for(var m=0;m<=r;++m)if(m!==v){var x=h[m];if(x.boundary&&!(x.lastVisited>=n)){var g=x.vertices;if(x.lastVisited!==-n){for(var y=0,E=0;E<=r;++E)g[E]<0?(y=E,l[E]=e):l[E]=o[g[E]];if(this.orient()>0){g[y]=n,x.boundary=!1,c.push(x),u.push(x),x.lastVisited=n;continue}x.lastVisited=-n}var w=x.adjacent,b=p.slice(),_=h.slice(),T=new a(b,_,!0);f.push(T);var A=w.indexOf(t);if(!(A<0)){w[A]=T,_[v]=x,b[m]=-1,_[m]=t,h[m]=T,T.flip();for(E=0;E<=r;++E){var S=b[E];if(!(S<0||S===n)){for(var R=new Array(r-1),M=0,C=0;C<=r;++C){var L=b[C];L<0||C===E||(R[M++]=L)}d.push(new i(R,T,E))}}}}}}d.sort(s);for(m=0;m+1<d.length;m+=2){var P=d[m],k=d[m+1],N=P.index,H=k.index;N<0||H<0||(P.cell.adjacent[P.index]=k.cell,k.cell.adjacent[k.index]=P.cell)}},f.insert=function(e,t){var n=this.vertices;n.push(e);var r=this.walk(e,t);if(r){for(var o=this.dimension,a=this.tuple,i=0;i<=o;++i){var s=r.vertices[i];a[i]=s<0?e:n[s]}var l=this.orient(a);l<0||(0!==l||(r=this.handleBoundaryDegeneracy(r,e)))&&this.addPeaks(e,r)}},f.boundary=function(){for(var e=this.dimension,t=[],n=this.simplices,r=n.length,o=0;o<r;++o){var a=n[o];if(a.boundary){for(var i=new Array(e),s=a.vertices,l=0,c=0,f=0;f<=e;++f)s[f]>=0?i[l++]=s[f]:c=1&f;if(c===(1&e)){var u=i[0];i[0]=i[1],i[1]=u}t.push(i)}}return t}},1255:(e,t,n)=>{"use strict";e.exports=function(e,t){for(var n=function(e,t){return r.unique(r.normalize(r.skeleton(e,t)))}(e,1),l=r.incidence(n,e),c=r.dual(e,t.length),f=[],u=[],d=new Array(n.length),p=new Array(t.length),h=0;h<d.length;++h)d[h]=-1;for(h=0;h<p.length;++h)p[h]=-1;for(var v=0;v<e.length;++v){for(var m=e[v],x=0;x<3;++x){var g=m[x],y=m[(x+1)%3];s[0]=g,s[1]=y;var E=r.findCell(n,s),w=d[E];if(w>=0)a[x]=w;else{var b=l[E],_=t[y],T=t[g],A=new Array(3);if(2===b.length){var S=t[o(y,g,e[b[0]])],R=t[o(y,g,e[b[1]])];for(h=0;h<3;++h)A[h]=(3*(_[h]+T[h])+S[h]+R[h])/8}else for(h=0;h<3;++h)A[h]=.5*(_[h]+T[h]);d[E]=a[x]=f.length,f.push(A)}if(p[g]>=0)i[x]=p[g];else{var M=c[g],C=[g];for(h=0;h<M.length;++h)for(var L=e[M[h]],P=0;P<3;++P)-1!==C.indexOf(L[P])&&C.push(L[P]);var k=3===M.length?3/16:3/(8*M.length),N=1-M.length*k,H=t[g];for(A=[.1,.1,.1],h=0;h<3;++h)A[h]=N*H[h];for(h=1;h<C.length;++h){var z=t[C[h]];for(P=0;P<3;++P)A[P]+=k*z[P]}i[x]=p[g]=f.length,f.push(A)}}u.push([i[0],a[0],a[2]],[a[0],a[1],a[2]],[a[0],i[1],a[1]],[a[1],i[2],a[2]])}return{positions:f,cells:u}};var r=n(8966);function o(e,t,n){for(var r=0;r<3;++r)if(n[r]!==e&&n[r]!==t)return n[r];return 0}var a=[0,0,0],i=[0,0,0],s=[0,0]},9852:(e,t,n)=>{var r=n(579).rasterize,o=n(579).contour,a=n(3794).angleNormals,i=n(8670);function s(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function l(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function c(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}var f=[0,0,0],u=[0,0,0],d=[0,0,0],p=[0,0,0],h=[0,0,0];function v(e,t,n,r,o){c(f,r,n),c(u,o,n),s(p,t,u);var a=l(f,p);if(Math.abs(a)<1e-4)return 1/0;c(d,e,n);var i=l(d,p);if(i<0||i>a)return 1/0;s(h,d,f);var v=l(t,h);return v<0||i+v>a?1/0:l(u,h)/a}e.exports=function(e,t,n){var s,l=n||{},c=2*(s="tolerance"in l?l.tolerance:function(e,t){for(var n=0,r=0;r<e.length;++r)for(var o=e[r],a=0;a<3;++a){var i=t[o[a]],s=t[o[(a+1)%3]];n+=Math.sqrt(Math.pow(i[0]-s[0],2)+Math.pow(i[1]-s[1],2)+Math.pow(i[2]-s[2],2))}return 2*n/(3*e.length)}(e,t)),f=o(r(e,t,{resolution:.5*s})),u=function(e,t,n){for(var r={},o=0;o<e.length;++o)for(var a=e[o],i=t[a[0]],s=t[a[1]],l=t[a[2]],c=Math.floor(Math.min(i[0],s[0],l[0])/n)-1,f=Math.floor(Math.min(i[1],s[1],l[1])/n)-1,u=Math.floor(Math.min(i[2],s[2],l[2])/n)-1,d=Math.ceil(Math.max(i[0],s[0],l[0])/n)+1,p=Math.ceil(Math.max(i[1],s[1],l[1])/n)+1,h=Math.ceil(Math.max(i[2],s[2],l[2])/n)+1,v=c;v<=d;++v)for(var m=f;m<=p;++m)for(var x=u;x<=h;++x){var g=v+","+m+","+x,y=r[g];y?y.push(a):r[g]=[a]}return r}(e,t,c);return f.normals=a(f.cells,f.positions),function(e,t,n,r,o){for(var a=0;a<n.length;++a){var i=n[a],s=i[0],l=i[1],c=i[1],f=e[Math.floor(s/o)+","+Math.floor(l/o)+","+Math.floor(c/o)];if(f){for(var u=r[a],d=1/0,p=0;p<f.length;++p){var h=f[p],m=v(i,u,t[h[0]],t[h[1]],t[h[2]]);Math.abs(m)<Math.abs(d)&&(d=m)}Math.abs(d)}}}(u,t,(f=i(f.cells,f.positions,f.normals,{edgeLength:.5*s})).positions,f.normals,c),f}},3190:(e,t,n)=>{var r=n(3930),o=n(8966);function a(e,t,n,r,o,a){for(var i=new Array(3),s=new Array(3),l=0,c=0;c<3;++c)i[c]=t[c]-e[c],l+=i[c]*i[c],s[c]=n[c]-e[c];if(l<1e-6)return 1e30;var f=Math.sqrt(l),u=1/f,d=0;for(c=0;c<3;++c)i[c]*=u,d+=i[c]*s[c];var p=0;for(c=0;c<3;++c)p+=Math.pow(s[c]-d*i[c],2);p=Math.sqrt(p);var h=r*r,v=(h-o*o+l)/(2*f),m=h-v*v;return m<0?1e30:(m=Math.sqrt(m),a<0&&(m*=-1),Math.sqrt(Math.pow(d-v,2)+Math.pow(p-m,2)))}function i(e,t){this.d=e,this.v=t}function s(e,t){return e.d-t.d}t.j=function(e,t,n,l,c,f){void 0===l&&(l=Number.POSITIVE_INFINITY),void 0===c&&(c=1e-4),"undefined"==typeof dual&&(f=o.dual(e,t.length));var u=function(e,t,n,o,a){var l=new r(s),c={};l.push(new i(0,e));for(var f=o[e],u=a*a;l.size()>0;){var d=l.pop();if(!(d.v in c)){var p=d.d,h=d.v;c[h]=p;for(var v=o[h],m=t[h],x=0;x<m.length;++x)for(var g=n[m[x]],y=0;y<g.length;++y){var E=g[y];if(E!==h&&!(E in c)){for(var w=o[E],b=0,_=0,T=0;T<3;++T)b+=Math.pow(v[T]-w[T],2),_+=Math.pow(f[T]-w[T],2);_<=u&&l.push(new i(Math.sqrt(b)+p,E))}}}}return c}(n,f,e,t,l);return function(e,t,n,r,o,i,s){function l(e,n){return t[e]-t[n]}for(var c=!1;!c;){c=!0;var f=[];for(var u in t)f.push(u);f.sort(l);for(var d=0;d<f.length&&(u=f[d],!(t[u]>i));++d)for(var p=r[u],h=0;h<p.length;++h){var v=o[p[h]].slice(0);if(v.sort(l),!(Math.abs(t[v[1]]-t[v[2]])<1e-6)){var m=a(n[v[0]],n[v[1]],n[v[2]],t[v[0]],t[v[1]],-1);if(!(m>i)){var x=t[v[2]];m<x&&Math.abs(m-x)>s&&(t[v[2]]=Math.min(x,m),c=!1)}}}}}(0,u,t,f,e,l,c),u}},4078:(e,t,n)=>{"use strict";var r=n(4964);function o(e,t){return e[0]-t[0]||e[1]-t[1]}e.exports=function(e,t){for(var n=t.length,a=e.length,i=r.mallocDouble(n),s=0;s<n;++s)i[s]=0;var l=[];for(s=0;s<a;++s){var c=e[s],f=c[0],u=c[1],d=c[2],p=t[f],h=t[u],v=t[d],m=p[0]-h[0],x=p[1]-h[1],g=p[2]-h[2],y=h[0]-v[0],E=h[1]-v[1],w=h[2]-v[2],b=v[0]-p[0],_=v[1]-p[1],T=v[2]-p[2],A=.5*(P=x*T-g*_,k=g*b-m*T,N=m*_-x*b,Math.sqrt(Math.pow(P,2)+Math.pow(k,2)+Math.pow(N,2)));if(!(A<1e-8)){var S=-.5/A,R=S*(m*b+x*_+g*T),M=S*(y*m+E*x+w*g),C=S*(b*y+_*E+T*w),L=A/3;i[f]+=L,i[u]+=L,i[d]+=L,l.push([u,d,R],[d,u,R],[d,f,M],[f,d,M],[f,u,C],[u,f,C])}}var P,k,N;var H=r.mallocDouble(n);for(s=0;s<n;++s)H[s]=0;l.sort(o);var z=0;for(s=0;s<l.length;){for(var D=l[s++];s<l.length&&l[s][0]===D[0]&&l[s][1]===D[1];)D[2]+=l[s++][2];D[2]/=i[D[0]],H[D[0]]+=D[2],l[z++]=D}l.length=z;for(s=0;s<n;++s)l.push([s,s,-H[s]]);return r.free(i),r.free(H),l}},8570:(e,t,n)=>{"use strict";e.exports=function(e,t){var n,a=o.fromList(r(e,t)),i=t.length,s=new Array(i),l=new Array(i),c=new Array(i),f=new Array(i);for(n=0;n<i;++n){var u=t[n];s[n]=u[0],l[n]=u[1],c[n]=u[2],f[n]=0}for(a.apply(s,f),n=0;n<i;++n)f[n]=Math.pow(f[n],2),s[n]=0;for(a.apply(l,s),n=0;n<i;++n)f[n]+=Math.pow(s[n],2),s[n]=0;for(a.apply(c,s),n=0;n<i;++n)f[n]+=Math.pow(s[n],2),s[n]=0;for(n=0;n<i;++n)f[n]=Math.sqrt(f[n]);return f};var r=n(4078),o=n(202)},4948:(e,t)=>{"use strict";t.compareCoord=new Function("ra","rb",["for(var i=2;i>=0;--i) {","var d=ra[i]-rb[i];","if(d){return d;}","}","return 0;"].join("\n")),t.saturateAbs=new Function("x",["if(x >= 0.0) {","if(x <= 1.0) {","return x;","}","} else if(x >= -1.0) {","return -x;","}","return 1.0;"].join("\n")),t.EPSILON=1e-6,t.POSITIVE_INFINITY=1<<30,t.NEGATIVE_INFINITY=-(1<<30)},639:(e,t,n)=>{"use strict";e.exports=function(e){var t=e.length;if(t<3){for(var n=new Array(t),o=0;o<t;++o)n[o]=o;return 2===t&&e[0][0]===e[1][0]&&e[0][1]===e[1][1]?[0]:n}var a=new Array(t);for(o=0;o<t;++o)a[o]=o;a.sort((function(t,n){var r=e[t][0]-e[n][0];return r||e[t][1]-e[n][1]}));var i=[a[0],a[1]],s=[a[0],a[1]];for(o=2;o<t;++o){for(var l=a[o],c=e[l],f=i.length;f>1&&r(e[i[f-2]],e[i[f-1]],c)<=0;)f-=1,i.pop();for(i.push(l),f=s.length;f>1&&r(e[s[f-2]],e[s[f-1]],c)>=0;)f-=1,s.pop();s.push(l)}n=new Array(s.length+i.length-2);for(var u=0,d=(o=0,i.length);o<d;++o)n[u++]=i[o];for(var p=s.length-2;p>0;--p)n[u++]=s[p];return n};var r=n(6651)[3]},5251:(e,t,n)=>{"use strict";var r=n(4948),o=r.POSITIVE_INFINITY,a=r.NEGATIVE_INFINITY,i=n(2552).StencilIterator,s=new Array(128);function l(e,t,n,r,o,a){this.volumes=e,this.stencil=t,this.ptrs=n,this.coord=r,this.stencil_len=o,this.frontier=a}!function(){for(var e=0;e<128;++e)s[e]=0}(),l.prototype.clone=function(){return new l(this.volumes,this.stencil,new Int32Array(this.ptrs),new Int32Array(this.coord),this.stencil_len)},l.prototype.hasNext=function(){return this.coord[0]<o},l.prototype.next=function(){for(var e=this.volumes,t=this.stencil,n=this.ptrs,r=this.coord,a=this.stencil_len,i=this.frontier,l=0,c=0,f=0;f<3;++f)r[f]=o;for(var u=0;u<e.length;++u){var d=e[u],p=d.coords,h=d.length();f=0;e:for(var v=0;f<a;++f,v+=3,c++){var m=n[c];if(!(m>=h-1)){m+=1;for(var x=2;x>=0;--x){var g=p[x][m]-t[v+x],y=r[x];if(g<y){for(r[x--]=g;x>=0;--x)r[x]=p[x][m]-t[v+x];l=0;break}if(g>y)continue e}s[l++]=c}}}for(f=0;f<i.length;++f)i[f]=0;for(f=0;f<l;++f){++n[c=s[f]],i[c]=1}},l.prototype.seek=function(e){for(var t=this.volumes,n=this.ptrs,r=this.stencil,o=new Int32Array(3),a=0,i=0;i<3;++i)this.coord[i]=e[i];for(var s=0;s<t.length;++s)for(var l=t[s],c=l.coords,f=l.length(),u=(i=0,0);i<stencil_len;++i,u+=3){for(var d=0;d<3;++d)o[d]=e[d]+r[u+d];n[a]=l.bisect(o,0,f-1),this[a]=c[0][n[a]]===o[0]&&c[1][n[a]]===o[1]&&c[2][n[a]]===o[2],++a}},l.prototype.getValues=function(e,t){for(var n=this.ptrs,r=this.frontier,o=0,a=0;a<this.volumes.length;++a)for(var i=this.volumes[a],s=i.phases,l=i.distances,c=0;c<this.stencil_len;++c){var f=n[o];e[o]=s[f],t[o]=r[o]?l[f]:1,++o}},l.prototype.subiterator=function(e){var t=this.stencil_len;return new i(this.volumes[e],this.stencil,new Int32Array(this.ptrs.subarray(3*t*e,3*t*(e+1))),new Int32Array(this.coord))},t.MultiIterator=l,t.beginMulti=function(e,t){var n=t.length/3|0;return s.length<n&&(s.length=n),new l(e,t,new Int32Array(e.length*n),new Int32Array([a,a,a]),n,new Uint8Array(e.length*n))}},3071:(e,t,n)=>{"use strict";var r=n(1641),o=n(2917),a=n(4964),i=n(19);function s(e,t,n,r,o,a,s){e|=0,t|=0,n|=0,o|=0,a|=0,i.isPow2(n)?c(e,t,n,r,o,a):function(e,t,n,r,o,a,s){e|=0,t|=0,n|=0,o|=0,a|=0,s|=0;var l,f,u,d,p,h,v,m,x,g=i.nextPow2(2*n+1),y=s,E=y+n,w=E+n,b=w+g,_=b+g,T=_+g,A=-e*Math.PI/n;for(x=0;x<n;++x)f=A*(x*x%(2*n)),d=Math.cos(f),p=Math.sin(f),r[_+(g-x)]=r[_+x]=r[y+x]=d,r[T+(g-x)]=r[T+x]=r[E+x]=p;for(x=n;x<=g-n;++x)r[_+x]=0;for(x=n;x<=g-n;++x)r[T+x]=0;c(1,1,g,r,_,T),A=e<0?1/n:1;for(l=0;l<t;++l){for(x=0;x<n;++x)f=r[o+x],u=r[a+x],h=(d=r[y+x])*(f+u),v=f*((p=-r[E+x])-d),m=u*(d+p),r[w+x]=h-m,r[b+x]=h+v;for(x=n;x<g;++x)r[w+x]=0;for(x=n;x<g;++x)r[b+x]=0;for(c(1,1,g,r,w,b),x=0;x<g;++x)f=r[w+x],u=r[b+x],h=(d=r[_+x])*(f+u),v=f*((p=r[T+x])-d),m=u*(d+p),r[w+x]=h-m,r[b+x]=h+v;for(c(-1,1,g,r,w,b),x=0;x<n;++x)f=r[w+x],u=r[b+x],h=(d=r[y+x])*(f+u),v=f*((p=-r[E+x])-d),m=u*(d+p),r[o+x]=A*(h-m),r[a+x]=A*(h+v);o+=n,a+=n}}(e,t,n,r,o,a,s)}function l(e){return i.isPow2(e)?0:2*e+4*i.nextPow2(2*e+1)}function c(e,t,n,r,o,a){var s,l,c,f,u,d,p,h,v,m,x,g,y,E,w,b,_,T,A,S,R,M,C,L;for(e|=0,t|=0,o|=0,a|=0,s=n|=0,l=i.log2(s),T=0;T<t;++T){for(p=s>>1,u=0,c=0;c<s-1;c++){for(c<u&&(y=r[o+c],r[o+c]=r[o+u],r[o+u]=y,y=r[a+c],r[a+c]=r[a+u],r[a+u]=y),d=p;d<=u;)u-=d,d>>=1;u+=d}for(x=-1,g=0,m=1,h=0;h<l;h++){for(v=m,m<<=1,b=1,_=0,u=0;u<v;u++){for(c=u;c<s;c+=m)A=r[o+(f=c+v)],S=r[a+f],R=r[o+c],M=r[a+c],E=(C=b*(A+S))-S*(b+_),w=C+(L=A*(_-b)),r[o+f]=R-E,r[a+f]=M-w,r[o+c]+=E,r[a+c]+=w;L=b*(g-x),b=(C=x*(b+_))-_*(x+g),_=C+L}g=Math.sqrt((1-x)/2),e<0&&(g=-g),x=Math.sqrt((1+x)/2)}if(e<0){var P=1/s;for(c=0;c<s;c++)r[o+c]*=P,r[a+c]*=P}o+=n,a+=n}}e.exports=function(e,t,n){var i,c,f=t.shape,u=f.length,d=1,p=new Array(u),h=0;for(i=u-1;i>=0;--i)if(p[i]=d,d*=f[i],h=Math.max(h,l(f[i])),t.shape[i]!==n.shape[i])throw new Error("Shape mismatch, real and imaginary arrays must have same size");var v,m=4*d+h;v="array"===t.dtype||"float64"===t.dtype||"custom"===t.dtype?a.mallocDouble(m):a.mallocFloat(m);var x,g,y,E,w=o(v,f.slice(0),p,0),b=o(v,f.slice(0),p.slice(0),d),_=o(v,f.slice(0),p.slice(0),2*d),T=o(v,f.slice(0),p.slice(0),3*d),A=4*d;for(r.assign(w,t),r.assign(b,n),i=u-1;i>=0&&(s(e,d/f[i],f[i],v,w.offset,b.offset,A),0!==i);--i){for(g=1,y=_.stride,E=T.stride,c=i-1;c<u;++c)E[c]=y[c]=g,g*=f[c];for(c=i-2;c>=0;--c)E[c]=y[c]=g,g*=f[c];r.assign(_,w),r.assign(T,b),x=w,w=_,_=x,x=b,b=T,T=x}r.assign(t,w),r.assign(n,b),a.free(v)}},6667:(e,t,n)=>{"use strict";e.exports=function(e,t,n){var c=new Array(e.dimension),f=1;Array.isArray(n)||(n=l(e.dimension,!!n));Array.isArray(t)||(t=l(e.dimension,t));for(var u=0;u<e.dimension;++u)n[u]?c[u]=e.shape[u]:c[u]=o(e.shape[u]+2*Math.ceil(3*t[u])),f*=c[u];var d=r(s.mallocFloat(f),c),p=d.hi.apply(d,e.shape.slice()),h=r(s.mallocFloat(f),c);return a.assigns(d,0),a.assign(p,e),a.assigns(h,0),i(1,d,h),function(e,t,n){for(var r=n.length,o=new Array(r),a=new Array(r),i=0;i<r;i++)o[i]=e.shape[i],a[i]=0;var s=new Array(r);for(i=0;i<r;++i)n[i]<1e-6?s[i]=0:s[i]=-2*Math.pow(Math.PI*n[i]/o[i],2);if(1===r)for(a[0]=0;a[0]<o[0];++a[0]){var l=0;for(i=0;i<r;++i){var c=.5*o[i]-Math.abs(.5*o[i]-a[i]);l+=s[i]*c*c}l=Math.exp(l),e.set(a[0],e.get(a[0])*l),t.set(a[0],t.get(a[0])*l)}else if(2===r)for(a[1]=0;a[1]<o[1];++a[1])for(a[0]=0;a[0]<o[0];++a[0]){for(l=0,i=0;i<r;++i){c=.5*o[i]-Math.abs(.5*o[i]-a[i]);l+=s[i]*c*c}l=Math.exp(l),e.set(a[0],a[1],e.get(a[0],a[1])*l),t.set(a[0],a[1],t.get(a[0],a[1])*l)}else if(3===r)for(a[2]=0;a[2]<o[2];++a[2])for(a[1]=0;a[1]<o[1];++a[1])for(a[0]=0;a[0]<o[0];++a[0]){for(l=0,i=0;i<r;++i){c=.5*o[i]-Math.abs(.5*o[i]-a[i]);l+=s[i]*c*c}l=Math.exp(l),e.set(a[0],a[1],a[2],e.get(a[0],a[1],a[2])*l),t.set(a[0],a[1],a[2],t.get(a[0],a[1],a[2])*l)}else console.warn("gaussBlur: higher dimension (> 3) not supported")}(d,h,t),i(-1,d,h),a.assign(e,p),s.freeFloat(d),s.freeFloat(h),e};var r=n(2917),o=n(8249),a=n(1641),i=n(3071),s=n(4964),l=n(6951)},1641:(e,t,n)=>{"use strict";var r=n(9245),o={body:"",args:[],thisVars:[],localVars:[]};function a(e){if(!e)return o;for(var t=0;t<e.args.length;++t){var n=e.args[t];e.args[t]=0===t?{name:n,lvalue:!0,rvalue:!!e.rvalue,count:e.count||1}:{name:n,lvalue:!1,rvalue:!0,count:1}}return e.thisVars||(e.thisVars=[]),e.localVars||(e.localVars=[]),e}function i(e){for(var t=[],n=0;n<e.args.length;++n)t.push("a"+n);return new Function("P",["return function ",e.funcName,"_ndarrayops(",t.join(","),") {P(",t.join(","),");return a0}"].join(""))(function(e){return r({args:e.args,pre:a(e.pre),body:a(e.body),post:a(e.proc),funcName:e.funcName})}(e))}var s={add:"+",sub:"-",mul:"*",div:"/",mod:"%",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"};!function(){for(var e in s){var n=s[e];t[e]=i({args:["array","array","array"],body:{args:["a","b","c"],body:"a=b"+n+"c"},funcName:e}),t[e+"eq"]=i({args:["array","array"],body:{args:["a","b"],body:"a"+n+"=b"},rvalue:!0,funcName:e+"eq"}),t[e+"s"]=i({args:["array","array","scalar"],body:{args:["a","b","s"],body:"a=b"+n+"s"},funcName:e+"s"}),t[e+"seq"]=i({args:["array","scalar"],body:{args:["a","s"],body:"a"+n+"=s"},rvalue:!0,funcName:e+"seq"})}}();var l={not:"!",bnot:"~",neg:"-",recip:"1.0/"};!function(){for(var e in l){var n=l[e];t[e]=i({args:["array","array"],body:{args:["a","b"],body:"a="+n+"b"},funcName:e}),t[e+"eq"]=i({args:["array"],body:{args:["a"],body:"a="+n+"a"},rvalue:!0,count:2,funcName:e+"eq"})}}();var c={and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">="};!function(){for(var e in c){var n=c[e];t[e]=i({args:["array","array","array"],body:{args:["a","b","c"],body:"a=b"+n+"c"},funcName:e}),t[e+"s"]=i({args:["array","array","scalar"],body:{args:["a","b","s"],body:"a=b"+n+"s"},funcName:e+"s"}),t[e+"eq"]=i({args:["array","array"],body:{args:["a","b"],body:"a=a"+n+"b"},rvalue:!0,count:2,funcName:e+"eq"}),t[e+"seq"]=i({args:["array","scalar"],body:{args:["a","s"],body:"a=a"+n+"s"},rvalue:!0,count:2,funcName:e+"seq"})}}();var f=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan"];!function(){for(var e=0;e<f.length;++e){var n=f[e];t[n]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b)",thisVars:["this_f"]},funcName:n}),t[n+"eq"]=i({args:["array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a"],body:"a=this_f(a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"eq"})}}();var u=["max","min","atan2","pow"];!function(){for(var e=0;e<u.length;++e){var n=u[e];t[n]=i({args:["array","array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(b,c)",thisVars:["this_f"]},funcName:n}),t[n+"s"]=i({args:["array","array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(b,c)",thisVars:["this_f"]},funcName:n+"s"}),t[n+"eq"]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(a,b)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"eq"}),t[n+"seq"]=i({args:["array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(a,b)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"seq"})}}();var d=["atan2","pow"];!function(){for(var e=0;e<d.length;++e){var n=d[e];t[n+"op"]=i({args:["array","array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(c,b)",thisVars:["this_f"]},funcName:n+"op"}),t[n+"ops"]=i({args:["array","array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b","c"],body:"a=this_f(c,b)",thisVars:["this_f"]},funcName:n+"ops"}),t[n+"opeq"]=i({args:["array","array"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b,a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"opeq"}),t[n+"opseq"]=i({args:["array","scalar"],pre:{args:[],body:"this_f=Math."+n,thisVars:["this_f"]},body:{args:["a","b"],body:"a=this_f(b,a)",thisVars:["this_f"]},rvalue:!0,count:2,funcName:n+"opseq"})}}(),t.any=r({args:["array"],pre:o,body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"if(a){return true}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return false"},funcName:"any"}),t.all=r({args:["array"],pre:o,body:{args:[{name:"x",lvalue:!1,rvalue:!0,count:1}],body:"if(!x){return false}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return true"},funcName:"all"}),t.sum=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"this_s+=a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"sum"}),t.prod=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=1"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:1}],body:"this_s*=a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"prod"}),t.norm2squared=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:2}],body:"this_s+=a*a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norm2squared"}),t.norm2=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:2}],body:"this_s+=a*a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return Math.sqrt(this_s)"},funcName:"norm2"}),t.norminf=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:4}],body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norminf"}),t.norm1=r({args:["array"],pre:{args:[],localVars:[],thisVars:["this_s"],body:"this_s=0"},body:{args:[{name:"a",lvalue:!1,rvalue:!0,count:3}],body:"this_s+=a<0?-a:a",localVars:[],thisVars:["this_s"]},post:{args:[],localVars:[],thisVars:["this_s"],body:"return this_s"},funcName:"norm1"}),t.sup=r({args:["array"],pre:{body:"this_h=-Infinity",args:[],thisVars:["this_h"],localVars:[]},body:{body:"if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_h"],localVars:[]},post:{body:"return this_h",args:[],thisVars:["this_h"],localVars:[]}}),t.inf=r({args:["array"],pre:{body:"this_h=Infinity",args:[],thisVars:["this_h"],localVars:[]},body:{body:"if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_h"],localVars:[]},post:{body:"return this_h",args:[],thisVars:["this_h"],localVars:[]}}),t.argmin=r({args:["index","array","shape"],pre:{body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",args:[{name:"_inline_0_arg0_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg1_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg2_",lvalue:!1,rvalue:!0,count:1}],thisVars:["this_i","this_v"],localVars:[]},body:{body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2},{name:"_inline_1_arg1_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_i","this_v"],localVars:["_inline_1_k"]},post:{body:"{return this_i}",args:[],thisVars:["this_i"],localVars:[]}}),t.argmax=r({args:["index","array","shape"],pre:{body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",args:[{name:"_inline_0_arg0_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg1_",lvalue:!1,rvalue:!1,count:0},{name:"_inline_0_arg2_",lvalue:!1,rvalue:!0,count:1}],thisVars:["this_i","this_v"],localVars:[]},body:{body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",args:[{name:"_inline_1_arg0_",lvalue:!1,rvalue:!0,count:2},{name:"_inline_1_arg1_",lvalue:!1,rvalue:!0,count:2}],thisVars:["this_i","this_v"],localVars:["_inline_1_k"]},post:{body:"{return this_i}",args:[],thisVars:["this_i"],localVars:[]}}),t.random=i({args:["array"],pre:{args:[],body:"this_f=Math.random",thisVars:["this_f"]},body:{args:["a"],body:"a=this_f()",thisVars:["this_f"]},funcName:"random"}),t.assign=i({args:["array","array"],body:{args:["a","b"],body:"a=b"},funcName:"assign"}),t.assigns=i({args:["array","scalar"],body:{args:["a","b"],body:"a=b"},funcName:"assigns"}),t.equals=r({args:["array","array"],pre:o,body:{args:[{name:"x",lvalue:!1,rvalue:!0,count:1},{name:"y",lvalue:!1,rvalue:!0,count:1}],body:"if(x!==y){return false}",localVars:[],thisVars:[]},post:{args:[],localVars:[],thisVars:[],body:"return true"},funcName:"equals"})},3397:(e,t,n)=>{"use strict";var r=n(4964),o=32;function a(e){switch(e){case"uint8":return[r.mallocUint8,r.freeUint8];case"uint16":return[r.mallocUint16,r.freeUint16];case"uint32":return[r.mallocUint32,r.freeUint32];case"int8":return[r.mallocInt8,r.freeInt8];case"int16":return[r.mallocInt16,r.freeInt16];case"int32":return[r.mallocInt32,r.freeInt32];case"float32":return[r.mallocFloat,r.freeFloat];case"float64":return[r.mallocDouble,r.freeDouble];default:return null}}function i(e){for(var t=[],n=0;n<e;++n)t.push("s"+n);for(n=0;n<e;++n)t.push("n"+n);for(n=1;n<e;++n)t.push("d"+n);for(n=1;n<e;++n)t.push("e"+n);for(n=1;n<e;++n)t.push("f"+n);return t}function s(e,t){var n=["'use strict'"],r=["ndarraySortWrapper",e.join("d"),t].join("");n.push(["function ",r,"(",["array"].join(","),"){"].join(""));for(var s=["data=array.data,offset=array.offset|0,shape=array.shape,stride=array.stride"],l=0;l<e.length;++l)s.push(["s",l,"=stride[",l,"]|0,n",l,"=shape[",l,"]|0"].join(""));var c=new Array(e.length),f=[];for(l=0;l<e.length;++l){0!==(p=e[l])&&(0===f.length?c[p]="1":c[p]=f.join("*"),f.push("n"+p))}var u=-1,d=-1;for(l=0;l<e.length;++l){var p,h=e[l];0!==h&&(u>0?s.push(["d",h,"=s",h,"-d",u,"*n",u].join("")):s.push(["d",h,"=s",h].join("")),u=h),0!==(p=e.length-1-l)&&(d>0?s.push(["e",p,"=s",p,"-e",d,"*n",d,",f",p,"=",c[p],"-f",d,"*n",d].join("")):s.push(["e",p,"=s",p,",f",p,"=",c[p]].join("")),d=p)}n.push("var "+s.join(","));var v=["0","n0-1","data","offset"].concat(i(e.length));n.push(["if(n0<=",o,"){","insertionSort(",v.join(","),")}else{","quickSort(",v.join(","),")}"].join("")),n.push("}return "+r);var m=new Function("insertionSort","quickSort",n.join("\n")),x=function(e,t){var n=["'use strict'"],r=["ndarrayInsertionSort",e.join("d"),t].join(""),o=["left","right","data","offset"].concat(i(e.length)),s=a(t),l=["i,j,cptr,ptr=left*s0+offset"];if(e.length>1){for(var c=[],f=1;f<e.length;++f)l.push("i"+f),c.push("n"+f);s?l.push("scratch=malloc("+c.join("*")+")"):l.push("scratch=new Array("+c.join("*")+")"),l.push("dptr","sptr","a","b")}else l.push("scratch");function u(e){return"generic"===t?["data.get(",e,")"].join(""):["data[",e,"]"].join("")}function d(e,n){return"generic"===t?["data.set(",e,",",n,")"].join(""):["data[",e,"]=",n].join("")}if(n.push(["function ",r,"(",o.join(","),"){var ",l.join(",")].join(""),"for(i=left+1;i<=right;++i){","j=i;ptr+=s0","cptr=ptr"),e.length>1){for(n.push("dptr=0;sptr=ptr"),f=e.length-1;f>=0;--f)0!==(p=e[f])&&n.push(["for(i",p,"=0;i",p,"<n",p,";++i",p,"){"].join(""));for(n.push("scratch[dptr++]=",u("sptr")),f=0;f<e.length;++f)0!==(p=e[f])&&n.push("sptr+=d"+p,"}");for(n.push("__g:while(j--\x3eleft){","dptr=0","sptr=cptr-s0"),f=1;f<e.length;++f)1===f&&n.push("__l:"),n.push(["for(i",f,"=0;i",f,"<n",f,";++i",f,"){"].join(""));for(n.push(["a=",u("sptr"),"\nb=scratch[dptr]\nif(a<b){break __g}\nif(a>b){break __l}"].join("")),f=e.length-1;f>=1;--f)n.push("sptr+=e"+f,"dptr+=f"+f,"}");for(n.push("dptr=cptr;sptr=cptr-s0"),f=e.length-1;f>=0;--f)0!==(p=e[f])&&n.push(["for(i",p,"=0;i",p,"<n",p,";++i",p,"){"].join(""));for(n.push(d("dptr",u("sptr"))),f=0;f<e.length;++f)0!==(p=e[f])&&n.push(["dptr+=d",p,";sptr+=d",p].join(""),"}");for(n.push("cptr-=s0\n}"),n.push("dptr=cptr;sptr=0"),f=e.length-1;f>=0;--f)0!==(p=e[f])&&n.push(["for(i",p,"=0;i",p,"<n",p,";++i",p,"){"].join(""));for(n.push(d("dptr","scratch[sptr++]")),f=0;f<e.length;++f){var p;0!==(p=e[f])&&n.push("dptr+=d"+p,"}")}}else n.push("scratch="+u("ptr"),"while((j--\x3eleft)&&("+u("cptr-s0")+">scratch)){",d("cptr",u("cptr-s0")),"cptr-=s0","}",d("cptr","scratch"));return n.push("}"),e.length>1&&s&&n.push("free(scratch)"),n.push("} return "+r),s?new Function("malloc","free",n.join("\n"))(s[0],s[1]):new Function(n.join("\n"))()}(e,t),g=function(e,t,n){var r=["'use strict'"],s=["ndarrayQuickSort",e.join("d"),t].join(""),l=["left","right","data","offset"].concat(i(e.length)),c=a(t),f=0;r.push(["function ",s,"(",l.join(","),"){"].join(""));var u=["sixth=((right-left+1)/6)|0","index1=left+sixth","index5=right-sixth","index3=(left+right)>>1","index2=index3-sixth","index4=index3+sixth","el1=index1","el2=index2","el3=index3","el4=index4","el5=index5","less=left+1","great=right-1","pivots_are_equal=true","tmp","tmp0","x","y","z","k","ptr0","ptr1","ptr2","comp_pivot1=0","comp_pivot2=0","comp=0"];if(e.length>1){for(var d=[],p=1;p<e.length;++p)d.push("n"+p),u.push("i"+p);for(p=0;p<8;++p)u.push("b_ptr"+p);u.push("ptr3","ptr4","ptr5","ptr6","ptr7","pivot_ptr","ptr_shift","elementSize="+d.join("*")),c?u.push("pivot1=malloc(elementSize)","pivot2=malloc(elementSize)"):u.push("pivot1=new Array(elementSize),pivot2=new Array(elementSize)")}else u.push("pivot1","pivot2");function h(e){return["(offset+",e,"*s0)"].join("")}function v(e){return"generic"===t?["data.get(",e,")"].join(""):["data[",e,"]"].join("")}function m(e,n){return"generic"===t?["data.set(",e,",",n,")"].join(""):["data[",e,"]=",n].join("")}function x(t,n,o){if(1===t.length)r.push("ptr0="+h(t[0]));else for(var a=0;a<t.length;++a)r.push(["b_ptr",a,"=s0*",t[a]].join(""));for(n&&r.push("pivot_ptr=0"),r.push("ptr_shift=offset"),a=e.length-1;a>=0;--a)0!==(i=e[a])&&r.push(["for(i",i,"=0;i",i,"<n",i,";++i",i,"){"].join(""));if(t.length>1)for(a=0;a<t.length;++a)r.push(["ptr",a,"=b_ptr",a,"+ptr_shift"].join(""));for(r.push(o),n&&r.push("++pivot_ptr"),a=0;a<e.length;++a){var i;0!==(i=e[a])&&(t.length>1?r.push("ptr_shift+=d"+i):r.push("ptr0+=d"+i),r.push("}"))}}function g(t,n,o,a){if(1===n.length)r.push("ptr0="+h(n[0]));else{for(var i=0;i<n.length;++i)r.push(["b_ptr",i,"=s0*",n[i]].join(""));r.push("ptr_shift=offset")}for(o&&r.push("pivot_ptr=0"),t&&r.push(t+":"),i=1;i<e.length;++i)r.push(["for(i",i,"=0;i",i,"<n",i,";++i",i,"){"].join(""));if(n.length>1)for(i=0;i<n.length;++i)r.push(["ptr",i,"=b_ptr",i,"+ptr_shift"].join(""));for(r.push(a),i=e.length-1;i>=1;--i)o&&r.push("pivot_ptr+=f"+i),n.length>1?r.push("ptr_shift+=e"+i):r.push("ptr0+=e"+i),r.push("}")}function y(){e.length>1&&c&&r.push("free(pivot1)","free(pivot2)")}function E(t,n){var o="el"+t,a="el"+n;if(e.length>1){var i="__l"+ ++f;g(i,[o,a],!1,["comp=",v("ptr0"),"-",v("ptr1"),"\n","if(comp>0){tmp0=",o,";",o,"=",a,";",a,"=tmp0;break ",i,"}\n","if(comp<0){break ",i,"}"].join(""))}else r.push(["if(",v(h(o)),">",v(h(a)),"){tmp0=",o,";",o,"=",a,";",a,"=tmp0}"].join(""))}function w(t,n){e.length>1?x([t,n],!1,m("ptr0",v("ptr1"))):r.push(m(h(t),v(h(n))))}function b(t,n,o){if(e.length>1){var a="__l"+ ++f;g(a,[n],!0,[t,"=",v("ptr0"),"-pivot",o,"[pivot_ptr]\n","if(",t,"!==0){break ",a,"}"].join(""))}else r.push([t,"=",v(h(n)),"-pivot",o].join(""))}function _(t,n){e.length>1?x([t,n],!1,["tmp=",v("ptr0"),"\n",m("ptr0",v("ptr1")),"\n",m("ptr1","tmp")].join("")):r.push(["ptr0=",h(t),"\n","ptr1=",h(n),"\n","tmp=",v("ptr0"),"\n",m("ptr0",v("ptr1")),"\n",m("ptr1","tmp")].join(""))}function T(t,n,o){e.length>1?(x([t,n,o],!1,["tmp=",v("ptr0"),"\n",m("ptr0",v("ptr1")),"\n",m("ptr1",v("ptr2")),"\n",m("ptr2","tmp")].join("")),r.push("++"+n,"--"+o)):r.push(["ptr0=",h(t),"\n","ptr1=",h(n),"\n","ptr2=",h(o),"\n","++",n,"\n","--",o,"\n","tmp=",v("ptr0"),"\n",m("ptr0",v("ptr1")),"\n",m("ptr1",v("ptr2")),"\n",m("ptr2","tmp")].join(""))}function A(e,t){_(e,t),r.push("--"+t)}function S(t,n,o){e.length>1?x([t,n],!0,[m("ptr0",v("ptr1")),"\n",m("ptr1",["pivot",o,"[pivot_ptr]"].join(""))].join("")):r.push(m(h(t),v(h(n))),m(h(n),"pivot"+o))}function R(t,n){r.push(["if((",n,"-",t,")<=",o,"){\n","insertionSort(",t,",",n,",data,offset,",i(e.length).join(","),")\n","}else{\n",s,"(",t,",",n,",data,offset,",i(e.length).join(","),")\n","}"].join(""))}function M(t,n,o){e.length>1?(r.push(["__l",++f,":while(true){"].join("")),x([t],!0,["if(",v("ptr0"),"!==pivot",n,"[pivot_ptr]){break __l",f,"}"].join("")),r.push(o,"}")):r.push(["while(",v(h(t)),"===pivot",n,"){",o,"}"].join(""))}return r.push("var "+u.join(",")),E(1,2),E(4,5),E(1,3),E(2,3),E(1,4),E(3,4),E(2,5),E(2,3),E(4,5),e.length>1?x(["el1","el2","el3","el4","el5","index1","index3","index5"],!0,["pivot1[pivot_ptr]=",v("ptr1"),"\n","pivot2[pivot_ptr]=",v("ptr3"),"\n","pivots_are_equal=pivots_are_equal&&(pivot1[pivot_ptr]===pivot2[pivot_ptr])\n","x=",v("ptr0"),"\n","y=",v("ptr2"),"\n","z=",v("ptr4"),"\n",m("ptr5","x"),"\n",m("ptr6","y"),"\n",m("ptr7","z")].join("")):r.push(["pivot1=",v(h("el2")),"\n","pivot2=",v(h("el4")),"\n","pivots_are_equal=pivot1===pivot2\n","x=",v(h("el1")),"\n","y=",v(h("el3")),"\n","z=",v(h("el5")),"\n",m(h("index1"),"x"),"\n",m(h("index3"),"y"),"\n",m(h("index5"),"z")].join("")),w("index2","left"),w("index4","right"),r.push("if(pivots_are_equal){"),r.push("for(k=less;k<=great;++k){"),b("comp","k",1),r.push("if(comp===0){continue}"),r.push("if(comp<0){"),r.push("if(k!==less){"),_("k","less"),r.push("}"),r.push("++less"),r.push("}else{"),r.push("while(true){"),b("comp","great",1),r.push("if(comp>0){"),r.push("great--"),r.push("}else if(comp<0){"),T("k","less","great"),r.push("break"),r.push("}else{"),A("k","great"),r.push("break"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),r.push("}else{"),r.push("for(k=less;k<=great;++k){"),b("comp_pivot1","k",1),r.push("if(comp_pivot1<0){"),r.push("if(k!==less){"),_("k","less"),r.push("}"),r.push("++less"),r.push("}else{"),b("comp_pivot2","k",2),r.push("if(comp_pivot2>0){"),r.push("while(true){"),b("comp","great",2),r.push("if(comp>0){"),r.push("if(--great<k){break}"),r.push("continue"),r.push("}else{"),b("comp","great",1),r.push("if(comp<0){"),T("k","less","great"),r.push("}else{"),A("k","great"),r.push("}"),r.push("break"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),S("left","(less-1)",1),S("right","(great+1)",2),R("left","(less-2)"),R("(great+2)","right"),r.push("if(pivots_are_equal){"),y(),r.push("return"),r.push("}"),r.push("if(less<index1&&great>index5){"),M("less",1,"++less"),M("great",2,"--great"),r.push("for(k=less;k<=great;++k){"),b("comp_pivot1","k",1),r.push("if(comp_pivot1===0){"),r.push("if(k!==less){"),_("k","less"),r.push("}"),r.push("++less"),r.push("}else{"),b("comp_pivot2","k",2),r.push("if(comp_pivot2===0){"),r.push("while(true){"),b("comp","great",2),r.push("if(comp===0){"),r.push("if(--great<k){break}"),r.push("continue"),r.push("}else{"),b("comp","great",1),r.push("if(comp<0){"),T("k","less","great"),r.push("}else{"),A("k","great"),r.push("}"),r.push("break"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),r.push("}"),y(),R("less","great"),r.push("}return "+s),e.length>1&&c?new Function("insertionSort","malloc","free",r.join("\n"))(n,c[0],c[1]):new Function("insertionSort",r.join("\n"))(n)}(e,t,x);return m(x,g)}var l={};e.exports=function(e){var t=e.order,n=e.dtype,r=[t,n].join(":"),o=l[r];return o||(l[r]=o=s(t,n)),o(e),e}},2917:e=>{var t="undefined"!=typeof Float64Array;function n(e,t){return e[0]-t[0]}function r(){var e,t=this.stride,r=new Array(t.length);for(e=0;e<r.length;++e)r[e]=[Math.abs(t[e]),e];r.sort(n);var o=new Array(r.length);for(e=0;e<o.length;++e)o[e]=r[e][1];return o}function o(e,t){var n=["View",t,"d",e].join("");t<0&&(n="View_Nil"+e);var o="generic"===e;if(-1===t){var i="function "+n+"(a){this.data=a;};var proto="+n+".prototype;proto.dtype='"+e+"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new "+n+"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_"+n+"(a){return new "+n+"(a);}";return new Function(i)()}if(0===t){i="function "+n+"(a,d) {this.data = a;this.offset = d};var proto="+n+".prototype;proto.dtype='"+e+"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function "+n+"_copy() {return new "+n+"(this.data,this.offset)};proto.pick=function "+n+"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function "+n+"_get(){return "+(o?"this.data.get(this.offset)":"this.data[this.offset]")+"};proto.set=function "+n+"_set(v){return "+(o?"this.data.set(this.offset,v)":"this.data[this.offset]=v")+"};return function construct_"+n+"(a,b,c,d){return new "+n+"(a,d)}";return new Function("TrivialArray",i)(a[e][0])}i=["'use strict'"];var s=function(e){for(var t=new Array(e),n=0;n<e;++n)t[n]=n;return t}(t),l=s.map((function(e){return"i"+e})),c="this.offset+"+s.map((function(e){return"this.stride["+e+"]*i"+e})).join("+"),f=s.map((function(e){return"b"+e})).join(","),u=s.map((function(e){return"c"+e})).join(",");i.push("function "+n+"(a,"+f+","+u+",d){this.data=a","this.shape=["+f+"]","this.stride=["+u+"]","this.offset=d|0}","var proto="+n+".prototype","proto.dtype='"+e+"'","proto.dimension="+t),i.push("Object.defineProperty(proto,'size',{get:function "+n+"_size(){return "+s.map((function(e){return"this.shape["+e+"]"})).join("*"),"}})"),1===t?i.push("proto.order=[0]"):(i.push("Object.defineProperty(proto,'order',{get:"),t<4?(i.push("function "+n+"_order(){"),2===t?i.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})"):3===t&&i.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")):i.push("ORDER})")),i.push("proto.set=function "+n+"_set("+l.join(",")+",v){"),o?i.push("return this.data.set("+c+",v)}"):i.push("return this.data["+c+"]=v}"),i.push("proto.get=function "+n+"_get("+l.join(",")+"){"),o?i.push("return this.data.get("+c+")}"):i.push("return this.data["+c+"]}"),i.push("proto.index=function "+n+"_index(",l.join(),"){return "+c+"}"),i.push("proto.hi=function "+n+"_hi("+l.join(",")+"){return new "+n+"(this.data,"+s.map((function(e){return["(typeof i",e,"!=='number'||i",e,"<0)?this.shape[",e,"]:i",e,"|0"].join("")})).join(",")+","+s.map((function(e){return"this.stride["+e+"]"})).join(",")+",this.offset)}");var d=s.map((function(e){return"a"+e+"=this.shape["+e+"]"})),p=s.map((function(e){return"c"+e+"=this.stride["+e+"]"}));i.push("proto.lo=function "+n+"_lo("+l.join(",")+"){var b=this.offset,d=0,"+d.join(",")+","+p.join(","));for(var h=0;h<t;++h)i.push("if(typeof i"+h+"==='number'&&i"+h+">=0){d=i"+h+"|0;b+=c"+h+"*d;a"+h+"-=d}");i.push("return new "+n+"(this.data,"+s.map((function(e){return"a"+e})).join(",")+","+s.map((function(e){return"c"+e})).join(",")+",b)}"),i.push("proto.step=function "+n+"_step("+l.join(",")+"){var "+s.map((function(e){return"a"+e+"=this.shape["+e+"]"})).join(",")+","+s.map((function(e){return"b"+e+"=this.stride["+e+"]"})).join(",")+",c=this.offset,d=0,ceil=Math.ceil");for(h=0;h<t;++h)i.push("if(typeof i"+h+"==='number'){d=i"+h+"|0;if(d<0){c+=b"+h+"*(a"+h+"-1);a"+h+"=ceil(-a"+h+"/d)}else{a"+h+"=ceil(a"+h+"/d)}b"+h+"*=d}");i.push("return new "+n+"(this.data,"+s.map((function(e){return"a"+e})).join(",")+","+s.map((function(e){return"b"+e})).join(",")+",c)}");var v=new Array(t),m=new Array(t);for(h=0;h<t;++h)v[h]="a[i"+h+"]",m[h]="b[i"+h+"]";i.push("proto.transpose=function "+n+"_transpose("+l+"){"+l.map((function(e,t){return e+"=("+e+"===undefined?"+t+":"+e+"|0)"})).join(";"),"var a=this.shape,b=this.stride;return new "+n+"(this.data,"+v.join(",")+","+m.join(",")+",this.offset)}"),i.push("proto.pick=function "+n+"_pick("+l+"){var a=[],b=[],c=this.offset");for(h=0;h<t;++h)i.push("if(typeof i"+h+"==='number'&&i"+h+">=0){c=(c+this.stride["+h+"]*i"+h+")|0}else{a.push(this.shape["+h+"]);b.push(this.stride["+h+"])}");return i.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),i.push("return function construct_"+n+"(data,shape,stride,offset){return new "+n+"(data,"+s.map((function(e){return"shape["+e+"]"})).join(",")+","+s.map((function(e){return"stride["+e+"]"})).join(",")+",offset)}"),new Function("CTOR_LIST","ORDER",i.join("\n"))(a[e],r)}var a={float32:[],float64:[],int8:[],int16:[],int32:[],uint8:[],uint16:[],uint32:[],array:[],uint8_clamped:[],bigint64:[],biguint64:[],buffer:[],generic:[]};e.exports=function(e,n,r,i){if(void 0===e)return(0,a.array[0])([]);"number"==typeof e&&(e=[e]),void 0===n&&(n=[e.length]);var s=n.length;if(void 0===r){r=new Array(s);for(var l=s-1,c=1;l>=0;--l)r[l]=c,c*=n[l]}if(void 0===i){i=0;for(l=0;l<s;++l)r[l]<0&&(i-=(n[l]-1)*r[l])}for(var f=function(e){if(Buffer.isBuffer(e))return"buffer";if(t)switch(Object.prototype.toString.call(e)){case"[object Float64Array]":return"float64";case"[object Float32Array]":return"float32";case"[object Int8Array]":return"int8";case"[object Int16Array]":return"int16";case"[object Int32Array]":return"int32";case"[object Uint8Array]":return"uint8";case"[object Uint16Array]":return"uint16";case"[object Uint32Array]":return"uint32";case"[object Uint8ClampedArray]":return"uint8_clamped";case"[object BigInt64Array]":return"bigint64";case"[object BigUint64Array]":return"biguint64"}return Array.isArray(e)?"array":"generic"}(e),u=a[f];u.length<=s+1;)u.push(o(f,u.length-1));return(0,u[s+1])(e,n,r,i)}},8249:e=>{e.exports=function(e){return e+=0===e,--e,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,(e|=e>>>16)+1}},3794:(e,t)=>{t.vertexNormals=function(e,t,n){for(var r=t.length,o=new Array(r),a=void 0===n?1e-6:n,i=0;i<r;++i)o[i]=[0,0,0];for(i=0;i<e.length;++i)for(var s=e[i],l=0,c=s[s.length-1],f=s[0],u=0;u<s.length;++u){l=c,c=f,f=s[(u+1)%s.length];for(var d=t[l],p=t[c],h=t[f],v=new Array(3),m=0,x=new Array(3),g=0,y=0;y<3;++y)v[y]=d[y]-p[y],m+=v[y]*v[y],x[y]=h[y]-p[y],g+=x[y]*x[y];if(m*g>a){var E=o[c],w=1/Math.sqrt(m*g);for(y=0;y<3;++y){var b=(y+1)%3,_=(y+2)%3;E[y]+=w*(x[b]*v[_]-x[_]*v[b])}}}for(i=0;i<r;++i){E=o[i];var T=0;for(y=0;y<3;++y)T+=E[y]*E[y];if(T>a)for(w=1/Math.sqrt(T),y=0;y<3;++y)E[y]*=w;else for(y=0;y<3;++y)E[y]=0}return o},t.faceNormals=function(e,t,n){for(var r=e.length,o=new Array(r),a=void 0===n?1e-6:n,i=0;i<r;++i){for(var s=e[i],l=new Array(3),c=0;c<3;++c)l[c]=t[s[c]];var f=new Array(3),u=new Array(3);for(c=0;c<3;++c)f[c]=l[1][c]-l[0][c],u[c]=l[2][c]-l[0][c];var d=new Array(3),p=0;for(c=0;c<3;++c){var h=(c+1)%3,v=(c+2)%3;d[c]=f[h]*u[v]-f[v]*u[h],p+=d[c]*d[c]}p=p>a?1/Math.sqrt(p):0;for(c=0;c<3;++c)d[c]*=p;o[i]=d}return o},t.angleNormals=function(e,t){function n(e,t,n){return Math.sqrt(Math.pow(e,2)+Math.pow(t,2)+Math.pow(n,2))}function r(e,t,n){return Math.atan2(t,e-n)}function o(e,t,n,r,o){e[0]+=t*n,e[1]+=t*r,e[2]+=t*o}for(var a=t.length,i=e.length,s=new Array(a),l=0;l<a;++l)s[l]=[0,0,0];for(l=0;l<i;++l){var c=e[l],f=t[c[0]],u=t[c[1]],d=t[c[2]],p=f[0]-u[0],h=f[1]-u[1],v=f[2]-u[2],m=n(p,h,v),x=u[0]-d[0],g=u[1]-d[1],y=u[2]-d[2],E=n(x,g,y),w=n(d[0]-f[0],d[1]-f[1],d[2]-f[2]);if(!(Math.min(m,E,w)<1e-6)){var b=.5*(m+E+w),_=Math.sqrt((b-m)*(b-E)*(b-w)/b),T=h*y-v*g,A=v*x-p*y,S=p*g-h*x,R=n(T,A,S);T/=R,A/=R,S/=R,o(s[c[0]],r(b,_,E),T,A,S),o(s[c[1]],r(b,_,w),T,A,S),o(s[c[2]],r(b,_,m),T,A,S)}}for(l=0;l<a;++l){var M=s[l],C=Math.sqrt(Math.pow(M[0],2)+Math.pow(M[1],2)+Math.pow(M[2],2));C<1e-8?(M[0]=1,M[1]=0,M[2]=0):(M[0]/=C,M[1]/=C,M[2]/=C)}return s}},6047:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var numeric=exports;void 0!==__webpack_require__.g&&(__webpack_require__.g.numeric=numeric),numeric.version="1.2.6",numeric.bench=function(e,t){var n,r,o;for(void 0===t&&(t=15),r=.5,n=new Date;;){for(o=r*=2;o>3;o-=4)e(),e(),e(),e();for(;o>0;)e(),o--;if(new Date-n>t)break}for(o=r;o>3;o-=4)e(),e(),e(),e();for(;o>0;)e(),o--;return 1e3*(3*r-1)/(new Date-n)},numeric._myIndexOf=function(e){var t,n=this.length;for(t=0;t<n;++t)if(this[t]===e)return t;return-1},numeric.myIndexOf=Array.prototype.indexOf?Array.prototype.indexOf:numeric._myIndexOf,numeric.Function=Function,numeric.precision=4,numeric.largeArray=50,numeric.prettyPrint=function(e){function t(e){if(0===e)return"0";if(isNaN(e))return"NaN";if(e<0)return"-"+t(-e);if(isFinite(e)){var n=Math.floor(Math.log(e)/Math.log(10)),r=e/Math.pow(10,n),o=r.toPrecision(numeric.precision);return 10===parseFloat(o)&&(n++,o=(r=1).toPrecision(numeric.precision)),parseFloat(o).toString()+"e"+n.toString()}return"Infinity"}var n=[];return function e(r){var o;if(void 0===r)return n.push(Array(numeric.precision+8).join(" ")),!1;if("string"==typeof r)return n.push('"'+r+'"'),!1;if("boolean"==typeof r)return n.push(r.toString()),!1;if("number"==typeof r){var a=t(r),i=r.toPrecision(numeric.precision),s=parseFloat(r.toString()).toString(),l=[a,i,s,parseFloat(i).toString(),parseFloat(s).toString()];for(o=1;o<l.length;o++)l[o].length<a.length&&(a=l[o]);return n.push(Array(numeric.precision+8-a.length).join(" ")+a),!1}if(null===r)return n.push("null"),!1;if("function"==typeof r){n.push(r.toString());var c=!1;for(o in r)r.hasOwnProperty(o)&&(c?n.push(",\n"):n.push("\n{"),c=!0,n.push(o),n.push(": \n"),e(r[o]));return c&&n.push("}\n"),!0}if(r instanceof Array){if(r.length>numeric.largeArray)return n.push("...Large Array..."),!0;c=!1;for(n.push("["),o=0;o<r.length;o++)o>0&&(n.push(","),c&&n.push("\n ")),c=e(r[o]);return n.push("]"),!0}for(o in n.push("{"),c=!1,r)r.hasOwnProperty(o)&&(c&&n.push(",\n"),c=!0,n.push(o),n.push(": \n"),e(r[o]));return n.push("}"),!0}(e),n.join("")},numeric.parseDate=function(e){return function e(t){if("string"==typeof t)return Date.parse(t.replace(/-/g,"/"));if(!(t instanceof Array))throw new Error("parseDate: parameter must be arrays of strings");var n,r=[];for(n=0;n<t.length;n++)r[n]=e(t[n]);return r}(e)},numeric.parseFloat=function(e){return function e(t){if("string"==typeof t)return parseFloat(t);if(!(t instanceof Array))throw new Error("parseFloat: parameter must be arrays of strings");var n,r=[];for(n=0;n<t.length;n++)r[n]=e(t[n]);return r}(e)},numeric.parseCSV=function(e){var t,n,r,o=e.split("\n"),a=[],i=/(([^'",]*)|('[^']*')|("[^"]*")),/g,s=/^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,l=0;for(n=0;n<o.length;n++){var c,f=(o[n]+",").match(i);if(f.length>0){for(a[l]=[],t=0;t<f.length;t++)c=(r=f[t]).substr(0,r.length-1),s.test(c)?a[l][t]=parseFloat(c):a[l][t]=c;l++}}return a},numeric.toCSV=function(e){var t,n,r,o,a,i=numeric.dim(e);for(r=i[0],i[1],a=[],t=0;t<r;t++){for(o=[],n=0;n<r;n++)o[n]=e[t][n].toString();a[t]=o.join(", ")}return a.join("\n")+"\n"},numeric.getURL=function(e){var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(),t},numeric.imageURL=function(e){function t(e,t,n){void 0===t&&(t=0),void 0===n&&(n=e.length);var r,o=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],a=-1;e.length;for(r=t;r<n;r++)a=a>>>8^o[255&(a^e[r])];return-1^a}var n,r,o,a,i,s,l,c,f,u,d=e[0].length,p=e[0][0].length,h=[137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,p>>24&255,p>>16&255,p>>8&255,255&p,d>>24&255,d>>16&255,d>>8&255,255&d,8,2,0,0,0,-1,-2,-3,-4,-5,-6,-7,-8,73,68,65,84,8,29];for(u=t(h,12,29),h[29]=u>>24&255,h[30]=u>>16&255,h[31]=u>>8&255,h[32]=255&u,n=1,r=0,l=0;l<d;l++){for(l<d-1?h.push(0):h.push(1),i=3*p+1+(0===l)&255,s=3*p+1+(0===l)>>8&255,h.push(i),h.push(s),h.push(255&~i),h.push(255&~s),0===l&&h.push(0),c=0;c<p;c++)for(o=0;o<3;o++)r=(r+(n=(n+(i=(i=e[o][l][c])>255?255:i<0?0:Math.round(i)))%65521))%65521,h.push(i);h.push(0)}return f=(r<<16)+n,h.push(f>>24&255),h.push(f>>16&255),h.push(f>>8&255),h.push(255&f),a=h.length-41,h[33]=a>>24&255,h[34]=a>>16&255,h[35]=a>>8&255,h[36]=255&a,u=t(h,37),h.push(u>>24&255),h.push(u>>16&255),h.push(u>>8&255),h.push(255&u),h.push(0),h.push(0),h.push(0),h.push(0),h.push(73),h.push(69),h.push(78),h.push(68),h.push(174),h.push(66),h.push(96),h.push(130),"data:image/png;base64,"+function(e){var t,n,r,o,a,i,s,l=e.length,c="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",f="";for(t=0;t<l;t+=3)a=((3&(n=e[t]))<<4)+((r=e[t+1])>>4),i=((15&r)<<2)+((o=e[t+2])>>6),s=63&o,t+1>=l?i=s=64:t+2>=l&&(s=64),f+=c.charAt(n>>2)+c.charAt(a)+c.charAt(i)+c.charAt(s);return f}(h)},numeric._dim=function(e){for(var t=[];"object"==typeof e;)t.push(e.length),e=e[0];return t},numeric.dim=function(e){var t;return"object"==typeof e?"object"==typeof(t=e[0])?"object"==typeof t[0]?numeric._dim(e):[e.length,t.length]:[e.length]:[]},numeric.mapreduce=function(e,t){return Function("x","accum","_s","_k",'if(typeof accum === "undefined") accum = '+t+';\nif(typeof x === "number") { var xi = x; '+e+'; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    '+e+";\n    xi = x[i-1];\n    "+e+";\n}\nif(i === 0) {\n    xi = x[i];\n    "+e+"\n}\nreturn accum;")},numeric.mapreduce2=function(e,t){return Function("x","var n = x.length;\nvar i,xi;\n"+t+";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    "+e+";\n}\nreturn accum;")},numeric.same=function e(t,n){var r,o;if(!(t instanceof Array&&n instanceof Array))return!1;if((o=t.length)!==n.length)return!1;for(r=0;r<o;r++)if(t[r]!==n[r]){if("object"!=typeof t[r])return!1;if(!e(t[r],n[r]))return!1}return!0},numeric.rep=function(e,t,n){void 0===n&&(n=0);var r,o=e[n],a=Array(o);if(n===e.length-1){for(r=o-2;r>=0;r-=2)a[r+1]=t,a[r]=t;return-1===r&&(a[0]=t),a}for(r=o-1;r>=0;r--)a[r]=numeric.rep(e,t,n+1);return a},numeric.dotMMsmall=function(e,t){var n,r,o,a,i,s,l,c,f,u,d;for(a=e.length,i=t.length,s=t[0].length,l=Array(a),n=a-1;n>=0;n--){for(c=Array(s),f=e[n],o=s-1;o>=0;o--){for(u=f[i-1]*t[i-1][o],r=i-2;r>=1;r-=2)d=r-1,u+=f[r]*t[r][o]+f[d]*t[d][o];0===r&&(u+=f[0]*t[0][o]),c[o]=u}l[n]=c}return l},numeric._getCol=function(e,t,n){var r;for(r=e.length-1;r>0;--r)n[r]=e[r][t],n[--r]=e[r][t];0===r&&(n[0]=e[0][t])},numeric.dotMMbig=function(e,t){var n,r,o,a=numeric._getCol,i=t.length,s=Array(i),l=e.length,c=t[0].length,f=new Array(l),u=numeric.dotVV;for(--i,r=--l;-1!==r;--r)f[r]=Array(c);for(r=--c;-1!==r;--r)for(a(t,r,s),o=l;-1!==o;--o)0,n=e[o],f[o][r]=u(n,s);return f},numeric.dotMV=function(e,t){var n,r=e.length,o=(t.length,Array(r)),a=numeric.dotVV;for(n=r-1;n>=0;n--)o[n]=a(e[n],t);return o},numeric.dotVM=function(e,t){var n,r,o,a,i,s,l;for(o=e.length,a=t[0].length,i=Array(a),r=a-1;r>=0;r--){for(s=e[o-1]*t[o-1][r],n=o-2;n>=1;n-=2)l=n-1,s+=e[n]*t[n][r]+e[l]*t[l][r];0===n&&(s+=e[0]*t[0][r]),i[r]=s}return i},numeric.dotVV=function(e,t){var n,r,o=e.length,a=e[o-1]*t[o-1];for(n=o-2;n>=1;n-=2)r=n-1,a+=e[n]*t[n]+e[r]*t[r];return 0===n&&(a+=e[0]*t[0]),a},numeric.dot=function(e,t){var n=numeric.dim;switch(1e3*n(e).length+n(t).length){case 2002:return t.length<10?numeric.dotMMsmall(e,t):numeric.dotMMbig(e,t);case 2001:return numeric.dotMV(e,t);case 1002:return numeric.dotVM(e,t);case 1001:return numeric.dotVV(e,t);case 1e3:return numeric.mulVS(e,t);case 1:return numeric.mulSV(e,t);case 0:return e*t;default:throw new Error("numeric.dot only works on vectors and matrices")}},numeric.diag=function(e){var t,n,r,o,a=e.length,i=Array(a);for(t=a-1;t>=0;t--){for(o=Array(a),n=t+2,r=a-1;r>=n;r-=2)o[r]=0,o[r-1]=0;for(r>t&&(o[r]=0),o[t]=e[t],r=t-1;r>=1;r-=2)o[r]=0,o[r-1]=0;0===r&&(o[0]=0),i[t]=o}return i},numeric.getDiag=function(e){var t,n=Math.min(e.length,e[0].length),r=Array(n);for(t=n-1;t>=1;--t)r[t]=e[t][t],r[--t]=e[t][t];return 0===t&&(r[0]=e[0][0]),r},numeric.identity=function(e){return numeric.diag(numeric.rep([e],1))},numeric.pointwise=function(e,t,n){void 0===n&&(n="");var r,o,a=[],i=/\[i\]$/,s="",l=!1;for(r=0;r<e.length;r++)i.test(e[r])?s=o=e[r].substring(0,e[r].length-3):o=e[r],"ret"===o&&(l=!0),a.push(o);return a[e.length]="_s",a[e.length+1]="_k",a[e.length+2]='if(typeof _s === "undefined") _s = numeric.dim('+s+');\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i'+(l?"":", ret = Array(_n)")+";\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee("+e.join(",")+",_s,_k+1);\n    return ret;\n}\n"+n+"\nfor(i=_n-1;i!==-1;--i) {\n    "+t+"\n}\nreturn ret;",Function.apply(null,a)},numeric.pointwise2=function(e,t,n){void 0===n&&(n="");var r,o,a=[],i=/\[i\]$/,s="",l=!1;for(r=0;r<e.length;r++)i.test(e[r])?s=o=e[r].substring(0,e[r].length-3):o=e[r],"ret"===o&&(l=!0),a.push(o);return a[e.length]="var _n = "+s+".length;\nvar i"+(l?"":", ret = Array(_n)")+";\n"+n+"\nfor(i=_n-1;i!==-1;--i) {\n"+t+"\n}\nreturn ret;",Function.apply(null,a)},numeric._biforeach=function e(t,n,r,o,a){var i;if(o!==r.length-1)for(i=r[o]-1;i>=0;i--)e("object"==typeof t?t[i]:t,"object"==typeof n?n[i]:n,r,o+1,a);else a(t,n)},numeric._biforeach2=function e(t,n,r,o,a){if(o===r.length-1)return a(t,n);var i,s=r[o],l=Array(s);for(i=s-1;i>=0;--i)l[i]=e("object"==typeof t?t[i]:t,"object"==typeof n?n[i]:n,r,o+1,a);return l},numeric._foreach=function e(t,n,r,o){var a;if(r!==n.length-1)for(a=n[r]-1;a>=0;a--)e(t[a],n,r+1,o);else o(t)},numeric._foreach2=function e(t,n,r,o){if(r===n.length-1)return o(t);var a,i=n[r],s=Array(i);for(a=i-1;a>=0;a--)s[a]=e(t[a],n,r+1,o);return s},numeric.ops2={add:"+",sub:"-",mul:"*",div:"/",mod:"%",and:"&&",or:"||",eq:"===",neq:"!==",lt:"<",gt:">",leq:"<=",geq:">=",band:"&",bor:"|",bxor:"^",lshift:"<<",rshift:">>",rrshift:">>>"},numeric.opseq={addeq:"+=",subeq:"-=",muleq:"*=",diveq:"/=",modeq:"%=",lshifteq:"<<=",rshifteq:">>=",rrshifteq:">>>=",bandeq:"&=",boreq:"|=",bxoreq:"^="},numeric.mathfuns=["abs","acos","asin","atan","ceil","cos","exp","floor","log","round","sin","sqrt","tan","isNaN","isFinite"],numeric.mathfuns2=["atan2","pow","max","min"],numeric.ops1={neg:"-",not:"!",bnot:"~",clone:""},numeric.mapreducers={any:["if(xi) return true;","var accum = false;"],all:["if(!xi) return false;","var accum = true;"],sum:["accum += xi;","var accum = 0;"],prod:["accum *= xi;","var accum = 1;"],norm2Squared:["accum += xi*xi;","var accum = 0;"],norminf:["accum = max(accum,abs(xi));","var accum = 0, max = Math.max, abs = Math.abs;"],norm1:["accum += abs(xi)","var accum = 0, abs = Math.abs;"],sup:["accum = max(accum,xi);","var accum = -Infinity, max = Math.max;"],inf:["accum = min(accum,xi);","var accum = Infinity, min = Math.min;"]},function(){var e,t;for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],numeric.ops2[t]=t;for(e in numeric.ops2)if(numeric.ops2.hasOwnProperty(e)){t=numeric.ops2[e];var n,r,o="";-1!==numeric.myIndexOf.call(numeric.mathfuns2,e)?(o="var "+t+" = Math."+t+";\n",n=function(e,n,r){return e+" = "+t+"("+n+","+r+")"},r=function(e,n){return e+" = "+t+"("+e+","+n+")"}):(n=function(e,n,r){return e+" = "+n+" "+t+" "+r},r=numeric.opseq.hasOwnProperty(e+"eq")?function(e,n){return e+" "+t+"= "+n}:function(e,n){return e+" = "+e+" "+t+" "+n}),numeric[e+"VV"]=numeric.pointwise2(["x[i]","y[i]"],n("ret[i]","x[i]","y[i]"),o),numeric[e+"SV"]=numeric.pointwise2(["x","y[i]"],n("ret[i]","x","y[i]"),o),numeric[e+"VS"]=numeric.pointwise2(["x[i]","y"],n("ret[i]","x[i]","y"),o),numeric[e]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric."+e+"VV, VS = numeric."+e+"VS, SV = numeric."+e+'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else '+r("x","y")+"\n}\nreturn x;\n"),numeric[t]=numeric[e],numeric[e+"eqV"]=numeric.pointwise2(["ret[i]","x[i]"],r("ret[i]","x[i]"),o),numeric[e+"eqS"]=numeric.pointwise2(["ret[i]","x"],r("ret[i]","x"),o),numeric[e+"eq"]=Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric."+e+"eqV, S = numeric."+e+'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')}for(e=0;e<numeric.mathfuns2.length;++e)t=numeric.mathfuns2[e],delete numeric.ops2[t];for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],numeric.ops1[t]=t;for(e in numeric.ops1)numeric.ops1.hasOwnProperty(e)&&(o="",t=numeric.ops1[e],-1!==numeric.myIndexOf.call(numeric.mathfuns,e)&&Math.hasOwnProperty(t)&&(o="var "+t+" = Math."+t+";\n"),numeric[e+"eqV"]=numeric.pointwise2(["ret[i]"],"ret[i] = "+t+"(ret[i]);",o),numeric[e+"eq"]=Function("x",'if(typeof x !== "object") return '+t+"x\nvar i;\nvar V = numeric."+e+"eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n"),numeric[e+"V"]=numeric.pointwise2(["x[i]"],"ret[i] = "+t+"(x[i]);",o),numeric[e]=Function("x",'if(typeof x !== "object") return '+t+"(x)\nvar i;\nvar V = numeric."+e+"V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n"));for(e=0;e<numeric.mathfuns.length;++e)t=numeric.mathfuns[e],delete numeric.ops1[t];for(e in numeric.mapreducers)numeric.mapreducers.hasOwnProperty(e)&&(t=numeric.mapreducers[e],numeric[e+"V"]=numeric.mapreduce2(t[0],t[1]),numeric[e]=Function("x","s","k",t[1]+'if(typeof x !== "object") {    xi = x;\n'+t[0]+';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.'+e+"V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n"+t[0]+";\n}\nreturn accum;\n"))}(),numeric.truncVV=numeric.pointwise(["x[i]","y[i]"],"ret[i] = round(x[i]/y[i])*y[i];","var round = Math.round;"),numeric.truncVS=numeric.pointwise(["x[i]","y"],"ret[i] = round(x[i]/y)*y;","var round = Math.round;"),numeric.truncSV=numeric.pointwise(["x","y[i]"],"ret[i] = round(x/y[i])*y[i];","var round = Math.round;"),numeric.trunc=function(e,t){return"object"==typeof e?"object"==typeof t?numeric.truncVV(e,t):numeric.truncVS(e,t):"object"==typeof t?numeric.truncSV(e,t):Math.round(e/t)*t},numeric.inv=function(e){var t,n,r,o,a,i,s,l=numeric.dim(e),c=Math.abs,f=l[0],u=l[1],d=numeric.clone(e),p=numeric.identity(f);for(i=0;i<u;++i){var h=-1,v=-1;for(a=i;a!==f;++a)(s=c(d[a][i]))>v&&(h=a,v=s);for(n=d[h],d[h]=d[i],d[i]=n,o=p[h],p[h]=p[i],p[i]=o,e=n[i],s=i;s!==u;++s)n[s]/=e;for(s=u-1;-1!==s;--s)o[s]/=e;for(a=f-1;-1!==a;--a)if(a!==i){for(t=d[a],r=p[a],e=t[i],s=i+1;s!==u;++s)t[s]-=n[s]*e;for(s=u-1;s>0;--s)r[s]-=o[s]*e,r[--s]-=o[s]*e;0===s&&(r[0]-=o[0]*e)}}return p},numeric.det=function(e){var t=numeric.dim(e);if(2!==t.length||t[0]!==t[1])throw new Error("numeric: det() only works on square matrices");var n,r,o,a,i,s,l,c,f=t[0],u=1,d=numeric.clone(e);for(r=0;r<f-1;r++){for(o=r,n=r+1;n<f;n++)Math.abs(d[n][r])>Math.abs(d[o][r])&&(o=n);for(o!==r&&(l=d[o],d[o]=d[r],d[r]=l,u*=-1),a=d[r],n=r+1;n<f;n++){for(s=(i=d[n])[r]/a[r],o=r+1;o<f-1;o+=2)c=o+1,i[o]-=a[o]*s,i[c]-=a[c]*s;o!==f&&(i[o]-=a[o]*s)}if(0===a[r])return 0;u*=a[r]}return u*d[r][r]},numeric.transpose=function(e){var t,n,r,o,a,i=e.length,s=e[0].length,l=Array(s);for(n=0;n<s;n++)l[n]=Array(i);for(t=i-1;t>=1;t-=2){for(o=e[t],r=e[t-1],n=s-1;n>=1;--n)(a=l[n])[t]=o[n],a[t-1]=r[n],(a=l[--n])[t]=o[n],a[t-1]=r[n];0===n&&((a=l[0])[t]=o[0],a[t-1]=r[0])}if(0===t){for(r=e[0],n=s-1;n>=1;--n)l[n][0]=r[n],l[--n][0]=r[n];0===n&&(l[0][0]=r[0])}return l},numeric.negtranspose=function(e){var t,n,r,o,a,i=e.length,s=e[0].length,l=Array(s);for(n=0;n<s;n++)l[n]=Array(i);for(t=i-1;t>=1;t-=2){for(o=e[t],r=e[t-1],n=s-1;n>=1;--n)(a=l[n])[t]=-o[n],a[t-1]=-r[n],(a=l[--n])[t]=-o[n],a[t-1]=-r[n];0===n&&((a=l[0])[t]=-o[0],a[t-1]=-r[0])}if(0===t){for(r=e[0],n=s-1;n>=1;--n)l[n][0]=-r[n],l[--n][0]=-r[n];0===n&&(l[0][0]=-r[0])}return l},numeric._random=function e(t,n){var r,o,a=t[n],i=Array(a);if(n===t.length-1){for(o=Math.random,r=a-1;r>=1;r-=2)i[r]=o(),i[r-1]=o();return 0===r&&(i[0]=o()),i}for(r=a-1;r>=0;r--)i[r]=e(t,n+1);return i},numeric.random=function(e){return numeric._random(e,0)},numeric.norm2=function(e){return Math.sqrt(numeric.norm2Squared(e))},numeric.linspace=function(e,t,n){if(void 0===n&&(n=Math.max(Math.round(t-e)+1,1)),n<2)return 1===n?[e]:[];var r,o=Array(n);for(r=--n;r>=0;r--)o[r]=(r*t+(n-r)*e)/n;return o},numeric.getBlock=function(e,t,n){var r=numeric.dim(e);return function e(o,a){var i,s=t[a],l=n[a]-s,c=Array(l);if(a===r.length-1){for(i=l;i>=0;i--)c[i]=o[i+s];return c}for(i=l;i>=0;i--)c[i]=e(o[i+s],a+1);return c}(e,0)},numeric.setBlock=function(e,t,n,r){var o=numeric.dim(e);return function e(r,a,i){var s,l=t[i],c=n[i]-l;if(i===o.length-1)for(s=c;s>=0;s--)r[s+l]=a[s];for(s=c;s>=0;s--)e(r[s+l],a[s],i+1)}(e,r,0),e},numeric.getRange=function(e,t,n){var r,o,a,i,s=t.length,l=n.length,c=Array(s);for(r=s-1;-1!==r;--r)for(c[r]=Array(l),a=c[r],i=e[t[r]],o=l-1;-1!==o;--o)a[o]=i[n[o]];return c},numeric.blockMatrix=function(e){var t=numeric.dim(e);if(t.length<4)return numeric.blockMatrix([e]);var n,r,o,a,i,s=t[0],l=t[1];for(n=0,r=0,o=0;o<s;++o)n+=e[o][0].length;for(a=0;a<l;++a)r+=e[0][a][0].length;var c=Array(n);for(o=0;o<n;++o)c[o]=Array(r);var f,u,d,p,h,v=0;for(o=0;o<s;++o){for(f=r,a=l-1;-1!==a;--a)for(f-=(i=e[o][a])[0].length,d=i.length-1;-1!==d;--d)for(h=i[d],u=c[v+d],p=h.length-1;-1!==p;--p)u[f+p]=h[p];v+=e[o][0].length}return c},numeric.tensor=function(e,t){if("number"==typeof e||"number"==typeof t)return numeric.mul(e,t);var n=numeric.dim(e),r=numeric.dim(t);if(1!==n.length||1!==r.length)throw new Error("numeric: tensor product is only defined for vectors");var o,a,i,s,l=n[0],c=r[0],f=Array(l);for(a=l-1;a>=0;a--){for(o=Array(c),s=e[a],i=c-1;i>=3;--i)o[i]=s*t[i],o[--i]=s*t[i],o[--i]=s*t[i],o[--i]=s*t[i];for(;i>=0;)o[i]=s*t[i],--i;f[a]=o}return f},numeric.T=function(e,t){this.x=e,this.y=t},numeric.t=function(e,t){return new numeric.T(e,t)},numeric.Tbinop=function(e,t,n,r,o){var a;numeric.indexOf;if("string"!=typeof o)for(a in o="",numeric)numeric.hasOwnProperty(a)&&(e.indexOf(a)>=0||t.indexOf(a)>=0||n.indexOf(a)>=0||r.indexOf(a)>=0)&&a.length>1&&(o+="var "+a+" = numeric."+a+";\n");return Function(["y"],"var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n"+o+"\nif(x.y) {  if(y.y) {    return new numeric.T("+r+");\n  }\n  return new numeric.T("+n+");\n}\nif(y.y) {\n  return new numeric.T("+t+");\n}\nreturn new numeric.T("+e+");\n")},numeric.T.prototype.add=numeric.Tbinop("add(x.x,y.x)","add(x.x,y.x),y.y","add(x.x,y.x),x.y","add(x.x,y.x),add(x.y,y.y)"),numeric.T.prototype.sub=numeric.Tbinop("sub(x.x,y.x)","sub(x.x,y.x),neg(y.y)","sub(x.x,y.x),x.y","sub(x.x,y.x),sub(x.y,y.y)"),numeric.T.prototype.mul=numeric.Tbinop("mul(x.x,y.x)","mul(x.x,y.x),mul(x.x,y.y)","mul(x.x,y.x),mul(x.y,y.x)","sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))"),numeric.T.prototype.reciprocal=function(){var e=numeric.mul,t=numeric.div;if(this.y){var n=numeric.add(e(this.x,this.x),e(this.y,this.y));return new numeric.T(t(this.x,n),t(numeric.neg(this.y),n))}return new T(t(1,this.x))},numeric.T.prototype.div=function(e){if(e instanceof numeric.T||(e=new numeric.T(e)),e.y)return this.mul(e.reciprocal());var t=numeric.div;return this.y?new numeric.T(t(this.x,e.x),t(this.y,e.x)):new numeric.T(t(this.x,e.x))},numeric.T.prototype.dot=numeric.Tbinop("dot(x.x,y.x)","dot(x.x,y.x),dot(x.x,y.y)","dot(x.x,y.x),dot(x.y,y.x)","sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))"),numeric.T.prototype.transpose=function(){var e=numeric.transpose,t=this.x,n=this.y;return n?new numeric.T(e(t),e(n)):new numeric.T(e(t))},numeric.T.prototype.transjugate=function(){var e=numeric.transpose,t=this.x,n=this.y;return n?new numeric.T(e(t),numeric.negtranspose(n)):new numeric.T(e(t))},numeric.Tunop=function(e,t,n){return"string"!=typeof n&&(n=""),Function("var x = this;\n"+n+"\nif(x.y) {  "+t+";\n}\n"+e+";\n")},numeric.T.prototype.exp=numeric.Tunop("return new numeric.T(ex)","return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))","var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;"),numeric.T.prototype.conj=numeric.Tunop("return new numeric.T(x.x);","return new numeric.T(x.x,numeric.neg(x.y));"),numeric.T.prototype.neg=numeric.Tunop("return new numeric.T(neg(x.x));","return new numeric.T(neg(x.x),neg(x.y));","var neg = numeric.neg;"),numeric.T.prototype.sin=numeric.Tunop("return new numeric.T(numeric.sin(x.x))","return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));"),numeric.T.prototype.cos=numeric.Tunop("return new numeric.T(numeric.cos(x.x))","return x.exp().add(x.neg().exp()).div(2);"),numeric.T.prototype.abs=numeric.Tunop("return new numeric.T(numeric.abs(x.x));","return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));","var mul = numeric.mul;"),numeric.T.prototype.log=numeric.Tunop("return new numeric.T(numeric.log(x.x));","var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);"),numeric.T.prototype.norm2=numeric.Tunop("return numeric.norm2(x.x);","var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));"),numeric.T.prototype.inv=function(){var e=this;if(void 0===e.y)return new numeric.T(numeric.inv(e.x));var t,n,r,o,a,i,s,l,c,f,u,d,p,h,v,m,x,g,y=e.x.length,E=numeric.identity(y),w=numeric.rep([y,y],0),b=numeric.clone(e.x),_=numeric.clone(e.y);for(c=0;c<y;c++){for(d=(h=b[c][c])*h+(v=_[c][c])*v,u=c,f=c+1;f<y;f++)(p=(h=b[f][c])*h+(v=_[f][c])*v)>d&&(u=f,d=p);for(u!==c&&(g=b[c],b[c]=b[u],b[u]=g,g=_[c],_[c]=_[u],_[u]=g,g=E[c],E[c]=E[u],E[u]=g,g=w[c],w[c]=w[u],w[u]=g),t=b[c],n=_[c],a=E[c],i=w[c],h=t[c],v=n[c],f=c+1;f<y;f++)m=t[f],x=n[f],t[f]=(m*h+x*v)/d,n[f]=(x*h-m*v)/d;for(f=0;f<y;f++)m=a[f],x=i[f],a[f]=(m*h+x*v)/d,i[f]=(x*h-m*v)/d;for(f=c+1;f<y;f++){for(r=b[f],o=_[f],s=E[f],l=w[f],h=r[c],v=o[c],u=c+1;u<y;u++)m=t[u],x=n[u],r[u]-=m*h-x*v,o[u]-=x*h+m*v;for(u=0;u<y;u++)m=a[u],x=i[u],s[u]-=m*h-x*v,l[u]-=x*h+m*v}}for(c=y-1;c>0;c--)for(a=E[c],i=w[c],f=c-1;f>=0;f--)for(s=E[f],l=w[f],h=b[f][c],v=_[f][c],u=y-1;u>=0;u--)m=a[u],x=i[u],s[u]-=h*m-v*x,l[u]-=h*x+v*m;return new numeric.T(E,w)},numeric.T.prototype.get=function(e){var t,n=this.x,r=this.y,o=0,a=e.length;if(r){for(;o<a;)n=n[t=e[o]],r=r[t],o++;return new numeric.T(n,r)}for(;o<a;)n=n[t=e[o]],o++;return new numeric.T(n)},numeric.T.prototype.set=function(e,t){var n,r=this.x,o=this.y,a=0,i=e.length,s=t.x,l=t.y;if(0===i)return l?this.y=l:o&&(this.y=void 0),this.x=r,this;if(l){for(o||(o=numeric.rep(numeric.dim(r),0),this.y=o);a<i-1;)r=r[n=e[a]],o=o[n],a++;return r[n=e[a]]=s,o[n]=l,this}if(o){for(;a<i-1;)r=r[n=e[a]],o=o[n],a++;return r[n=e[a]]=s,o[n]=s instanceof Array?numeric.rep(numeric.dim(s),0):0,this}for(;a<i-1;)r=r[n=e[a]],a++;return r[n=e[a]]=s,this},numeric.T.prototype.getRows=function(e,t){var n,r,o=t-e+1,a=Array(o),i=this.x,s=this.y;for(n=e;n<=t;n++)a[n-e]=i[n];if(s){for(r=Array(o),n=e;n<=t;n++)r[n-e]=s[n];return new numeric.T(a,r)}return new numeric.T(a)},numeric.T.prototype.setRows=function(e,t,n){var r,o=this.x,a=this.y,i=n.x,s=n.y;for(r=e;r<=t;r++)o[r]=i[r-e];if(s)for(a||(a=numeric.rep(numeric.dim(o),0),this.y=a),r=e;r<=t;r++)a[r]=s[r-e];else if(a)for(r=e;r<=t;r++)a[r]=numeric.rep([i[r-e].length],0);return this},numeric.T.prototype.getRow=function(e){var t=this.x,n=this.y;return n?new numeric.T(t[e],n[e]):new numeric.T(t[e])},numeric.T.prototype.setRow=function(e,t){var n=this.x,r=this.y,o=t.x,a=t.y;return n[e]=o,a?(r||(r=numeric.rep(numeric.dim(n),0),this.y=r),r[e]=a):r&&(r=numeric.rep([o.length],0)),this},numeric.T.prototype.getBlock=function(e,t){var n=this.x,r=this.y,o=numeric.getBlock;return r?new numeric.T(o(n,e,t),o(r,e,t)):new numeric.T(o(n,e,t))},numeric.T.prototype.setBlock=function(e,t,n){n instanceof numeric.T||(n=new numeric.T(n));var r=this.x,o=this.y,a=numeric.setBlock,i=n.x,s=n.y;if(s)return o||(this.y=numeric.rep(numeric.dim(this),0),o=this.y),a(r,e,t,i),a(o,e,t,s),this;a(r,e,t,i),o&&a(o,e,t,numeric.rep(numeric.dim(i),0))},numeric.T.rep=function(e,t){var n=numeric.T;t instanceof n||(t=new n(t));var r=t.x,o=t.y,a=numeric.rep;return o?new n(a(e,r),a(e,o)):new n(a(e,r))},numeric.T.diag=function(e){e instanceof numeric.T||(e=new numeric.T(e));var t=e.x,n=e.y,r=numeric.diag;return n?new numeric.T(r(t),r(n)):new numeric.T(r(t))},numeric.T.eig=function(){if(this.y)throw new Error("eig: not implemented for complex matrices.");return numeric.eig(this.x)},numeric.T.identity=function(e){return new numeric.T(numeric.identity(e))},numeric.T.prototype.getDiag=function(){var e=numeric,t=this.x,n=this.y;return n?new e.T(e.getDiag(t),e.getDiag(n)):new e.T(e.getDiag(t))},numeric.house=function(e){var t=numeric.clone(e),n=(e[0]>=0?1:-1)*numeric.norm2(e);t[0]+=n;var r=numeric.norm2(t);if(0===r)throw new Error("eig: internal error");return numeric.div(t,r)},numeric.toUpperHessenberg=function(e){var t=numeric.dim(e);if(2!==t.length||t[0]!==t[1])throw new Error("numeric: toUpperHessenberg() only works on square matrices");var n,r,o,a,i,s,l,c,f,u,d=t[0],p=numeric.clone(e),h=numeric.identity(d);for(r=0;r<d-2;r++){for(a=Array(d-r-1),n=r+1;n<d;n++)a[n-r-1]=p[n][r];if(numeric.norm2(a)>0){for(i=numeric.house(a),s=numeric.getBlock(p,[r+1,r],[d-1,d-1]),l=numeric.tensor(i,numeric.dot(i,s)),n=r+1;n<d;n++)for(c=p[n],f=l[n-r-1],o=r;o<d;o++)c[o]-=2*f[o-r];for(s=numeric.getBlock(p,[0,r+1],[d-1,d-1]),l=numeric.tensor(numeric.dot(s,i),i),n=0;n<d;n++)for(c=p[n],f=l[n],o=r+1;o<d;o++)c[o]-=2*f[o-r-1];for(s=Array(d-r-1),n=r+1;n<d;n++)s[n-r-1]=h[n];for(l=numeric.tensor(i,numeric.dot(i,s)),n=r+1;n<d;n++)for(u=h[n],f=l[n-r-1],o=0;o<d;o++)u[o]-=2*f[o]}}return{H:p,Q:h}},numeric.epsilon=2220446049250313e-31,numeric.QRFrancis=function(e,t){void 0===t&&(t=1e4),e=numeric.clone(e);numeric.clone(e);var n,r,o,a,i,s,l,c,f,u,d,p,h,v,m,x,g,y,E=numeric.dim(e)[0],w=numeric.identity(E);if(E<3)return{Q:w,B:[[0,E-1]]};var b=numeric.epsilon;for(y=0;y<t;y++){for(x=0;x<E-1;x++)if(Math.abs(e[x+1][x])<b*(Math.abs(e[x][x])+Math.abs(e[x+1][x+1]))){var _=numeric.QRFrancis(numeric.getBlock(e,[0,0],[x,x]),t),T=numeric.QRFrancis(numeric.getBlock(e,[x+1,x+1],[E-1,E-1]),t);for(p=Array(x+1),m=0;m<=x;m++)p[m]=w[m];for(h=numeric.dot(_.Q,p),m=0;m<=x;m++)w[m]=h[m];for(p=Array(E-x-1),m=x+1;m<E;m++)p[m-x-1]=w[m];for(h=numeric.dot(T.Q,p),m=x+1;m<E;m++)w[m]=h[m-x-1];return{Q:w,B:_.B.concat(numeric.add(T.B,x+1))}}var A,S,R;if(o=e[E-2][E-2],a=e[E-2][E-1],i=e[E-1][E-2],c=o+(s=e[E-1][E-1]),l=o*s-a*i,f=numeric.getBlock(e,[0,0],[2,2]),c*c>=4*l)A=.5*(c+Math.sqrt(c*c-4*l)),S=.5*(c-Math.sqrt(c*c-4*l)),f=numeric.add(numeric.sub(numeric.dot(f,f),numeric.mul(f,A+S)),numeric.diag(numeric.rep([3],A*S)));else f=numeric.add(numeric.sub(numeric.dot(f,f),numeric.mul(f,c)),numeric.diag(numeric.rep([3],l)));for(n=[f[0][0],f[1][0],f[2][0]],r=numeric.house(n),p=[e[0],e[1],e[2]],h=numeric.tensor(r,numeric.dot(r,p)),m=0;m<3;m++)for(d=e[m],v=h[m],g=0;g<E;g++)d[g]-=2*v[g];for(p=numeric.getBlock(e,[0,0],[E-1,2]),h=numeric.tensor(numeric.dot(p,r),r),m=0;m<E;m++)for(d=e[m],v=h[m],g=0;g<3;g++)d[g]-=2*v[g];for(p=[w[0],w[1],w[2]],h=numeric.tensor(r,numeric.dot(r,p)),m=0;m<3;m++)for(u=w[m],v=h[m],g=0;g<E;g++)u[g]-=2*v[g];for(x=0;x<E-2;x++){for(g=x;g<=x+1;g++)if(Math.abs(e[g+1][g])<b*(Math.abs(e[g][g])+Math.abs(e[g+1][g+1]))){_=numeric.QRFrancis(numeric.getBlock(e,[0,0],[g,g]),t),T=numeric.QRFrancis(numeric.getBlock(e,[g+1,g+1],[E-1,E-1]),t);for(p=Array(g+1),m=0;m<=g;m++)p[m]=w[m];for(h=numeric.dot(_.Q,p),m=0;m<=g;m++)w[m]=h[m];for(p=Array(E-g-1),m=g+1;m<E;m++)p[m-g-1]=w[m];for(h=numeric.dot(T.Q,p),m=g+1;m<E;m++)w[m]=h[m-g-1];return{Q:w,B:_.B.concat(numeric.add(T.B,g+1))}}for(R=Math.min(E-1,x+3),n=Array(R-x),m=x+1;m<=R;m++)n[m-x-1]=e[m][x];for(r=numeric.house(n),p=numeric.getBlock(e,[x+1,x],[R,E-1]),h=numeric.tensor(r,numeric.dot(r,p)),m=x+1;m<=R;m++)for(d=e[m],v=h[m-x-1],g=x;g<E;g++)d[g]-=2*v[g-x];for(p=numeric.getBlock(e,[0,x+1],[E-1,R]),h=numeric.tensor(numeric.dot(p,r),r),m=0;m<E;m++)for(d=e[m],v=h[m],g=x+1;g<=R;g++)d[g]-=2*v[g-x-1];for(p=Array(R-x),m=x+1;m<=R;m++)p[m-x-1]=w[m];for(h=numeric.tensor(r,numeric.dot(r,p)),m=x+1;m<=R;m++)for(u=w[m],v=h[m-x-1],g=0;g<E;g++)u[g]-=2*v[g]}}throw new Error("numeric: eigenvalue iteration does not converge -- increase maxiter?")},numeric.eig=function(e,t){var n,r,o,a,i,s,l,c,f,u,d,p,h,v,m,x,g=numeric.toUpperHessenberg(e),y=numeric.QRFrancis(g.H,t),E=numeric.T,w=e.length,b=y.B,_=numeric.dot(y.Q,numeric.dot(g.H,numeric.transpose(y.Q))),T=new E(numeric.dot(y.Q,g.Q)),A=b.length,S=Math.sqrt;for(r=0;r<A;r++)if((n=b[r][0])===b[r][1]);else{if(a=n+1,i=_[n][n],s=_[n][a],l=_[a][n],c=_[a][a],0===s&&0===l)continue;(u=(f=-i-c)*f-4*(i*c-s*l))>=0?((m=(i-(d=f<0?-.5*(f-S(u)):-.5*(f+S(u))))*(i-d)+s*s)>(x=l*l+(c-d)*(c-d))?(h=(i-d)/(m=S(m)),v=s/m):(h=l/(x=S(x)),v=(c-d)/x),o=new E([[v,-h],[h,v]]),T.setRows(n,a,o.dot(T.getRows(n,a)))):(d=-.5*f,p=.5*S(-u),(m=(i-d)*(i-d)+s*s)>(x=l*l+(c-d)*(c-d))?(h=(i-d)/(m=S(m+p*p)),v=s/m,d=0,p/=m):(h=l/(x=S(x+p*p)),v=(c-d)/x,d=p/x,p=0),o=new E([[v,-h],[h,v]],[[d,p],[p,-d]]),T.setRows(n,a,o.dot(T.getRows(n,a))))}var R=T.dot(e).dot(T.transjugate()),M=(w=e.length,numeric.T.identity(w));for(a=0;a<w;a++)if(a>0)for(r=a-1;r>=0;r--){var C=R.get([r,r]),L=R.get([a,a]);numeric.neq(C.x,L.x)||numeric.neq(C.y,L.y)?(d=R.getRow(r).getBlock([r],[a-1]),p=M.getRow(a).getBlock([r],[a-1]),M.set([a,r],R.get([r,a]).neg().sub(d.dot(p)).div(C.sub(L)))):M.setRow(a,M.getRow(r))}for(a=0;a<w;a++)d=M.getRow(a),M.setRow(a,d.div(d.norm2()));return M=M.transpose(),M=T.transjugate().dot(M),{lambda:R.getDiag(),E:M}},numeric.ccsSparse=function(e){var t,n,r,o=e.length,a=[];for(n=o-1;-1!==n;--n)for(r in t=e[n]){for(r=parseInt(r);r>=a.length;)a[a.length]=0;0!==t[r]&&a[r]++}var i=a.length,s=Array(i+1);for(s[0]=0,n=0;n<i;++n)s[n+1]=s[n]+a[n];var l=Array(s[i]),c=Array(s[i]);for(n=o-1;-1!==n;--n)for(r in t=e[n])0!==t[r]&&(a[r]--,l[s[r]+a[r]]=n,c[s[r]+a[r]]=t[r]);return[s,l,c]},numeric.ccsFull=function(e){var t,n,r,o,a=e[0],i=e[1],s=e[2],l=numeric.ccsDim(e),c=l[0],f=l[1],u=numeric.rep([c,f],0);for(t=0;t<f;t++)for(r=a[t],o=a[t+1],n=r;n<o;++n)u[i[n]][t]=s[n];return u},numeric.ccsTSolve=function(e,t,n,r,o){var a,i,s,l,c,f,u,d=e[0],p=e[1],h=e[2],v=d.length-1,m=Math.max,x=0;function g(e){var t;if(0===n[e]){for(n[e]=1,t=d[e];t<d[e+1];++t)g(p[t]);o[x]=e,++x}}for(void 0===r&&(n=numeric.rep([v],0)),void 0===r&&(r=numeric.linspace(0,n.length-1)),void 0===o&&(o=[]),a=r.length-1;-1!==a;--a)g(r[a]);for(o.length=x,a=o.length-1;-1!==a;--a)n[o[a]]=0;for(a=r.length-1;-1!==a;--a)i=r[a],n[i]=t[i];for(a=o.length-1;-1!==a;--a){for(i=o[a],s=d[i],l=m(d[i+1],s),c=s;c!==l;++c)if(p[c]===i){n[i]/=h[c];break}for(u=n[i],c=s;c!==l;++c)(f=p[c])!==i&&(n[f]-=u*h[c])}return n},numeric.ccsDFS=function(e){this.k=Array(e),this.k1=Array(e),this.j=Array(e)},numeric.ccsDFS.prototype.dfs=function(e,t,n,r,o,a){var i,s,l,c=0,f=o.length,u=this.k,d=this.k1,p=this.j;if(0===r[e])for(r[e]=1,p[0]=e,u[0]=s=t[e],d[0]=l=t[e+1];;)if(s>=l){if(o[f]=p[c],0===c)return;++f,s=u[--c],l=d[c]}else 0===r[i=a[n[s]]]?(r[i]=1,u[c]=s,p[++c]=i,s=t[i],d[c]=l=t[i+1]):++s},numeric.ccsLPSolve=function(e,t,n,r,o,a,i){var s,l,c,f,u,d,p,h,v,m=e[0],x=e[1],g=e[2],y=(m.length,t[0]),E=t[1],w=t[2];for(l=y[o],c=y[o+1],r.length=0,s=l;s<c;++s)i.dfs(a[E[s]],m,x,n,r,a);for(s=r.length-1;-1!==s;--s)n[r[s]]=0;for(s=l;s!==c;++s)n[f=a[E[s]]]=w[s];for(s=r.length-1;-1!==s;--s){for(u=m[f=r[s]],d=m[f+1],p=u;p<d;++p)if(a[x[p]]===f){n[f]/=g[p];break}for(v=n[f],p=u;p<d;++p)(h=a[x[p]])!==f&&(n[h]-=v*g[p])}return n},numeric.ccsLUP1=function(e,t){var n,r,o,a,i,s,l,c=e[0].length-1,f=[numeric.rep([c+1],0),[],[]],u=[numeric.rep([c+1],0),[],[]],d=f[0],p=f[1],h=f[2],v=u[0],m=u[1],x=u[2],g=numeric.rep([c],0),y=numeric.rep([c],0),E=numeric.ccsLPSolve,w=(Math.max,Math.abs),b=numeric.linspace(0,c-1),_=numeric.linspace(0,c-1),T=new numeric.ccsDFS(c);for(void 0===t&&(t=1),n=0;n<c;++n){for(E(f,e,g,y,n,_,T),a=-1,i=-1,r=y.length-1;-1!==r;--r)(o=y[r])<=n||(s=w(g[o]))>a&&(i=o,a=s);for(w(g[n])<t*a&&(r=b[n],a=b[i],b[n]=a,_[a]=n,b[i]=r,_[r]=i,a=g[n],g[n]=g[i],g[i]=a),a=d[n],i=v[n],l=g[n],p[a]=b[n],h[a]=1,++a,r=y.length-1;-1!==r;--r)s=g[o=y[r]],y[r]=0,g[o]=0,o<=n?(m[i]=o,x[i]=s,++i):(p[a]=b[o],h[a]=s/l,++a);d[n+1]=a,v[n+1]=i}for(r=p.length-1;-1!==r;--r)p[r]=_[p[r]];return{L:f,U:u,P:b,Pinv:_}},numeric.ccsDFS0=function(e){this.k=Array(e),this.k1=Array(e),this.j=Array(e)},numeric.ccsDFS0.prototype.dfs=function(e,t,n,r,o,a,i){var s,l,c,f=0,u=o.length,d=this.k,p=this.k1,h=this.j;if(0===r[e])for(r[e]=1,h[0]=e,d[0]=l=t[a[e]],p[0]=c=t[a[e]+1];;){if(isNaN(l))throw new Error("Ow!");if(l>=c){if(o[u]=a[h[f]],0===f)return;++u,l=d[--f],c=p[f]}else 0===r[s=n[l]]?(r[s]=1,d[f]=l,h[++f]=s,l=t[s=a[s]],p[f]=c=t[s+1]):++l}},numeric.ccsLPSolve0=function(e,t,n,r,o,a,i,s){var l,c,f,u,d,p,h,v,m,x=e[0],g=e[1],y=e[2],E=(x.length,t[0]),w=t[1],b=t[2];for(c=E[o],f=E[o+1],r.length=0,l=c;l<f;++l)s.dfs(w[l],x,g,n,r,a,i);for(l=r.length-1;-1!==l;--l)n[i[u=r[l]]]=0;for(l=c;l!==f;++l)n[u=w[l]]=b[l];for(l=r.length-1;-1!==l;--l){for(v=i[u=r[l]],d=x[u],p=x[u+1],h=d;h<p;++h)if(g[h]===v){n[v]/=y[h];break}for(m=n[v],h=d;h<p;++h)n[g[h]]-=m*y[h];n[v]=m}},numeric.ccsLUP0=function(e,t){var n,r,o,a,i,s,l,c=e[0].length-1,f=[numeric.rep([c+1],0),[],[]],u=[numeric.rep([c+1],0),[],[]],d=f[0],p=f[1],h=f[2],v=u[0],m=u[1],x=u[2],g=numeric.rep([c],0),y=numeric.rep([c],0),E=numeric.ccsLPSolve0,w=(Math.max,Math.abs),b=numeric.linspace(0,c-1),_=numeric.linspace(0,c-1),T=new numeric.ccsDFS0(c);for(void 0===t&&(t=1),n=0;n<c;++n){for(E(f,e,g,y,n,_,b,T),a=-1,i=-1,r=y.length-1;-1!==r;--r)(o=y[r])<=n||(s=w(g[b[o]]))>a&&(i=o,a=s);for(w(g[b[n]])<t*a&&(r=b[n],a=b[i],b[n]=a,_[a]=n,b[i]=r,_[r]=i),a=d[n],i=v[n],l=g[b[n]],p[a]=b[n],h[a]=1,++a,r=y.length-1;-1!==r;--r)s=g[b[o=y[r]]],y[r]=0,g[b[o]]=0,o<=n?(m[i]=o,x[i]=s,++i):(p[a]=b[o],h[a]=s/l,++a);d[n+1]=a,v[n+1]=i}for(r=p.length-1;-1!==r;--r)p[r]=_[p[r]];return{L:f,U:u,P:b,Pinv:_}},numeric.ccsLUP=numeric.ccsLUP0,numeric.ccsDim=function(e){return[numeric.sup(e[1])+1,e[0].length-1]},numeric.ccsGetBlock=function(e,t,n){var r=numeric.ccsDim(e),o=r[0],a=r[1];void 0===t?t=numeric.linspace(0,o-1):"number"==typeof t&&(t=[t]),void 0===n?n=numeric.linspace(0,a-1):"number"==typeof n&&(n=[n]);var i,s,l,c,f=t.length,u=n.length,d=numeric.rep([a],0),p=[],h=[],v=[d,p,h],m=e[0],x=e[1],g=e[2],y=numeric.rep([o],0),E=0,w=numeric.rep([o],0);for(s=0;s<u;++s){var b=m[c=n[s]],_=m[c+1];for(i=b;i<_;++i)w[l=x[i]]=1,y[l]=g[i];for(i=0;i<f;++i)w[t[i]]&&(p[E]=i,h[E]=y[t[i]],++E);for(i=b;i<_;++i)w[l=x[i]]=0;d[s+1]=E}return v},numeric.ccsDot=function(e,t){var n,r,o,a,i,s,l,c,f,u,d,p=e[0],h=e[1],v=e[2],m=t[0],x=t[1],g=t[2],y=numeric.ccsDim(e),E=numeric.ccsDim(t),w=y[0],b=(y[1],E[1]),_=numeric.rep([w],0),T=numeric.rep([w],0),A=Array(w),S=numeric.rep([b],0),R=[],M=[],C=[S,R,M];for(o=0;o!==b;++o){for(a=m[o],i=m[o+1],f=0,r=a;r<i;++r)for(u=x[r],d=g[r],s=p[u],l=p[u+1],n=s;n<l;++n)0===T[c=h[n]]&&(A[f]=c,T[c]=1,f+=1),_[c]=_[c]+v[n]*d;for(i=(a=S[o])+f,S[o+1]=i,r=f-1;-1!==r;--r)d=a+r,n=A[r],R[d]=n,M[d]=_[n],T[n]=0,_[n]=0;S[o+1]=S[o]+f}return C},numeric.ccsLUPSolve=function(e,t){var n=e.L,r=e.U,o=(e.P,t[0]),a=!1;"object"!=typeof o&&(o=(t=[[0,t.length],numeric.linspace(0,t.length-1),t])[0],a=!0);var i,s,l,c,f,u,d=t[1],p=t[2],h=n[0].length-1,v=o.length-1,m=numeric.rep([h],0),x=Array(h),g=numeric.rep([h],0),y=Array(h),E=numeric.rep([v+1],0),w=[],b=[],_=numeric.ccsTSolve,T=0;for(i=0;i<v;++i){for(f=0,l=o[i],c=o[i+1],s=l;s<c;++s)u=e.Pinv[d[s]],y[f]=u,g[u]=p[s],++f;for(y.length=f,_(n,g,m,y,x),s=y.length-1;-1!==s;--s)g[y[s]]=0;if(_(r,m,g,x,y),a)return g;for(s=x.length-1;-1!==s;--s)m[x[s]]=0;for(s=y.length-1;-1!==s;--s)u=y[s],w[T]=u,b[T]=g[u],g[u]=0,++T;E[i+1]=T}return[E,w,b]},numeric.ccsbinop=function(e,t){return void 0===t&&(t=""),Function("X","Y","var Xi = X[0], Xj = X[1], Xv = X[2];\nvar Yi = Y[0], Yj = Y[1], Yv = Y[2];\nvar n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\nvar Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\nvar x = numeric.rep([m],0),y = numeric.rep([m],0);\nvar xk,yk,zk;\nvar i,j,j0,j1,k,p=0;\n"+t+"for(i=0;i<n;++i) {\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Xj[j];\n    x[k] = 1;\n    Zj[p] = k;\n    ++p;\n  }\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Yj[j];\n    y[k] = Yv[j];\n    if(x[k] === 0) {\n      Zj[p] = k;\n      ++p;\n    }\n  }\n  Zi[i+1] = p;\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n  j0 = Zi[i]; j1 = Zi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Zj[j];\n    xk = x[k];\n    yk = y[k];\n"+e+"\n    Zv[j] = zk;\n  }\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n}\nreturn [Zi,Zj,Zv];")},function(){var k,A,B,C;for(k in numeric.ops2)A=isFinite(eval("1"+numeric.ops2[k]+"0"))?"[Y[0],Y[1],numeric."+k+"(X,Y[2])]":"NaN",B=isFinite(eval("0"+numeric.ops2[k]+"1"))?"[X[0],X[1],numeric."+k+"(X[2],Y)]":"NaN",C=isFinite(eval("1"+numeric.ops2[k]+"0"))&&isFinite(eval("0"+numeric.ops2[k]+"1"))?"numeric.ccs"+k+"MM(X,Y)":"NaN",numeric["ccs"+k+"MM"]=numeric.ccsbinop("zk = xk "+numeric.ops2[k]+"yk;"),numeric["ccs"+k]=Function("X","Y",'if(typeof X === "number") return '+A+';\nif(typeof Y === "number") return '+B+";\nreturn "+C+";\n")}(),numeric.ccsScatter=function(e){var t,n=e[0],r=e[1],o=e[2],a=numeric.sup(r)+1,i=n.length,s=numeric.rep([a],0),l=Array(i),c=Array(i),f=numeric.rep([a],0);for(t=0;t<i;++t)f[r[t]]++;for(t=0;t<a;++t)s[t+1]=s[t]+f[t];var u,d,p=s.slice(0);for(t=0;t<i;++t)l[u=p[d=r[t]]]=n[t],c[u]=o[t],p[d]=p[d]+1;return[s,l,c]},numeric.ccsGather=function(e){var t,n,r,o,a,i=e[0],s=e[1],l=e[2],c=i.length-1,f=s.length,u=Array(f),d=Array(f),p=Array(f);for(a=0,t=0;t<c;++t)for(r=i[t],o=i[t+1],n=r;n!==o;++n)d[a]=t,u[a]=s[n],p[a]=l[n],++a;return[u,d,p]},numeric.sdim=function e(t,n,r){if(void 0===n&&(n=[]),"object"!=typeof t)return n;var o;for(o in void 0===r&&(r=0),r in n||(n[r]=0),t.length>n[r]&&(n[r]=t.length),t)t.hasOwnProperty(o)&&e(t[o],n,r+1);return n},numeric.sclone=function e(t,n,r){void 0===n&&(n=0),void 0===r&&(r=numeric.sdim(t).length);var o,a=Array(t.length);if(n===r-1){for(o in t)t.hasOwnProperty(o)&&(a[o]=t[o]);return a}for(o in t)t.hasOwnProperty(o)&&(a[o]=e(t[o],n+1,r));return a},numeric.sdiag=function(e){var t,n,r=e.length,o=Array(r);for(t=r-1;t>=1;t-=2)n=t-1,o[t]=[],o[t][t]=e[t],o[n]=[],o[n][n]=e[n];return 0===t&&(o[0]=[],o[0][0]=e[t]),o},numeric.sidentity=function(e){return numeric.sdiag(numeric.rep([e],1))},numeric.stranspose=function(e){var t,n,r,o=[];e.length;for(t in e)if(e.hasOwnProperty(t))for(n in r=e[t])r.hasOwnProperty(n)&&("object"!=typeof o[n]&&(o[n]=[]),o[n][t]=r[n]);return o},numeric.sLUP=function(e,t){throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.")},numeric.sdotMM=function(e,t){var n,r,o,a,i,s,l,c=e.length,f=(t.length,numeric.stranspose(t)),u=f.length,d=Array(c);for(o=c-1;o>=0;o--){for(l=[],n=e[o],i=u-1;i>=0;i--){for(a in s=0,r=f[i],n)n.hasOwnProperty(a)&&a in r&&(s+=n[a]*r[a]);s&&(l[i]=s)}d[o]=l}return d},numeric.sdotMV=function(e,t){var n,r,o,a,i=e.length,s=Array(i);for(r=i-1;r>=0;r--){for(o in a=0,n=e[r])n.hasOwnProperty(o)&&t[o]&&(a+=n[o]*t[o]);a&&(s[r]=a)}return s},numeric.sdotVM=function(e,t){var n,r,o,a,i=[];for(n in e)if(e.hasOwnProperty(n))for(r in o=t[n],a=e[n],o)o.hasOwnProperty(r)&&(i[r]||(i[r]=0),i[r]+=a*o[r]);return i},numeric.sdotVV=function(e,t){var n,r=0;for(n in e)e[n]&&t[n]&&(r+=e[n]*t[n]);return r},numeric.sdot=function(e,t){var n=numeric.sdim(e).length,r=numeric.sdim(t).length;switch(1e3*n+r){case 0:return e*t;case 1001:return numeric.sdotVV(e,t);case 2001:return numeric.sdotMV(e,t);case 1002:return numeric.sdotVM(e,t);case 2002:return numeric.sdotMM(e,t);default:throw new Error("numeric.sdot not implemented for tensors of order "+n+" and "+r)}},numeric.sscatter=function(e){var t,n,r,o,a=e[0].length,i=e.length,s=[];for(n=a-1;n>=0;--n)if(e[i-1][n]){for(o=s,r=0;r<i-2;r++)o[t=e[r][n]]||(o[t]=[]),o=o[t];o[e[r][n]]=e[r+1][n]}return s},numeric.sgather=function e(t,n,r){var o,a,i;for(a in void 0===n&&(n=[]),void 0===r&&(r=[]),o=r.length,t)if(t.hasOwnProperty(a))if(r[o]=parseInt(a),"number"==typeof(i=t[a])){if(i){if(0===n.length)for(a=o+1;a>=0;--a)n[a]=[];for(a=o;a>=0;--a)n[a].push(r[a]);n[o+1].push(i)}}else e(i,n,r);return r.length>o&&r.pop(),n},numeric.cLU=function(e){var t,n,r,o,a,i,s=e[0],l=e[1],c=e[2],f=s.length,u=0;for(t=0;t<f;t++)s[t]>u&&(u=s[t]);u++;var d,p=Array(u),h=Array(u),v=numeric.rep([u],1/0),m=numeric.rep([u],-1/0);for(r=0;r<f;r++)t=s[r],(n=l[r])<v[t]&&(v[t]=n),n>m[t]&&(m[t]=n);for(t=0;t<u-1;t++)m[t]>m[t+1]&&(m[t+1]=m[t]);for(t=u-1;t>=1;t--)v[t]<v[t-1]&&(v[t-1]=v[t]);for(t=0;t<u;t++)h[t]=numeric.rep([m[t]-v[t]+1],0),p[t]=numeric.rep([t-v[t]],0),t-v[t]+1,m[t]-t+1;for(r=0;r<f;r++)h[t=s[r]][l[r]-v[t]]=c[r];for(t=0;t<u-1;t++)for(o=t-v[t],y=h[t],n=t+1;v[n]<=t&&n<u;n++)if(a=t-v[n],i=m[t]-t,d=(E=h[n])[a]/y[o]){for(r=1;r<=i;r++)E[r+a]-=d*y[r+o];p[n][t-v[n]]=d}var x,g,y=[],E=[],w=[],b=[],_=[],T=[];for(f=0,x=0,t=0;t<u;t++){for(o=v[t],a=m[t],g=h[t],n=t;n<=a;n++)g[n-o]&&(y[f]=t,E[f]=n,w[f]=g[n-o],f++);for(g=p[t],n=o;n<t;n++)g[n-o]&&(b[x]=t,_[x]=n,T[x]=g[n-o],x++);b[x]=t,_[x]=t,T[x]=1,x++}return{U:[y,E,w],L:[b,_,T]}},numeric.cLUsolve=function(e,t){var n,r,o=e.L,a=e.U,i=numeric.clone(t),s=o[0],l=o[1],c=o[2],f=a[0],u=a[1],d=a[2],p=f.length,h=(s.length,i.length);for(r=0,n=0;n<h;n++){for(;l[r]<n;)i[n]-=c[r]*i[l[r]],r++;r++}for(r=p-1,n=h-1;n>=0;n--){for(;u[r]>n;)i[n]-=d[r]*i[u[r]],r--;i[n]/=d[r],r--}return i},numeric.cgrid=function(e,t){"number"==typeof e&&(e=[e,e]);var n,r,o,a=numeric.rep(e,-1);if("function"!=typeof t)switch(t){case"L":t=function(t,n){return t>=e[0]/2||n<e[1]/2};break;default:t=function(e,t){return!0}}for(o=0,n=1;n<e[0]-1;n++)for(r=1;r<e[1]-1;r++)t(n,r)&&(a[n][r]=o,o++);return a},numeric.cdelsq=function(e){var t,n,r,o,a,i=[[-1,0],[0,-1],[0,1],[1,0]],s=numeric.dim(e),l=s[0],c=s[1],f=[],u=[],d=[];for(t=1;t<l-1;t++)for(n=1;n<c-1;n++)if(!(e[t][n]<0)){for(r=0;r<4;r++)o=t+i[r][0],a=n+i[r][1],e[o][a]<0||(f.push(e[t][n]),u.push(e[o][a]),d.push(-1));f.push(e[t][n]),u.push(e[t][n]),d.push(4)}return[f,u,d]},numeric.cdotMV=function(e,t){var n,r,o,a=e[0],i=e[1],s=e[2],l=a.length;for(o=0,r=0;r<l;r++)a[r]>o&&(o=a[r]);for(o++,n=numeric.rep([o],0),r=0;r<l;r++)n[a[r]]+=s[r]*t[i[r]];return n},numeric.Spline=function(e,t,n,r,o){this.x=e,this.yl=t,this.yr=n,this.kl=r,this.kr=o},numeric.Spline.prototype._at=function(e,t){var n,r,o,a=this.x,i=this.yl,s=this.yr,l=this.kl,c=this.kr,f=numeric.add,u=numeric.sub,d=numeric.mul;n=u(d(l[t],a[t+1]-a[t]),u(s[t+1],i[t])),r=f(d(c[t+1],a[t]-a[t+1]),u(s[t+1],i[t]));var p=(o=(e-a[t])/(a[t+1]-a[t]))*(1-o);return f(f(f(d(1-o,i[t]),d(o,s[t+1])),d(n,p*(1-o))),d(r,p*o))},numeric.Spline.prototype.at=function(e){if("number"==typeof e){var t,n,r,o=this.x,a=o.length,i=Math.floor;for(t=0,n=a-1;n-t>1;)o[r=i((t+n)/2)]<=e?t=r:n=r;return this._at(e,t)}a=e.length;var s,l=Array(a);for(s=a-1;-1!==s;--s)l[s]=this.at(e[s]);return l},numeric.Spline.prototype.diff=function(){var e,t,n,r=this.x,o=this.yl,a=this.yr,i=this.kl,s=this.kr,l=o.length,c=i,f=s,u=Array(l),d=Array(l),p=numeric.add,h=numeric.mul,v=numeric.div,m=numeric.sub;for(e=l-1;-1!==e;--e)t=r[e+1]-r[e],n=m(a[e+1],o[e]),u[e]=v(p(h(n,6),h(i[e],-4*t),h(s[e+1],-2*t)),t*t),d[e+1]=v(p(h(n,-6),h(i[e],2*t),h(s[e+1],4*t)),t*t);return new numeric.Spline(r,c,f,u,d)},numeric.Spline.prototype.roots=function(){function e(e){return e*e}var t=[],n=this.x,r=this.yl,o=this.yr,a=this.kl,i=this.kr;"number"==typeof r[0]&&(r=[r],o=[o],a=[a],i=[i]);var s,l,c,f,u,d,p,h,v,m,x,g,y,E,w,b,_,T,A,S,R,M,C,L=r.length,P=n.length-1,k=(t=Array(L),Math.sqrt);for(s=0;s!==L;++s){for(f=r[s],u=o[s],d=a[s],p=i[s],h=[],l=0;l!==P;l++){for(l>0&&u[l]*f[l]<0&&h.push(n[l]),b=n[l+1]-n[l],n[l],x=f[l],g=u[l+1],v=d[l]/b,y=(m=p[l+1]/b)+3*x+2*v-3*g,E=3*(m+v+2*(x-g)),(w=e(v-m+3*(x-g))+12*m*x)<=0?_=(T=y/E)>n[l]&&T<n[l+1]?[n[l],T,n[l+1]]:[n[l],n[l+1]]:(T=(y-k(w))/E,A=(y+k(w))/E,_=[n[l]],T>n[l]&&T<n[l+1]&&_.push(T),A>n[l]&&A<n[l+1]&&_.push(A),_.push(n[l+1])),R=_[0],T=this._at(R,l),c=0;c<_.length-1;c++)if(M=_[c+1],A=this._at(M,l),0!==T)if(0===A||T*A>0)R=M,T=A;else{for(var N=0;!((C=(T*M-A*R)/(T-A))<=R||C>=M);)if((S=this._at(C,l))*A>0)M=C,A=S,-1===N&&(T*=.5),N=-1;else{if(!(S*T>0))break;R=C,T=S,1===N&&(A*=.5),N=1}h.push(C),R=_[c+1],T=this._at(R,l)}else h.push(R),R=M,T=A;0===A&&h.push(M)}t[s]=h}return"number"==typeof this.yl[0]?t[0]:t},numeric.spline=function(e,t,n,r){var o,a=e.length,i=[],s=[],l=[],c=numeric.sub,f=numeric.mul,u=numeric.add;for(o=a-2;o>=0;o--)s[o]=e[o+1]-e[o],l[o]=c(t[o+1],t[o]);"string"!=typeof n&&"string"!=typeof r||(n=r="periodic");var d=[[],[],[]];switch(typeof n){case"undefined":i[0]=f(3/(s[0]*s[0]),l[0]),d[0].push(0,0),d[1].push(0,1),d[2].push(2/s[0],1/s[0]);break;case"string":i[0]=u(f(3/(s[a-2]*s[a-2]),l[a-2]),f(3/(s[0]*s[0]),l[0])),d[0].push(0,0,0),d[1].push(a-2,0,1),d[2].push(1/s[a-2],2/s[a-2]+2/s[0],1/s[0]);break;default:i[0]=n,d[0].push(0),d[1].push(0),d[2].push(1)}for(o=1;o<a-1;o++)i[o]=u(f(3/(s[o-1]*s[o-1]),l[o-1]),f(3/(s[o]*s[o]),l[o])),d[0].push(o,o,o),d[1].push(o-1,o,o+1),d[2].push(1/s[o-1],2/s[o-1]+2/s[o],1/s[o]);switch(typeof r){case"undefined":i[a-1]=f(3/(s[a-2]*s[a-2]),l[a-2]),d[0].push(a-1,a-1),d[1].push(a-2,a-1),d[2].push(1/s[a-2],2/s[a-2]);break;case"string":d[1][d[1].length-1]=0;break;default:i[a-1]=r,d[0].push(a-1),d[1].push(a-1),d[2].push(1)}i="number"!=typeof i[0]?numeric.transpose(i):[i];var p=Array(i.length);if("string"==typeof n)for(o=p.length-1;-1!==o;--o)p[o]=numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(d)),i[o]),p[o][a-1]=p[o][0];else for(o=p.length-1;-1!==o;--o)p[o]=numeric.cLUsolve(numeric.cLU(d),i[o]);return p="number"==typeof t[0]?p[0]:numeric.transpose(p),new numeric.Spline(e,t,t,p,p)},numeric.fftpow2=function e(t,n){var r=t.length;if(1!==r){var o,a,i=Math.cos,s=Math.sin,l=Array(r/2),c=Array(r/2),f=Array(r/2),u=Array(r/2);for(a=r/2,o=r-1;-1!==o;--o)f[--a]=t[o],u[a]=n[o],--o,l[a]=t[o],c[a]=n[o];e(l,c),e(f,u),a=r/2;var d,p,h,v=-6.283185307179586/r;for(o=r-1;-1!==o;--o)-1===--a&&(a=r/2-1),p=i(d=v*o),h=s(d),t[o]=l[a]+p*f[a]-h*u[a],n[o]=c[a]+p*u[a]+h*f[a]}},numeric._ifftpow2=function e(t,n){var r=t.length;if(1!==r){var o,a,i=Math.cos,s=Math.sin,l=Array(r/2),c=Array(r/2),f=Array(r/2),u=Array(r/2);for(a=r/2,o=r-1;-1!==o;--o)f[--a]=t[o],u[a]=n[o],--o,l[a]=t[o],c[a]=n[o];e(l,c),e(f,u),a=r/2;var d,p,h,v=6.283185307179586/r;for(o=r-1;-1!==o;--o)-1===--a&&(a=r/2-1),p=i(d=v*o),h=s(d),t[o]=l[a]+p*f[a]-h*u[a],n[o]=c[a]+p*u[a]+h*f[a]}},numeric.ifftpow2=function(e,t){numeric._ifftpow2(e,t),numeric.diveq(e,e.length),numeric.diveq(t,t.length)},numeric.convpow2=function(e,t,n,r){var o,a,i,s,l;for(numeric.fftpow2(e,t),numeric.fftpow2(n,r),o=e.length-1;-1!==o;--o)a=e[o],s=t[o],i=n[o],l=r[o],e[o]=a*i-s*l,t[o]=a*l+s*i;numeric.ifftpow2(e,t)},numeric.T.prototype.fft=function(){var e,t,n=this.x,r=this.y,o=n.length,a=Math.log,i=a(2),s=Math.ceil(a(2*o-1)/i),l=Math.pow(2,s),c=numeric.rep([l],0),f=numeric.rep([l],0),u=Math.cos,d=Math.sin,p=-3.141592653589793/o,h=numeric.rep([l],0),v=numeric.rep([l],0);Math.floor(o/2);for(e=0;e<o;e++)h[e]=n[e];if(void 0!==r)for(e=0;e<o;e++)v[e]=r[e];for(c[0]=1,e=1;e<=l/2;e++)t=p*e*e,c[e]=u(t),f[e]=d(t),c[l-e]=u(t),f[l-e]=d(t);var m=new numeric.T(h,v),x=new numeric.T(c,f);return m=m.mul(x),numeric.convpow2(m.x,m.y,numeric.clone(x.x),numeric.neg(x.y)),(m=m.mul(x)).x.length=o,m.y.length=o,m},numeric.T.prototype.ifft=function(){var e,t,n=this.x,r=this.y,o=n.length,a=Math.log,i=a(2),s=Math.ceil(a(2*o-1)/i),l=Math.pow(2,s),c=numeric.rep([l],0),f=numeric.rep([l],0),u=Math.cos,d=Math.sin,p=3.141592653589793/o,h=numeric.rep([l],0),v=numeric.rep([l],0);Math.floor(o/2);for(e=0;e<o;e++)h[e]=n[e];if(void 0!==r)for(e=0;e<o;e++)v[e]=r[e];for(c[0]=1,e=1;e<=l/2;e++)t=p*e*e,c[e]=u(t),f[e]=d(t),c[l-e]=u(t),f[l-e]=d(t);var m=new numeric.T(h,v),x=new numeric.T(c,f);return m=m.mul(x),numeric.convpow2(m.x,m.y,numeric.clone(x.x),numeric.neg(x.y)),(m=m.mul(x)).x.length=o,m.y.length=o,m.div(o)},numeric.gradient=function(e,t){var n=t.length,r=e(t);if(isNaN(r))throw new Error("gradient: f(x) is a NaN!");var o,a,i,s,l,c,f,u,d,p=Math.max,h=numeric.clone(t),v=Array(n),m=(numeric.div,numeric.sub,p=Math.max,Math.abs),x=Math.min,g=0;for(o=0;o<n;o++)for(var y=p(1e-6*r,1e-8);;){if(++g>20)throw new Error("Numerical gradient fails");if(h[o]=t[o]+y,a=e(h),h[o]=t[o]-y,i=e(h),h[o]=t[o],isNaN(a)||isNaN(i))y/=16;else{if(v[o]=(a-i)/(2*y),s=t[o]-y,l=t[o],c=t[o]+y,f=(a-r)/y,u=(r-i)/y,d=p(m(v[o]),m(r),m(a),m(i),m(s),m(l),m(c),1e-8),!(x(p(m(f-v[o]),m(u-v[o]),m(f-u))/d,y/d)>.001))break;y/=16}}return v},numeric.uncmin=function(e,t,n,r,o,a,i){var s=numeric.gradient;void 0===i&&(i={}),void 0===n&&(n=1e-8),void 0===r&&(r=function(t){return s(e,t)}),void 0===o&&(o=1e3);var l,c,f=(t=numeric.clone(t)).length,u=e(t);if(isNaN(u))throw new Error("uncmin: f(x0) is a NaN!");var d=Math.max,p=numeric.norm2;n=d(n,numeric.epsilon);var h,v,m,x,g,y,E,w,b,_,T=i.Hinv||numeric.identity(f),A=numeric.dot,S=(numeric.inv,numeric.sub),R=numeric.add,M=numeric.tensor,C=numeric.div,L=numeric.mul,P=numeric.all,k=numeric.isFinite,N=numeric.neg,H=0,z="";for(v=r(t);H<o;){if("function"==typeof a&&a(H,t,u,v,T)){z="Callback returned true";break}if(!P(k(v))){z="Gradient has Infinity or NaN";break}if(!P(k(h=N(A(T,v))))){z="Search direction has Infinity or NaN";break}if((_=p(h))<n){z="Newton step smaller than tol";break}for(b=1,c=A(v,h),g=t;H<o&&!(b*_<n)&&(g=R(t,x=L(h,b)),(l=e(g))-u>=.1*b*c||isNaN(l));)b*=.5,++H;if(b*_<n){z="Line search step size smaller than tol";break}if(H===o){z="maxit reached during line search";break}w=A(y=S(m=r(g),v),x),E=A(T,y),T=S(R(T,L((w+A(y,E))/(w*w),M(x,x))),C(R(M(E,x),M(x,E)),w)),t=g,u=l,v=m,++H}return{solution:t,f:u,gradient:v,invHessian:T,iterations:H,message:z}},numeric.Dopri=function(e,t,n,r,o,a,i){this.x=e,this.y=t,this.f=n,this.ymid=r,this.iterations=o,this.events=i,this.message=a},numeric.Dopri.prototype._at=function(e,t){function n(e){return e*e}var r,o,a,i,s,l,c,f,u,d=this,p=d.x,h=d.y,v=d.f,m=d.ymid,x=(p.length,Math.floor,numeric.add),g=numeric.mul,y=numeric.sub;return r=p[t],o=p[t+1],i=h[t],s=h[t+1],a=r+.5*(o-r),l=m[t],c=y(v[t],g(i,1/(r-a)+2/(r-o))),f=y(v[t+1],g(s,1/(o-a)+2/(o-r))),x(x(x(x(g(i,(u=[n(e-o)*(e-a)/n(r-o)/(r-a),n(e-r)*n(e-o)/n(r-a)/n(o-a),n(e-r)*(e-a)/n(o-r)/(o-a),(e-r)*n(e-o)*(e-a)/n(r-o)/(r-a),(e-o)*n(e-r)*(e-a)/n(r-o)/(o-a)])[0]),g(l,u[1])),g(s,u[2])),g(c,u[3])),g(f,u[4]))},numeric.Dopri.prototype.at=function(e){var t,n,r,o=Math.floor;if("number"!=typeof e){var a=e.length,i=Array(a);for(t=a-1;-1!==t;--t)i[t]=this.at(e[t]);return i}var s=this.x;for(t=0,n=s.length-1;n-t>1;)s[r=o(.5*(t+n))]<=e?t=r:n=r;return this._at(e,t)},numeric.dopri=function(e,t,n,r,o,a,i){void 0===o&&(o=1e-6),void 0===a&&(a=1e3);var s,l,c,f,u,d,p,h,v,m,x,g,y,E=[e],w=[n],b=[r(e,n)],_=[],T=[3/40,9/40],A=[44/45,-56/15,32/9],S=[19372/6561,-25360/2187,64448/6561,-212/729],R=[9017/3168,-355/33,46732/5247,49/176,-5103/18656],M=[35/384,0,500/1113,125/192,-2187/6784,11/84],C=[.10013431883002395,0,.3918321794184259,-.02982460176594817,.05893268337240795,-.04497888809104361,5618549.5/235043384],L=[.2,.3,.8,8/9,1,1],P=[-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40],k=0,N=(t-e)/10,H=0,z=numeric.add,D=numeric.mul,F=(Math.max,Math.min),I=Math.abs,O=numeric.norminf,U=Math.pow,G=numeric.any,B=numeric.lt,V=numeric.and,W=(numeric.sub,new numeric.Dopri(E,w,b,_,-1,""));for("function"==typeof i&&(x=i(e,n));e<t&&H<a;)if(++H,e+N>t&&(N=t-e),s=r(e+L[0]*N,z(n,D(.2*N,b[k]))),l=r(e+L[1]*N,z(z(n,D(T[0]*N,b[k])),D(T[1]*N,s))),c=r(e+L[2]*N,z(z(z(n,D(A[0]*N,b[k])),D(A[1]*N,s)),D(A[2]*N,l))),f=r(e+L[3]*N,z(z(z(z(n,D(S[0]*N,b[k])),D(S[1]*N,s)),D(S[2]*N,l)),D(S[3]*N,c))),u=r(e+L[4]*N,z(z(z(z(z(n,D(R[0]*N,b[k])),D(R[1]*N,s)),D(R[2]*N,l)),D(R[3]*N,c)),D(R[4]*N,f))),d=r(e+N,v=z(z(z(z(z(n,D(b[k],N*M[0])),D(l,N*M[2])),D(c,N*M[3])),D(f,N*M[4])),D(u,N*M[5]))),(m="number"==typeof(p=z(z(z(z(z(D(b[k],N*P[0]),D(l,N*P[2])),D(c,N*P[3])),D(f,N*P[4])),D(u,N*P[5])),D(d,N*P[6])))?I(p):O(p))>o){if(e+(N=.2*N*U(o/m,.25))===e){W.msg="Step size became too small";break}}else{if(_[k]=z(z(z(z(z(z(n,D(b[k],N*C[0])),D(l,N*C[2])),D(c,N*C[3])),D(f,N*C[4])),D(u,N*C[5])),D(d,N*C[6])),E[++k]=e+N,w[k]=v,b[k]=d,"function"==typeof i){var j,q,X=e,Y=e+.5*N;if(g=i(Y,_[k-1]),G(y=V(B(x,0),B(0,g)))||(X=Y,x=g,g=i(Y=e+N,v),y=V(B(x,0),B(0,g))),G(y)){for(var Q,K,Z=0,J=1,$=1;;){if("number"==typeof x)q=($*g*X-J*x*Y)/($*g-J*x);else for(q=Y,h=x.length-1;-1!==h;--h)x[h]<0&&g[h]>0&&(q=F(q,($*g[h]*X-J*x[h]*Y)/($*g[h]-J*x[h])));if(q<=X||q>=Y)break;K=i(q,j=W._at(q,k-1)),G(Q=V(B(x,0),B(0,K)))?(Y=q,g=K,y=Q,$=1,-1===Z?J*=.5:J=1,Z=-1):(X=q,x=K,J=1,1===Z?$*=.5:$=1,Z=1)}return v=W._at(.5*(e+q),k-1),W.f[k]=r(q,j),W.x[k]=q,W.y[k]=j,W.ymid[k-1]=v,W.events=y,W.iterations=H,W}}e+=N,n=v,x=g,N=F(.8*N*U(o/m,.25),4*N)}return W.iterations=H,W},numeric.LU=function(e,t){t=t||!1;var n,r,o,a,i,s,l,c,f,u=Math.abs,d=e.length,p=d-1,h=new Array(d);for(t||(e=numeric.clone(e)),o=0;o<d;++o){for(l=o,f=u((s=e[o])[o]),r=o+1;r<d;++r)f<(a=u(e[r][o]))&&(f=a,l=r);for(h[o]=l,l!=o&&(e[o]=e[l],e[l]=s,s=e[o]),i=s[o],n=o+1;n<d;++n)e[n][o]/=i;for(n=o+1;n<d;++n){for(c=e[n],r=o+1;r<p;++r)c[r]-=c[o]*s[r],c[++r]-=c[o]*s[r];r===p&&(c[r]-=c[o]*s[r])}}return{LU:e,P:h}},numeric.LUsolve=function(e,t){var n,r,o,a,i,s=e.LU,l=s.length,c=numeric.clone(t),f=e.P;for(n=l-1;-1!==n;--n)c[n]=t[n];for(n=0;n<l;++n)for(o=f[n],f[n]!==n&&(i=c[n],c[n]=c[o],c[o]=i),a=s[n],r=0;r<n;++r)c[n]-=c[r]*a[r];for(n=l-1;n>=0;--n){for(a=s[n],r=n+1;r<l;++r)c[n]-=c[r]*a[r];c[n]/=a[n]}return c},numeric.solve=function(e,t,n){return numeric.LUsolve(numeric.LU(e,n),t)},numeric.echelonize=function(e){var t,n,r,o,a,i,s,l,c=numeric.dim(e),f=c[0],u=c[1],d=numeric.identity(f),p=Array(f),h=Math.abs,v=numeric.diveq;for(e=numeric.clone(e),t=0;t<f;++t){for(r=0,a=e[t],i=d[t],n=1;n<u;++n)h(a[r])<h(a[n])&&(r=n);for(p[t]=r,v(i,a[r]),v(a,a[r]),n=0;n<f;++n)if(n!==t){for(l=(s=e[n])[r],o=u-1;-1!==o;--o)s[o]-=a[o]*l;for(s=d[n],o=f-1;-1!==o;--o)s[o]-=i[o]*l}}return{I:d,A:e,P:p}},numeric.__solveLP=function(e,t,n,r,o,a,i){var s,l,c,f,u=numeric.sum,d=(numeric.log,numeric.mul),p=numeric.sub,h=numeric.dot,v=numeric.div,m=numeric.add,x=e.length,g=n.length,y=!1,E=1,w=(numeric.transpose(t),numeric.svd,numeric.transpose),b=(numeric.leq,Math.sqrt),_=Math.abs,T=(numeric.muleq,numeric.norminf,numeric.any,Math.min),A=numeric.all,S=numeric.gt,R=Array(x),M=Array(g),C=(numeric.rep([g],1),numeric.solve),L=p(n,h(t,a)),P=h(e,e);for(c=0;c<o;++c){var k,N;for(k=g-1;-1!==k;--k)M[k]=v(t[k],L[k]);var H=w(M);for(k=x-1;-1!==k;--k)R[k]=u(H[k]);E=.25*_(P/h(e,R));var z=100*b(P/h(R,R));for((!isFinite(E)||E>z)&&(E=z),f=m(e,d(E,R)),l=h(H,M),k=x-1;-1!==k;--k)l[k][k]+=1;N=C(l,v(f,E),!0);var D=v(L,h(t,N)),F=1;for(k=g-1;-1!==k;--k)D[k]<0&&(F=T(F,-.999*D[k]));if(s=p(a,d(N,F)),!A(S(L=p(n,h(t,s)),0)))return{solution:a,message:"",iterations:c};if(a=s,E<r)return{solution:s,message:"",iterations:c};if(i){var I=h(e,f),O=h(t,f);for(y=!0,k=g-1;-1!==k;--k)if(I*O[k]<0){y=!1;break}}else y=!(a[x-1]>=0);if(y)return{solution:s,message:"Unbounded",iterations:c}}return{solution:a,message:"maximum iteration count exceeded",iterations:c}},numeric._solveLP=function(e,t,n,r,o){var a=e.length,i=n.length,s=(numeric.sum,numeric.log,numeric.mul,numeric.sub),l=numeric.dot,c=(numeric.div,numeric.add,numeric.rep([a],0).concat([1])),f=numeric.rep([i,1],-1),u=numeric.blockMatrix([[t,f]]),d=n,p=numeric.rep([a],0).concat(Math.max(0,numeric.sup(numeric.neg(n)))+1),h=numeric.__solveLP(c,u,d,r,o,p,!1),v=numeric.clone(h.solution);if(v.length=a,numeric.inf(s(n,l(t,v)))<0)return{solution:NaN,message:"Infeasible",iterations:h.iterations};var m=numeric.__solveLP(e,t,n,r,o-h.iterations,v,!0);return m.iterations+=h.iterations,m},numeric.solveLP=function(e,t,n,r,o,a,i){if(void 0===i&&(i=1e3),void 0===a&&(a=numeric.epsilon),void 0===r)return numeric._solveLP(e,t,n,a,i);var s,l=r.length,c=r[0].length,f=t.length,u=numeric.echelonize(r),d=numeric.rep([c],0),p=u.P,h=[];for(s=p.length-1;-1!==s;--s)d[p[s]]=1;for(s=c-1;-1!==s;--s)0===d[s]&&h.push(s);var v=numeric.getRange,m=numeric.linspace(0,l-1),x=numeric.linspace(0,f-1),g=v(r,m,h),y=v(t,x,p),E=v(t,x,h),w=numeric.dot,b=numeric.sub,_=w(y,u.I),T=b(E,w(_,g)),A=b(n,w(_,o)),S=Array(p.length),R=Array(h.length);for(s=p.length-1;-1!==s;--s)S[s]=e[p[s]];for(s=h.length-1;-1!==s;--s)R[s]=e[h[s]];var M=b(R,w(S,w(u.I,g))),C=numeric._solveLP(M,T,A,a,i),L=C.solution;if(L!=L)return C;var P=w(u.I,b(o,w(g,L))),k=Array(e.length);for(s=p.length-1;-1!==s;--s)k[p[s]]=P[s];for(s=h.length-1;-1!==s;--s)k[h[s]]=L[s];return{solution:k,message:C.message,iterations:C.iterations}},numeric.MPStoLP=function(e){e instanceof String&&e.split("\n");var t,n,r,o,a=0,i=["Initial state","NAME","ROWS","COLUMNS","RHS","BOUNDS","ENDATA"],s=e.length,l=0,c={},f=[],u=0,d={},p=0,h=[],v=[],m=[];function x(n){throw new Error("MPStoLP: "+n+"\nLine "+t+": "+e[t]+"\nCurrent state: "+i[a]+"\n")}for(t=0;t<s;++t){var g=(r=e[t]).match(/\S*/g),y=[];for(n=0;n<g.length;++n)""!==g[n]&&y.push(g[n]);if(0!==y.length){for(n=0;n<i.length&&r.substr(0,i[n].length)!==i[n];++n);if(n<i.length){if(a=n,1===n&&(o=y[1]),6===n)return{name:o,c:h,A:numeric.transpose(v),b:m,rows:c,vars:d}}else switch(a){case 0:case 1:x("Unexpected line");case 2:switch(y[0]){case"N":0===l?l=y[1]:x("Two or more N rows");break;case"L":c[y[1]]=u,f[u]=1,m[u]=0,++u;break;case"G":c[y[1]]=u,f[u]=-1,m[u]=0,++u;break;case"E":c[y[1]]=u,f[u]=0,m[u]=0,++u;break;default:x("Parse error "+numeric.prettyPrint(y))}break;case 3:d.hasOwnProperty(y[0])||(d[y[0]]=p,h[p]=0,v[p]=numeric.rep([u],0),++p);var E=d[y[0]];for(n=1;n<y.length;n+=2)if(y[n]!==l){var w=c[y[n]];v[E][w]=(f[w]<0?-1:1)*parseFloat(y[n+1])}else h[E]=parseFloat(y[n+1]);break;case 4:for(n=1;n<y.length;n+=2)m[c[y[n]]]=(f[c[y[n]]]<0?-1:1)*parseFloat(y[n+1]);break;case 5:break;case 6:x("Internal error")}}}x("Reached end of file without ENDATA")}},2624:e=>{"use strict";var t=new Float64Array(4),n=new Float64Array(4),r=new Float64Array(4);var o=new Float64Array(4);e.exports=function(e,a,i,s){switch(s||(o.length<i.length&&(o=new Float64Array(i.length)),s=o),e.length){case 0:for(var l=0;l<i.length;++l)s[l]=Number.NaN;return Number.NaN;case 1:return function(e,t,n){for(var r=0,o=0;o<t.length;++o){n[o]=e[o];var a=e[o]-t[o];r+=a*a}return r}(a[e[0]],i,s);case 2:return function(e,t,n,r){for(var o=0,a=0,i=0;i<n.length;++i){var s=e[i],l=t[i],c=s-l;a+=c*(n[i]-l),o+=c*c}var f=0;Math.abs(o)>1e-8&&((f=a/o)<0?f=0:f>1&&(f=1));var u=1-f,d=0;for(i=0;i<n.length;++i){var p=f*e[i]+u*t[i];r[i]=p;var h=n[i]-p;d+=h*h}return d}(a[e[0]],a[e[1]],i,s);case 3:return function(e,o,a,i,s){t.length<i.length&&(t=new Float64Array(i.length),n=new Float64Array(i.length),r=new Float64Array(i.length));for(var l=0;l<i.length;++l)t[l]=e[l]-i[l],n[l]=o[l]-e[l],r[l]=a[l]-e[l];var c=0,f=0,u=0,d=0,p=0,h=0;for(l=0;l<i.length;++l){var v=n[l],m=r[l],x=t[l];c+=v*v,f+=v*m,u+=m*m,d+=x*v,p+=x*m,h+=x*x}var g,y,E,w,b,_=Math.abs(c*u-f*f),T=f*p-u*d,A=f*d-c*p;if(T+A<=_)if(T<0)A<0&&d<0?(A=0,-d>=c?(T=1,g=c+2*d+h):g=d*(T=-d/c)+h):(T=0,p>=0?(A=0,g=h):-p>=u?(A=1,g=u+2*p+h):g=p*(A=-p/u)+h);else if(A<0)A=0,d>=0?(T=0,g=h):-d>=c?(T=1,g=c+2*d+h):g=d*(T=-d/c)+h;else{var S=1/_;g=(T*=S)*(c*T+f*(A*=S)+2*d)+A*(f*T+u*A+2*p)+h}else T<0?(E=u+p)>(y=f+d)?(w=E-y)>=(b=c-2*f+u)?(T=1,A=0,g=c+2*d+h):g=(T=w/b)*(c*T+f*(A=1-T)+2*d)+A*(f*T+u*A+2*p)+h:(T=0,E<=0?(A=1,g=u+2*p+h):p>=0?(A=0,g=h):g=p*(A=-p/u)+h):A<0?(E=c+d)>(y=f+p)?(w=E-y)>=(b=c-2*f+u)?(A=1,T=0,g=u+2*p+h):g=(T=1-(A=w/b))*(c*T+f*A+2*d)+A*(f*T+u*A+2*p)+h:(A=0,E<=0?(T=1,g=c+2*d+h):d>=0?(T=0,g=h):g=d*(T=-d/c)+h):(w=u+p-f-d)<=0?(T=0,A=1,g=u+2*p+h):w>=(b=c-2*f+u)?(T=1,A=0,g=c+2*d+h):g=(T=w/b)*(c*T+f*(A=1-T)+2*d)+A*(f*T+u*A+2*p)+h;var R=1-T-A;for(l=0;l<i.length;++l)s[l]=R*e[l]+T*o[l]+A*a[l];return g<0?0:g}(a[e[0]],a[e[1]],a[e[2]],i,s);default:return console.log("closestPoint: general case not supported..."),Number.NaN}}},4726:(e,t,n)=>{"use strict";var r=n(8743),o=n(67),a=n(5297);e.exports=function(e){e.sort(o);for(var t=e.length,n=0,i=0;i<t;++i){var s=e[i],l=a(s);if(0!==l){if(n>0){var c=e[n-1];if(0===r(s,c)&&a(c)!==l){n-=1;continue}}e[n++]=s}}return e.length=n,e}},8670:(e,t,n)=>{"use strict";e.exports=function(e,t,n,o){var a=function(e,t,n){return new l(e.length,function(e){for(var t=e.length,n=r.mallocInt32(i(3*t)),o=0,a=0;a<t;++a)for(var s=e[a],l=0;l<3;++l)n[o++]=s[l];return n}(e),t.length,u(t),u(n))}(e,t,n);b(a,o);var s=a.unpack();return a.dispose(),s},e.exports.packed=b;var r=n(4964),o=n(2917),a=n(3397),i=n(8249);function s(e,t,n,r,o,a){return Math.pow(e-r,2)+Math.pow(t-o,2)+Math.pow(n-a,2)}function l(e,t,n,r,o){this.numCells=e,this.cells=t,this.numVerts=n,this.verts=r,this.normals=o}var c=l.prototype;function f(e,t){for(var n=new Array(e),r=0;r<e;++r)n[r]=[t[3*r],t[3*r+1],t[3*r+2]];return n}function u(e){for(var t=e.length,n=r.mallocFloat32(i(3*t)),o=0,a=0;a<t;++a)for(var s=e[a],l=0;l<3;++l)n[o++]=s[l];return n}c.unpack=function(){return{cells:f(this.numCells,this.cells),positions:f(this.numVerts,this.verts),normals:f(this.numVerts,this.normals)}},c.dispose=function(){r.free(this.cells),r.free(this.verts),r.free(this.normals)};function d(e,t,n){if(e.length>=t)return e;t=i(t);for(var o=r.mallocFloat32(t),a=0;a<n;++a)o[a]=e[a];return r.free(e),o}function p(e,t,n,r){for(var o=0;o<3;++o){var a=e[3*t+o];if(a!==n&&a!==r)return o}return-1}var h=[-1,-1,-1,-1,-1];function v(e,t,n,l){for(var c=0;c<n;++c){for(var f=e.numCells,u=e.cells,v=e.numVerts,m=e.verts,x=e.normals,g=3*f,y=0,E=r.mallocInt32(3*g),w=0;w<f;++w){var b=u[3*w],_=u[3*w+1],T=u[3*w+2],A=m[3*b],S=m[3*b+1],R=m[3*b+2],M=m[3*_],C=m[3*_+1],L=m[3*_+2],P=m[3*T],k=m[3*T+1],N=m[3*T+2];s(A,S,R,M,C,L)>t&&(E[y++]=Math.min(b,_),E[y++]=Math.max(b,_),E[y++]=w),s(M,C,L,P,k,N)>t&&(E[y++]=Math.min(_,T),E[y++]=Math.max(_,T),E[y++]=w),s(P,k,N,A,S,R)>t&&(E[y++]=Math.min(T,b),E[y++]=Math.max(T,b),E[y++]=w)}if(y<3*l)return r.free(E),c>0;var H=y/3|0;a(o(E,[H,3],[3,1],0)),m=d(m,3*(H+v),3*v),x=d(x,3*(H+v),3*v);var z=0,D=-1,F=-1,I=-1;for(w=0;w<y;w+=3){b=E[w],_=E[w+1];var O=E[w+2];if(b===D&&_===F){var U=v++;m[3*U]=.5*(m[3*b]+m[3*_]),m[3*U+1]=.5*(m[3*b+1]+m[3*_+1]),m[3*U+2]=.5*(m[3*b+2]+m[3*_+2]);var G=x[3*b],B=x[3*b+1],V=x[3*b+2],W=.5*(G+x[3*_]),j=.5*(B+x[3*_+1]),q=.5*(V+x[3*_+2]),X=Math.pow(W,2)+Math.pow(j,2)+Math.pow(q,2);X>1e-6?(X=1/Math.sqrt(X),x[3*U]=W*X,x[3*U+1]=j*X,x[3*U+2]=q*X):(x[3*U]=G,x[3*U+1]=B,x[3*U+2]=V),E[z++]=4*O+p(u,O,b,_),E[z++]=U,E[z++]=4*I+p(u,I,b,_),E[z++]=U}D=b,F=_,I=O}var Y=z/2|0;if(Y<l)return r.free(E),c>0;a(o(E,[Y,2],[2,1],0));var Q=0,K=r.mallocInt32(i(3*(f+Y))),Z=0;for(w=0;w<f;++w)if(Z>=H||E[2*Z]>>2!==w)K[Q++]=u[3*w],K[Q++]=u[3*w+1],K[Q++]=u[3*w+2];else{h[0]=u[3*w+1],h[1]=-1,h[2]=u[3*w+2],h[3]=-1,h[4]=u[3*w],h[5]=-1;for(var J=0;Z<Y;){var $=E[2*Z];if($>>2!==w)break;h[J=1+2*(3&$)]=E[2*Z+1],Z+=1}for(var ee=-1,te=h[J],ne=1;ne<6;++ne){var re=h[(ne+J)%6];re<0||(ee>=0&&(K[Q++]=te,K[Q++]=ee,K[Q++]=re),ee=re)}}e.numVerts=v,e.verts=m,e.numCells=Q/3|0,e.cells=K,e.normals=x,r.free(u),r.free(E)}return c>0}function m(e,t,n,r,o,a){for(var i=0;i<n;++i)r[i]=0;for(var s=0;s<3*e;++s)r[t[s]]+=2;var l=0;for(i=0;i<n;++i)o[i]=l,l+=r[i];for(i=0;i<e;++i){var c=t[3*i],f=t[3*i+1],u=t[3*i+2],d=o[c];o[c]=d+2;var p=o[f];o[f]=p+2;var h=o[u];o[u]=h+2,a[d]=f,a[d+1]=u,a[p]=c,a[p+1]=u,a[h]=c,a[h+1]=f}var v=0,m=0;for(i=0;i<n;++i){var x=o[i],g=v;v=x,o[i]=m;for(s=g;s<x;++s){for(var y=a[s],E=s;E>g;--E){var w=a[E-1];if(w<=y)break;a[E]=w}a[E]=y}var b=-1,_=m;for(s=g;s<x;++s){(y=a[s])!==b&&(a[m++]=b=y)}r[i]=m-_}}function x(e,t,n,r,o,a,i,l,c){for(var f=0;f<a;++f){var u=l[o+f];if(c[u]>=0||s(t,n,r,i[3*u],i[3*u+1],i[3*u+2])>=e)return!0}return!1}function g(e,t,n,r,o,a,i,l,c,f,u,d,p,h,v,m,g,y,E,w,b,_){if(s(u,d,p,h,v,m)>i)return!1;for(var T=r[c],A=o[c],S=r[f],R=o[f],M=.5*(u+h),C=.5*(d+v),L=.5*(p+m),P=0,k=0,N=0;P<A&&k<R;){var H=a[P+T],z=a[k+S];if(H===z){if(++N>2)return!1;P+=1,k+=1}else H<z?P+=1:k+=1}if(x(l,M,C,L,T,A,e,a,n)||x(l,M,C,L,S,R,e,a,n))return!1;var D=.5*(g+w),F=.5*(y+b),I=.5*(E+_),O=Math.pow(D,2)+Math.pow(F,2)+Math.pow(I,2);if(O<.1)return!1;var U=0|Math.min(c,f);return n[c]=n[f]=U,e[3*U]=M,e[3*U+1]=C,e[3*U+2]=L,O=1/Math.sqrt(O),t[3*U]=D*O,t[3*U+1]=F*O,t[3*U+2]=I*O,!0}function y(e,t,n,o,a){for(var i=0|e.numCells,s=e.cells,l=0|e.numVerts,c=e.verts,f=e.normals,u=r.mallocInt32(l),d=r.mallocInt32(l),p=r.mallocInt32(6*i),h=0;h<o;++h){m(i,s,l,d,u,p);for(var v=r.mallocInt32(l),x=0;x<l;++x)v[x]=-1;var y=0;for(x=0;x<i;++x){var E=s[3*x],w=s[3*x+1],b=s[3*x+2],_=v[E],T=v[w],A=v[b];if(!(_>=0||T>=0||A>=0)){var S=c[3*E],R=c[3*E+1],M=c[3*E+2],C=c[3*w],L=c[3*w+1],P=c[3*w+2],k=c[3*b],N=c[3*b+1],H=c[3*b+2],z=f[3*E],D=f[3*E+1],F=f[3*E+2],I=f[3*w],O=f[3*w+1],U=f[3*w+2],G=f[3*b],B=f[3*b+1],V=f[3*b+2];(g(c,f,v,u,d,p,t,n,E,w,S,R,M,C,L,P,z,D,F,I,O,U)||g(c,f,v,u,d,p,t,n,w,b,C,L,P,k,N,H,I,O,U,G,B,V)||g(c,f,v,u,d,p,t,n,b,E,k,N,H,S,R,M,G,B,V,z,D,F))&&(y+=1)}}if(y<a)break;var W=0;for(x=0;x<l;++x){var j=v[x];j<0||j===x?d[x]>0&&(v[x]=W,c[3*W]=c[3*x],c[3*W+1]=c[3*x+1],c[3*W+2]=c[3*x+2],f[3*W]=f[3*x],f[3*W+1]=f[3*x+1],f[3*W+2]=f[3*x+2],W+=1):v[x]=v[j]}var q=0;for(x=0;x<i;++x){E=v[s[3*x]],w=v[s[3*x+1]],b=v[s[3*x+2]];E!==w&&w!==b&&b!==E&&(s[3*q]=E,s[3*q+1]=w,s[3*q+2]=b,q+=1)}e.numVerts=l=W,e.numCells=i=q}return r.free(v),r.free(d),r.free(u),r.free(p),h>0}function E(e,t,n){var i=e.numCells,s=e.cells,l=e.numVerts,c=r.mallocInt32(6*i),f=r.mallocInt32(2*l);!function(e,t,n,i,s){for(var l=0;l<i;++l)s[l]=0;for(l=0;l<3*e;++l)n[l]=-1;var c=3*e,f=r.mallocInt32(3*c),u=0;for(l=0;l<e;++l){var d=t[3*l],p=t[3*l+1],h=t[3*l+2];f[u++]=0|Math.min(d,p),f[u++]=0|Math.max(d,p),f[u++]=4*l+2,f[u++]=0|Math.min(p,h),f[u++]=0|Math.max(p,h),f[u++]=4*l,f[u++]=0|Math.min(h,d),f[u++]=0|Math.max(h,d),f[u++]=4*l+1}var v=u/3|0;a(o(f,[v,3],[3,1],0));var m=-1,x=-1,g=-1;for(l=0;l<v;++l){d=f[3*l],p=f[3*l+1];var y=f[3*l+2];if(d===m&&p===x){var E=g>>2,w=3&g;n[3*(y>>2)+(3&y)]=g,n[3*E+w]=y}else m>=0&&(s[m]+=1,s[x]+=1);m=d,x=p,g=y}m>=0&&(s[m]+=1,s[x]+=1),r.free(f)}(i,s,c,l,f);for(var u=0;u<t;++u){for(var d=0,p=0;p<i;++p){var h=s[3*p],v=s[3*p+1],m=s[3*p+2],x=c[3*p],g=c[3*p+1],y=c[3*p+2],E=f[h],w=f[v],b=f[m],_=6,T=6,A=6;x<0&&(T=A=4),g<0&&(A=_=4),y<0&&(T=_=4);var S=0|Math.abs(E-_+1),R=0|Math.abs(E-_),M=0|Math.abs(E-_-1),C=0|Math.abs(w-T+1),L=0|Math.abs(w-T),P=0|Math.abs(w-T-1),k=0|Math.abs(b-A+1),N=0|Math.abs(b-A),H=0|Math.abs(b-A-1);if(x>=0){var z=f[B=s[3*(U=x>>2)+(G=3&x)]],D=(s[V=3*U+(G+1)%3],c[V]),F=c[3*U+(G+2)%3];if(s[V]===v){var I=D;D=F,F=I}var O=6;if((F<0||D<0)&&(O=4),S+P+H+(0|Math.abs(z-O+1))<R+L+N+(0|Math.abs(z-O))){s[3*p]=h,s[3*p+1]=v,s[3*p+2]=B,c[3*p]=D,c[3*p+1]=4*U+2,c[3*p+2]=y,D>=0&&(c[3*(D>>2)+(3&D)]=4*p),y>=0&&(c[3*(y>>2)+(3&y)]=4*p+2),s[3*U]=h,s[3*U+1]=B,s[3*U+2]=m,c[3*U]=F,c[3*U+1]=g,c[3*U+2]=4*p+1,F>=0&&(c[3*(F>>2)+(3&F)]=4*U),g>=0&&(c[3*(g>>2)+(3&g)]=4*U+1),f[h]+=1,f[v]-=1,f[m]-=1,f[B]+=1,d+=1;continue}}if(g>=0){z=f[B=s[3*(U=g>>2)+(G=3&g)]],s[V=3*U+(G+1)%3],D=c[V],F=c[3*U+(G+2)%3];if(s[V]===m){I=D;D=F,F=I}O=6;if((D<0||F<0)&&(O=4),M+C+H+(0|Math.abs(z-O+1))<R+L+N+(0|Math.abs(z-O))){s[3*p]=v,s[3*p+1]=m,s[3*p+2]=B,c[3*p]=D,c[3*p+1]=4*U+2,c[3*p+2]=x,D>=0&&(c[3*(D>>2)+(3&D)]=4*p),x>=0&&(c[3*(x>>2)+(3&x)]=4*p+2),s[3*U]=v,s[3*U+1]=B,s[3*U+2]=h,c[3*U]=F,c[3*U+1]=y,c[3*U+2]=4*p+1,F>=0&&(c[3*(F>>2)+(3&F)]=4*U),y>=0&&(c[3*(y>>2)+(3&y)]=4*U+1),f[h]-=1,f[v]+=1,f[m]-=1,f[B]+=1,d+=1;continue}}if(y>=0){var U,G,B,V;z=f[B=s[3*(U=y>>2)+(G=3&y)]],s[V=3*U+(G+1)%3],D=c[V],F=c[3*U+(G+2)%3];if(s[V]===h){I=D;D=F,F=I}O=6;if((D<0||F<0)&&(O=4),M+P+k+(0|Math.abs(z-O+1))<R+L+N+(0|Math.abs(z-O))){s[3*p]=m,s[3*p+1]=h,s[3*p+2]=B,c[3*p]=D,c[3*p+1]=4*U+2,c[3*p+2]=g,D>=0&&(c[3*(D>>2)+(3&D)]=4*p),g>=0&&(c[3*(g>>2)+(3&g)]=4*p+2),s[3*U]=m,s[3*U+1]=B,s[3*U+2]=v,c[3*U]=F,c[3*U+1]=x,c[3*U+2]=4*p+1,F>=0&&(c[3*(F>>2)+(3&F)]=4*U),x>=0&&(c[3*(x>>2)+(3&x)]=4*U+1),f[h]-=1,f[v]-=1,f[m]+=1,f[B]+=1,d+=1;continue}}}if(d<n)break}return r.free(f),r.free(c),u>0}function w(e,t,n,o){for(var a=e.numCells,i=e.cells,s=e.numVerts,l=e.verts,c=e.normals,f=r.mallocFloat32(4*s),u=0;u<n;++u){for(var d=0;d<4*s;++d)f[d]=0;for(d=0;d<a;++d){var p=i[3*d],h=i[3*d+1],v=i[3*d+2],m=l[3*p],x=l[3*p+1],g=l[3*p+2],y=l[3*h],E=l[3*h+1],w=l[3*h+2],b=m+y+l[3*v],_=x+E+l[3*v+1],T=g+w+l[3*v+2];f[4*p]+=b,f[4*p+1]+=_,f[4*p+2]+=T,f[4*p+3]+=1,f[4*h]+=b,f[4*h+1]+=_,f[4*h+2]+=T,f[4*h+3]+=1,f[4*v]+=b,f[4*v+1]+=_,f[4*v+2]+=T,f[4*v+3]+=1}var A=0;for(d=0;d<s;++d){b=l[3*d],_=l[3*d+1],T=l[3*d+2];var S=f[4*d],R=f[4*d+1],M=f[4*d+2],C=f[4*d+3];S*=C=1/(3*C),R*=C,M*=C;var L=c[3*d],P=c[3*d+1],k=c[3*d+2],N=S-b,H=R-_,z=M-T,D=L*N+P*H+k*z,F=l[3*d]=b+t*(N-D*L),I=l[3*d+1]=_+t*(H-D*P),O=l[3*d+2]=T+t*(z-D*k);A=Math.max(A,Math.pow(F-b,2)+Math.pow(I-_,2)+Math.pow(O-T,2))}if(A<o)break}return r.free(f),u>0}function b(e,t){var n=(t=t||{}).edgeLength||function(e){for(var t=e.numCells,n=e.cells,i=e.verts,l=r.mallocFloat32(3*t),c=0;c<t;++c){var f=n[3*c],u=n[3*c+1],d=n[3*c+2],p=i[3*f],h=i[3*f+1],v=i[3*f+2],m=i[3*u],x=i[3*u+1],g=i[3*u+2],y=i[3*d],E=i[3*d+1],w=i[3*d+2];l[3*c]=s(p,h,v,m,x,g),l[3*c+1]=s(m,x,g,y,E,w),l[3*c+2]=s(y,E,w,p,h,v)}a(o(l));var b=l[l.length>>1];return r.free(l),Math.sqrt(b)}(e),i=t.smoothRate||.95;i=Math.max(Math.min(i,1),.001);for(var l=Math.pow(1.25*n,2),c=Math.pow(.75*n,2),f=t.maxIters||5,u=t.splitIters||10,d=t.collapseIters||10,p=t.flipIters||10,h=t.smoothIters||20,m=0|Math.max(t.minSplit||0,0),x=0|Math.max(t.minCollapse||0,0),g=0|Math.max(t.minFlip||0,0),b=Math.pow(Math.max(t.minSmooth||.05*n/i,0),2),_=!0,T=0;_&&T<f;++T)_=!1,_=v(e,l,u,m)||_,_=y(e,c,l,d,x)||_,_=E(e,p,g)||_,_=w(e,i,h,b)||_}},3859:(e,t,n)=>{"use strict";var r=n(4948);t.compareCoord=r.compareCoord,t.saturateAbs=r.saturateAbs,t.EPSILON=r.EPSILON,t.POSITIVE_INFINITY=r.POSITIVE_INFINITY,t.NEGATIVE_INFINITY=r.NEGATIVE_INFINITY;var o=n(1828);t.DynamicVolume=o.DynamicVolume,t.StaticVolume=o.StaticVolume;var a=n(2552);t.StencilIterator=a.StencilIterator,t.beginStencil=a.beginStencil;var i=n(5251);t.MultiIterator=i.MultiIterator,t.beginMulti=i.beginMulti},5518:(e,t,n)=>{"use strict";var r=n(3859),o=r.POSITIVE_INFINITY,a=r.NEGATIVE_INFINITY;function i(e){return!!e}e.exports=function(e,t){var n,r,s=[o,o,o],l=[a,a,a],c=e.length(),f=e.coords,u=e.phases;for(t||(t=i),n=0;n<c-1;++n)if(t(u[n]))for(r=0;r<3;++r)s[r]=Math.min(f[r][n],s[r]),l[r]=Math.max(f[r][n],l[r]);for(r=0;r<3;++r)--s[r],++l[r];return[s,l]}},8596:(e,t,n)=>{"use strict";var r=n(3859),o=n(3982),a=r.NEGATIVE_INFINITY,i=r.POSITIVE_INFINITY,s=r.EPSILON,l=o.CUBE_STENCIL,c=r.compareCoord,f=r.beginStencil,u=new Int32Array([6,5,3,0,0,0,1,1,2,2,4,4]),d=new Int32Array([7,7,7,1,2,4,3,5,3,6,5,6]),p=new Int32Array([0,1,2,0,1,2,1,2,0,2,0,1]),h=new Int16Array(256);!function(){for(var e=0;e<256;++e)for(var t=0,n=0;n<12;++n){!(e&1<<u[n])!=!(e&1<<d[n])&&(t|=1<<n),h[e]=t}}();var v=new Function("phase","return !!phase;");e.exports=function(e,t,n,r){var o,m;t?o instanceof Int32Array||(o=new Int32Array(t)):(o=new Int32Array(3))[0]=o[1]=o[2]=a,n?m instanceof Int32Array||(m=new Int32Array(n)):(m=new Int32Array(3))[0]=m[1]=m[2]=i,r||(r=v);var x=[],g=[],y=[],E=e.distances,w=e.phases,b=new Float64Array(8),_=new Int32Array(8),T=new Int32Array(8),A=f(e,l);A.seek(o);e:for(;A.hasNext();A.next()){var S=A.coord;if(c(m,S)<=0)break;for(var R=0;R<3;++R)if(S[R]<o[R]||S[R]>=m[R])continue e;var M=A.ptrs,C=0;for(R=0;R<8;++R){var L=M[R];b[R]=E[L];var P=w[L];_[R]=P,C|=r(w[M[R]])?0:1<<R}if(0!==C&&255!==C){var k=h[C],N=[0,0,0],H=0;for(R=0;R<12;++R)if(0!=(k&1<<R)){for(var z=u[R],D=d[R],F=p[R],I=b[z],O=b[D],U=0;U<3;++U)z&1<<U&&(N[U]-=1-s);N[F]-=Math.min(1-s,Math.max(s,I/(I+O))),++H}var G=1/H;for(R=0;R<3;++R)N[R]=S[R]+N[R]*G;x.push(N);t:for(R=0;R<8;++R)for(;;){if(T[R]>=x.length-1)continue t;var B=x[T[R]+1];for(U=2;U>=0;--U){var V=(0|Math.ceil(B[U]))-S[U]+(R&1<<U?1:0);if(V)break}if(V<=0&&++T[R],V>=0)break}for(R=0;R<3;++R)if(S[R]<=o[R])continue e;var W=_[7];for(R=0;R<3;++R)if(k&1<<R){var j=_[7^1<<R],q=1<<(R+1)%3,X=1<<(R+2)%3;128&C?(y.push([j,W]),y.push([j,W]),g.push([T[0],T[q],T[X]]),g.push([T[X],T[q],T[q+X]])):(y.push([W,j]),y.push([W,j]),g.push([T[0],T[X],T[q]]),g.push([T[q],T[X],T[q+X]]))}}}return{positions:x,cells:g,phases:y}}},2952:(e,t,n)=>{"use strict";var r=n(2917),o=n(3859),a=n(7898),i=n(5518);t.A=function(e,t){t||(t=i(e));var n,o,a=[0,0,0],s=e.length(),l=1,c=[0,0,0];for(n=0;n<3;++n)a[n]=t[1][n]-t[0][n]|0,c[n]=l,l*=a[n];var f,u,d,p,h,v,m=r(new Int32Array(l),a,c,0),x=r(new Float32Array(l),a,c,0),g=l,y=e.coords[0],E=e.coords[1],w=e.coords[2],b=e.phases,_=e.distances,T=0|t[0][0],A=0|t[0][1],S=0|t[0][2];for(n=s-1;n>=0;--n)if(v=g,f=y[n]-T|0,u=E[n]-A|0,!((d=w[n]-S|0)<0||d>=a[2]))for(u<0?f=u=0:u>=a[1]?(f=a[0]-1,u=a[1]-1):f<0?f=0:f>=a[0]&&(f=a[0]-1),g=f+a[0]*(u+a[1]*d),h=_[n],p=b[n],o=v-1;o>=g;--o)m.data[o]=p,x.data[o]=h;return{phase:m,distance:x}}},1844:(e,t,n)=>{"use strict";var r=n(6195),o=n(3794),a=n(3114),i=n(3859),s=n(7898),l=new Function("a","b",["for(var i=2; i>=0; --i) {","var d = a[i]-b[i];","if(d) return d;","}","return 0;"].join("\n"));e.exports=function(e,t,n){e.cells&&(n=e.faceNormals,t=e.positions,e=e.cells);var c=r(e,t,1),f=(n=n||o.faceNormals(c.cells,c.positions),[]);for(var u in c.grid){var d=c.grid[u].coord,p=a(c,n,d);isNaN(p)||Math.abs(p)>1||(p<0?f.push([d[0],d[1],d[2],1,-p]):f.push([d[0],d[1],d[2],0,p]))}f.sort(l);var h=new Array(f.length+1),v=new Array(f.length+1),m=new Array(f.length+1),x=new Array(f.length+1),g=new Array(f.length+1);h[0]=v[0]=m[0]=i.NEGATIVE_INFINITY,x[0]=0,g[0]=1;for(var y=0;y<f.length;++y){var E=f[y];h[y+1]=E[0],v[y+1]=E[1],m[y+1]=E[2],x[y+1]=E[3],g[y+1]=E[4]}return s.removeDuplicates(new i.DynamicVolume([h,v,m],g,x))}},7898:(e,t,n)=>{"use strict";var r=n(3859),o=n(3982).CROSS_STENCIL,a=r.beginStencil;function i(e,t){for(var n=t[0],r=0;r<t.length;++r)for(var o=t[r]+1,a=r<t.length-1?t[r+1]:e.length,i=o;i<a;++i)e[n++]=e[i];e.length=e.length-t.length}t.resort=function(e){for(var t=e.coords,n=e.phases,r=e.distances,o=(e.length(),new Array(e.length)),a=0;a<e.length();++a)o[a]=[t[0][a],t[1][a],t[2][a],r[a],n[a]];o.sort(rle.compareCoord);for(a=0;a<e.length;++a){var i=o[a];t[0][a]=i[0],t[1][a]=i[1],t[2][a]=i[2],r[a]=i[3],n[a]=i[4]}return e},t.resurface=function(e){return e},t.removeDuplicates=function(e){var t=[],n=e.coords,r=e.distances,s=e.phases,l=a(e,o),c=l.coord,f=l.ptrs;l.next();e:for(;l.hasNext();l.next()){for(var u=l.ptrs[0],d=0;d<3;++d)if(c[d]!==n[d][u])continue e;var p=s[u];for(d=1;d<7;++d)if(p!==s[f[d]])continue e;t.push(u)}if(t.length>0){for(d=0;d<3;++d)i(n[d],t);i(r,t),i(s,t)}return e},t.fullRepair=function(e){t.resort(e),t.resurface(e),t.removeDuplicates(e)}},1471:(e,t,n)=>{"use strict";var r=n(3859),o=new Function("return 1.0");function a(e,t,n,a){a||(a=o);var i=new r.DynamicVolume,s=new Int32Array(3),l=new Int32Array(3);for(s[2]=e[2];s[2]<t[2];++s[2])for(s[1]=e[1];s[1]<t[1];++s[1])for(s[0]=e[0];s[0]<t[0];++s[0]){var c=n(s);l[0]=s[0],l[1]=s[1],l[2]=s[2];e:for(var f=0;f<3;++f)for(var u=-1;u<=1;u+=2){if(l[f]+=u,c!==n(l)){i.push(s[0],s[1],s[2],r.saturateAbs(a(s)),c);break e}l[f]=s[f]}}return i}t.dense=a;var i=new Function("x","return x.join('|');");function s(e,t,n,a,s){s=s||o;var l={},c=[];e:for(var f=0;f<n.length;++f)for(var u=a(m=n[f]),d=0;d<3;++d)for(var p=-1;p<=2;p+=2){var h=m[d];m[d]+=p;var v=a(m);if(m[d]=h,v!==u){c.push([m[0],m[1],m[2],s(m),a(m)]),l[i(m)]=!0;continue e}}for(var m=[0,0,0],x=0;x<c.length;++x){var g=c[x];for(d=0;d<3;++d)e:for(p=-1;p<=1;p+=2){for(f=0;f<3;++f)m[f]=g[f];m[d]+=p;for(f=0;f<3;++f)if(m[f]<e[f]||m[f]>=t[f])continue e;var y=i(m);if(!l[y]){var E=a(m);t:for(var w=0;w<3;++w)for(h=-1;h<=1;++h){m[w]+=h;var b=a(m);if(m[w]-=h,b!==E){c.push([m[0],m[1],m[2],r.saturateAbs(s(m)),E]);break t}}l[y]=!0}}}c.sort(r.compareCoord);var _=new Array(c.length+1),T=new Array(c.length+1),A=new Array(c.length+1),S=new Array(c.length+1),R=new Array(c.length+1);_[0]=T[0]=A[0]=r.NEGATIVE_INFINITY,S[0]=1,R[0]=0;for(f=0;f<c.length;++f){var M=c[f];_[f+1]=M[0],T[f+1]=M[1],A[f+1]=M[2],S[f+1]=M[3],R[f+1]=M[4]}return new r.DynamicVolume([_,T,A],S,R)}function l(e,t,n,r,a){n instanceof Array||(n=[n,n,n]),a=a||o;var i=[],l=[0,0,0];for(l[0]=e[0]+n[0];l[0]<t[0];l[0]+=n[0])for(l[1]=e[1]+n[1];l[1]<t[1];l[1]+=n[1])for(l[2]=e[2]+n[2];l[2]<t[2];l[2]+=n[2])for(var c=r(l),f=0;f<3;++f){var u=l[f];l[f]-=n[f];var d=r(l[f]);if(c!==d){for(var p=l[f],h=l[f]+n[f];p<h;)l[f]=p+h>>1,r(l[f])===d?p=l[f]+1:h=l[f]-1;i.push(l.slice(0))}l[f]=u}return s(e,t,i,r,a)}t.marching=s,t.adaptive=l;var c=new Function("dist_func","x","return dist_func(x) <= 0 ? 1 : 0;");function f(e){return c.bind(null,e)}t.solid={dense:function(e,t,n){return a(e,t,f(n),n)},marching:function(e,t,n,r){return s(e,t,n,f(r),r)},adaptive:function(e,t,n,r){return l(e,t,n,f(r),r)}}},3982:(e,t)=>{function n(e){for(var t=[],n=Math.ceil(e),r=-n;r<=n;++r)for(var o=-n;o<=n;++o)for(var a=-n;a<=n;++a)t.push(r),t.push(o),t.push(a);return new Int32Array(t)}function r(e,t){if(e===Number.POSITIVE_INFINITY)return n(t);for(var r=[],o=0|Math.ceil(t),a=Math.pow(t,e),i=-o;i<=o;++i)for(var s=-o;s<=o;++s)for(var l=-o;l<=o;++l)Math.pow(Math.abs(i),e)+Math.pow(Math.abs(s),e)+Math.pow(Math.abs(l),e)<=a&&(r.push(i),r.push(s),r.push(l));return r}var o,a;!function(){for(var e=[],t=0;t<8;++t){for(var n=[0,0,0],r=0;r<3;++r)0!=(t&1<<r)&&(n[r]=-1);e.push(n[0]),e.push(n[1]),e.push(n[2])}o=new Int32Array(e)}(),function(){for(var e=[0,0,0],t=0;t<3;++t)for(var n=-1;n<=1;n+=2)e.push(0===t?n:0),e.push(1===t?n:0),e.push(2===t?n:0);a=new Int32Array(e)}(),t.lp=r,t.moore=n,t.vonNeumann=r.bind(null,1),t.ball=r.bind(null,2),t.CROSS_STENCIL=a,t.CUBE_STENCIL=o},1341:e=>{"use strict";e.exports=function(e){for(var t=e.length,n=e[e.length-1],r=t,o=t-2;o>=0;--o){var a=n,i=e[o];(l=i-((n=a+i)-a))&&(e[--r]=n,n=l)}var s=0;for(o=r;o<t;++o){var l;a=e[o];(l=(i=n)-((n=a+i)-a))&&(e[s++]=l)}return e[s++]=n,e.length=s,e}},5308:(e,t,n)=>{"use strict";var r=n(7258),o=n(92),a=n(9388),i=n(1341);function s(e,t){for(var n=new Array(e.length-1),r=1;r<e.length;++r)for(var o=n[r-1]=new Array(e.length-1),a=0,i=0;a<e.length;++a)a!==t&&(o[i++]=e[r][a]);return n}function l(e){for(var t=new Array(e),n=0;n<e;++n){t[n]=new Array(e);for(var r=0;r<e;++r)t[n][r]=["m[",n,"][",r,"]"].join("")}return t}function c(e){if(1===e.length)return e[0];if(2===e.length)return["sum(",e[0],",",e[1],")"].join("");var t=e.length>>1;return["sum(",c(e.slice(0,t)),",",c(e.slice(t)),")"].join("")}function f(e){if(2===e.length)return["sum(prod(",e[0][0],",",e[1][1],"),prod(-",e[0][1],",",e[1][0],"))"].join("");for(var t=[],n=0;n<e.length;++n)t.push(["scale(",f(s(e,n)),",",(r=n,1&r?"-":""),e[0][n],")"].join(""));return c(t);var r}function u(e){return new Function("sum","scale","prod","compress",["function robustDeterminant",e,"(m){return compress(",f(l(e)),")};return robustDeterminant",e].join(""))(o,a,r,i)}var d=[function(){return[0]},function(e){return[e[0][0]]}];!function(){for(;d.length<6;)d.push(u(d.length));for(var t=[],n=["function robustDeterminant(m){switch(m.length){"],r=0;r<6;++r)t.push("det"+r),n.push("case ",r,":return det",r,"(m);");n.push("}var det=CACHE[m.length];if(!det)det=CACHE[m.length]=gen(m.length);return det(m);}return robustDeterminant"),t.push("CACHE","gen",n.join(""));var o=Function.apply(void 0,t);for(e.exports=o.apply(void 0,d.concat([d,u])),r=0;r<d.length;++r)e.exports[r]=d[r]}()},4857:(e,t,n)=>{"use strict";var r=n(5308);function o(e){for(var t="robustLinearSolve"+e+"d",n=["function ",t,"(A,b){return ["],o=0;o<e;++o){n.push("det([");for(var a=0;a<e;++a){a>0&&n.push(","),n.push("[");for(var i=0;i<e;++i)i>0&&n.push(","),i===o?n.push("+b[",a,"]"):n.push("+A[",a,"][",i,"]");n.push("]")}n.push("]),")}n.push("det(A)]}return ",t);var s=new Function("det",n.join(""));return s(e<6?r[e]:r)}var a=[function(){return[[0]]},function(e,t){return[[t[0]],[e[0][0]]]}];!function(){for(;a.length<6;)a.push(o(a.length));for(var t=[],n=["function dispatchLinearSolve(A,b){switch(A.length){"],r=0;r<6;++r)t.push("s"+r),n.push("case ",r,":return s",r,"(A,b);");n.push("}var s=CACHE[A.length];if(!s)s=CACHE[A.length]=g(A.length);return s(A,b)}return dispatchLinearSolve"),t.push("CACHE","g",n.join(""));var i=Function.apply(void 0,t);for(e.exports=i.apply(void 0,a.concat([a,o])),r=0;r<6;++r)e.exports[r]=a[r]}()},6651:(e,t,n)=>{"use strict";var r=n(7258),o=n(92),a=n(9388),i=n(865);function s(e,t){for(var n=new Array(e.length-1),r=1;r<e.length;++r)for(var o=n[r-1]=new Array(e.length-1),a=0,i=0;a<e.length;++a)a!==t&&(o[i++]=e[r][a]);return n}function l(e){if(1===e.length)return e[0];if(2===e.length)return["sum(",e[0],",",e[1],")"].join("");var t=e.length>>1;return["sum(",l(e.slice(0,t)),",",l(e.slice(t)),")"].join("")}function c(e){if(2===e.length)return[["sum(prod(",e[0][0],",",e[1][1],"),prod(-",e[0][1],",",e[1][0],"))"].join("")];for(var t=[],n=0;n<e.length;++n)t.push(["scale(",l(c(s(e,n))),",",(r=n,1&r?"-":""),e[0][n],")"].join(""));return t;var r}function f(e){for(var t=[],n=[],f=function(e){for(var t=new Array(e),n=0;n<e;++n){t[n]=new Array(e);for(var r=0;r<e;++r)t[n][r]=["m",r,"[",e-n-1,"]"].join("")}return t}(e),u=[],d=0;d<e;++d)0==(1&d)?t.push.apply(t,c(s(f,d))):n.push.apply(n,c(s(f,d))),u.push("m"+d);var p=l(t),h=l(n),v="orientation"+e+"Exact",m=["function ",v,"(",u.join(),"){var p=",p,",n=",h,",d=sub(p,n);return d[d.length-1];};return ",v].join("");return new Function("sum","prod","scale","sub",m)(o,r,a,i)}var u=f(3),d=f(4),p=[function(){return 0},function(){return 0},function(e,t){return t[0]-e[0]},function(e,t,n){var r,o=(e[1]-n[1])*(t[0]-n[0]),a=(e[0]-n[0])*(t[1]-n[1]),i=o-a;if(o>0){if(a<=0)return i;r=o+a}else{if(!(o<0))return i;if(a>=0)return i;r=-(o+a)}var s=33306690738754716e-32*r;return i>=s||i<=-s?i:u(e,t,n)},function(e,t,n,r){var o=e[0]-r[0],a=t[0]-r[0],i=n[0]-r[0],s=e[1]-r[1],l=t[1]-r[1],c=n[1]-r[1],f=e[2]-r[2],u=t[2]-r[2],p=n[2]-r[2],h=a*c,v=i*l,m=i*s,x=o*c,g=o*l,y=a*s,E=f*(h-v)+u*(m-x)+p*(g-y),w=7771561172376103e-31*((Math.abs(h)+Math.abs(v))*Math.abs(f)+(Math.abs(m)+Math.abs(x))*Math.abs(u)+(Math.abs(g)+Math.abs(y))*Math.abs(p));return E>w||-E>w?E:d(e,t,n,r)}];function h(e){var t=p[e.length];return t||(t=p[e.length]=f(e.length)),t.apply(void 0,e)}!function(){for(;p.length<=5;)p.push(f(p.length));for(var t=[],n=["slow"],r=0;r<=5;++r)t.push("a"+r),n.push("o"+r);var o=["function getOrientation(",t.join(),"){switch(arguments.length){case 0:case 1:return 0;"];for(r=2;r<=5;++r)o.push("case ",r,":return o",r,"(",t.slice(0,r).join(),");");o.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation"),n.push(o.join(""));var a=Function.apply(void 0,n);for(e.exports=a.apply(void 0,[h].concat(p)),r=0;r<=5;++r)e.exports[r]=p[r]}()},8371:(e,t,n)=>{e.exports=function(e,t){for(var n=t[0],o=t[1],a=e.length,i=1,s=a,l=0,c=a-1;l<s;c=l++){var f=e[l],u=e[c],d=f[1],p=u[1];if(p<d){if(p<o&&o<d){if(0===(m=r(f,u,t)))return 0;i^=0<m|0}else if(o===d){var h=(v=e[(l+1)%a])[1];if(d<h){if(0===(m=r(f,u,t)))return 0;i^=0<m|0}}}else if(d<p){if(d<o&&o<p){if(0===(m=r(f,u,t)))return 0;i^=m<0|0}else if(o===d){var v=e[(l+1)%a];if((h=v[1])<d){var m;if(0===(m=r(f,u,t)))return 0;i^=m<0|0}}}else if(o===d){var x=Math.min(f[0],u[0]),g=Math.max(f[0],u[0]);if(0===l){for(;c>0;){var y=(c+a-1)%a;if((b=e[y])[1]!==o)break;var E=b[0];x=Math.min(x,E),g=Math.max(g,E),c=y}if(0===c)return x<=n&&n<=g?0:1;s=c+1}for(var w=e[(c+a-1)%a][1];l+1<s;){var b;if((b=e[l+1])[1]!==o)break;E=b[0];x=Math.min(x,E),g=Math.max(g,E),l+=1}if(x<=n&&n<=g)return 0;var _=e[(l+1)%a][1];n<x&&w<o!=_<o&&(i^=1)}}return 2*i-1};var r=n(6651)},9388:(e,t,n)=>{"use strict";var r=n(7258),o=n(9553);e.exports=function(e,t){var n=e.length;if(1===n){var a=r(e[0],t);return a[0]?a:[a[1]]}var i=new Array(2*n),s=[.1,.1],l=[.1,.1],c=0;r(e[0],t,s),s[0]&&(i[c++]=s[0]);for(var f=1;f<n;++f){r(e[f],t,l);var u=s[1];o(u,l[0],s),s[0]&&(i[c++]=s[0]);var d=l[1],p=s[1],h=d+p,v=p-(h-d);s[1]=h,v&&(i[c++]=v)}s[1]&&(i[c++]=s[1]);0===c&&(i[c++]=0);return i.length=c,i}},865:e=>{"use strict";e.exports=function(e,t){var n=0|e.length,r=0|t.length;if(1===n&&1===r)return function(e,t){var n=e+t,r=n-e,o=e-(n-r)+(t-r);if(o)return[o,n];return[n]}(e[0],-t[0]);var o,a,i=new Array(n+r),s=0,l=0,c=0,f=Math.abs,u=e[l],d=f(u),p=-t[c],h=f(p);d<h?(a=u,(l+=1)<n&&(u=e[l],d=f(u))):(a=p,(c+=1)<r&&(p=-t[c],h=f(p)));l<n&&d<h||c>=r?(o=u,(l+=1)<n&&(u=e[l],d=f(u))):(o=p,(c+=1)<r&&(p=-t[c],h=f(p)));var v,m,x=o+a,g=x-o,y=a-g,E=y,w=x;for(;l<n&&c<r;)d<h?(o=u,(l+=1)<n&&(u=e[l],d=f(u))):(o=p,(c+=1)<r&&(p=-t[c],h=f(p))),(y=(a=E)-(g=(x=o+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v;for(;l<n;)(y=(a=E)-(g=(x=(o=u)+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v,(l+=1)<n&&(u=e[l]);for(;c<r;)(y=(a=E)-(g=(x=(o=p)+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v,(c+=1)<r&&(p=-t[c]);E&&(i[s++]=E);w&&(i[s++]=w);s||(i[s++]=0);return i.length=s,i}},92:e=>{"use strict";e.exports=function(e,t){var n=0|e.length,r=0|t.length;if(1===n&&1===r)return function(e,t){var n=e+t,r=n-e,o=e-(n-r)+(t-r);if(o)return[o,n];return[n]}(e[0],t[0]);var o,a,i=new Array(n+r),s=0,l=0,c=0,f=Math.abs,u=e[l],d=f(u),p=t[c],h=f(p);d<h?(a=u,(l+=1)<n&&(u=e[l],d=f(u))):(a=p,(c+=1)<r&&(p=t[c],h=f(p)));l<n&&d<h||c>=r?(o=u,(l+=1)<n&&(u=e[l],d=f(u))):(o=p,(c+=1)<r&&(p=t[c],h=f(p)));var v,m,x=o+a,g=x-o,y=a-g,E=y,w=x;for(;l<n&&c<r;)d<h?(o=u,(l+=1)<n&&(u=e[l],d=f(u))):(o=p,(c+=1)<r&&(p=t[c],h=f(p))),(y=(a=E)-(g=(x=o+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v;for(;l<n;)(y=(a=E)-(g=(x=(o=u)+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v,(l+=1)<n&&(u=e[l]);for(;c<r;)(y=(a=E)-(g=(x=(o=p)+a)-o))&&(i[s++]=y),E=w-((v=w+x)-(m=v-w))+(x-m),w=v,(c+=1)<r&&(p=t[c]);E&&(i[s++]=E);w&&(i[s++]=w);s||(i[s++]=0);return i.length=s,i}},3114:(e,t,n)=>{n(6047);e.exports=function(e,t,n){var r=e.closestCells(n);if(!r)return Number.NaN;if(r.distance<1e-6)return 0;for(var o=0,a=!1,i=r.cells,s=r.points,l=0;l<i.length;++l){for(var c=0,f=0,u=s[l],d=t[i[l]],p=0;p<n.length;++p){var h=u[p]-n[p];c+=h*h,f+=d[p]*h}(f/=Math.sqrt(c))<0?(f=-f)>o&&(o=f,a=!0):f>o&&(o=f,a=!1)}var v=Math.sqrt(r.distance);return a?v:-v}},8979:(e,t,n)=>{"use strict";e.exports=function(e){return o(r(e))};var r=n(4966),o=n(4726)},8966:(e,t,n)=>{"use strict";var r=n(19),o=n(4010);function a(e,t){var n=e.length,r=e.length-t.length,o=Math.min;if(r)return r;switch(n){case 0:return 0;case 1:return e[0]-t[0];case 2:return(s=e[0]+e[1]-t[0]-t[1])||o(e[0],e[1])-o(t[0],t[1]);case 3:var a=e[0]+e[1],i=t[0]+t[1];if(s=a+e[2]-(i+t[2]))return s;var s,l=o(e[0],e[1]),c=o(t[0],t[1]);return(s=o(l,e[2])-o(c,t[2]))||o(l+e[2],a)-o(c+t[2],i);default:var f=e.slice(0);f.sort();var u=t.slice(0);u.sort();for(var d=0;d<n;++d)if(r=f[d]-u[d])return r;return 0}}function i(e,t){return a(e[0],t[0])}function s(e,t){if(t){for(var n=e.length,r=new Array(n),o=0;o<n;++o)r[o]=[e[o],t[o]];r.sort(i);for(o=0;o<n;++o)e[o]=r[o][0],t[o]=r[o][1];return e}return e.sort(a),e}function l(e){if(0===e.length)return[];for(var t=1,n=e.length,r=1;r<n;++r){var o=e[r];if(a(o,e[r-1])){if(r===t){t++;continue}e[t++]=o}}return e.length=t,e}function c(e,t){for(var n=0,r=e.length-1,o=-1;n<=r;){var i=n+r>>1,s=a(e[i],t);s<=0?(0===s&&(o=i),n=i+1):s>0&&(r=i-1)}return o}function f(e,t){for(var n=new Array(e.length),o=0,i=n.length;o<i;++o)n[o]=[];for(var s=[],l=(o=0,t.length);o<l;++o)for(var f=t[o],u=f.length,d=1,p=1<<u;d<p;++d){s.length=r.popCount(d);for(var h=0,v=0;v<u;++v)d&1<<v&&(s[h++]=f[v]);var m=c(e,s);if(!(m<0))for(;n[m++].push(o),!(m>=e.length||0!==a(e[m],s)););}return n}function u(e,t){if(t<0)return[];for(var n=[],o=(1<<t+1)-1,a=0;a<e.length;++a)for(var i=e[a],l=o;l<1<<i.length;l=r.nextCombination(l)){for(var c=new Array(t+1),f=0,u=0;u<i.length;++u)l&1<<u&&(c[f++]=i[u]);n.push(c)}return s(n)}t.dimension=function(e){for(var t=0,n=Math.max,r=0,o=e.length;r<o;++r)t=n(t,e[r].length);return t-1},t.countVertices=function(e){for(var t=-1,n=Math.max,r=0,o=e.length;r<o;++r)for(var a=e[r],i=0,s=a.length;i<s;++i)t=n(t,a[i]);return t+1},t.cloneCells=function(e){for(var t=new Array(e.length),n=0,r=e.length;n<r;++n)t[n]=e[n].slice(0);return t},t.compareCells=a,t.normalize=s,t.unique=l,t.findCell=c,t.incidence=f,t.dual=function(e,t){if(!t)return f(l(u(e,0)),e);for(var n=new Array(t),r=0;r<t;++r)n[r]=[];r=0;for(var o=e.length;r<o;++r)for(var a=e[r],i=0,s=a.length;i<s;++i)n[a[i]].push(r);return n},t.explode=function(e){for(var t=[],n=0,r=e.length;n<r;++n)for(var o=e[n],a=0|o.length,i=1,l=1<<a;i<l;++i){for(var c=[],f=0;f<a;++f)i>>>f&1&&c.push(o[f]);t.push(c)}return s(t)},t.skeleton=u,t.boundary=function(e){for(var t=[],n=0,r=e.length;n<r;++n)for(var o=e[n],a=0,i=o.length;a<i;++a){for(var l=new Array(o.length-1),c=0,f=0;c<i;++c)c!==a&&(l[f++]=o[c]);t.push(l)}return s(t)},t.connectedComponents=function(e,t){return t?function(e,t){for(var n=new o(t),r=0;r<e.length;++r)for(var a=e[r],i=0;i<a.length;++i)for(var s=i+1;s<a.length;++s)n.link(a[i],a[s]);var l=[],c=n.ranks;for(r=0;r<c.length;++r)c[r]=-1;for(r=0;r<e.length;++r){var f=n.find(e[r][0]);c[f]<0?(c[f]=l.length,l.push([e[r].slice(0)])):l[c[f]].push(e[r].slice(0))}return l}(e,t):function(e){for(var t=l(s(u(e,0))),n=new o(t.length),r=0;r<e.length;++r)for(var a=e[r],i=0;i<a.length;++i)for(var f=c(t,[a[i]]),d=i+1;d<a.length;++d)n.link(f,c(t,[a[d]]));var p=[],h=n.ranks;for(r=0;r<h.length;++r)h[r]=-1;for(r=0;r<e.length;++r){var v=n.find(c(t,[e[r][0]]));h[v]<0?(h[v]=p.length,p.push([e[r].slice(0)])):p[h[v]].push(e[r].slice(0))}return p}(e)}},7619:(e,t,n)=>{var r=n(4964);function o(e,t,n){return Math.sqrt(Math.pow(e,2)+Math.pow(t,2)+Math.pow(n,2))}function a(e,t,n){for(var r=0;r<3;++r)e[r]+=t[r]*n}function i(e){for(var t=new Array(e.length),n=0;n<e.length;++n)t[n]=e[n].slice();return t}function s(e,t,n,r,i){var s,l=t.length,c=e.length;for(s=0;s<l;++s){var f=n[s];f[0]=f[1]=f[2]=0}for(s=0;s<l;++s)r[s]=0;for(s=0;s<c;++s){var u=e[s],d=u[0],p=u[1],h=u[2],v=t[d],m=t[p],x=t[h],g=v[0]-m[0],y=v[1]-m[1],E=v[2]-m[2],w=m[0]-x[0],b=m[1]-x[1],_=m[2]-x[2],T=x[0]-v[0],A=x[1]-v[1],S=x[2]-v[2],R=.5*o(y*S-E*A,E*T-g*S,g*A-y*T);if(!(R<1e-8)){var M=-.5/R,C=M*(g*T+y*A+E*S),L=M*(w*g+b*y+_*E),P=M*(T*w+A*b+S*_);r[d]+=L+P,r[p]+=P+C,r[h]+=C+L;var k=n[d],N=n[p],H=n[h];a(N,x,C),a(H,m,C),a(H,v,L),a(k,x,L),a(k,m,P),a(N,v,P)}}for(s=0;s<l;++s)for(var z=n[s],D=t[s],F=r[s],I=0;I<3;++I){var O=D[I];z[I]=O+i*(z[I]/F-O)}}e.exports=function(e,t,n){for(var o=n||{},a=("passBand"in o?+o.passBand:.1),l=("iters"in o?0|o.iters:10),c=r.mallocDouble(t.length),f=i(t),u=i(t),d=a,p=Math.sqrt(d*d- -8),h=(-d+p)/-4,v=(-d-p)/-4,m=Math.max(h,v),x=Math.min(h,v),g=0;g<l;++g)s(e,f,u,c,m),s(e,u,f,c,x);return r.free(c),f}},6195:(e,t,n)=>{"use strict";var r=n(6047),o=n(19),a=n(2624);function i(e,t){this.coord=e,this.cells=t}function s(e,t,n,r){this.cells=e,this.positions=t,this.tolerance=n,this.grid=r}function l(e){switch(e.length){case 0:return 0;case 1:return e[0];case 2:return o.interleave2(e[0],e[1]);case 3:return o.interleave3(e[0],e[1],e[2]);default:return e.join("|")}}function c(e){return e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e&=65535)|e<<8))|e<<4))|e<<2))|e<<1)}function f(e){return e=1227133513&((e=3272356035&((e=251719695&((e=4278190335&((e&=1023)|e<<16))|e<<8))|e<<4))|e<<2)}function u(e,t,n,o,s,c){if(s<0){var f=r.mul(e.tolerance,c),d=a(e.cells[o],e.positions,f);if(isNaN(d)||d>=t.length*e.tolerance*e.tolerance)return;var p=l(c),h=e.grid[p];h?h.cells.push(o):e.grid[p]=new i(c.slice(0),[o])}else for(c[s]=t[s];c[s]<=n[s];++c[s])u(e,t,n,o,s-1,c)}function d(e,t,n,r){var o=t.length;switch(o){case 0:break;case 1:!function(e,t,n,r){for(var o=t[0];o<=n[0];++o)e[o]?e[o].cells.push(r):e[o]=new i([o],[r])}(e,t,n,r);break;case 2:!function(e,t,n,r){for(var o=[0,0],s=2*e.tolerance*e.tolerance,l=t[1];l<=n[1];++l){var f=c(l)<<1;o[1]=l*e.tolerance;for(var u=t[0];u<=n[0];++u){o[0]=p*e.tolerance;var d=a(e.cells[r],e.positions,o);if(!(isNaN(d)||d>=s)){var p=f+c(u),h=e.grid[p];h?h.cells.push(r):e.grid[p]=new i([u,l],[r])}}}}(e,t,n,r);break;case 3:!function(e,t,n,r){for(var o=[0,0,0],s=3*e.tolerance*e.tolerance,l=t[2];l<=n[2];++l){var c=f(l)<<2;o[2]=e.tolerance*l;for(var u=t[1];u<=n[1];++u){var d=c+(f(u)<<1);o[1]=e.tolerance*u;for(var p=t[0];p<=n[0];++p){o[0]=e.tolerance*p;var h=a(e.cells[r],e.positions,o);if(!(isNaN(h)||h>=s)){var v=d+f(p),m=e.grid[v];m?m.cells.push(r):e.grid[v]=new i([p,u,l],[r])}}}}}(e,t,n,r);break;default:u(e,t,n,r,o-1,new Array(o))}}i.prototype.closestCells=function(e,t){for(var n=this.cells,r=Number.POSITIVE_INFINITY,o=[],i=[],s=new Array(t.length),l=0;l<n.length;++l){var c=n[l],f=a(e.cells[c],e.positions,t,s);Math.abs(f-r)<1e-6?(o.push(c),i.push(s.slice(0))):f<r&&(r=f,o.length=1,o[0]=c,i.length=1,i[0]=s.slice(0))}return{points:i,cells:o,distance:r}},i.prototype.neighborhood=function(e,t,n){for(var r=this.cells,o=[],i=n*n,s=0;s<r.length;++s){var l=r[s];a(e.cells[l],e.positions,t)<=i&&o.push(l)}return o},s.prototype.closestCells=function(e){for(var t=this.tolerance,n=new Array(e.length),r=0;r<e.length;++r)n[r]=Math.floor(e[r]/t);var o=this.grid[l(n)];return o?o.closestCells(this,e):null},s.prototype.neighborhood=function(e,t){for(var n=this.tolerance,r=new Array(e.length),o=0;o<e.length;++o)r[o]=Math.floor(e[o]/n);var a=this.grid[l(r)];return a?a.neighborhood(this,e,t):[]},e.exports=function(e,t,n){for(var r=new s(e,t,n,{}),o=t[0].length,a=new Array(o),i=new Array(o),l=new Array(o),c=new Array(o),f=0;f<e.length;++f){for(var u=e[f],p=0;p<o;++p)a[p]=Number.POSITIVE_INFINITY,l[p]=Number.NEGATIVE_INFINITY;for(var h=0;h<u.length;++h){var v=t[u[h]];for(p=0;p<o;++p)a[p]=Math.min(a[p],v[p]),l[p]=Math.max(l[p],v[p])}for(p=0;p<o;++p)i[p]=Math.floor(a[p]/n)-1,c[p]=Math.ceil(l[p]/n)+1;d(r,i,c,f)}return r}},2552:(e,t,n)=>{"use strict";var r=n(4948),o=r.POSITIVE_INFINITY,a=r.NEGATIVE_INFINITY,i=new Int32Array(128);function s(e,t,n,r,o){this.volume=e,this.stencil=t,this.ptrs=n,this.coord=r,this.frontier=o,3*i.length<t.length&&(i=new Int32Array(t.length/3))}!function(){for(var e=0;e<128;++e)i[e]=0}(),s.prototype.clone=function(){return new s(this.volume,this.stencil,new Int32Array(this.ptrs),new Int32Array(this.coord),new Uint8Array(this.frontier))},s.prototype.hasNext=function(){return this.coord[0]<o},s.prototype.next=function(){for(var e=this.volume.coords,t=this.volume.length(),n=this.frontier,r=this.stencil,a=this.ptrs,s=this.coord,l=0,c=0;c<3;++c)s[c]=o;c=0;e:for(var f=0;c<a.length;++c,f+=3){var u=a[c];if(!(u>=t-1)){u+=1;for(var d=2;d>=0;--d){var p=e[d][u]-r[f+d],h=s[d];if(p<h){for(s[d--]=p;d>=0;--d)s[d]=e[d][u]-r[f+d];l=0;break}if(p>h)continue e}i[l++]=c}}for(c=0;c<a.length;++c)n[c]=0;for(c=0;c<l;++c){var v=i[c];++a[v],n[v]=1}},s.prototype.seek=function(e){for(var t=this.volume,n=t.coords,r=t.length(),o=this.ptrs,a=this.stencil,i=this.frontier,s=new Int32Array(3),l=0;l<3;++l)this.coord[l]=e[l];l=0;for(var c=0;l<o.length;++l,c+=3){for(var f=0;f<3;++f)s[f]=e[f]+a[c+f];o[l]=t.bisect(s,0,r-1),i[l]=n[0][o[l]]===s[0]&&n[1][o[l]]===s[1]&&n[2][o[l]]===s[2]}},s.prototype.getValues=function(e,t){for(var n=this.ptrs,r=this.frontier,o=this.volume.phases,a=this.volume.distances,i=0;i<n.length;++i){var s=n[i];e[i]=o[s],t[i]=r[i]?a[s]:1}},t.StencilIterator=s,t.beginStencil=function(e,t){var n=new Int32Array(t.length/3),r=new Int32Array(3);return r[0]=r[1]=r[2]=a,new s(e,t,n,r,new Uint8Array(n.length))}},7258:e=>{"use strict";e.exports=function(e,n,r){var o=e*n,a=t*e,i=a-(a-e),s=e-i,l=t*n,c=l-(l-n),f=n-c,u=s*f-(o-i*c-s*c-i*f);if(r)return r[0]=u,r[1]=o,r;return[u,o]};var t=+(Math.pow(2,27)+1)},9553:e=>{"use strict";e.exports=function(e,t,n){var r=e+t,o=r-e,a=t-o,i=e-(r-o);if(n)return n[0]=i+a,n[1]=r,n;return[i+a,r]}},4964:(e,t,n)=>{"use strict";var r=n(19),o=n(6951);n.g.__TYPEDARRAY_POOL||(n.g.__TYPEDARRAY_POOL={UINT8:o([32,0]),UINT16:o([32,0]),UINT32:o([32,0]),BIGUINT64:o([32,0]),INT8:o([32,0]),INT16:o([32,0]),INT32:o([32,0]),BIGINT64:o([32,0]),FLOAT:o([32,0]),DOUBLE:o([32,0]),DATA:o([32,0]),UINT8C:o([32,0]),BUFFER:o([32,0])});var a="undefined"!=typeof Uint8ClampedArray,i="undefined"!=typeof BigUint64Array,s="undefined"!=typeof BigInt64Array,l=n.g.__TYPEDARRAY_POOL;l.UINT8C||(l.UINT8C=o([32,0])),l.BIGUINT64||(l.BIGUINT64=o([32,0])),l.BIGINT64||(l.BIGINT64=o([32,0])),l.BUFFER||(l.BUFFER=o([32,0]));var c=l.DATA,f=l.BUFFER;function u(e){if(e){var t=e.length||e.byteLength,n=r.log2(t);c[n].push(e)}}function d(e){e=r.nextPow2(e);var t=r.log2(e),n=c[t];return n.length>0?n.pop():new ArrayBuffer(e)}function p(e){return new Uint8Array(d(e),0,e)}function h(e){return new Uint16Array(d(2*e),0,e)}function v(e){return new Uint32Array(d(4*e),0,e)}function m(e){return new Int8Array(d(e),0,e)}function x(e){return new Int16Array(d(2*e),0,e)}function g(e){return new Int32Array(d(4*e),0,e)}function y(e){return new Float32Array(d(4*e),0,e)}function E(e){return new Float64Array(d(8*e),0,e)}function w(e){return a?new Uint8ClampedArray(d(e),0,e):p(e)}function b(e){return i?new BigUint64Array(d(8*e),0,e):null}function _(e){return s?new BigInt64Array(d(8*e),0,e):null}function T(e){return new DataView(d(e),0,e)}function A(e){e=r.nextPow2(e);var t=r.log2(e),n=f[t];return n.length>0?n.pop():new Buffer(e)}t.free=function(e){if(Buffer.isBuffer(e))f[r.log2(e.length)].push(e);else{if("[object ArrayBuffer]"!==Object.prototype.toString.call(e)&&(e=e.buffer),!e)return;var t=e.length||e.byteLength,n=0|r.log2(t);c[n].push(e)}},t.freeUint8=t.freeUint16=t.freeUint32=t.freeBigUint64=t.freeInt8=t.freeInt16=t.freeInt32=t.freeBigInt64=t.freeFloat32=t.freeFloat=t.freeFloat64=t.freeDouble=t.freeUint8Clamped=t.freeDataView=function(e){u(e.buffer)},t.freeArrayBuffer=u,t.freeBuffer=function(e){f[r.log2(e.length)].push(e)},t.malloc=function(e,t){if(void 0===t||"arraybuffer"===t)return d(e);switch(t){case"uint8":return p(e);case"uint16":return h(e);case"uint32":return v(e);case"int8":return m(e);case"int16":return x(e);case"int32":return g(e);case"float":case"float32":return y(e);case"double":case"float64":return E(e);case"uint8_clamped":return w(e);case"bigint64":return _(e);case"biguint64":return b(e);case"buffer":return A(e);case"data":case"dataview":return T(e);default:return null}return null},t.mallocArrayBuffer=d,t.mallocUint8=p,t.mallocUint16=h,t.mallocUint32=v,t.mallocInt8=m,t.mallocInt16=x,t.mallocInt32=g,t.mallocFloat32=t.mallocFloat=y,t.mallocFloat64=t.mallocDouble=E,t.mallocUint8Clamped=w,t.mallocBigUint64=b,t.mallocBigInt64=_,t.mallocDataView=T,t.mallocBuffer=A,t.clearCache=function(){for(var e=0;e<32;++e)l.UINT8[e].length=0,l.UINT16[e].length=0,l.UINT32[e].length=0,l.INT8[e].length=0,l.INT16[e].length=0,l.INT32[e].length=0,l.FLOAT[e].length=0,l.DOUBLE[e].length=0,l.BIGUINT64[e].length=0,l.BIGINT64[e].length=0,l.UINT8C[e].length=0,c[e].length=0,f[e].length=0}},4010:e=>{"use strict";function t(e){this.roots=new Array(e),this.ranks=new Array(e);for(var t=0;t<e;++t)this.roots[t]=t,this.ranks[t]=0}e.exports=t;var n=t.prototype;Object.defineProperty(n,"length",{get:function(){return this.roots.length}}),n.makeSet=function(){var e=this.roots.length;return this.roots.push(e),this.ranks.push(0),e},n.find=function(e){for(var t=e,n=this.roots;n[e]!==e;)e=n[e];for(;n[t]!==e;){var r=n[t];n[t]=e,t=r}return e},n.link=function(e,t){var n=this.find(e),r=this.find(t);if(n!==r){var o=this.ranks,a=this.roots,i=o[n],s=o[r];i<s?a[n]=r:s<i?a[r]=n:(a[r]=n,++o[n])}}},8506:e=>{"use strict";e.exports=function(e,t,n){return 0===e.length?e:t?(n||e.sort(t),function(e,t){for(var n=1,r=e.length,o=e[0],a=e[0],i=1;i<r;++i)if(a=o,t(o=e[i],a)){if(i===n){n++;continue}e[n++]=o}return e.length=n,e}(e,t)):(n||e.sort(),function(e){for(var t=1,n=e.length,r=e[0],o=e[0],a=1;a<n;++a)if(o=r,(r=e[a])!==o){if(a===t){t++;continue}e[t++]=r}return e.length=t,e}(e))}},1828:(e,t,n)=>{"use strict";var r=n(4948).NEGATIVE_INFINITY;function o(e,t,n){var r=this.coords;e:for(;t<=n;){for(var o=t+n>>1,a=2;a>=0;--a){var i=r[a][o]-e[a];if(i<0){t=o+1;continue e}if(i>0){n=o-1;continue e}}return o}return Math.max(0,n)}function a(e,t,n){e?(this.coords=e,this.distances=t,this.phases=n):(this.coords=[[r],[r],[r]],this.distances=[1],this.phases=[0])}function i(e,t,n){e?(this.coords=e,this.distances=t,this.phases=n):(this.coords=[new Int32Array(1),new Int32Array(1),new Int32Array(1)],this.distances=new Float32Array(1),this.phases=new Int32Array(1),this.coords[0][0]=this.coords[1][0]=this.coords[2][0]=r,this.distances[0]=1)}a.prototype.clone=function(){return new a([this.coords[0].slice(0),this.coords[1].slice(0),this.coords[2].slice(0)],this.distances.slice(0),this.phases.slice(0))},a.prototype.length=function(){return this.phases.length},a.prototype.pop=function(){this.coords[0].pop(),this.coords[1].pop(),this.coords[2].pop(),this.distances.pop(),this.phases.pop()},a.prototype.push=function(e,t,n,r,o){var a=this.coords;a[0].push(e),a[1].push(t),a[2].push(n),this.distances.push(r),this.phases.push(o)},a.prototype.bisect=o,a.prototype.toStatic=function(){return new i([new Int32Array(this.coords[0]),new Int32Array(this.coords[1]),new Int32Array(this.coords[2])],new Float32Array(this.distances),new Int32Array(this.phases))},i.prototype.clone=function(){return new i([new Int32Array(this.coords[0]),new Int32Array(this.coords[1]),new Int32Array(this.coords[2])],new Float64Array(this.distances),new Int32Array(this.phases))},i.prototype.length=function(){return this.phases.length};var s=Array.prototype.slice;i.prototype.toDynamic=function(){return new a([s.call(this.coords[0],0),s.call(this.coords[1],0),s.call(this.coords[2],0)],s.call(this.distances,0),s.call(this.phases,0))},i.prototype.bisect=o,t.StaticVolume=i,t.DynamicVolume=a},2446:(e,t,n)=>{"use strict";var r=n(1844),o=n(2952).A;e.exports=function(e,t,n){var a,i,s,l=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0],f=t.length;for(a=0;a<f;++a)for(s=t[a],i=0;i<3;++i)l[i]=Math.min(l[i],s[i]),c[i]=Math.max(c[i],s[i]);var u=+n||1,d=1/u,p=[0,0,0];for(i=0;i<3;++i)p[i]=l[i]-u;var h=new Array(f);for(a=0;a<f;++a){for(s=t[a].slice(0),i=0;i<3;++i)s[i]=(s[i]-p[i])*d;h[a]=s}var v=r(e,h);return{voxels:o(v).phase,origin:p,resolution:n}}},4324:e=>{e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n#define texChannel0 textureMaps[0]\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_SCENE_REPEAT\r\n#define ENABLE_REFLECT_PASS\r\n\r\n// Choose...\r\n#define ENABLE_PHONG_SHADING\r\n//#define ENABLE_COOK_SHADING\r\n\r\nconst vec3 lightCol = vec3(1.0, 0.97, 0.92) * 5.0;\r\n\r\nvec2 sceneMap( vec3 p )\r\n{\r\n#ifdef ENABLE_SCENE_REPEAT\r\n    p = mod(p, 1.0) - 0.5;\r\n#endif\r\n\r\n    //float d0 = fRoundBox(p, vec3(0.225,0.225,0.225), 0.1);// 0.1=radius (0.0=box, 0.5=sphere)\r\n    //float d0 = fSphere(p, 0.25);\r\n    float d0 = fBox(p, vec3(0.22, 0.22, 0.22));\r\n\r\n    // float displace = 0.015*texture(texChannel0,(p.xy*p.xz)*2.0).x;\r\n    // d0 -= displace;\r\n\r\n    d0 = d0 - 0.2*fSinusoidalPlasma(p*2.0) + 0.1*fSinusoidalPlasma(p*4.0) - 0.05*fSinusoidalPlasma(p*8.0);\r\n    \r\n    return vec2(d0, 0.0);\r\n}\r\n\r\nvec3 getLighting( vec3 p, vec3 n, vec3 ld, vec3 rd, int reflectPass )\r\n{\r\n    // base color\r\n    vec3 col = vec3(1.0);\r\n    #ifdef ENABLE_SCENE_REPEAT\r\n        vec3 voxPos = mod( p*0.5, 1.0 );\r\n        vec3 spectumColor = vec3( sin(voxPos.x*7.0), 0.8*sin(voxPos.y*8.), 0.4*sin(voxPos.z*4.0) );\r\n        if( (voxPos.x < 0.5) && (voxPos.z < 0.5) ) col = vec3(1.0, 0.85, 0.5) * (0.85 + 0.3*spectumColor);\r\n        else if( (voxPos.x >= 0.5) && (voxPos.z >= 0.5) ) col = vec3(1.0, 0.85, 0.5) * (0.85 + 0.3*spectumColor);\r\n    #endif\r\n\r\n    // texture color\r\n    col *= texCube(texChannel0, p, n, 4.0).xyz;\r\n\r\n    // bump normal\r\n    if( reflectPass == 0 ) n = getBumpNormal(texChannel0, p, n, 0.0075);\r\n\r\n    // shadow & ao\r\n    float shadow = (reflectPass == 0)? sceneShadow( p, ld ) : 1.0;\r\n    float ao = sceneAO(p, n);\r\n\r\n    // shading...\r\n    #if defined (ENABLE_PHONG_SHADING)\r\n        float shininess = 64.0;\r\n        return getPhongShading( col, shininess, ld, lightCol, p, n, rd ) * (shadow * ao);\r\n\r\n    #elif defined (ENABLE_COOK_SHADING)\r\n        float metallic = 0.1;\r\n        float roughness = 0.1;\r\n        return getCookShading( col, metallic, roughness, ld, lightCol*2.0, n, rd ) * (shadow * ao);\r\n\r\n    #endif\r\n}\r\n\r\nvec4 getSceneColor( vec3 ro, vec3 rd, float tmin, float tmax )\r\n{\r\n    //----------------------------------------------------\r\n    // step 1: primary scene color: direct lighting pass\r\n    //----------------------------------------------------\r\n\r\n    gl_FragDepth = 0.99;\r\n\r\n    // intersection\r\n\tfloat t = rayTracing( ro, rd, tmin, tmax, 0.75 );\r\n\tif( t > tmax ) return vec4(vec3(0.0), 1.0);\r\n\r\n    // hitted\r\n\tvec3 p = ro + rd * t;\r\n    vec3 n = sceneNormal( p, 0.2 );\r\n\r\n    // light\r\n    vec3 lp = vec3(ro.x, ro.y + 1.0, ro.z);\r\n    vec3 ld = normalize(lp - p);\r\n\r\n\tvec3 sceneColor = getLighting( p, n, ld, rd, 0 ); // 0 = reflectPass ==> shadow will be computed\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    //----------------------------------------------------\r\n    // step 2: secondary scene color: reflection pass\r\n    //----------------------------------------------------\r\n    #ifdef ENABLE_REFLECT_PASS\r\n        vec3 r = reflect(rd, n);\r\n        t = rayTracing(p, r, 0.005, tmax, 0.75 ); // 0.005 (recommended: distance per one pixel)\r\n        if( t < tmax ) {\r\n            float refCoef = 0.35;\r\n            p += r * t;\r\n            n = sceneNormal( p, 0.2 );\r\n            sceneColor += getLighting( p, n, ld, r, 1 ) * refCoef; // 1 = reflectPass ==> shadow will be computed\r\n        }\r\n    #endif\r\n\r\n\treturn vec4( saturate(sceneColor), 1.0 );\r\n}\r\n\r\nmat2 rotMatrix( float angle )\r\n{\r\n\tfloat c = cos( angle );\r\n\tfloat s = sin( angle );\t\r\n\treturn mat2( c, s, -s, c );\r\n}\r\nvoid setCamera( out vec3 ro, out vec3 rd )\r\n{\r\n    vec2 aspect = vec2(resolution.x/ resolution.y, 1.0);\r\n\tvec2 screenPos = (2.0*gl_FragCoord.xy / resolution.xy - 1.0) * aspect;\r\n\r\n\tfloat rad = 0.5;\r\n\tvec3 lookAt = vec3( 0.5,                       5.8*rad*cos(time*0.125), time       );\r\n\tvec3 camPos = vec3( 0.5+1.4*rad*sin(time*0.5), 5.8*rad*cos(time*0.125), -1.0 + time);\r\n\r\n    vec3 forward = normalize(lookAt - camPos);\r\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\r\n    vec3 up = normalize(cross(forward, right));\r\n    float FOV = 0.5;\r\n    ro = camPos;\r\n    rd = normalize(forward + FOV*screenPos.x*right + FOV*screenPos.y*up);\r\n\r\n    //rd.xz *= rotMatrix( PI*sin(-time*0.125)/2.0  ); // rotY ==> yawing sinusoidally (not frequently)\r\n\trd.yz *= rotMatrix( PI*sin(-time*0.125)/6.0 ); // rotX ==> pitching (like nodding) sinusoidally\r\n\trd.xy *= rotMatrix( PI*sin(-time*0.5)/4.0 );   // rotZ ==> rolling (like car wipers) sinusoidally\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    setCamera( ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n\tfloat NEAR = 0.0;\r\n\tfloat FAR = 16.0;\r\n    gl_FragColor = getSceneColor( ro, rd, NEAR, FAR );\r\n}'},9299:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#define USE_LENSFLARES_1\r\n#define USE_TERRAIN_3\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = heightTex0 ('images/raymarch/organic2.png')\r\n// textureMaps[1] = heightTex1 ('images/raymarch/abstract1.jpg')\r\n// textureMaps[2] = detailTex  ('images/raymarch/rgbaNoise256.png')\r\n\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n// #define ENABLE_SNOW\r\n#define ENABLE_LENS_FLARES\r\n\r\nconst float FAR = 150.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-1.0,0.19,0.4));\r\n//const vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.05);\r\nconst float SKY_HEIGHT = 500.0;//1000.0;\r\n\r\n// vec3 SUN_COLOUR = vec3(1.1, 0.95, 0.85);\r\n// vec3 FOG_COLOUR = vec3(0.48, 0.49, 0.53);\r\n// vec3 SKY_BLUE_COLOUR = vec3(0.218, 0.325, 0.455);\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n\tvec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n\tres = dUnion( res, vec2( terrainMap(textureMaps[0], textureMaps[1], textureMaps[2], p), MATERIAL_TERRAIN ) );\r\n\treturn res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n\ttmin = 0.1;//1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n        \r\n    vec2 tm = rayMarching( ro, rd, tmin, tmax );\r\n\tif( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n\tvec3 col = vec3(0.0);\r\n\r\n\tif( tm.y == MATERIAL_SKY )\r\n\t{\r\n\t\tgl_FragDepth = 0.99;\r\n\t\tcol = skyColor( SUN_LIGHT, rd );\r\n\t\tapplyClouds( col, ro, rd );\r\n\t}\r\n\telse if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n\t\tgl_FragDepth = getFragDepth( p );\r\n\t\tcol = terrainColor( textureMaps[0], textureMaps[1], textureMaps[2], SUN_LIGHT, rd, p, tm.x );\r\n\r\n\t\t// col *= 1.0 when the sun is in front ===> as it is\r\n\t\t// col *= 0.5 when the sun is on the side ==> it gets dark\r\n\t\tcol *= 1.0 - 0.5 * pow( 1.0-saturate(dot(rd,SUN_LIGHT)), 3.0);//0.25\r\n\r\n\t\tapplyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.2 );\r\n\t\tapplyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.003, tm.x );//0.005\r\n\r\n\t#ifdef ENABLE_DUST_WIND\r\n\t\tfloat dustAmount = 0.2;//0.1;//0.01;\r\n\t\tfloat dustHeight = 10.0;//3.0;\r\n\t\tfloat windTurbulency = 0.3;\r\n\t\tapplyDustWind( col, ro, rd, tm.x, dustAmount, dustHeight, windTurbulency );\r\n\t#endif\r\n\t}\r\n\r\n    // sun glare\r\n\tcol += sunScatter( SUN_LIGHT, rd );\r\n\tcol = saturate(col);\r\n\r\n\t// color grading\r\n#if 0\r\n\tcol *= vec3(1.1, 1.0, 1.0); // almost linear\r\n\tcol = col*col*(3.0-2.0*col); // col = smooth(0,1,col)\r\n\tcol = pow( col, vec3(0.9,1.0,1.0) ); // red = sqr(red)\r\n\r\n\tcol = mix( col, vec3(dot(col,vec3(0.333))), 0.4 ); // 0.6*col + 0.4*gray_of_col ==> gray-tone added\r\n\tcol = col*0.5+0.5*col*col*(3.0-2.0*col); // almost linear\r\n#endif\r\n\r\n\tcol = col * 1.05 - 0.05;\r\n\t//col = col*col*(3.0-2.0*col);\r\n\tcol = FilmicToneMapping( col );\r\n\tcol = LinearToGamma( vec4(col, 1.0), 1.6 ).rgb;\r\n\r\n#ifdef ENABLE_SNOW\r\n\tcol += snowColor(0.2, 0.5);\r\n#endif\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 p = vec3( 0.0, 0.0, 95.0 + t );\r\n\tfloat a = smoothstep(5.0, 20.0, t);\r\n\tp.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tp.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tp.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tp.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\treturn -p;\r\n}\r\n\r\nmat3 cameraAutoView( in sampler2D heightTex0, out vec3 ro, out vec3 rd )\r\n{\r\n\tfloat curTime = 0.5*(time);//1.0\r\n#if 0\r\n    ro = vec3(0.0, 0.0, -95.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -105.0-curTime);\r\n#else\r\n\tro = cpath( curTime );\r\n\tvec3 ta = cpath( 2.0 + curTime );//10.0\r\n#endif\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 10.0, curTime) );\r\n\tro.y = terrainL( heightTex0, ro.xz ) + 0.1;//5.0\r\n\tta.y = ro.y - 1.5;//5.0\r\n\r\n    float fl = 1.0;//1.2;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n\treturn cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\tvec3 ro, rd;\r\n    mat3 cam = cameraAutoView( textureMaps[0], ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n\r\n#ifdef ENABLE_LENS_FLARES\r\n\tvec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\t#ifdef ENABLE_AUTO_VIEW\r\n\t\tapplyLensFlares( col, cam, xy, SUN_COLOR, SUN_LIGHT, 0.0 );\r\n\t#else\r\n\t\tapplyLensFlares( col, ro, cameraWorldMatrix, cameraProjectionMatrixInverse, xy, SUN_COLOR, SUN_LIGHT, 0.0 );\r\n\t#endif\r\n#endif\r\n\r\n\tcol = Vignetting( col, 0.5 );\r\n\tgl_FragColor = vec4( col, 1.0 );\r\n}"},3923:e=>{e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n#define map( pos )  sceneMap( pos ).x\r\n\r\n// textureMaps[0] = \'images/raymarch/pebbles.jpg\'\r\n// textureMaps[1] = \'images/raymarch/organic1.jpg\'\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n\r\n//==============================================================================\r\n// Desert Canyon\r\n// The far plane. I\'d like this to be larger, but the extra iterations required to render the \r\n// additional scenery starts to slow things down on my slower machine.\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n#define ENABLE_PHONG_LIGHTING\r\n\r\n// Choose...\r\n//#define DESERT_CAVE\r\n//#define SMOOTH_CAVE\r\n//#define HELL_CAVE\r\n#define CAVE_CANYON         // similar to DESERT_CAVE (default)\r\n//#define FLOATING_CANYON\r\n\r\n#define FAR 65.0\r\n\r\n// used in path function & used to shape the tunnel and guide the camera.\r\nconst float freqA = 0.15/3.75;\r\nconst float freqB = 0.25/2.75;\r\nconst float ampA = 20.0;\r\nconst float ampB = 4.0;\r\n\r\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies and amplitudes.\r\nvec2 path( in float z )\r\n{\r\n    return vec2( ampA*sin(z * freqA), ampB*cos(z * freqB) + 3.0*(sin(z*0.025) - 1.0) );\r\n}\r\n\r\n#ifdef DESERT_CAVE\r\n// The canyon, complete with hills, gorges and tunnels. I would have liked to provide a far\r\n// more interesting scene, but had to keep things simple in order to accommodate slower machines.\r\nfloat desertCanyon(in vec3 p)\r\n{\r\n    // Indexing into the pebbled texture to provide some rocky surface detatiling. I like this\r\n    // texture but I\'d much rather produce my own. From what I hear, Shadertoy will be providing\r\n    // fixed offscreen buffer sizes (like 512 by 512, for instance) at a later date. When that\r\n    // happens, I\'ll really be able to do some damage. :)\r\n\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(0.111));\r\n\r\n    // The terrain, so to speak. Just a flat XZ plane, at zero height, with some hills added.\r\n    float d = p.y + h*6.0;\r\n  \r\n    // Reusing "h" to provide an undulating base layer on the tunnel walls.\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// Producing a single winding tunnel. If you\'re not familiar with the process, this is it.\r\n    // We\'re also adding some detailing to the walls via "h" and the rocky "tx" value.\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n\t// Smoothly combine the terrain with the tunnel - using a smooth maximum - then add some\r\n    // detailing. I\'ve also added a portion of the tunnel term onto the end, just because\r\n    // I liked the way it looked more. \r\n    return fsmax(d, tunnel, 2.0) - tx*0.5 + tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef SMOOTH_CAVE\r\nfloat smoothCave(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n\r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*0.2 + h*20.0;\r\n  \r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n  \r\n\t// winding tunnel (adding details to the walls via "h" and the rocky "tx" value)\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n\t// combine terrain with the tunnel\r\n    //return fsmax(d, tunnel, 2.0) + tx*0.5 + tunnel*0.8;\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 + tunnel*0.8 + tunnel * tx;\r\n}\r\n#endif\r\n\r\n#ifdef HELL_CAVE\r\nfloat hellCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.15;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*3.1 + h*16.0;\r\n\r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 - tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef CAVE_CANYON\r\nfloat caveCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.24;\r\n    float freq = 2.8;\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y - h*20.0;\r\n\r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) - tx*0.5 + tunnel*0.8;\r\n}\r\n#endif\r\n\r\n#ifdef FLOATING_CANYON\r\nfloat floatingCanyon(in vec3 p)\r\n{\r\n    // rocky surface detailing\r\n    float tx = textureLod(iChannel0, p.xz/16.0 + p.xy/80.0, 0.0).x;\r\n  \r\n    // sinusoidal layers (to produce the rocky hills)\r\n    vec3 q = p*0.25;\r\n    float freq = 1.5;// The larger value, the more empty space in the internal space\r\n    float h = dot(sin(q)*cos(q.yzx), vec3(0.122)) + dot(sin(q*freq)*cos(q.yzx*freq), vec3(0.111));\r\n\r\n    // terrain (with some hills added)\r\n    float d = p.y*0.2 + h*22.0;\r\n  \r\n    // undulating base layer on the tunnel walls\r\n    q = sin(p*0.5 + h);\r\n    h = q.x*q.y*q.z;\r\n\r\n    // winding tunnel\r\n    p.xy -= path(p.z);\r\n    float tunnel = 1.5 - length(p.xy*vec2(0.33, 0.66)) + h + (1.0 - tx)*0.25;\r\n\r\n    // combine terrain with the tunnel\r\n    return fsmax(d, tunnel, 2.0) + tx*0.5 - tunnel*0.8;\r\n}\r\n#endif\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n#if defined( DESERT_CAVE )\r\n    return vec2( desertCanyon(p), 0.0 );\r\n\r\n#elif defined( SMOOTH_CAVE )\r\n    return vec2( smoothCave(p), 0.0 );\r\n\r\n#elif defined( HELL_CAVE )\r\n    return vec2( hellCanyon(p), 0.0 );\r\n\r\n#elif defined( CAVE_CANYON )\r\n    return vec2( caveCanyon(p), 0.0 );\r\n\r\n#elif defined( FLOATING_CANYON )\r\n    return vec2( floatingCanyon(p), 0.0 );\r\n\r\n#endif\r\n}\r\n\r\nvoid applyLighting( inout vec3 col, in vec3 p, in vec3 n, in vec3 ld, in vec3 rd )\r\n// ld = light direction from surface to light\r\n{\r\n    float diffuseIntensity = 3.0;\r\n    float specularIntensity = 1.0;//2.25;\r\n    float shininess = 16.0;\r\n    float F0 = 0.2;// F0(dielectric)=0.04, F0(water)=0.0204\r\n\r\n    //float shadow = sceneShadow(p, ld, 0.05, FAR, 8.0);\r\n    float shadow = sceneShadow(p+ld*0.05, ld, 0.05, FAR, 8.0);\r\n    float ao = sceneAO(p, n);\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float diffuse = max( dot(ld, n), 0.0) * diffuseIntensity;\r\n    float specular = pow( max(dot(n, h), 0.0), shininess) * specularIntensity;\r\n    float F = mix(F0, 1.0, pow(1.0 - max(dot(h,v),0.0), 5.0));// schlick approximation\r\n    float ambient = saturate( 0.3 + 0.1*n.y );\r\n    col = mix( col*(diffuse + ambient)*shadow*ao, vec3(specular*shadow), F );\r\n}\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\t// Screen coordinates\r\n\tvec2 u = (gl_FragCoord.xy - resolution.xy*0.5)/resolution.y;\r\n\t\r\n\t// Camera Setup.\r\n\tvec3 lookAt = vec3(0.0, 0.0, time*8.0);  // "Look At" position.\r\n\tvec3 ro = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\r\n \r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// Sending the camera and "look at" vectors down the tunnel. The "path" function is \r\n\t// synchronized with the distance function.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tro.xy += path(ro.z);\r\n\r\n    // Using the above to produce the unit ray-direction vector.\r\n    float FOV = 3.14159/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt-ro);\r\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n\r\n    // rd - Ray direction.\r\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\r\n    \r\n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\r\n    // Naturally, it\'s synchronized with the path in some kind of way.\r\n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n    vec2 u = ndc; // ndc = normalized device coordinates [-1, +1]\r\n#endif\r\n\r\n    // light position\r\n    vec3 lp = vec3(FAR*0.5, FAR, FAR) + vec3(0, 0, ro.z);\r\n\r\n    // sky & clouds\r\n#ifdef HELL_CAVE\r\n    vec3 sky = vec3(0.0, -0.0, -0.0);\r\n    applyClouds( sky, ro, rd );\r\n#else\r\n    vec3 sky = skyColor(normalize(lp - ro), rd, 1.0);\r\n    applyClouds( sky, ro, rd );\r\n#endif\r\n\r\n    vec3 col = sky;\r\n\r\n    // ray marching...\r\n    float t = rayTracing( ro, rd, 0.001, FAR, 0.3 );//0.4\r\n\r\n    gl_FragDepth = 0.99;\r\n    \r\n    // If we\'ve hit the ground, color it up.\r\n    if( t < FAR )\r\n    {\r\n#ifdef ENABLE_PHONG_LIGHTING\r\n        vec3 p = ro+t*rd;\r\n        vec3 n = sceneNormal( p, t );\r\n\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // light direction\r\n        vec3 ld = lp - p;\r\n        ld /= max( length(ld), 0.0001 );\r\n\r\n        // 0) bump normal (for details)\r\n        const float texScale = 0.2;\r\n        n = getBumpNormal(iChannel1, p*texScale, n, 0.01/(1.0 + t/FAR));\r\n\r\n        // 1) base color (soil) (see \'skin peeler\' for details)\r\n        col = mix( vec3(0.8, 0.5, 0.3), vec3(0.5, 0.25, 0.125), (p.y + 1.0)*0.15 );\r\n        col = clamp(col, vec3(0.5, 0.25, 0.125), vec3(1.0));\r\n\r\n        // 2) texture\r\n        col = smoothstep(-0.5, 1.0, texCube(iChannel1, p*texScale, n).rgb)*(col + 0.25);\r\n\r\n        // 3) anisotropic filtering (for crisp textures)\r\n        float crisp = 0.45;\r\n        col = saturate(col + noise13(p*48.0)*crisp - 0.15);\r\n\r\n        // 4) color in the crack ==> more darker\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n\r\n        // 5) sky reflection ===> almost ineffective\r\n        //col += skyColor(ld, reflect(rd, n), 1.0) * F * 0.2;\r\n\r\n        // 6) gamma correction\r\n        col = pow(col, vec3(2.2));\r\n\r\n        // 7) lighting\r\n        applyLighting( col, p, n, ld, rd );\r\n#else\r\n        vec3 p = ro+t*rd;\r\n        vec3 n = sceneNormal( p, t );\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        vec3 ld = lp - p;\r\n        ld /= max( length(ld), 0.0001 );\r\n\r\n        const float texScale = 1.0/6.0;\r\n        n = getBumpNormal(iChannel1, p*texScale, n, 0.007/(1.0 + t/FAR));\r\n\r\n        float shd = sceneShadow(p, ld, 0.05, FAR, 8.0);\r\n        float ao = sceneAO(p, n);\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n\r\n        vec3 v = -rd;\r\n        vec3 h = normalize(ld + v);\r\n        float dif = max( dot( ld, n ), 0.0);\r\n        float spe = pow( max(dot( n, h ),0.0), 5.0); // 5.0 = shininess\r\n        float fre = saturate(1.0 - dot(v, n)); // (1 - dotNV) for fresnel term\r\n\t\tfloat schlick = pow(1.0 - max(dot(rd, normalize(rd + ld)), 0.0), 5.0);\r\n\t\tfloat F = mix(0.2, 1.0, schlick);  // F0 (hard clay) = 0.2\r\n        float amb = fre*F + 0.06*ao;\r\n\r\n        col = mix( vec3(0.8, 0.5, 0.3), vec3(0.5, 0.25, 0.125), (p.y + 1.0)*0.15 );\r\n        col = clamp( col, vec3(0.5, 0.25, 0.125), vec3(1.0));\r\n        col = smoothstep(-0.5, 1.0, texCube(iChannel1, p*texScale, n).rgb)*(col + 0.25);\r\n        col = saturate(col + noise13(p*48.0)*0.3 - 0.15);\r\n        col = pow(col, vec3(1.5));\r\n        col *= smoothstep(0.0, 0.7, curv);\r\n        col += skyColor(ld, reflect(rd, n), 1.0)*fre*F*0.5;\r\n        col = (col*(dif + 0.1) + F*spe)*shd*ao + amb*col;\r\n#endif\r\n    }\r\n\r\n    // terrain + sky(with fog) ===> foggy terrain\r\n    col = mix(col, sky, sqrt(smoothstep(FAR - 15.0, FAR, t)));\r\n\r\n#ifdef ENABLE_DUST_WIND\r\n    #ifdef FLOATING_CANYON\r\n        float dustAmount = 0.005;\r\n    #else\r\n        float dustAmount = 0.01;\r\n    #endif\r\n    float dustHeight = 3.0;\r\n    float windTurbulency = 0.3;\r\n    applyDustWind( col, ro, rd, t, dustAmount, dustHeight, windTurbulency );\r\n#endif\r\n\r\n#ifdef ENABLE_PHONG_LIGHTING\r\n    col = pow(col, vec3(0.95)); // LinearToGamma\r\n#else\r\n    col = pow(max(col, 0.0), vec3(0.75));\r\n#endif\r\n\r\n    // vignetting\r\n#if 0\r\n    u = gl_FragCoord.xy / resolution.xy;\r\n    col *= pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y), 0.0625);\r\n#else\r\n    col = Vignetting( col, 0.5 );\r\n#endif\r\n\r\n\tgl_FragColor = vec4( saturate(col), 1.0 );\r\n}'},6512:e=>{e.exports="uniform sampler2D t_particle;\nuniform float curTime;\n\nvoid main()\n{\n  //vec4 col = vec4( 1.0, 0.3, 0.2, 1.0 );    // red flames\n  //vec4 col = vec4( 0.07, 0.09, 0.52, 1.0 );   // blue flames\n  vec4 col = vec4( 1.0 );\n  vec4 tex = texture2D( t_particle, gl_PointCoord );\n  gl_FragColor = vec4( col.rgb*tex.a, col.a*tex.a );\n}\n\n\n// vec4 getFlameColor(vec2 fragCoord)\n// {\n// \tfloat shift = 0.02;\n// \tvec2 speed = vec2(1.5);\n\n// \tconst vec3 c1 = vec3(0.0470588235, 0.0471698113, 0.278431373);\n// \tconst vec3 c2 = vec3(0.854901961, 0.862745098, 0.0150993377);\n// \tconst vec3 c3 = vec3(0.2, 0.0, 0.0);\n// \tconst vec3 c4 = vec3(0.635294118, 0.00392156863, 0.00460732984);\n// \tconst vec3 c5 = vec3(3.1);\n// \tconst vec3 c6 = vec3(1.151);\n\n//   // screen size\n//   // large monitor(4K): 2775 1500\n//   // small monitor(2K): 2066 1101\n//   vec2 screenSize = vec2(2066.0, 1101.0);\n\n// \tvec2 p = fragCoord.xy * 8.0 / screenSize.xx;\n// \tfloat q = fbm(p - curTime * 0.1);\n// \tvec2 r = vec2(fbm(p + q + curTime * speed.x - p.x - p.y), fbm(p + q - curTime * speed.y));\n// \tvec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n// \tfloat grad = fragCoord.y / screenSize.y;\n// \tvec4 color = vec4(c * cos(shift * fragCoord.y / screenSize.y), 1.0);\n// \tcolor.xyz *= 1.0-grad;\n// \treturn color;\n// }\n// void main()\n// {\n//   vec4 texColor = texture( t_particle, gl_PointCoord );//gl_PointCoord\n// \tif( texColor.a < 0.5 ) discard;\n//   //texColor.r += 0.5;\n\n// \tvec3 fragColor = vec3(0.75, 0.5, 0.5);\n//   vec4 flameColor = getFlameColor(gl_FragCoord.xy);//gl_FragCoord.xy\n//   fragColor = mix(fragColor.xyz, flameColor.xyz, 0.8);\n\n//   gl_FragColor = vec4( fragColor, 1.0 );\n// }"},5179:e=>{e.exports="uniform sampler2D t_oPos;\nuniform sampler2D t_pos;\nuniform vec2 resolution;\n\nuniform float dTime;\nuniform float curTime;\nuniform vec3 emitPos;       // emitter position (x,y,z)\nuniform vec3 emitVec;       // emit direction and its length (not needed for radialCurl)\nuniform float curlType;     // 0=radialCurl, 1=directionalCurl\nuniform float curlShape;    // shape of curl (0 ~ 1) ==> 0.0(rocketJet), 0.5(smoking), 1.0(floating)\nuniform float curlSpeed;    // moving speed of particles (0 ~ 1)\nuniform float curlSpread;   // level of spread of particles (0 ~ 1)\n\n// in vec2 vUv;\nvarying vec2 vUv;\n\n#ifndef RAYMARCH_SIMPLEX\n#define RAYMARCH_SIMPLEX\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626, // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i = floor(v + dot(v, C.yy) );\n  vec2 x0 = v - i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// Maintainer : ijm\n// Lastmod : 20110822 (ijm)\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n{\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n}\n\nfloat snoise(vec4 v)\n{\n  const vec4 C = vec4( 0.138196601125011, // (5 - sqrt(5))/20 G4\n                        0.276393202250021, // 2 * G4\n                        0.414589803375032, // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\n// First corner\n  vec4 i = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n// i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxxx\n  // x1 = x0 - i1 + 1.0 * C.xxxx\n  // x2 = x0 - i2 + 2.0 * C.xxxx\n  // x3 = x0 - i3 + 3.0 * C.xxxx\n  // x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0, ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\n#endif // RAYMARCH_SIMPLEX\n#ifndef RAYMARCH_CURL\n#define RAYMARCH_CURL\n\nvec3 snoiseVec3( vec3 x )\n{\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n}\n\nvec3 curlNoise( vec3 p )\n{\n  const float e = 1e-1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n\nvec4 snoiseVec4( vec4 x )\n{\n  float s  = snoise(vec4( x ));\n  float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.w + 47.2 , x.x + 12.2 ));\n  float s2 = snoise(vec4( x.z + 74.2 , x.w - 124.5 , x.x + 99.4 , x.y - 123.2 ));\n  float s3 = snoise(vec4( x.w + 21.2 , x.x - 52.5 , x.y + 60.4 , x.z + 42.2 ));\n  vec4 c = vec4( s , s1 , s2 , s3 );\n  return c;\n}\n\nvec4 curlNoise( vec4 p )\n{\n  const float e = 0.1;\n  vec4 dx = vec4( e   , 0.0 , 0.0 , 0.0 );\n  vec4 dy = vec4( 0.0 , e   , 0.0 , 0.0 );\n  vec4 dz = vec4( 0.0 , 0.0 , e   , 0.0 );\n  vec4 dw = vec4( 0.0 , 0.0 , 0.0 , e  );\n  vec4 p_x0 = snoiseVec4( p - dx );\n  vec4 p_x1 = snoiseVec4( p + dx );\n  vec4 p_y0 = snoiseVec4( p - dy );\n  vec4 p_y1 = snoiseVec4( p + dy );\n  vec4 p_z0 = snoiseVec4( p - dz );\n  vec4 p_z1 = snoiseVec4( p + dz );\n  vec4 p_w0 = snoiseVec4( p - dw );\n  vec4 p_w1 = snoiseVec4( p + dw );\n  float x = p_y1.z - p_y0.z - p_z1.w + p_z0.w + p_w0.y - p_w1.y;\n  float y = p_z1.w - p_z0.w - p_w1.x + p_w0.x + p_x0.z - p_x1.z;\n  float z = p_w1.x - p_w0.x - p_x1.y + p_x0.y + p_y0.w - p_y1.w;\n  float w = p_x1.y - p_x0.y - p_y1.z + p_y0.z + p_z0.x - p_y1.x;\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec4( x , y , z, w ) * divisor );\n}\n\n#endif // RAYMARCH_CURL\n\nfloat rand(vec2 co)\n{\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid radialCurl()\n{\n  //vec3 emitPos = vec3(0.0);\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  //vec4 oPos = texture2D( t_oPos, uv );\n  vec4 pos  = texture2D( t_pos, uv );\n\n  float shape = mix(0.04, 0.01, curlShape);\n  vec3 curl = curlNoise(vec4(pos.xyz * shape, curTime * 1.1 * 2.5)).xyz;\n  float speed = mix(0.5, 2.5, curlSpeed);\n  vec3 vel = curl * speed;\n\n  vec4 newPos;\n  newPos.xyz = pos.xyz + vel;\n  newPos.w = pos.w + dTime; // pos.w = particle's time of life (age)\n\n  if( newPos.w > 10.0 ) // died at 10(secs) old\n  {\n    newPos.xyz = emitPos;\n    float spread = mix(0.1, 200.0, curlSpread);\n    newPos.x += spread*(rand(uv*curTime+0.7)-0.5);\n    newPos.y += spread*(rand(uv*curTime+1.3)-0.5);\n    newPos.z += spread*(rand(uv*curTime+2.7)-0.5);\n    newPos.w = 10.0*rand(uv*curTime+3.9);\n  }\n\n  gl_FragColor = vec4( newPos.xyz, newPos.w );\n}\n\nvoid directionalCurl()\n{\n  float emitLength = length(emitVec);\n  vec3 emitDir = emitVec / emitLength;\n\n  //vec3 curlParams = vec3(0.5, 0.4, 0.0);// <== default\n  float shape = 0.5 * exp( -curlShape * 4.6 );\n  float speed = 0.5 + 5.0 * curlSpeed;\n  float spread = 0.1 + 2.0 * curlSpread;\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  //vec4 oPos = texture2D( t_oPos, uv );\n  vec4 pos  = texture2D( t_pos, uv );\n\n  vec3 curl = curlNoise(vec4(pos.xyz * shape, curTime * 0.5 * speed)).xyz;\n  vec3 vel = curl*0.1;\n\n  float t = dot(emitDir, pos.xyz - emitPos);\n  float v = pow(smoothstep(0.0, emitLength, t), 2.0);\n  v = 0.05 + v * (0.2 + rand(uv) * 0.2);\n  v = clamp(v, 0.01, 5.0);\n  vel += emitDir * v;\n  vel *= speed;\n  vec3 newPos = pos.xyz + vel * dTime*400.0;\n\n  t = dot(emitDir, newPos - emitPos);\n  if( t > emitLength ) {\n    newPos = emitPos;\n    newPos.x += emitLength*spread*(rand(uv + vec2(21.3, 63.21))-0.5);\n    newPos.y += emitLength*spread*(rand(uv + vec2(32.3, 734.21))-0.5);\n    newPos.z += emitLength*spread*(rand(uv + vec2(127.3, 31.21))-0.5);\n\n    t = dot(emitDir, newPos - emitPos);\n    if( t < 0.0 ) { newPos = newPos - t*emitDir; t = 0.0; }\n    vec3 tpos = emitPos + t*emitDir;\n    vec3 rvec = newPos - tpos;\n    float r = (1.0 - cos(smoothstep(0.0, 0.2*emitLength, t) * 3.141592654)) * 0.5;\n    newPos = newPos + (r-1.0) * rvec;\n  }\n\n  gl_FragColor = vec4( newPos, 1.0 );\n}\n\nvoid main()\n{\n  if( curlType < 0.5 )\n    radialCurl();       // curlType = 0.0\n  else\n    directionalCurl();  // curlType = 1.0\n}"},8083:e=>{e.exports="uniform sampler2D t_pos;\n\nvoid main()\n{\n  vec4 pos = texture2D( t_pos, position.xy );\n  float dist = length(cameraPosition - pos.xyz);\n\n  //gl_PointSize = clamp( 500.0 / dist, 10.0, 50.0 );\n  //gl_PointSize = max( 50.0 * exp(-0.005 * dist), 10.0 );\n  gl_PointSize = max( 20.0 - 0.1 * dist, 5.0 );\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos.xyz, 1.0 );\n}"},3806:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n//#define USE_CLOUDS_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/organic2.jpg' (1024 x 1024)\r\n// textureMaps[1] = 'images/raymarch/abstract1.jpg' (1024 x 1024)\r\n// textureMaps[2] = 'images/raymarch/grayNoise256.png' (256 x 256)\r\n// textureMaps[3] = 'images/raymarch/lichen.jpg' (1024 x 1024)\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n#define iChannel2   textureMaps[2]\r\n#define iChannel3   textureMaps[3]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_FISH_COLORING\r\n\r\nconst float FAR = 300.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(0.9,0.35,-0.2));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 100.0;\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\nconst vec3 UNDER_WATER_COLOR = vec3(0.0, 0.15, 0.25);\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nfloat aquaTerrainH( vec3 p )\r\n{\r\n    float h = 1.0;\r\n\tvec3 q = p;\r\n\tfloat th = smoothstep( 0.1, 0.4, textureLod( iChannel0, 0.002*q.xz, 0.0 ).x );\r\n    float rr = smoothstep( 0.2, 0.5, textureLod( iChannel1, 2.0*0.02*q.xz, 0.0 ).y );\r\n\th = 0.9 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.1*(1.0-textureLod( iChannel0, 0.1*q.xz, 0.0 ).x);\r\n\th += th * 1.25;\r\n    h -= 0.24 * rr;\r\n\th *= 0.75;\r\n    return -h;\r\n}\r\n\r\n// float aquaTerrainL( in sampler2D tex, in vec3 p )\r\n// {\r\n//     return aquaTerrainH( p );\r\n// }\r\n\r\nfloat aquaTerrainMap( vec3 p )\r\n{\r\n    // return (p.y - aquaTerrainH(p))*1.0;//0.3\r\n    return p.y - aquaTerrainH(p);\r\n}\r\n\r\nvec3 aquaTerrainColor( in vec3 rd, in vec3 pos, in vec3 nor )\r\n{\r\n    vec4 mate = vec4(0.5,0.5,0.5,0.0);\r\n\r\n    vec3 te = texture( iChannel0, 0.1*pos.xz ).xyz;\r\n    te = 0.05 + te;\r\n    mate.xyz = 0.6*te;          // material diffuse\r\n    mate.w = 5.0*(0.5+0.5*te.x);// material shininess\r\n\r\n    float th = smoothstep( 0.1, 0.4, texture( iChannel0, 0.002*pos.xz ).x );\r\n    vec3 dcol = mix( vec3(0.1, 0.1, 0.0), 0.4*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n    mate.xyz = mix( mate.xyz*0.5, dcol, th*smoothstep( 0.0, 1.0, nor.y ) );\r\n\r\n    float rr = smoothstep( 0.2, 0.4, texture( iChannel1, 2.0*0.02*pos.xz ).y );\r\n    mate.xyz *= mix( vec3(1.0), vec3(0.2,0.2,0.2)*1.5, rr );\r\n    mate.xyz *= 1.5;\r\n\r\n    // lighting\r\n    vec3 lig = SUN_LIGHT;\r\n    float sky = saturate(nor.y);\r\n    float bou = saturate(-nor.y);\r\n    float dif = max(dot(nor,lig),0.0);\r\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n    float sha = 0.0; if( dif>0.001 ) sha = sceneShadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n    float fre = pow( saturate( 1.0 + dot(nor,rd) ), 5.0 );\r\n    float spe = max( 0.0, pow( saturate( dot(lig, reflect(rd,nor)) ), mate.w ) ) * mate.w;\r\n    float sss = pow( saturate( 1.0 + dot(nor,rd) ), 3.0 );\r\n    \r\n    // water caustics...\r\n    float cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*time*vec2( 1.0, 0.0) ).x;\r\n          cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*time*vec2( 0.0, 1.0) ).x;\r\n          cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*time*vec2(-1.0,-1.0) ).x;\r\n    cc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n    dif *= 1.0 + 2.0*cc;\r\n\r\n    // lights\r\n    vec3 lin = vec3(0.0);\r\n    lin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n    lin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n    lin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n    lin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n    lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n    lin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\r\n    // surface-light interacion\r\n    vec3 col = mate.xyz * lin;\r\n    return col;\r\n}\r\n\r\n// fish type\r\n#define FISH_WINE_SNAPPER   0\r\n#define FISH_GREEN_SNAPPER  1\r\n#define FISH_RED_SNAPPER    2\r\n#define FISH_GOLD_SNAPPER   3\r\n#define FISH_AMERICAN_SHAD  4\r\n\r\n// (only for internal use)\r\nvec3 fshPos = vec3(0.0);    // global coords\r\nfloat fshTime = 0.0;        // fish motion time\r\nvec2 fshCoord = vec2(0.0);  // fish length coord + fish width coord\r\nvec3 fshSize = vec3(0.5);   // fish (width, height, length)\r\nint fshType = 0;            // fish type ==> FishMaterial*\r\n\r\n// Fish Definition\r\n// 1. geometry (fishPos, fishTime, fishSize)\r\n// 2. material (fishType)\r\n#define FISH_AMOUNT         4\r\n#define FISH_MAX_SIZE       10.0\r\nvec3 fishPos[FISH_AMOUNT];  // fish position in world space\r\nfloat fishTime[FISH_AMOUNT];// fish motion time\r\nvec3 fishSize[FISH_AMOUNT]; // fish (width, height, length)\r\nint fishType[FISH_AMOUNT];  // fish type ==> FishMaterial*\r\n\r\n// fish material(color) <=== fish type\r\nstruct FishMaterial {\r\n    float   shininess;      // 8.0;\r\n    vec3    upperBodyCol;   // vec3(0.24,0.17,0.22);\r\n    vec3    lowerBodyCol;   // vec3(1.0);\r\n    float   upperSideLine;  // 0.4;\r\n    float   lowerSideLine;  // 0.0;\r\n    vec3    tailCombCol;    // vec3(2.0,1.0,0.5);\r\n    vec3    tailPartCol;    // 0.9*vec3(2.6,1.5,1.0);\r\n    vec3    stripeCol;      // vec3(0.5);\r\n    float   bellyPattern;   // 50.0; (freq of belly pattern)\r\n    vec3    topFinCol;      // vec3(0.8,0.2,0.2);\r\n};\r\nFishMaterial getFishMaterial( int type )\r\n{\r\n    FishMaterial fish;\r\n    if( type == FISH_WINE_SNAPPER )\r\n    {\r\n        fish.shininess = 64.0;\r\n    #ifdef ENABLE_FISH_COLORING\r\n        fish.upperBodyCol = mix( vec3(0.3,0.17,0.17), vec3(0.17,0.17,0.17), 0.5+0.5*sin(time) );\r\n    #else\r\n        fish.upperBodyCol = vec3(0.3,0.17,0.17);\r\n    #endif\r\n        fish.lowerBodyCol = vec3(1.0);\r\n        fish.upperSideLine = 0.4;\r\n        fish.lowerSideLine = 0.0;\r\n        fish.tailCombCol = 1.0*vec3(2.0,1.0,0.5);\r\n        fish.tailPartCol = 0.9*vec3(2.6,1.5,1.0);\r\n        fish.stripeCol = vec3(0.5);\r\n        fish.bellyPattern = 50.0; // freq of belly pattern\r\n        fish.topFinCol = vec3(0.8,0.2,0.2);\r\n    }\r\n    else if( type == FISH_GREEN_SNAPPER )\r\n    {\r\n        fish.shininess = 32.0;//8.0;\r\n        fish.upperBodyCol = vec3(0.5,1.0,0.2);\r\n        fish.lowerBodyCol = vec3(0.9,0.7,0.5);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.6;\r\n        fish.tailCombCol = vec3(1.0,1.0,0.0);\r\n        fish.tailPartCol = vec3(1.0,1.0,0.0);\r\n        fish.stripeCol = vec3(1.0,0.0,1.0);\r\n        fish.bellyPattern = 75.0;//50.0;\r\n        fish.topFinCol = vec3(1.5,0.0,0.0);\r\n    }\r\n    else if( type == FISH_RED_SNAPPER )\r\n    {\r\n        fish.shininess = 64.0;//8.0;\r\n    #ifdef ENABLE_FISH_COLORING\r\n        fish.upperBodyCol = mix( vec3(1.5,0.4,0.2), vec3(0.2,1.5,0.4), 0.5+0.5*sin(time) );\r\n    #else\r\n        fish.upperBodyCol = vec3(1.5,0.4,0.2);\r\n    #endif\r\n        fish.lowerBodyCol = vec3(0.9,0.7,0.5);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.6;\r\n        fish.tailCombCol = vec3(1.0,1.0,0.0);\r\n        fish.tailPartCol = vec3(1.0,1.0,0.0);\r\n        fish.stripeCol = vec3(1.5,0.1,0.1);\r\n        fish.bellyPattern = 75.0;//50.0;\r\n        fish.topFinCol = vec3(1.5,0.0,0.0);\r\n    }\r\n    else if( type == FISH_GOLD_SNAPPER ) // Goldfish\r\n    {\r\n        fish.shininess = 8.0;\r\n        fish.upperBodyCol = vec3(0.9, 0.34, 0.07);\r\n        fish.lowerBodyCol = vec3(0.85, 0.84, 0.81);\r\n        fish.upperSideLine = 0.2;\r\n        fish.lowerSideLine = -0.5;\r\n        fish.tailCombCol = vec3(0.77, 0.48, 0.11);\r\n        fish.tailPartCol = vec3(0.83, 0.38, 0.1);\r\n        fish.stripeCol = vec3(0.88, 0.31, 0.15);\r\n        fish.bellyPattern = 20.0;//50.0;\r\n        fish.topFinCol = vec3(0.85, 0.13, 0.0);\r\n    }\r\n    else if( type == FISH_AMERICAN_SHAD )\r\n    {\r\n        fish.shininess = 8.0;\r\n        fish.upperBodyCol = vec3(0.22, 0.35, 0.32);\r\n        fish.lowerBodyCol = vec3(0.88, 0.91, 0.89);\r\n        fish.upperSideLine = 0.4;\r\n        fish.lowerSideLine = 0.1;\r\n        fish.tailCombCol = vec3(0.65, 0.71, 0.6);\r\n        fish.tailPartCol = vec3(0.58, 0.62, 0.32);\r\n        fish.stripeCol = vec3(0.22, 0.35, 0.32);\r\n        fish.bellyPattern = 10.0;//50.0;\r\n        fish.topFinCol = vec3(0.42, 0.41, 0.33);\r\n    }\r\n    return fish;\r\n}\r\n\r\nvec2 vSegment( vec3 a, vec3 b, vec3 p )\r\n// segment (has the length from a to b) \r\n// return.x = d * d (d = distance from p to segment)\r\n// return.y = t (where a + t(b-a) = projection of p to segment) (0 < t < 1)\r\n{\r\n\tvec3  pa = p - a;\r\n\tvec3  ba = b - a;\r\n\tfloat t = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\tvec3  v = pa - ba*t;\r\n\treturn vec2( dot(v,v), t );\r\n}\r\nfloat fishMap( in vec3 p )\r\n// return dist from p to fish\r\n// p ==> fishPos[i] ==> i ==> (fshPos, fshTime, fshSize, fshType, fshCoord)\r\n{\r\n    // vec3 spacing = vec3(3.0, 0.0, 7.0);\r\n    // p = sRepeat( p, spacing );\r\n    // p = sRotateY( p, PI*2.0 );\r\n\r\n    //\r\n    // find fishPos[i] which is the closest to p\r\n    //\r\n    float minDist = 1000.0;\r\n    for(int i=0; i<FISH_AMOUNT; i++)\r\n    {\r\n        float dist = length( p - fishPos[i] );\r\n        if( dist < minDist )\r\n        {\r\n            minDist = dist;\r\n            fshPos = fishPos[i];\r\n            fshTime = fishTime[i];\r\n            fshSize = fishSize[i];\r\n            fshType = fishType[i];\r\n        }\r\n    }\r\n\r\n    // res.x = distance from p to fish\r\n    // res.y = fish length coord\r\n    // res.z = fish width coord\r\n    vec3 res = vec3( 1000.0, 0.0, 0.0 );\r\n\r\n\tp -= fshPos;\r\n\r\n    if( dot(p,p) > FISH_MAX_SIZE*FISH_MAX_SIZE ) return FISH_MAX_SIZE;\r\n\r\n    float fishW = mapLinear( fshSize.x, 0.0, 1.0, 2.5, 0.8 ); // fish width:  2.5(thin) ~ 0.8(fat)\r\n    float fishH = mapLinear( fshSize.y, 0.0, 1.0, 1.2, 0.5 ); // fish height: 1.2(short) ~ 0.5(tall)\r\n    float fishL = mapLinear( fshSize.z, 0.0, 1.0, 2.0, 0.5 ); // fish length: 3.0(short) ~ 0.5(long)\r\n    p *= vec3(fishW, fishH, fishL);\r\n\r\n\tvec3 q = p;\r\n\t\r\n    vec3 a = vec3(0.0);\r\n\ta.x -= 0.25*sin(8.0 * 0.2 * fshTime);\r\n\tvec3 oa = a;\r\n\r\n\tfloat or = 0.0;\r\n\tfloat th = 0.0;\r\n\tfloat hm = 0.0;\r\n\r\n\tconst int NUMI = 7;\r\n\tconst float NUMF = 7.0;\r\n\tvec3 p1 = a; vec3 d1 = vec3(0.0);\r\n\tvec3 p2 = a; vec3 d2 = vec3(0.0);\r\n\tvec3 mp = a;\r\n\tfor(int i=0; i<NUMI; i++)\r\n\t{\t\r\n\t\tfloat ih = float(i)/NUMF;\r\n\t\tfloat ang = or + 1.0*(0.2+0.8*ih)*sin(3.0*ih - 2.0*fshTime);\r\n\t\tfloat ll = 0.26; if( i == (NUMI-1) ) ll = 0.4;\r\n\t\tvec3 b = a + ll*vec3(sin(ang), 0.0, cos(ang))*(16.0/NUMF);\r\n\r\n\t\tvec2 dis = vSegment( a, b, p );\r\n\r\n\t\tif( dis.x < res.x ) {\r\n            res = vec3(dis.x, ih + dis.y / NUMF, 0.0);\r\n            mp = a + (b - a)*dis.y;\r\n        }\r\n\r\n\t\tif( i == 1 ) { p1 = a; d1 = b - a; }\r\n\r\n\t\ta = b;\r\n\t}\r\n\tfloat h = res.y;\r\n\tfloat ra = 0.04 + h*(1.0-h)*(1.0-h)*2.7;\r\n\r\n\t// tail\r\n\tp.y /= 1.0 + 14.0*(1.0-smoothstep( 0.0, 0.13, 1.0-h));\r\n    p.z += 0.08*(1.0-saturate(abs(p.y)/0.075))*(1.0-smoothstep(0.0,0.1,1.0-h));\r\n\tres.x = 0.75 * (distance(p, mp) - ra);\r\n\t\r\n\t// mouth\r\n\tfloat d3 = 0.75*( length((p-oa)*vec3(0.5,2.0,1.0)) - 0.12 );\r\n\tres.x = max( -d3, res.x );\r\n\r\n\t// upper central fin\r\n\tfloat fh = smoothstep(0.15,0.2,h) - smoothstep(0.25,0.8,h);\r\n\tfh -= 0.2*pow(0.5+0.5*sin(210.0*h),0.2)*fh;\r\n\td3 = length(p.xz-mp.xz) - 0.01;\r\n    d3 = max( d3, p.y - (mp.y+ra+0.2*fh) );\r\n\td3 = max( d3, -p.y - 0.0 );\r\n\tres.x = min( res.x, d3 );\r\n\r\n\t// fins\r\n\td1.xz = normalize(d1.xz);\r\n\r\n\tfloat flap = 0.7 + 0.3*sin(2.0*8.0*0.2*fshTime);\r\n    vec2 dd = normalize(d1.xz + sign((p-p1).x)*flap*d1.zx*vec2(-1.0,1.0));\r\n\tmat2 mm = mat2( dd.y, dd.x, -dd.x, dd.y );\r\n\r\n\tvec3 sq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += -0.15;\r\n\tfloat d = length( (sq-vec3(0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, fBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d < res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = fsmin( d, res.x, 0.05 );\r\n\r\n\tsq = p-p1;\r\n\tsq.xz = mm*sq.xz;\r\n\tsq.y += 0.2;\r\n\tsq.x += 0.15;\r\n\td = length( (sq-vec3(-0.5,0.0,0.0))*vec3(1.0,2.0,1.0) ) - 0.3;\r\n\td = 0.5*max( d, fBox( sq, vec3(1.0,1.0,0.01) ) );\r\n    if( d < res.x ) res.z = smoothstep( 0.2, 0.7, sq.x );\r\n\tres.x = fsmin( d, res.x, 0.05 );\r\n\r\n    fshCoord = res.yz;\r\n\r\n\treturn res.x;\r\n}\r\n\r\nvec3 fishColor( in vec3 rd, in vec3 pos, in vec3 nor, \r\n    in vec3 fshPos, in float fshTime, in vec2 fshCoord, in vec3 fshSize, in int fshType )\r\n// fshPos, fshTime, fshCoord, fshSize ==> (geometry data)\r\n// fshType ==> FishMaterial ==> (material(color) data)\r\n{\r\n    FishMaterial fish = getFishMaterial( fshType );\r\n\r\n    // whole body\r\n    vec4 mate = vec4(0.0);\r\n    mate.xyz = fish.upperBodyCol; // material diffuse\r\n    mate.w = fish.shininess;      // material shininess\r\n    vec3 te = 0.8+2.2*texture( iChannel0, vec2(2.0*fshCoord.x,pos.y) ).xyz;\r\n    mate.xyz *= te;\r\n    \r\n    // belly/backfin\r\n    vec3 tailCol = mix( 1.0+0.5*sin(150.0*pos.y - sign(pos.y)*fshCoord.x*300.0), // <=== pattern of tail comb\r\n                        1.0, smoothstep(0.0,0.1,1.0-fshCoord.x) ) * fish.tailPartCol;  // <=== tail part\r\n    tailCol += (1.0-smoothstep(0.0,0.09,1.0-fshCoord.x)) * fish.tailCombCol;\r\n    float iscola = smoothstep( 0.0, 0.2, 1.0-fshCoord.x );\r\n    mate.xyz = mix( mix( vec3(te.x*0.5 + 1.5), tailCol, 1.0-iscola ) * 0.5, // <=== lower body\r\n                    mate.xyz,                                               // <=== upper body\r\n                    smoothstep(fish.lowerSideLine, fish.upperSideLine, nor.y) // upper if nor.y > upperSideLine, lower if nor.y < lowerSideLine\r\n                );\r\n\r\n    // stripes\r\n    mate.xyz = mix( mate.xyz, \r\n                    (te.x+0.5)*1.0*fish.stripeCol, \r\n                    0.75*smoothstep( 0.5, 1.0, sin(1.0*te.x + fshCoord.x*100.0 + 13.0*nor.y) )*smoothstep(0.0,0.5,nor.y) );\r\n\r\n    // escamas\r\n    float ll = saturate( (fshCoord.x-0.2)/(0.8-0.2) );\r\n    float ha = 1.0-4.0*ll*(1.0-ll);\r\n    float pa = smoothstep( -1.0+2.0*ha, 1.0, sin(fish.bellyPattern*(pos.y-fshPos.y) ) ) * smoothstep( -1.0, 0.0, sin( 560.0*fshCoord.x ) );\r\n    pa *= 1.0-smoothstep( 0.1, 0.2, nor.y );\r\n    mate.xyz *= 0.5 + 0.5*fish.lowerBodyCol * (1.0-pa);\r\n\r\n    // eye\r\n    float r = length(vec2(5.0*fshCoord.x,pos.y)-vec2(0.5,0.13+fshPos.y) );\r\n    r /= 1.2;\r\n    mate.xyz = mix( mate.xyz, vec3(1.5)*saturate(1.0-r*4.0), 0.5*(1.0-smoothstep(0.08,0.09,r)) );\r\n    mate.xyz *= smoothstep(0.03,0.05,r);\r\n    mate.xyz += vec3(4.0)*(1.0-smoothstep(0.0,0.1,r))*\r\n        pow( texture( iChannel1, 4.0*vec2(0.2*fshPos.z+4.0*fshCoord.x, pos.y) ).x, 2.0 );\r\n    r = length(vec2(5.0*fshCoord.x,pos.y)-vec2(0.48,0.14) );\r\n    mate.xyz = mix( mate.xyz, vec3(2.0), (1.0-smoothstep(0.0,0.02,r)) );\r\n    \r\n    // mouth\r\n    vec3 oa = fshPos;\r\n    oa.x -= 0.25*sin(8.0*0.2*fshTime);\r\n    mate.xyz *= 0.1 + 0.9*step( 0.0, length( (pos - oa+vec3(0.0,0.0,-0.02))*vec3(1.5,2.0,1.0) ) - 0.14 );\r\n    \r\n    // top fin\r\n    float fh = smoothstep(0.15,0.2,fshCoord.x) - smoothstep(0.25,0.8,fshCoord.x);\r\n    float ra = 0.04 + fshCoord.x*(1.0-fshCoord.x)*(1.0-fshCoord.x)*2.7;\r\n    float vv = saturate( (pos.y-fshPos.y-fshSize.y-ra-0.1) / 0.2 );\r\n    vec3 fincol = mix( 1.0+0.5*sin(520.0*fshCoord.x), 1.0, vv ) * mix( fish.topFinCol, vec3(1.5,1.4,1.5), vv );\r\n    mate.xyz = mix( mate.xyz, fincol, fh*smoothstep(0.0,0.05,pos.y-fshPos.y-fshSize.y-ra-0.1) );\r\n    \r\n    // side fins\r\n    float isFin = fshCoord.y;\r\n    fincol = 0.5*vec3(3.0,2.0,2.0) * mix(1.0+0.2*sin(150.0*pos.y),1.0,0.0);\r\n    mate.xyz = mix( mate.xyz, fincol, isFin );\r\n    mate.xyz *= 0.17;\r\n\r\n    // lighting\r\n    vec3 lig = SUN_LIGHT;\r\n    float sky = saturate(nor.y);\r\n    float bou = saturate(-nor.y);\r\n    float dif = max(dot(nor,lig),0.0);\r\n    float bac = max(0.3 + 0.7*dot(nor,-vec3(lig.x,0.0,lig.z)),0.0);\r\n    float sha = 0.0; if( dif>0.001 ) sha = sceneShadow( pos+0.01*nor, lig, 0.0005, 32.0 );\r\n    float fre = pow( saturate( 1.0 + dot(nor,rd) ), 5.0 );\r\n    float spe = max( 0.0, pow( saturate( dot(lig, reflect(rd,nor)) ), mate.w ) ) * mate.w;\r\n    float sss = pow( saturate( 1.0 + dot(nor,rd) ), 3.0 );\r\n    \r\n    // lights\r\n    vec3 lin = vec3(0.0);\r\n    float cc  = 0.55*texture( iChannel2, 1.8*0.02*pos.xz + 0.007*time*vec2( 1.0, 0.0) ).x;\r\n          cc += 0.25*texture( iChannel2, 1.8*0.04*pos.xz + 0.011*time*vec2( 0.0, 1.0) ).x;\r\n          cc += 0.10*texture( iChannel2, 1.8*0.08*pos.xz + 0.014*time*vec2(-1.0,-1.0) ).x;\r\n    cc = 0.6*(1.0-smoothstep( 0.0, 0.025, abs(cc-0.4))) + 0.4*(1.0-smoothstep( 0.0, 0.150, abs(cc-0.4)));\r\n    dif *= 1.0 + 2.0*cc;\r\n\r\n    lin += 3.5*dif*vec3(1.00,1.00,1.00)*sha;\r\n    lin += 3.0*sky*vec3(0.10,0.20,0.35);\r\n    lin += 1.0*bou*vec3(0.20,0.20,0.20);\r\n    lin += 2.0*bac*vec3(0.50,0.60,0.70);\r\n    lin += 2.0*sss*vec3(0.20,0.20,0.20)*(0.2+0.8*dif*sha)*mate.w;\r\n    lin += 2.0*spe*vec3(1.0)*sha*(0.3+0.7*fre);\r\n\r\n    // material-light interacion\r\n    vec3 col = mate.xyz * lin;\r\n    return col;\r\n}\r\n\r\n//===========================================================\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( aquaTerrainMap(p), MATERIAL_TERRAIN ) );\r\n    res = dUnion( res, vec2( fishMap(p), MATERIAL_FISH ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        applyClouds( col, iChannel2, ro, rd );\r\n\t}\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 pos = ro + rd * tm.x;\r\n        vec3 nor = sceneNormal( pos );\r\n        gl_FragDepth = getFragDepth( pos );\r\n\r\n        col = aquaTerrainColor( rd, pos, nor );\r\n    }\r\n    else if( tm.y == MATERIAL_FISH )\r\n    {\r\n        vec3 pos = ro + rd * tm.x;\r\n        vec3 nor = sceneNormal( pos );\r\n        gl_FragDepth = getFragDepth( pos );\r\n\r\n        col = fishColor( rd, pos, nor, fshPos, fshTime, fshCoord, fshSize, fshType );\r\n    }\r\n\r\n    // fog under the water...\r\n    col *= 0.65;\r\n#ifdef ENABLE_AUTO_VIEW\r\n    float density = 0.005;//0.01;\r\n#else\r\n    float density = 0.025;//0.2;\r\n#endif\r\n    //float t = max(0.0, tm.x-1.3);\r\n    float t = max(0.0, tm.x);\r\n    float h = 1.0-exp(-density*t);\r\n    col = mix( col*(1.0-h), UNDER_WATER_COLOR, h );\r\n\r\n    // water surface...\r\n#if 1\r\n    if( rd.y < 0.0 )\r\n    {\r\n        float waterHeight = 2.0;//2.0\r\n\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro - vec3(0.0, waterHeight, 0.0), rd, vec4(0.0) );//cloudy = 0.0\r\n        if( 0.0 < waterCol.w && waterCol.w < tm.x )\r\n        {\r\n            // foam on water...\r\n            float t = (waterHeight-ro.y)/rd.y;\r\n            vec2 uv = (ro + rd * t).xz;\r\n            float sur = texture( iChannel3, 0.06*uv ).x;\r\n            sur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2, 1.0, texture( iChannel2, 1.0*uv ).x);\r\n            waterCol.rgb = mix( waterCol.rgb, vec3(2.5), 0.5*sur ); // foamCol = vec3(2.5)\r\n\r\n            // sun specular...\r\n            // float sunAmount = saturate( dot(SUN_LIGHT, reflect( rd, vec3(0.0,1.0,0.0) ) ) );\r\n            // waterCol.rgb += 0.2*vec3(1.0,0.95,0.9)*pow(sunAmount,16.0);\r\n            // waterCol.rgb += 0.5*vec3(1.0,0.95,0.9)*pow(sunAmount,96.0);\r\n\r\n            col = mix(col, waterCol.rgb, saturate(1.1+rd.y));\r\n        }\r\n    }\r\n#endif\r\n\r\n    // post-processing\r\n    col = pow( saturate(col), vec3(0.45) );\r\n    col = mix( col, vec3(dot(col,vec3(0.333))), -0.5 );\r\n\tcol = 0.5*col + 0.5*col*col*(3.0-2.0*col);\r\n    // col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\r\n\tcol *= smoothstep( 0.0, 1.0, time );\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 0.2*time;\r\n\tvec3 ta = fishPos[0] - vec3(2.0, 0.0, -2.0);\r\n    ta.y += 2.0*sin(time);\r\n\r\n    float r = 12.0;//8.0;\r\n\tro = ta + vec3(r*sin(curTime), r, r*cos(curTime));\r\n\r\n    float fl = 2.5;//2.0 1.2\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta );\r\n\trd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    // setup for fish animation...\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\n    float speedScale = 1.0;//0.7;\r\n#else\r\n    float speedScale = 0.0;\r\n#endif\r\n\r\n    fishTime[0] = time + 1.1;\r\n    fishTime[1] = time + 2.2;\r\n    fishTime[2] = time + 0.1;\r\n    fishTime[3] = time + 1.5;\r\n\r\n#ifdef ENABLE_FISH_COLORING\r\n    fishPos[0] = vec3( 0.0, 0.0, -speedScale*fishTime[0] );\r\n    fishPos[1] = vec3( 4.5, 1.0+0.5*sin(time), -speedScale*fishTime[1] );\r\n    fishPos[2] = vec3( -5.0, 0.2, -speedScale*fishTime[2] );\r\n    fishPos[3] = vec3( -9.5, 0.3+0.5*sin(time+0.5), -speedScale*fishTime[3] );\r\n\r\n    fishSize[0] = vec3(0.5+0.3*sin(time), 0.5, 0.65+0.25*sin(time)); // fish (width, height, length)\r\n    fishSize[1] = vec3(0.7, 0.0, 0.7);\r\n    fishSize[2] = vec3(0.3, 0.5+0.3*sin(time), 0.8);\r\n    fishSize[3] = vec3(0.5+0.3*sin(time), 0.5, 0.4+0.25*sin(time));\r\n#else\r\n    fishPos[0] = vec3( 0.0, 0.0, -speedScale*fishTime[0] );\r\n    fishPos[1] = vec3( 4.5, 0.4, -speedScale*fishTime[1] );\r\n    fishPos[2] = vec3( -5.0, 0.2, -speedScale*fishTime[2] );\r\n    fishPos[3] = vec3( -9.5, 0.3, -speedScale*fishTime[3] );\r\n\r\n    fishSize[0] = vec3(0.5, 0.5, 0.9); // fish (width, height, length)\r\n    fishSize[1] = vec3(0.7, 0.0, 0.7);\r\n    fishSize[2] = vec3(0.3, 0.7, 0.6);\r\n    fishSize[3] = vec3(0.8, 0.5, 0.5);\r\n#endif\r\n\r\n    fishType[0] = FISH_WINE_SNAPPER;    // purple(wine)\r\n    fishType[1] = FISH_GREEN_SNAPPER;   // green\r\n    fishType[2] = FISH_RED_SNAPPER;     // red\r\n    fishType[3] = FISH_GOLD_SNAPPER;    // gold\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = LinearToGamma( vec4( col, 1.0 ), 0.35 ); // 0.3 ~ 0.5\r\n}"},456:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_CLOUDS_2\r\n#define USE_TERRAIN_2\r\n#define USE_TREES_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n#define iChannel0   textureMaps[0]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 500.0;//300.0;\r\nconst vec3 SUN_LIGHT = vec3(-0.624695,0.468521,-0.624695);\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 500.0;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( terrainMap( iChannel0, p ), MATERIAL_TERRAIN ) );\r\n    res = dUnion( res, vec2( treesMap( iChannel0, p ), MATERIAL_TREES ) );\r\n    //res = dUnion( res, vec2( cloudsMap( p ).x, MATERIAL_CLOUDS ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    // raymarch ==> intersection\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        // sky & clouds\r\n        col = skyCloudsColor( iChannel0, SUN_COLOR, SUN_LIGHT, ro, rd );\r\n\r\n        // clouds(volumetric)\r\n        vec4 cloudsCol = cloudsColor( SUN_LIGHT, ro, rd, 0.0, FAR );//1000.0\r\n        #if 0\r\n            col = col*(1.0-cloudsCol.w) + cloudsCol.xyz;\r\n        #else\r\n            col = mix( col, cloudsCol.xyz, cloudsCol.w );\r\n        #endif\r\n\t}\r\n\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n        col = terrainColor( iChannel0, SUN_LIGHT, rd, p, tm.x );\r\n    }\r\n    else if( tm.y == MATERIAL_TREES )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n        col = treesColor( iChannel0, SUN_LIGHT, p, rd, tm.x );\r\n    }\r\n\r\n    // fog\r\n    applyFog( col, FOG_COLOR, 0.003, tm.x*0.5 );\r\n\r\n    // sun glare\r\n    col += sunScatter( SUN_LIGHT, rd );\r\n\r\n    // color grading\r\n#if 0\r\n    col = col*0.15 + 0.85*col*col*(3.0-2.0*col); // contrast\r\n    col = pow( col, vec3(1.0,0.92,1.0) );  // soft green\r\n    col *= vec3(1.02,0.99,0.99);           // tint red\r\n    col.z = (col.z+0.1)/1.1;               // bias blue\r\n    col = mix( col, col.yyy, 0.15 );       // desaturate\r\n    col = saturate( col );\r\n#endif\r\n\r\n    col = FilmicToneMapping( col );\r\n    col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n    return col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 10.0*time;\r\n    ro = vec3(0.0, 0.0, -80.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -90.0-curTime);\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 500.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xz ) + 30.0;//20.0 30.0\r\n    ta.y = ro.y - 2.0;\r\n\r\n    float fl = 1.2;//1.0;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n}"},5243:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n#define iChannel0   textureMaps[0]\r\n\r\n//CBS\r\n//Parallax scrolling fractal galaxy.\r\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\r\n\r\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\r\nfloat field(in vec3 p,float s) {\r\n\tfloat strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.0;\r\n\tfloat prev = 0.0;\r\n\tfloat tw = 0.0;\r\n\tfor (int i = 0; i < 26; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-0.5, -0.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.0);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0.0, 5.0 * accum / tw - 0.7);\r\n}\r\n\r\n// less iterations for second layer\r\nfloat field2(in vec3 p, float s) {\r\n\tfloat strength = 7.0 + 0.03 * log(1.e-6 + fract(sin(time) * 4373.11));\r\n\tfloat accum = s/4.0;\r\n\tfloat prev = 0.0;\r\n\tfloat tw = 0.0;\r\n\tfor (int i = 0; i < 18; ++i) {\r\n\t\tfloat mag = dot(p, p);\r\n\t\tp = abs(p) / mag + vec3(-0.5, -0.4, -1.5);\r\n\t\tfloat w = exp(-float(i) / 7.0);\r\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\r\n\t\ttw += w;\r\n\t\tprev = mag;\r\n\t}\r\n\treturn max(0.0, 5.0 * accum / tw - 0.7);\r\n}\r\n\r\nvec3 nrand3( vec2 co )\r\n{\r\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3( 1.3e5, 4.7e5, 2.9e5 ) );\r\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3( 8.1e5, 1.0e5, 0.1e5 ) );\r\n\tvec3 c = mix(a, b, 0.5);\r\n\treturn c;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv = 2.0 * fragCoord.xy / resolution.xy - 1.0;\r\n\tvec2 uvs = uv * resolution.xy / max(resolution.x, resolution.y);\r\n\tvec3 p = vec3(uvs/4.0, 0.0) + vec3(1.0, -1.3, 0.0);\r\n\tp += 0.2 * vec3(sin(time / 16.0), sin(time / 12.0),  sin(time / 128.0));\r\n\r\n\tfloat freqs[4];\r\n\t// sound\r\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\r\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\r\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\r\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\r\n\r\n\tfloat t = field(p, freqs[2]);\r\n\tfloat v = (1.0 - exp((abs(uv.x) - 1.0) * 6.0)) * (1.0 - exp((abs(uv.y) - 1.0) * 6.0));\r\n\r\n    // second Layer\r\n\tvec3 p2 = vec3(uvs / (4.0 + sin(time*0.11)*0.2 + 0.2 + sin(time*0.15)*0.3 + 0.4), 1.5) + vec3(2.0, -1.3, -1.0);\r\n\tp2 += 0.25 * vec3(sin(time/16.0), sin(time/12.0), sin(time/128.0));\r\n\tfloat t2 = field2(p2, freqs[3]);\r\n\tvec4 c2 = mix(0.4, 1.0, v) * vec4(1.3*t2*t2*t2, 1.8*t2*t2, t2*freqs[0], t2);\r\n\r\n\t// let's add some stars\r\n\t// thanks to http://glsl.heroku.com/e#6904.0\r\n\tvec2 seed = p.xy * 2.0;\t\r\n\tseed = floor(seed * resolution.x);\r\n\tvec3 rnd = nrand3( seed );\r\n\tvec4 starcolor = vec4(pow(rnd.y, 27.0)); // 40.0 => 27.0\r\n\r\n\t// second Layer\r\n\tvec2 seed2 = p2.xy * 2.0;\r\n\tseed2 = floor(seed2 * resolution.x);\r\n\tvec3 rnd2 = nrand3( seed2 );\r\n\tstarcolor += vec4(pow(rnd2.y, 27.0)); // 40.0 => 27.0\r\n\r\n\tfragColor = mix(freqs[3]-0.3, 1.0, v) * vec4(1.5*freqs[2]*t*t*t, 1.2*freqs[1]*t*t, freqs[3]*t, 1.0) + c2 + starcolor;\r\n}\r\n\r\nvoid main()\r\n{\r\n    gl_FragDepth = 0.99;\r\n    mainImage( gl_FragColor, gl_FragCoord.xy );\r\n\tgl_FragColor = LinearToGamma( vec4(gl_FragColor.xyz, 1.0), 0.75 ); // jamie\r\n}"},2387:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\n\n//==============================================================================\n// Enables\n//==============================================================================\n\n//#define ENABLE_TEST_RENDER\n\n// Choose...\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n// ENABLE_SPECULAR(o) && ENABLE_REFLECTIONS(o) ==> glossy, mirror\n// ENABLE_SPECULAR(o) && ENABLE_REFLECTIONS(x) ==> glossy only\n// ENABLE_SPECULAR(x) && ENABLE_REFLECTIONS(o) ==> no glossy, no mirror\n// ENABLE_SPECULAR(x) && ENABLE_REFLECTIONS(x) ==> no glossy, no mirror\n#define ENABLE_TRANSPARENCY\n#define ENABLE_DOUBLE_TRANSPARENCY\n#define ENABLE_FOG\n#define ENABLE_BUMP_MAPPING\n//#define ENABLE_SUBSURFACE\t\t// <=== not complete...\n\n// Choose...\n#define ENABLE_SHADOW\n#define ENABLE_AO\n\n// Choose...\n#define ENABLE_SUNDIR_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n//#define ENABLE_POINT_LIGHT_FLARE\n\n// Choose...\n//#define DEMO_REPEAT_SPHERES\n//#define DEMO_PRIMITIVES\n#define DEMO_TEST\n\n#ifdef DEMO_PRIMITIVES\n\t#undef ENABLE_TRANSPARENCY\n\t#undef ENABLE_DOUBLE_TRANSPARENCY\n\t#undef ENABLE_FOG\n\t#undef ENABLE_REFLECTIONS\n\t#undef ENABLE_SPECULAR\n#endif\n\n//==============================================================================\n// constants\n//==============================================================================\n\nconst vec3 SUN_LIGHT = normalize(vec3(0.4, 0.4, -0.48));\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.83);\n\nconst float FAR = 100.0;\nconst float airIOR = 1.0003;\nconst float fogDensity = 0.001;//0.05\n\nconst float kMaterialSky = 0.0;\nconst float kMaterialChecker = 1.0;\nconst float kMaterialGround = 2.0;\nconst float kMaterialGold = 3.0;\nconst float kMaterialSilver = 4.0;\nconst float kMaterialTile = 5.0;\nconst float kMaterialPipe = 6.0;\nconst float kMaterialWater = 7.0;\nconst float kMaterialTexture0 = 11.0;\t// textureMaps[0]\nconst float kMaterialTexture1 = 12.0;\t// textureMaps[1]\nconst float kMaterialTexture2 = 13.0;\t// textureMaps[1]\nconst float kMaterialTexture3 = 14.0;\t// textureMaps[1]\n\nconst vec3 cGold = vec3(1.000, 0.766, 0.336);\nconst vec3 cSilver = vec3(0.972, 0.960, 0.915);\nconst vec3 cCopper = vec3(0.955, 0.637, 0.538);\nconst vec3 cIron = vec3(0.56, 0.57, 0.58);\nconst vec3 cAluminium = vec3(0.913, 0.921, 0.925);\nconst vec3 cChromium = vec3(0.550, 0.556, 0.554);\nconst vec3 cNickel = vec3(0.660, 0.609, 0.526);\nconst vec3 cTitanium = vec3(0.542, 0.497, 0.449);\nconst vec3 cCobalt = vec3(0.662, 0.655, 0.634);\nconst vec3 cPlatinum = vec3(0.672, 0.637, 0.585);\n\n//==============================================================================\n// Data structures\n//==============================================================================\n\nstruct CRay\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat tmin;\n\tfloat tmax;\t// maximum distance of ray\n};\nstruct CHit\n{\n\tvec3 p;\t\t// p = ro + rd * dist\n\tvec3 n;\t\t// surface normal\n\tfloat t;\n\tfloat m;\n\tvec3 refCol; // reflected color\n\tvec3 trmCol; // transmitted color (refraction)\n};\nstruct CMaterial\n{\n\tvec3 albedo;\t\t// diffuse reflectivity\n\tfloat ior;\t\t\t// F0 = ((1-ior)/(1+ior))^2 (where ior = Index of Refraction)\n\tfloat smoothness;\t// Fresnel = F0 + (1.0 - F0) * (1 - cosTheta)^5 * smoothness\n\tfloat transparency; // diffuse*(1-fTransparency) + cTransmission*fTransparency\n};\nstruct CShading\n{\n\tvec3 diffuse;\n\tvec3 specular;\n};\nstruct CPointLight\n{\n\tvec3 pos;\n\tvec3 col;\n};\nstruct CDirLight\n{\n\tvec3 dir;\n\tvec3 col;\n};\n\n//==============================================================================\n// Scene Description\n//==============================================================================\n\n#ifdef DEMO_REPEAT_SPHERES\nvec2 demoRepeatSpheres( in vec3 p )\n{\n\tvec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\n\tvec3 p1 = sRepeat( p, vec3(10.0, 10.0, 10.0) );\n\td = dUnion( d, vec2( fSphere(p1, 2.5), kMaterialSilver ) );//kMaterialTexture0\n\n\treturn d;\n}\n#endif\n\n#ifdef DEMO_PRIMITIVES\nvec2 demoPrimitives(vec3 p)\n{\n    // 21 objects + 1 floor\n    float m = 0.0;\n    vec2 res = dUnion( vec2( fPlane(     p), kMaterialChecker ),\n\t                   vec2( fSphere(    p-vec3( 0.0,0.25, 0.0), 0.25 ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fBox(       p-vec3( 1.0,0.25, 0.0), vec3(0.25) ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( uRoundBox(  p-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus(     p-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), m ) );  m += 1.0;\n    res = dUnion( res, vec2( fCapsule(   p,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTriPrism(  p-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCylinder(  p-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCone(      p-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus82(   p-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fTorus88(   p-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fCylinder6( p-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), m ) );  m += 1.0;\n\tres = dUnion( res, vec2( fHexPrism(  p-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( fPryamid4(  p-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ), m ) );  m += 1.0;\n    res = dUnion( res, dSubtract( vec2(  uRoundBox(p-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05), m),\n\t                              vec2(  fSphere(p-vec3(-2.0,0.2, 1.0), 0.25), m+1.0) ) ); m += 2.0;\n    res = dUnion( res, dSubtract( vec2(  fTorus82(p-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), m),\n\t                              vec2(  fCylinder(sRepeat(vec3(atan(p.x+2.0,p.z)/6.2831, p.y, 0.02+0.5*length(p-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6)), m+1.0) )); m += 2.0;\n\tres = dUnion( res, vec2( 0.5*fSphere( p-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*p.x)*sin(50.0*p.y)*sin(50.0*p.z), m ) ); m += 1.0;\n\tres = dUnion( res, vec2( 0.5*fTorus(  sTwist(p-vec3(-2.0,0.25,2.0), 10.0), vec2(0.20,0.05)), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fConeSection(p-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), m ) ); m += 1.0;\n    res = dUnion( res, vec2( fEllipsoid(  p-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), m ) ); m += 1.0;\n    return res;\n}\n#endif\n\n#ifdef DEMO_TEST\nvec2 demoTest( in vec3 p )\n{\n\t// // case 1: static sphere\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// d = dUnion( d, vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialWater ) );\n\n\t// // case 2: smooth union/subtract\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// vec3 tp = sTranslate( p, vec3(0.0, 2.0, 0.0) );\n\t// vec2 dcy1 = vec2( fCylinder(tp, vec2(1.0, 2.0)), kMaterialTexture0);\n\t// vec2 dcy2 = vec2( fCylinder(tp.yzx, vec2(0.5, 2.0)), kMaterialTexture1 );\n\t// d = dUnion( d, dSmoothUnion( dcy1, dcy2, 0.1 ) );\n    // //d = dUnion( d, dSmoothSubtract( dcy1, dcy2, 0.1 ) );\n\n\t// case 3: wriggling ice\n\tvec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\tvec2 sph = vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialTexture3 );\n\tp = rotM3*p*0.12; sph.x += 0.13*sinusoidBumps( p, time*1.1 );\n\tp = rotM3*p*0.57; sph.x -= 0.19*sinusoidBumps( p, time*2.1 );\n\td = dUnion( d, sph );\n\n\t// // case 4: heart\n\t// vec2 d = vec2( fPlane(p), kMaterialChecker ); // base plane\n\t// vec2 sph = vec2( fSphere(p-vec3(0.0, 2.5, 0.0), 2.5), kMaterialTexture2 );\n\t// p = rotM3*p*0.15; sph.x += 0.23*sinusoidBumps( p, time*0.1 );\n\t// p = rotM3*p*0.15; sph.x -= 0.05*sinusoidBumps( p, time*3.1 );\n\t// d = dUnion( d, sph );\n\n\treturn d;\n}\n#endif\n\nvec2 sceneMap( in vec3 p )\n{\n#if defined (DEMO_REPEAT_SPHERES)\n\treturn demoRepeatSpheres( p );\n\n#elif defined (DEMO_PRIMITIVES)\n\treturn demoPrimitives( p );\n\n#elif defined (DEMO_TEST)\n\treturn demoTest( p );\n\n#endif\n}\n\n//==============================================================================\n// Materials\n//==============================================================================\n\nCMaterial getMaterial( in CHit hit )\n{\n\t// IOR tables\n\t// Acetone 1.36\n\t// Actinolite 1.618\n\t// Agalmatoite 1.550\n\t// Agate 1.544\n\t// Agate, Moss 1.540\n\t// Air 1.0002926 (= 1.0003)\n\t// Alcohol 1.329\n\t// Amber 1.546\n\t// Amethyst 1.544\n\t// Crystal 2.00\n\t// Diamond 2.417\n\t// Emerald 1.576\n\t// Ethanol 1.36\n\t// Ethyl Alcohol 1.36\n\t// Glass 1.51714\n\t// Glass, Albite 1.4890\n\t// Glass, Crown 1.520\n\t// Glass, Crown, Zinc 1.517\n\t// Glass, Flint, Dense 1.66\n\t// Glass, Flint, Heaviest 1.89\n\t// Glass, Flint, Heavy 1.65548\n\t// Glass, Flint, Lanthanum 1.80\n\t// Glass, Flint, Light 1.58038\n\t// Glass, Flint, Medium 1.62725\n\t// Gold 0.47\n\t// Ice 1.309\n\t// Ivory 1.540\n\t// Jade, Nephrite 1.610\n\t// Jadeite 1.665\n\t// Lead 2.01\n\t// Malachite 1.655\n\t// Methanol 1.329\n\t// Moonstone, Albite 1.535\n\t// Nylon 1.53\n\t// Onyx 1.486\n\t// Opal 1.450\n\t// Oxygen (gas) 1.000276\n\t// Oxygen (liq) 1.221\n\t// Pearl 1.530\n\t// Plastic 1.460\n\t// Plexiglas 1.50\n\t// Polystyrene 1.55\n\t// Quartz 1.544\n\t// Quartz, Fused 1.45843\n\t// Rock Salt 1.544\n\t// Rubber, Natural 1.5191\n\t// Ruby 1.760\n\t// Sapphire 1.760\n\t// Silicon 4.24\n\t// Steel 2.50\n\t// Tiger eye 1.544\n\t// Topaz 1.620\n\t// Tourmaline 1.624\n\t// Turpentine 1.472\n\t// Turquoise 1.610\n\t// Water (gas) 1.000261\n\t// Water 35'C (Room temp) 1.33157\n\t// Zirconia, Cubic 2.170\n\n\t// Silver 0.180\n\t// Iron 2.950\n\t// Milk 1.350\n\t// Copper 1.100\n\t// Bronze1.180\n\t// Asphalt 1.635\n\t// Eye,Lens 1.410\n\t// Leather, Stone(Pebbles), Wood, Plaster 1.52\n\n\tCMaterial m;\n\tif(hit.m == kMaterialTexture0)\t\t// textureMaps[0]\n\t{\n\t\tm.albedo = texCube( textureMaps[0], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.52;//Pebbles\n\t\tm.smoothness = 0.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture1)\t\t// textureMaps[1]\n\t{\n\t\tm.albedo = texCube( textureMaps[1], hit.p, hit.n ).rgb;\n\t\tm.ior = 2.50;//Steel\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture2)\t\t// textureMaps[2]\n\t{\n\t\tm.albedo = texCube( textureMaps[2], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.760;//Ruby\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTexture3)\t\t// textureMaps[3]\n\t{\n\t\tm.albedo = texCube( textureMaps[3], hit.p, hit.n ).rgb;\n\t\tm.ior = 1.309;//Ice\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 1.0;\n\t}\n\telse if(hit.m == kMaterialChecker)\n\t{\n\t\tfloat f = checkerGradBox( 1.0*hit.p.xz );\n\t\tm.albedo = 0.1 + f*vec3(0.8);\n\t\t//m.ior = 1.309;//Ice\n\t\tm.ior = 1.0;//No_reflection\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialGround)\n\t{\n\t\tfloat f = checkerGradBox( 1.0*hit.p.xz );\n\t\tm.albedo = cCopper + 0.1*f*vec3(1.0);\n\t\tm.ior = 1.0;//No_reflection\n\t\tm.smoothness = 0.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialGold)\n\t{\n\t\tm.albedo = cGold;\n\t\tm.ior = 0.47;//Gold\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialSilver)\n\t{\n\t\tm.albedo = cSilver;\n\t\tm.ior = 0.180;//Silver\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialTile)\n\t{\n\t\t// Textureless version\n\t\tvec2 vTile = step(vec2(0.15), fract(hit.p.xz));\n\t\tfloat fTile = vTile.x * vTile.y;\n\t\tm.albedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n\t\tm.ior = 2.01;//Lead\n\t\tm.smoothness = m.albedo.r;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialPipe)\n\t{\n\t\tm.albedo = vec3(0.5);\n\t\tm.ior = 2.50;//Steel\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\telse if(hit.m == kMaterialWater)\n\t{\n\t\tm.ior = 1.3330; // Water at 20'C\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 1.0;\n\t\tfloat fExtinctionScale = 2.0;\n\t\t//vec3 vExtinction = vec3(0.3,0.7,0.9);\n\t\tvec3 vExtinction = vec3(1.0);\n\t\tm.albedo = (vec3(1.0) - vExtinction) * fExtinctionScale;\n\t}\n\telse\n\t{\n\t\tm.albedo = hsl2rgb( vec3(hit.m/7.0, 1.0, 0.5) );\n\t\tm.ior = 1.410;//Eye,Lens\n\t\tm.smoothness = 1.0;\n\t\tm.transparency = 0.0;\n\t}\n\treturn m;\n}\n\n//==============================================================================\n// Lights\n//==============================================================================\n\nCPointLight getPointLight()\n{\n\tCPointLight res;\n\tres.pos = vec3(2.0, 4.0, -2.0);\n\tres.col = vec3(1.0, 0.0, 0.0);\n\treturn res;\n}\n\nCDirLight getDirLight()\n{\n\tCDirLight res;\n\tres.dir = vec3(1.0);\n\tres.col = vec3(1.0);\n\treturn res;\n}\n\nCDirLight getSunLight()\n{\n\tCDirLight res;\n\tres.dir = SUN_LIGHT;\n\tres.col = SUN_COLOR;\n\treturn res;\n}\n\nvec3 getSkyGradient( in vec3 rd )\n{\n#if 1\n\tfloat sunAmount = max(dot(rd, SUN_LIGHT), 0.0);\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\n\tvec3 sky = v * SUN_COLOR*vec3(0.4) + vec3(0.18,0.22,0.4);\n\t// wide glare effect...\n\tsky = sky + SUN_COLOR * min(pow(sunAmount, 60.5)*0.32, 0.3);\n\tsky = sky+ SUN_COLOR * min(pow(sunAmount, 1150.0), 0.3)*0.65;\n\treturn sky;\n#else\n\treturn vec3(0.1);\n#endif\n}\n\nvec3 getAmbientLight( in vec3 n )\n{\n\treturn getSkyGradient( n );\n}\n\n//==============================================================================\n// Raymarching\n//==============================================================================\n\nvoid rayMarching( in CRay r, out CHit hit )\n{\n\tvec2 tm = rayMarching( r.o, r.d, r.tmin, FAR );\n\thit.t = tm.x;\n\thit.p = r.o + r.d * hit.t;\n\thit.m = (tm.y == -1.0)? kMaterialSky : tm.y;\n}\n\n//==============================================================================\n// Lighting & Shadow\n//==============================================================================\n\nvoid applyAtmosphere( inout vec3 col, in CRay r, in CHit hit )\n{\n#ifdef ENABLE_FOG\n    float fogAmount = exp(hit.t * -fogDensity);\n    vec3 fogCol = getSkyGradient(r.d);\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n        CDirLight dirLight = getDirLight();\n        float dirDot = clamp(dot(-dirLight.dir, r.d), 0.0, 1.0);\n        fogCol += dirLight.col * pow(dirDot, 10.0);\n    #endif\n    col = mix(fogCol, col, fogAmount);\n#endif\n\n#ifdef ENABLE_POINT_LIGHT_FLARE\n    CPointLight pointLight = getPointLight();\n    vec3 toLight = pointLight.pos - r.o;\n    float pointDot = dot(toLight, r.d);\n    pointDot = clamp(pointDot, 0.0, hit.t);\n    vec3 PointClosest = r.o + r.d * pointDot;\n    float dist = length(PointClosest - pointLight.pos);\n    col += pointLight.col * 0.01/ (dist * dist);\n#endif\n}\n\nfloat Schlick( in vec3 h, in vec3 v, in float ior, in float smoothFactor )\n{\n\tfloat F0 = pow( (airIOR - ior)/(airIOR + ior), 2.0 ); // airIOR = 1.0003\n\tfloat dotHV = dot(h, v); // H o V\n    return F0 + (1.0 - F0) * pow(saturate(1.0 - dotHV), 5.0) * smoothFactor;// fresnel = F0 + (1.0 - F0) * (1 - cosTheta)^5 * smoothFactor\n}\n\nvec3 getFresnelColor( in vec3 diffuse, in vec3 specular, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = reflect(rd, n); // R = reflect(-V, N)\n\tvec3 h = normalize(ld - rd); // H = L + V\n\t//float F = Schlick(h, -rd, m.ior, m.smoothness * 0.9 + 0.1);\n\tfloat F = Schlick(h, -rd, m.ior, m.smoothness);\n\treturn mix(diffuse, specular, F); // return (Ld*Md) * (1-F) + Ls * (F)\n}\n\nfloat getSpecularIntensity( in vec3 rd, in vec3 ld, in vec3 n, in float smoothness )\n// ld = surface to light position\n{          \n\tvec3 h = normalize(ld - rd);  // H = L + V\n\tfloat dotNH = max(0.0, dot(n, h));      // NoH = N o H\n\tfloat specPower = exp2(4.0 + 6.0 * smoothness);   // smoothness ==> specPower (= shininess)\n\tfloat specIntensity = (specPower + 2.0) * 0.125; // specPower ==> specIntensity (= specIntensity)\n\treturn pow(dotNH, specPower) * specIntensity;   // specWt = specIntensity * NoH^(shininess)\n}\n\nCShading getPointLighting( in CPointLight light, in vec3 p, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = normalize(light.pos - p);\n\tfloat tmin = 0.01 / abs(dot(ld, n));\n\tfloat tmax = length(light.pos - p);\n\t#ifdef ENABLE_SHADOW\n\t\tfloat shadow = sceneShadow( p, ld, tmin, tmax, 32.0 );\n\t#else\n\t\tfloat shadow = 1.0;\n\t#endif\n\n\tCShading shading;\n\tfloat atten = 1.0 / (tmax * tmax); // atten = 1/(d*d)\n\n\tvec3 inLight = light.col * (shadow*atten) * max(0.0, dot(ld, n)); // Ld = shadow * atten * Lc * NoL\n\tshading.diffuse = inLight;\n\tshading.specular = getSpecularIntensity( rd, ld, n, m.smoothness ) * inLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nCShading getDirectionalLighting( in CDirLight light, in vec3 p, in vec3 n, in vec3 rd, in CMaterial m )\n{\n\tvec3 ld = light.dir;\n\tfloat tmin = 0.01 / abs(dot(ld, n));\n\tfloat tmax = FAR*0.5;\n\t#ifdef ENABLE_SHADOW\n\t\tfloat shadow = sceneShadow( p, ld, tmin, tmax, 32.0 );\n\t#else\n\t\tfloat shadow = 1.0;\n\t#endif\n\n\tCShading shading;\n\tvec3 inLight = light.col * (shadow) * max(0.0, dot(ld, n)); // Ld = shadow * Lc * NoL\n\tshading.diffuse = inLight;\n\tshading.specular = getSpecularIntensity( rd, ld, n, m.smoothness ) * inLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nfloat getSubSurfScattering( in vec3 p, in vec3 rd )\n// subsurface scattering\n{\n\tfloat SSS_K = 1.5;\n\tfloat SSS_DELTA = 0.3;\n\tconst int SSS_N = 5;\n\tfloat sum = 0.0;\n\tfloat weight = -0.5;\n\tfloat delta = SSS_DELTA;\n\tfor(int i = 0; i < SSS_N; i++)\n\t{\n\t\tsum += weight * min( 0.0, sceneMap(p + delta*rd).x );\n\t\tdelta += delta;\n\t\tweight *= 0.5;\n\t}\n\treturn clamp( float(SSS_K)*sum, 0.0, 1.0 );\n}\n\nvec3 getPhongShading( in CRay r, in CHit hit, in CMaterial m )\n// r = 1st ray (incident)\n{\n\t#ifdef ENABLE_BUMP_MAPPING\n\t\tif( hit.m == kMaterialTexture0 )\n\t\t\thit.n = getBumpNormal(textureMaps[0], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture1 )\n\t\t\thit.n = getBumpNormal(textureMaps[1], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture2 )\n\t\t\thit.n = getBumpNormal(textureMaps[2], hit.p, hit.n, 0.075);\n\t\telse if( hit.m == kMaterialTexture3 )\n\t\t\thit.n = getBumpNormal(textureMaps[3], hit.p, hit.n, 0.075);\n\t#endif\n\n\tvec3 sceneCol;\n\tCShading shading;\n\tshading.diffuse = vec3(0.0);  // totalLd = 0.0\n\tshading.specular = vec3(0.0); // totalLs = 0.0\n\n\t#ifdef ENABLE_AO\n\t\tfloat ao = sceneAO(hit.p, hit.n);\n\t#else\n\t\tfloat ao = 1.0;\n\t#endif\n\n\t// reflection color added to specular term\n\tvec3 ambientLight = getAmbientLight(hit.n);\n\tshading.diffuse += ambientLight * ao;\n\tshading.specular += hit.refCol;\n\n\t#ifdef ENABLE_SUNDIR_LIGHT\n\t\tCDirLight sunLight = getSunLight();\n\t\tCShading sunShading = getDirectionalLighting(sunLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += sunShading.diffuse * ao;\n\t\tshading.specular += sunShading.specular;\n\t#endif\n\n\t#ifdef ENABLE_DIRECTIONAL_LIGHT\n\t\tCDirLight dirLight = getDirLight();\n\t\tCShading dirShading = getDirectionalLighting(dirLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += dirShading.diffuse * ao;\n\t\tshading.specular += dirShading.specular;\n\t#endif\n\n\t#ifdef ENABLE_POINT_LIGHT\n\t\tCPointLight pointLight = getPointLight();\n\t\tCShading pointShading = getPointLighting(pointLight, hit.p, hit.n, r.d, m);\n\t\tshading.diffuse += pointShading.diffuse * ao;\n\t\tshading.specular += pointShading.specular;\n\t#endif\n\n\tvec3 diffuseReflected = shading.diffuse * m.albedo;\n\tdiffuseReflected = mix(diffuseReflected, hit.trmCol, m.transparency);\n\t#ifdef ENABLE_SPECULAR\n\t\tsceneCol = getFresnelColor(diffuseReflected, shading.specular, hit.n, r.d, m);\n\t#else\n\t\tsceneCol = diffuseReflected;\n\t#endif\n\n\t#ifdef ENABLE_SUBSURFACE\n\t\tfloat sss = getSubSurfScattering( hit.p, r.d );\n\t\tsceneCol *= (1.0 - sss);\n\t#endif\n\n\treturn sceneCol;\n}\n\nvec3 getSceneColor2( in CRay r );\n\nvec3 getReflection( in CRay r, in CHit hit )\n// r = 1st ray (incident)\n{\n#if defined (ENABLE_SPECULAR) && defined (ENABLE_REFLECTIONS)\n    float separation = 0.01;\n    CRay re; // 2nd ray (reflected)\n    re.d = reflect(r.d, hit.n);\n    re.o = hit.p;\n\tre.tmin = separation / abs(dot(re.d, hit.n));\n    re.tmax = FAR*0.5;\n    return getSceneColor2(re);\n#else\n    return getSkyGradient(reflect(r.d, hit.n));                              \n#endif\n}\n\nvec3 getTransmission( in CRay r, in CHit hit, in CMaterial m )\n// r = 1st ray (incident)\n{\n\t#ifdef ENABLE_TRANSPARENCY\n\t{\n\t\t// Trace until outside transparent object\n\t\tfloat separation = 0.01;\n\t\tCRay ra;\n\t\tra.d = refract(r.d, hit.n, airIOR/m.ior);\n\t\tra.o = hit.p;\n\t\tra.tmin = separation / abs(dot(ra.d, hit.n));\n\t\tra.tmax = FAR*0.5;\n\n\t\t#ifdef ENABLE_DOUBLE_TRANSPARENCY\n\t\t\tCHit hit2;\n\t\t\trayMarching(ra, hit2);\n\t\t\tvec3 n = sceneNormal(hit2.p);\n\n\t\t\tCRay ra2;\n\t\t\tra2.d = refract(ra.d, n, m.ior/airIOR);\n\t\t\tra2.o = hit2.p;\n\t\t\tra2.tmin = separation / abs(dot(ra2.d, n));\n\t\t\tra2.tmax = FAR*0.5;\n\t\t\t\n\t\t\tfloat extinctionDist = hit2.t;\n\t\t\tvec3 sceneCol = getSceneColor2(ra2);\n\t\t#else\n\t\t\tfloat extinctionDist = 0.5;\n\t\t\tvec3 sceneCol = getSceneColor2(ra);\n\t\t#endif\n\n\t\tvec3 extinctionCol = m.albedo;\n\t\t// extinction should really be exp(-) but this is a nice hack to get RGB\n\t\textinctionCol = (1.0 / (1.0 + (extinctionCol * extinctionDist)));\n\t\treturn sceneCol * extinctionCol;\n\t}\n\t#else\n        return getSkyGradient(reflect(r.d, hit.n));\n    #endif\n}\n\nvec3 getSceneColor2( in CRay r )\n// no reflections, no transparency\n// r = secondary rays\n{\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\tsceneCol = getSkyGradient(r.d);\n\t}\n\telse\n\t{\n\t\thit.n = sceneNormal(hit.p);\n\t\tCMaterial m = getMaterial(hit);\n\n\t\t// use sky gradient instead of reflection\n\t\thit.refCol = getSkyGradient(reflect(r.d, hit.n));\n\t\tm.transparency = 0.0;\n\n\t\tsceneCol = getPhongShading(r, hit, m);\n\t}\n\n\tapplyAtmosphere(sceneCol, r, hit);\n\treturn sceneCol;\n}\n\nvec3 getSceneColourTestVersion( in CRay r )\n{\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\tsceneCol = getSkyGradient(r.d);\n\t}\n\telse\n    {\n\t\thit.n = sceneNormal(hit.p);\n\n\t\t#ifdef ENABLE_AO\n\t\t\tfloat ao = sceneAO(hit.p, hit.n);\n\t\t#else\n\t\t\tfloat ao = 1.0;\n\t\t#endif\n\n\t\t#ifdef ENABLE_SHADOW\n\t\t\tfloat shadow = sceneShadow(hit.p, SUN_LIGHT);\n\t\t#else\n\t\t\tfloat shadow = 1.0;\n\t\t#endif\n\n\t\t//vec3 ambientLight = getAmbientLight(hit.n);\n\n\t\tCMaterial m = getMaterial(hit);\n\t\tsceneCol = getPhongShading( m.albedo, 32.0, SUN_LIGHT, SUN_COLOR, hit.p, hit.n, r.d );\n\t\tsceneCol *= (shadow * ao);\n    }\n\treturn sceneCol;\n}\n\nvec3 getSceneColor( in CRay r )\n{\n#ifdef ENABLE_TEST_RENDER\n\treturn getSceneColourTestVersion( r );\n#endif\n\n\t// step 1: geometric intersection\n\tCHit hit;\n\trayMarching(r, hit);\n\n\tvec3 sceneCol;\n\tif( hit.m == kMaterialSky )\n\t{\n\t\t// no hit\n\t\tsceneCol = getSkyGradient(r.d);\n\t\tgl_FragDepth = 0.99;\n\t}\n\telse\n\t{\n\t\t// step 2: normal\n\t\thit.n = sceneNormal(hit.p);\n\n\t\t// step 3: material\n\t\tCMaterial m = getMaterial(hit);\n\n\t\t// step 4.1: 2nd ray (reflected)\n\t\thit.refCol = getReflection(r, hit);\n\n\t\t// step 4.2: 2nd ray (transmitted)\n\t\thit.trmCol = (m.transparency > 0.0)? getTransmission(r, hit, m) : vec3(0.0);\n\n\t\t// step 4.3: 1st ray (incident)\n\t\tsceneCol = getPhongShading(r, hit, m);\n\n\t\tgl_FragDepth = getFragDepth( hit.p );\n\t}\n\n\t// step 5: fog...\n\tapplyAtmosphere(sceneCol, r, hit);\n\treturn sceneCol;\n}\n\nvoid applyPostEffects( inout vec3 col )\n{\n\t// tonemap\n\tcol = (1.0 - exp(-col * 1.5)) * 1.0024; // fExposure = 1.5\n\n\t// gamma correction\n\tcol = pow( col, vec3(0.4545) );\n}\n\n//==============================================================================\n// Main\n//==============================================================================\n\nvoid main()\n{\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\n\n\tCRay r;\n\tr.o = ro;\n\tr.d = rd;\n\n#if defined (DEMO_REPEAT_SPHERES)\n\tr.tmin = 0.0;\n\tr.tmax = FAR;\n#elif defined (DEMO_PRIMITIVES)\n\tr.tmin = 0.0;\n\tr.tmax = 20.0;\n#endif\n\n\tvec3 col = getSceneColor( r );\n\tapplyPostEffects( col );\n\tgl_FragColor = vec4( col, 1.0 );\n}"},7155:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n//vec3 fragPos;\t\t// output: fragment position\r\n//vec3 fragNrm;\t\t// output: fragment normal\r\n\r\n//------------------------------------------------------------------------------------------\r\n//\t\tTerrain Mountains\r\n//------------------------------------------------------------------------------------------\r\n\r\n// Stereo version code thanks to Croqueteer :)\r\n//#define STEREOT\r\n\r\nfloat treeLine = 0.0;\r\nfloat treeCol = 0.0;\r\n\r\nconst vec3 SUN_LIGHT = normalize( vec3(0.4, 0.4, 0.48) );\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.83);\r\n\r\nfloat specular = 0.0;\r\nvec3 cameraPos;\r\nfloat ambient;\r\nvec2 add = vec2(1.0, 0.0);\r\n\r\n#define HASHSCALE1 .1031\r\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\r\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\r\n\r\n// This peturbs the fractal positions for each iteration down...\r\n// Helps make nice twisted landscapes...\r\nconst mat2 rotate2D = mat2(1.3623, 1.7531, -1.7131, 1.4623);\r\n\r\n// Alternative rotation:\r\n// const mat2 rotate2D = mat2(1.2323, 1.999231, -1.999231, 1.22);\r\n\r\n//  1 out, 2 in...\r\nfloat Hash12(vec2 p)\r\n{\r\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx + 19.19);\r\n    return fract((p3.x + p3.y) * p3.z);\r\n}\r\nvec2 Hash22(vec2 p)\r\n{\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n\r\n}\r\n\r\nfloat Noise( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    \r\n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\r\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\nvec2 Noise2( in vec2 x )\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    float n = p.x + p.y * 57.0;\r\n   vec2 res = mix(mix( Hash22(p),          Hash22(p + add.xy),f.x),\r\n                  mix( Hash22(p + add.yx), Hash22(p + add.xx),f.x),f.y);\r\n    return res;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat Trees(vec2 p)\r\n{\r\n \t//return (texture(iChannel1,0.04*p).x * treeLine);\r\n    return Noise(p*13.0)*treeLine;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Low def version for ray-marching through the height field...\r\n// Thanks to IQ for all the noise stuff...\r\nfloat Terrain( in vec2 p )\r\n{\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw = -w * 0.4;\t//...Flip negative and positive for variation\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\t\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Map to lower resolution for height field mapping for Scene function...\r\nfloat Map(in vec3 p)\r\n{\r\n\tfloat h = Terrain(p.xz);\r\n\r\n\tfloat ff = Noise(p.xz*.3) + Noise(p.xz*3.3)*.5;\r\n\ttreeLine = smoothstep(ff, .0+ff*2.0, h) * smoothstep(1.0+ff*3.0, .4+ff, h) ;\r\n\ttreeCol = Trees(p.xz);\r\n\th += treeCol;\r\n\t\r\n    return p.y - h;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// High def version only used for grabbing normal information.\r\nfloat Terrain2( in vec2 p )\r\n{\r\n\t// There's some real magic numbers in here! \r\n\t// The Noise calls add large mountain ranges for more variation over distances...\r\n\tvec2 pos = p*0.05;\r\n\tfloat w = (Noise(pos*.25)*0.75+.15);\r\n\tw = 66.0 * w * w;\r\n\tvec2 dxy = vec2(0.0, 0.0);\r\n\tfloat f = .0;\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\t//...Flip negative and positive for varition\t   \r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\tfloat ff = Noise(pos*.002);\r\n\tf += pow(abs(ff), 5.0)*275.-5.0;\r\n\t\r\n\ttreeCol = Trees(p);\r\n\tf += treeCol;\r\n\tif (treeCol > 0.0) return f;\r\n\r\n\t// That's the last of the low resolution, now go down further for the Normal data...\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tf += w * Noise(pos);\r\n\t\tw =  - w * 0.4;\r\n\t\tpos = rotate2D * pos;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat FractalNoise(in vec2 xy)\r\n{\r\n\tfloat w = .7;\r\n\tfloat f = 0.0;\r\n\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tf += Noise(xy) * w;\r\n\t\tw *= 0.5;\r\n\t\txy *= 2.7;\r\n\t}\r\n\treturn f;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Simply Perlin clouds that fade to the horizon...\r\n// 200 units above the ground...\r\nvec3 GetClouds(in vec3 sky, in vec3 rd)\r\n{\r\n\tif (rd.y < 0.01) return sky;\r\n\tfloat v = (200.0-cameraPos.y)/rd.y;\r\n\trd.xz *= v;\r\n\trd.xz += cameraPos.xz;\r\n\trd.xz *= .010;\r\n\tfloat f = (FractalNoise(rd.xz) -.55) * 5.0;\r\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\r\n\tsky = mix(sky, vec3(.55, .55, .52), clamp(f*rd.y-.1, 0.0, 1.0));\r\n\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Grab all sky information for a given ray from camera\r\nvec3 GetSky(in vec3 rd)\r\n{\r\n\tfloat sunAmount = max( dot( rd, SUN_LIGHT), 0.0 );\r\n\tfloat v = pow(1.0-max(rd.y,0.0),5.)*.5;\r\n\tvec3  sky = vec3( v*SUN_COLOR.x*0.4+0.18, v*SUN_COLOR.y*0.4+0.22, v*SUN_COLOR.z*0.4+0.4);\r\n\t// Wide glare effect...\r\n\tsky = sky + SUN_COLOR * pow(sunAmount, 6.5)*.32;\r\n\t// Actual sun...\r\n\tsky = sky+ SUN_COLOR * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Merge mountains into the sky background for correct disappearance...\r\nvec3 ApplyFog( in vec3  rgb, in float dis, in vec3 dir)\r\n{\r\n\tfloat fogAmount = exp(-dis* 0.00001);\r\n\treturn mix(GetSky(dir), rgb, fogAmount );\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Calculate sun light...\r\nvoid DoLighting(inout vec3 mat, in vec3 pos, in vec3 normal, in vec3 eyeDir, in float dis)\r\n{\r\n\tfloat h = dot(SUN_LIGHT,normal);\r\n\tfloat c = max(h, 0.0)+ambient;\r\n\tmat = mat * SUN_COLOR * c ;\r\n\t// Specular...\r\n\tif (h > 0.0)\r\n\t{\r\n\t\tvec3 R = reflect(SUN_LIGHT, normal);\r\n\t\tfloat specAmount = pow( max(dot(R, normalize(eyeDir)), 0.0), 3.0)*specular;\r\n\t\tmat = mix(mat, SUN_COLOR, specAmount);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Hack the height, position, and normal data to create the coloured landscape\r\nvec3 TerrainColour(vec3 pos, vec3 normal, float dis)\r\n{\r\n\tvec3 mat;\r\n\tspecular = .0;\r\n\tambient = .1;\r\n\tvec3 dir = normalize(pos-cameraPos);\r\n\t\r\n\tvec3 matPos = pos * 2.0;// ... I had change scale halfway though, this lazy multiply allow me to keep the graphic scales I had\r\n\r\n\tfloat disSqrd = dis * dis;// Squaring it gives better distance scales.\r\n\r\n\tfloat f = clamp(Noise(matPos.xz*.05), 0.0,1.0);//*10.8;\r\n\tf += Noise(matPos.xz*.1+normal.yz*1.08)*.85;\r\n\tf *= .55;\r\n\tvec3 m = mix(vec3(.63*f+.2, .7*f+.1, .7*f+.1), vec3(f*.43+.1, f*.3+.2, f*.35+.1), f*.65);\r\n\tmat = m*vec3(f*m.x+.36, f*m.y+.30, f*m.z+.28);\r\n\t// Should have used smoothstep to add colours, but left it using 'if' for sanity...\r\n\tif (normal.y < .5)\r\n\t{\r\n\t\tfloat v = normal.y;\r\n\t\tfloat c = (.5-normal.y) * 4.0;\r\n\t\tc = clamp(c*c, 0.1, 1.0);\r\n\t\tf = Noise(vec2(matPos.x*.09, matPos.z*.095+matPos.yy*0.15));\r\n\t\tf += Noise(vec2(matPos.x*2.233, matPos.z*2.23))*0.5;\r\n\t\tmat = mix(mat, vec3(.4*f), c);\r\n\t\tspecular+=.1;\r\n\t}\r\n\r\n\t// Grass. Use the normal to decide when to plonk grass down...\r\n\tif (matPos.y < 45.35 && normal.y > .65)\r\n\t{\r\n\r\n\t\tm = vec3(Noise(matPos.xz*.023)*.5+.15, Noise(matPos.xz*.03)*.6+.25, 0.0);\r\n\t\tm *= (normal.y- 0.65)*.6;\r\n\t\tmat = mix(mat, m, clamp((normal.y-.65)*1.3 * (45.35-matPos.y)*0.1, 0.0, 1.0));\r\n\t}\r\n\r\n\tif (treeCol > 0.0)\r\n\t{\r\n\t\tmat = vec3(.02+Noise(matPos.xz*5.0)*.03, .05, .0);\r\n\t\tnormal = normalize(normal+vec3(Noise(matPos.xz*33.0)*1.0-.5, .0, Noise(matPos.xz*33.0)*1.0-.5));\r\n\t\tspecular = .0;\r\n\t}\r\n\t\r\n\t// Snow topped mountains...\r\n\tif (matPos.y > 80.0 && normal.y > .42)\r\n\t{\r\n\t\tfloat snow = clamp((matPos.y - 80.0 - Noise(matPos.xz * .1)*28.0) * 0.035, 0.0, 1.0);\r\n\t\tmat = mix(mat, vec3(.7,.7,.8), snow);\r\n\t\tspecular += snow;\r\n\t\tambient+=snow *.3;\r\n\t}\r\n\t// Beach effect...\r\n\tif (matPos.y < 1.45)\r\n\t{\r\n\t\tif (normal.y > .4)\r\n\t\t{\r\n\t\t\tf = Noise(matPos.xz * .084)*1.5;\r\n\t\t\tf = clamp((1.45-f-matPos.y) * 1.34, 0.0, .67);\r\n\t\t\tfloat t = (normal.y-.4);\r\n\t\t\tt = (t*t);\r\n\t\t\tmat = mix(mat, vec3(.09+t, .07+t, .03+t), f);\r\n\t\t}\r\n\t\t// Cheap under water darkening...it's wet after all...\r\n\t\tif (matPos.y < 0.0)\r\n\t\t{\r\n\t\t\tmat *= .2;\r\n\t\t}\r\n\t}\r\n\r\n\tDoLighting(mat, pos, normal,dir, disSqrd);\r\n\t\r\n\t// Do the water...\r\n\tif (matPos.y < 0.0)\r\n\t{\r\n\t\t// Pull back along the ray direction to get water surface point at y = 0.0 ...\r\n\t\tfloat time = (time)*.03;\r\n\t\tvec3 watPos = matPos;\r\n\t\twatPos += -dir * (watPos.y/dir.y);\r\n\t\t// Make some dodgy waves...\r\n\t\tfloat tx = cos(watPos.x*.052) *4.5;\r\n\t\tfloat tz = sin(watPos.z*.072) *4.5;\r\n\t\tvec2 co = Noise2(vec2(watPos.x*4.7+1.3+tz, watPos.z*4.69+time*35.0-tx));\r\n\t\tco += Noise2(vec2(watPos.z*8.6+time*13.0-tx, watPos.x*8.712+tz))*.4;\r\n\t\tvec3 nor = normalize(vec3(co.x, 20.0, co.y));\r\n\t\tnor = normalize(reflect(dir, nor));//normalize((-2.0*(dot(dir, nor))*nor)+dir);\r\n\t\t// Mix it in at depth transparancy to give beach cues..\r\n        tx = watPos.y-matPos.y;\r\n\t\tvec3 sky = GetSky(nor)*vec3(0.3,0.3,0.5);\r\n\t\tmat = mix( mat, GetClouds( sky, nor )*0.1 + vec3(0.0, 0.02, 0.03), clamp( tx*0.4, 0.6, 1.0) );\r\n\r\n\t\t// Add some extra water glint...\r\n\t#if 1\r\n        mat += vec3(.1)*clamp(1.-pow(tx+.5, 3.)*texture(textureMaps[0], watPos.xz*.1, -2.).x, 0.,1.0);\r\n\t#else\r\n\t\tfloat tmpTex = texture(textureMaps[0], watPos.xz*0.1).x;\r\n\t\ttmpTex = 1.0 - pow(tx+0.5, 3.0) * tmpTex;\r\n\t\tmat += vec3(0.1)*clamp(tmpTex, 0.0,1.0);\r\n\t#endif\r\n\r\n\t\tfloat sunAmount = max( dot(nor, SUN_LIGHT), 0.0 );\r\n\t\tmat = mat + SUN_COLOR * pow(sunAmount, 228.5)*.6;\r\n        vec3 temp = (watPos-cameraPos*2.)*.5;\r\n        disSqrd = dot(temp, temp);\r\n\t}\r\n\tmat = ApplyFog(mat, disSqrd, dir);\r\n\treturn mat;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\r\n{\r\n\t// Home in on the surface by dividing by two and split...\r\n    float halfwayT;\r\n\tfor (int n = 0; n < 5; n++)\r\n\t{\r\n\t\thalfwayT = (t.x + t.y) * .5;\r\n\t\tvec3 p = rO + halfwayT*rD;\r\n\t\t//(Map(p) < 0.5) ? t.x = halfwayT: t.y = halfwayT;\r\n\t\tif( Map(p) < 0.5 ) t.x = halfwayT;\r\n\t\telse t.y = halfwayT;\r\n\t}\r\n\treturn t.x;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nbool Scene(in vec3 rO, in vec3 rD, out float resT)\r\n{\r\n    float t = 1. + Hash12(gl_FragCoord.xy);\r\n\tfloat oldT = 0.0;\r\n\tfloat delta = 0.0;\r\n\tbool fin = false;\r\n\tbool res = false;\r\n\tvec2 distances;\r\n\tfor( int j=0; j< 150; j++ )\r\n\t{\r\n\t\tif (fin || t > 240.0) break;\r\n\t\tvec3 p = rO + t*rD;\r\n\t\t//if (t > 240.0 || p.y > 195.0) break;\r\n\t\tfloat h = Map(p); // ...Get this positions height mapping.\r\n\t\t// Are we inside, and close enough to fudge a hit?...\r\n\t\tif( h < 0.5 )\r\n\t\t{\r\n\t\t\tfin = true;\r\n\t\t\tdistances = vec2(t, oldT);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t// Delta ray advance - a fudge between the height returned\r\n\t\t// and the distance already travelled.\r\n\t\t// It's a really fiddly compromise between speed and accuracy\r\n\t\t// Too large a step and the tops of ridges get missed.\r\n\t\tdelta = max(0.01, 0.3*h) + (t*0.0065);\r\n\t\toldT = t;\r\n\t\tt += delta;\r\n\t}\r\n\tif (fin) resT = BinarySubdivision(rO, rD, distances);\r\n\r\n\treturn fin;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvec3 CameraPath( float t )\r\n{\r\n\tfloat iMouseX = 0.0;\r\n\tfloat m = 1.0+(iMouseX/resolution.x)*300.0;\r\n\tt = (time*1.5+m+657.0)*.006 + t;\r\n    vec2 p = 476.0*vec2( sin(3.5*t), cos(1.5*t) );\r\n\treturn vec3(35.0-p.x, 0.6, 4108.0+p.y);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// Some would say, most of the magic is done in post! :D\r\nvec3 PostEffects(vec3 rgb, vec2 uv)\r\n{\r\n\t//#define CONTRAST 1.1\r\n\t//#define SATURATION 1.12\r\n\t//#define BRIGHTNESS 1.3\r\n\t//rgb = pow(abs(rgb), vec3(0.45));\r\n\t//rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\r\n\trgb = (1.0 - exp(-rgb * 6.0)) * 1.0024;\r\n\t//rgb = clamp(rgb+hash12(gl_FragCoord.xy*rgb.r)*0.1, 0.0, 1.0);\r\n\treturn rgb;\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\nvoid mainImage( in vec3 ro, in vec3 rd, out vec4 fragColor, out float fragDepth )\r\n{\r\n#if 0\r\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\r\n\tvec2 uv = xy * vec2(resolution.x/resolution.y,1.0);\r\n\tvec3 camTar;\r\n\r\n\tcameraPos.xz = CameraPath(0.0).xz;\r\n\tcamTar.xyz\t = CameraPath(.005).xyz;\r\n\tcamTar.y = cameraPos.y = max((h*.25)+3.5, 1.5+sin(time*5.)*.5);\r\n\t\r\n\tfloat roll = 0.15*sin(time*.2);\r\n\tvec3 cw = normalize(camTar-cameraPos);\r\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\r\n\tvec3 cu = normalize(cross(cw,cp));\r\n\tvec3 cv = normalize(cross(cu,cw));\r\n\tvec3 rd = normalize( uv.x*cu + uv.y*cv + 1.5*cw );\r\n#else\r\n\tcameraPos = ro;\r\n\t//rd = rd;\r\n#endif\r\n\r\n\t// Use several forward heights, of decreasing influence with distance from the camera.\r\n\tfloat h = 0.0;\r\n\tfloat f = 1.0;\r\n\tfor (int i = 0; i < 7; i++)\r\n\t{\r\n\t\th += Terrain(CameraPath((.6-f)*.008).xz) * f;\r\n\t\tf -= .1;\r\n\t}\r\n\r\n\t#ifdef STEREO\r\n\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\r\n\t#endif\r\n\r\n\t#ifdef STEREO\r\n\tvec3 cu = vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]);\r\n\tcameraPos += 0.45*cu*isCyan; // move camera to the right - the rd vector is still good\r\n\t#endif\r\n\r\n\tvec3 col;\r\n\tfloat distance;\r\n\tif( !Scene(cameraPos, rd, distance) )\r\n\t{\r\n\t\t// Missed scene, now just get the sky value...\r\n\t\tcol = GetSky(rd);\r\n\t\tcol = GetClouds(col, rd);\r\n\t\t//fragPos = vec3(1.0e+30);\r\n\t\t//fragNrm = rd;\r\n\t\tfragDepth = 0.99;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// Get world coordinate of landscape...\r\n\t\tvec3 pos = cameraPos + distance * rd;\r\n\t\t// Get normal from sampling the high definition height map\r\n\t\t// Use the distance to sample larger gaps to help stop aliasing...\r\n\t\tfloat p = min(.3, .0005+.00005 * distance*distance);\r\n\t\tvec3 nor  \t= vec3(0.0,\t\t    Terrain2(pos.xz), 0.0);\r\n\t\tvec3 v2\t\t= nor-vec3(p,\t\tTerrain2(pos.xz+vec2(p,0.0)), 0.0);\r\n\t\tvec3 v3\t\t= nor-vec3(0.0,\t\tTerrain2(pos.xz+vec2(0.0,-p)), -p);\r\n\t\tnor = cross(v2, v3);\r\n\t\tnor = normalize(nor);\r\n\r\n\t\t// Get the colour using all available data...\r\n\t\tcol = TerrainColour(pos, nor, distance);\r\n\t\t//fragPos = pos;\r\n\t\t//fragNrm = nor;\r\n\t\tfragDepth = getFragDepth( pos );\r\n\t}\r\n\r\n\tvec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\r\n\tvec2 uv = xy * vec2(resolution.x/resolution.y,1.0);\r\n\tcol = PostEffects(col, uv);\r\n\t\r\n\t#ifdef STEREO\r\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\r\n\t#endif\r\n\t\r\n\tfragColor = vec4(col, 1.0);\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------------------\r\n//\t\tMain Function\r\n//------------------------------------------------------------------------------------------\r\nvoid main()\r\n{\r\n\t//--------------------------------------\r\n\t// ray generation\r\n\t// (ro = rayOrigin, rd = rayDirection)\r\n\t//--------------------------------------\r\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n\t//--------------------------------------\r\n\t// distance fields\r\n\t// -input: ro, rd\r\n\t// -output: fragColor, fragDepth\r\n\t//--------------------------------------\r\n\tvec4 fragColor;\r\n\tfloat fragDepth;\r\n\tmainImage( ro, rd, fragColor, fragDepth );\t\t// provided by external sources (e.g.: shadertoy)\r\n\r\n\tgl_FragColor = fragColor;\r\n\tgl_FragDepth = fragDepth;\r\n\r\n// \t//--------------------------------------\r\n// \t// store to g-buffer\r\n// \t//--------------------------------------\r\n// #if 1\r\n// \tvec4 fragPosV = viewMatrix * vec4(fragPos, 1.0);\r\n// \tfloat ze = fragPosV.z/fragPosV.w;\r\n// \tgl_FragDepth = far*(near + ze) / ((far - near) * ze);\r\n// \tdepthOut = gl_FragDepth;\r\n// #else\r\n// \tvec4 viewPos = viewMatrix * vec4(fragPos, 1.0);\r\n// \tvec4 clipPos = projMatrix * viewPos;\r\n// \tfloat zn = clipPos.z/clipPos.w;\r\n// \tgl_FragDepth = zn*0.5 + 0.5;\r\n// \tdepthOut = gl_FragDepth;\r\n// #endif\r\n// \tnormalOut = normalize( vec3(viewMatrix * vec4(fragNrm, 0.0)) );\r\n// \talbedoOut = fragColor.xyz;\r\n}"},8226:e=>{e.exports="//==============================================================================\r\n//\r\n// Microsurface (roughness or glossiness)\r\n// -metalness workflow: setting a metalness value or creating a metalness map(1 for metal, 0 for non-metal)\r\n// -specular workflow: setting a specular value or creating a specular map(color and intensity of the reflected light)\r\n//\r\n// Diffuse(albedo or base color): \r\n// -constant value (= Gold(1.000, 0.766, 0.336), Silver(0.972, 0.960, 0.915), Copper(0.955, 0.637, 0.538)...)\r\n// -diffuse map texture\r\n//\r\n// Metalness:\r\n// -single value (metal (1) or non-metal(0))\r\n// -metalness map (= define specific areas of your material as metal or non-metal)\r\n//\r\n// Glossiness:\r\n// -blurry or sharp the reflections on the material (or how broad or narrow the specular highlights are)\r\n// -single value between (0-100) or a glossiness map\r\n// (*The roughness is the inverse of the glossiness)\r\n//\r\n// Additional properties: Ambient Occulusion, Emissive, Opacity, Normal and Height maps\r\n//\r\n//==============================================================================\r\n\r\n#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n\r\n//#undef STANDARD\r\n#define USE_RAY_SHADOW\r\n#define USE_RAY_AO\r\n\r\n#ifndef RAYMARCH_LIGHTS\r\n#define RAYMARCH_LIGHTS\r\n\r\nuniform samplerCube envMap;\r\n// uniform sampler2D envMap;\r\n\r\n// NOTE: MAX_TEXTURE_IMAGE_UNITS = 16 supported for WebGL1\r\n#define MAX_MATERIALS    4\r\n\r\nuniform int useAlbedoMaps[ MAX_MATERIALS ];\r\n//uniform int useNormalMaps[ MAX_MATERIALS ];\r\nuniform int useMetalnessMaps[ MAX_MATERIALS ];\r\nuniform int useRoughnessMaps[ MAX_MATERIALS ];\r\n//uniform int useAoMaps[ MAX_MATERIALS ];\r\n\r\nuniform sampler2D albedoMaps[ MAX_MATERIALS ];\r\n//uniform sampler2D normalMaps[ MAX_MATERIALS ];\r\nuniform sampler2D metalnessMaps[ MAX_MATERIALS ];\r\nuniform sampler2D roughnessMaps[ MAX_MATERIALS ];\r\n//uniform sampler2D aoMaps[ MAX_MATERIALS ];\r\n\r\nuniform vec3 albedos[ MAX_MATERIALS ];\r\nuniform float metalnesss[ MAX_MATERIALS ];\r\nuniform float roughnesss[ MAX_MATERIALS ];\r\n//uniform float aos[ MAX_MATERIALS ];\r\n\r\n// see distances.glsl for these definitions\r\nfloat sceneShadow( in vec3 ro, in vec3 rd );\r\nfloat sceneAO( vec3 p, vec3 n );\r\n\r\n//==============================================================================\r\n\r\n#define PHYSICAL\r\n#define PHYSICALLY_CORRECT_LIGHTS\r\n#define STANDARD\r\n\r\n#define USE_ENVMAP\r\n#define ENVMAP_TYPE_CUBE        // uniform samplerCube envMap;\r\n// #define ENVMAP_TYPE_CUBE_UV  // uniform sampler2D envMap;\r\n#define ENVMAP_MODE_REFLECTION\r\n\r\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n\tconst float reflectivity = 1.0;\r\n\tconst float envMapIntensity = 1.0;\r\n#endif\r\n\r\n#ifdef USE_ENVMAP\r\n    const float flipEnvMap = 1.0; //-1.0\r\n    const int maxMipLevel = 6;\r\n#endif\r\n\r\nstruct IncidentLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n\tbool visible;\r\n};\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\nstruct GeometricContext {\r\n\tvec3 position;\r\n\tvec3 normal;\r\n\tvec3 viewDir;\r\n};\r\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\r\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\r\n}\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n}\r\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\r\n\treturn - distance * planeNormal + point;\r\n}\r\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\r\n}\r\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\r\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\r\n}\r\nmat3 transposeMat3( const in mat3 m ) {\r\n\tmat3 tmp;\r\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\r\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\r\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\r\n\treturn tmp;\r\n}\r\nfloat linearToRelativeLuminance( const in vec3 color ) {\r\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\r\n\treturn dot( weights, color.rgb );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec4 inputTexelToLinear( vec4 value ) {\r\n\t// if ( inputEncoding == 0 ) {\r\n\t// \treturn value;\r\n\t// } else if ( inputEncoding == 1 ) {\r\n\t// \treturn sRGBToLinear( value );\r\n\t// } else if ( inputEncoding == 2 ) {\r\n\t// \treturn RGBEToLinear( value );\r\n\t// } else if ( inputEncoding == 3 ) {\r\n\t// \treturn RGBMToLinear( value, 7.0 );\r\n\t// } else if ( inputEncoding == 4 ) {\r\n\t// \treturn RGBMToLinear( value, 16.0 );\r\n\t// } else if ( inputEncoding == 5 ) {\r\n\t// \treturn RGBDToLinear( value, 256.0 );\r\n\t// } else {\r\n\t// \treturn GammaToLinear( value, 2.2 );\r\n\t// }\r\n\treturn GammaToLinear( value, 2.2 );\r\n}\r\n\r\nvec4 envMapTexelToLinear( vec4 color ) {\r\n\treturn inputTexelToLinear( color );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\tif( decayExponent > 0.0 ) {\r\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\r\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\r\n#else\r\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\r\n#endif\r\n\t}\r\n\treturn 1.0;\r\n}\r\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n}\r\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\r\n}\r\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\treturn 1.0 / ( gl * gv );\r\n}\r\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\treturn 0.5 / max( gv + gl, EPSILON );\r\n}\r\nfloat D_GGX( const in float alpha, const in float dotNH ) {\r\n\tfloat a2 = pow2( alpha );\r\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\r\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\r\n}\r\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\tfloat alpha = pow2( roughness );\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\treturn F * ( G * D );\r\n}\r\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\r\n\tconst float LUT_SIZE  = 64.0;\r\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\r\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\r\n\tfloat dotNV = saturate( dot( N, V ) );\r\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\r\n\tuv = uv * LUT_SCALE + LUT_BIAS;\r\n\treturn uv;\r\n}\r\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\r\n\tfloat l = length( f );\r\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\r\n}\r\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\r\n\tfloat x = dot( v1, v2 );\r\n\tfloat y = abs( x );\r\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\r\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\r\n\tfloat v = a / b;\r\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\r\n\treturn cross( v1, v2 ) * theta_sintheta;\r\n}\r\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\r\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\r\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\r\n\tvec3 lightNormal = cross( v1, v2 );\r\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\r\n\tvec3 T1, T2;\r\n\tT1 = normalize( V - N * dot( V, N ) );\r\n\tT2 = - cross( N, T1 );\r\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\r\n\tvec3 coords[ 4 ];\r\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\r\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\r\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\r\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\r\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\r\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\r\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\r\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\r\n\tvec3 vectorFormFactor = vec3( 0.0 );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\r\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\r\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\r\n\treturn vec3( result );\r\n}\r\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\r\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n\tvec4 r = roughness * c0 + c1;\r\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\r\n\treturn specularColor * AB.x + AB.y;\r\n}\r\nfloat G_BlinnPhong_Implicit( ) {\r\n\treturn 0.25;\r\n}\r\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n}\r\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\r\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\r\n\tvec3 F = F_Schlick( specularColor, dotLH );\r\n\tfloat G = G_BlinnPhong_Implicit( );\r\n\tfloat D = D_BlinnPhong( shininess, dotNH );\r\n\treturn F * ( G * D );\r\n}\r\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\r\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\r\n}\r\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\r\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\r\n}\r\n\r\n// #ifdef ENVMAP_TYPE_CUBE_UV\r\n// #define cubeUV_textureSize (1024.0)\r\n// int getFaceFromDirection(vec3 direction) {\r\n// \tvec3 absDirection = abs(direction);\r\n// \tint face = -1;\r\n// \tif( absDirection.x > absDirection.z ) {\r\n// \t\tif(absDirection.x > absDirection.y )\r\n// \t\t\tface = direction.x > 0.0 ? 0 : 3;\r\n// \t\telse\r\n// \t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n// \t}\r\n// \telse {\r\n// \t\tif(absDirection.z > absDirection.y )\r\n// \t\t\tface = direction.z > 0.0 ? 2 : 5;\r\n// \t\telse\r\n// \t\t\tface = direction.y > 0.0 ? 1 : 4;\r\n// \t}\r\n// \treturn face;\r\n// }\r\n// #define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\r\n// #define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\r\n// vec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\r\n// \tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\r\n// \tfloat dxRoughness = dFdx(roughness);\r\n// \tfloat dyRoughness = dFdy(roughness);\r\n// \tvec3 dx = dFdx( vec * scale * dxRoughness );\r\n// \tvec3 dy = dFdy( vec * scale * dyRoughness );\r\n// \tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\r\n// \td = clamp(d, 1.0, cubeUV_rangeClamp);\r\n// \tfloat mipLevel = 0.5 * log2(d);\r\n// \treturn vec2(floor(mipLevel), fract(mipLevel));\r\n// }\r\n// #define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\r\n// #define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\r\n// vec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\r\n// \tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\r\n// \tfloat a = 16.0 * cubeUV_rcpTextureSize;\r\n// \tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\r\n// \tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\r\n// \tfloat powScale = exp2_packed.x * exp2_packed.y;\r\n// \tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\r\n// \tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\r\n// \tbool bRes = mipLevel == 0.0;\r\n// \tscale =  bRes && (scale < a) ? a : scale;\r\n// \tvec3 r;\r\n// \tvec2 offset;\r\n// \tint face = getFaceFromDirection(direction);\r\n// \tfloat rcpPowScale = 1.0 / powScale;\r\n// \tif( face == 0) {\r\n// \t\tr = vec3(direction.x, -direction.z, direction.y);\r\n// \t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 1) {\r\n// \t\tr = vec3(direction.y, direction.x, direction.z);\r\n// \t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 2) {\r\n// \t\tr = vec3(direction.z, direction.x, direction.y);\r\n// \t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\r\n// \t}\r\n// \telse if( face == 3) {\r\n// \t\tr = vec3(direction.x, direction.z, direction.y);\r\n// \t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \telse if( face == 4) {\r\n// \t\tr = vec3(direction.y, direction.x, -direction.z);\r\n// \t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \telse {\r\n// \t\tr = vec3(direction.z, -direction.x, direction.y);\r\n// \t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\r\n// \t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\r\n// \t}\r\n// \tr = normalize(r);\r\n// \tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\r\n// \tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\r\n// \tvec2 base = offset + vec2( texelOffset );\r\n// \treturn base + s * ( scale - 2.0 * texelOffset );\r\n// }\r\n// #define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\r\n// vec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\r\n// \tfloat roughnessVal = roughness * cubeUV_maxLods3;\r\n// \tfloat r1 = floor(roughnessVal);\r\n// \tfloat r2 = r1 + 1.0;\r\n// \tfloat t = fract(roughnessVal);\r\n// \tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\r\n// \tfloat s = mipInfo.y;\r\n// \tfloat level0 = mipInfo.x;\r\n// \tfloat level1 = level0 + 1.0;\r\n// \tlevel1 = level1 > 5.0 ? 5.0 : level1;\r\n// \tlevel0 += min( floor( s + 0.5 ), 5.0 );\r\n// \tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\r\n// \tvec4 color10 = envMapTexelToLinear(texture(envMap, uv_10));\r\n// \tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\r\n// \tvec4 color20 = envMapTexelToLinear(texture(envMap, uv_20));\r\n// \tvec4 result = mix(color10, color20, t);\r\n// \treturn vec4(result.rgb, 1.0);\r\n// }\r\n// #endif\r\n#ifdef ENVMAP_TYPE_CUBE_UV\r\n#define cubeUV_maxMipLevel 8.0\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_maxTileSize 256.0\r\n#define cubeUV_minTileSize 16.0\r\n// These shader functions convert between the UV coordinates of a single face of\r\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\r\n// sampling a textureCube (not generally normalized).\r\nfloat getFace(vec3 direction) {\r\n    vec3 absDirection = abs(direction);\r\n    float face = -1.0;\r\n    if (absDirection.x > absDirection.z) {\r\n      if (absDirection.x > absDirection.y)\r\n        face = direction.x > 0.0 ? 0.0 : 3.0;\r\n      else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    } else {\r\n      if (absDirection.z > absDirection.y)\r\n        face = direction.z > 0.0 ? 2.0 : 5.0;\r\n      else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\nvec2 getUV(vec3 direction, float face) {\r\n    vec2 uv;\r\n    if (face == 0.0) {\r\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\r\n    } else if (face == 1.0) {\r\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\r\n    } else if (face == 2.0) {\r\n      uv = direction.xy / abs(direction.z);\r\n    } else if (face == 3.0) {\r\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\r\n    } else if (face == 4.0) {\r\n      uv = direction.xz / abs(direction.y);\r\n    } else {\r\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\r\n    }\r\n    return 0.5 * (uv + 1.0);\r\n}\r\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\r\n  float face = getFace(direction);\r\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\r\n  mipInt = max(mipInt, cubeUV_minMipLevel);\r\n  float faceSize = exp2(mipInt);\r\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\r\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\r\n  vec2 f = fract(uv);\r\n  uv += 0.5 - f;\r\n  if (face > 2.0) {\r\n    uv.y += faceSize;\r\n    face -= 3.0;\r\n  }\r\n  uv.x += face * faceSize;\r\n  if(mipInt < cubeUV_maxMipLevel){\r\n    uv.y += 2.0 * cubeUV_maxTileSize;\r\n  }\r\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\r\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\r\n  uv *= texelSize;\r\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.x += texelSize;\r\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.y += texelSize;\r\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  uv.x -= texelSize;\r\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\r\n  vec3 tm = mix(tl, tr, f.x);\r\n  vec3 bm = mix(bl, br, f.x);\r\n  return mix(tm, bm, f.y);\r\n}\r\n// These defines must match with PMREMGenerator\r\n#define r0 1.0\r\n#define v0 0.339\r\n#define m0 -2.0\r\n#define r1 0.8\r\n#define v1 0.276\r\n#define m1 -1.0\r\n#define r4 0.4\r\n#define v4 0.046\r\n#define m4 2.0\r\n#define r5 0.305\r\n#define v5 0.016\r\n#define m5 3.0\r\n#define r6 0.21\r\n#define v6 0.0038\r\n#define m6 4.0\r\nfloat roughnessToMip(float roughness) {\r\n  float mip = 0.0;\r\n  if (roughness >= r1) {\r\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\r\n  } else if (roughness >= r4) {\r\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\r\n  } else if (roughness >= r5) {\r\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\r\n  } else if (roughness >= r6) {\r\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\r\n  } else {\r\n    mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25\r\n  }\r\n  return mip;\r\n}\r\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\r\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\r\n  float mipF = fract(mip);\r\n  float mipInt = floor(mip);\r\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\r\n  if (mipF == 0.0) {\r\n    return vec4(color0, 1.0);\r\n  } else {\r\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\r\n    return vec4(mix(color0, color1, mipF), 1.0);\r\n  }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n\r\nuniform vec3 ambientLightColor;\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\tvec3 irradiance = ambientLightColor;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\treturn irradiance;\r\n}\r\n#if NUM_DIR_LIGHTS > 0\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t};\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\t}\r\n#endif\r\n#if NUM_POINT_LIGHTS > 0\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t\t// float shadowCameraNear;\r\n\t\t// float shadowCameraFar;\r\n\t};\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\t}\r\n#endif\r\n#if NUM_SPOT_LIGHTS > 0\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\t// int shadow;\r\n\t\t// float shadowBias;\r\n\t\t// float shadowRadius;\r\n\t\t// vec2 shadowMapSize;\r\n\t};\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\t\t} else {\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\t\t}\r\n\t}\r\n#endif\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\tuniform sampler2D ltc_1;\r\n    uniform sampler2D ltc_2;\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n#endif\r\n#if NUM_HEMI_LIGHTS > 0\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\t\tirradiance *= PI;\r\n\t\t#endif\r\n\t\treturn irradiance;\r\n\t}\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\r\n\t\t#else\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\t\t#endif\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\t}\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\t}\r\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\t\t#else\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\t\t#endif\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent) );\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#endif\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\t}\r\n#endif\r\n\r\n//==============================================================================\r\n\r\nstruct PhysicalMaterial {\r\n\tvec3\tdiffuseColor;\r\n    float   metalness;      // added\r\n\tfloat\tspecularRoughness;\r\n\tvec3\tspecularColor;\r\n\t// #ifndef STANDARD\r\n\t// \tfloat clearCoat;\r\n\t// \tfloat clearCoatRoughness;\r\n\t// #endif\r\n};\r\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\r\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\r\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\r\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\r\n}\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\t\tvec3 normal = geometry.normal;\r\n\t\tvec3 viewDir = geometry.viewDir;\r\n\t\tvec3 position = geometry.position;\r\n\t\tvec3 lightPos = rectAreaLight.position;\r\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\r\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\r\n\t\tvec3 lightColor = rectAreaLight.color;\r\n\t\tfloat roughness = material.specularRoughness;\r\n\t\tvec3 rectCoords[ 4 ];\r\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\r\n        rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\r\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\r\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\r\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\r\n\t\tvec4 t1 = texture( ltc_1, uv );\r\n\t\tvec4 t2 = texture( ltc_2, uv );\r\n\t\tmat3 mInv = mat3(\r\n\t\t\tvec3( t1.x, 0, t1.y ),\r\n\t\t\tvec3(    0, 1,    0 ),\r\n\t\t\tvec3( t1.z, 0, t1.w )\r\n\t\t);\r\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\r\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\r\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\r\n\t}\r\n#endif\r\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\r\n\tvec3 irradiance = dotNL * directLight.color;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\t#ifndef STANDARD\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\r\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n\t#ifndef STANDARD\r\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\t#endif\r\n}\r\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n}\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\r\n\t#ifndef STANDARD\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\t\tfloat dotNL = dotNV;\r\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\r\n\t#else\r\n\t\tfloat clearCoatDHR = 0.0;\r\n\t#endif\r\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\r\n\t#ifndef STANDARD\r\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\r\n\t#endif\r\n}\r\n#define RE_Direct\t\t\t\tRE_Direct_Physical\r\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\r\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\r\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\r\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\r\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\r\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\r\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\r\n}\r\n\r\n#ifdef USE_BUMPMAP\r\n\tuniform sampler2D bumpMap;\r\n\tuniform float bumpScale;\r\n\tvec2 dHdxy_fwd() {\r\n\t\tvec2 dSTdx = dFdx( vUv );\r\n\t\tvec2 dSTdy = dFdy( vUv );\r\n\t\tfloat Hll = bumpScale * texture( bumpMap, vUv ).x;\r\n\t\tfloat dBx = bumpScale * texture( bumpMap, vUv + dSTdx ).x - Hll;\r\n\t\tfloat dBy = bumpScale * texture( bumpMap, vUv + dSTdy ).x - Hll;\r\n\t\treturn vec2( dBx, dBy );\r\n\t}\r\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\r\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\r\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\r\n\t\tvec3 vN = surf_norm;\r\n\t\tvec3 R1 = cross( vSigmaY, vN );\r\n\t\tvec3 R2 = cross( vN, vSigmaX );\r\n\t\tfloat fDet = dot( vSigmaX, R1 );\r\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\r\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\r\n\t}\r\n#endif\r\n\r\n#ifdef USE_NORMALMAP\r\n\tuniform sampler2D normalMap;\r\n\tuniform vec2 normalScale;\r\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\r\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\r\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\r\n\t\tvec2 st0 = dFdx( vUv.st );\r\n\t\tvec2 st1 = dFdy( vUv.st );\r\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\r\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\r\n\t\tvec3 N = normalize( surf_norm );\r\n\t\tvec3 mapN = texture( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n\t\tmapN.xy = normalScale * mapN.xy;\r\n\t\tmat3 tsn = mat3( S, T, N );\r\n\t\treturn normalize( tsn * mapN );\r\n\t}\r\n#endif\r\n\r\n//==============================================================================\r\n// Physical lighting...\r\n//==============================================================================\r\n\r\nvec3 FresnelSchlickRoughness( float cosTheta, vec3 F0, float roughness )\r\n// consider surface roughness when calculating indirect diffuse\r\n{\r\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\n\r\nvec4 getPBRColor( in vec3 p, in vec3 n, in vec3 v, in PhysicalMaterial material )\r\n// p = hitted position\r\n// n = normal at p\r\n// v = view (= -rd) at p\r\n// material = material at p\r\n{\r\n    // Hitted material\r\n    vec3 emissiveRadiance = vec3(0.0);//material.emissiveColor;\r\n    float opacity = 1.0;\r\n    vec4 diffuseColor = vec4( material.diffuseColor, opacity );//material.opacity\r\n\r\n    // Hitted geometry\r\n    GeometricContext geometry;\r\n    geometry.position = p;\r\n    geometry.normal = n;\r\n    geometry.viewDir = v;//normalize(-rd);\r\n\r\n    IncidentLight directLight;\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissiveRadiance;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tPointLight pointLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n        pointLight = pointLights[ i ];\r\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible )  directLight.color *= sceneShadow( geometry.position, pointLight.position-geometry.position );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tSpotLight spotLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n        spotLight = spotLights[ i ];\r\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible ) directLight.color *= sceneShadow( geometry.position, spotLight.position-geometry.position );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\r\n\tDirectionalLight directionalLight;\r\n\t\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n        directionalLight = directionalLights[ i ];\r\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\r\n        #ifdef USE_RAY_SHADOW\r\n        if( directLight.visible ) directLight.color *= sceneShadow( geometry.position, directionalLight.direction );\r\n        #endif\r\n        RE_Direct( directLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\tRectAreaLight rectAreaLight;\r\n\r\n    #pragma unroll_loop\r\n    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n        rectAreaLight = rectAreaLights[ i ];\r\n        RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n    }\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n    #if ( NUM_HEMI_LIGHTS > 0 )\r\n        #pragma unroll_loop\r\n        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n        }\r\n    #endif\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearCoatRadiance = vec3( 0.0 );\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\t// #ifdef USE_LIGHTMAP\r\n\t// \tvec3 lightMapIrradiance = texture( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\t// \t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t// \t\tlightMapIrradiance *= PI;\r\n\t// \t#endif\r\n\t// \tirradiance += lightMapIrradiance;\r\n\t// #endif\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\r\n\t#endif\r\n#endif\r\n\r\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\r\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\r\n\t#ifndef STANDARD\r\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\r\n\t#endif\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\r\n#endif\r\n\r\n#if 1\r\n    // adding surface roughness when calculating indirect diffuse...\r\n    float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n    vec3 F = FresnelSchlickRoughness(dotNV, material.specularColor, material.specularRoughness);\r\n    reflectedLight.indirectDiffuse *= (1.0 - F);\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\r\n#endif\r\n\r\n#ifdef USE_RAY_AO\r\n    //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n    float diffuseAO = sceneAO( geometry.position, geometry.normal );\r\n    float specularAO = saturate( pow(dotNV + diffuseAO, pow2(material.specularRoughness)) - 1.0 + diffuseAO);\r\n    reflectedLight.indirectDiffuse *= diffuseAO;\r\n    reflectedLight.indirectSpecular *= specularAO;\r\n#endif\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\treturn vec4( outgoingLight, diffuseColor.a );\r\n\r\n// #if defined( TONE_MAPPING )\r\n//   gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n// #endif\r\n\r\n//   gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n\r\n// #ifdef USE_FOG\r\n// \t#ifdef FOG_EXP2\r\n// \t\tfloat fogFactor = whiteComplement( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\r\n// \t#else\r\n// \t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\r\n// \t#endif\r\n// \tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\r\n// #endif\r\n\r\n// #ifdef PREMULTIPLIED_ALPHA\r\n// \tgl_FragColor.rgb *= gl_FragColor.a;\r\n// #endif\r\n\r\n// #if defined( DITHERING )\r\n//   gl_FragColor.rgb = dithering( gl_FragColor.rgb );\r\n// #endif\r\n}\r\n\r\n#endif // RAYMARCH_LIGHTS\r\n\r\n//==============================================================================\r\n\r\n// numMaterials: must be <= 4\r\n#define numMaterials    4\r\n\r\n// Choose...\r\n#define ENABLE_BUMP_NORMAL\r\n#define ENABLE_FOG\r\n#define ENABLE_REFLECT_PASS\r\n\r\n// Choose one of these demos...\r\n#define ENABLE_DEMO_ROUGH_METAL\r\n//#define ENABLE_DEMO_PBR_MATERIALS\r\n//#define ENABLE_DEMO_PRIMITIVES\r\n\r\n// floor material\r\n#define MTL_FLOOR       100.0\r\n#define FLOOR_COLOR     checkerColor(p, 5.0, 0.6)\r\n\r\n#ifdef ENABLE_FOG\r\nconst float fogDensity = 0.001;\r\nconst vec3 fogColor = vec3(0.56, 0.64, 0.8);\r\n#endif\r\n\r\n// const vec3 cGold = vec3(1.000, 0.766, 0.336);\r\n// const vec3 cSilver = vec3(0.972, 0.960, 0.915);\r\n// const vec3 cCopper = vec3(0.955, 0.637, 0.538);\r\n// const vec3 cIron = vec3(0.56, 0.57, 0.58);\r\n// const vec3 cAluminium = vec3(0.913, 0.921, 0.925);\r\n// const vec3 Chromium = vec3(0.550, 0.556, 0.554);\r\n// const vec3 Nickel = vec3(0.660, 0.609, 0.526);\r\n// const vec3 Titanium = vec3(0.542, 0.497, 0.449);\r\n// const vec3 Cobalt = vec3(0.662, 0.655, 0.634);\r\n// const vec3 Platinum = vec3(0.672, 0.637, 0.585);\r\n\r\n\r\n//==============================================================================\r\n// Scene Modeling\r\n//==============================================================================\r\n\r\nvec2 simpleScene(vec3 p)\r\n{\r\n    // // one sphere\r\n    // vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    // float r = 0.5;\r\n    // vec3 c = vec3(0.0, r, 0.0);\r\n    // vec2 sph = vec2(fSphere(p - c, r), 0.0);\r\n    // res = dUnion(res, sph);\r\n    // return res;\r\n\r\n    // smooth union\r\n    vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    float k = 0.1;\r\n\tvec3 tp = sTranslate( p, vec3(0.0, 2.0, 0.0) );\r\n\tvec2 dcy1 = vec2( fCylinder(tp, vec2(1.0, 2.0)), 0.0 );\r\n\tvec2 dcy2 = vec2( fCylinder(tp.yzx, vec2(0.5, 2.0)), 1.0 );\r\n\t//res = dUnion( res, dSmoothUnion( dcy1, dcy2, k ) );\r\n    res = dUnion( res, dSmoothSubtract( dcy1, dcy2, k ) );\r\n    return res;\r\n}\r\n\r\n#ifdef ENABLE_DEMO_ROUGH_METAL\r\nvec2 demoRoughMetalScene(vec3 p)\r\n{\r\n    vec2 res = vec2( fPlane(p), MTL_FLOOR ); // floor\r\n\r\n    const int nx = 7, ny = 7;\r\n    float r = 0.25;\r\n    float m = 0.0;\r\n\r\n    float dx = 3.0*r, dy = 3.0*r;\r\n    float x, x0 = -(float(nx)/2.0-0.5)*dx;\r\n    float y, y0 = r;\r\n\r\n    for(int j = 0; j < ny; j++) {\r\n        y = y0 + float(j)*dy;\r\n        for(int i = 0; i < nx; i++) {\r\n            x = x0 + float(i)*dx;\r\n            res = dUnion( res, vec2( fSphere(p-vec3(x, y, 0.0), r), m ) );\r\n            m = m + 1.0;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_DEMO_PBR_MATERIALS\r\nvec2 demoPBRMaterialsScene(vec3 p)\r\n{\r\n    vec2 res = vec2(fPlane(p), MTL_FLOOR);\r\n    float r = 0.5;\r\n    //float dr = 0.0;\r\n    float dr = 0.2;\r\n    float dx = (r + dr)*2.0;\r\n    float x0 = (float(numMaterials)-1.0) / -2.0;\r\n    for(int i = 0; i < numMaterials; i++) {\r\n        vec3 c = vec3( x0 + float(i)*dx, r, 0.0 );\r\n        vec2 sph = vec2(fSphere(p - c, r), float(i));\r\n        res = dUnion(res, sph);\r\n    }\r\n    return res;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_DEMO_PRIMITIVES\r\nvec2 demoPrimitivesScene(vec3 p)\r\n{\r\n    // 21 objects + 1 floor\r\n    float m = 0.0;\r\n    vec2 res = dUnion( vec2( fPlane(     p), MTL_FLOOR ),\r\n\t                   vec2( fSphere(    p-vec3( 0.0,0.25, 0.0), 0.25 ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fBox(       p-vec3( 1.0,0.25, 0.0), vec3(0.25) ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( uRoundBox(  p-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus(     p-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), m ) );  m += 1.0;\r\n    res = dUnion( res, vec2( fCapsule(   p,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTriPrism(  p-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCylinder(  p-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCone(      p-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus82(   p-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fTorus88(   p-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fCylinder6( p-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), m ) );  m += 1.0;\r\n\tres = dUnion( res, vec2( fHexPrism(  p-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( fPryamid4(  p-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ), m ) );  m += 1.0;\r\n    res = dUnion( res, dSubtract( vec2(  uRoundBox(p-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05), m),\r\n\t                              vec2(  fSphere(p-vec3(-2.0,0.2, 1.0), 0.25), m+1.0) ) ); m += 2.0;\r\n    res = dUnion( res, dSubtract( vec2(  fTorus82(p-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), m),\r\n\t                              vec2(  fCylinder(sRepeat(vec3(atan(p.x+2.0,p.z)/6.2831, p.y, 0.02+0.5*length(p-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6)), m+1.0) )); m += 2.0;\r\n\tres = dUnion( res, vec2( 0.5*fSphere( p-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*p.x)*sin(50.0*p.y)*sin(50.0*p.z), m ) ); m += 1.0;\r\n\tres = dUnion( res, vec2( 0.5*fTorus(  sTwist(p-vec3(-2.0,0.25,2.0), 10.0), vec2(0.20,0.05)), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fConeSection(p-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), m ) ); m += 1.0;\r\n    res = dUnion( res, vec2( fEllipsoid(  p-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), m ) ); m += 1.0;\r\n    return res;\r\n}\r\n#endif\r\n\r\nvec2 sceneMap(vec3 p)\r\n{\r\n#if defined(ENABLE_DEMO_ROUGH_METAL)\r\n    return demoRoughMetalScene(p);\r\n\r\n#elif defined(ENABLE_DEMO_PBR_MATERIALS)\r\n    return demoPBRMaterialsScene(p);\r\n\r\n#elif defined(ENABLE_DEMO_PRIMITIVES)\r\n    return demoPrimitivesScene(p);\r\n\r\n#else\r\n    return simpleScene(p);\r\n\r\n#endif\r\n}\r\n\r\n//==============================================================================\r\n// Material\r\n//==============================================================================\r\n\r\nvoid getPBRMaterial( in float m, in vec3 p, in vec3 n, out PhysicalMaterial material )\r\n{\r\n    //------------------------------------------------------\r\n    vec3 baseColor = vec3(1.0);         // default baseColor\r\n    float metalness = 0.1;//1.0;           // default metalness\r\n    float roughness = 0.1;//0.04;  // default roughness\r\n    //------------------------------------------------------\r\n\r\n    if( m == MTL_FLOOR )\r\n    {\r\n        baseColor = FLOOR_COLOR;\r\n        metalness = 0.1;\r\n        roughness = 0.1;\r\n    }\r\n    else\r\n    {\r\n//------------------------------------------------------\r\n#if defined(ENABLE_DEMO_ROUGH_METAL)\r\n        baseColor = vec3(1.0, 1.0, 1.0);\r\n        float nx = 7.0, ny = 7.0;\r\n        metalness = floor(m/nx) / (ny-1.0); // metalness = [0,1] along yaxis\r\n        roughness = mod(m,nx) / (nx-1.0);   // roughness = [0,1] along xaxis\r\n\r\n//------------------------------------------------------\r\n#elif defined(ENABLE_DEMO_PRIMITIVES)\r\n        baseColor = hsl2rgb( vec3( m/21.0, 1.0, 0.5) );\r\n        metalness = 0.7;//m/21.0;\r\n        roughness = n.y;\r\n\r\n//------------------------------------------------------\r\n#else\r\n        for(int i = 0; i<numMaterials; i++)\r\n        {\r\n            if( int(m) == i ) {\r\n                vec3 texCol = pow( texCube(albedoMaps[i], p, n).rgb, vec3(2.2) );\r\n                baseColor = mix( albedos[i], texCol, float(useAlbedoMaps[i]) );\r\n                metalness = mix( metalnesss[i],  texCube(metalnessMaps[i], p, n).r, float(useMetalnessMaps[i]) );\r\n                roughness = mix( roughnesss[i], texCube(roughnessMaps[i], p, n).r, float(useRoughnessMaps[i]) );\r\n                break;\r\n            }\r\n        }\r\n#endif\r\n//------------------------------------------------------\r\n    }\r\n\r\n    // material.metalness\r\n    material.metalness = clamp( metalness, 0.0, 1.0 );\r\n\r\n    // material.specularRoughness <== roughness (0.04 ~ 1.0)\r\n    material.specularRoughness = clamp( roughness, 0.04, 1.0 );\r\n\r\n    // material.diffuseColor <== baseColor + metalness\r\n    material.diffuseColor = baseColor.rgb * ( 1.0 - material.metalness );\r\n\r\n    // material.specularColor <== baseColor + metalness\r\n    #ifdef STANDARD\r\n        material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), baseColor.rgb, material.metalness );\r\n    #else\r\n        float reflectivity = 0.5; // maps to F0 = 0.04\r\n        material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), baseColor.rgb, material.metalness );\r\n        material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\r\n        material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\r\n    #endif\r\n}\r\n\r\n//==============================================================================\r\n// Post-Effects\r\n//==============================================================================\r\n\r\n#ifdef ENABLE_BUMP_NORMAL\r\nvec3 getBumpNormal( in float m, in vec3 p, in vec3 n, float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    // cf: array index for samplers must be constant integral expressions\r\n    vec3 normal;\r\n    int i = int( m ); // assume: numMaterials = 4\r\n\r\n    if( i == 0 ) normal = getBumpNormal( albedoMaps[ 0 ], p, n, bumpFactor );\r\n    else if( i == 1 ) normal = getBumpNormal( albedoMaps[ 1 ], p, n, bumpFactor );\r\n    else if( i == 2 ) normal = getBumpNormal( albedoMaps[ 2 ], p, n, bumpFactor );\r\n    else if( i == 3 ) normal = getBumpNormal( albedoMaps[ 3 ], p, n, bumpFactor );\r\n    else normal = n;\r\n\r\n    return normal;\r\n}\r\n#endif\r\n\r\n#ifdef ENABLE_FOG\r\nvec3 applyFog( in vec3 color, in vec3 fogColor, in float fogDensity, in float fogDepth )\r\n{\r\n    float fogFactor = exp2( -fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );//LOG2 = 1.442695\r\n    fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\r\n\treturn mix( color, fogColor, fogFactor );\r\n}\r\n#endif\r\n\r\nvoid doPostEffects( inout vec4 color, in float fogDepth )\r\n{\r\n    color.rgb = FilmicToneMapping( color.rgb );\r\n\r\n#ifdef ENABLE_FOG\r\n    color.rgb = applyFog( color.rgb, fogColor, fogDensity, fogDepth );\r\n#endif\r\n\r\n    color = LinearToGamma( color, 2.2 ); // gammaFactor = 2.2\r\n\r\n    color.rgb *= color.a;\r\n\r\n    color.rgb = Dithering( color.rgb );\r\n}\r\n\r\n//==============================================================================\r\n// Rendering\r\n//==============================================================================\r\n\r\nvec4 render(in vec3 ro, in vec3 rd, out float t)\r\n{\r\n    vec4 color = vec4(0.0);\r\n\r\n    // hit.xy = (distance, material)\r\n    vec2 hit = rayMarching(ro, rd);\r\n    t = hit.x;\r\n    float m = hit.y;\r\n\r\n    gl_FragDepth = 1.0;\r\n\r\n    // hit something in the scene\r\n    if (m >= 0.0)\r\n    {\r\n        vec3 p = ro + t * rd;\r\n        vec3 n = sceneNormal(p);\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        PhysicalMaterial material;\r\n        getPBRMaterial( m, p, n, material );\r\n\r\n        #ifdef ENABLE_BUMP_NORMAL\r\n            n = getBumpNormal( m, p, n, material.specularRoughness * 0.01 );\r\n        #endif\r\n\r\n        color = getPBRColor( p, n, -rd, material );\r\n\r\n        #ifdef ENABLE_REFLECT_PASS\r\n        if( material.metalness > 0.0 )\r\n        {\r\n            vec3 r = reflect(rd, n);\r\n            vec2 hit2 = rayMarching(p, r);\r\n            m = hit2.y;\r\n            if( m >= 0.0 )\r\n            {\r\n                p += r * hit2.x;\r\n                n = sceneNormal(p);\r\n\r\n                PhysicalMaterial material2;\r\n                getPBRMaterial( m, p, n, material2 );\r\n\r\n                float gloss = material.metalness;\r\n                gloss *= (1.0 - material.specularRoughness);\r\n                gloss *= 0.35 / (1.0 + hit2.x * hit2.x);\r\n                color += getPBRColor( p, n, -r, material2 ) * gloss;\r\n            }\r\n        }\r\n        #endif\r\n    }\r\n\r\n    return color;\r\n}\r\n\r\n//==============================================================================\r\n// Main\r\n//==============================================================================\r\n\r\nvoid main()\r\n{\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    float t;\r\n    vec4 color = render( ro, rd, t );\r\n\r\n    if( gl_FragDepth == 1.0 ) discard;\r\n\r\n    doPostEffects( color, t );\r\n\r\n    gl_FragColor = color;\r\n}"},114:e=>{e.exports="precision highp int;\nprecision highp float;\n\nvoid main()\n{\n\tgl_Position = vec4(position, 1.0);\n}"},4650:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n\r\n#define NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 20.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.2;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    //return H * sin( PI2/L * x );\r\n    float W = PI2/L;\r\n    return H*(sin(W*x) + sin(W*x*2.0));\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    //return H * W * cos(W * x);\r\n    return H*W*(cos(W*x) + 2.0*cos(W*x*2.0));\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.5*riverBaseDepth(p*2.0);\r\n    //depth += 0.25*riverBaseDepth(p*4.0);\r\n    return depth;\r\n}\r\n#define USE_WATER_2\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n// textureMaps[1] = 'images/raymarch/lichen.jpg'\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 60.0;//20.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-1.0, 0.7, 0.25));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.85, 0.5) * 5.0;//5.0;\r\nconst vec3 SKY_COLOR = vec3(0.1, 0.5, 1.0);\r\n\r\nfloat terrainHeight( vec3 p )\r\n// p.y not used...\r\n{\r\n    // terrain map\r\n    vec2 q = p.xz * vec2(0.5, 1.0);\r\n    float f = 0.0;\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for(int i=0; i<2; i++)//3\r\n    {\r\n        f += noise( q ) * a;\r\n        q *= 2.0;\r\n        tot += a;\r\n        a *= 0.5;\r\n    }\r\n    float fbm = f / tot;\r\n    float height = fbm * fbm;\r\n\r\n    // add river...\r\n    height -= riverDepth(p);\r\n\r\n    return height;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p ) // mandatory function\r\n{\r\n    return vec2( p.y - terrainHeight( p ), MATERIAL_TEXTURE1 );\r\n}\r\n\r\nvec3 getTerrainColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float t )\r\n{\r\n    // position & normal\r\n    vec3 p = ro + rd * t;\r\n    vec3 n = sceneNormal( p, EPS );\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // material\r\n    vec3 col = texCube( iChannel1, p, n ).xyz;\r\n    vec3 albedo = col*col;\r\n    float wetness = 1.0 - saturate( (p.y + 0.025) * 5.0 );\r\n    float gloss = mix( albedo.r, 1.0, wetness );\r\n    albedo = mix( albedo, albedo * 0.8, wetness );\r\n    vec3 specF0 = vec3(0.001);\r\n\r\n    // sun light ==> diffuseCol + specularCol\r\n    vec3 diffuseCol;\r\n    vec3 specularCol;\r\n    float shadow = sceneShadow( p, SUN_LIGHT, FAR*0.01, FAR*0.1, 16.0 );\r\n    getCookShading( albedo, gloss, SUN_COLOR, SUN_LIGHT, n, rd, diffuseCol, specularCol );\r\n    diffuseCol *= shadow;\r\n\r\n    // reflectCol ==> specularCol\r\n    vec3 reflectRd = reflect( rd, n );\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = 1.0;\r\n\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return result;\r\n}\r\n\r\nvec3 sceneColor( in vec3 ro,  in vec3 rd )\r\n{\r\n    vec2 hit = bisectMarching( ro, rd, 0.01, FAR );\r\n\r\n    float fogDistance;\r\n    vec3 result;\r\n\r\n    // sky\r\n    if( hit.x > FAR )\r\n    {\r\n        result = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        fogDistance = FAR;\r\n        gl_FragDepth = 0.99;\r\n    }\r\n\r\n    // water\r\n    else\r\n    {\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, SKY_COLOR, ro, rd, hit.x, FAR );\r\n        result = waterCol.xyz;\r\n        fogDistance = waterCol.w;\r\n    }\r\n\r\n    // terrain\r\n    if( result == vec3(0.0) )\r\n    {\r\n        result = getTerrainColor( SUN_COLOR, SUN_LIGHT, SKY_COLOR, ro, rd, hit.x );\r\n        fogDistance = hit.x;\r\n    }\r\n\r\n    // fog...\r\n    float fogDensity = 0.025;//0.015\r\n    vec3 fogCol = skyColor( SUN_LIGHT, rd, 0.0 );\r\n    applyFog( result, fogCol, fogDensity, fogDistance );\r\n\r\n    return result;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( out vec3 ro, out vec3 rd )\r\n{\r\n    vec3 ta = vec3(0.0, -0.5, 0.0);\r\n    ta.x -= time * 0.75;//0.5\r\n    ro = ta + vec3(1.5);//2.0\r\n    \r\n    float fHeading = time * 0.15;//0.1\r\n    float dist = 1.5 - cos(time * 0.1 + 2.0) * 0.8;\r\n\r\n    ro.x += sin( fHeading ) * dist;\r\n    ro.z += cos( fHeading ) * dist;\r\n    ro.y += 1.0 + dist * dist * 0.01;\r\n    ta.z += riverCurve( ta.x );\r\n    ro.z += riverCurve( ro.x );\r\n#if 1\r\n    // camera moves above the water\r\n    ro.y = max( ro.y, terrainHeight( ro ) + 0.2 );\r\n#else\r\n    // camera moves up and down the water\r\n    ro.y = min( ro.y, terrainHeight( ro ) + 0.5 );\r\n#endif\r\n\r\n    // camera ray direction\r\n    float fl = 1.5;//2.0\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n\tvec3 ro, rd;\r\n    cameraAutoView( ro, rd );\r\n\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n#endif\r\n\r\n    vec3 result = sceneColor(ro, rd);\r\n\tresult = Vignetting( result, 0.5 );\r\n    result = FilmicToneMapping( result );\r\n    result = LinearToGamma( vec4(result, 1.0), 0.9 ).xyz; //2.2\r\n\r\n\tgl_FragColor = vec4(result, 1.0);\r\n}"},2105:e=>{e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_SEA_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst vec3 SUN_LIGHT = normalize( vec3(0.4, 0.4, 0.48) );\r\n\r\nvec2 sceneMap( in vec3 p ){ return vec2(0.0); }\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nmat3 cameraAutoView( out vec3 ro, out vec3 rd )\r\n{\r\n    vec3 ta = vec3(0.0, -0.5, 0.0);\r\n    ta.x -= time * 0.75;//0.5\r\n    ro = ta + vec3(1.5);//2.0\r\n    \r\n    float fHeading = time * 0.15;//0.1\r\n    float dist = 1.5 - cos(time * 0.1 + 2.0) * 0.8;\r\n\r\n    ro.x += sin( fHeading ) * dist;\r\n    ro.z += cos( fHeading ) * dist;\r\n    ro.y += 1.0 + dist * dist * 0.01;\r\n\r\n    // camera ray direction\r\n    float fl = 1.0;//1.5 2.0\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main(void)\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    // mixing = sky + sea\r\n    float FAR = 1000.0;\r\n    vec3 sky = skyColor( SUN_LIGHT, rd, 1.0 );\r\n    vec3 sea = seaColor( SUN_LIGHT, ro, rd, FAR );\r\n    vec3 color = mix( sky, sea, pow( smoothstep(0.0, -0.05, rd.y), 0.3) );\r\n\r\n    // post-processing\r\n    gl_FragColor = LinearToGamma( vec4(color, 1.0), 1.2 ); // 2.2 => 1.2\r\n}'},3136:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\nconst float eps = 0.01;\r\nconst float OFFSET = eps * 2.0;//100.0;\r\nconst int STEPS = 64;\r\n\r\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, -0.3244428422615251 );\r\n\r\nfloat random(vec2 p) { return fract(sin(mod(dot(p.xy, vec2(12.9898, 78.233)), 3.14))*43758.5453123); }\r\n\r\n// distance functions\r\nvec3 opRep( vec3 p, float interval )\r\n{\r\n    vec2 q = mod( p.xz, interval ) - interval * 0.5;\r\n    return vec3( q.x, p.y, q.y );\r\n\r\n    // vec3 r = vec3(interval);\r\n    // return mod( p, r ) - 0.5 * r;\r\n}\r\n\r\nfloat sphereDist( vec3 p, float r )\r\n{\r\n    return length( opRep( p, 3.5*r ) ) - r;\r\n}\r\n\r\nfloat floorDist( vec3 p )\r\n// floor.y = -1.0\r\n{\r\n    return dot(p, vec3( 0.0, 1.0, 0.0 ) ) + 1.0;\r\n}\r\n\r\nvec4 minVec4( vec4 a, vec4 b )\r\n{\r\n    return ( a.a < b.a ) ? a : b;\r\n}\r\n\r\nfloat checkerPattern( vec3 p )\r\n{\r\n    float u = 1.0 - floor( mod( p.x, 2.0 ) );\r\n    float v = 1.0 - floor( mod( p.z, 2.0 ) );\r\n\r\n    if ( ( u == 1.0 && v < 1.0 ) || ( u < 1.0 && v == 1.0 ) )\r\n        return 0.5;\r\n    else\r\n        return 1.0;\r\n}\r\n\r\nvec3 hsv2rgb( vec3 c )\r\n{\r\n    vec4 K = vec4( 1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0 );\r\n    vec3 p = abs( fract( c.xxx + K.xyz ) * 6.0 - K.www );\r\n    return c.z * mix( K.xxx, clamp( p - K.xxx, 0.0, 1.0 ), c.y );\r\n}\r\n\r\nfloat sceneDist( vec3 p )\r\n{\r\n    float radius = 1.0;// + 0.2*sin(time*0.8);\r\n\r\n    vec3 p1 = p;\r\n    p1.y += cos(p.z + time*1.2) * sin(p.x + time*1.5);\r\n\r\n    vec3 p2 = p;\r\n    p2.y += cos(time) * sin(time);\r\n\r\n    return min( sphereDist( p1, radius ), floorDist( p2 ) );\r\n}\r\n\r\nvec3 sceneColor( vec3 p )\r\n{\r\n    float radius = 1.0;\r\n    vec3 sphereColor = hsv2rgb( vec3( (p.z + p.x)/9.0, 1.0, 1.0) );\r\n    vec3 checkerColor = vec3(0.5) * checkerPattern( p );\r\n\r\n    float d1 = sphereDist( p, radius );\r\n    float d2 = floorDist( p );\r\n    return mix( sphereColor, checkerColor, float(d1 > d2) );\r\n\r\n    // return minVec4(\r\n    //     // 3 * 6 / 2 = 9\r\n    //     vec4( sphereColor, sphereDist( p, radius ) ),\r\n    //     vec4( checkerColor, floorDist( p ) )\r\n    // );\r\n}\r\n\r\n// vec3 getNormal( vec3 p )\r\n// {\r\n//     return normalize(vec3(\r\n//         sceneDist(p + vec3( eps, 0.0, 0.0 ) ) - sceneDist(p + vec3( -eps, 0.0, 0.0 ) ),\r\n//         sceneDist(p + vec3( 0.0, eps, 0.0 ) ) - sceneDist(p + vec3( 0.0, -eps, 0.0 ) ),\r\n//         sceneDist(p + vec3( 0.0, 0.0, eps ) ) - sceneDist(p + vec3( 0.0, 0.0, -eps ) )\r\n//     ));\r\n// }\r\nvec3 getNormal( vec3 pos, float eps )\r\n{\r\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\r\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\r\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\r\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\r\n    return normalize( v1 * sceneDist( pos + v1*eps ) +\r\n        v2 * sceneDist( pos + v2*eps ) +\r\n        v3 * sceneDist( pos + v3*eps ) +\r\n        v4 * sceneDist( pos + v4*eps ) );\r\n}\r\nvec3 getNormal(vec3 pos)\r\n{\r\n    return getNormal(pos, 0.002);\r\n}\r\n\r\nfloat getShadow( vec3 ro, vec3 rd )\r\n{\r\n    float h = 0.0;\r\n    float c = 0.0;\r\n    float r = 1.0;\r\n    float shadowCoef = 0.5;\r\n\r\n    for ( float t = 0.0; t < 50.0; t++ )\r\n    {\r\n        h = sceneDist( ro + rd * c );\r\n        if ( h < eps ) return shadowCoef;\r\n\r\n        r = min( r, h * 16.0 / c );\r\n        c += h;\r\n    }\r\n\r\n    return 1.0 - shadowCoef + r * shadowCoef;\r\n}\r\n\r\nvec3 getRayColor( vec3 ro, vec3 rd, out vec3 pos, out vec3 normal, out bool hit )\r\n{\r\n    // marching loop\r\n    float dist;\r\n    float depth = 0.0;\r\n    pos = ro;\r\n\r\n    for ( int i = 0; i < STEPS; i++ )\r\n    {\r\n        dist = sceneDist( pos );\r\n        depth += dist;\r\n        pos = ro + depth * rd;\r\n        if ( abs(dist) < eps ) break;\r\n    }\r\n\r\n    // hit check and calc color\r\n    vec3 color = vec3( 0.0 );\r\n    if ( abs(dist) < eps )\r\n    {\r\n        normal = getNormal( pos );\r\n        float diffuse = clamp( dot( lightDir, normal ), 0.1, 1.0 );\r\n        float specular = pow( clamp( dot( reflect( lightDir, normal ), rd ), 0.0, 1.0 ), 10.0 );\r\n        float shadow = getShadow( pos + normal * OFFSET, lightDir );\r\n        color = ( sceneColor( pos ) * diffuse + vec3( 0.8 ) * specular ) * max( 0.5, shadow );\r\n        hit = true;\r\n    }\r\n\r\n    // attenuation\r\n    //return color - pow( clamp( 0.05 * depth, 0.0, 0.6 ), 2.0 );\r\n    return color;\r\n}\r\n\r\nvoid main()\r\n{\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    vec3 color = vec3( 0.0 );\r\n    vec3 pos, normal;\r\n    bool hit;\r\n    float alpha = 1.0;\r\n\r\n    for( int i = 0; i < 3; i++ )\r\n    {\r\n        color += alpha * getRayColor( ro, rd, pos, normal, hit );\r\n\r\n        // compute fragDepth at the 1st hit...\r\n        if( i == 0 && hit ) gl_FragDepth = getFragDepth( pos );\r\n\r\n        // create a new ray for another hit...\r\n        alpha *= 0.3;\r\n        rd = normalize( reflect( rd, normal ) );\r\n        ro = pos + normal * OFFSET; // if OFFSET = 0.0, ray does not start...\r\n\r\n        if( !hit ) {\r\n            gl_FragDepth = 1.0; // fragment will be killed\r\n            break;\r\n        }\r\n    }\r\n\r\n    gl_FragColor = vec4( color, 1.0 );\r\n}"},4367:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\n\n//#define ENABLE_TEST_RENDER\n\n#ifdef LOW_QUALITY\n\t#define kRaymarchMaxIter 16\n#else\n\t#define kRaymarchMaxIter 32\n\t#define ENABLE_AMBIENT_OCCLUSION\n\t#define DOUBLE_SIDED_TRANSPARENCY\n#endif\n\n#ifdef ENABLE_HARD_SHADOWS\n\t#undef ENABLE_SOFT_SHADOWS\n#else\n\t#define ENABLE_SOFT_SHADOWS\n#endif\n\n#define ENABLE_SPECULAR\n#define ENABLE_REFLECTIONS\n#define ENABLE_TRANSPARENCY\n#define ENABLE_FOG\n#define ENABLE_TEXTURE\t\t\t//psk: now not working\n\n#define ENABLE_DIRECTIONAL_LIGHT\n#define ENABLE_DIRECTIONAL_LIGHT_FLARE\n//#define ENABLE_POINT_LIGHT\n//#define ENABLE_POINT_LIGHT_FLARE\n\nconst float kFarClip = 100.0;\nconst float kRaymarchEpsilon = 0.001;\t//0.01\nconst float kFogDensity = 0.005;\t\t//0.05\nconst float kPI = 3.141592654;\nconst float kTwoPI = kPI * 2.0;\nconst float kTranspNo = -1.0;\nconst float kTranspYes = 1.0;\nconst float kTranspInverse = 0.0;\n\nconst float kMaterialGround = 1.0;\t\t// sky=0.0\nconst float kMaterialGold = 2.0;\nconst float kMaterialSilver = 3.0;\nconst float kMaterialWall = 4.0;\nconst float kMaterialPipe = 5.0;\nconst float kMaterialWater = 6.0;\nconst float kMaterialTexture0 = 7.0;\t// textureMaps[0]\nconst float kMaterialTexture1 = 8.0;\t// textureMaps[1]\n\nstruct CRay\n{\n\tvec3 vOrigin;\n\tvec3 vDir;\n\tfloat fStartDist;\n\tfloat fLength;\t// maximum distance of ray\n};\nstruct CHitInfo\n{\n\tvec3 vPos;\t\t// vPos = ro + rd * fDist\n\tfloat fDist;\n\tvec3 vObjectID;\t// x=ID, yz=??(tex_uv)\n}; \nstruct CSurface\n{\n\tvec3 vNormal;\n\tvec3 cReflection;\t// reflected color\n\tvec3 cTransmission;\t// transmitted color (refraction)\n};\nstruct CMaterial\n{\n\tvec3 cAlbedo;\t\t// diffuse reflectivity (= cTexture * cTexture)\n\tfloat fR0;\t\t\t// reflection coeff for light incoming parallel to the normal (= [(n1-n2)/(n1+n2)]^2 )\n\tfloat fSmoothness;\t// related to alpha for (n*h)^alpha\n\tvec2 vParam;\n\tfloat fTransparency;\n\tfloat fRefractIndex;\t// defined as n1/n2 (where n1=come, n2=go)\n\t// cf: n(Air) = 1.0003, n(Water)=1.333, n(common Glass)=1.52, n(Diamond)=2.42\n\t// n(Aluminium/Al)=1.0972, n(Copper/Cu)=0.46090, n(Iron/Fe)=2.9304\n\t// n(Gold/Au)=0.27049, n(Silver/Ag)=0.15016, n(Titanium/Ti)=2.6112, n(Lead/Pb)=2.6\n};\nstruct CShading\n{\n\tvec3 cDiffuse;\n\tvec3 cSpecular;\n};\nstruct CPointLight\n{\n\tvec3 vPos;\n\tvec3 cCol;\n};\nstruct CDirectionalLight\n{\n\tvec3 vDir;\n\tvec3 cCol;\n};\n\n//----------------------------------------------------------------------------\n// primitives\n//----------------------------------------------------------------------------\nfloat fSphere( vec3 p, float r )\n// r = radius\n{\n\treturn length(p) - r;\n}\nfloat fEllipsoid( in vec3 p, in vec3 r )\n{\n\treturn (length( p/r ) - 1.0) * min(min(r.x, r.y), r.z);\n}\nfloat fBox( vec3 p, vec3 b )\n// b.x =half of width (along x-axis)\n// b.y = halft of height (along y-axis)\n// b.z = half of depth (along z-axis)\n{\n\tvec3 d = abs(p) - b;\n\treturn min( max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\nfloat fTorus( vec3 p, vec2 t )\t\t// t=(major radius, minor radius)\n// p.xyz : rotating the circle around the y-axis\n// p.yzx : rotating the circle around the z-axis\n// p.zxy : rotating the circle around the x-axis\n{\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\t// zaxis = major axis of rotation\n\treturn length(q) - t.y;\n}\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat fTorus82( vec3 p, vec2 t )\t// similar to fTorus\n{\n\tvec2 q = vec2(length2(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\nfloat fTorus88( vec3 p, vec2 t )\t// similar to fTorus\n{\n\tvec2 q = vec2(length8(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\nfloat fCylinder( vec3 p, vec2 h )\n// p = pos relative to center point\n// h.x = radius, h.y = half of height\n{\n\tvec2 d = abs( vec2( length(p.xz), p.y ) ) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\nfloat fCone( in vec3 p, in vec3 c )\n// p = pos relative to apex\n// c.xy = normal to cone surface (cf: if c.x>c.y, more steeper cone)\n// c.z = height downward from apex\n{\n\tvec2 q = vec2( length(p.xz), p.y );\n\tfloat d1 = -q.y-c.z;\n\tfloat d2 = max( dot(q,c.xy), q.y );\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\nfloat fConeSection( in vec3 p, in float h, in float r1, in float r2 )\t// h=height, r1=base_radius, r2=top_radius\n// p = pos relative to base center\n// h = half of height\n// r1 = base radius, r2 = top radius\n{\n\tfloat d1 = -p.y - h;\n\tfloat q = p.y - h;\n\tfloat si = 0.5*(r1-r2)/h;\n\tfloat d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n}\nfloat fTriPrism( vec3 p, vec2 h )\n// rect-face is parallel to ground & tri-face is normal to ground\n// h.x = side length of triangle\n// h.y = height of prism (along z-axis)\n{\n\tvec3 q = abs(p);\n\treturn max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat fHexPrism( vec3 p, vec2 h )\n// h.x = radius of the inscribed circle of hex\n// h.y = half of height (along z-axis)\n{\n\tvec3 q = abs(p);\n#if 0\n\treturn max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n\tfloat d1 = q.z-h.y;\n\tfloat d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n\treturn length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.0);\n#endif\n}\n\nfloat fCapsule( vec3 p, vec3 a, vec3 b, float r )\n// a = start point, b = end point\n// r = radius of both ends\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\nfloat fPlane( vec3 p, vec3 n )\n// p = pos relative to (0,0,0)\n// n = unit normal\n{\n\treturn dot(n, p);\n}\n\n//----------------------------------------------------------------------------\n// (function-level) operations (real-valued function: f=(dist to surface))\n//----------------------------------------------------------------------------\nfloat fUnion( const in float f1, const in float f2 )\n{\n\treturn mix(f1, f2, step(f2, f1));\n}\nfloat fIntersect( const in float f1, const in float f2 )\n{\n\treturn mix(f2, f1, step(f2, f1));\n}\nfloat fSubtract( const in float f1, const in float f2 )\n{\n\treturn fIntersect(f1, -f2);\n}\nfloat fDisplace( const in float f1, const in float ds )\n{\n\treturn f1+ds;\n}\nfloat fSmoothPoly( const in float a, const in float b, const in float k ) // polynomial smooth min (k = 0.1)\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat fSmoothExp( const in float a, const in float b, const in float k ) // exponential smooth min (k = 32)\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n\treturn -log( res )/k;\n}\nfloat fSmoothPow( const in float a, const in float b, const in float k ) // power smooth min (k = 8)\n{\n\tfloat aa = pow( a, k );\n\tfloat bb = pow( b, k );\n\treturn pow( (aa*bb) / (aa+bb), 1.0/k );\n}\nfloat fNoise( const in vec2 p )\n{\n\tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\n\treturn dot(s, vec2(0.125)) + 0.5;\n}\n\n//----------------------------------------------------------------------------\n// (object-level) operations (vector-valued object: d.xyzw=(dist, matID, texU, texV))\n//----------------------------------------------------------------------------\nvec4 dUnion( const in vec4 d1, const in vec4 d2 )\n{\n\treturn mix(d1, d2, step(d2.x, d1.x));\n}\nvec4 dUnionTransp( const in vec4 d1, const in vec4 d2, const in float fTranspScale )\n{\n\t// Negate the distance to the transparency object if transparent scale is 0.0\n\t// This allows us to retrace out of transparency\n\tvec4 vScaled = vec4(d2.x * (fTranspScale * 2.0 - 1.0), d2.yzw);\n\n\t// The condition allows us to ignore transparency for secondary rays\n\treturn mix(d1, vScaled, step(vScaled.x, d1.x) * step(0.0, fTranspScale));\n}\nvec4 dIntersect( const in vec4 d1, const in vec4 d2 )\n{\n\treturn mix(d2, d1, step(d2.x,d1.x));\n}\nvec4 dSubtract( const in vec4 d1, const in vec4 d2 )\n{\n\treturn dIntersect(d1, vec4(-d2.x, d2.yzw));\n}\nvec4 dDisplace( const in vec4 d1, const in float ds )\n// ds = displacement to apply to d1\n// for example:\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\n// vec4 new_sphere = dDisplace( vec4(fSphere(p,r), gold), ds(p) );\n{\n\treturn vec4( d1.x+ds, d1.yzw );\n}\nvec4 dBlend( const in vec4 d1, const in vec4 d2, const in float k )\n// using polynomial smooth min (often k = 0.1)\n{\n\tfloat fdist = fSmoothPoly( d1.x, d2.x, k );\n\tvec3 vmat = mix( d1.yzw, d2.yzw, step(d2.x, d1.x) );\n\treturn vec4( fdist, vmat );\n}\n\n//----------------------------------------------------------------------------\n// (space-level) operations (vector-valued space: p=(x,y,z))\n//----------------------------------------------------------------------------\nvec3 sRepeat( const in vec3 p, const in vec3 spacing )\n// The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\n// if spacing.y=0, then infinite column is repeated along x-axis & z-axis\n{\n\t//return mod(p, spacing) - 0.5*spacing;\n\tvec3 q = p - 0.5*spacing;\n\treturn mod(q, spacing) - 0.5*spacing;\n}\nvec3 sTwist( const in vec3 p, const in float angle )\n// twist by angle per unit-length along y-axis with the right-hand rule\n{\n\tfloat c = cos( angle*p.y );\n\tfloat s = sin( angle*p.y );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 twist = m*p.zx;\n\treturn vec3( twist.y, p.y, twist.x );\n}\nvec3 sTwistY( const in vec3 p, const in float angle )\t// twist along y-axis\n{\n\treturn sTwist( p, angle );\n}\nvec3 sTwistZ( const in vec3 p, const in float angle )\t// twist along z-axis\n{\n\tvec3 q = p.yzx;\n\tq = sTwist( q, angle );\n\treturn q.zxy;\n}\nvec3 sTwistX( const in vec3 p, const in float angle )\t// twist along x-axis\n{\n\tvec3 q = p.zxy;\n\tq = sTwist( q, angle );\n\treturn q.yzx;\n}\nvec3 sTranslate( const in vec3 p, const in vec3 t )\n{\n\treturn p - t;\n}\nvec3 sRotateX( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\n}\nvec3 sRotateY( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\n}\nvec3 sRotateZ( const in vec3 p, const in float angle )\n{\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\n}\n// Scale\n// e.g., float fScaled = fSphere( p/s, r ) * s\n// only possible to scale uniformly\nvec3 sCheapBendY( const in vec3 p, float angle )\n// bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.x );\n\tfloat s = sin( angle*p.x );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.zx;\n\treturn vec3( b.y, p.y, b.x );\n}\nvec3 sCheapBendZ( const in vec3 p, float angle )\n// bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.y );\n\tfloat s = sin( angle*p.y );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.xy;\n\treturn vec3( b.x, b.y, p.z );\n}\nvec3 sCheapBendX( const in vec3 p, float angle )\n// bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\n{\n\tfloat c = cos( angle*p.z );\n\tfloat s = sin( angle*p.z );\n\tmat2 m = mat2( c, -s, s, c );\n\tvec2 b = m*p.yz;\n\treturn vec3( p.x, b.x, b.y );\n}\n\n//----------------------------------------------------------------------------\n// Scene Description\n//----------------------------------------------------------------------------\nvec4 dCheckerBoard( const in vec3 vPos )\n{\n\treturn vec4( fPlane( vPos-vec3(0.0), vec3(0.0, 1.0, 0.0) ), kMaterialGround, vPos.xy );\n}\nvec4 SimpleScene( const in vec3 vPos, const in float fTranspScale )\n{\n\tvec3 tex0 = vec3(kMaterialTexture0, vPos.z, vPos.x);\n\tvec3 tex1 = vec3(kMaterialTexture1, vPos.x, vPos.y);\n\tvec3 gold = vec3(kMaterialGold, vPos.z, vPos.x);\n\tvec3 silver = vec3(kMaterialSilver, vPos.z, vPos.x);\n\tvec4 res = dCheckerBoard( vPos );\n#if 0\n\tres = dUnion( res, vec4( fBox(vPos-vec3(0.5,0.5,0.5), vec3(0.5)), silver ) );\n#endif\n\n#if 0\n\tres = dUnion( res, vec4( fBox(vPos-vec3(0.5,0.5,0.5), vec3(0.25)), tex0 ) );\n\tres = dUnion( res, vec4( fCylinder(vPos-vec3(1,0.3,0), vec2(0.2, 0.3)), tex1 ) );\n\tres = dUnion( res, vec4( fCone(vPos-vec3( 0.0,0.9, 1.0), vec3(0.8, 0.1, 0.6) ), gold ) );\n#endif\n\n#if 1\n\tvec3 p = sRepeat( vPos, vec3(10.0, 10.0, 10.0) );\n\tres = dUnion( res, vec4( fSphere(p, 2.5), tex0 ) );\n#endif\n\n#if 0\n\tvec3 p = sCheapBendX( vPos, kPI/4.0 );\n\tres = dUnion( res, vec4( fBox(p, vec3(1, 0.2, 1)), gold ) );\n#endif\n\n#if 0\n\tfloat a = 2.0;\tfloat r = 0.5;\n\tvec3 p = sTranslate( vPos, vec3(0,0,0) );\n\tfloat dfmValue = sin(a*p.x)*sin(a*p.y)*sin(a*p.z);\n\tvec4 dsphere = vec4( fSphere(p, r), gold );\n\tvec4 dsphere1 = dDisplace( dsphere, dfmValue );\n\tres = dUnion( res, dsphere1 );\t//psk : some portion is clipped out (need to debug)\n#endif\n\n#if 0\n\tfloat k = 0.1;\n\tvec3 p = sTranslate( vPos, vec3(0,2,0) );\n\tvec4 dcy1 = vec4( fCylinder(p, vec2(1.0,2.0)), gold );\n\tvec4 dcy2 = vec4( fCylinder(p.yzx, vec2(0.5, 2.0)), silver );\n\tres = dUnion( res, dBlend( dcy1, dcy2, k ) );\n#endif\n\n\treturn res;\n}\nvec4 PrimitiveScene( const in vec3 pos, const in float fTranspScale )\n{\n\t//vec3 gold = vec3(kMaterialGold, 0, 0);\n\tvec3 gold = vec3(kMaterialGold, pos.x, pos.y);\t//psk : texUV=(pos.x, pos.y)\n\t\n\tvec4 res = dCheckerBoard( pos );\n\tres = dUnion( res, vec4( fSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), gold ) );\n\tres = dUnion( res, vec4( fBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), gold ) );\n\tres = dUnion( res, vec4( fTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), gold ) );\n\tres = dUnion( res, vec4( fTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), gold ) );\n\tres = dUnion( res, vec4( fCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), gold ) );\n\tres = dUnion( res, vec4( fTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fCylinder(  pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), gold ) );\n\tres = dUnion( res, vec4( fHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ), gold ) );\n\tres = dUnion( res, vec4( fSubtract(  fBox( pos-vec3(-2.0,0.2, 1.0), vec3(0.2)), fSphere( pos-vec3(-2.0,0.2, 1.0), 0.25)), gold ) );\n\tres = dUnion( res, vec4( fSubtract( fTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)), fCylinder( sRepeat( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2,0.0)) ), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), gold ) );\n\tres = dUnion( res, vec4( 0.7*fSphere( pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), gold ) );\n\tres = dUnion( res, vec4( 0.5*fTorus( sTwist(pos-vec3(-2.0,0.25, 2.0), 20.0), vec2(0.20,0.05)), gold ) );\n\tres = dUnion( res, vec4( fConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), gold ) );\n\tres = dUnion( res, vec4( fEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), gold ) );\n\treturn res;\n}\nvec4 SpoutScene( const in vec3 vPos, const in float fTranspScale )\n{\n    const float kPipeRadius = 0.4;\n    const float kPipeThickness = 0.15;\n    const float kWaterNoiseScale = 0.025;\n    const float kWaterVelocity = 1.0;\n    const float kWaterAccel = -1.0;\n    const float kWaterAnimSpeed = 80.0;\n    const float kTrenchWaterAnimSpeed = 20.0;\n\n    //float kPipeHeight = 2.0;\n\tfloat kPipeHeight = 2.0 + sin(time);\n    float kRipplePos = sqrt(abs(2.0 * kPipeHeight / kWaterAccel)) * kWaterVelocity;\n\n\tvec4 vResult = vec4(10000.0, -1.0, 0.0, 0.0);\n\tfloat fDistFloor = vPos.y;\n\tfloat fDistBrick = fDistFloor;\n\tfloat fDistTrench = length(vPos.yz + vec2(-0.4, 0.0)) - 1.0;\n\tfDistBrick = max(fDistBrick, -(fDistTrench));\n\tfloat fDistWall = vPos.x + 1.0;\n\tfDistBrick = min(fDistBrick, fDistWall);\n\tvec4 vDistFloor = vec4(fDistBrick, kMaterialWall, vPos.xz + vec2(vPos.y, 0.0));\n\tvResult = dUnion(vResult, vDistFloor);\n\tvec3 vWaterDomain = vPos - vec3(0.0, kPipeHeight, 0.0);\n\n\tfloat t = max(vWaterDomain.x / kWaterVelocity, 0.0);\n\n\t// Equations of motion\n\tfloat s = 0.5 * kWaterAccel * t * t;\n\tfloat v = -kWaterAccel * t;\n\n\tvWaterDomain.y -= s;\n\tfloat fDistWater = (length(vWaterDomain.yz) - kPipeRadius);\n\tfloat fDistPipe = max(fDistWater - kPipeThickness, vWaterDomain.x);\n\tfDistPipe = max(fDistPipe, -fDistWater); // subtract the water from the pipe to make the hole\n\tvec4 vDistPipe = vec4(fDistPipe, kMaterialPipe, vPos.xy);\n\n\tvResult = dUnion(vResult, vDistPipe);\n\n\t// compensate for domain distortion of water, otherwise ray sometimes misses\n\tfDistWater /= (1.0 + v * 0.5);\n\tvec2 vNoiseDomain = vPos.xz;\n\n\t// modify noise for water in trench\n\tfloat fInTrench = step(vPos.y, (-0.1 + 0.05));\n\tvec2 vRippleCentre1 = vPos.xz - vec2(kRipplePos, 0.0);\n\tvNoiseDomain.x = mix(vNoiseDomain.x, length(vRippleCentre1), fInTrench);\n\tfloat fNoiseScale = mix(t * t, 1.0 / (1.0 + vNoiseDomain.x), fInTrench) * kWaterNoiseScale;\n\tfloat fWaterSpeed = mix(kWaterAnimSpeed * kWaterVelocity, kTrenchWaterAnimSpeed, fInTrench);\n\n\tvNoiseDomain *= 30.0;\n\tvNoiseDomain.x += -time * fWaterSpeed;\n\n\tfloat fTrenchWaterDist = vPos.y + 0.1;\n\tfDistWater = min(fDistWater, fTrenchWaterDist);\n\tfDistWater += fNoise(vNoiseDomain) * fNoiseScale;\n\tvec4 vDistWater = vec4(fDistWater, kMaterialWater, vPos.xy);\n\tvResult = dUnionTransp(vResult, vDistWater, fTranspScale);\n\treturn vResult;\n}\n\n//----------------------------------------------------------------------------\n\nvec4 GetDistanceScene( const in vec3 vPos, const in float fTranspScale )\n// return vec4.x = scene_distance\n//        vec4.y = material (or object) id\n//        vec4.zw = material specific parameters (maybe uv coordinates)\n{\n\treturn SpoutScene( vPos, fTranspScale );\t\t// scene example 1\n\t//return SimpleScene( vPos, fTranspScale );\n\t//return PrimitiveScene( vPos, fTranspScale );\n}\n\nCMaterial GetObjectMaterial( const in CHitInfo hitInfo )\n{\n#if 0\t\t// reflectance of a material\nmat.cAlbedo = vec3(0.93, 0.88, 0.38);\t// Gold\nmat.cAlbedo = vec3(0.26, 0.28, 0.26);\t// Iridium\nmat.cAlbedo = vec3(0.44, 0.435, 0.43);\t// Iron\nmat.cAlbedo = vec3(0.50, 0.47, 0.36);\t// Nickel\nmat.cAlbedo = vec3(0.93, 0.80, 0.46);\t// Copper\nmat.cAlbedo = vec3(0.63, 0.62, 0.57);\t// Platinum\nmat.cAlbedo = vec3(0.97, 0.97, 0.96);\t// Silver\n#endif\n\tCMaterial mat;\n\tif(hitInfo.vObjectID.x == kMaterialTexture0)\t\t// textureMaps[0]\n\t{\n\t\tmat.cAlbedo = texture( textureMaps[0], hitInfo.vObjectID.yz ).rgb;\n\t\tmat.fR0 = (1.0003-0.27049)/(1.0003+0.27049);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialTexture1)\t\t// textureMaps[1]\n\t{\n\t\tmat.cAlbedo = texture( textureMaps[1], hitInfo.vObjectID.yz ).rgb;\n\t\tmat.fR0 = 0.2;//2.0;\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialGround)\n\t{\n\t\tfloat ncell = 2.0;//5.0;\t// ncell = no. cell per unit length (e.g. if ncell=2, then cellsize=0.5)\n\t\tfloat f = mod( floor(ncell*hitInfo.vPos.z) + floor(ncell*hitInfo.vPos.x), 2.0 );\n\t\tmat.cAlbedo = 0.4 + 0.1*f*vec3(1.0);\n\t\tmat.fR0 = 4.0;//0.8;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialGold)\n\t{\n\t\tmat.cAlbedo = vec3(1.0, 0.84, 0.0);\n\t\tmat.fR0 = (1.0003-0.27049)/(1.0003+0.27049);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialSilver)\n\t{\n\t\tmat.cAlbedo = vec3(0.75, 0.75, 0.75);\n\t\tmat.fR0 = (1.0003-0.15016)/(1.0003+0.15016);\n\t\tmat.fR0 *= mat.fR0;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialWall)\n\t{\n\t\t// floor\n\t\tmat.fR0 = 0.02;\n\t#ifdef ENABLE_TEXTURE\n\t\t//hitInfo.vObjectID.yz = fragTexCoord;\n\t\tvec3 cTexture = texture(textureMaps[0], hitInfo.vObjectID.yz * 0.25).rgb;\n\n\t\tmat.cAlbedo = cTexture * cTexture;\n\t\tmat.fSmoothness = mat.cAlbedo.r;\n\t\tmat.fTransparency = 0.0;\n\t#else\n\t\t// Textureless version\n\t\tvec2 vTile = step(vec2(0.15), fract(hitInfo.vObjectID.yz));\n\t\tfloat fTile = vTile.x * vTile.y;\n\t\tmat.cAlbedo = vec3(1.0) * (fTile * 0.8 + 0.2);\n\t\tmat.fSmoothness = 1.0;\n\t#endif\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialPipe)\n\t{\n\t\tmat.fR0 = 0.8;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.cAlbedo = vec3(0.5);\n\t\tmat.fTransparency = 0.0;\n\t}\n\telse if(hitInfo.vObjectID.x == kMaterialWater)\n\t{\n\t\tmat.fR0 = 0.01;\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 1.0;\n\t\tmat.fRefractIndex = 1.0 / 1.3330;\t// n1(air) / n2(water)\n\t\tconst float fExtinctionScale = 2.0;\n\t\tconst vec3 vExtinction = vec3(0.3, 0.7, 0.9);\n\t\tmat.cAlbedo = (vec3(1.0) - vExtinction) * fExtinctionScale; // becomes extinction for transparency\n\t}\n\telse\n\t{\n\t\t// red color not to define a material\n\t\tmat.cAlbedo = vec3(1,0,0);\n\t\tmat.fSmoothness = 1.0;\n\t\tmat.fTransparency = 0.0;\n\t}\n\treturn mat;\n}\n\nvec3 GetSkyGradient( const in vec3 vDir )\n{\n\tconst vec3 cColourTop = vec3(0.7, 0.8, 1.0);    // cSky\n\tconst vec3 cColourHorizon = cColourTop * 0.5;   // cGround\n\tfloat fBlend = clamp(vDir.y, 0.0, 1.0);         // w = clamp(vDir.y, 0.0, 1.0)\n\treturn mix(cColourHorizon, cColourTop, fBlend); // skyGradient = cGround*(1-w) + cSky * w\n}\n\nCPointLight GetPointLight()\n{\n\tCPointLight result;\n\tresult.vPos = vec3(0.5, 1.0, -2.0);\n    //result.cCol = vec3(32.0, 6.0, 1.0) * 10.0;\n\tresult.cCol = vec3(32.0, 6.0, 1.0) * 2.0;\n\treturn result;\n}\n\nCDirectionalLight GetDirectionalLight()\n{\n\tCDirectionalLight result;\n\tresult.vDir = normalize(vec3(-0.2, -0.3, 0.5));\n    //result.cCol = vec3(8.0, 7.5, 7.0);\n\tresult.cCol = vec3(2.0, 1.5, 1.0);\n\treturn result;\n}\n\nvec3 GetAmbientLight(const in vec3 vNormal)\n{\n\treturn GetSkyGradient(vNormal); // Lc = skyGradient\n}\n\n//----------------------------------------------------------------------------\n// Raymarching\n//----------------------------------------------------------------------------\nvec3 GetSceneNormal( const in vec3 vPos, const in float fTranspScale )\n{\n\tvec3 eps = vec3( kRaymarchEpsilon, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tGetDistanceScene(vPos+eps.xyy, fTranspScale).x - GetDistanceScene(vPos-eps.xyy, fTranspScale).x,\n\t\tGetDistanceScene(vPos+eps.yxy, fTranspScale).x - GetDistanceScene(vPos-eps.yxy, fTranspScale).x,\n\t\tGetDistanceScene(vPos+eps.yyx, fTranspScale).x - GetDistanceScene(vPos-eps.yyx, fTranspScale).x );\n\treturn normalize(nor);\n}\nvoid Raymarch( const in CRay ray, out CHitInfo result, const int maxIter, const float fTranspScale )\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n{\n    result.fDist = ray.fStartDist;\n    result.vObjectID.x = 0.0;\n    for(int i=0;i<=kRaymarchMaxIter; i++)\n    {\n        result.vPos = ray.vOrigin + ray.vDir * result.fDist;\n        vec4 vSceneDist = GetDistanceScene( result.vPos, fTranspScale );\n        result.vObjectID = vSceneDist.yzw;\n        // abs allows backward stepping - should only be necessary for non uniform distance functions\n        if( (abs(vSceneDist.x) <= kRaymarchEpsilon) || (result.fDist >= ray.fLength) || (i > maxIter) ) break;\n        result.fDist = result.fDist + vSceneDist.x;\n    }\n    if(result.fDist >= ray.fLength)\n    {\n        result.fDist = kFarClip;\n        result.vPos = ray.vOrigin + ray.vDir * result.fDist;\n        result.vObjectID.x = 0.0; // maybe sky\n    }\n}\n\nfloat GetShadow( const in vec3 vPos, const in vec3 vNormal, const in vec3 vLightDir, const in float fLightDistance )\n{\n#if defined(ENABLE_HARD_SHADOWS)\t\t// #ifdef ENABLE_HARD_SHADOWS\n    CRay shadowRay;\n    shadowRay.vDir = vLightDir;\n    shadowRay.vOrigin = vPos;\n    const float fShadowBias = 0.05;\n    shadowRay.fStartDist = fShadowBias / abs(dot(vLightDir, vNormal));\n    shadowRay.fLength = fLightDistance - shadowRay.fStartDist;\n    CHitInfo shadowIntersect;\n    Raymarch(shadowRay, shadowIntersect, 32, kTranspNo);\n    float fShadow = step(0.0, shadowIntersect.fDist) * step(fLightDistance, shadowIntersect.fDist );\n    return fShadow;\n#elif defined(ENABLE_SOFT_SHADOWS)\n    const float fShadowBias = 0.05;\n    float fDist = fShadowBias / abs(dot(vLightDir, vNormal));\n    float fDistMax = fLightDistance - fDist;\n    float fResult = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        float fSceneDist = GetDistanceScene( vPos + vLightDir*fDist, kTranspNo ).x;\n        fResult = min( fResult, 8.0*fSceneDist/fDist );\n        fDist += clamp( fSceneDist, 0.02, 0.10 );\t\t\t//psk\n        if( fSceneDist<0.001 || fDist>fDistMax ) break;\n    }\n    return clamp( fResult, 0.0, 1.0 );\n#else\n    return 1.0;\n#endif\n}\n\nfloat GetAmbientOcclusion(const in CHitInfo intersection, const in CSurface surface)\n{\n#ifdef ENABLE_AMBIENT_OCCLUSION\n    float fScaleOcc = 0.2;\t\t//psk\n    vec3 vPos = intersection.vPos;\n    vec3 vNormal = surface.vNormal;\n    float fAmbientOcclusion = 1.0;\n    float fDist = 0.0;\n    for(int i=0; i<=5; i++)\n    {\n        fDist += 0.1;\n        vec4 vSceneDist = GetDistanceScene(vPos + vNormal * fDist, kTranspNo);\n        fAmbientOcclusion *= 1.0 - max(0.0, (fDist - vSceneDist.x) * fScaleOcc / fDist );\n    }\n    return fAmbientOcclusion;\n#else\n    return 1.0;\n#endif\n}\n\n//----------------------------------------------------------------------------\n// Lighting and Shading\n//----------------------------------------------------------------------------\nvoid ApplyAtmosphere(inout vec3 col, const in CRay ray, const in CHitInfo hitInfo)\n{\n#ifdef ENABLE_FOG\n    float fFogAmount = exp(hitInfo.fDist * -kFogDensity);\n    vec3 cFog = GetSkyGradient(ray.vDir);\n    #ifdef ENABLE_DIRECTIONAL_LIGHT_FLARE\n        CDirectionalLight directionalLight = GetDirectionalLight();\n        float fDirDot = clamp(dot(-directionalLight.vDir, ray.vDir), 0.0, 1.0);\n        cFog += directionalLight.cCol * pow(fDirDot, 10.0);\n    #endif\n    col = mix(cFog, col, fFogAmount);\n#endif\n#ifdef ENABLE_POINT_LIGHT_FLARE\n    CPointLight pointLight = GetPointLight();\n    vec3 vToLight = pointLight.vPos - ray.vOrigin;\n    float fPointDot = dot(vToLight, ray.vDir);\n    fPointDot = clamp(fPointDot, 0.0, hitInfo.fDist);\n    vec3 vClosestPoint = ray.vOrigin + ray.vDir * fPointDot;\n    float fDist = length(vClosestPoint - pointLight.vPos);\n    col += pointLight.cCol * 0.01/ (fDist * fDist);\n#endif\n}\n\nfloat Schlick( const in vec3 vHalf, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vHalf, -vView); // H o V\n\tfDot = clamp((1.0 - fDot), 0.0, 1.0); // 1 - H o V\n\tfloat fDotPow = pow(fDot, 5.0); // (1 - H o V)^5\n\treturn fR0 + (1.0 - fR0) * fDotPow * fSmoothFactor; // fresnel = fR0 + (1.0 - fR0) * (1 - H o V)^5 * smoothFactor\n}\n\nvec3 ApplyFresnel(const in vec3 vDiffuse, const in vec3 vSpecular, const in vec3 vNormal, const in vec3 vView, const in CMaterial material)\n// vView = ray.vDir\n{\n\tvec3 vReflect = reflect(vView, vNormal); // R = reflect(-V, N)\n\tvec3 vHalf = normalize(vReflect + -vView); // H = R + V\n\tfloat fFresnel = Schlick(vHalf, vView, material.fR0, material.fSmoothness * 0.9 + 0.1);\n\treturn mix(vDiffuse, vSpecular, fFresnel); // return (Ld*Md) * (1-fresnel) + Ls * (fresnel)\n}\n\nfloat GetBlinnPhongIntensity(const in vec3 vIncidentDir, const in vec3 vLightDir, const in vec3 vNormal, const in float fSmoothness)\n// vIncidentDir = ray.vDir = eyePos to surfPos\n// vLightDir = surfPos to lightPos\n{          \n\tvec3 vHalf = normalize(vLightDir - vIncidentDir);  // H = L + V\n\tfloat fNdotH = max(0.0, dot(vHalf, vNormal));      // NoH = N o H\n\tfloat fSpecPower = exp2(4.0 + 6.0 * fSmoothness);  // fSmoothness ==> fSpecPower (= shininess)\n\tfloat fSpecIntensity = (fSpecPower + 2.0) * 0.125; // fSpecPower ==> fSpecIntensity (= specIntensity)\n\treturn pow(fNdotH, fSpecPower) * fSpecIntensity;   // specWt = specIntensity * NoH^(shininess)\n}\n\nCShading ApplyPointLight( const in CPointLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in CMaterial material )\n// vIncidentDir = ray.vDir = eyePos to surfPos\n{\n\tCShading shading;\n\tvec3 vToLight = light.vPos - vSurfacePos; // L\n\tvec3 vLightDir = normalize(vToLight); // L = L/|L|\n\tfloat fLightDistance = length(vToLight); // d = |L|\n\tfloat fAttenuation = 1.0 / (fLightDistance * fLightDistance); // atten = 1/(d*d)\n\tfloat fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, fLightDistance ); // shadow\n\tvec3 vIncidentLight = light.cCol * fShadowFactor * fAttenuation * max(0.0, dot(vLightDir, vNormal)); // Ld = shadow * atten * Lc * NoL\n\tshading.cDiffuse = vIncidentLight; // Ld\n\tshading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nCShading ApplyDirectionalLight( const in CDirectionalLight light, const in vec3 vSurfacePos, const in vec3 vIncidentDir, const in vec3 vNormal, const in CMaterial material )\n// vIncidentDir = ray.vDir = eyePos to surfPos\n{\n\tCShading shading;\n\tconst float kShadowRayLength = 10.0;\n\tvec3 vLightDir = -light.vDir; // L\n\tfloat fShadowFactor = GetShadow( vSurfacePos, vNormal, vLightDir, kShadowRayLength ); // shadow\n\tvec3 vIncidentLight = light.cCol * fShadowFactor * max(0.0, dot(vLightDir, vNormal)); // Ld = shadow * Lc * NoL\n\tshading.cDiffuse = vIncidentLight; // Ld\n\tshading.cSpecular = GetBlinnPhongIntensity( vIncidentDir, vLightDir, vNormal, material.fSmoothness ) * vIncidentLight; // Ls = Ld * specWt\n\treturn shading;\n}\n\nvec3 ShadeSurface(const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface, const in CMaterial material)\n{\n\tvec3 cScene;\n\tCShading shading;\n\tshading.cDiffuse = vec3(0.0);  // totalLd = 0.0\n\tshading.cSpecular = vec3(0.0); // totalLs = 0.0\n\tfloat fAmbientOcclusion = GetAmbientOcclusion(hitInfo, surface);\n\tvec3 vAmbientLight = GetAmbientLight(surface.vNormal) * fAmbientOcclusion; // La = Lc(= skyGradient) * AO\n\tshading.cDiffuse += vAmbientLight;        // totalLd += La\n\tshading.cSpecular += surface.cReflection; // totalLs += (Ms)\n\n#ifdef ENABLE_POINT_LIGHT\n    CPointLight pointLight = GetPointLight(); \n    CShading pointLighting = ApplyPointLight(pointLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += pointLighting.cDiffuse;   // totalLd += Ld\n    shading.cSpecular += pointLighting.cSpecular; // totalLs += Ls\n#endif\n\n#ifdef ENABLE_DIRECTIONAL_LIGHT\n    CDirectionalLight directionalLight = GetDirectionalLight();\n    CShading directionLighting = ApplyDirectionalLight(directionalLight, hitInfo.vPos, ray.vDir, surface.vNormal, material);\n    shading.cDiffuse += directionLighting.cDiffuse;\t  // totalLd += Ld\n    shading.cSpecular += directionLighting.cSpecular; // totalLs += Ls\n#endif\n\n\tvec3 vDiffuseReflection = shading.cDiffuse * material.cAlbedo; // totalLd * (Md)\n\tvDiffuseReflection = mix(vDiffuseReflection, surface.cTransmission, material.fTransparency);// totalDiff = (totalLd*Md)*(transp-1) + Mt*transp\n\n#ifdef ENABLE_SPECULAR\n    cScene = ApplyFresnel(vDiffuseReflection, shading.cSpecular, surface.vNormal, ray.vDir, material);// cScene = (totalDiff) * (1-fresnel) + totalLs * (fresnel)\n#else\n    cScene = vDiffuseReflection; // cScene = (totalDiff)\n#endif\n\n\treturn cScene;\n}\n\nvec3 GetSceneColourSecondary( const in CRay ray );\n\nvec3 GetReflection( const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface )\n{\n#ifdef ENABLE_REFLECTIONS    \n{\n\t// get colour from reflected ray\n    const float fSeparation = 0.1;//psk\n    CRay reflectRay;\n    reflectRay.vDir = reflect(ray.vDir, surface.vNormal);\n    reflectRay.vOrigin = hitInfo.vPos;\n    reflectRay.fLength = 16.0;//psk\n    reflectRay.fStartDist = fSeparation / abs(dot(reflectRay.vDir, surface.vNormal));\n    return GetSceneColourSecondary(reflectRay);\n}\n#else\n    return GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n#endif\n}\n\nvec3 GetTransmission( const in CRay ray, const in CHitInfo hitInfo, const in CSurface surface, const in CMaterial material )\n{\n\t#ifdef ENABLE_TRANSPARENCY\n\t{\n\t\tconst float fSeparation = 0.05;//psk\n\t\t// Trace until outside transparent object\n\t\tCRay refractRay;\n\t\t// we dont handle total internal reflection (in that case refract returns a zero length vector)\n\t\trefractRay.vDir = refract(ray.vDir, surface.vNormal, material.fRefractIndex);\n\t\trefractRay.vOrigin = hitInfo.vPos;\n\t\trefractRay.fLength = 16.0;//psk\n\t\trefractRay.fStartDist = fSeparation / abs(dot(refractRay.vDir, surface.vNormal));\n\n\t\t#ifdef DOUBLE_SIDED_TRANSPARENCY\n\t\t\tCHitInfo hitInfo2;\n\t\t\tRaymarch(refractRay, hitInfo2, 32, kTranspInverse);\n\t\t\tvec3 vNormal = GetSceneNormal(hitInfo2.vPos, kTranspInverse);\n\t\t\t\n\t\t\t// get colour from rest of scene\n\t\t\tCRay refractRay2;\n\t\t\trefractRay2.vDir = refract(refractRay.vDir, vNormal, 1.0 / material.fRefractIndex);\n\t\t\trefractRay2.vOrigin = hitInfo2.vPos;\n\t\t\trefractRay2.fLength = 16.0;\n\t\t\trefractRay2.fStartDist = 0.0;//fSeparation / abs(dot(refractRay2.vDir, vNormal));\n\t\t\t\n\t\t\tfloat fExtinctionDist = hitInfo2.fDist;\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay2);\n\t\t#else\n\t\t\tvec3 vSceneColour = GetSceneColourSecondary(refractRay);\n\t\t\tfloat fExtinctionDist = 0.5;//psk\n\t\t#endif\n\n\t\tvec3 cMaterialExtinction = material.cAlbedo;\n\t\t// extinction should really be exp(-) but this is a nice hack to get RGB\n\t\tvec3 cExtinction = (1.0 / (1.0 + (cMaterialExtinction * fExtinctionDist)));\n\t\treturn vSceneColour * cExtinction;\n\t}\n\t#else\n\t\treturn GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n\t#endif\n}\n\nvec3 GetSceneColourSecondary( const in CRay ray )\n// no reflections, no transparency, used for secondary rays\n{\n\tCHitInfo hitInfo;\n\tRaymarch(ray, hitInfo, 32, kTranspNo);\n\tvec3 cScene;\n\tif( hitInfo.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n\t{\n\t\tCSurface surface;\n\t\tsurface.vNormal = GetSceneNormal(hitInfo.vPos, kTranspNo);\n\t\tCMaterial material = GetObjectMaterial(hitInfo);\n\t\t// use sky gradient instead of reflection\n\t\tsurface.cReflection = GetSkyGradient(reflect(ray.vDir, surface.vNormal));\n\t\tmaterial.fTransparency = 0.0;\n\t\t// apply lighting\n\t\tcScene = ShadeSurface(ray, hitInfo, surface, material);\n\t}\n\tApplyAtmosphere(cScene, ray, hitInfo);\n\treturn cScene;\n}\n\nvec3 GetSceneColourTestVersion( const in CRay ray )\n{\n\tvec3 cScene;\n\tCHitInfo intersection;\n\tRaymarch(ray, intersection, 256, kTranspNo);\n\tif( intersection.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\t}\n\telse\n    {\n\t\tfloat t = intersection.fDist;\n        vec3 pos = intersection.vPos;\n\t\tCSurface surface;\n\t\tsurface.vNormal = GetSceneNormal(intersection.vPos, kTranspNo);\n\t\tvec3 nor = surface.vNormal;\n        vec3 ref = reflect( ray.vDir, nor );\n\t\t//vec3 col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) ); // material\n\t\tCMaterial material = GetObjectMaterial( intersection );\n\t\tvec3 col = material.cAlbedo;\n\t\tfloat occ = GetAmbientOcclusion( intersection, surface );\n\t\t// lighitng\n\t\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor, ray.vDir), 0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\t\tdif *= GetShadow( pos, nor, lig, 2.5 );\t\t// 2.5 = max distance from hitPos to lightPos\n\t\tdom *= GetShadow( pos, nor, ref, 2.5 );\n\t\tvec3 lin = vec3(0.0);\n\t\tfloat scale = 2.0;//1.2;\n        lin += scale*dif*vec3(1.00,0.85,0.55);\n\t\tlin += scale*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t ) ); // fog\n\t\tcol = clamp(col, 0.0, 1.0);\n\t\tcScene = pow( col, vec3(0.4545) ); //psk\n    }\n\treturn cScene;\n}\n\nvec3 GetSceneColourPrimary( const in CRay ray )\n{\n#ifdef ENABLE_TEST_RENDER\n\treturn GetSceneColourTestVersion( ray );\n#else\n\n\tCHitInfo intersection;\n\tRaymarch(ray, intersection, 256, kTranspYes);\n\tvec3 cScene;\n\tif( intersection.vObjectID.x < 0.5 )\n\t{\n\t\tcScene = GetSkyGradient(ray.vDir);\n\n\t\t// fragment depth\n\t\tgl_FragDepth = 0.99;\n\t}\n\telse\n\t{\n\t\tCSurface surface;\n\t\t// surface normal\n\t\tsurface.vNormal = GetSceneNormal(intersection.vPos, kTranspYes);\n\t\t// material selection\n\t\tCMaterial material = GetObjectMaterial(intersection);\n\t\t// surface reflection\n\t\tsurface.cReflection = GetReflection(ray, intersection, surface);\n\t\t// surface transmission\n\t\tif(material.fTransparency > 0.0)\n\t\t{\n\t\t\tsurface.cTransmission = GetTransmission(ray, intersection, surface, material);\n\t\t}\n\t\t// apply lighting\n\t\tcScene = ShadeSurface(ray, intersection, surface, material);\n\n\t\t// fragment depth\n\t\tgl_FragDepth = getFragDepth( intersection.vPos );\n\t}\n\tApplyAtmosphere(cScene, ray, intersection);\n\treturn cScene;\n#endif\n}\n\nvec3 Tonemap( const in vec3 cCol )\n{\n\tvec3 vResult = 1.0 -exp2(-cCol);\n\treturn vResult;\n}\n\nvoid main()\n{\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\n\n\tCRay ray;\n\tray.vOrigin = ro;\n\tray.vDir = rd;\n\tray.fStartDist = 0.0;\n\tray.fLength = kFarClip;\n\n\tvec3 cScene = GetSceneColourPrimary( ray );\n\n\tgl_FragColor = vec4( Tonemap(cScene * 1.5), 1.0 ); //fExposure = 1.5\n}"},2109:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n//#define USE_CLOUDS_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/terrain/rockyTerrainDirt.jpg' (512 x 512)\r\n// textureMaps[1] = 'images/raymarch/organic1.jpg' (1024 x 1024)\r\n// textureMaps[2] = 'images/raymarch/grayNoise256.png' (256 x 256)\r\n// textureMaps[3] = 'images/raymarch/lichen.jpg' (1024 x 1024)\r\n#define iChannel0   textureMaps[0]\r\n#define iChannel1   textureMaps[1]\r\n#define iChannel2   textureMaps[2]\r\n#define iChannel3   textureMaps[3]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n\r\nconst float FAR = 300.0;//300.0;\r\nconst vec3 SUN_LIGHT = normalize(vec3(-0.8, 0.4, -0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 100.0;//300.0;\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\n\r\n// terrain land scales...\r\nconst float MYSTERY_LAND_SCALE = 1.65;\r\nconst float GRASS_LAND_SCALE = 1.75;\r\nconst float BUMPY_LAND_SCALE = 1.2;\r\nconst float STONE_LAND_SCALE = 1.9;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nfloat grassLand( vec3 p )\r\n{\r\n    float h = triSmooth12( vec2(0.19, 0.31) + triSmooth12( p.xz/16.0 ) );\r\n    //float h = triSmooth12( vec2(0.11, 0.99) + triSmooth12( p.xz/16.0 ) );\r\n    //float h = triSmooth12( vec2(0.22, 0.88) + triSmooth12( p.xz/16.0 ) );\r\n    h += triNoise13( p * 0.1 );\r\n    return p.y - h * GRASS_LAND_SCALE;\r\n}\r\nfloat bumpyLand( vec3 p )\r\n{\r\n    float h = triNoise13( p * 0.1 );\r\n    return p.y - h * BUMPY_LAND_SCALE;\r\n}\r\nfloat stoneLand( vec3 p )\r\n{\r\n    float h = triNoise13( p * 0.01 )*11.0; // 0.01 0.02 (for more complex stone)\r\n    return p.y - h * STONE_LAND_SCALE;\r\n}\r\nfloat mysteryLand( vec3 p )\r\n{\r\n    float h = 0.0;\r\n    h += triSmooth12( p.xz/16.0 )*0.66 + triSmooth12( p.xz/8.0 )*0.34;\r\n    h += tri12( p.xz/2.0 )*0.23; p.xz = rotM2i * p.xz;\r\n    h += tri12( p.xz*1.0 )*0.11; //p.xz = rotM2i * p.xz;\r\n    h += triNoiseSmooth13( p * 0.01 )*11.5;\r\n    return p.y - h * MYSTERY_LAND_SCALE;\r\n}\r\n\r\nvec2 terrainMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( stoneLand(p), MATERIAL_TEXTURE0 );\r\n    res = dUnion( res, vec2( bumpyLand(sTranslate(p, vec3(0.0, 4.0, 0.0))), MATERIAL_TEXTURE1 ) );\r\n    return res;\r\n}\r\n\r\nfloat terrainL( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainMap( p ).x;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, terrainMap(p) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col = vec3(0.0);\r\n\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );\r\n        applyClouds( col, iChannel2, ro, rd );\r\n\t}\r\n\r\n    else if( tm.y == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // bump normal\r\n        vec3 n = sceneNormal(p);\r\n        //n = getBumpNormal(iChannel0, p*0.1, n, 0.1-0.05*tm.x/tmax );//0.075\r\n        n = getBumpNormal(iChannel0, p*0.1, n, 0.075 );//0.075\r\n\r\n        // cook shading\r\n        vec3 diffuse, specular;\r\n        float fre = pow( saturate(1.0 + dot(n, rd)), 5.0 );\r\n        vec3 albedo = texCube( iChannel0, p, n ).xyz;\r\n        albedo = mix(albedo, vec3(0.2,0.3,0.0), noise(iChannel2, p.xz*0.25));\r\n        getCookShading( albedo, 0.01, 1.0, SUN_LIGHT, SUN_COLOR*3.0, n, rd, diffuse, specular );\r\n        col = mix(diffuse, fre*vec3(1.0), saturate(n.y)) + specular;\r\n\r\n        // curvature\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n    }\r\n    else if( tm.y == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        // bump normal\r\n        vec3 n = sceneNormal(p);\r\n        //n = getBumpNormal(iChannel1, p*0.1, n, 0.1-0.05*tm.x/tmax );//0.075\r\n        n = getBumpNormal(iChannel1, p*0.1, n, 0.075 );//0.075\r\n\r\n        // cook shading\r\n        vec3 diffuse, specular;\r\n        float fre = pow( saturate(1.0 + dot(n, rd)), 5.0 );\r\n        vec3 albedo = texCube( iChannel1, p, n ).xyz;\r\n        albedo = mix(albedo, vec3(0.85, 0.4, 0.2), noise(iChannel2, p.xz*0.05));\r\n        getCookShading( albedo, 0.01, 1.0, SUN_LIGHT, SUN_COLOR*3.0, n, rd, diffuse, specular );\r\n        col = mix(diffuse, fre*vec3(0.7), saturate(n.y)) + specular;\r\n\r\n        // curvature\r\n        float curv = cheapCurvature(p)*0.9 + 0.1;\r\n        col *= smoothstep(0.0, 0.8, curv);\r\n    }\r\n\r\n    // water surface...\r\n    if( rd.y < 0.0 )\r\n    {\r\n        float waterHeight = 5.0;\r\n\r\n        vec4 waterCol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro - vec3(0.0, waterHeight, 0.0), rd, vec4(0.0) );//cloudy = 0.0\r\n        if( 0.0 < waterCol.w && waterCol.w < tm.x )\r\n        {\r\n            // foam on water...\r\n            float t = (waterHeight-ro.y)/rd.y;\r\n            vec2 uv = (ro + rd * t).xz;\r\n            #if 0\r\n                float sur = texture( iChannel3, 0.007*time * 0.06*uv ).x;\r\n            #else\r\n                float sur = texture( iChannel3, 0.06*uv ).x;\r\n            #endif\r\n            sur = smoothstep( 0.5, 1.0, sur )*0.5 + 0.5*sur*sur*smoothstep(0.2, 1.0, texture( iChannel2, 1.0*uv ).x);\r\n            waterCol.rgb = mix( waterCol.rgb, vec3(2.5), 0.5*sur ); // foamCol = vec3(2.5)\r\n\r\n            // sun specular...\r\n            // float sunAmount = saturate( dot(SUN_LIGHT, reflect( rd, vec3(0.0,1.0,0.0) ) ) );\r\n            // waterCol.rgb += 0.2*vec3(1.0,0.95,0.9)*pow(sunAmount,16.0);\r\n            // waterCol.rgb += 0.5*vec3(1.0,0.95,0.9)*pow(sunAmount,96.0);\r\n\r\n            col = mix(col, waterCol.rgb, saturate(1.1+rd.y));\r\n        }\r\n    }\r\n\r\n    if( tm.y != MATERIAL_SKY )\r\n    {\r\n        // height-based fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.4 );//1.2\r\n        // constant fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.005, tm.x );//0.003\r\n    }\r\n\r\n    // post-processing\r\n    col = FilmicToneMapping( col );\r\n    col = col * 1.05 - 0.05;\r\n    //col = col * 1.1 - 0.1;\r\n    //col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n\treturn col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvec3 cpath( float t )\r\n{\r\n\tvec3 p = vec3( 0.0, 0.0, 80.0 + t );//95.0\r\n\tfloat a = smoothstep(5.0, 20.0, t);\r\n\tp.xz += a*150.0 * cos( vec2(5.0,6.0) + 1.0*0.01*t );\r\n\tp.xz -= a*150.0 * cos( vec2(5.0,6.0) );\r\n\tp.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\r\n\tp.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\r\n\treturn -p;\r\n}\r\n\r\nmat3 cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 2.0*time;//10.0\r\n#if 0\r\n    ro = vec3(0.0, 0.0, -80.0-curTime);\r\n    vec3 ta = vec3(0.0, 0.0, -90.0-curTime);\r\n#else\r\n    ro = cpath( curTime );\r\n\tvec3 ta = cpath( 10.0 + curTime );\r\n#endif\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 100.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xyz ) + 20.0;//30.0 20.0\r\n    ta.y = ro.y - 5.0;\r\n\r\n    float fl = 1.5;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n    return cam;\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    col = Vignetting( col, 0.5 );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n}"},5749:e=>{e.exports="#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above \"float noise(vec3)\"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_DUSTWIND_1\r\n#define USE_TERRAIN_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate \"distance per pixel\"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = 'images/raymarch/grayNoise256.png'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// textureMaps[0] = 'images/raymarch/grayNoise256.png'\r\n#define iChannel0   textureMaps[0]\r\n\r\n// on the derivatives based noise: http://iquilezles.org/www/articles/morenoise/morenoise.htm\r\n// on the soft shadow technique: http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\r\n// on the fog calculations: http://iquilezles.org/www/articles/fog/fog.htm\r\n// on the lighting: http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\r\n// on the raymarching: http://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_VIEW\r\n#define ENABLE_DUST_WIND\r\n\r\nconst float FAR = 300.0;//200.0\r\nconst vec3 SUN_LIGHT = normalize(vec3(-0.8, 0.4, -0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.9, 0.85);\r\nconst float SKY_HEIGHT = 300.0;\r\n\r\nfloat skyMap( in vec3 p )\r\n{\r\n    return SKY_HEIGHT - p.y;\r\n}\r\n\r\nvec2 sceneMap( in vec3 p )\r\n{\r\n    vec2 res = vec2( skyMap(p), MATERIAL_SKY );\r\n    res = dUnion( res, vec2( terrainMap( iChannel0, p ), MATERIAL_TERRAIN ) );\r\n    return res;\r\n}\r\n\r\nvoid rayMinMax( in vec3 ro, in vec3 rd, out float tmin, out float tmax )\r\n{\r\n    tmin = 1.0;\r\n    tmax = FAR;\r\n    float max_height = SKY_HEIGHT;\r\n    float t = (max_height - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        if( ro.y > max_height ) tmin = max( tmin, t );\r\n        else                    tmax = min( tmax, t );\r\n    }\r\n    else\r\n    {\r\n        if( ro.y > max_height ) tmin = tmax = 1.0;\r\n    }\r\n}\r\n\r\nvec3 render( in vec3 ro, in vec3 rd )\r\n{\r\n    float tmin, tmax;\r\n\trayMinMax( ro, rd, tmin, tmax );\r\n\r\n    vec2 tm = bisectMarching( ro, rd, tmin, tmax );\r\n    if( tm.x > tmax ) tm.y = MATERIAL_SKY;\r\n\r\n    vec3 col;\r\n    if( tm.y == MATERIAL_SKY )\r\n    {\r\n        gl_FragDepth = 0.99;\r\n\r\n        col = skyColor( SUN_LIGHT, rd, 0.0 );//1.0\r\n        applyClouds( col, iChannel0, ro, rd );\r\n\t}\r\n    else if( tm.y == MATERIAL_TERRAIN )\r\n    {\r\n        vec3 p = ro + rd * tm.x;\r\n        gl_FragDepth = getFragDepth( p );\r\n\r\n        col = terrainColor( iChannel0, SUN_COLOR, SUN_LIGHT, p, tm.x, tmax );\r\n        // height-based fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, ro, rd, tm.x*1.4 );\r\n        // constant fog density\r\n        applyFog( col, SUN_COLOR, SUN_LIGHT, rd, 0.003, tm.x );//0.005\r\n    }\r\n\r\n    // sun scatter\r\n    col += sunScatter( SUN_LIGHT, rd );\r\n\r\n#ifdef ENABLE_DUST_WIND\r\n    float dustAmount = 0.25;//0.25;\r\n    float dustHeight = 75.0*TERRAIN_SCALE;//50.0\r\n    float windTurbulency = 0.5;\r\n    applyDustWind( col, ro, rd, tm.x, dustAmount, dustHeight, windTurbulency );\r\n#endif\r\n\r\n    col = FilmicToneMapping( col );\r\n    //col = col * 1.05 - 0.05;\r\n    col = LinearToGamma( vec4(col, 1.0), 0.8 ).rgb;//0.8\r\n\r\n    return col;\r\n}\r\n\r\n#ifdef ENABLE_AUTO_VIEW\r\nvoid cameraAutoView( in sampler2D tex, out vec3 ro, out vec3 rd )\r\n{\r\n    float curTime = 5.5*time;\r\n    ro = vec3( 0.0, 0.0, -95.0-curTime );\r\n    vec3 ta = vec3( 0.0, 0.0, -110.0-curTime );\r\n    ta = mix( ro + vec3(0.0, 1.0, 0.0), ta, smoothstep(1.0, 25.0, curTime) );\r\n    ro.y = terrainL( tex, ro.xz ) + 50.0*TERRAIN_SCALE;//75.0\r\n    ta.y = ro.y - 40.0*TERRAIN_SCALE;//-75.0\r\n\r\n    float fl = 1.0;\r\n    vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n    mat3 cam = cameraMatrix( ro, ta ); // cam[0] = cu, cam[1] = cv, cam[2] = cw\r\n    rd = normalize( xy.x*cam[0] + xy.y*cam[1] + fl*cam[2] );\r\n}\r\n#endif\r\n\r\nvoid main()\r\n{\r\n#ifdef ENABLE_AUTO_VIEW\r\n    vec3 ro, rd;\r\n    cameraAutoView( iChannel0, ro, rd );\r\n#else\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n#endif\r\n\r\n    vec3 col = render( ro, rd );\r\n    gl_FragColor = vec4( col, 1.0 );\r\n    gl_FragColor.rgb = Vignetting( gl_FragColor.rgb, 0.5 );\r\n}"},6056:e=>{e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n\r\n#define texChannel0 textureMaps[0]\r\n\r\n// Choose...\r\n#define ENABLE_AUTO_CAMERA\r\n\r\n// Choose...\r\n//#define ENABLE_SURF_JAG1      // sharp\r\n#define ENABLE_SURF_JAG2        // default\r\n//#define ENABLE_SURF_JAG3      // flat\r\n//#define ENABLE_SURF_JAG4\r\n//#define ENABLE_SURF_JAG5\r\n//#define ENABLE_SURF_JAG6      // round\r\n\r\n// Choose...\r\n#define ENABLE_ROUND_TUNNEL     // default\r\n//#define ENABLE_SQUARE_TUNNEL\r\n//#define ENABLE_ROUNDED_SQUARE_TUNNEL\r\n//#define ENABLE_MINIMALISTS\r\n\r\n// Choose...\r\n#define ENABLE_GLOW           // default\r\n//#define ENABLE_SHINY\r\n\r\n// Choose...\r\n//#define ENABLE_EDGE_EFFECT\r\n\r\n// Choose the camera speed\r\n#define CAMERA_SPEED    5.0\r\n// 1.0 = slow\r\n// 5.0 = normal (default)\r\n// 10.0 = fast\r\n\r\n// Choose the ground height\r\n#define GROUND_HEIGHT   1.0\r\n// 0.0 = wide flat groud\r\n// 1.0 = narrow flat ground (default)\r\n// 2.0 = bumpy ground (no flat)\r\n// 3.0 = more bumpy ground\r\n\r\n\r\n// Grey scale.\r\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\n// Non-standard vec3-to-vec3 hash function.\r\nvec3 hash33(vec3 p)\r\n{\r\n    float n = sin(dot(p, vec3(7, 157, 113)));    \r\n    return fract(vec3(2097152, 262144, 32768)*n); \r\n}\r\n\r\n// 2x2 matrix rotation.\r\nmat2 rot2(float a)\r\n{\r\n\tfloat c = cos(a); float s = sin(a);\r\n\treturn mat2(c, s, -s, c);\r\n}\r\n\r\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\r\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\r\n    n /= (n.x + n.y + n.z );   \r\n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\r\n}\r\n\r\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\r\n// See Xyptonjtroz - Very cool. Anyway, it\'s not really being used to its full potential here.\r\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\r\n\r\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \r\n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \r\n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \r\n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \r\n// are bump mapped.\r\nfloat surfFunc(in vec3 p)\r\n{\r\n    // all have range: [0, 1]\r\n\r\n#if defined(ENABLE_SURF_JAG1)\r\n\treturn dot(tri(p*0.5 + tri(p*0.25 + 0.25).yzx), vec3(0.666));\r\n\r\n#elif defined(ENABLE_SURF_JAG2)\r\n    float n = dot(tri(p*0.5 + tri(p*0.25 + 0.25).yzx), vec3(0.444));\r\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.7071;\r\n    return dot(tri(p*0.75 + tri(p*0.375 + 0.125).yzx), vec3(0.222)) + n; // Range [0, 1]\r\n\r\n#elif defined(ENABLE_SURF_JAG3)\r\n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.333)) + \r\n           sin(p.x*1.5+sin(p.y*2.+sin(p.z*2.5)))*0.25+0.25;\r\n\r\n#elif defined(ENABLE_SURF_JAG4)\r\n    return dot(tri(p*0.6 + tri(p*0.3).yzx), vec3(0.333)) + \r\n           sin(p.x*1.75+sin(p.y*2.+sin(p.z*2.25)))*0.25+0.25; // Range [0, 1]\r\n\r\n#elif defined(ENABLE_SURF_JAG5)\r\n    p *= 0.5;\r\n    float n = dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.66));\r\n    p *= 1.5;\r\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\r\n    n += dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.34));\r\n    return n;\r\n\r\n#elif defined(ENABLE_SURF_JAG6)\r\n    p *= 2.;\r\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\r\n    p *= 1.5773;\r\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\r\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\r\n    p *= 1.5773;\r\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\r\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\r\n    return n*0.4+0.6;\r\n#endif\r\n}\r\n\r\n// Cheap...ish smooth minimum function.\r\nfloat smoothMinP( float a, float b, float smoothing )\r\n{\r\n    float h = clamp((b-a)*0.5/smoothing + 0.5, 0.0, 1.0 );\r\n    return mix(b, a, h) - smoothing*h*(1.0-h);\r\n}\r\n\r\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\r\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/12.); return vec2(s*12., 0.); }\r\n\r\n// Standard tunnel distance function with a bit of perturbation thrown into the mix. A winding \r\n// tunnel is just a tube with a smoothly shifting center as you traverse lengthwise. The walls \r\n// of the tunnels should be perturbed by some kind of 3D surface function... preferably a cheap \r\n// one with decent visual impact.\r\nfloat map(vec3 p)\r\n{\r\n#if defined(ENABLE_ROUND_TUNNEL)\r\n    // Round tunnel with floor using Euclidean distance: length(tun.xy)\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    float n = 1.- length(tun.xy) + (0.5-surfFunc(p)); //max(tun.x, tun.y)\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_SQUARE_TUNNEL)\r\n    // Square tunnel using Chebyshev distance: max(abs(tun.x), abs(tun.y))\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    //tun *= tun;\r\n    float n = 1.- max(tun.x, tun.y) + (0.5-surfFunc(p));\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_ROUNDED_SQUARE_TUNNEL)\r\n    // Rounded square tunnel using Minkowski distance: pow(pow(abs(tun.x), n), pow(abs(tun.y), n), 1/n)\r\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\r\n    tun = pow(tun, vec2(4.));\r\n    float n =1.-pow(tun.x + tun.y, 1.0/4.) + (0.5-surfFunc(p));\r\n    return min(n, p.y + GROUND_HEIGHT);\r\n\r\n#elif defined(ENABLE_MINIMALISTS)\r\n    // For the minimalists. :)\r\n    float n = 0.5-surfFunc(p + 0.25*sign(p.y));\r\n    n = min(GROUND_HEIGHT, 1. - sign(p.y)*n*0.75);\r\n    return min(-p.y + n, p.y + n);\r\n#endif\r\n}\r\n\r\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\r\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor )\r\n{\r\n    const float eps = 0.001;\r\n    float ref = getGrey(tex3D(tex,  p , nor));                 \r\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x+eps, p.y, p.z), nor))-ref,\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y+eps, p.z), nor))-ref,\r\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z+eps), nor))-ref )/eps;\r\n    grad -= nor*dot(nor, grad);\r\n    return normalize( nor + grad*bumpfactor );\r\n}\r\n\r\n// Surface normal.\r\nvec3 getNormal(in vec3 p)\r\n{\r\n\tconst float eps = 0.001;\r\n\treturn normalize(vec3(\r\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\r\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\r\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\r\n\t));\r\n}\r\n\r\n// Based on original by IQ.\r\nfloat calculateAO(vec3 p, vec3 n)\r\n{\r\n    const float AO_SAMPLES = 5.0;\r\n    float r = 0.0, w = 1.0, d;\r\n    for (float i = 1.0; i < AO_SAMPLES + 1.1; i++ )\r\n    {\r\n        d = i/AO_SAMPLES;\r\n        r += w*(d - map(p + n*d));\r\n        w *= 0.25; // jamie: 0.5 => 0.25\r\n    }\r\n    return 1.0 - saturate(r);\r\n}\r\n\r\n// Cool curve function, by Shadertoy user, Nimitz.\r\n// I think it\'s based on a discrete finite difference approximation to the continuous\r\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \r\n// which is pretty handy. I used it to do a bit of fake shadowing.\r\nfloat curve(in vec3 p, in float w)\r\n{\r\n    vec2 e = vec2(-1., 1.)*w;\r\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\r\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\r\n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n#ifdef ENABLE_AUTO_CAMERA\r\n    //===================\r\n    // original codes\r\n    //===================\r\n\r\n\t// screen coordinates\r\n\tvec2 uv = (fragCoord - resolution.xy*0.5)/resolution.y;\r\n\t\r\n\t// camera setup\r\n    vec3 lookAt = vec3(0.0, 0.0, time * CAMERA_SPEED); // "lookAt" position.\r\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\r\n \r\n    // light positioning. One is a little behind the camera, and the other is further down the tunnel.\r\n \tvec3 light_pos = camPos + vec3(0.0, 0.125, -0.125); // Put it a bit in front of the camera.\r\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 6.0);     // Put it a bit in front of the camera.\r\n\r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// sending the "camera", "lookAt," and two lights down the tunnel.\r\n    // The "path" function is synchronized with the distance function.\r\n    // change to "path2" to traverse the other tunnel.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tcamPos.xy += path(camPos.z);\r\n\tlight_pos.xy += path(light_pos.z);\r\n\tlight_pos2.xy += path(light_pos2.z);\r\n\r\n    // ray direction\r\n    float FOV = PI/3.; // FOV - Field of view.\r\n    vec3 forward = normalize(lookAt-camPos);\r\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \r\n    vec3 up = cross(forward, right);\r\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\r\n\r\n#else\r\n    //===================\r\n    // my codes... (to control view)\r\n    //===================\r\n\r\n    #ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\t\r\n\t// screen coordinates\r\n    vec2 uv = screenPos;\r\n\t\r\n\t// camera setup\r\n\tvec3 lookAt = vec3(0.0, 0.0, time * CAMERA_SPEED); // "lookAt" position.\r\n    vec3 camPos = -lookAt + rd; // Camera position, doubling as the ray origin.\r\n \r\n    // light positioning. One is a little behind the camera, and the other is further down the tunnel.\r\n \tvec3 light_pos = camPos - vec3(0.0, 0.125, -0.125);// Put it a bit in front of the camera.\r\n\tvec3 light_pos2 = camPos - vec3(0.0, 0.0, 6.0);// Put it a bit in front of the camera.\r\n\r\n\t// Using the Z-value to perturb the XY-plane.\r\n\t// sending the "camera", "lookAt," and two lights down the tunnel.\r\n    // The "path" function is synchronized with the distance function.\r\n    // change to "path2" to traverse the other tunnel.\r\n\tlookAt.xy += path(lookAt.z);\r\n\tcamPos.xy += path(camPos.z);\r\n\tlight_pos.xy += path(light_pos.z);\r\n\tlight_pos2.xy += path(light_pos2.z);\r\n\r\n#endif\r\n\r\n\trd.xy *= rot2( -path(lookAt.z).x / 32.0 );\r\n    // rd.xz *= rot2( path(lookAt.z).x / 32.0 );\r\n\r\n    // standard ray marching routine. I find that some system setups don\'t like anything other than\r\n    // a "break" statement (by itself) to exit. \r\n\tfloat t = 0.0, dt;\r\n\tfor(int i=0; i<128; i++)\r\n    {\r\n\t\tdt = map( camPos + rd * t );\r\n\t\tif( dt < 0.005 || t > 150.0 ){ break; }\r\n        t += dt * 1.1; // jamie: 0.75 => 1.1\r\n\t}\r\n\r\n\tvec3 sceneCol = vec3(0.0);\r\n\r\n\t// The ray has effectively hit the surface, so light it up.\r\n\tif( dt < 0.005 )\r\n    {\r\n\t    // The ray marching loop (above) exits when "dt" is less than a certain threshold, which in this \r\n        // case, is hardcoded to "0.005." However, the distance is still "dt" from the surface? By my logic, \r\n\t    // adding the extra "dt" after breaking would gain a little more accuracy and effectively reduce \r\n\t    // surface popping? Would that be correct? I tend to do this, but could be completely wrong, so if \r\n\t    // someone could set me straight, it\'d be appreciated. \r\n\t    t += dt;\r\n\r\n    \t// Surface position and surface normal.\r\n\t    vec3 sp = t*rd + camPos;\r\n\t    vec3 sn = getNormal(sp);\r\n\r\n        gl_FragDepth = getFragDepth( sp );\r\n\r\n        // Texture scale factor.\r\n        const float tSize0 = 1./2.; \r\n        const float tSize1 = 1./3.; \r\n\r\n    \t// Texture-based bump mapping. Comment this line out to spoil the illusion.\r\n\t    if( sp.y < -(GROUND_HEIGHT - 0.005) )\r\n            sn = doBumpMap( texChannel0, sp*tSize1, sn, 0.0125 );\r\n\t    else\r\n            sn = doBumpMap( texChannel0, sp*tSize0, sn, 0.025 );\r\n\r\n\t    // Ambient occlusion.\r\n\t    float ao = calculateAO(sp, sn);\r\n\r\n    \t// Light direction vectors.\r\n\t    vec3 ld = light_pos - sp;\r\n\t    vec3 ld2 = light_pos2 - sp;\r\n\r\n        // Distance from respective lights to the surface point.\r\n\t    float distlpsp = max(length(ld), 0.001);\r\n\t    float distlpsp2 = max(length(ld2), 0.001);\r\n\r\n    \t// Normalize the light direction vectors.\r\n\t    ld /= distlpsp;\r\n\t    ld2 /= distlpsp2;\r\n\r\n\t    // Light attenuation, based on the distances above.\r\n\t    float atten = min(1./(distlpsp) + 1./(distlpsp2), 1.0);\r\n\r\n    \t// Ambient light.\r\n\t    float ambience = 0.25;\r\n\r\n    \t// Diffuse lighting.\r\n\t    float diff = max( dot(sn, ld), 0.0);\r\n\t    float diff2 = max( dot(sn, ld2), 0.0);\r\n\r\n    \t// Specular lighting.\r\n\t    float spec = pow( max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\r\n\t    float spec2 = pow( max( dot( reflect(-ld2, sn), -rd ), 0.0 ), 8.0);\r\n\r\n    \t// Curvature.\r\n\t    float crv = saturate(curve(sp, 0.125)*0.5 + 0.5);\r\n\r\n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\r\n        float fre = pow( saturate(dot(sn, rd) + 1.0), 1.0);\r\n\r\n        // Obtaining the texel color. \r\n        vec3 texCol;\r\n        if( sp.y < -(GROUND_HEIGHT - 0.005) )\r\n        {\r\n            texCol = tex3D( texChannel0, sp*tSize1, sn );\r\n            texCol = texCol*0.5 + getGrey(texCol)*0.25 + 0.25;\r\n        }\r\n\t    else texCol = tex3D( texChannel0, sp*tSize0, sn ); // Sandstone.\r\n\r\n        // Jitter, if needed.\r\n        //vec3 aniso = (0.5-hash33(sp))*fre*0.35;\r\n\t    //texCol = clamp(texCol + aniso, 0., 1.);\r\n\r\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\r\n\t    float shading = crv * 0.5 + 0.5; \r\n\r\n    \t// Combing the above terms to produce the final color. It was based more on acheiving a\r\n        // certain aesthetic than science.\r\n\r\n#if defined(ENABLE_GLOW)\r\n        sceneCol = getGrey(texCol)*( (diff+diff2)*0.75 + ambience*0.25 ) + (spec + spec2)*texCol*1.5 + fre*crv*texCol.zyx*2.0;\r\n#elif defined(ENABLE_SHINY)\r\n        sceneCol = texCol*((diff+diff2)*vec3(1.0, 0.95, 0.9) + ambience + fre*fre*texCol) + (spec+spec2);\r\n#endif\r\n        // if( sp.y > -0.995 ) sceneCol += (spec + spec2)*texCol*0.5;\r\n\r\n        // Shading\r\n        sceneCol *= atten * shading * ao;\r\n\r\n#ifdef ENABLE_EDGE_EFFECT\r\n        // sceneCol *= saturate(1.0-abs(curve(sp, 0.01))); // add dense edges\r\n        sceneCol *= pow( saturate(1.0-(curve(sp, 0.0125))), 0.5); // add thick edges\r\n#endif\r\n\t}\r\n    else gl_FragDepth = 0.99;\r\n\r\n\t// fragColor = vec4( saturate(sceneCol), 1.0 );\r\n    fragColor = LinearToGamma( vec4( saturate(sceneCol), 1.0), 0.7 ); // jamie\r\n}\r\n\r\nvoid main()\r\n{\r\n    mainImage( gl_FragColor, gl_FragCoord.xy );\r\n}'},2992:e=>{e.exports='#ifndef RAYMARCH_INCLUDE\r\n#define RAYMARCH_INCLUDE\r\n\r\n#define gl_FragCoord     (gl_FragCoord / devicePixelRatio)\r\n\r\n#define PI 3.14159265359\r\n#define PI2 6.28318530718\r\n#define PI_HALF 1.5707963267949\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define RECIPROCAL_PI2 0.15915494\r\n#define LOG2 1.442695\r\n#define EPSILON 1e-6\r\n\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\r\n\r\nuniform float devicePixelRatio;\r\nuniform float time;\r\nuniform vec2 resolution;\r\nuniform float cameraNear;\r\nuniform float cameraFar;\r\n// uniform mat4 viewMatrix;\r\n\r\n// uniform vec3 cameraPosition;\r\nuniform mat4 cameraWorldMatrix;\r\nuniform mat4 cameraProjectionMatrixInverse;\r\nuniform sampler2D textureMaps[4];\r\n\r\nfloat getFragDepth( vec3 fragPosW )\r\n// gl_FragDepthEXT = getFragDepth( fragPos );\r\n// where gl_FragDepthEXT = [0.0, 1.0]\r\n// if gl_FragDepthEXT = 1.0  ==> fragment will be killed\r\n// if gl_FragDepthEXT = 0.99 ==> fragment will be preserved as background\r\n{\r\n    vec4 fragPosV = viewMatrix * vec4(fragPosW, 1.0);\r\n\r\n    // // viewZ to perspectiveDepth\r\n    // float fragDepth = cameraFar * (cameraNear + fragPosV.z) / ((cameraFar - cameraNear) * fragPosV.z);\r\n\r\n    // viewZ To orthographicDepth\r\n    float fragDepth = ( fragPosV.z + cameraNear ) / ( cameraNear - cameraFar );\r\n\r\n    return fragDepth; // orthographicDepth(O), perspectiveDepth(X)\r\n}\r\n\r\n#endif // RAYMARCH_INCLUDE\r\n#ifndef RAYMARCH_UTILS\r\n#define RAYMARCH_UTILS\r\n\r\n//==============================================================================\r\n// Basic functions\r\n//==============================================================================\r\n\r\n#define TONE_MAPPING_EXPOSURE 0.4\r\n\r\nvec3 FilmicToneMapping( vec3 color ) {\r\n    color *= TONE_MAPPING_EXPOSURE;\r\n    return saturate( (color*(2.51*color + 0.03)) / (color*(2.43*color + 0.59) + 0.14) );\r\n}\r\n\r\nfloat pow2( const in float x ) { return x*x; }\r\nfloat pow3( const in float x ) { return x*x*x; }\r\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\r\nfloat pow5( const in float x ) { float x2 = x*x; return x2*x2*x; }\r\n\r\nfloat mapLinear( float x, float x0, float x1, float y0, float y1 ) {\r\n    return y0 + (x - x0) * (y1 - y0) / (x1 - x0);\r\n}\r\n\r\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\r\n\r\nvec2 smoothstepd( float a, float b, float x )\r\n// return smoothstep and its derivative\r\n{\r\n\tif( x < a ) return vec2( 0.0, 0.0 );\r\n\tif( x > b ) return vec2( 1.0, 0.0 );\r\n    float ir = 1.0 / (b - a);\r\n    x = (x - a)*ir;\r\n    return vec2( x*x*(3.0 - 2.0*x), 6.0*x*(1.0 - x)*ir );\r\n}\r\n\r\nfloat rand( in float x ) {\r\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))*(43758.5453));\r\n}\r\n\r\nfloat rand( in vec2 uv ) {\r\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\r\n\tfloat dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\r\n\treturn fract(sin(sn) * c);\r\n}\r\n\r\nvec3 Dithering( in vec3 color ) {\r\n    float grid_position = rand( gl_FragCoord.xy );\r\n    vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n    dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n    return color + dither_shift_RGB;\r\n}\r\n\r\nvec3 Vignetting( in vec3 color, in float strength ) {\r\n    // strength(0.0~3.0) = no-effect(0.0), weakly(0.5), normal(1.0), max-effect(5.0)\r\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 offset = (uv - 0.5) * sqrt(2.0);\r\n\tfloat dist = dot(offset, offset);\r\n\tfloat shade = mix( 1.0, 1.0 - strength, dist );\t\r\n\treturn color * shade;\r\n}\r\n\r\n// uv = [0,1] x [0,1]\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n//\r\n// vec2 xy = (-1.0 + 2.0*uv) * vec2(resolution.x/resolution.y, 1.0);\r\n// vec2 uv = 0.5 + 0.5*xy*vec2(resolution.y/resolution.x, 1.0);\r\n//\r\n// vec2 uv = gl_FragCoord.xy/resolution.xy;\r\n// vec2 xy = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;\r\n\r\n//==============================================================================\r\n// Filtering\r\n//==============================================================================\r\n\r\nfloat checkerGradBox( in vec2 p )\r\n// box-filtered checker-board (2D)\r\n{\r\n    // filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n    // analytical integral (box filter)\r\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\r\n\r\n    // xor pattern\r\n    return 0.5 - 0.5*i.x*i.y;\r\n}\r\n\r\nfloat gridGradBox( in vec2 p )\r\n// box-filtered grid-board (2D)\r\n{\r\n    const float N = 10.0; // grid ratio\r\n\r\n\t// filter kernel\r\n    vec2 w = fwidth(p) + 0.001;\r\n\r\n\t// analytic (box) filtering\r\n    vec2 a = p + 0.5*w;                        \r\n    vec2 b = p - 0.5*w;           \r\n    vec2 i = (floor(a)+min(fract(a)*N,1.0) - floor(b)-min(fract(b)*N,1.0))/(N*w);\r\n\r\n    //pattern\r\n    return (1.0-i.x)*(1.0-i.y);\r\n}\r\n\r\nvec3 checkerColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = checkerGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\nvec3 gridColor( in vec3 p, in float ntile, in float intensity )\r\n// ntile = number of tile per length\r\n{\r\n    float f = gridGradBox( ntile * p.xz );\r\n    return (1.0 - intensity) + f * vec3(intensity);\r\n}\r\n\r\n//==============================================================================\r\n// Color\r\n//==============================================================================\r\n\r\n// Color mixing...\r\n// col = mix(col1, col2, smoothstep(t1, t2, t))\r\n// t < t1 ==> col = col1\r\n// t > t2 ==> col = col2\r\n// t1 < t < t2 ==> col = (1-w)*col1 + w*col2 (w = smoothstep(t1, t2, t))\r\n\r\nfloat euclideanModulo( float n, float m )\r\n{\r\n    return mod((mod(n,m) + m), m);\r\n}\r\n\r\nfloat hue2rgb( float p, float q, float t )\r\n{\r\n    if ( t < 0.0 ) t += 1.0;\r\n    if ( t > 1.0 ) t -= 1.0;\r\n    if ( t < 1.0 / 6.0 ) return p + ( q - p ) * 6.0 * t;\r\n    if ( t < 1.0 / 2.0 ) return q;\r\n    if ( t < 2.0 / 3.0 ) return p + ( q - p ) * 6.0 * ( 2.0 / 3.0 - t );\r\n    return p;\r\n}\r\n\r\nvec3 hsl2rgb( vec3 hsl )\r\n// hsl = vec3(h, s, l)\r\n// h,s,l ranges are in 0.0 - 1.0\r\n{\r\n    vec3 rgb;\r\n    float h = euclideanModulo( hsl.x, 1.0 );\r\n    float s = clamp( hsl.y, 0.0, 1.0 );\r\n    float l = clamp( hsl.z, 0.0, 1.0 );\r\n    if ( s == 0.0 )\r\n        rgb = vec3(l);\r\n    else {\r\n        float p = (l <= 0.5) ? l * ( 1.0 + s ) : l + s - ( l * s );\r\n        float q = ( 2.0 * l ) - p;\r\n        rgb.r = hue2rgb( q, p, h + 1.0 / 3.0 );\r\n        rgb.g = hue2rgb( q, p, h );\r\n        rgb.b = hue2rgb( q, p, h - 1.0 / 3.0 );\r\n    }\r\n    return rgb;\r\n}\r\n\r\n//==============================================================================\r\n// Texture\r\n//==============================================================================\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = texture( tex, p.yz );\r\n\tvec4 ty = texture( tex, p.zx );\r\n\tvec4 tz = texture( tex, p.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n, in float k, in vec3 dpdx, in vec3 dpdy )\r\n// p = hitted point(x, y, z)\r\n// n = unit normal vector of its tangent plane\r\n// k = 4.0\r\n// dpdx = dp/dx = partial deriv of p w.r.t. window x\r\n// dpdy = dp/dy = partial deriv of p w.r.t. window y\r\n{\r\n    vec3 m = pow( abs(n), vec3(k) );\r\n\tvec4 tx = textureGrad( tex, p.yz, dpdx.yz, dpdy.yz );\r\n\tvec4 ty = textureGrad( tex, p.zx, dpdx.zx, dpdy.zx );\r\n\tvec4 tz = textureGrad( tex, p.xy, dpdx.xy, dpdy.xy );\r\n\treturn (tx*m.x + ty*m.y + tz*m.z) / (m.x + m.y + m.z);\r\n}\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n )\r\n{\r\n    return texCube( tex, p, n, 4.0 );\r\n}\r\n\r\n// http://www.iquilezles.org/www/articles/texture/texture.htm\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn texture( tex, uv );\r\n}\r\nvec4 texSmooth( in sampler2D tex, in vec2 res, in vec2 uv, in vec2 duvdx, in vec2 duvdy )\r\n// get smooth texture interpolation\r\n// res = texture resolution\r\n// uv = texture coordinates\r\n// duvdx = d(uv)/dx, duvdy = d(uv)/dy\r\n{\r\n\tuv = uv*res + 0.5;\r\n\tvec2 iuv = floor( uv );\r\n\tvec2 fuv = fract( uv );\r\n\tuv = iuv + fuv*fuv*(3.0-2.0*fuv);\r\n\tuv = (uv - 0.5)/res;\r\n\treturn textureGrad( tex, uv, duvdx, duvdy );\r\n}\r\n\r\nfloat getGrey( vec3 p ){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\r\n\r\nvec3 getBumpNormal( in sampler2D tex, in vec3 p, in vec3 n, in float bumpFactor )\r\n// bumpFactor = 0.0075, 0.075\r\n{\r\n    const float eps = 0.001;\r\n    float baseVal = getGrey(texCube(tex, p, n).rgb);\r\n    vec3 grad = vec3( getGrey(texCube(tex, vec3(p.x+eps, p.y, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y+eps, p.z), n).rgb) - baseVal,\r\n                      getGrey(texCube(tex, vec3(p.x, p.y, p.z+eps), n).rgb) - baseVal )/eps;\r\n    grad -= n * dot( n, grad );\r\n    //return normalize( n - grad*bumpFactor );\r\n    return normalize( n + grad*bumpFactor );\r\n}\r\n\r\n#endif // RAYMARCH_UTILS\r\n#ifndef RAYMARCH_NOISES\r\n#define RAYMARCH_NOISES\r\n\r\n#if 1\r\n    // for integer stepped ranges, (ie value-noise/perlin noise functions)\r\n    #define HASHSCALE1 0.1031\r\n    #define HASHSCALE3 vec3(0.1031, 0.1030, 0.0973)\r\n    #define HASHSCALE4 vec4(0.1031, 0.1030, 0.0973, 0.1099)\r\n#else\r\n    // for smaller input rangers (like audio tick or 0-1 UVs use these...)\r\n    #define HASHSCALE1 443.8975\r\n    #define HASHSCALE3 vec3(443.897, 441.423, 437.195)\r\n    #define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\r\n#endif\r\nfloat hash11(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash12(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nfloat hash13(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE1);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.x+p3.y)*p3.z);\r\n}\r\nvec2 hash21(float p) {\r\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n\tp3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash22(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec2 hash23(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yzx+19.19);\r\n    return fract((p3.xx+p3.yz)*p3.zy);\r\n}\r\nvec3 hash31(float p) {\r\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\r\n   p3 += dot(p3, p3.yzx+19.19);\r\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \r\n}\r\nvec3 hash32(vec2 p) {\r\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\r\n}\r\nvec3 hash33(vec3 p3) {\r\n\tp3 = fract(p3 * HASHSCALE3);\r\n    p3 += dot(p3, p3.yxz+19.19);\r\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\r\n}\r\nvec4 hash41(float p) {\r\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash42(vec2 p) {\r\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash43(vec3 p) {\r\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\nvec4 hash44(vec4 p4) {\r\n\tp4 = fract(p4 * HASHSCALE4);\r\n    p4 += dot(p4, p4.wzxy+19.19);\r\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise11(float x) {\r\n    float p = floor(x);\r\n    float f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix( hash11(p + 0.0), hash11(p + 1.0), f );\r\n}\r\nfloat noise12(vec2 x) {\r\n    vec2 i = floor(x);\r\n    vec2 f = fract(x);\r\n\tfloat a = hash12(i);\r\n    float b = hash12(i + vec2(1.0, 0.0));\r\n    float c = hash12(i + vec2(0.0, 1.0));\r\n    float d = hash12(i + vec2(1.0, 1.0));\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\r\n}\r\nfloat noise12(sampler2D tex, vec2 x) {\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = p.xy + f.xy;\r\n\treturn textureLod(tex, (uv + 0.5)/256.0, 0.0).x;\r\n}\r\nfloat noise13(vec3 x) {\r\n    const vec3 step = vec3(110.0, 241.0, 171.0);\r\n    vec3 i = floor(x);\r\n    vec3 f = fract(x); \r\n    float n = dot(i, step);\r\n    vec3 u = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 0.0))), hash11(n + dot(step, vec3(1.0, 0.0, 0.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 0.0))), hash11(n + dot(step, vec3(1.0, 1.0, 0.0))), u.x), u.y),\r\n               mix(mix( hash11(n + dot(step, vec3(0.0, 0.0, 1.0))), hash11(n + dot(step, vec3(1.0, 0.0, 1.0))), u.x),\r\n                   mix( hash11(n + dot(step, vec3(0.0, 1.0, 1.0))), hash11(n + dot(step, vec3(1.0, 1.0, 1.0))), u.x), u.y), u.z);\r\n}\r\nfloat noise13(sampler2D tex, vec3 x) {\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n\tvec2 uv = (p.xy + vec2(37.0, 17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod(tex, (uv + 0.5)/256.0, 0.0).yx;\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\nvec2 noise22(vec2 x) {\r\n    return vec2( noise12(x), noise12(x+17.0) );//OK\r\n    //return vec2( noise12(x), noise12(x-43.0) );//OK\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat Hash11( float p ) {\r\n    return fract( p*17.0*fract( p*0.3183099 ) );\r\n}\r\nfloat Hash12(vec2 p) {\r\n#if 1\r\n    float h = dot( p, vec2(127.1,311.7) );\r\n    return fract( sin(h) * 43758.5453123 );\r\n#else\r\n    p = 50.0*fract( p*0.3183099 );\r\n    return fract( p.x*p.y*(p.x+p.y) );\r\n#endif\r\n}\r\nfloat Hash13(vec3 p) {\r\n    // replace this by something better\r\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\r\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\r\n}\r\nvec2 Hash21( float p ) {\r\n    return fract( sin(vec2(p, p+1.0)) * vec2(43758.5453123, 22578.1459123) );\r\n}\r\nvec2 Hash22(vec2 p) {\r\n    // replace this by something better\r\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\r\n    p = p*k + k.yx;\r\n    return fract( 16.0 * k*fract( p.x*p.y*(p.x + p.y)) );\r\n}\r\nvec3 Hash33(vec3 p) {\r\n    // replace this by something better\r\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\r\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\r\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\r\n    return fract(sin(p)*43758.5453123);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat noise(vec2 x)\r\n// value noise 2D\r\n{\r\n#if 0\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( Hash12( p + vec2(0.0,0.0) ), \r\n                     Hash12( p + vec2(1.0,0.0) ), u.x),\r\n                mix( Hash12( p + vec2(0.0,1.0) ), \r\n                     Hash12( p + vec2(1.0,1.0) ), u.x), u.y);\r\n#else\r\n    vec2 p = floor(x);\r\n    vec2 w = fract(x);\r\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    float a = Hash12(p+vec2(0.0,0.0));\r\n    float b = Hash12(p+vec2(1.0,0.0));\r\n    float c = Hash12(p+vec2(0.0,1.0));\r\n    float d = Hash12(p+vec2(1.0,1.0));\r\n    return a + (b-a)*u.x + (c-a)*u.y + (a-b-c+d)*u.x*u.y;\r\n#endif\r\n}\r\nfloat noise(sampler2D tex, vec2 x)\r\n// value noise 2D\r\n{\r\n    // tex = 256 x 256\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 0 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0));\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.x );\r\n}\r\nfloat noise(vec3 x)\r\n// value noise 3D\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n    f = f*f*(3.0-2.0*f);\r\n    return mix(mix(mix( Hash13( p + vec3(0,0,0) ), \r\n                        Hash13( p + vec3(1,0,0) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,0) ), \r\n                        Hash13( p + vec3(1,1,0) ), f.x), f.y),\r\n               mix(mix( Hash13( p + vec3(0,0,1) ), \r\n                        Hash13( p + vec3(1,0,1) ), f.x),\r\n                   mix( Hash13( p + vec3(0,1,1) ), \r\n                        Hash13( p + vec3(1,1,1) ), f.x), f.y), f.z);\r\n}\r\nfloat noise(sampler2D tex, vec3 x)\r\n// value noise 3D : much faster than the above "float noise(vec3)"\r\n{\r\n\t// tex = 256 x 256\r\n    vec3 p = floor(x);\r\n    vec3 f = fract(x);\r\n\tf = f*f*(3.0-2.0*f);\r\n#if 1 // low qaulity\r\n\tvec2 uv = (p.xy + vec2(37.0,17.0)*p.z) + f.xy;\r\n\tvec2 rg = textureLod( tex, (uv + 0.5)/256.0, 0.0 ).yx;\r\n#else // high quality\r\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\r\n\tvec2 rg1 = textureLod( tex, (uv + vec2(0.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg2 = textureLod( tex, (uv + vec2(1.5,0.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg3 = textureLod( tex, (uv + vec2(0.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg4 = textureLod( tex, (uv + vec2(1.5,1.5))/256.0, 0.0 ).yx;\r\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\r\n#endif\r\n\treturn mix( rg.x, rg.y, f.z );\r\n}\r\n\r\nfloat gnoise(vec2 p)\r\n// gradient noise 2D\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n\tvec2 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( dot( Hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \r\n                     dot( Hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\r\n                mix( dot( Hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \r\n                     dot( Hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\r\n}\r\nfloat gnoise(vec3 p)\r\n// gradient noise 3D\r\n{\r\n    vec3 i = floor( p );\r\n    vec3 f = fract( p );\r\n\tvec3 u = f*f*(3.0-2.0*f);\r\n    return mix( mix( mix( dot( Hash33( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\r\n                mix( mix( dot( Hash33( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\r\n                     mix( dot( Hash33( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \r\n                          dot( Hash33( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\r\n}\r\n\r\nvec3 noised(vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 p = floor(x);\r\n    vec2 f = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    float a = Hash12( p + vec2(0.0,0.0) );\r\n    float b = Hash12( p + vec2(1.0,0.0) );\r\n    float c = Hash12( p + vec2(0.0,1.0) );\r\n    float d = Hash12( p + vec2(1.0,1.0) );\r\n    float k0 = a;\r\n    float k1 = b - a;\r\n    float k2 = c - a;\r\n    float k4 = a - b - c + d;\r\n    return vec3( k0 + k1*u.x + k2*u.y + k4*u.x*u.y,     // value\r\n                 du * vec2(k1 + k4*u.y, k2 + k4*u.x) ); // derivative\r\n}\r\nvec3 noised(sampler2D tex, vec2 x)\r\n// value noise 2D, derivatives\r\n// return value noise (in x) and its derivatives (in yz)\r\n{\r\n    // tex = 256 X 256\r\n    vec2 f = fract(x);\r\n    vec2 p = floor(x);\r\n#if 0\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n\tfloat a = textureLod( tex, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat b = textureLod( tex, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n\tfloat c = textureLod( tex, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n\tfloat d = textureLod( tex, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y, du*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n}\r\nvec4 noised(vec3 x)\r\n// value noise 3D (0.0 ~ 1.0), derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n#if 1\r\n    // quintic interpolation\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n#endif\r\n\r\n#if 0\r\n    float a = Hash13(p+vec3(0.0,0.0,0.0));\r\n    float b = Hash13(p+vec3(1.0,0.0,0.0));\r\n    float c = Hash13(p+vec3(0.0,1.0,0.0));\r\n    float d = Hash13(p+vec3(1.0,1.0,0.0));\r\n    float e = Hash13(p+vec3(0.0,0.0,1.0));\r\n\tfloat f = Hash13(p+vec3(1.0,0.0,1.0));\r\n    float g = Hash13(p+vec3(0.0,1.0,1.0));\r\n    float h = Hash13(p+vec3(1.0,1.0,1.0));\r\n#else\r\n    float n = p.x + 317.0*p.y + 157.0*p.z;\r\n    float a = Hash11(n + 0.0);\r\n    float b = Hash11(n + 1.0);\r\n    float c = Hash11(n + 317.0);\r\n    float d = Hash11(n + 318.0);\r\n    float e = Hash11(n + 157.0);\r\n\tfloat f = Hash11(n + 158.0);\r\n    float g = Hash11(n + 474.0);\r\n    float h = Hash11(n + 475.0);\r\n#endif\r\n\r\n    float k0 =   a;\r\n    float k1 =   b - a;\r\n    float k2 =   c - a;\r\n    float k3 =   e - a;\r\n    float k4 =   a - b - c + d;\r\n    float k5 =   a - c - e + g;\r\n    float k6 =   a - b - e + f;\r\n    float k7 = - a + b + c - d + e - f - g + h;\r\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \r\n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\r\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\r\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\r\n}\r\n\r\nvec3 gnoised(vec2 p)\r\n// gradient noise 2D, derivatives\r\n// return gradient noise (in x) and its derivatives (in yz)\r\n{\r\n    vec2 i = floor( p );\r\n    vec2 f = fract( p );\r\n#if 1\r\n    // quintic interpolation\r\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n#else\r\n    // cubic interpolation\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n#endif\r\n    vec2 ga = Hash22( i + vec2(0.0,0.0) );\r\n    vec2 gb = Hash22( i + vec2(1.0,0.0) );\r\n    vec2 gc = Hash22( i + vec2(0.0,1.0) );\r\n    vec2 gd = Hash22( i + vec2(1.0,1.0) );\r\n    float va = dot( ga, f - vec2(0.0,0.0) );\r\n    float vb = dot( gb, f - vec2(1.0,0.0) );\r\n    float vc = dot( gc, f - vec2(0.0,1.0) );\r\n    float vd = dot( gd, f - vec2(1.0,1.0) );\r\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\r\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\r\n}\r\nvec4 gnoised(vec3 x)\r\n// gradient noise 3D, derivatives\r\n// return value noise (in x) and its derivatives (in yzw)\r\n{\r\n    // grid\r\n    vec3 p = floor(x);\r\n    vec3 w = fract(x);\r\n    #if 1\r\n    // quintic interpolant\r\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\r\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\r\n    #else\r\n    // cubic interpolant\r\n    vec3 u = w*w*(3.0-2.0*w);\r\n    vec3 du = 6.0*w*(1.0-w);\r\n    #endif\r\n    // gradients\r\n    vec3 ga = Hash33( p+vec3(0.0,0.0,0.0) );\r\n    vec3 gb = Hash33( p+vec3(1.0,0.0,0.0) );\r\n    vec3 gc = Hash33( p+vec3(0.0,1.0,0.0) );\r\n    vec3 gd = Hash33( p+vec3(1.0,1.0,0.0) );\r\n    vec3 ge = Hash33( p+vec3(0.0,0.0,1.0) );\r\n\tvec3 gf = Hash33( p+vec3(1.0,0.0,1.0) );\r\n    vec3 gg = Hash33( p+vec3(0.0,1.0,1.0) );\r\n    vec3 gh = Hash33( p+vec3(1.0,1.0,1.0) );\r\n    // projections\r\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\r\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\r\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\r\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\r\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\r\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\r\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\r\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\r\n    // interpolations\r\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\r\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\r\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\r\n}\r\n\r\n//==============================================================================\r\n\r\n#define NUM_NOISE_OCTAVES   5\r\n\r\nfloat fbm11(float x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tfloat shift = float(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise11(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm12(vec2 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec2 shift = vec2(100.0);\r\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise12(x);\r\n\t\tx = rot * x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\nfloat fbm13(vec3 x) {\r\n\tfloat v = 0.0;\r\n\tfloat a = 0.5;\r\n\tvec3 shift = vec3(100.0);\r\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; i++) {\r\n\t\tv += a * noise13(x);\r\n\t\tx = x * 2.0 + shift;\r\n\t\ta *= 0.5;\r\n\t}\r\n\treturn v;\r\n}\r\n\r\nconst mat2 rotM2  = mat2(0.80,0.60,-0.60,0.80);\r\nconst mat2 rotM2i = mat2(0.80,-0.60,0.60,0.80);//36.87(deg)\r\nconst mat3 rotM3  = mat3(0.00,0.80,0.60,-0.80,0.36,-0.48,-0.60,-0.48,0.64);\r\nconst mat3 rotM3i = mat3(0.00,-0.80,-0.60,0.80,0.36,-0.48,0.60,-0.48,0.64);\r\n\r\nfloat fbm(sampler2D tex, vec2 p) {\r\n    // tex = 256 x 256 (grayNoise256.png)\r\n    float f = 0.0;\r\n    f += 0.5000 * texture( tex, p/256.0 ).x; p = rotM2*p*2.02;\r\n    f += 0.2500 * texture( tex, p/256.0 ).x; p = rotM2*p*2.03;\r\n    f += 0.1250 * texture( tex, p/256.0 ).x; p = rotM2*p*2.01;\r\n    f += 0.0625 * texture( tex, p/256.0 ).x;\r\n    return f/0.9375;\r\n}\r\n\r\nfloat fbm_4(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++)\r\n    {\r\n        //float n = noise12(tex, x); // low quality\r\n        float n = noise(tex, x);     // high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_9(sampler2D tex, vec2 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        //float n = noise12(tex, x); //low quality\r\n        float n = noise(tex, x);     //high quality\r\n        a += b * n;\r\n        b *= 0.5;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nfloat fbm_4(vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat fbm_4(sampler2D tex, vec3 x) {\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<4; i++ )\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n    }\r\n\treturn a;\r\n}\r\n\r\nvec3 fbmd_5(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\nvec3 fbmd_9(vec2 x) {\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec2  d = vec2(0.0);\r\n    mat2  m = mat2(1.0,0.0, 0.0,1.0);\r\n    for(int i=0; i<9; i++)\r\n    {\r\n        vec3 n = noised(x);\r\n        a += b * n.x;          // accumulate values\t\t\r\n        d += b * m * n.yz;       // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM2 * x;\r\n        m = f * rotM2i * m;\r\n    }\r\n\treturn vec3( a, d );\r\n}\r\n\r\nvec4 fbmd_5(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<5; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\nvec4 fbmd_7(vec3 x) {\r\n    // return value (in x) and its derivatives (in yzw)\r\n    float f = 1.92;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    vec3  d = vec3(0.0);\r\n    mat3  m = mat3(1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0);\r\n    for(int i=0; i<7; i++)\r\n    {\r\n        vec4 n = noised(x);\r\n        a += b * n.x;       // accumulate values\t\t\r\n        d += b * m * n.yzw; // accumulate derivatives\r\n        b *= 0.5;\r\n        x = f * rotM3 * x;\r\n        m = f * rotM3i * m;\r\n    }\r\n\treturn vec4( a, d );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat triSmooth11(float x){ return 0.25+0.25*cos(PI2*x); }\r\nfloat triSmooth12(vec2 p) { return triSmooth11(p.x+triSmooth11(p.y)) + triSmooth11(p.y+triSmooth11(p.x)); }\r\nvec3  triSmooth33(vec3 p) { return vec3(triSmooth11(p.x+triSmooth11(p.y)), triSmooth11(p.y+triSmooth11(p.z)), triSmooth11(p.z+triSmooth11(p.x))); }\r\nfloat triNoiseSmooth13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = triSmooth33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (triSmooth11(p.z + triSmooth11(p.x + triSmooth11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\nfloat tri11(float x) { return abs(fract(x)-0.5); }\r\nfloat tri12(vec2 p)  { return tri11(p.x+tri11(p.y)) + tri11(p.y+tri11(p.x)); }\r\nvec3  tri33(vec3 p)  { return vec3(tri11(p.x+tri11(p.y)), tri11(p.y+tri11(p.z)), tri11(p.z+tri11(p.x))); }\r\nfloat triNoise13(vec3 p) {\r\n    float z = 1.4;\r\n\tfloat rz = 0.0;\r\n    vec3 bp = p;\r\n\tfor(int i = 0; i <= 3; i++)\r\n\t{\r\n        vec3 dg = tri33( bp );\r\n        p += dg;\r\n        bp *= 1.8;//2.0\r\n\t\tz *= 1.5;\r\n\t\tp *= 1.2;\r\n        rz += (tri11(p.z + tri11(p.x + tri11(p.y))))/z;\r\n        bp += 0.14;\r\n\t}\r\n\treturn rz;\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sinusoidBumps(in vec3 p, in float time) {\r\n    // NOTE*: sinusoidBumps() + combined with 3D rotations ==> better than cheap noise\r\n    return sin(p.x*16.+time*0.57)*cos(p.y*16.+time*2.17)*sin(p.z*16.-time*1.31) + 0.5*sin(p.x*32.+time*0.07)*cos(p.y*32.+time*2.11)*sin(p.z*32.-time*1.23);\r\n}\r\n\r\n#endif // RAYMARCH_NOISES\r\n#ifndef RAYMARCH_DISTANCES\r\n#define RAYMARCH_DISTANCES\r\n\r\n//==============================================================================\r\n// distance field functions (primitives)\r\n//==============================================================================\r\n\r\nfloat fPlane(vec3 p) { return p.y; }\r\nfloat fSphere(vec3 p, float s) { return length(p)-s; }\r\nfloat fBox(vec3 p, vec3 b) {\r\n    vec3 d = abs(p) - b;\r\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\r\n}\r\nfloat fEllipsoid(vec3 p, vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\r\nfloat uRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b,0.0))-r; }\r\nfloat fRoundBox(vec3 p, vec3 b, float r) { return length(max(abs(p)-b+vec3(r),0.0))-r; }\r\nfloat fTorus(vec3 p, vec2 t) { return length( vec2(length(p.xz)-t.x,p.y) )-t.y; }\r\nfloat fHexPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n#if 0\r\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\r\n#else\r\n    float d1 = q.z-h.y;\r\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n#endif\r\n}\r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\r\n\tvec3 pa = p-a, ba = b-a;\r\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n\treturn length( pa - ba*h ) - r;\r\n}\r\nfloat fEquilateralTriangle(vec2 p) {\r\n    const float k = 1.73205;//sqrt(3.0);\r\n    p.x = abs(p.x) - 1.0;\r\n    p.y = p.y + 1.0/k;\r\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\r\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\r\n    return -length(p)*sign(p.y);\r\n}\r\nfloat fTriPrism(vec3 p, vec2 h) {\r\n    vec3 q = abs(p);\r\n    float d1 = q.z-h.y;\r\n#if 1\r\n    // distance bound\r\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\r\n#else\r\n    // correct distance\r\n    h.x *= 0.866025;\r\n    float d2 = fEquilateralTriangle(p.xy/h.x)*h.x;\r\n#endif\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fCylinder(vec3 p, vec2 h) {\r\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\r\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\r\n}\r\nfloat fCone(vec3 p, vec3 c) {\r\n    vec2 q = vec2( length(p.xz), p.y );\r\n    float d1 = -q.y-c.z;\r\n    float d2 = max( dot(q,c.xy), q.y);\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fConeSection(vec3 p, float h, float r1, float r2) {\r\n    float d1 = -p.y - h;\r\n    float q = p.y - h;\r\n    float si = 0.5*(r1-r2)/h;\r\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\r\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\r\n}\r\nfloat fPryamid4(vec3 p, vec3 h) {\r\n    // h = (cos a, sin a, height)\r\n    // Tetrahedron = Octahedron - Cube\r\n    float box = fBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\r\n    float d = 0.0;\r\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\r\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\r\n    float octa = d - h.z;\r\n    return max(-box,octa); // Subtraction\r\n}\r\nfloat length2(vec2 p) { return sqrt( p.x*p.x + p.y*p.y ); }\r\nfloat length6(vec2 p) {\r\n\tp = p*p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/6.0 );\r\n}\r\nfloat length8(vec2 p) {\r\n\tp = p*p; p = p*p; p = p*p;\r\n\treturn pow( p.x + p.y, 1.0/8.0 );\r\n}\r\nfloat fTorus82(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fTorus88(vec3 p, vec2 t) {\r\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\r\n    return length8(q)-t.y;\r\n}\r\nfloat fCylinder6(vec3 p, vec2 h) { return max( length6(p.xz)-h.x, abs(p.y)-h.y ); }\r\n// float fNoise(vec2 p) {\r\n// \tvec2 s = sin(p * 0.6345) + sin(p * 1.62423);\r\n// \treturn dot(s, vec2(0.125)) + 0.5;\r\n// }\r\nfloat fSinusoidalPlasma(vec3 p) { return sin(p.x)*cos(p.y)*sin(p.z) + 0.5*sin(p.x*2.0)*cos(p.y*2.0)*sin(p.z*2.0); }\r\nfloat fsmin(float a, float b, float k) {\r\n    // polynomial smooth min (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) - k*h*(1.0-h);\r\n}\r\n#if 1\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\r\n\treturn mix(a, b, h) + k*h*(1.0-h);\r\n}\r\n#else\r\nfloat fsmax(float a, float b, float k) {\r\n    // polynomial smooth max (k = 0.1)\r\n\tfloat h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\r\n\treturn mix(b, a, h) + k*h*(1.0-h);\r\n    // NOTE: this might be the same result as the above fsmax()\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// (object-level) operations (vector-valued object: d.xy=(dist, matID))\r\n//==============================================================================\r\n\r\n//vec2 dUnion(vec2 d1, vec2 d2) { return d1.x < d2.x ? d1 : d2; }\r\nvec2 dUnion(vec2 d1, vec2 d2) { return mix(d1, d2, step(d2.x, d1.x)); }\r\nvec2 dIntersect(vec2 d1, vec2 d2) { return mix(d2, d1, step(d2.x, d1.x)); }\r\nvec2 dSubtract(vec2 d1, vec2 d2) { return dIntersect(d1, vec2(-d2.x, d2.y)); }\r\n// ds = displacement to apply to d1\r\n// for example:\r\n// float ds(vec3 p) { return sin(2*p.x)*sin(2*p.y)*sin(2*p.z); }\r\n// vec2 new_sphere = dDisplace( vec2(fSphere(p,r), m), ds(p) );\r\nvec2 dDisplace(vec2 d1, float ds) { return vec2(d1.x + ds, d1.y); }\r\nvec2 dSmoothUnion(vec2 d1, vec2 d2, float k) {\r\n    // smooth union (often k = 0.1)\r\n\tfloat f = fsmin( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d2.x, d1.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothIntersect(vec2 d1, vec2 d2, float k) {\r\n    // smooth intersection (often k = 0.1)\r\n\tfloat f = fsmax( d1.x, d2.x, k );\r\n\tfloat m = mix( d1.y, d2.y, step(d1.x, d2.x) );\r\n\treturn vec2(f, m);\r\n}\r\nvec2 dSmoothSubtract(vec2 d1, vec2 d2, float k) { return dSmoothIntersect(d1, vec2(-d2.x, d2.y), k); }\r\n\r\n//==============================================================================\r\n// (space-level) operations (vector-valued space: p=(x,y,z))\r\n//==============================================================================\r\n\r\nvec3 sRepeat(vec3 p, vec3 spacing) {\r\n    // The same domain space is repeated along (x,y,z)-axis, whose size is spacing.xyz, respectively.\r\n    // if spacing.y=0, then infinite column is repeated along x-axis & z-axis\r\n\tvec3 q = p - 0.5*spacing;\r\n\treturn mod(q, spacing) - 0.5*spacing;\r\n}\r\nvec3 sTwist(vec3 p, float angle) {\r\n    // twist by angle per unit-length along y-axis with the right-hand rule\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 twist = m*p.zx;\r\n\treturn vec3( twist.y, p.y, twist.x );\r\n}\r\nvec3 sTwistY(vec3 p, float angle) {\r\n    // twist along y-axis\r\n\treturn sTwist( p, angle );\r\n}\r\nvec3 sTwistZ(vec3 p, float angle) {\r\n    // twist along z-axis\r\n\tvec3 q = p.yzx;\r\n\tq = sTwist( q, angle );\r\n\treturn q.zxy;\r\n}\r\nvec3 sTwistX(vec3 p, float angle) {\r\n    // twist along x-axis\r\n\tvec3 q = p.zxy;\r\n\tq = sTwist( q, angle );\r\n\treturn q.yzx;\r\n}\r\nvec3 sTranslate(vec3 p, vec3 t) { return p - t; }\r\nvec3 sRotateX(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( p.x, c*p.y+s*p.z, -s*p.y+c*p.z );\r\n}\r\nvec3 sRotateY(vec3 p, float angle) {\r\n\t//float s = sin(angle);\r\n    float s = -sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.z, p.y, -s*p.x+c*p.z );\r\n}\r\nvec3 sRotateZ(vec3 p, float angle) {\r\n\tfloat s = sin(angle);\r\n\tfloat c = cos(angle);\r\n\treturn vec3( c*p.x+s*p.y, -s*p.x+c*p.y, p.z );\r\n}\r\n// Scale\r\n// e.g., float fScaled = fSphere( p/s, r ) * s\r\n// only possible to scale uniformly\r\nvec3 sCheapBendY(vec3 p, float angle) {\r\n    // bending moment: yaxis, convex up = zaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.x );\r\n\tfloat s = sin( angle*p.x );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.zx;\r\n\treturn vec3( b.y, p.y, b.x );\r\n}\r\nvec3 sCheapBendZ(vec3 p, float angle) {\r\n    // bending moment: zaxis, convex up = xaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.y );\r\n\tfloat s = sin( angle*p.y );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.xy;\r\n\treturn vec3( b.x, b.y, p.z );\r\n}\r\nvec3 sCheapBendX(vec3 p, float angle) {\r\n    // bending moment: xaxis, convex up: yaxis, fixed: (0,0,0)\r\n\tfloat c = cos( angle*p.z );\r\n\tfloat s = sin( angle*p.z );\r\n\tmat2 m = mat2( c, -s, s, c );\r\n\tvec2 b = m*p.yz;\r\n\treturn vec3( p.x, b.x, b.y );\r\n}\r\n\r\n//==============================================================================\r\n// Ray marching\r\n//==============================================================================\r\n\r\n#define EPS             0.001\r\n#define MAX_RAY_ITER    512     // 256 128\r\n#define MIN_RAY_DIST    0.02    // 0.02\r\n#define MAX_RAY_DIST    20.0    // 20.0\r\n#define MAX_SHADOW_ITER 64      // 16\r\n#define MIN_SHADOW_DIST 0.005   // 0.01\r\n#define MAX_SHADOW_DIST 10.0    // 2.5\r\n\r\nvec2 sceneMap( in vec3 p );\r\n\r\n//==============================================================================\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float k )\r\n// tmin = 0.005\r\n// tmax = MAX_RAY_DIST*0.5\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_SHADOW_ITER; i++)\r\n    {\r\n        float h = sceneMap(ro + rd * t).x;\r\n        shade = min( shade, k * h / t );\r\n        t += clamp( h, 0.5, 1.0 );\r\n        if( h < EPS || t > tmax ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.1, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat sceneShadow( in vec3 ro, in vec3 rd )\r\n{\r\n    return sceneShadow( ro, rd, MIN_SHADOW_DIST, MAX_RAY_DIST*0.5, 64.0 ); // 10, 32 or 64\r\n}\r\n\r\nfloat sceneShadow( in vec3 ro, in vec3 rd, float tmin, float k )\r\n// k = fade-off factor (eg: 10, 32 or 64) (smaller: soft penumbra, larger: hard-edged penumbra)\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<40; i++)\r\n    {\r\n        float h = sceneMap(ro + rd*t).x;\r\n        shade = min( shade, smoothstep(0.0, 1.0, k*h/t) );\r\n\t\tt += clamp( h, 0.05, 0.5 );\r\n\t\tif( h < 0.0001 ) break;\r\n    }\r\n    return clamp(shade, 0.0, 1.0);\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat sceneAO( in vec3 p, in vec3 n )\r\n{\r\n    float ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i = 0; i < 6; i++)\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = sceneMap( n * off + p ).x;\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nvec3 sceneNormal( in vec3 p )\r\n{\r\n    vec3 eps = vec3(EPS, 0.0, 0.0);\r\n    vec3 n = vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x);\r\n    return normalize(n);\r\n}\r\n\r\nvec3 sceneNormal( in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2( 0.005*t, 0.0 );\r\n\treturn normalize( vec3(\r\n            sceneMap(p + eps.xyy).x - sceneMap(p - eps.xyy).x,\r\n            sceneMap(p + eps.yxy).x - sceneMap(p - eps.yxy).x,\r\n            sceneMap(p + eps.yyx).x - sceneMap(p - eps.yyx).x ) );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat rayTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax, in float mfac )\r\n{\r\n    float t = tmin;\r\n\tfor(int i = 0; i < MAX_RAY_ITER; i++)\r\n\t{\r\n\t\tfloat d = sceneMap( ro + rd*t ).x;\r\n\t\tif( d < EPS || t > tmax ) break;\r\n        t += mfac * d; // mfac = 1.0, 0.75, 0.5, 0.3...\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd, float tmin, float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin;\r\n    for(int i = 0; i < MAX_RAY_ITER; i++)\r\n    {\r\n        vec2 d = sceneMap( ro + rd*t );\r\n        if( d.x < EPS || t > tmax ) break;\r\n        t += d.x;\r\n        m = d.y;\r\n    }\r\n    if( t > tmax ) m = -1.0;\r\n    return vec2(t, m);\r\n}\r\n\r\nvec2 rayMarching( in vec3 ro, in vec3 rd )\r\n{\r\n    return rayMarching( ro, rd, MIN_RAY_DIST, MAX_RAY_DIST );\r\n}\r\n\r\n//==============================================================================\r\n\r\nfloat bisectTracing( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n{\r\n    float t = tmin, told = tmin, mid, dn;\r\n    float d = sceneMap(ro + rd*t).x;\r\n    float sgn = sign(d);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d) != sgn || d < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d)*(log(abs(d) + 1.1)*0.7 - d*0.7) + d*0.7;\r\n        d = sceneMap(ro + rd*t).x;\r\n    }\r\n    if( sign(d) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            float d = sceneMap(ro + rd*mid).x;\r\n            if( abs(d) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return t;\r\n}\r\n\r\nvec2 bisectMarching( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// return vec2(travelDist, materialID)\r\n// if travelDist > tmax, no intersection found\r\n{\r\n    float m = -1.0;\r\n    float t = tmin, told = tmin, mid, dn;\r\n    vec2 d = sceneMap(ro + rd*t); m = d.y;\r\n    float sgn = sign(d.x);\r\n    for(int i=0; i<80; i++)\r\n    {\r\n        if( sign(d.x) != sgn || d.x < EPS || t > tmax ) break;\r\n        told = t;\r\n        t += step(-1.0, -d.x)*(log(abs(d.x) + 1.1)*0.7 - d.x*0.7) + d.x*0.7;\r\n        d = sceneMap(ro + rd*t); m = d.y;\r\n    }\r\n    if( sign(d.x) != sgn )\r\n    {\r\n        dn = sign( sceneMap(ro + rd*told).x );\r\n        vec2 iv = vec2(told, t);\r\n        for(int ii=0; ii<8; ii++)\r\n        {\r\n            mid = dot(iv, vec2(0.5));\r\n            vec2 d = sceneMap(ro + rd*mid); m = d.y;\r\n            if( abs(d.x) < EPS ) break;\r\n            iv = mix( vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d.x*dn) );\r\n        }\r\n        t = mid;\r\n    }\r\n    return vec2(t, m);\r\n}\r\n\r\n//==============================================================================\r\n\r\nmat3 cameraMatrix( vec3 ro, vec3 ta )\r\n{\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cu = normalize( cross(cw, vec3(0.0, 1.0, 0.0)) );\r\n    vec3 cv = normalize( cross(cu, cw) );\r\n    return mat3(cu, cv, cw);\r\n}\r\n\r\n#endif // RAYMARCH_DISTANCES\r\n#define USE_WATER_1\r\n#define USE_CLOUDS_1\r\n#define USE_RAIN_1\r\n#define USE_FLASH_1\r\n#define USE_LENSFLARES_1\r\n#ifndef RAYMARCH_SCENE\r\n#define RAYMARCH_SCENE\r\n\r\n//==============================================================================\r\n// getMaterial() <=== terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#define MATERIAL_SKY        0.0\r\n#define MATERIAL_TERRAIN    1.0\r\n#define MATERIAL_WATER      2.0\r\n#define MATERIAL_TREES      3.0\r\n#define MATERIAL_CLOUDS     4.0\r\n#define MATERIAL_FISH       10.0\r\n#define MATERIAL_TEXTURE0  20.0\r\n#define MATERIAL_TEXTURE1  21.0\r\n#define MATERIAL_TEXTURE2  22.0\r\n#define MATERIAL_TEXTURE3  23.0\r\n\r\nstruct ShadeMaterial\r\n{\r\n    vec3 albedo; // base color\r\n    float gloss; // gloss = 1 - roughness\r\n    float metalness; // not used...\r\n};\r\n\r\nvec4 texCube( in sampler2D tex, in vec3 p, in vec3 n );\r\n\r\nShadeMaterial getMaterial( vec3 p, vec3 n, float m )\r\n{\r\n    ShadeMaterial mtl;\r\n    if( m == MATERIAL_SKY )\r\n    {\r\n        mtl.albedo = vec3(0.2, 0.5, 0.85);\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_WATER )\r\n    {\r\n        mtl.albedo = vec3(1.0);\r\n        vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n        float gloss = max(dp.x, dp.y);\r\n        gloss = exp2( -gloss * 0.3 );\r\n        mtl.gloss = gloss;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE0 )\r\n    {\r\n        vec3 col = texCube( textureMaps[0], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE1 )\r\n    {\r\n        vec3 col = texCube( textureMaps[1], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE2 )\r\n    {\r\n        vec3 col = texCube( textureMaps[2], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    else if( m == MATERIAL_TEXTURE3 )\r\n    {\r\n        vec3 col = texCube( textureMaps[3], p, n ).xyz;\r\n        mtl.albedo = col;\r\n        mtl.gloss = 0.0;\r\n    }\r\n    return mtl;\r\n}\r\n\r\n//==============================================================================\r\n// Basic Functions: \r\n//      fresnelGloss(), getExtinction(), cheapCurvature()\r\n//==============================================================================\r\n\r\nvec3 fresnelGloss( vec3 n, vec3 v, vec3 F0, float gloss )\r\n{\r\n    float dotNV = max(0.0, dot(n, v));\r\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - dotNV, 5.0) * pow(gloss, 20.0);\r\n}\r\n\r\nvec3 getExtinction( float dist, float density, vec3 col )\r\n// dist = traveled distance\r\n// density = optical density (= absorption coeff) (eg: WATER_OPACITY*16.0 for water)\r\n// col = extinctCol (= 1.0-vec3(0.5,0.4,0.1) for water)\r\n{\r\n    //return exp2( -dist * density * col ); // exp2(x) = 2^x\r\n    return exp( -dist * density * col ); // exp2(x) = 2^x\r\n}\r\n\r\nfloat cheapCurvature( in vec3 p )\r\n// here, used to darken the crevices(= crack)\r\n{\r\n    const float eps = 0.05, amp = 4.0, ampInit = 0.5;\r\n    vec2 e = vec2(-1.0, 1.0)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\r\n    float t1 = sceneMap(p + e.yxx).x, t2 = sceneMap(p + e.xxy).x;\r\n    float t3 = sceneMap(p + e.xyx).x, t4 = sceneMap(p + e.yyy).x;\r\n    return saturate((t1 + t2 + t3 + t4 - 4.0*sceneMap(p).x)*amp + ampInit);\r\n}\r\n\r\n//==============================================================================\r\n// Cook-Torrance PBR\r\n//==============================================================================\r\n\r\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\r\n    float a = roughness*roughness;\r\n    float a2 = a*a;\r\n    float dotNH = max(dot(N, H), 0.0);\r\n    float denom = (dotNH*dotNH * (a2 - 1.0) + 1.0);\r\n    denom = PI * denom * denom;\r\n    return a2 / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and dotNH=1.0\r\n}\r\nfloat GeometrySchlickGGX(float dotNV, float roughness) {\r\n    float r = roughness + 1.0;\r\n    float k = (r*r) / 8.0;\r\n    return dotNV / (dotNV * (1.0 - k) + k);\r\n}\r\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float ggx2 = GeometrySchlickGGX(dotNV, roughness);\r\n    float ggx1 = GeometrySchlickGGX(dotLN, roughness);\r\n    return ggx1 * ggx2;\r\n}\r\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\r\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\r\n}\r\nvec3 getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 specular = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    return (kD * albedo / PI + specular) * radiance * dotLN;\r\n}\r\nvoid getCookShading( \r\n    in vec3 albedo, float metallic, float roughness, \r\n    in vec3 ld, in vec3 lc, \r\n    in vec3 n, in vec3 rd, \r\n    out vec3 diffuse, out vec3 specular )\r\n// ld = light direction\r\n// lc = light color\r\n// NOTE: we consider only the diffuse & specular of directional light\r\n{\r\n    vec3 F0 = vec3(0.04);\r\n    F0 = mix(F0, albedo, metallic);\r\n    vec3 radiance = lc;\r\n    vec3 N = n;\r\n    vec3 V = -rd;\r\n    vec3 L = ld;\r\n    vec3 H = normalize(V + L);\r\n    float dotHV = max(dot(H, V), 0.0);\r\n    float dotNV = max(dot(N, V), 0.0);\r\n    float dotLN = max(dot(N, L), 0.0);\r\n    float NDF = DistributionGGX( N, H, roughness );\r\n    float G = GeometrySmith( N, V, L, roughness );\r\n    vec3 F = fresnelSchlick( dotHV, F0 );\r\n    vec3 spec = (NDF * G * F) / max(4.0 * dotNV * dotLN, 0.001);\r\n    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);\r\n    vec3 diff = kD * albedo / PI;\r\n    vec3 lint = radiance * dotLN;\r\n    diffuse = diff * lint;\r\n    specular = spec * lint;\r\n}\r\nvoid getCookShading( vec3 albedo, float gloss, vec3 lc, vec3 ld, vec3 n, vec3 rd, out vec3 diffuse, out vec3 specular )\r\n// NOTE*: fresnel not included (only called for internal use)\r\n{\r\n    vec3 v = -rd;\r\n\tvec3 h = normalize( v + ld );\r\n\tfloat dotLN = max(dot(ld, n), 0.0);\r\n\tfloat dotNV = max(dot(v, n), 0.0);\r\n\tfloat dotNH = max(dot(n, h), 0.0);\r\n    vec3 lightWt = lc * dotLN;\r\n    diffuse = albedo/PI * lightWt;\r\n\r\n\tfloat a = 1.0 - gloss;\r\n\tfloat a2 = a * a;\r\n\tfloat denom = dotNH * dotNH * (a2 - 1.0) + 1.0;\r\n\tfloat D = a2 / (PI * denom * denom);\r\n\tfloat k = a / 2.0;\r\n    float vis1 = 1.0 / ((dotLN + 0.0001) * (1.0 - k) + k);\r\n    float vis2 = 1.0 / ((dotNV + 0.0001) * (1.0 - k) + k);\r\n    float G = vis1 * vis2;\r\n\tspecular = (D * G) * lightWt;\r\n}\r\n\r\n//==============================================================================\r\n// Blinn-Phong Shading\r\n//==============================================================================\r\n\r\nvec3 getPhongShading( in vec3 col, in float s, in vec3 ld, in vec3 lc, in vec3 p, in vec3 n, in vec3 rd )\r\n// s = shininess (= 32, 64, 128, 256...)\r\n// ld = light direction\r\n// lc = light color\r\n{\r\n    #if 0\r\n        float shadow = sceneShadow(p, ld);\r\n        float ao = sceneAO(p, n);\r\n        float atten = 1.0;\r\n        float lfactor = atten * shadow * ao;\r\n    #else\r\n        float lfactor = 1.0;\r\n    #endif\r\n\r\n    vec3 v = -rd;\r\n    vec3 h = normalize(ld + v);\r\n    float amb = 0.0;//0.1\r\n    float diff = max(dot(ld,n),0.0);\r\n    float spec = pow(max(dot(n,h),0.0), s);\r\n\r\n    return amb + (col*diff + spec) * lc * (lfactor);\r\n\r\n    // < Blinn-Phong reflection >\r\n    // col = ka*ia + { kd(L*N)*id + ks(R*V)^alpha*is } * (atten*shadow*ao)\r\n    // col = ka*ia + { albedo*(L*N) + (N*H)^alpha } * lightCol * (atten*shadow*ao)\r\n    // R*V (phong model) = N*H (blinn-phong model) (where H=L+V)\r\n    // kd = albedo, ks = vec3(1.0)\r\n    // atten = lightPower/(dist*dist)\r\n    // alpha = shininess (eg: 16, 32, 64, 128)\r\n    // i = incoming light, k = material\r\n    // d = diffuse, s = specular, a = ambient\r\n}\r\n\r\n//==============================================================================\r\n// Oren-Nayar Diffuse Lighting\r\n//==============================================================================\r\n\r\nfloat orenNayarDiffuse( in vec3 l, in vec3 n, in vec3 v, float r )\r\n// return the diffuse light intensity (before multiplying albedo)\r\n// l = lightDir (surf to light)\r\n// n = surface normal at the sample point\r\n// v = viewDir (surf to eye)\r\n// r = surface roughness\r\n{\r\n    float r2 = r*r;\r\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\r\n    float b = 0.45*(r2/(r2+0.09));\r\n\r\n    float nl = dot(n, l);\r\n    float nv = dot(n, v);\r\n\r\n    float ga = dot(v-n*nv, n-n*nl);\r\n\r\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\r\n}\r\n\r\n//==============================================================================\r\n// Reflection (not including shadows & specular for high performance) (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz );\r\n\r\nvec4 reflectRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// return vec4(reflectCol, travelDist)\r\n{\r\n    vec3 rd2 = reflect( rd, n );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    return vec4( diffuse, hit.x ); // we ignore shadows, specular...\r\n}\r\n\r\n//==============================================================================\r\n// Refraction (or transmittance) with inscatter & extinction (<=== riverFS.glsl)\r\n//==============================================================================\r\n\r\nvec4 refractRayColor( in vec3 lc, in vec3 ld, in vec3 rd, in vec3 p, in vec3 n, in float eta, in float density, in float FAR )\r\n// rd = 1st rays\r\n// p = position at 1st hit\r\n// n = normal at 1st hit\r\n// eta = airIOR / waterIOR (= 1.0 / 1.3333) when light travel from air to water\r\n// density = optical density (eg: WATER_OPACITY*6.0 for water)\r\n// return vec4(refractCol, travelDist)\r\n{\r\n    vec3 rd2 = refract( rd, n, eta );\r\n\r\n    vec2 hit = bisectMarching( p, rd2, 0.01, FAR );\r\n\r\n    if( hit.x > FAR ) return vec4( skyColor( ld, rd2, 0.0 ), hit.x );\r\n\r\n    // material\r\n    vec3 p2 = p + rd2 * hit.x;\r\n    vec3 n2 = sceneNormal( p2, EPS );\r\n    ShadeMaterial mtl = getMaterial( p2, n2, hit.y );\r\n\r\n    // lighting\r\n    vec3 diffuse, specular;\r\n    getCookShading( mtl.albedo, mtl.gloss, lc, ld, n2, rd2, diffuse, specular );\r\n    // here, we ignore shadows, specular...\r\n\r\n    // inscatter & extinction\r\n    float travelDist = hit.x;\r\n    float sunAmount = dot(ld, rd);\r\n    vec3 inscatter = diffuse * (1.0 - exp( -travelDist * 0.1 )) * (1.0 + sunAmount);\r\n    #if 0\r\n        vec3 extinction = getExtinction( travelDist, density, diffuse ); // study required...\r\n    #else\r\n        vec3 extinction = getExtinction( travelDist, density, 1.0-vec3(0.5,0.4,0.1) );\r\n    #endif\r\n\r\n    return vec4( (diffuse + inscatter) * extinction, hit.x );\r\n}\r\n\r\n//==============================================================================\r\n// flashColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_FLASH_1\r\nvec3 flashColor( in float cloudy, in float time )\r\n{\r\n    float lightning = 0.0;\r\n    if( cloudy > 0.77 ) {\r\n        float f = mod(time + 1.5, 2.5);\r\n        if( f < 0.8 ) {\r\n            f = smoothstep(0.8, 0.0, f) * 1.5;\r\n            lightning = mod(-time*(1.5 - hash11(time*0.3)*0.002), 1.0) * f;\r\n        }\r\n    }\r\n    return saturate(vec3(1.0, 1.0, 1.2) * lightning);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyClouds() <=== cavesFS.glsl + terrainFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\nvoid applyClouds( inout vec3 col, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(0.005*p)) );\r\n}\r\n\r\nvoid applyClouds( inout vec3 col, in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    vec3 cloud = vec3(1.0, 0.95, 1.0);\r\n    float amount = 300.0; // 100 ~ 500\r\n    vec2 p = ro.xz + (rd.xz/rd.y) * (amount - ro.y);\r\n    col = mix( col, cloud, 0.5*smoothstep(0.5, 0.8, fbm_4(tex, 0.005*p)) );\r\n}\r\n\r\n//==============================================================================\r\n// applySnow()\r\n//==============================================================================\r\n\r\nvoid applySnow( inout vec3 col, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm12(0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm12(0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nvoid applySnow( inout vec3 col, in sampler2D tex, in float hmin, in float hmax, in vec3 p, in vec3 n )\r\n// (hmin, hmax) = (55.0, 80.0)\r\n{\r\n    // cf: soilColor = 0.1*vec3(0.62, 0.65, 0.7)\r\n    // amount (based on height): smoothstep( h1, h2, y + random )\r\n    // dense (based on normal): denser as n.y point toward sky\r\n    vec3 snow = 0.28*vec3(0.62, 0.65, 0.7);\r\n    //float amount = smoothstep( 55.0, 80.0, p.y + 25.0*fbm(tex, 0.01*p.xz) );\r\n    float amount = smoothstep( hmin, hmax, p.y + (hmax-hmin)*fbm(tex, 0.01*p.xz) );\r\n    float dense = smoothstep( 1.0-0.5*amount, 1.0-0.1*amount, n.y );\r\n    float strength = amount*dense;\r\n    col = mix( col, snow, smoothstep( 0.1, 0.9, strength ) );\r\n}\r\nfloat snowFlake(vec2 uv, vec2 center, float radius)\r\n{\r\n    return 1.0 - sqrt(smoothstep(0.0, radius, length(uv - center)));\r\n}\r\nvec3 snowColor( float flakeSize, float windSpeed )\r\n// snow falls from the sky (eg: col += snowColor(0.2, 0.5))\r\n// flakeSize = size of snow flake (0.0 ~ 1.0, default=0.2)\r\n// windSpeed = speed of wind (0.0 ~ 1.0, default=0.5)\r\n{\r\n\tconst float NUM_SHEETS = 10.0;\r\n\tconst float NUM_FLAKES = 400.0;\r\n\r\n\tflakeSize *= 0.002;\r\n\twindSpeed *= 2.0;\r\n\tfloat windTime = windSpeed*time;\r\n    vec2 uv = gl_FragCoord.xy / resolution.x;\r\n\tvec3 col = vec3(0.0);\r\n\r\n    for(float i=1.0; i<=NUM_SHEETS; i+=1.0)\r\n\t{\r\n        for(float j=1.0; j<=NUM_FLAKES; j+=1.0)\r\n\t\t{\r\n            if( j > NUM_FLAKES / i ) break;\r\n\t\t\tfloat size = flakeSize*i * (1.0 + rand(j)/2.0);\r\n            float speed = 0.75*size + rand(i)/1.5;\r\n\r\n            vec2 center = vec2(0.0);\r\n            center.x = -0.3 + rand(j*i) * 1.4 + 0.1*cos(windTime + sin(j*i));\r\n            center.y = fract(sin(j) - speed * windTime) / 1.3;\r\n\r\n            col += vec3( (1.0 - i/NUM_SHEETS) * snowFlake(uv, center, size) );\r\n        }\r\n    }\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// sunScatter()\r\n//==============================================================================\r\n\r\nvec3 sunScatter( vec3 ld, vec3 rd )\r\n// sun glare...\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    return 0.3*vec3(1.0,0.7,0.3) * pow( sunAmount, 8.0 );\r\n    //return 0.25*vec3(1.0,0.4,0.2)*pow( sunAmount, 4.0 );\r\n}\r\n\r\n//==============================================================================\r\n// skyColor()\r\n//==============================================================================\r\n\r\nvec3 skyColor( vec3 rd )\r\n// sky only\r\n{\r\n    rd.y = max( rd.y, 0.0 );\r\n    return vec3( pow(1.0-rd.y, 2.0), 1.0-rd.y, 0.6+(1.0-rd.y)*0.4 );\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n\tfloat sunAmount = max( dot(ld, rd), 0.0 );\r\n#if 0\r\n\tvec3 hor = mix( 1.2*vec3(0.7,1.0,1.0), vec3(1.5,0.5,0.05), 0.25+0.75*sunAmount );\r\n\tvec3 col = mix( vec3(0.2,0.6,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*max(0.0,rd.y-0.1)) );\r\n#else\r\n\t//vec3 hor = vec3(1.2);\r\n\tvec3 hor = 2.5*vec3(0.48, 0.49, 0.53);//2.5*fogColor\r\n\tvec3 col = mix( vec3(0.2,0.3,0.9), hor, exp(-(4.0+2.0*(1.0-sunAmount))*(rd.y-0.1)) );\r\n#endif\r\n    col *= 0.5;\r\n\tcol += 0.35*vec3(1.0,0.8,0.7)*pow(sunAmount,512.0);\r\n\tcol += 0.25*vec3(1.0,0.4,0.6)*pow(sunAmount,32.0);\r\n\tcol += 0.25*vec3(1.0,0.2,0.4)*pow(sunAmount,4.0);\r\n\treturn col;\r\n}\r\nvec3 skyColor( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare,sizable)\r\n{\r\n    vec3 sky = skyColor( rd );\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n    float sunGlare = 0.32; //[0.2, 0.4]\r\n    float sunSize = 1.0;   //[0.3, 2.0]\r\n\tsky += lc * pow(sunAmount, 6.5) * sunGlare;\r\n    sky += lc * min( pow( sunAmount, 1150.0 ), 0.7 ) * sunSize;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGradient( vec3 lc, vec3 ld, vec3 rd )\r\n// sky + sun(glare)\r\n{\r\n    // sky\r\n\tfloat v = pow(1.0 - max(rd.y, 0.0), 5.0)*0.5;\r\n\tvec3 sky = v * lc*vec3(0.4) + vec3(0.18,0.22,0.4);\r\n\t// sun: wide glare effect...\r\n    float sunAmount = max(dot(rd, ld), 0.0);\r\n\tsky += lc * min(pow(sunAmount, 60.5)*0.32, 0.3);\r\n\tsky += lc * min(pow(sunAmount, 1150.0), 0.3)*0.65;\r\n\treturn sky;\r\n}\r\nvec3 skyColorGlare( vec3 lc, vec3 ld, vec3 rd )\r\n{\r\n    float sunAmount = max( dot(rd, ld), 0.0 );\r\n\tfloat v = pow(1.0 - max(rd.y,0.0), 6.0);\r\n\tvec3  sky = mix(vec3(0.1, 0.2, 0.3), vec3(0.32, 0.32, 0.32), v);\r\n\tsky += lc * sunAmount * sunAmount * 0.25;\r\n\tsky += lc * min(pow(sunAmount, 800.0)*1.5, 0.3);\r\n\treturn saturate(sky);\r\n}\r\nvec3 skyColor( vec3 ld, vec3 rd, float horiz )\r\n// sky + sun(layered)\r\n// ld = direction from surface to sun\r\n// horiz = 0.0(not added) or 1.0(add horiz)\r\n{\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n\r\n    // sky\r\n    vec3 skyTop = vec3(0.2, 0.4, 0.85); skyTop = 1.2*skyTop - rd.y*rd.y*0.5;\r\n    vec3 skyBottom = vec3(0.6, 0.64, 0.72);\r\n    vec3 sky = mix( skyTop, skyBottom, pow(1.0-max(rd.y,0.0), 4.0) );\r\n    vec3 sunRedish = vec3(0.4, 0.375, 0.35);\r\n    sky = mix( sky, sunRedish, sunAmount*0.75 );// add redish around the sun\r\n\r\n    // sun with three layers (much better)\r\n    vec3 sun = 0.25*vec3(1.0,0.7,0.4) * pow(sunAmount, 5.0);\r\n    sun += 0.25*vec3(1.0,0.8,0.6) * pow(sunAmount, 64.0);\r\n    sun += 0.2*vec3(1.0,0.9,0.7) * pow(sunAmount, 512.0);\r\n\r\n    // sky with sun\r\n    sky += sun;\r\n\r\n    // sky with horizon\r\n    if( horiz == 1.0 )\r\n    {\r\n        vec3 horizCol = 0.68*vec3(0.4, 0.65, 1.0);\r\n        sky = mix( sky, horizCol, pow( 1.0-max(rd.y,0.0), 16.0 ) );\r\n    }\r\n\r\n    return sky;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd )\r\n// tex = noise texture for clouds (eg: grayNoise256.png)\r\n{\r\n    // sky (background)\r\n    vec3 col = 0.9*vec3(0.4,0.65,1.0) - rd.y*vec3(0.4,0.36,0.4);\r\n\r\n    // clouds\r\n    float t = (500.0 - ro.y) / rd.y;\r\n    if( t > 0.0 )\r\n    {\r\n        vec2 uv = (ro + t*rd).xz;\r\n        float cl = -1.0 + 2.0*fbm_9( tex, uv*0.002 );\r\n        float dl = smoothstep(-0.2,0.6,cl);\r\n        col = mix( col, vec3(1.0), 0.4*dl );\r\n    }\r\n\r\n\t// sun glare\r\n    float sunAmount = max( dot(ld, rd), 0.0 );\r\n    col += 0.6*lc*pow( sunAmount, 32.0 ); // eg: lc = vec3(1.0,0.6,0.3)\r\n\r\n\treturn col;\r\n}\r\n\r\n//==============================================================================\r\n// applyFog() <=== pbrFS.glsl + riverFS.glsl + terrainFS.glsl + terrain2FS.glsl + forestFS.glsl\r\n//==============================================================================\r\n\r\nvoid applyFog( inout vec3 col, in vec3 fog, in float density, in float dist )\r\n{\r\n    float amount = 1.0 - exp(-pow(dist * density, 1.5));\r\n    col = mix( col, fog, amount );\r\n}\r\nvoid applyFog( inout vec3 col, float dist )\r\n{\r\n    float density = 0.0005; // 0.0002 ~ 0.001\r\n    vec3 fogCol = 0.65*vec3(0.4, 0.65, 1.0);\r\n    applyFog( col, fogCol, density, dist );\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 rd, in float density, in float dist )\r\n// fog density ===> constant\r\n{\r\n    float fogAmount = 1.0 - exp(-dist * density);\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\nvoid applyFog( inout vec3 col, in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in float dist )\r\n// fog density ==> changed along y (cf: d(y) = a * e ^ (-b*y))\r\n{\r\n#if 1\r\n    float c = 0.05;  // fog factor\r\n    float b = 0.25;  // fog falloff\r\n#else\r\n    float c = 0.15;  // fog factor\r\n    float b = 0.025; // fog falloff\r\n#endif\r\n\r\n    float fogAmount = c * exp(-ro.y * b) * (1.0 - exp(-dist * rd.y * b)) / rd.y;\r\n    vec3 fogCol = skyColorGradient( lc, ld, rd );\r\n    #ifdef USE_LIGHT_FLARE\r\n        float dotLV = saturate(dot(ld, -rd));\r\n        fogCol += lc * pow(dotLV, 10.0);\r\n    #endif\r\n    col = mix(col, fogCol, fogAmount);\r\n}\r\n\r\n//==============================================================================\r\n// applyLensFlares() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_LENSFLARES_1\r\n\r\nvoid applyLensFlares( inout vec3 col, mat3 camMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camMat[0] = camera rightVec\r\n// camMat[1] = camera upVec\r\n// camMat[2] = camera forwardVec\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n{\r\n\tvec3 cu = camMat[0];\r\n\tvec3 cv = camMat[1];\r\n\tvec3 cw = camMat[2];\r\n\tfloat bri = dot(cw, ld) * 2.7 * clamp(-(0.7*cloudy-0.45) + 0.2, 0.0, 0.2);\r\n\tif( bri > 0.0 )\r\n\t{\r\n\t\tvec2 sunPos = vec2( dot( ld, cu ), dot( ld, cv ) );\r\n\t\tvec2 uvT = xy - sunPos;\r\n\t\tuvT = uvT * length( uvT );\r\n\t\tbri = pow( bri, 6.0 )*0.6;\r\n\r\n\t\tfloat glare1 = max(1.2 - length(uvT + sunPos*2.0)*2.0, 0.0);\r\n\t\tfloat glare2 = max(1.2 - length(uvT + sunPos*0.5)*4.0, 0.0);\r\n\t\tuvT = mix (uvT, xy, -2.3);\r\n\t\tfloat glare3 = max(1.2 - length(uvT + sunPos*5.0)*1.2, 0.0);\r\n\r\n\t\tcol += bri * lc * vec3(1.0, 0.5, 0.2)  * pow(glare1, 10.0)*25.0;\r\n\t\tcol += bri * vec3(0.8, 0.8, 1.0) * pow(glare2, 8.0)*9.0;\r\n\t\tcol += bri * lc * pow(glare3, 4.0)*10.0;\r\n\t}\r\n}\r\nvoid applyLensFlares( inout vec3 col, in vec3 camPos, mat4 worldMat, mat4 iprojMat, vec2 xy, vec3 lc, vec3 ld, float cloudy )\r\n// camPos = camera position (= ro)\r\n// worldMat = view space to world space\r\n// iprojMat = proj space to view space\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// lc = light(sun) color, ld = light direction\r\n// cloudy = cloud amount (0 ~ 1)\r\n{\r\n    vec3 camTar = (worldMat * iprojMat * vec4(0.,0.,0.,1.)).xyz;\r\n\tmat3 camMat = cameraMatrix(camPos, camTar);\r\n    applyLensFlares( col, camMat, xy, lc, ld, cloudy );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_1\r\n\r\nconst float CLOUD_LOWER = 2800.0;\r\nconst float CLOUD_UPPER = 3800.0;\r\n\r\nfloat cloudsMap( vec3 p, float cloudy )\r\n{\r\n\tfloat h = -(fbm13(p*0.0005) - (0.7*cloudy-0.45) - 0.6);\r\n\treturn h;\r\n}\r\nfloat cloudsMapBounded( vec3 p, float cloudy )\r\n{\r\n\tfloat h = cloudsMap( p, cloudy );\r\n    h *= smoothstep(CLOUD_UPPER + 100.0, CLOUD_UPPER, p.y);\r\n\treturn h;\r\n}\r\nfloat cloudsInScattering( vec3 p, vec3 ld, float cloudy )\r\n// return intensity of light incident on p(inside the cloud) along the ray(ld) from sun\r\n// where ld = ray direction from p to sun\r\n{\r\n\tfloat cloudThick = CLOUD_UPPER - CLOUD_LOWER;\r\n\tcloudThick *= 0.2;\r\n\t//float cloudThick = 1.0;\r\n    float l = cloudsMapBounded( p, cloudy ) - cloudsMapBounded( p + ld * cloudThick, cloudy );\r\n\treturn clamp( -l*2.0, 0.05, 1.0 );\r\n}\r\nvec3 cloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy, out float density )\r\n// lc = light color, ld = light direction\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// density = clouds density accumulated along the ray(rd)\r\n{\r\n\tfloat tmin = ((CLOUD_LOWER-ro.y) / rd.y);\r\n\tfloat tmax = ((CLOUD_UPPER-ro.y) / rd.y);\r\n\tvec3 p = ro + rd*tmin;\r\n\t#if 1\r\n\t\ttmin += hash12(p.xz*19.19)*350.0;\r\n\t#endif\r\n\r\n\t// trace the inside of clouds\r\n\tconst int iter = 20;//55\r\n\tvec3 dp = rd * (tmax-tmin) / float(iter);\r\n\tvec2 shadeSum = vec2(0.0, 0.0);\r\n\tfor(int i = 0; i < iter; i++)\r\n\t{\r\n\t\tif( shadeSum.y >= 1.0 ) break;\r\n        vec2 shade;\r\n\t\tshade.x = cloudsInScattering(p, ld, cloudy.x); // shade.x = light intensity\r\n\t\tshade.y = max(cloudsMap(p, cloudy.x), 0.0);    // shade.y = cloud density\r\n\t\t//shade.x *= shade.y;\r\n\t\tshadeSum += shade * (1.0 - shadeSum.y);        // accumulation\r\n\t\tp += dp;\r\n\t}\r\n\tvec3 clouds = mix(vec3(pow(shadeSum.x, 0.6)), lc, (1.0-shadeSum.y)*0.4);\r\n\r\n\t// add flash (= cloudy.yzw)\r\n    clouds += cloudy.yzw * (shadeSum.y + shadeSum.x + 0.2) * 0.5;\r\n\tdensity = shadeSum.y;\r\n\treturn clouds;\r\n}\r\n\r\n//==============================================================================\r\n// skyCloudsColor() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\nvec3 skyCloudsColor( in vec3 lc, in vec3 ld, in vec3 ro, in vec3 rd, in vec4 cloudy )\r\n// skyColor() + cloudsColor()\r\n// ld = light direction toward the sun\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n\tfloat density;\r\n\tvec3 sky = skyColor( ld, rd, 1.0 );\r\n\tvec3 clouds = cloudsColor( lc, ld, ro, rd, cloudy, density );\r\n\tsky = mix( sky, min(clouds, 1.0), density );\r\n\treturn saturate( sky );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// cloudsColor() (volumetric) <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_CLOUDS_2\r\n\r\nconst float CLOUD_LOWER_HEIGHT = 50.0;\r\nconst float CLOUD_UPPER_HEIGHT = 500.0;\r\nconst float CLOUD_AMOUNT = 0.0001; // 0.0 ~ 1.0\r\nconst vec3 FOG_COLOR = vec3(0.4, 0.6, 1.15);\r\n\r\nvec4 cloudsMap( in vec3 pos )\r\n// return (x,yzw) = (density, gradient)\r\n{\r\n    vec4 n = fbmd_7( pos*0.003*vec3(0.6,1.0,0.6) - vec3(0.1,1.9,2.8) );\r\n    n.x = -1.0 + 2.0*n.x;\r\n    n.yzw = 2.0 * n.yzw;\r\n    float h0 = CLOUD_LOWER_HEIGHT;\r\n    float h1 = CLOUD_UPPER_HEIGHT;\r\n    float hm = mix( h0, h1, 0.1 );\r\n    vec2 h =  smoothstepd( h0, hm, pos.y ) -  smoothstepd( hm, h1, pos.y );\r\n    h.x = 2.0*n.x + h.x + mapLinear( CLOUD_AMOUNT, 0.0, 1.0, -1.5, 0.0 );\r\n    return vec4( h.x, 2.0*n.yzw*vec3(0.6,1.0,0.6)*0.003 + vec3(0.0,h.y,0.0) );\r\n}\r\nvec4 cloudsColor( in vec3 ld, in vec3 ro, in vec3 rd, in float tmin, in float tmax )\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec4 sum = vec4(0.0);\r\n\r\n    // bounding volume!!\r\n    float tl = (CLOUD_LOWER_HEIGHT - ro.y) / rd.y;\r\n    float th = (CLOUD_UPPER_HEIGHT - ro.y) / rd.y;\r\n\r\n    tl = max( tl, 0.0 );\r\n    th = max( th, 0.0 );\r\n    tmin = max( tmin, min( tl, th ) );\r\n    tmax = min( tmax, max( tl, th ) );\r\n\r\n    float t = tmin;\r\n    float thickness = 0.0;\r\n    float delta = (tmax - tmin)/128.0;\r\n\r\n    for(int i=0; i<128; i++)\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        vec4  denGrad = cloudsMap( pos ); \r\n        float den = denGrad.x;\r\n        float dt = max(delta, 0.011*t);//0.1\r\n\r\n        if( den > 0.001 )\r\n        {\r\n        #if 1\r\n            float sha = 1.0; // low quality\r\n        #else\r\n            float sha = clamp( 1.0 - max(0.0, cloudsMap( pos + ld*5.0 ).x), 0.0, 1.0 );\r\n        #endif\r\n\r\n            // lighting\r\n            vec3 n = -normalize( denGrad.yzw );\r\n            float dif = saturate( dot(n, ld) )*sha; \r\n            float fre = saturate( 1.0 + dot(n,rd) )*sha;\r\n            vec3 lin  = vec3(0.70,0.80,1.00)*0.9*(0.6+0.4*n.y);\r\n            lin += vec3(0.20,0.25,0.20)*0.7*(0.5-0.5*n.y);\r\n            lin += vec3(1.00,0.70,0.40)*4.5*dif*(1.0-den);        \r\n            lin += vec3(0.80,0.70,0.50)*1.3*pow(fre,32.0)*(1.0-den);\r\n\r\n            // color\r\n            vec3 col = vec3(0.8,0.77,0.72) * saturate(1.0-4.0*den);\r\n            col *= lin;\r\n\r\n            // fog added\r\n            applyFog( col, FOG_COLOR, 0.001, t );\r\n\r\n            // front to back blending\r\n            float alpha = saturate( den*0.25*min(dt, tmax-t-dt) );\r\n            col.rgb *= alpha;\r\n            sum = sum + vec4(col, alpha)*(1.0 - sum.a);\r\n\r\n            thickness += dt * den;\r\n        }\r\n        else\r\n        {\r\n            dt *= 1.0 + 4.0*abs(den);\r\n        }\r\n        t += dt;\r\n        if( sum.a > 0.995 || t > tmax ) break;\r\n    }\r\n    \r\n    if( thickness > 0.0 )\r\n    {\r\n        float sunAmount = saturate( dot(ld, rd) );\r\n\t\tsum.xyz += vec3(1.0,0.6,0.4)*0.2 * pow(sunAmount,32.0) * exp(-0.3*thickness) * saturate(thickness*4.0);\r\n    }\r\n\r\n    return saturate( sum );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyRain() <=== weatherFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_RAIN_1\r\nvoid applyRain( inout vec3 col, in sampler2D tex, in vec2 xy, in vec4 cloudy, in float time )\r\n// xy = [-1.7,1.7] x [-1,1] (1.77 = aspect)\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\tvec2 st = xy * vec2(0.5+(uv.y+1.0)*0.3, 0.02) + vec2(time*0.5+uv.y*0.2, time*0.2);\r\n \tfloat f = texture(tex, st, -100.0).y * texture(tex, st*0.773, -100.0).x * 1.55;\r\n\tfloat rain = saturate((0.7*cloudy.x-0.45) - 0.15);\r\n\tf = clamp( pow(abs(f), 15.0)*5.0*(rain*rain*125.0), 0.0, (uv.y+0.1)*0.6 );\r\n\tcol = mix( col, vec3(0.15) + cloudy.yzw, f );\r\n\tcol = saturate(col);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for simple/fast waters (under sky & clouds) <=== weatherFS.glsl + terrain2FS.glsl\r\n//==============================================================================\r\n\r\n#if defined(USE_WATER_1) || defined(USE_WATER_2)\r\nconst float WATER_HEIGHT = 0.0;\r\nconst float WATER_SPEED = 0.5;      // 0.0 ~ 1.0\r\nconst float WATER_CHOPPINESS = 0.5; // 0.0 ~ 1.0 (not used...)\r\nconst float WATER_OPACITY = 0.5;    // 0.0 ~ 1.0\r\n#endif\r\n\r\n#ifdef USE_WATER_1\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 wc, in vec3 ro,in vec3 rd, in vec4 cloudy )\r\n// lc = light(sun) color, ld = light direction\r\n// wc = water color (eg: vec3(0.3, 0.4, 0.45))\r\n// cloudy.x = cloud amount (0.0 ~ 1.0)\r\n// cloudy.yzw = cloud flash color\r\n// reflected: skyColor() + cloudsColor(cloudy)\r\n// if 0.0 < vec4.w < sceneDist, then ray hits the water before hitting the terrain scene (see terrain2FS.glsl)\r\n{\r\n\t// water position (where ray intersects with water)\r\n\tfloat t = (WATER_HEIGHT-ro.y)/rd.y;\r\n    if( t < 0.0 ) return vec4(0.0,0.0,0.0,t);\r\n\tvec3 p = ro + rd * t; // p = waterPos\r\n\r\n\t// water normal\r\n\tfloat distort = WATER_SPEED * time;\r\n\tfloat tx = cos(p.x*.052)*4.5;\r\n\tfloat tz = sin(p.z*.072)*4.5;\r\n\tvec2 co = noise22( vec2(p.x*4.7 + 1.3 + tz, p.z*4.69 + distort*35.0 - tx) );\r\n\tco += noise22( vec2(p.z*8.6 + distort*13.0 - tx, p.x*8.712 + tz) )*0.4;\r\n\tvec3 n = normalize( vec3(co.x, 20.0, co.y) );\r\n\r\n\t// reflected: sky + clouds\r\n\tvec3 re = reflect(rd, n);\r\n    #ifdef USE_CLOUDS_1\r\n        vec3 sky = skyCloudsColor(lc, ld, p, re, cloudy);\r\n    #else\r\n        float density;\r\n        vec3 sky = skyColor( ld, re, 1.0 );\r\n        applyClouds( sky, ro, rd );\r\n        sky = saturate( sky );\r\n    #endif\r\n\r\n\t// lighting...\r\n\t#if 1\r\n\t\tfloat fresnel = max(dot(n, -rd), 0.0);\r\n\t\tfresnel = pow(fresnel, 0.3) * 1.1;\r\n\t\tvec3 water = mix( wc * max(dot(ld, n), 0.0), sky*0.6, fresnel );\r\n\t#else\r\n\t\t// mix sea color (diffuse) with sky color (specular)\r\n\t\tfloat FAR = CLOUD_UPPER;\r\n\t\tfloat atten = smoothstep( FAR, FAR*0.7, t );\r\n\t\tfloat F0 = 0.0204; // water\r\n\t\tvec3 V = -rd;\r\n\t\tvec3 H = normalize(ld + V);\r\n\t\tfloat F = mix(F0, 1.0, pow(1.0 - max(dot(H, V),0.0), 5.0));// schlick approximation\r\n\t\tvec3 water = mix( atten*wc*max(dot(ld, n), 0.0), sky*0.6, F );\r\n\t#endif\r\n\r\n\t// optional: add the reflected sun(= lc)...\r\n\t#if 1\r\n\t\tfloat glit = max(dot(re, ld), 0.0);\r\n\t\twater += lc * pow(glit, 220.0) * max(-(0.7*cloudy.x-0.45)*100.0, 0.0);\r\n\t#endif\r\n\r\n\t// optional: add the water glint...\r\n\t#if 1\r\n\t\ttx = p.y - ro.y;\r\n\t\twater += vec3(0.1)*saturate( 1.0 - pow(tx + 0.5, 3.0) * texture(textureMaps[0], p.xz*0.1, -2.0).x );\r\n\t#endif\r\n\r\n\treturn vec4(water, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// waterColor() for river waters (under sky + above terrain) <=== riverFS.glsl\r\n//==============================================================================\r\n\r\n#ifndef NEW_RIVER_DEPTH\r\nconst float RIVER_WAVE_LENGTH = 16.0;\r\nconst float RIVER_WAVE_HEIGHT = 1.5;\r\nfloat riverCurve( float x ) {\r\n    // definition of meandering river\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    return H * sin( PI2/L * x );\r\n}\r\nfloat riverCurved( float x ) {\r\n    // derivative of riverCurve() above\r\n    float L = RIVER_WAVE_LENGTH;\r\n    float H = RIVER_WAVE_HEIGHT;\r\n    float W = PI2/L;\r\n    return H * W * cos(W * x);\r\n}\r\nfloat riverBaseDepth( vec3 p ) {\r\n    float depth = 0.3 + (0.5 + 0.5*sin(p.x*0.001 + 3.0)) * 0.4;\r\n    float width = 2.0 + cos( p.x * 0.1 ) * 1.0;\r\n    float amount = smoothstep( width, width * 0.5, abs(p.z - riverCurve(p.x)) );\r\n    return amount * depth;\r\n}\r\nfloat riverDepth( vec3 p ) {\r\n    float depth = 0.0;\r\n    depth += riverBaseDepth(p);\r\n    depth += 0.45*riverBaseDepth(p*2.0);\r\n    return depth;\r\n}\r\n#endif\r\n\r\n#ifdef USE_WATER_2\r\nvec3 waterNoise( vec2 waterPos, vec2 flowOffset, float foamScale, float gradAscent )\r\n// foamScale = scaling factor of noise amplitude\r\n// gradAscent = scaling factorof noise derivative\r\n{\r\n    waterPos *= (WATER_CHOPPINESS*2.0);\r\n\tvec3 f = vec3(0.0);\r\n    float tot = 0.0;\r\n    float a = 1.0;\r\n    for( int i=0; i<4; i++)\r\n    {\r\n        waterPos += flowOffset * WATER_SPEED;\r\n        flowOffset *= -0.75;\r\n        vec3 v = noised( waterPos ).yzx; // v.xy = deriv, v.z = value\r\n        f += v * a;\r\n        waterPos += v.xy * gradAscent;\r\n        waterPos *= 2.0;\r\n        tot += a;\r\n        a *= foamScale;\r\n    }\r\n    return f / tot;\r\n}\r\nvec3 waterBaseFlow( vec3 p ) {\r\n    // p = waterPos\r\n    return vec3( 1.0, 0.0, riverCurved(p.x) );\r\n}\r\nfloat waterFlowDepth( vec3 p ) {\r\n    // depth from waterPos to terrainPos under the water\r\n    // p = waterPos\r\n    return WATER_HEIGHT + sceneMap(p).x - p.y;\r\n}\r\nvec3 waterFlowGradient( vec3 p ) {\r\n    // p = waterPos\r\n    vec3 eps = vec3(0.01, 0.0, 0.0);\r\n    float dx = waterFlowDepth( p + eps.xyy ) - waterFlowDepth( p - eps.xyy );\r\n    float dz = waterFlowDepth( p + eps.yyx ) - waterFlowDepth( p - eps.yyx );\r\n    return vec3( dx, 0.0, dz );\r\n}\r\nvec3 waterFlowRate( vec3 p )\r\n{\r\n    // water flow...\r\n    vec3 baseFlow = waterBaseFlow( p );\r\n    vec3 flow = baseFlow;\r\n\r\n\tfloat depth = waterFlowDepth( p );\r\n    vec3 dFlow = waterFlowGradient( p );\r\n    \r\n    flow += -dFlow * 40.0 / (1.0 + depth * 1.5);\r\n    flow *= 1.0 / (1.0 + depth * 0.5);\r\n\r\n#if 1\r\n    float behindObstacle = 0.5 - dot( normalize(dFlow), -normalize(flow)) * 0.5;\r\n    float slowDist = clamp( depth * 5.0, 0.0, 1.0);\r\n    slowDist = mix(slowDist * 0.9 + 0.1, 1.0, behindObstacle * 0.9);\r\n    slowDist = 0.5 + slowDist * 0.5;\r\n    flow *= slowDist;\r\n#endif\r\n\r\n    // water foam...\r\n    float foamScale1 = 0.5;//0.0 ~ 1.0 (default: 0.5)\r\n    float foamScale2 = 0.35;\r\n    float foamCutoff = 0.4;\r\n\r\n    float foam = abs(length( flow.xz )) * foamScale1;\r\n\tfoam += saturate( foam - foamCutoff );\r\n    foam = 1.0 - pow( depth, foam * foamScale2 );\r\n    //foam = 0.1 * foam / depth; // force foam intensity to increase...\r\n    return vec3( flow.xz * 0.6, foam  );\r\n}\r\nvec4 waterNormal( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    vec2 dWaterPos = max(abs(dFdx(waterPos.xz)), abs(dFdy(waterPos.xz)));\r\n  \tfloat flowScale = max(dWaterPos.x, dWaterPos.y);\r\n    flowScale = (1.0 / (1.0 + flowScale * flowScale * 2000.0));\r\n\r\n    float gradAscent = 0.25 - (foam * 1.5);\r\n    vec3 dxy = waterNoise(waterPos.xz * 20.0, flowOffset.xz * 20.0, (0.75 + foam*0.25), gradAscent);\r\n    flowScale *= max(0.25, 1.0 - foam * 5.0); // flatten normal in foam\r\n    vec3 blended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, flowOffset.y, dxy.y) ), flowScale );\r\n    return vec4( normalize( blended ), dxy.z * flowScale );\r\n}\r\nfloat waterFoam( vec3 waterPos, vec3 flowOffset, float foam )\r\n{\r\n    // foam = not used...\r\n    float f = waterNoise(waterPos.xz*30.0, flowOffset.xz*50.0, 0.8, -0.5 ).z;\r\n    float amount = 0.2;\r\n    f = max( 0.0, (f - amount) / amount );\r\n    return pow( 0.5, f );\r\n}\r\nvec4 waterFlowingNormal( vec3 waterPos, vec3 flowRate, float foam, float time, out float flowFoam )\r\n{\r\n    float fMag = 2.5 / (1.0 + dot( flowRate, flowRate ) * 5.0);\r\n    float t0 = fract( time );\r\n    float t1 = fract( time + 0.5 );\r\n\r\n    float o0 = t0 - 0.5;\r\n    float o1 = t1 - 0.5;\r\n    float weight = abs( t0 - 0.5 ) * 2.0;\r\n\r\n    vec3 flowOffset0 = vec3(flowRate.x*o0, fMag, flowRate.z*o0);\r\n    vec3 flowOffset1 = vec3(flowRate.x*o1, fMag, flowRate.z*o1);\r\n    vec4 normal0 = waterNormal( waterPos, flowOffset0, foam );\r\n    vec4 normal1 = waterNormal( waterPos, flowOffset1, foam );\r\n    vec4 normal = mix( normal0, normal1, weight );\r\n    normal.xyz = normalize(normal.xyz);\r\n\r\n    o0 *= 0.25;\r\n    o1 *= 0.25;\r\n    flowOffset0 = vec3(flowRate.x*o0, 0.0, flowRate.z*o0);\r\n    flowOffset1 = vec3(flowRate.x*o1, 0.0, flowRate.z*o1);\r\n    float foam0 = waterFoam( waterPos, flowOffset0, foam );\r\n    float foam1 = waterFoam( waterPos, flowOffset1, foam );\r\n    flowFoam = mix( foam0, foam1, weight );\r\n\r\n    return normal;\r\n}\r\nvec3 waterEnvColor( vec3 sky, vec3 rd, float gloss )\r\n{\r\n    // WATER_GLOSS_COLOR : appears strongly when view is parallel to the water surface\r\n    const vec3 WATER_GLOSS_COLOR = vec3(0.3, 0.2, 0.2);\r\n    return mix( WATER_GLOSS_COLOR, sky*4.0, saturate(rd.y * (1.0 - gloss*0.5)*0.5 + 0.5) );\r\n}\r\nvec4 waterColor( in vec3 lc, in vec3 ld, in vec3 sky, in vec3 ro, in vec3 rd, in float sceneDist, in float FAR )\r\n// sky = sky color\r\n// sceneDist = rayMarching().x (which used to check if water is visible)\r\n// return xyz = (waterColor), w = (dist from ro to waterPos)\r\n// if water is invisible ==> return vec4(0,0,0, dist to waterPos)\r\n{\r\n    float t = (WATER_HEIGHT-ro.y) / rd.y;\r\n    t = (t > 0.0)? t : FAR;\r\n\r\n    vec3 p = ro + rd * t; // waterPos\r\n    gl_FragDepth = getFragDepth( p );\r\n\r\n    // flowNormal\r\n    vec3 flowRateFoam = waterFlowRate( p );\r\n    vec3 flowRate = vec3(flowRateFoam.x, 0.0, flowRateFoam.y);\r\n    float flowFoam;\r\n    float foamScale = 1.5;\r\n    float foamOffset = 0.2;\r\n    float foam = saturate( (flowRateFoam.z - foamOffset) * foamScale );\r\n    foam = foam * foam * 0.5;\r\n    vec4 flowNormal = waterFlowingNormal( p, flowRate, foam, time, flowFoam );\r\n    \r\n    if( rd.y < -0.01 )\r\n    {\r\n        t -= (0.04 * (1.0 - flowNormal.w) / rd.y);\r\n    } // here, t = dist from ro to waterPos\r\n\r\n    // water visible\r\n    if( t >= sceneDist ) return vec4(0.0, 0.0, 0.0, t);\r\n\r\n    // water material\r\n    vec3 albedo = vec3(1.0);\r\n    vec3 specF0 = vec3(0.0204); // F0(water) = 0.0204\r\n    vec2 dp = max(abs(dFdx(p.xz)), abs(dFdy(p.xz)));\r\n    float gloss = max(dp.x, dp.y);\r\n    gloss = exp2( -gloss * 0.3 );\r\n\r\n    // flowNormal ==> waterNormal\r\n    vec3 n = normalize( flowNormal.xyz + ld * foam ); // would rather have SSS for foam\r\n\r\n    vec3 diffuseCol = vec3(0.0);\r\n    vec3 specularCol = vec3(0.0);\r\n\r\n    // waterSpecular ==> specularCol\r\n    vec3 waterDiffuse;\r\n    vec3 waterSpecular;\r\n    getCookShading( albedo, gloss, lc, ld, n, rd, waterDiffuse, waterSpecular );\r\n    specularCol += waterSpecular;\r\n\r\n    // reflectCol ===> specularCol\r\n    vec3 reflectCol = reflectRayColor( lc, ld, rd, p, n, FAR ).xyz;\r\n    vec3 reflectRd = reflect( rd, n );\r\n    reflectCol = mix( waterEnvColor(sky, reflectRd, gloss), reflectCol, pow(gloss, 40.0) );\r\n    specularCol += reflectCol;\r\n\r\n    // transmitCol + waterDiffuse ==> diffuseCol\r\n    vec3 transmitCol = refractRayColor( lc, ld, rd, p, n, 1.0 / 1.3333, WATER_OPACITY*6.0, FAR ).xyz;\r\n    float foamBlend = 1.0 - pow(flowFoam, foam*5.0);\r\n    diffuseCol = mix(transmitCol, waterDiffuse*0.8, foamBlend );\r\n\r\n    // fresnel\r\n    vec3 fresnel = fresnelGloss( n, -rd, specF0, gloss );\r\n    float specScale = saturate(1.0 - foamBlend*4.0);\r\n\r\n    // diffuseCol + specularCol ===> result\r\n    vec3 result = mix( diffuseCol, specularCol, fresnel*specScale );\r\n    return vec4(result, t);\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// seaColor() <=== seaFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_SEA_1\r\n\r\nconst float SEA_CHOPPY = 4.0;\r\nconst float SEA_SPEED = 0.8;\r\nconst float SEA_FREQ = 0.16;\r\nconst float SEA_HEIGHT = 0.6;\r\nconst vec3 SEA_BASE_COLOR = vec3(0.1, 0.19, 0.22);\r\nconst vec3 SEA_WATER_COLOR = vec3(0.8, 0.9, 0.6);\r\nconst mat2 SEA_ROTM2 = mat2(1.6, 1.2, -1.2, 1.6);\r\n\r\nfloat seaOctave( vec2 uv, float choppy )\r\n{\r\n    uv += (2.0*noise(uv)-1.0);\r\n    vec2 wv = 1.0 - abs( sin(uv) );\r\n    vec2 swv = abs( cos(uv) );\r\n    wv = mix( wv, swv, wv );\r\n    return pow( 1.0 - pow(wv.x * wv.y, 0.65), choppy );\r\n}\r\nfloat seaMap( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 3; i++)\r\n    {\r\n        d = seaOctave(( uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nfloat seaMapH( vec3 p )\r\n{\r\n    float seaTime = time * SEA_SPEED;\r\n    float freq = SEA_FREQ;\r\n    float amp = SEA_HEIGHT;\r\n    float choppy = SEA_CHOPPY;\r\n    vec2 uv = p.xz; uv.x *= 0.75;\r\n    float d, h = 0.0;\r\n    for(int i = 0; i < 5; i++)\r\n    {\r\n        d = seaOctave( (uv + seaTime)*freq, choppy );\r\n        d += seaOctave( (uv - seaTime)*freq, choppy );\r\n        h += d * amp;\r\n        uv *= SEA_ROTM2;\r\n        freq *= 1.9; amp *= 0.22;\r\n        choppy = mix( choppy, 1.0, 0.2 );\r\n    }\r\n    return p.y - h;\r\n}\r\nvec3 seaNormal( vec3 p, float eps )\r\n{\r\n    vec3 n;\r\n    n.y = seaMapH( p );\r\n    n.x = seaMapH( vec3(p.x+eps, p.y, p.z) )     - n.y;\r\n    n.z = seaMapH( vec3(p.x,     p.y, p.z+eps) ) - n.y;\r\n    n.y = eps;\r\n    return normalize(n);\r\n}\r\nfloat seaTracing( in vec3 ro, in vec3 rd, in float tmax )\r\n{\r\n    float tm = 0.0;\r\n    float tx = tmax;//1000.0;\r\n    float hx = seaMap(ro + rd * tx);\r\n    if( hx > 0.0 ) return tx;\r\n    float hm = seaMap(ro + rd * tm);\r\n    float tmid = 0.0;\r\n    for(int i = 0; i < 8; i++)\r\n    {\r\n        tmid = mix(tm, tx, hm/(hm-hx));\r\n        vec3 p = ro + rd * tmid;\r\n    \tfloat hmid = seaMap(p);\r\n\t\tif( hmid < 0.0 )\r\n        {\r\n        \ttx = tmid;\r\n            hx = hmid;\r\n        }\r\n        else\r\n        {\r\n            tm = tmid;\r\n            hm = hmid;\r\n        }\r\n    }\r\n    return tmid;\r\n}\r\nfloat seaLightDiffuse( vec3 n, vec3 ld, float power ) {\r\n    return pow( dot(n, ld)*0.4 + 0.6, power );\r\n}\r\nfloat seaLightSpecular( vec3 n, vec3 ld, vec3 rd, float s ) {\r\n    float nrm = (s + 8.0) / (PI * 8.0);\r\n    return pow( max( dot( reflect(rd, n), ld ), 0.0 ), s ) * nrm;\r\n}\r\nvec3 seaColor( vec3 p, vec3 n, vec3 ld, vec3 ro, vec3 rd )\r\n// p = sea position\r\n// n = normal at p\r\n// ld = light direction\r\n// ro, rd = ray definition\r\n{\r\n    float fresnel = 1.0 - max(dot(n,-rd), 0.0);\r\n    fresnel = pow(fresnel, 3.0) * 0.65;\r\n\r\n    vec3 reflected = skyColor( ld, reflect(rd, n), 1.0 );\r\n    vec3 refracted = SEA_BASE_COLOR + seaLightDiffuse(n, ld, 80.0) * SEA_WATER_COLOR * 0.12;\r\n    vec3 color = mix( refracted, reflected, fresnel );\r\n\r\n    vec3 dist = p - ro;\r\n    float atten = max( 1.0 - dot(dist, dist) * 0.002, 0.0 );//0.001\r\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\r\n\r\n    color += vec3( seaLightSpecular( n, ld, rd, 60.0 ) );\r\n\r\n    color = pow(color, vec3(1.65)); // we will apply LinearToGamma(2.2) as post-processing...\r\n    return color;\r\n}\r\nvec3 seaColor( vec3 ld, vec3 ro, vec3 rd, float tmax )\r\n{\r\n    float t = seaTracing( ro, rd, tmax );\r\n    vec3 p = ro + rd*t;\r\n    vec3 dist = p - ro;\r\n    float distpp = dot(dist,dist)*0.1 / resolution.x; // estimate "distance per pixel"\r\n    vec3 n = seaNormal( p, distpp );\r\n    //\r\n    gl_FragDepth = getFragDepth( p );\r\n    //\r\n    return seaColor( p, n, ld, ro, rd );\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// applyDustWind() <=== terrainFS.glsl + cavesFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_DUSTWIND_1\r\nfloat dustWindMap( in vec3 p, in float d, float height, float wind )\r\n{\r\n    p.x += time;\r\n    p.z += time*0.5;\r\n    return triNoise13( p*wind/(d+1.0) ) * smoothstep( height, 0.0, p.y );\r\n}\r\nvoid applyDustWind( inout vec3 col, in vec3 ro, in vec3 rd, in float t, float amount, float height, float wind )\r\n// t      = distance from ro to hitted position\r\n// amount = dust amount (0.0 ~ 1.0)\r\n// height = dust moves between 0 and height\r\n// wind   = wind turbulency (laminar: 0.01 ~ 0.2, turbulent: 0.3 ~ 1.0)\r\n{\r\n    vec3 dust = vec3(0.85, 0.65, 0.5);\r\n    float d = 0.5;\r\n    for(int i = 0; i < 7; i++)\r\n    {\r\n        vec3 p = ro + rd*d;\r\n        float w = dustWindMap(p, d, height, wind); // w = dust intensity\r\n        col = mix( col, dust, amount*saturate( w * smoothstep(d, d*1.8, t)) );\r\n        d *= 1.8;\r\n        if( d > t ) break;\r\n    }\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== terrainFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_1\r\n\r\nconst mat2 rotMat2 = mat2(1.6,-1.2,1.2,1.6);\r\nconst float TERRAIN_SCALE = 0.1;  // terrain scene scale: 0.075(high/snow), 0.1, 0.2, 0.3(lower/green)\r\nconst float TERRAIN_FREQ = 0.03;  // terrain noise frequency: 0.02, 0.03, 0.04\r\nconst float SEA_LEVEL = -2.0;     // -5.0 ~ 0.0\r\n\r\nfloat terrainH( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    //for(int i = 0; i < 15; i++)\r\n    for(int i = 0; i < 13; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 9; i++)\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 x )\r\n{\r\n    vec2  p = x*TERRAIN_FREQ;\r\n    float a = 0.0;\r\n    float b = 1.0;\r\n\tvec2  d = vec2(0.0);\r\n    for(int i = 0; i < 2; i++)//3\r\n    {\r\n        vec3 n = noised(tex, p);\r\n        d += n.yz;\r\n        a += b*n.x/(1.0+dot(d,d));\r\n\t\tb *= 0.5;\r\n        p = rotMat2*p;\r\n    }\r\n    return a/TERRAIN_SCALE + SEA_LEVEL;\r\n}\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    // terrainMap:    h(p) = p.y - terrainM( p.xz )\r\n    // terrainNormal: grad h(p) = (dh/dp.x, dh/dp.y, dh/dp.z)\r\n    vec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 lc, in vec3 ld, in vec3 p, in float t, in float tmax )\r\n// tex = \'images/raymarch/grayNoise256.png\'\r\n// p = terrainPos\r\n// t = dist from ro(cameraPos) to p\r\n// tmax = FAR\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n\r\n    float r = texture( tex, (7.0/TERRAIN_SCALE)*p.xz/256.0 ).x;\r\n\r\n    // soil\r\n    vec3 soilA = vec3(0.08,0.05,0.03);\r\n    vec3 soilB = vec3(0.10,0.09,0.08);\r\n    vec3 col = (0.75 + 0.25*r)*mix( soilA, soilB, texture(tex,0.0007*vec2(p.x,p.y*19.19)/TERRAIN_SCALE).x );\r\n    // rock\r\n    vec3 rock = 0.2*vec3(0.45, 0.30, 0.15);\r\n    col = mix( col, rock*(0.5 + 0.5*r), smoothstep(0.85, 0.9, n.y) );\r\n    // weed\r\n    vec3 weed = 0.1*vec3(0.30, 0.30, 0.10);\r\n    col = mix( col, weed*(0.5 + 0.5*r), smoothstep(0.9, 0.95, n.y) );\r\n    // grass\r\n    vec3 grass = 0.35*vec3(0.16, 0.3, 0.0);\r\n    col = mix( col, grass*(0.25 + 0.75*r), smoothstep(0.95, 1.0, n.y) );\r\n    // snow\r\n    float hmin = 10.0/TERRAIN_SCALE;\r\n    float hmax = 30.0/TERRAIN_SCALE;\r\n    applySnow( col, tex, hmin, hmax, p/TERRAIN_SCALE, n );\r\n\r\n    // lighting\r\n    float amb = saturate( 0.5 + 0.5*n.y );\r\n    float dif = saturate( dot( ld, n ) );\r\n    float bac = saturate( 0.2 + 0.8*dot(normalize(vec3(-ld.x, 0.0, ld.z)), n) );\r\n    float shd = (dif >= 0.001)? sceneShadow(p + ld*0.01/TERRAIN_SCALE, ld, 0.01/TERRAIN_SCALE, tmax/TERRAIN_SCALE, 2.0) : 1.0;\r\n    vec3 cshd = pow( vec3(shd), vec3(1.0, 1.2, 1.5) ); // colorize shadow penumbras\r\n    vec3 lin = dif*vec3(7.0,5.0,3.0)*1.3*cshd * lc;\r\n    lin += amb*vec3(0.4,0.6,1.0)*1.2;\r\n    lin += bac*vec3(0.4,0.5,0.6);\r\n    col *= lin;\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_2\r\n\r\nfloat terrainNoise( in sampler2D tex, in vec2 x )\r\n{\r\n    float f = 1.92;//2.0;\r\n    float a = 0.0;\r\n    float b = 0.5;\r\n    for(int i=0; i<6; i++)\r\n    {\r\n        float n = noise(tex, x);\r\n        a += b * n;\r\n        b *= 0.55;//0.55;\r\n        x = f * rotM2 * x;\r\n    }\r\n\treturn a;\r\n}\r\nfloat terrainH( in sampler2D tex, in vec2 p )\r\n{\r\n    const float terrain_freq = 0.01;\r\n    const float terrain_scale = 70.0;//10.0(flat) ~ 100.0(high)\r\n    p *= terrain_freq;\r\n    float e = -1.0 + 2.0*terrainNoise( tex, p + vec2(1.0,-2.0) );\r\n    e *= terrain_scale;\r\n    return e;\r\n}\r\nfloat terrainM( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\nfloat terrainL( in sampler2D tex, in vec2 p )\r\n{\r\n    return terrainH( tex, p );\r\n}\r\n\r\nfloat terrainMap( in sampler2D tex, in vec3 p )\r\n{\r\n    return p.y - terrainM( tex, p.xz );\r\n}\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 eps = vec2(0.002*t, 0.0);\r\n\treturn normalize( vec3(terrainH(tex, p.xz-eps.xy) - terrainH(tex, p.xz+eps.xy),\r\n                           2.0*eps.x,\r\n                           terrainH(tex, p.xz-eps.yx) - terrainH(tex, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D tex, in vec3 ro, in vec3 rd, in float tmin )\r\n{\r\n    float shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<8; i++)//32\r\n    {\r\n        vec3  pos = ro + t*rd;\r\n        float h = terrainMap( tex, pos );\r\n        shade = min( shade, 32.0*h/t );\r\n        if( shade < 0.0001 ) break;\r\n        t += clamp( h, 1.0+t*0.1, 50.0 );\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 terrainColor( in sampler2D tex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 n = terrainNormal( tex, p, t );\r\n    // bump map\r\n    #if 1\r\n        n = normalize( n + 1.28*(1.0-abs(n.y)) * fbmd_7(p*0.3*vec3(1.0,0.2,1.0)).yzw );//1.28=0.8*0.8*2.0\r\n    #endif\r\n\r\n    vec3 col = vec3(0.18,0.11,0.10)*0.75;\r\n    col = mix( col, vec3(0.1,0.1,0.0)*0.3, smoothstep(0.7, 0.9, n.y) );\r\n    #if 0\r\n        col *= 1.0 + 2.0*fbm_4( iChannel0, p*0.2*vec3(1.0,4.0,1.0) );\r\n    #endif\r\n    \r\n    float sha = 0.0;\r\n    float dif = saturate( dot(n, ld) );\r\n    if( dif > 0.0001 ) \r\n    {\r\n        sha = terrainShadow( tex, p+n*0.01, ld, 0.01 );\r\n        dif *= sha;\r\n    }\r\n    vec3  ref = reflect(rd, n);\r\n    float bac = saturate( dot(normalize(vec3(-ld.x, 0.0, -ld.z)), n) ) * saturate( (p.y+100.0)/100.0 );\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    vec3  lin  = 0.2*mix(0.1*vec3(0.1,0.2,0.0), vec3(0.7,0.9,1.0), dom);//pow(vec3(occ),vec3(1.5,0.7,0.5));\r\n    lin += 5.0*vec3(1.0,0.9,0.8)*dif;        \r\n    lin += 0.35*vec3(1.0)*bac;\r\n    col *= lin;\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// terrainColor() <=== canyonFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TERRAIN_3\r\n\r\nfloat terrainDetails( in sampler2D detailTex, in vec3 p )\r\n{\r\n#if 0\r\n    float f;\r\n    f  = 0.5000*noise( detailTex, p ); p = rotM3*p*2.02;\r\n    f += 0.2500*noise( detailTex, p ); p = rotM3*p*2.03;\r\n    f += 0.1250*noise( detailTex, p ); p = rotM3*p*2.01;\r\n    f += 0.0625*noise( detailTex, p );\r\n    return f;\r\n#else\r\n\treturn fbm_4( detailTex, p );\r\n#endif\r\n}\r\nfloat terrainH( in sampler2D heightTex0, in sampler2D heightTex1, in vec2 q )\r\n// heightTex0: (global) height texture\r\n// heightTex1:  (local) height texture\r\n// shapeNoise: 0.1=(almost_flat), 0.5=(smooth+wide), 2.5=(sharp+rugged)\r\n// seaLevel: height from the bottom of terrain\r\n// riseHeight (-15.0 ~ 15.0): rise above seaLevel (if negative, terrain exists below seaLevel)\r\n// sinkHeight (0.0 ~ 1.0): depth below seaLevel\r\n{\r\n\t// shapeNoise (0.1 ~ 2.5)\r\n\tfloat shapeNoise = 1.0;//1.5;//1.0;\r\n\tq *= shapeNoise;\r\n\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );    // heightTex0 = 1024 x 1024\r\n    float rr = smoothstep( 0.1, 0.5, textureLod( heightTex1, 2.0*0.03*q, 0.0 ).y ); // heightTex1 = 1024 x 1024\r\n\r\n\t// seaLevel\r\n\tfloat seaLevel = 0.5;\r\n\tfloat h = 0.7 - seaLevel;\r\n\r\n\th -= -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\t//h += -0.15 + (1.0-0.6*rr)*(1.5-1.0*th) * 0.3*(1.0-textureLod( heightTex0, 0.04*q*vec2(1.2,0.5), 0.0 ).x);\r\n\r\n\t// riseHeight (-15.0 ~ 15.0)\r\n\tfloat riseHeight = 7.0;\r\n\th += th * riseHeight;\r\n\r\n\t// sinkHeight (0.0 ~ 1.0)\r\n\tfloat sinkHeight = 0.3;\r\n\th -= rr * sinkHeight;\r\n    return h;\r\n}\r\nfloat terrainL( in sampler2D heightTex0, in vec2 q )\r\n{\r\n\tfloat th = smoothstep( 0.0, 0.7, textureLod( heightTex0, 0.001*q, 0.0 ).x );\r\n\tfloat h = 0.2;//1.0 0.2\r\n\th += th * 7.0;//7.0\r\n\treturn h;\r\n}\r\nfloat terrainMap( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p )\r\n{\r\n\t// base height\r\n\tfloat h = terrainH( heightTex0, heightTex1, p.xz );\r\n\r\n\t// added: details\r\n\tfloat detailAmount = 0.001;//0.15;//0.25;\t// 0.0 ~ 0.5\r\n    float layerAmount = 1.5;//3.0;\t\t// 0.0 ~ 3.0\r\n    float displaceAmount = 1.5;//3.0;\t// 0.0 ~ 5.0\r\n\r\n    float d = terrainDetails( detailTex, detailAmount * p * vec3(1.0, layerAmount, 1.0) );\r\n    d *= displaceAmount;\r\n\r\n\treturn (p.y - h + d) * 0.25;\r\n}\r\nvec3 terrainNormal( in sampler2D heightTex0, in sampler2D heightTex1, in vec3 p, in float t )\r\n{\r\n\tvec2 eps = vec2( 0.002*t, 0.0 );\r\n    return normalize( vec3( terrainH(heightTex0, heightTex1, p.xz-eps.xy) - terrainH(heightTex0, heightTex1, p.xz+eps.xy),\r\n                            2.0*eps.x,\r\n                            terrainH(heightTex0, heightTex1, p.xz-eps.yx) - terrainH(heightTex0, heightTex1, p.xz+eps.yx) ) );\r\n}\r\nfloat terrainShadow( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ro, in vec3 rd, float tmin )\r\n{\r\n\tfloat shade = 1.0;\r\n    float t = tmin;\r\n    for(int i=0; i<32; i++)//8 64\r\n    {\r\n        float h = terrainMap(heightTex0, heightTex1, detailTex, ro + rd * t);\r\n        shade = min( shade, 32.0*h/t );//32.0\r\n        t += clamp( h, 0.5, 1.0 );\r\n\t\tif( h < 0.001 ) break;\r\n    }\r\n    return min( max(shade, 0.0) + 0.05, 1.0 ); // 0.3 or 0.1 (preference)\r\n}\r\nfloat terrainAO( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 p, in vec3 n )\r\n{\r\n\tfloat ao = 0.0;\r\n    float s = 1.0;\r\n    for(int i=0; i<2; i++)//6\r\n    {\r\n        float off = 0.001 + 0.2 * float(i)/5.0;\r\n        float t = terrainMap( heightTex0, heightTex1, detailTex, n * off + p );\r\n        ao += ( off - t ) * s;\r\n        s *= 0.4;\r\n    }\r\n    return smoothstep( 0.0, 1.0, clamp(1.0-12.0*ao, 0.0, 1.0) );\r\n}\r\nvec3 terrainColor( in sampler2D heightTex0, in sampler2D heightTex1, in sampler2D detailTex, in vec3 ld, in vec3 rd, in vec3 p, in float t )\r\n{\r\n\tvec3 n = terrainNormal( heightTex0, heightTex1, p, t );\r\n\r\n\tfloat gloss = 2.0;//1.0; // 0.1(trash-heap) ~ 10.0(smooth)\r\n\tvec3 uvw = gloss * p;\r\n\r\n\t// bump normal\r\n\tn = getBumpNormal( heightTex0, uvw, n, 0.075 );\r\n\r\n\t// materials\r\n\tvec3 te = 0.05 + texCube( heightTex0, 0.15*uvw, n ).xyz;\r\n\tvec4 mate;\r\n\tmate.xyz = 0.6*te;\t\t\t\t// material diffuse\r\n\tmate.w = 1.5*(0.5+0.5*te.x);\t// material shininess\r\n\r\n\t// added: soil color using heightTex0\r\n\tfloat th = smoothstep( 0.1, 0.4, texCube( heightTex0, 0.002*uvw, n ).x );\r\n\tvec3 dcol = mix( vec3(0.2, 0.3, 0.0), 0.2*vec3(0.65, 0.4, 0.2), 0.2+0.8*th );\r\n\tmate.xyz = mix( mate.xyz, 2.0*dcol, th*smoothstep(0.0, 1.0, n.y) );\r\n\r\n\t// added: snow(white) using heightTex1\r\n\tfloat rr = smoothstep( 0.2, 0.4, texCube( heightTex1, 0.04*uvw, n ).y );\r\n\tmate.xyz *= mix( vec3(1.0), 2.25*vec3(0.25,0.24,0.22), rr );\r\n\tmate.xyz *= 1.5*pow(texCube( heightTex1, 8.0*uvw, n ).xyz, vec3(0.5));\r\n\tmate = mix( mate, vec4(vec3(1.0), 0.0), smoothstep(0.8, 0.9, n.y + n.x*0.6*te.x*te.x) );\r\n\tmate.xyz *= 1.5;\r\n\r\n\t// lighting\r\n\tfloat sky = 0.0;\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3(-3.0, 1.0, 0.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0, 3.0 )), n, -rd, 1.0 );\r\n\tsky += 0.2*orenNayarDiffuse( normalize(vec3( 0.0, 1.0,-3.0 )), n, -rd, 1.0 );\r\n\tfloat dif = orenNayarDiffuse( ld, n, -rd, 1.0 );\r\n\tvec3 blig = normalize(vec3(-ld.x, 0.0, -ld.z));\r\n\tfloat bac = orenNayarDiffuse( blig, n, -rd, 1.0 );\r\n\r\n\tfloat sha = 0.0;\r\n\tif( dif > 0.001 ) sha = terrainShadow( heightTex0, heightTex1, detailTex, p+0.01*n, ld, 0.005 );\r\n\tfloat spe = mate.w * pow(saturate(dot(reflect(rd,n),ld)), 2.0) * saturate(dot(n,ld));\r\n\tfloat occ = terrainAO( heightTex0, heightTex1, detailTex, p, n );\r\n\tvec3 lin = vec3(0.0);\r\n\tlin += 7.0*dif*vec3(1.20,0.50,0.25)*vec3(sha,sha*0.5+0.5*sha*sha, sha*sha);\r\n\tlin += 1.0*sky*vec3(0.10,0.50,0.70)*occ;\r\n\tlin += 2.0*bac*vec3(0.30,0.15,0.15)*occ;\r\n\tlin += 0.5*vec3(spe)*sha*occ;\r\n\tvec3 col = mate.xyz * lin;\r\n\treturn col;\r\n}\r\n#endif\r\n\r\n//==============================================================================\r\n// treesColor() <=== forestFS.glsl\r\n//==============================================================================\r\n\r\n#ifdef USE_TREES_1\r\n\r\nconst float TREES_HEIGHT = 2.0;\r\n\r\nfloat terrainM( in sampler2D tex, in vec2 p );\r\nvec3 terrainNormal( in sampler2D tex, in vec3 p, in float t );\r\n\r\nfloat treesMap( in sampler2D tex, in vec3 p )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n{\r\n    //float base = terrainM(p.xz);\r\n    float base = terrainM(tex, p.xz)*0.925;\r\n\r\n    float d = 20.0;//10.0\r\n    vec2 n = floor( p.xz );\r\n    vec2 f = fract( p.xz );\r\n    for(int j=-1; j<=1; j++)\r\n    for(int i=-1; i<=1; i++)\r\n    {\r\n        vec2  g = vec2( float(i), float(j) );\r\n        vec2  o = hash22( n + g );\r\n        vec2  v = hash22( n + g + vec2(13.1,71.7) );\r\n        vec2  r = g - f + o;\r\n\r\n        float height = TREES_HEIGHT * (0.4 + 0.8*v.x);\r\n        float width = 0.9*(0.5 + 0.2*v.x + 0.3*v.y);\r\n        vec3  q = vec3(r.x, p.y-base-height*0.5, r.y);\r\n        #if 1\r\n            float k = fEllipsoid( q, vec2(width,0.5*height).xyx );\r\n        #else\r\n            vec3 a = vec3(0.0, -height*0.5, 0.0);\r\n            vec3 b = vec3(0.0, height*0.5, 0.0);\r\n            float k = fCapsule( q, a, b, width );\r\n        #endif\r\n        d = min( d, k );\r\n    }\r\n\r\n    // distort ellipsoids to make them look like trees (works only in the distance really)\r\n    float rt = 350.0 * rand( p.xz );\r\n    //if( rt < 350.0 )\r\n    {\r\n        float s = -1.0 + 2.0*fbm_4( tex, p*3.0 );\r\n        float att = 1.0-smoothstep(150.0, 350.0, rt);\r\n        d += 2.0*s*s*att*att;\r\n    }\r\n    \r\n    return d;\r\n}\r\nvec3 treesNormal( in sampler2D tex, in vec3 p, in float t )\r\n{\r\n    vec2 e = vec2(t,-t) * 0.002;\r\n    return normalize( e.xyy * treesMap(tex, p + e.xyy) \r\n                    + e.yyx * treesMap(tex, p + e.yyx) \r\n                    + e.yxy * treesMap(tex, p + e.yxy) \r\n                    + e.xxx * treesMap(tex, p + e.xxx) );\r\n}\r\nfloat treesShadow( in sampler2D tex, in vec3 ro, in vec3 rd )\r\n{\r\n    float shade = 1.0;\r\n    float t = 0.02;\r\n    //for( int i=0; i<50; i++ )\r\n    for( int i=0; i<10; i++ )\r\n    {\r\n        float h = treesMap( tex, ro + rd*t );\r\n        shade = min( shade, 32.0*h/t );\r\n        t += h;\r\n        if( shade < 0.001 || t > 20.0 ) break;\r\n    }\r\n    return saturate( shade );\r\n}\r\nvec3 treesColor( in sampler2D tex, in vec3 ld, in vec3 pos, in vec3 rd, float t )\r\n// tex = noise texture (eg: grayNoise256.png)\r\n// ld = light direction (eg: SUN_LIGHT)\r\n{\r\n    vec3 terrainN = terrainNormal( tex, pos, t );\r\n\r\n    vec3 treesN = treesNormal( tex, pos, t );\r\n    vec3 n = normalize( treesN + 2.5*terrainN );\r\n\r\n    // lighting\r\n    float sha = 1.0;\r\n    vec3  ref = reflect(rd, n);\r\n    float occ = 1.0;\r\n    float dif = saturate(0.1 + 0.9*dot(n, ld));\r\n    if( dif > 0.0001 )\r\n    {\r\n        sha *= treesShadow( tex, pos+n*0.1, ld ); // only cast in non-terrain-occluded areas\r\n    }\r\n    float dom = saturate( 0.5 + 0.5*n.y );\r\n    float fre = saturate( 1.0 + dot(n,rd) );\r\n    float spe = pow(saturate(dot(ref, ld)), 9.0) * dif*sha * (0.2 + 0.8*pow(fre, 5.0)) * occ;\r\n\r\n    // lights\r\n    vec3 lin = 0.5*mix(0.1*vec3(0.1,0.2,0.0),vec3(0.6,1.0,1.0),dom*occ);\r\n    lin += 10.0*vec3(1.0,0.9,0.8)*dif*occ*sha;\r\n    lin += 0.5*vec3(0.9,1.0,0.8)*pow(fre, 3.0)*occ;\r\n    lin += 0.05*vec3(0.15,0.4,0.1)*occ;\r\n   \r\n    // material\r\n    float brownAreas = fbm_4( tex, pos.zx*0.03 );\r\n    vec3 col = vec3(0.08,0.09,0.02);\r\n    col = mix( col, vec3(0.06,0.05,0.01)*1.1, 1.0-smoothstep(0.9,0.91,terrainN.y) );\r\n    col = mix( col, vec3(0.25,0.16,0.01)*0.15, 0.7*smoothstep(0.1,0.3,brownAreas)*smoothstep(0.5,0.8,terrainN.y) );\r\n    col *= 1.6;\r\n\r\n    // brdf * material\r\n    col *= lin;\r\n    col += spe*1.2*vec3(1.0,1.1,2.5);\r\n\r\n    #if 1\r\n        applyFog( col, FOG_COLOR, 0.0005, t );\r\n    #endif\r\n\r\n    return col;\r\n}\r\n#endif\r\n\r\n#endif // RAYMARCH_SCENE\r\n\r\n// rgbaNoise256.png\r\n#define iChannel0   textureMaps[0]\r\n\r\n//==============================================================================\r\n\r\nconst vec3 SUN_LIGHT = normalize(vec3(0.35, 0.14, 0.3));\r\nconst vec3 SUN_COLOR = vec3(1.0, 0.7, 0.55);\r\nconst vec3 WATER_COLOR = vec3(0.3, 0.4, 0.45);\r\n\r\nvec2 sceneMap( in vec3 p ){ return vec2(0.0); }\r\n\r\nvoid main()\r\n{\r\n\t#ifndef RAYMARCH_RAY\r\n#define RAYMARCH_RAY\r\n\r\n// screen position [-1, 1]\r\nvec2 ndc = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution;\r\n\r\n// ray direction in normalized device coordinate\r\nvec4 ndcRay = vec4( ndc.xy, 1.0, 1.0 );\r\n\r\n// ray direction in world coordinate\r\nndcRay = cameraProjectionMatrixInverse * ndcRay;\r\nndcRay = cameraWorldMatrix * ndcRay;\r\nndcRay /= ndcRay.w;\r\nvec3 rd = normalize( ndcRay.xyz );\r\n\r\n// ray origin (= camera position in world coordinate)\r\nvec3 ro = cameraPosition;\r\n\r\n#ifdef USE_SHADERTOY_CAMERA\r\n    vec3 ta = (cameraWorldMatrix * cameraProjectionMatrixInverse * vec4(0.0,0.0,0.0,1.0)).xyz;\r\n    vec3 cw = normalize( ta - ro );\r\n    vec3 cv = vec3(0.0, 1.0, 0.0);\r\n    vec3 cu = cross(cw, cv);\r\n    cv = cross(cu, cw);\r\n    mat3 ca = mat3(cu, cv, cw);\r\n#endif\r\n\r\n#endif // RAYMARCH_RAY\r\n\r\n    float curTime = time*0.5;\r\n\r\n\tvec4 cloudy;\r\n\tcloudy.x = cos(curTime* 0.25)*0.5 + 0.5;\t\t// cloud amount\r\n    cloudy.yzw = flashColor( cloudy.x, curTime );\t// flash in cloudy weather\r\n\r\n\tvec3 col;\r\n\tif( rd.y > 0.0 )\r\n\t\tcol = skyCloudsColor( SUN_COLOR, SUN_LIGHT, ro, rd, cloudy );\r\n\telse\r\n\t\tcol = waterColor( SUN_COLOR, SUN_LIGHT, WATER_COLOR, ro, rd, cloudy ).rgb;\r\n\r\n\tvec2 xy = ndc * vec2(resolution.x/resolution.y, 1.0); // xy = [-1.77, 1.77] x [-1, 1]\r\n\tapplyLensFlares( col, ro, cameraWorldMatrix, cameraProjectionMatrixInverse, xy, SUN_COLOR, SUN_LIGHT, cloudy.x );\r\n\tapplyRain( col, iChannel0, xy, cloudy, curTime );\r\n\r\n\tcol = (col*col*(3.0-2.0*col));\r\n\tcol *= 0.55 + 0.45 * Vignetting( col, 0.8 );\r\n\tgl_FragColor = LinearToGamma( vec4(col, 1.0), 2.2 );\r\n}\r\n'}},__webpack_module_cache__={};function __webpack_require__(e){if(__webpack_module_cache__[e])return __webpack_module_cache__[e].exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=__webpack_require__(5370);window.THREE=e,__webpack_require__(2700),__webpack_require__(303),__webpack_require__(7342),__webpack_require__(6288),__webpack_require__(822),__webpack_require__(9607),__webpack_require__(4419),__webpack_require__(5847),__webpack_require__(4271),__webpack_require__(6834),__webpack_require__(1617),__webpack_require__(3215),__webpack_require__(3202),__webpack_require__(8085),__webpack_require__(7181),__webpack_require__(1088),__webpack_require__(3138),__webpack_require__(5992),__webpack_require__(3861),__webpack_require__(3538),__webpack_require__(3818),__webpack_require__(5071),__webpack_require__(3572),__webpack_require__(2649),__webpack_require__(8694),__webpack_require__(2509),__webpack_require__(5640),__webpack_require__(5151),__webpack_require__(507),__webpack_require__(7862),__webpack_require__(356),__webpack_require__(3531),__webpack_require__(6889),__webpack_require__(7763),__webpack_require__(5470),__webpack_require__(7613),__webpack_require__(3230),__webpack_require__(8726),__webpack_require__(8695),__webpack_require__(8168),__webpack_require__(1553),__webpack_require__(2025),__webpack_require__(5),__webpack_require__(159),__webpack_require__(385),__webpack_require__(1790),__webpack_require__(900),__webpack_require__(5435),__webpack_require__(9929),__webpack_require__(235),__webpack_require__(6707),__webpack_require__(8233),__webpack_require__(6999),__webpack_require__(9681),__webpack_require__(9127),__webpack_require__(801),__webpack_require__(9211),__webpack_require__(9413),__webpack_require__(6716),__webpack_require__(3675),__webpack_require__(5144),__webpack_require__(8),__webpack_require__(1362),__webpack_require__(9174),__webpack_require__(841),__webpack_require__(3425),__webpack_require__(1517),__webpack_require__(6868),__webpack_require__(4559),__webpack_require__(1701),__webpack_require__(7879),__webpack_require__(864),__webpack_require__(8080),__webpack_require__(6136),__webpack_require__(3723),__webpack_require__(6842),__webpack_require__(2596),__webpack_require__(7542),__webpack_require__(8721),__webpack_require__(7684),__webpack_require__(6427),__webpack_require__(9443),__webpack_require__(8084),__webpack_require__(5100);var t={tabIndices:{ViewWorks:"1",GameWorks:"1",NatureWorks:"1",sketcher:"4"},zIndices:{ViewWorks:"0",NatureWorks:"0",sketcher:"2",colorSelector:"3",matcaps:"4"},appWorks:null,shaders:null,sunLight:null,TEXTURE_MAPS:["map","matcap","alphaMap","bumpMap","normalMap","displacementMap","roughnessMap","metalnessMap","specularMap","envMap","lightMap","aoMap","emissiveMap","gradientMap"],WORLD_SIZE:1e3,GRID_SPACING:5,GROUND_HEIGHT:0,WATER_HEIGHT:0,WATER_COLOR:7695,OCEAN_COLOR:139053,FOG_COLOR:14014425,SUN_COLOR:16777215};t.Timer={unit:"sec",startTime:0,endTime:0,msg:"",start:function(e){this.msg=e,this.startTime=performance.now()},end:function(){this.endTime=performance.now();var e=this.endTime-this.startTime;"sec"===this.unit&&(e*=.001),console.log(">> time ("+this.msg+") = "+e.toFixed(2)+" ("+this.unit+")")},setUnit:function(e){this.unit=e}};var n,r,o,a,i,s,l,c=__webpack_require__(2865);t.clock=new THREE.Clock,t.getDeltaTime=function(){return t.clock.getDelta()},t.getCurrentTime=function(){return t.clock.getElapsedTime()},t.humanFileSize=function(e,t,n,r,o){return(t=Math,n=t.log,1e3,o=n(e)/n(1e3)|0,e/t.pow(1e3,o)).toFixed(2)+" "+(o?"KMGTPEZY"[--o]+"B":"Bytes")},t.isDeviceMobile=function(){var e=!1;return/Mobi|Android|webOS|Tablet|iPad|iPhone|iPod|Windows Phone|BlackBerry|BB10|Opera Mini/i.test(navigator.userAgent)&&(e=!0),e},t.isDeviceLandscape=function(){return 90===window.orientation||-90===window.orientation},t.isDeviceTouch=function(){return"ontouchend"in window},t.isDeviceWindowsOS=function(){return navigator.platform.toUpperCase().indexOf("WIN32")>=0},t.isDeviceMacOS=function(){return navigator.platform.toUpperCase().indexOf("MAC")>=0},t.isDeviceiOS=function(){return/iPad|iPhone|iPod/g.test(navigator.userAgent)&&!window.MSStream},t.isWebGL1Available=function(){var e=document.createElement("canvas");return!(!window.WebGLRenderingContext||!e.getContext("webgl")&&!e.getContext("experimental-webgl"))},t.isWebGL2Available=function(){var e=document.createElement("canvas");return!(!window.WebGL2RenderingContext||!e.getContext("webgl2"))},t.isWebGL1=function(){var e=t.appWorks.renderer.getContext();return void 0!==e&&e instanceof window.WebGLRenderingContext},t.isWebGL2=function(){var e=t.appWorks.renderer.getContext();return void 0!==e&&e instanceof window.WebGL2RenderingContext},t.getWebGLInfo=function(){var e=[],n="WebGL1: "+(t.isWebGL1Available()?"available":"unavailable");e.push(n);var r="WebGL2: "+(t.isWebGL2Available()?"available":"unavailable");e.push(r);var o=t.appWorks.renderer.getContext().getSupportedExtensions();return e=e.concat(o)},t.isWebGLExtensionAvailable=function(e){return t.appWorks.renderer.getContext().getSupportedExtensions().indexOf(e)>=0},Number.prototype.format=function(){return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1,")},String.prototype.trunc=function(e,t){if(this.length<=e)return(" "+this).slice(1);var n=this.substr(0,e);return(t?n.substr(0,n.lastIndexOf(" ")+1):n)+"..."},Array.prototype.clone=function(){return this.map((e=>Array.isArray(e)?e.clone():e))},Array.prototype.remove=function(e,t){var n=this.slice((t||e)+1||this.length);return this.length=e<0?this.length+e:e,this.push.apply(this,n)},Array.prototype.sum=function(){return this.reduce((function(e,t){return e+Number(t)}),0)},Array.prototype.average=function(){return this.sum()/(this.length||1)},Array.prototype.mean=function(){return this.sum()/(this.length||1)},Array.prototype.median=function(){var e=this.slice(0).sort(((e,t)=>e-t)),t=e.length/2;return t%1?e[t-.5]:(e[t-1]+e[t])/2},Array.prototype.variance=function(){var e=this.mean();return this.map((t=>Math.pow(t-e,2))).mean()},Array.prototype.std=function(){return Math.sqrt(this.variance())},Array.prototype.zscores=function(){var e=this.mean(),t=this.std();return this.map((n=>(n-e)/t))},Array.prototype.range=function(){return this.max()-this.min()},Array.prototype.zero=function(e){for(var t=0;t<e;t++)this[t]=0;return this},Array.prototype.scale=function(e){return this.map((t=>t*e))},Array.prototype.add=function(e){return this.map(((t,n)=>t+e[n]))},Array.prototype.sub=function(e){return this.map(((t,n)=>t-e[n]))},Array.prototype.mul=function(e){return this.map(((t,n)=>t*e[n]))},Array.prototype.div=function(e){return this.map(((t,n)=>t/e[n]))},Array.prototype.dot=function(e){return this.map(((t,n)=>t*e[n])).reduce(((e,t)=>e+t))},Array.prototype.norm2=function(){return Math.sqrt(this.map(((e,t)=>e*e)).reduce(((e,t)=>e+t)))},Array.prototype.transpose=function(){var e=this;return e[0].map((function(t,n){return e.map((function(e,t){return e[n]}))}))},Array.prototype.mmul=function(e){return this.map((function(t,n){return e.transpose().map((function(e,n){return t.dot(e)}))}))},Array.prototype.vmul=function(e){return this.map((function(t,n){return t.dot(e)}))},Array.prototype.sortNumbers=function(e){return"ascending"===(e=e||"ascending")?this.sort(((e,t)=>e-t)):"descending"===e&&this.sort(((e,t)=>t-e)),this},Array.prototype.minX=function(){return this.reduce(((e,t)=>t.x<e?t.x:e),this[0].x)},Array.prototype.maxX=function(){return this.reduce(((e,t)=>t.x>e?t.x:e),this[0].x)},Array.prototype.minY=function(){return this.reduce(((e,t)=>t.y<e?t.y:e),this[0].y)},Array.prototype.maxY=function(){return this.reduce(((e,t)=>t.y>e?t.y:e),this[0].y)},Array.prototype.minZ=function(){return this.reduce(((e,t)=>t.z<e?t.z:e),this[0].z)},Array.prototype.maxZ=function(){return this.reduce(((e,t)=>t.z>e?t.z:e),this[0].z)},Array.prototype.min=function(){return this.reduce(((e,t)=>t<e?t:e),this[0])},Array.prototype.max=function(){return this.reduce(((e,t)=>t>e?t:e),this[0])},Array.prototype.householder=function(){function e(e,t=(e=>e)){return Array.from(Array(e),((e,n)=>t(n)))}function t(e,t=(e=>e)){return e.reduce(((e,n,r)=>e+t(n,r)),0)}const n=Math.sqrt(this.length),r=Array.from(this);console.assert(Number.isInteger(n));const o=(e,t)=>t*n+e;for(let a=0;a<n-2;a++){if(Math.abs(r[o(a,a+1)])<Number.EPSILON)continue;const i=e(n,(e=>e<=a?0:r[o(a,e)])),s=Math.sign(i[a+1])*Math.hypot(...i);i[a+1]+=s;const l=Math.sqrt(2*s*i[a+1]),c=i.map((e=>e/l)),f=e(n,(e=>t(c,((t,n)=>t*r[o(n,e)])))),u=e(n,(e=>t(c,((t,n)=>t*r[o(e,n)])))),d=t(f,((e,t)=>e*c[t])),p=t(u,((e,t)=>e*c[t])),h=f.map(((e,t)=>2*(e-d*c[t]))),v=u.map(((e,t)=>2*(e-p*c[t])));for(let e=0;e<n;e++)for(let t=0;t<n;t++)r[o(t,e)]-=c[e]*v[t]+c[t]*h[e]}return r},Array.prototype.qr=function(){function e(e,t=(e=>e)){return e.reduce(((e,n,r)=>e+t(n,r)),0)}const t=Math.sqrt(this.length),n=Array.from(this);console.assert(Number.isInteger(t));const r=(e,n)=>n*t+e;let o=t;for(;o>=2;){if(Math.abs(n[r(o-2,o-1)])<Number.EPSILON){o--;continue}const t=n[r(o-1,o-1)],a=n[r(o-2,o-1)],i=n[r(o-1,o-2)],s=n[r(o-2,o-2)],l=t*s,c=t*s-a*i,f=Math.sqrt(l*l-4*c)||0,u=(l+f)/2,d=(l-f)/2,p=t-(Math.abs(u)<Math.abs(d)?u:d);for(let e=0;e<o;e++)n[r(e,e)]-=p;const h=(e,t)=>t*o+e,v=Array(o*o).fill(0);for(let e=0;e<o;e++)v[h(e,e)]=1;for(let e=0;e<o-1;e++){const t=n[r(e,e)],a=n[r(e,e+1)],i=Math.hypot(t,a),s=i<Number.EPSILON?0:t/i,l=i<Number.EPSILON?0:a/i;n[r(e,e)]=i,n[r(e,e+1)]=0;for(let t=e+1;t<o;t++){const o=n[r(t,e)],a=n[r(t,e+1)];n[r(t,e)]=o*s+a*l,n[r(t,e+1)]=a*s-o*l}for(let t=0;t<o;t++){const n=v[h(e,t)],r=v[h(e+1,t)];v[h(e,t)]=n*s+r*l,v[h(e+1,t)]=r*s-n*l}}for(let t=0;t<o;t++){const a=Array.from(Array(o-t),((e,o)=>n[r(t+o,t)]));for(let i=0;i<o;i++)n[r(i,t)]=e(a,((e,n)=>e*v[h(i,n+t)]))}for(let e=0;e<o;e++)n[r(e,e)]+=p}return n},Array.prototype.eigenvalues=function(){const e=this.householder().qr(),t=Math.sqrt(e.length);return function(e,t=(e=>e)){return Array.from(Array(e),((e,n)=>t(n)))}(t,(n=>e[n*t+n]))},t.concatTypedArrays=function(e,...t){const n=new e(t.reduce(((e,t)=>e+t.length),0));return t.reduce(((e,t)=>(n.set(t,e),e+t.length)),0),n},t.fromTypedArray=function(e){return[].slice.call(e)},t.fillArray=function(e,t){for(var n=[],r=t;r--;)n[r]=e;return n},t.flattenArray=function(e){return e.reduce((function(e,n){return e.concat(Array.isArray(n)?t.flattenArray(n):n)}),[])},t.flattenVector2s=function(e,t){void 0===t&&(t=[]);for(var n=0,r=e.length;n<r;n++){var o=e[n];t.push(o.x,o.y)}return t},t.flattenVector3s=function(e,t){void 0===t&&(t=[]);for(var n=0,r=e.length;n<r;n++){var o=e[n];t.push(o.x,o.y,o.z)}return t},t.flattenVector4s=function(e,t){void 0===t&&(t=[]);for(var n=0,r=e.length;n<r;n++){var o=e[n];t.push(o.x,o.y,o.z,o.w)}return t},t.mergeArray3=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var n,r={},o=[],a={},i=0,s=e.length;i<s;i++)a.x=e[i][0],a.y=e[i][1],a.z=e[i][2],void 0===r[n=Math.round(a.x*t)+"_"+Math.round(a.y*t)+"_"+Math.round(a.z*t)]&&(r[n]=i,o.push([e[i][0],e[i][1],e[i][2]]));return o.slice(0)},t.mergeArray2=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var n,r={},o=[],a={},i=0,s=e.length;i<s;i++)a.x=e[i][0],a.y=e[i][1],void 0===r[n=Math.round(a.x*t)+"_"+Math.round(a.y*t)]&&(r[n]=i,o.push([e[i][0],e[i][1]]));return o.slice(0)},t.mergeArray=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var n,r={},o=[],a={},i=0,s=e.length;i<s;i++)a.x=e[i],void 0===r[n=Math.round(a.x*t)]&&(r[n]=i,o.push(e[i]));return o.slice(0)},t.mergeVertices=function(e,t){t=void 0!==t?t:4,t=Math.pow(10,t);for(var n,r,o={},a=0,i=e.length;a<i;a++)n=e[a],void 0===o[r=Math.round(n.x*t)+"_"+Math.round(n.y*t)+"_"+Math.round(n.z*t)]&&(o[r]=a,this.push(e[a]));return e.length-this.length},t.toHexValue=function(e,n){return n?"0x"+t.toHexValue(e).toString(16):new THREE.Color(e).getHex()},t.toHexStyle=function(e){return"#"+new THREE.Color(e).getHexString()},t.clamp=function(e,t,n){return Math.max(t,Math.min(n,e))},t.mix=function(e,t,n){return e*(1-n)+t*n},t.lerp=function(e,t,n){return e*(1-n)+t*n},t.smoothstep=function(e,t,n){return n<=e?0:n>=t?1:(n=(n-e)/(t-e))*n*(3-2*n)},t.randInt=function(e,t){return e+Math.floor(Math.random()*(t-e+1))},t.randFloat=function(e,t){return e+Math.random()*(t-e)},t.randFloatSpread=function(e,t){return e+t*(Math.random()-.5)},t.linearRand=function(e,n){return t.randFloat(e,n)},t.gaussRand=function(e,n){var r,o,a;do{r=(o=t.randFloat(-1,1))*o+(a=t.randFloat(-1,1))*a}while(r>1);return a*n*n*Math.sqrt(-2*Math.log(r)/r)+e},t.diskRand=(n=new THREE.Vector2,function(e){var r;do{n.x=t.randFloat(-e,e),n.y=t.randFloat(-e,e),r=n.length()}while(r>e);return n}),t.ballRand=function(){var e=new THREE.Vector3;return function(n){var r;do{e.x=t.randFloat(-n,n),e.y=t.randFloat(-n,n),e.z=t.randFloat(-n,n),r=e.length()}while(r>n);return e}}(),t.circularRand=function(){var e=new THREE.Vector2;return function(n){var r=t.randFloat(0,6.283185307179586);return e.x=n*Math.cos(r),e.y=n*Math.sin(r),e}}(),t.sphericalRand=function(){var e=new THREE.Vector3;return function(n){var r=t.randFloat(-1,1),o=t.randFloat(0,6.283185307179586),a=Math.sqrt(1-r*r),i=a*Math.cos(o),s=a*Math.sin(o);return e.x=i*n,e.y=s*n,e.z=r*n,e}}(),t.createMathRandom=function(e){var t,n=function(e){for(var t=0,n=1779033703^e.length;t<e.length;t++)n=(n=Math.imul(n^e.charCodeAt(t),3432918353))<<13|n>>>19;return function(){return n=Math.imul(n^n>>>16,2246822507),n=Math.imul(n^n>>>13,3266489909),(n^=n>>>16)>>>0}}(e.toString());return t=n(),()=>((t=Math.imul(741103597,t))>>>0)/2**32},t.createRandFloat=function(e){var n=void 0!==e?t.createMathRandom(e):Math.random;return function(e,t){return e+n()*(t-e)}},t.createFbmNoise=function(e){var t=void 0!==(e=e||{}).octaves?e.octaves:4,n=void 0!==e.persistence?e.persistence:.5;switch(void 0!==e.noiseType?e.noiseType:"simplex3d"){case"perlin3d":var r=(new THREE.ImprovedNoise).noise;break;default:var o=new THREE.SimplexNoise;r=o.noise3d.bind(o)}for(var a=new Array(t),i=new Array(t),s=0,l=0;l<t;l++)a[l]=Math.pow(n,l),i[l]=Math.pow(2,l),s+=a[l];return s=1/s,function(e,n,o){for(var i=0,l=0;l<t;l++){var c=1<<l;i+=a[l]*r(e*c,n*c,o*c)}return i*s}},t.fileExist=function(e,t,n){n=void 0!==n&&n,fetch((!0===n?"https://cors-anywhere.herokuapp.com/":"")+e).then((e=>{t&&t("404"!=e.status)})).catch((e=>{t&&t(!1)}))},t.triggerWindowResize=function(){if("function"==typeof Event)window.dispatchEvent(new Event("resize"));else{var e=window.document.createEvent("UIEvents");e.initUIEvent("resize",!0,!1,window,0),window.dispatchEvent(e)}},t.isCtrlKeyDown=function(e){return t.isDeviceMacOS()?e.metaKey:e.ctrlKey},t.escapeHTML=function(e){return e.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")},t.createImageDropZone=function(e,t){return null==e&&((e=document.createElement("img")).style.width="50px",e.style.height="50px",e.style.border="1px solid white"),e.addEventListener("dragover",(function(e){e.preventDefault(),e.stopPropagation(),e.dataTransfer.dropEffect="copy"}),!1),e.addEventListener("drop",(function(e){e.preventDefault(),e.stopPropagation();var n=new FileReader;n.addEventListener("load",(function(e){var n=new Image;n.onload=function(){t(n)},n.src=e.currentTarget.result}),!1),n.readAsDataURL(e.dataTransfer.files[0])}),!1),e},t.setDraggable=function(e){var t=0,n=0,r=0,o=0,a=e.children[0];function i(e){(e=e||window.event).preventDefault(),r=e.clientX,o=e.clientY,document.onmouseup=l,document.onmousemove=s}function s(a){(a=a||window.event).preventDefault(),t=r-a.clientX,n=o-a.clientY,r=a.clientX,o=a.clientY,e.style.top=e.offsetTop-n+"px",e.style.left=e.offsetLeft-t+"px"}function l(){document.onmouseup=null,document.onmousemove=null}a?a.onmousedown=i:e.onmousedown=i},t.removeHTMLElement=function(e){for("string"==typeof e&&(e=document.getElementById(e)),e.parentNode&&e.parentNode.removeChild(e);e.firstChild;)e.removeChild(e.firstChild)},t.createFlashtext=function(e,t){var n,r,o=(t=t||{}).fontSize||"10vw";if(n=document.getElementById("flash-text"))return(r=document.getElementById("flash-style")).innerHTML=r.innerHTML.replace(/font-size:\s\w+\;/,`font-size: ${o};`),n.innerHTML=`\n            <h1 class="flash" data-heading="${e}">${e}</h1>\n        `,void(n.style.display="");(n=document.createElement("div")).id="flash-text",n.innerHTML=`\n        <h1 class="flash" data-heading="${e}">${e}</h1>\n    `,document.body.appendChild(n),(r=document.createElement("style")).id="flash-style",r.innerHTML=`\n        .flash {\n            background: url("images/frozen.jpg");\n            -webkit-background-clip: text;\n            background-size: contain;\n            width: 100%;\n            text-align: center;\n            color: transparent;\n            font-weight: 900;\n\n            top: 50%;\n            left: 50%;\n            -webkit-transform: translate(-50%, -50%);\n                    transform: translate(-50%, -50%);\n            position: absolute;\n            font-size: ${o};\n            margin: 0;\n            font-family: 'frozen', serif;\n        }\n        .flash::before {\n            content: attr(data-heading);\n            position: absolute;\n            left: 0;\n            top: 0;\n            width: 100%;\n            background: linear-gradient(45deg, rgba(255, 255, 255, 0) 45%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 55%, rgba(255, 255, 255, 0) 100%);\n            -webkit-background-clip: text;\n            color: transparent;\n            mix-blend-mode: screen;\n            -webkit-animation: shine 1s infinite;\n                    animation: shine 1s infinite;\n            background-size: 200%;\n            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2), -2px 2px 10px rgba(0, 0, 0, 0.2), -2px -2px 10px rgba(0, 0, 0, 0.2);\n        }\n        @-webkit-keyframes shine {\n            0% {\n                background-position: -100%;\n            }\n            100% {\n                background-position: 100%;\n            }\n        }\n        @keyframes shine {\n            0% {\n                background-position: -100%;\n            }\n            100% {\n                background-position: 100%;\n            }\n        }\n        @font-face {\n            font-family: 'frozen';\n            src: url("fonts/Ice kingdom - Bold - Por Kustren.woff");\n        }\n    `,document.head.appendChild(r)},t.showFlashtext=function(){var e=document.getElementById("flash-text");e&&(e.style.display="")},t.hideFlashtext=function(){var e=document.getElementById("flash-text");e&&(e.style.display="none")},t.removeFlashtext=function(){var e=document.getElementById("flash-text");e&&document.body.removeChild(e);var t=document.getElementById("flash-style");t&&document.head.removeChild(t)},t.createSpincircle=function(){if(e=document.getElementById("spin-circle"))e.style.display="";else{var e;(e=document.createElement("div")).id="spin-circle",e.innerHTML='\n        <div class="spin-wrapper">\n            <div class="spin-text">Computing...</div>\n            <div class="spin"></div>\n        </div>\n    ',document.body.appendChild(e);var t=document.createElement("style");t.id="spin-style",t.innerHTML='\n        .spin-wrapper {\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            color: #888;\n        }\n        .spin-text {\n            position: absolute;\n            left: 50%;\n            top: 50%;\n            transform: translate(-50%, -50%);\n            color: #888;\n        }\n        .spin {\n            position: relative;\n            left: 50%;\n            top: 50%;\n            width: 150px;\n            height: 150px;\n            margin: -75px 0 0 -75px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #3498db;\n            -webkit-animation: spin 2s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 2s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        .spin:before {\n            content: "";\n            position: absolute;\n            top: 5px;\n            left: 5px;\n            right: 5px;\n            bottom: 5px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #e74c3c;\n            -webkit-animation: spin 3s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 3s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        .spin:after {\n            content: "";\n            position: absolute;\n            top: 15px;\n            left: 15px;\n            right: 15px;\n            bottom: 15px;\n            border-radius: 50%;\n            border: 3px solid transparent;\n            border-top-color: #f9c922;\n            -webkit-animation: spin 1.5s linear infinite; /* Chrome, Opera 15+, Safari 5+ */\n            animation: spin 1.5s linear infinite; /* Chrome, Firefox 16+, IE 10+, Opera */\n        }\n        @-webkit-keyframes spin {\n            0%   {\n                -webkit-transform: rotate(0deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(0deg);  /* IE 9 */\n                transform: rotate(0deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n            100% {\n                -webkit-transform: rotate(360deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(360deg);  /* IE 9 */\n                transform: rotate(360deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n        }\n        @keyframes spin {\n            0%   {\n                -webkit-transform: rotate(0deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(0deg);  /* IE 9 */\n                transform: rotate(0deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n            100% {\n                -webkit-transform: rotate(360deg);  /* Chrome, Opera 15+, Safari 3.1+ */\n                -ms-transform: rotate(360deg);  /* IE 9 */\n                transform: rotate(360deg);  /* Firefox 16+, IE 10+, Opera */\n            }\n        }\n    ',document.head.appendChild(t)}},t.showSpincircle=function(){var e=document.getElementById("spin-circle");e&&(e.style.display="")},t.hideSpincircle=function(){var e=document.getElementById("spin-circle");e&&(e.style.display="none")},t.removeSpincircle=function(){var e=document.getElementById("spin-circle");void 0!==e&&document.body.removeChild(e);var t=document.getElementById("spin-style");void 0!==t&&document.head.removeChild(t)},t.createProgressbar=function(){var e;if(e=document.getElementById("progress-box"))return e.style.display="",void(t.getProgressbar().style.width="0%");(e=document.createElement("div")).id="progress-box",e.innerHTML='\n        <div>\n            <div style="color:#888;">Loading...</div>\n            <div class="progress">\n                <div id="progressbar"></div>\n            </div>\n        </div>\n    ',document.body.appendChild(e);var n=document.createElement("style");n.id="progress-style",n.innerHTML="\n        #progress-box {\n            position: absolute;\n            left: 0;\n            top: 0;\n            width: 100%;\n            height: 100%;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            text-align: center;\n            font-size: x-large;\n            font-family: sans-serif;\n        }\n        #progress-box>div>div {\n            padding: 2px;\n        }\n        .progress {\n            width: 50vw;\n            border: 1px solid #888;\n        }\n        #progressbar {\n            width: 0;\n            transition: width ease-out .5s;\n            height: 1em;\n            background-color: #888;\n            background-image: linear-gradient(\n                -45deg, \n                rgba(255, 255, 255, .5) 25%, \n                transparent 25%, \n                transparent 50%, \n                rgba(255, 255, 255, .5) 50%, \n                rgba(255, 255, 255, .5) 75%, \n                transparent 75%, \n                transparent\n            );\n            background-size: 50px 50px;\n            animation: progressanim 2s linear infinite;\n        }\n    ",document.head.appendChild(n)},t.getProgressbar=function(){return document.getElementById("progressbar")},t.updateProgressbar=function(e,n,r){void 0===r&&(r=t.getProgressbar()),r.style.width=(e/n*100|0)+"%"},t.hideProgressbar=function(){var e=document.getElementById("progress-box");e&&(e.style.display="none")},t.showProgressbar=function(){var e=document.getElementById("progress-box");e&&(e.style.display="")},t.errorProgressbar=function(e){console.warn(e)},t.removeProgressbar=function(){var e=document.getElementById("progress-box");void 0!==e&&document.body.removeChild(e);var t=document.getElementById("progress-style");void 0!==t&&document.head.removeChild(t)},t.getDistancePerPixel=function(){var e=t.appWorks.camera;return e.position.length()*Math.tan(e.fov/2*THREE.Math.DEG2RAD)*2*e.aspect/t.appWorks.width},t.getMouseScreenCoords=(r=new THREE.Vector2,function(e){return e.changedTouches?(r.x=e.changedTouches[0].clientX,r.y=e.changedTouches[0].clientY):(r.x=e.clientX,r.y=e.clientY),r}),t.toggleLightHelpers=function(e){t.appWorks.sceneHelpers.children.forEach((function(t){(t instanceof THREE.PointLightHelper||t instanceof THREE.SpotLightHelper||t instanceof THREE.DirectionalLightHelper||t instanceof THREE.HemisphereLightHelper)&&(t.visible=void 0!==e?e:!t.visible)}))},t.createSpritesHUD=function(e,n,r,o,a){var i;i=e.isTexture?new THREE.SpriteMaterial({map:e,transparent:!0,depthTest:!1}):!0===e.isSpriteMaterial?e:new THREE.SpriteMaterial({color:16777215,transparent:!0,depthTest:!1});var s=new THREE.Sprite(i);s.center.set(.5,.5),s.scale.set(o,a,1),s.name="spritesHUD";var l=t.appWorks.cameraHUD;return s.position.x=l.left+o/2+n,s.position.y=l.bottom+a/2+r,s},t.createTextHUD=function(e,n,r,o,a,i){!1===Array.isArray(e)&&(e=[e]);n=n||0,r=r||0;var s,l=-1;e.forEach(((e,t)=>{e.length>l&&(l=e.length,s=t)}));var c=document.createElement("canvas"),f=c.getContext("2d");f.font="Normal 20px Arial",c.width=f.measureText(e[s]).width,f.font="Normal 20px Arial";var u=1.2*f.measureText("M").width;c.height=u*e.length*1.2;o=o||c.width,a=a||c.height;var d=new THREE.CanvasTexture(f.canvas),p=new THREE.MeshBasicMaterial({map:d,transparent:!0,depthTest:!1}),h=new THREE.PlaneBufferGeometry(o,a),v=new THREE.Mesh(h,p);v.name="textHUD";var m=t.appWorks.cameraHUD;v.position.x=m.left+o/2+n,v.position.y=m.bottom+a/2+r,!0===i&&(v.userData.context2D=f,v.userData.texts=e,v.userData.lineHeight=u),f.font="Normal 20px Arial",f.textAlign="left",f.fillStyle="rgba(255,255,255,1.0)",f.clear();r=u;return e.forEach((e=>{f.fillText(e,0,r),r+=u})),d.needsUpdate=!0,v},t.createRenderTargetHUD=function(e,n,r,o,a,i){n=n||0,r=r||0,o=o||t.appWorks.width,a=a||t.appWorks.height;var s=e.clone(),l=new THREE.Scene;l.add(s),l.add(t.createHemisphereLight()),l.background=t.appWorks.scene.background;var c=t.appWorks.camera.clone();t.fitCameraToObject(s,c);var f=new THREE.WebGLRenderTarget(t.appWorks.width,t.appWorks.height),u=t.appWorks.renderer;u.setRenderTarget(f),u.render(l,c);var d=new THREE.MeshBasicMaterial({map:f.texture}),p=new THREE.PlaneBufferGeometry(o,a),h=new THREE.Mesh(p,d);h.name="renderTargetHUD";var v=t.appWorks.cameraHUD;return h.position.x=v.left+o/2+n,h.position.y=v.bottom+a/2+r,!0===i&&(h.userData.renderTarget=f,h.userData.rtScene=l,h.userData.rtCamera=c),h},t.computeBoundingBox=function(e){return(new THREE.Box3).setFromObject(e)},t.computeBoundingSphere=function(){var e,t,n,r=new THREE.Vector3;function o(o){var a=o.geometry;if(void 0!==a)if(a.isGeometry){var i=a.vertices;for(t=0,n=i.length;t<n;t++)r.copy(i[t]),r.applyMatrix4(o.matrixWorld),e.push(r.clone())}else if(a.isBufferGeometry){var s;if(void 0!==(s=a.attributes.instancePosition?a.attributes.instancePosition:a.attributes.position))for(t=0,n=s.count;t<n;t++)r.fromBufferAttribute(s,t),r.applyMatrix4(o.matrixWorld),e.push(r.clone())}}return function(t){return e=[],t.updateMatrixWorld(!0),t.traverse(o),e.length>0?(new THREE.Sphere).setFromPoints(e):void 0}}(),t.getObjectName=function(e,t){t=void 0!==t?t:"";if(Array.isArray(e)){for(var n=[],r=0;r<e.length;r++)n.push(""===e[r].name?t:e[r].name);return n.join(", ").trunc(20)}return(void 0===e.name?t:e.name).trunc(20)},t.getObjectSize=(o=new THREE.Vector3,function(e){return t.computeBoundingBox(e).getSize(o),Math.max(o.x,o.y,o.z)}),t.resizeObject=function(e,n){if(n){var r=t.getObjectSize(e);e.scale.setScalar(n/r)}},t.transformObject=function(e,t,n,r){t&&e.position.set(t.x,t.y,t.z),n&&e.rotation.set(n.x,n.y,n.z),r&&e.scale.set(r.x,r.y,r.z),e.updateMatrix()},t.copyTransform=function(e,n){var r=n.position,o=n.rotation,a=n.scale;t.transformObject(e,r,o,a)},t.cloneObject=function(e){return void 0!==e.userData.type?new t[e.userData.type](e):e.clone()},t.traverseMaterials=function(e,t){e.traverse((e=>{if(!e.isMesh)return;(Array.isArray(e.material)?e.material:[e.material]).forEach(t)}))},t.updateMaterialMapEncoding=function(e,n){n=n||THREE.sRGBEncoding,t.traverseMaterials(e,(e=>{e.map&&(e.map.encoding=n),e.emissiveMap&&(e.emissiveMap.encoding=n),(e.map||e.emissiveMap)&&(e.needsUpdate=!0)}))},t.underWaterBackground=function(){void 0!==t.appWorks.underWaterPass&&(t.appWorks.underWaterPass.enabled=!0),t.appWorks.createSceneBackground("underWater"),t.appWorks.scene.fog||t.appWorks.createSceneFog({type:"exp2",color:594516,density:.004}),t.appWorks.renderer.toneMappingExposure=.7},t.filmGrainBackground=function(){var e=t.appWorks.width,n=t.appWorks.height,r={aspect:t.appWorks.camera.aspect,aspectCorrection:!0,grainScale:1.5/Math.min(e,n),color1:16777215,color2:3487029,noiseAlpha:.75};(new THREE.TextureLoader).load("images/wallpaper/arctic.jpg",(function(e){t.imageProcessing(e,"FilmGrainShader",r,(function(e){t.appWorks.scene.background=e}))}))},t.redColors=(a=[16752762,16416882,15308410,15761536,13458524,14423100,11674146,16711680,9109504,8388608,16737095,16729344,14381203],function(e){return a[e%a.length]}),t.greenColors=(i=[8190976,8388352,3329330,65280,2263842,32768,25600,11403055,10145074,65407,64154,9498256,10025880,9419919,3978097,2142890,3050327,526336,5597999,7048739],function(e){return i[e%i.length]}),t.blueColors=(s=[4744096,2839678,2832470,1383252,128,1388926,1383309,160,8386,16834,2446535,1403335,2842846,2049532,2844140,3174143,1411583,6723839,3914239],function(e){return s[e%s.length]}),t.randomColors=function(e){if((e=e||{}).colors)return e.colors;var n,r,o,a=void 0!==e.numInstances?Math.floor(e.numInstances):1,i=void 0!==e.colorMode?e.colorMode:"none",s=new THREE.Color,l=[];if("0"===i)for(var c=0;c<a;c++)n=Math.random(),r=Math.random(),o=Math.random(),s.setHSL(n,r,o),l.push(s.r,s.g,s.b);else if("1"===i)for(c=0;c<a;c++)n=Math.random(),r=.5,o=.5,s.setHSL(n,r,o),l.push(s.r,s.g,s.b);else if("2"===i)for(c=0;c<a;c++)n=Math.random(),r=1,o=.5,s.setHSL(n,r,o),l.push(s.r,s.g,s.b);else if("reds"===i)for(c=0;c<a;c++)s.setHex(t.redColors(c)),l.push(s.r,s.g,s.b);else if("greens"===i)for(c=0;c<a;c++)s.setHex(t.greenColors(c)),l.push(s.r,s.g,s.b);else if("blues"===i)for(c=0;c<a;c++)s.setHex(t.blueColors(c)),l.push(s.r,s.g,s.b);return l},t.cameraAutoView=function(e){if((e=e||{}).isWorking)return"stop"!==l;if("circle"===(l=e.viewMode||"circle")){var n=e.radius||20,r=new THREE.CircleBufferGeometry(n,32),o=new THREE.Mesh(r);o.name="cameraPath",o.visible=!1,t.add(o),o.add(t.appWorks.camera),o.update=function(){this.rotation.y+=.003}}else if("stop"===l){var a=t.appWorks.camera.parent;a&&"cameraPath"===a.name&&(a.remove(t.appWorks.camera),t.appWorks.camera.parent=null)}},t.fitCameraToObject=function(e,n,r){if(e){n=void 0!==n?n:t.appWorks.camera,r=void 0===r||r;var o=new THREE.Vector3,a=new THREE.Vector3,i=t.computeBoundingBox(e);i.getSize(a);var s=e.position.clone();!0===r?(i.getCenter(o),s.sub(o),o.set(0,0,0)):o.copy(s);var l=n.fov*THREE.Math.DEG2RAD,c=Math.max(a.x,a.y,a.z),f=Math.abs(c/2/Math.tan(l/2));if(f*=1.25,n===t.appWorks.camera){var u=t.appWorks.controls;u instanceof THREE.OrbitControls?(u.reset(),u.maxDistance=100*f,u.saveState()):u instanceof THREE.TrackballControls&&(u.reset(),u.maxDistance=100*f)}var d=n.position.clone();d.normalize().multiplyScalar(f),n.lookAt(o);var p=f/100,h=100*f;if(t.appWorks.history&&n===t.appWorks.camera){var v=[];r&&v.push(new t.SetPositionCommand(e,s)),v.push(new t.SetPositionCommand(n,d)),v.push(new t.SetValueCommand(n,"near",p)),v.push(new t.SetValueCommand(n,"far",h)),t.appWorks.multiCmds(v)}else r&&e.position.copy(s),n.position.copy(d),n.near=p,n.far=h;n.updateProjectionMatrix()}},t.welcomeObject=function(e){if(e.traverse((function(e){e.isMesh&&(e.frustumCulled=!1,e.castShadow=!0,e.receiveShadow=!0)})),"NatureWorks"===t.appWorks.appName)t.fitCameraToObject(e);else if("ViewWorks"===t.appWorks.appName){t.resizeObject(e,1),t.fitCameraToObject(e),t.appWorks.selectObject=e;var n=t.appWorks.scene.getObjectByName("showroom");void 0===n&&(n=t.createShowroom(e),t.add(n))}},t.nextShowroom=function(e,n){if(n||(n=t.appWorks.scene.getObjectByName("showroom")),"background"===e){(o=n.getObjectByName("raymarch"))&&n.remove(o),a=((a=n.activeBackground)+1)%n.backgrounds.length,n.activeBackground=a;var r=n.backgrounds[a];r.isMesh?(t.appWorks.scene.background=null,n.add(r)):t.appWorks.scene.background=r}if("floor"===e){var o,a;(o=n.getObjectByName("floor"))&&n.remove(o),a=((a=n.activeFloor)+1)%n.floors.length,n.activeFloor=a;var i=n.floors[a];n.add(i)}},t.createShowroom=function(e){var n=new THREE.Object3D;n.name="showroom",n.activeBackground=-1,n.backgrounds=[];var r=["arctic","burlesque","denim","mercury","neo","origin","rouge","slate"];r.forEach((e=>{var r=(new THREE.TextureLoader).load("images/wallpaper/"+e+".jpg");r.encoding=THREE.sRGBEncoding,n.backgrounds.push(t.createBackground(r))})),(r=["blueSky","cloud","galaxy","lake","bridge","park"]).forEach((e=>{n.backgrounds.push(t.createBackground(e))})),(r=["cloudsFS","cellsFS","fogFS","sunsetFS"]).forEach((e=>{var r=t.createBackground(e);r.name="raymarch",n.backgrounds.push(r)})),n.backgrounds.push(t.createBackground(12632256)),n.activeFloor=-1,n.floors=[];var o=new THREE.TextureLoader,a=t.computeBoundingBox(e),i=a.min.y,s=a.getSize(new THREE.Vector3),l=4*(s=Math.max(s.x,s.y,s.z));function c(e,t){t=t||8;e.repeat.set(t,t),e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping}(p=t.createAcrylicCircle(l)).rotation.x=-Math.PI/2,p.position.y=i,p.name="floor",n.floors.push(p);var f=[];f.push({map:o.load("images/rock/crackRockDiffuse.jpg",c),normalMap:o.load("images/rock/crackRockNormal.jpg",c),aoMap:o.load("images/rock/crackRockAO.jpg",c)}),f.push({color:11184810,roughness:1,metalness:0,map:o.load("images/pbr/wallA.png",c),normalMap:o.load("images/pbr/wallN.png",c),aoMap:o.load("images/pbr/wallAO.png",c),roughnessMap:o.load("images/pbr/wallR.png",c)}),f.push({roughness:1,metalness:0,map:o.load("images/pbr/bathroomtileA.png",c),normalMap:o.load("images/pbr/bathroomtileN.png",c),aoMap:o.load("images/pbr/bathroomtileAO.png",c),roughnessMap:o.load("images/pbr/bathroomtileR.png",c)}),f.push({roughness:1,metalness:0,map:o.load("images/pbr/charcoalA.png",c),normalMap:o.load("images/pbr/charcoalN.png",c),roughnessMap:o.load("images/pbr/charcoalR.png",c)}),f.push({color:11184810,roughness:1,metalness:0,map:o.load("images/pbr/grassA.png",c),normalMap:o.load("images/pbr/grassN.png",c),aoMap:o.load("images/pbr/grassAO.png",c),roughnessMap:o.load("images/pbr/grassR.png",c)}),f.push({color:8947848,roughness:.5,metalness:.5,map:o.load("images/pbr/rustIronA.png",(e=>c(e,2))),normalMap:o.load("images/pbr/rustIronN.png",(e=>c(e,2))),aoMap:o.load("images/pbr/rustIronAO.png",(e=>c(e,2))),roughnessMap:o.load("images/pbr/rustIronR.png",(e=>c(e,2))),metalnessMap:o.load("images/pbr/rustIronM.png",(e=>c(e,2)))});for(var u=new THREE.CircleBufferGeometry(l,64),d=0;d<f.length;d++){var p,h=new THREE.MeshStandardMaterial(f[d]);(p=new THREE.Mesh(u,h)).receiveShadow=!0,p.rotation.x=-Math.PI/2,p.position.y=i,p.name="floor",n.floors.push(p)}t.nextShowroom("background",n),t.nextShowroom("floor",n),t.add(t.createHemisphereLight());var v=t.createDirectionalLight({shadowCameraSize:.5*l});return v.position.set(0,.75*l,.5*l),t.add(v),n},t.manhatten2D=function(e,t){return Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)},t.manhatten3D=function(e,t){return Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)+Math.pow(e[2]-t[2],2)},t.createKdTree=function(e,n,r){var o=e[0];Array.isArray(o)?e=t.flattenArray(e):o instanceof THREE.Vector2?e=t.flattenVector2s(e):o instanceof THREE.Vector3?e=t.flattenVector3s(e):o instanceof THREE.Vector4&&(e=t.flattenVector4s(e)),e=new Float32Array(e);r=r||2===n?t.manhatten2D:t.manhatten3D;return new THREE.TypedArrayUtils.Kdtree(e,r,n)},t.getKdTreeNearest=function(e,t,n,r){for(var o=e.nearest(t,n,r),a=[],i=0,s=o.length;i<s;i++){var l=o[i],c={};c.position=l[0].obj,c.index=l[0].pos,c.distance=l[1],a.push(c)}return a},t.OctreeHelper=function(e,n){if(!e instanceof c.PointOctree)return null;var r=(n=n||{}).leaves||!1,o=n.color||16777215,a=[],i=[];if(r){i=t.getLeafOctants(e,!0)}else{var s=n.topLevel||0,l=n.bottomLevel||e.getDepth();i=t.getOctantsByLevels(e,s,l)}i.forEach((function(e){var t=new THREE.Box3(e.min,e.max),n=new THREE.Box3Helper(t);n.updateMatrixWorld(!0),n.geometry.applyMatrix4(n.matrixWorld),a.push(n.geometry)}));var f=THREE.BufferGeometryUtils.mergeBufferGeometries(a),u=new THREE.LineBasicMaterial({color:o});THREE.LineSegments.call(this,f,u),this.name="octreeHelper",a.forEach((function(e){e.dispose()}))},t.OctreeHelper.prototype=Object.create(THREE.LineSegments.prototype),t.OctreeHelper.prototype.constructor=t.OctreeHelper,t.getOctantsByLevels=function(e,t,n){for(var r=[];t<=n;){var o=e.findNodesByLevel(t)[Symbol.iterator]();if(o)for(var a=o.next();!a.done;)r.push(a.value),a=o.next();t++}return r},t.getLeafOctants=function(e,t){var n=[],r=e.leaves(),o=r.next();if(t=t||!0)for(;!o.done;)o.value.points&&n.push(o.value),o=r.next();else for(;!o.done;)n.push(o.value),o=r.next();return n},CanvasRenderingContext2D.prototype.clear=function(e){e&&(this.beginPath(),this.save(),this.setTransform(1,0,0,1,0,0)),this.clearRect(0,0,this.canvas.width,this.canvas.height),e&&this.restore()},CanvasRenderingContext2D.prototype.circle=function(e,t,n){return this.beginPath(),this.moveTo(e+n,t),this.arc(e,t,n,0,2*Math.PI),this},CanvasRenderingContext2D.prototype.fillCircle=function(e,t,n,r){return r&&(this.fillStyle=r),this.circle(e,t,n).fill(),this},CanvasRenderingContext2D.prototype.strokeCircle=function(e,t,n,r){return r&&(this.strokeStyle=r),this.circle(e,t,n).stroke(),this},CanvasRenderingContext2D.prototype.roundRect=function(e,t,n,r,o){var a={tl:0,tr:0,bl:0,br:0};if("object"==typeof o)for(var i in o)a[i]=o[i];if("number"==typeof o)for(var i in a)a[i]=o;return this.beginPath(),this.moveTo(e+a.tl,t),this.lineTo(e+n-a.tr,t),this.quadraticCurveTo(e+n,t,e+n,t+a.tr),this.lineTo(e+n,t+r-a.br),this.quadraticCurveTo(e+n,t+r,e+n-a.br,t+r),this.lineTo(e+a.bl,t+r),this.quadraticCurveTo(e,t+r,e,t+r-a.bl),this.lineTo(e,t+a.tl),this.quadraticCurveTo(e,t,e+a.tl,t),this.closePath(),this},CanvasRenderingContext2D.prototype.fillRoundRect=function(e,t,n,r,o,a){return a&&(this.fillStyle=a),this.roundRect(e,t,n,r,o).fill(),this},CanvasRenderingContext2D.prototype.strokeRoundRect=function(e,t,n,r,o,a){return a&&(this.strokeStyle=a),this.roundRect(e,t,n,r,o).stroke(),this},CanvasRenderingContext2D.prototype.polygon=function(e,t){t>0&&(e=function(e,t){function n(e,t,n,r,o,a){var i=Math.sqrt(Math.pow(n-e,2)+Math.pow(r-t,2)),s=a?o/i:(i-o)/i;return[e+s*(n-e),t+s*(r-t)]}var r,o,a,i,s,l,c,f,u=e.length,d=new Array(u);for(o=0;o<u;o++)(r=o-1)<0&&(r=u-1),(a=o+1)==u&&(a=0),i=e[r],s=e[o],l=e[a],c=n(i[0],i[1],s[0],s[1],t,!1),f=n(s[0],s[1],l[0],l[1],t,!0),d[o]=[c[0],c[1],s[0],s[1],f[0],f[1]];return d}(e,t)),this.beginPath();for(var n=0,r=e.length;n<r;n++){var o=e[n];0==n?this.moveTo(o[0],o[1]):this.lineTo(o[0],o[1]),t>0&&this.quadraticCurveTo(o[2],o[3],o[4],o[5])}return this.closePath(),this},CanvasRenderingContext2D.prototype.fillPolygon=function(e,t,n){return n&&(this.fillStyle=n),this.polygon(e,t).fill(),this},CanvasRenderingContext2D.prototype.strokePolygon=function(e,t,n){return n&&(this.strokeStyle=n),this.polygon(e,t).stroke(),this},CanvasRenderingContext2D.prototype.speechBubble=function(e,t,n,r,o,a,i,s){e=e||0,n=n||1,r=r||1,o=o||.2*r,a=a||e+n/2,s=s||o;var l,c,f,u=e+n,d=(t=t||0)+r;return(i=i||t+r+o)<t||i>t+r?(l=Math.min(Math.max(e+o,a-s/2),u-o-s),c=Math.min(Math.max(e+o+s,a+s/2),u-o)):(l=Math.min(Math.max(t+o,i-s/2),d-o-s),c=Math.min(Math.max(t+o+s,i+s/2),d-o)),i<t&&(f=2),i>t&&(f=3),a<e&&i>=t&&i<=d&&(f=0),a>e&&i>=t&&i<=d&&(f=1),a>=e&&a<=u&&i>=t&&i<=d&&(f=-1),this.beginPath(),this.moveTo(e+o,t),2==f?(this.lineTo(l,t),this.lineTo(a,i),this.lineTo(c,t),this.lineTo(u-o,t)):this.lineTo(u-o,t),this.quadraticCurveTo(u,t,u,t+o),1==f?(this.lineTo(u,l),this.lineTo(a,i),this.lineTo(u,c),this.lineTo(u,d-o)):this.lineTo(u,d-o),this.quadraticCurveTo(u,d,u-o,d),3==f?(this.lineTo(c,d),this.lineTo(a,i),this.lineTo(l,d),this.lineTo(e+o,d)):this.lineTo(e+o,d),this.quadraticCurveTo(e,d,e,d-o),0==f?(this.lineTo(e,c),this.lineTo(a,i),this.lineTo(e,l),this.lineTo(e,t+o)):this.lineTo(e,t+o),this.quadraticCurveTo(e,t,e+o,t),this.closePath(),this},CanvasRenderingContext2D.prototype.fillSpeechBubble=function(e,t,n,r,o,a,i,s,l){return l&&(this.fillStyle=l),this.speechBubble(e,t,n,r,o,a,i,s).fill(),this},CanvasRenderingContext2D.prototype.strokeSpeechBubble=function(e,t,n,r,o,a,i,s,l){return l&&(this.strokeStyle=l),this.speechBubble(e,t,n,r,o,a,i,s).stroke(),this},t.createFaceVertexUVs=function(e){!e instanceof THREE.Geometry||(e.faceVertexUvs[0]=[],e.faces.forEach((function(t){var n=["x","y","z"].sort((function(e,n){return Math.abs(t.normal[e])>Math.abs(t.normal[n])})),r=e.vertices[t.a],o=e.vertices[t.b],a=e.vertices[t.c];e.faceVertexUvs[0].push([new THREE.Vector2(r[n[0]],r[n[1]]),new THREE.Vector2(o[n[0]],o[n[1]]),new THREE.Vector2(a[n[0]],a[n[1]])])})),e.uvsNeedUpdate=!0)},t.loadObject3D=function(e){const n=["position","rotation","quaternion","scale"];var r=Array.isArray(e)?e:[e];return r.forEach((e=>{void 0===e.object?e.object={type:"Mesh"}:void 0===e.object.type&&(e.object.type="Mesh")})),function(t){const r=[];return t.forEach((e=>{r.push(function(e){var t=e.object;if(e.url){const t=[o(e.url)];return Promise.all(t).then((t=>(t[0].name=e.url,t[0])))}if("Sprite"===t.type){const t=[i(e.material)];return Promise.all(t).then((e=>new THREE.Sprite(e[0])))}if("Points"===t.type||"Mesh"===t.type||"SkinnedMesh"===t.type||"Line"===t.type||"LineLoop"===t.type||"LineSegments"===t.type){const n=[a(e.geometry),i(e.material)];return Promise.all(n).then((e=>new THREE[t.type](e[0],e[1])))}return Promise.resolve(void 0)}(e))})),Promise.all(r).then((r=>(r.forEach(((e,r)=>{var o=t[r].object;Object.keys(o).map((t=>{"type"===t||(-1!==n.indexOf(t)?e[t].fromArray(o[t]):e[t]="userData"===t?JSON.parse(JSON.stringify(o[t])):"customDepthMaterial"===t||"customDistanceMaterial"===t?o[t].clone():o[t])}))})),Array.isArray(e)?Promise.resolve(r):Promise.resolve(r[0]))))}(r);function o(e){return e?new Promise((t=>{(new THREE.ObjectLoader).load(e,t)})):Promise.resolve(void 0)}function a(e){if(e){if(e instanceof THREE.BufferGeometry||e instanceof THREE.Geometry)return Promise.resolve(e);if(e.parameters)return new Promise((t=>{t(new THREE[e.type](...e.parameters))}));if(e.attributes){var t=new THREE.BufferGeometry;return Object.keys(e.attributes).map((n=>{t.setAttribute(n,new THREE.Float32BufferAttribute(e.attributes[n],3))})),e.index&&t.setIndex(e.index),Promise.resolve(t)}return Promise.resolve(void 0)}return Promise.resolve(void 0)}function i(e){if(e){var n;const r={},o=Object.keys(e).map((o=>{if("type"===o)n=e[o];else{if(-1!==t.TEXTURE_MAPS.indexOf(o))return function(e){if(!e)return Promise.resolve(null);return e.isTexture?Promise.resolve(e):"string"==typeof e?new Promise((t=>{(new THREE.TextureLoader).load(e,t)})):Promise.resolve(void 0)}(e[o]).then((e=>{r[o]=e}));r[o]=e[o]}}));return Promise.all(o).then((()=>new THREE[n](r)))}return Promise.resolve(void 0)}},t.loadTextures=function(e,t){var n=new THREE.TextureLoader,r=[];e.forEach((e=>{r.push(function(e,t){return new Promise((n=>{t.load(e,(e=>{n(e)}))}))}(e,n))})),Promise.all(r).then((e=>{t&&t(e)}))};var f=function(){var e=new Uint32Array([0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0]),t=[new Uint8Array([]),new Uint8Array([0,8,3]),new Uint8Array([0,1,9]),new Uint8Array([1,8,3,9,8,1]),new Uint8Array([1,2,10]),new Uint8Array([0,8,3,1,2,10]),new Uint8Array([9,2,10,0,2,9]),new Uint8Array([2,8,3,2,10,8,10,9,8]),new Uint8Array([3,11,2]),new Uint8Array([0,11,2,8,11,0]),new Uint8Array([1,9,0,2,3,11]),new Uint8Array([1,11,2,1,9,11,9,8,11]),new Uint8Array([3,10,1,11,10,3]),new Uint8Array([0,10,1,0,8,10,8,11,10]),new Uint8Array([3,9,0,3,11,9,11,10,9]),new Uint8Array([9,8,10,10,8,11]),new Uint8Array([4,7,8]),new Uint8Array([4,3,0,7,3,4]),new Uint8Array([0,1,9,8,4,7]),new Uint8Array([4,1,9,4,7,1,7,3,1]),new Uint8Array([1,2,10,8,4,7]),new Uint8Array([3,4,7,3,0,4,1,2,10]),new Uint8Array([9,2,10,9,0,2,8,4,7]),new Uint8Array([2,10,9,2,9,7,2,7,3,7,9,4]),new Uint8Array([8,4,7,3,11,2]),new Uint8Array([11,4,7,11,2,4,2,0,4]),new Uint8Array([9,0,1,8,4,7,2,3,11]),new Uint8Array([4,7,11,9,4,11,9,11,2,9,2,1]),new Uint8Array([3,10,1,3,11,10,7,8,4]),new Uint8Array([1,11,10,1,4,11,1,0,4,7,11,4]),new Uint8Array([4,7,8,9,0,11,9,11,10,11,0,3]),new Uint8Array([4,7,11,4,11,9,9,11,10]),new Uint8Array([9,5,4]),new Uint8Array([9,5,4,0,8,3]),new Uint8Array([0,5,4,1,5,0]),new Uint8Array([8,5,4,8,3,5,3,1,5]),new Uint8Array([1,2,10,9,5,4]),new Uint8Array([3,0,8,1,2,10,4,9,5]),new Uint8Array([5,2,10,5,4,2,4,0,2]),new Uint8Array([2,10,5,3,2,5,3,5,4,3,4,8]),new Uint8Array([9,5,4,2,3,11]),new Uint8Array([0,11,2,0,8,11,4,9,5]),new Uint8Array([0,5,4,0,1,5,2,3,11]),new Uint8Array([2,1,5,2,5,8,2,8,11,4,8,5]),new Uint8Array([10,3,11,10,1,3,9,5,4]),new Uint8Array([4,9,5,0,8,1,8,10,1,8,11,10]),new Uint8Array([5,4,0,5,0,11,5,11,10,11,0,3]),new Uint8Array([5,4,8,5,8,10,10,8,11]),new Uint8Array([9,7,8,5,7,9]),new Uint8Array([9,3,0,9,5,3,5,7,3]),new Uint8Array([0,7,8,0,1,7,1,5,7]),new Uint8Array([1,5,3,3,5,7]),new Uint8Array([9,7,8,9,5,7,10,1,2]),new Uint8Array([10,1,2,9,5,0,5,3,0,5,7,3]),new Uint8Array([8,0,2,8,2,5,8,5,7,10,5,2]),new Uint8Array([2,10,5,2,5,3,3,5,7]),new Uint8Array([7,9,5,7,8,9,3,11,2]),new Uint8Array([9,5,7,9,7,2,9,2,0,2,7,11]),new Uint8Array([2,3,11,0,1,8,1,7,8,1,5,7]),new Uint8Array([11,2,1,11,1,7,7,1,5]),new Uint8Array([9,5,8,8,5,7,10,1,3,10,3,11]),new Uint8Array([5,7,0,5,0,9,7,11,0,1,0,10,11,10,0]),new Uint8Array([11,10,0,11,0,3,10,5,0,8,0,7,5,7,0]),new Uint8Array([11,10,5,7,11,5]),new Uint8Array([10,6,5]),new Uint8Array([0,8,3,5,10,6]),new Uint8Array([9,0,1,5,10,6]),new Uint8Array([1,8,3,1,9,8,5,10,6]),new Uint8Array([1,6,5,2,6,1]),new Uint8Array([1,6,5,1,2,6,3,0,8]),new Uint8Array([9,6,5,9,0,6,0,2,6]),new Uint8Array([5,9,8,5,8,2,5,2,6,3,2,8]),new Uint8Array([2,3,11,10,6,5]),new Uint8Array([11,0,8,11,2,0,10,6,5]),new Uint8Array([0,1,9,2,3,11,5,10,6]),new Uint8Array([5,10,6,1,9,2,9,11,2,9,8,11]),new Uint8Array([6,3,11,6,5,3,5,1,3]),new Uint8Array([0,8,11,0,11,5,0,5,1,5,11,6]),new Uint8Array([3,11,6,0,3,6,0,6,5,0,5,9]),new Uint8Array([6,5,9,6,9,11,11,9,8]),new Uint8Array([5,10,6,4,7,8]),new Uint8Array([4,3,0,4,7,3,6,5,10]),new Uint8Array([1,9,0,5,10,6,8,4,7]),new Uint8Array([10,6,5,1,9,7,1,7,3,7,9,4]),new Uint8Array([6,1,2,6,5,1,4,7,8]),new Uint8Array([1,2,5,5,2,6,3,0,4,3,4,7]),new Uint8Array([8,4,7,9,0,5,0,6,5,0,2,6]),new Uint8Array([7,3,9,7,9,4,3,2,9,5,9,6,2,6,9]),new Uint8Array([3,11,2,7,8,4,10,6,5]),new Uint8Array([5,10,6,4,7,2,4,2,0,2,7,11]),new Uint8Array([0,1,9,4,7,8,2,3,11,5,10,6]),new Uint8Array([9,2,1,9,11,2,9,4,11,7,11,4,5,10,6]),new Uint8Array([8,4,7,3,11,5,3,5,1,5,11,6]),new Uint8Array([5,1,11,5,11,6,1,0,11,7,11,4,0,4,11]),new Uint8Array([0,5,9,0,6,5,0,3,6,11,6,3,8,4,7]),new Uint8Array([6,5,9,6,9,11,4,7,9,7,11,9]),new Uint8Array([10,4,9,6,4,10]),new Uint8Array([4,10,6,4,9,10,0,8,3]),new Uint8Array([10,0,1,10,6,0,6,4,0]),new Uint8Array([8,3,1,8,1,6,8,6,4,6,1,10]),new Uint8Array([1,4,9,1,2,4,2,6,4]),new Uint8Array([3,0,8,1,2,9,2,4,9,2,6,4]),new Uint8Array([0,2,4,4,2,6]),new Uint8Array([8,3,2,8,2,4,4,2,6]),new Uint8Array([10,4,9,10,6,4,11,2,3]),new Uint8Array([0,8,2,2,8,11,4,9,10,4,10,6]),new Uint8Array([3,11,2,0,1,6,0,6,4,6,1,10]),new Uint8Array([6,4,1,6,1,10,4,8,1,2,1,11,8,11,1]),new Uint8Array([9,6,4,9,3,6,9,1,3,11,6,3]),new Uint8Array([8,11,1,8,1,0,11,6,1,9,1,4,6,4,1]),new Uint8Array([3,11,6,3,6,0,0,6,4]),new Uint8Array([6,4,8,11,6,8]),new Uint8Array([7,10,6,7,8,10,8,9,10]),new Uint8Array([0,7,3,0,10,7,0,9,10,6,7,10]),new Uint8Array([10,6,7,1,10,7,1,7,8,1,8,0]),new Uint8Array([10,6,7,10,7,1,1,7,3]),new Uint8Array([1,2,6,1,6,8,1,8,9,8,6,7]),new Uint8Array([2,6,9,2,9,1,6,7,9,0,9,3,7,3,9]),new Uint8Array([7,8,0,7,0,6,6,0,2]),new Uint8Array([7,3,2,6,7,2]),new Uint8Array([2,3,11,10,6,8,10,8,9,8,6,7]),new Uint8Array([2,0,7,2,7,11,0,9,7,6,7,10,9,10,7]),new Uint8Array([1,8,0,1,7,8,1,10,7,6,7,10,2,3,11]),new Uint8Array([11,2,1,11,1,7,10,6,1,6,7,1]),new Uint8Array([8,9,6,8,6,7,9,1,6,11,6,3,1,3,6]),new Uint8Array([0,9,1,11,6,7]),new Uint8Array([7,8,0,7,0,6,3,11,0,11,6,0]),new Uint8Array([7,11,6]),new Uint8Array([7,6,11]),new Uint8Array([3,0,8,11,7,6]),new Uint8Array([0,1,9,11,7,6]),new Uint8Array([8,1,9,8,3,1,11,7,6]),new Uint8Array([10,1,2,6,11,7]),new Uint8Array([1,2,10,3,0,8,6,11,7]),new Uint8Array([2,9,0,2,10,9,6,11,7]),new Uint8Array([6,11,7,2,10,3,10,8,3,10,9,8]),new Uint8Array([7,2,3,6,2,7]),new Uint8Array([7,0,8,7,6,0,6,2,0]),new Uint8Array([2,7,6,2,3,7,0,1,9]),new Uint8Array([1,6,2,1,8,6,1,9,8,8,7,6]),new Uint8Array([10,7,6,10,1,7,1,3,7]),new Uint8Array([10,7,6,1,7,10,1,8,7,1,0,8]),new Uint8Array([0,3,7,0,7,10,0,10,9,6,10,7]),new Uint8Array([7,6,10,7,10,8,8,10,9]),new Uint8Array([6,8,4,11,8,6]),new Uint8Array([3,6,11,3,0,6,0,4,6]),new Uint8Array([8,6,11,8,4,6,9,0,1]),new Uint8Array([9,4,6,9,6,3,9,3,1,11,3,6]),new Uint8Array([6,8,4,6,11,8,2,10,1]),new Uint8Array([1,2,10,3,0,11,0,6,11,0,4,6]),new Uint8Array([4,11,8,4,6,11,0,2,9,2,10,9]),new Uint8Array([10,9,3,10,3,2,9,4,3,11,3,6,4,6,3]),new Uint8Array([8,2,3,8,4,2,4,6,2]),new Uint8Array([0,4,2,4,6,2]),new Uint8Array([1,9,0,2,3,4,2,4,6,4,3,8]),new Uint8Array([1,9,4,1,4,2,2,4,6]),new Uint8Array([8,1,3,8,6,1,8,4,6,6,10,1]),new Uint8Array([10,1,0,10,0,6,6,0,4]),new Uint8Array([4,6,3,4,3,8,6,10,3,0,3,9,10,9,3]),new Uint8Array([10,9,4,6,10,4]),new Uint8Array([4,9,5,7,6,11]),new Uint8Array([0,8,3,4,9,5,11,7,6]),new Uint8Array([5,0,1,5,4,0,7,6,11]),new Uint8Array([11,7,6,8,3,4,3,5,4,3,1,5]),new Uint8Array([9,5,4,10,1,2,7,6,11]),new Uint8Array([6,11,7,1,2,10,0,8,3,4,9,5]),new Uint8Array([7,6,11,5,4,10,4,2,10,4,0,2]),new Uint8Array([3,4,8,3,5,4,3,2,5,10,5,2,11,7,6]),new Uint8Array([7,2,3,7,6,2,5,4,9]),new Uint8Array([9,5,4,0,8,6,0,6,2,6,8,7]),new Uint8Array([3,6,2,3,7,6,1,5,0,5,4,0]),new Uint8Array([6,2,8,6,8,7,2,1,8,4,8,5,1,5,8]),new Uint8Array([9,5,4,10,1,6,1,7,6,1,3,7]),new Uint8Array([1,6,10,1,7,6,1,0,7,8,7,0,9,5,4]),new Uint8Array([4,0,10,4,10,5,0,3,10,6,10,7,3,7,10]),new Uint8Array([7,6,10,7,10,8,5,4,10,4,8,10]),new Uint8Array([6,9,5,6,11,9,11,8,9]),new Uint8Array([3,6,11,0,6,3,0,5,6,0,9,5]),new Uint8Array([0,11,8,0,5,11,0,1,5,5,6,11]),new Uint8Array([6,11,3,6,3,5,5,3,1]),new Uint8Array([1,2,10,9,5,11,9,11,8,11,5,6]),new Uint8Array([0,11,3,0,6,11,0,9,6,5,6,9,1,2,10]),new Uint8Array([11,8,5,11,5,6,8,0,5,10,5,2,0,2,5]),new Uint8Array([6,11,3,6,3,5,2,10,3,10,5,3]),new Uint8Array([5,8,9,5,2,8,5,6,2,3,8,2]),new Uint8Array([9,5,6,9,6,0,0,6,2]),new Uint8Array([1,5,8,1,8,0,5,6,8,3,8,2,6,2,8]),new Uint8Array([1,5,6,2,1,6]),new Uint8Array([1,3,6,1,6,10,3,8,6,5,6,9,8,9,6]),new Uint8Array([10,1,0,10,0,6,9,5,0,5,6,0]),new Uint8Array([0,3,8,5,6,10]),new Uint8Array([10,5,6]),new Uint8Array([11,5,10,7,5,11]),new Uint8Array([11,5,10,11,7,5,8,3,0]),new Uint8Array([5,11,7,5,10,11,1,9,0]),new Uint8Array([10,7,5,10,11,7,9,8,1,8,3,1]),new Uint8Array([11,1,2,11,7,1,7,5,1]),new Uint8Array([0,8,3,1,2,7,1,7,5,7,2,11]),new Uint8Array([9,7,5,9,2,7,9,0,2,2,11,7]),new Uint8Array([7,5,2,7,2,11,5,9,2,3,2,8,9,8,2]),new Uint8Array([2,5,10,2,3,5,3,7,5]),new Uint8Array([8,2,0,8,5,2,8,7,5,10,2,5]),new Uint8Array([9,0,1,5,10,3,5,3,7,3,10,2]),new Uint8Array([9,8,2,9,2,1,8,7,2,10,2,5,7,5,2]),new Uint8Array([1,3,5,3,7,5]),new Uint8Array([0,8,7,0,7,1,1,7,5]),new Uint8Array([9,0,3,9,3,5,5,3,7]),new Uint8Array([9,8,7,5,9,7]),new Uint8Array([5,8,4,5,10,8,10,11,8]),new Uint8Array([5,0,4,5,11,0,5,10,11,11,3,0]),new Uint8Array([0,1,9,8,4,10,8,10,11,10,4,5]),new Uint8Array([10,11,4,10,4,5,11,3,4,9,4,1,3,1,4]),new Uint8Array([2,5,1,2,8,5,2,11,8,4,5,8]),new Uint8Array([0,4,11,0,11,3,4,5,11,2,11,1,5,1,11]),new Uint8Array([0,2,5,0,5,9,2,11,5,4,5,8,11,8,5]),new Uint8Array([9,4,5,2,11,3]),new Uint8Array([2,5,10,3,5,2,3,4,5,3,8,4]),new Uint8Array([5,10,2,5,2,4,4,2,0]),new Uint8Array([3,10,2,3,5,10,3,8,5,4,5,8,0,1,9]),new Uint8Array([5,10,2,5,2,4,1,9,2,9,4,2]),new Uint8Array([8,4,5,8,5,3,3,5,1]),new Uint8Array([0,4,5,1,0,5]),new Uint8Array([8,4,5,8,5,3,9,0,5,0,3,5]),new Uint8Array([9,4,5]),new Uint8Array([4,11,7,4,9,11,9,10,11]),new Uint8Array([0,8,3,4,9,7,9,11,7,9,10,11]),new Uint8Array([1,10,11,1,11,4,1,4,0,7,4,11]),new Uint8Array([3,1,4,3,4,8,1,10,4,7,4,11,10,11,4]),new Uint8Array([4,11,7,9,11,4,9,2,11,9,1,2]),new Uint8Array([9,7,4,9,11,7,9,1,11,2,11,1,0,8,3]),new Uint8Array([11,7,4,11,4,2,2,4,0]),new Uint8Array([11,7,4,11,4,2,8,3,4,3,2,4]),new Uint8Array([2,9,10,2,7,9,2,3,7,7,4,9]),new Uint8Array([9,10,7,9,7,4,10,2,7,8,7,0,2,0,7]),new Uint8Array([3,7,10,3,10,2,7,4,10,1,10,0,4,0,10]),new Uint8Array([1,10,2,8,7,4]),new Uint8Array([4,9,1,4,1,7,7,1,3]),new Uint8Array([4,9,1,4,1,7,0,8,1,8,7,1]),new Uint8Array([4,0,3,7,4,3]),new Uint8Array([4,8,7]),new Uint8Array([9,10,8,10,11,8]),new Uint8Array([3,0,9,3,9,11,11,9,10]),new Uint8Array([0,1,10,0,10,8,8,10,11]),new Uint8Array([3,1,10,11,3,10]),new Uint8Array([1,2,11,1,11,9,9,11,8]),new Uint8Array([3,0,9,3,9,11,1,2,9,2,11,9]),new Uint8Array([0,2,11,8,0,11]),new Uint8Array([3,2,11]),new Uint8Array([2,3,8,2,8,10,10,8,9]),new Uint8Array([9,10,2,0,9,2]),new Uint8Array([2,3,8,2,8,10,0,1,8,1,10,8]),new Uint8Array([1,10,2]),new Uint8Array([1,3,8,9,1,8]),new Uint8Array([0,9,1]),new Uint8Array([0,3,8]),new Uint8Array([])],n=[new Uint8Array([0,0,0]),new Uint8Array([1,0,0]),new Uint8Array([1,1,0]),new Uint8Array([0,1,0]),new Uint8Array([0,0,1]),new Uint8Array([1,0,1]),new Uint8Array([1,1,1]),new Uint8Array([0,1,1])],r=[new Uint8Array([0,1]),new Uint8Array([1,2]),new Uint8Array([2,3]),new Uint8Array([3,0]),new Uint8Array([4,5]),new Uint8Array([5,6]),new Uint8Array([6,7]),new Uint8Array([7,4]),new Uint8Array([0,4]),new Uint8Array([1,5]),new Uint8Array([2,6]),new Uint8Array([3,7])],o=[new Uint8Array([0,0,0]),new Uint8Array([1,0,0]),new Uint8Array([1,1,0]),new Uint8Array([0,1,0]),new Uint8Array([0,0,1]),new Uint8Array([1,0,1]),new Uint8Array([1,1,1]),new Uint8Array([0,1,1])],a=[new Uint8Array([0,2,3,7]),new Uint8Array([0,6,2,7]),new Uint8Array([0,4,6,7]),new Uint8Array([0,6,1,2]),new Uint8Array([0,1,6,4]),new Uint8Array([5,6,1,4])],i=new Int32Array(24),s=new Int32Array(256);!function(){for(var e=0,t=0;t<8;++t)for(var n=1;n<=4;n<<=1){var r=t^n;t<=r&&(i[e++]=t,i[e++]=r)}for(t=0;t<256;++t){var o=0;for(n=0;n<24;n+=2){o|=!!(t&1<<i[n])!==!!(t&1<<i[n+1])?1<<(n>>1):0}s[t]=o}}();var l=new Array(4096);!function(){for(var e=0;e<l.length;++e)l[e]=0}();var c=[],f=function(e,t,n){var r=0;return r+=e[0],r+=c[1]*e[1],n[r+=c[2]*e[2]]};return{marchingCubes:function(o,a,i,s){s=s||0,c=[1,o[0],o[0]*o[1]],i||(i=[[0,0,0],o]);for(var l=[0,0,0],u=[0,0,0],d=0;d<3;++d)l[d]=(i[1][d]-i[0][d])/o[d],u[d]=i[0][d];var p=[],h=[],v=0,m=new Array(8),x=new Array(12),g=[0,0,0];for(g[2]=0;g[2]<o[2]-1;++g[2],v+=o[0])for(g[1]=0;g[1]<o[1]-1;++g[1],++v)for(g[0]=0;g[0]<o[0]-1;++g[0],++v){var y=0;if("function"==typeof a)for(d=0;d<8;++d){var E=n[d],w=a(l[0]*(g[0]+E[0])+u[0],l[1]*(g[1]+E[1])+u[1],l[2]*(g[2]+E[2])+u[2])-s;m[d]=w,y|=w>0?1<<d:0}else for(d=0;d<8;++d){E=n[d],w=f([g[0]+E[0],g[1]+E[1],g[2]+E[2]],0,a)-s;m[d]=w,y|=w>0?1<<d:0}var b=e[y];if(0!==b){for(d=0;d<12;++d)if(0!=(b&1<<d)){x[d]=p.length;var _=[0,0,0],T=r[d],A=n[T[0]],S=n[T[1]],R=m[T[0]],M=R-m[T[1]],C=0;Math.abs(M)>1e-6&&(C=R/M);for(var L=0;L<3;++L)_[L]=l[L]*(g[L]+A[L]+C*(S[L]-A[L]))+u[L];p.push(_)}var P=t[y];for(d=0;d<P.length;d+=3)h.push([x[P[d]],x[P[d+1]],x[P[d+2]]])}}return{vertices:p,faces:h}},marchingTetrahedra:function(e,t,n,r){r=r||0,c=[1,e[0],e[0]*e[1]],n||(n=[[0,0,0],e]);for(var i=[0,0,0],s=[0,0,0],l=0;l<3;++l)i[l]=(n[1][l]-n[0][l])/e[l],s[l]=n[0][l];var u=[],d=[],p=0,h=new Float32Array(8),v=[0,0,0];function m(e,t){var n=h[e],r=h[t],a=o[e],l=o[t],c=[v[0],v[1],v[2]],f=n-r;Math.abs(f)>1e-6&&(f=n/f);for(var d=0;d<3;++d)c[d]=i[d]*(c[d]+a[d]+f*(l[d]-a[d]))+s[d];return u.push(c),u.length-1}for(v[2]=0;v[2]<e[2]-1;++v[2],p+=e[0])for(v[1]=0;v[1]<e[1]-1;++v[1],++p)for(v[0]=0;v[0]<e[0]-1;++v[0],++p){if("function"==typeof t)for(l=0;l<8;++l){var x=o[l];h[l]=t(i[0]*(v[0]+x[0])+s[0],i[1]*(v[1]+x[1])+s[1],i[2]*(v[2]+x[2])+s[2])-r}else for(l=0;l<8;++l){x=o[l];h[l]=f([v[0]+x[0],v[1]+x[1],v[2]+x[2]],0,t)-r}for(l=0;l<a.length;++l){var g=a[l],y=0;switch(h[g[0]]<0&&(y|=1),h[g[1]]<0&&(y|=2),h[g[2]]<0&&(y|=4),h[g[3]]<0&&(y|=8),y){case 0:case 15:break;case 14:d.push([m(g[0],g[1]),m(g[0],g[3]),m(g[0],g[2])]);break;case 1:d.push([m(g[0],g[1]),m(g[0],g[2]),m(g[0],g[3])]);break;case 13:d.push([m(g[1],g[0]),m(g[1],g[2]),m(g[1],g[3])]);break;case 2:d.push([m(g[1],g[0]),m(g[1],g[3]),m(g[1],g[2])]);break;case 12:d.push([m(g[1],g[2]),m(g[1],g[3]),m(g[0],g[3]),m(g[0],g[2])]);break;case 3:d.push([m(g[1],g[2]),m(g[0],g[2]),m(g[0],g[3]),m(g[1],g[3])]);break;case 4:d.push([m(g[2],g[0]),m(g[2],g[1]),m(g[2],g[3])]);break;case 11:d.push([m(g[2],g[0]),m(g[2],g[3]),m(g[2],g[1])]);break;case 5:d.push([m(g[0],g[1]),m(g[1],g[2]),m(g[2],g[3]),m(g[0],g[3])]);break;case 10:d.push([m(g[0],g[1]),m(g[0],g[3]),m(g[2],g[3]),m(g[1],g[2])]);break;case 6:d.push([m(g[2],g[3]),m(g[0],g[2]),m(g[0],g[1]),m(g[1],g[3])]);break;case 9:d.push([m(g[2],g[3]),m(g[1],g[3]),m(g[0],g[1]),m(g[0],g[2])]);break;case 7:d.push([m(g[3],g[0]),m(g[3],g[1]),m(g[3],g[2])]);break;case 8:d.push([m(g[3],g[0]),m(g[3],g[2]),m(g[3],g[1])])}}}return{vertices:u,faces:d}},surfaceNets:function(e,t,n,r){r=r||0,c=[1,e[0],e[0]*e[1]],n||(n=[[0,0,0],e]);for(var o=[0,0,0],a=[0,0,0],u=0;u<3;++u)o[u]=(n[1][u]-n[0][u])/e[u],a[u]=n[0][u];var d=[],p=[],h=[0,0,0],v=[1,e[0]+1,(e[0]+1)*(e[1]+1)],m=[0,0,0,0,0,0,0,0],x=1;if(2*v[2]>l.length){var g=l.length;for(l.length=2*v[2];g<l.length;)l[g++]=0}for(h[2]=0;h[2]<e[2]-1;++h[2],e[0],x^=1,v[2]=-v[2]){var y=1+(e[0]+1)*(1+x*(e[1]+1));for(h[1]=0;h[1]<e[1]-1;++h[1],y+=2)for(h[0]=0;h[0]<e[0]-1;++h[0],++y){var E=0,w=0;if("function"==typeof t)for(var b=0;b<2;++b)for(var _=0;_<2;++_)for(u=0;u<2;++u,++w){var T=t(o[0]*(h[0]+u)+a[0],o[1]*(h[1]+_)+a[1],o[2]*(h[2]+b)+a[2])-r;m[w]=T,E|=T<0?1<<w:0}else for(b=0;b<2;++b)for(_=0;_<2;++_)for(u=0;u<2;++u,++w){T=f([h[0]+u,h[1]+_,h[2]+b],0,t)-r;m[w]=T,E|=T<0?1<<w:0}if(0!==E&&255!==E){var A=s[E],S=[0,0,0],R=0;for(u=0;u<12;++u)if(A&1<<u){++R;var M=i[u<<1],C=i[1+(u<<1)],L=m[M],P=L-m[C];if(Math.abs(P)>1e-6){P=L/P;for(_=0,b=1;_<3;++_,b<<=1){var k=M&b,N=C&b;S[_]+=k!==N?k?1-P:P:k?1:0}}}var H=1/R;for(u=0;u<3;++u)S[u]=o[u]*(h[u]+H*S[u])+a[u];l[y]=d.length,d.push(S);for(u=0;u<3;++u)if(A&1<<u){var z=(u+1)%3,D=(u+2)%3;if(0!==h[z]&&0!==h[D]){var F=v[z],I=v[D];1&E?(p.push([l[y],l[y-F],l[y-I]]),p.push([l[y-I],l[y-F],l[y-F-I]])):(p.push([l[y],l[y-I],l[y-F]]),p.push([l[y-F],l[y-I],l[y-F-I]]))}}}}}return{vertices:d,faces:p}}}},u=__webpack_require__(6549),d=__webpack_require__.n(u),p=__webpack_require__(3108),h={};h.sample=__webpack_require__(1471),h.vol2Msh=__webpack_require__(8596),h.rasterize=__webpack_require__(1844),h.voxelize=__webpack_require__(2446),h.normals=__webpack_require__(3794),h.spatialGrid=__webpack_require__(6195),h.signedDistance=__webpack_require__(3114),h.convexHull=__webpack_require__(1690),h.pointInPolygon=__webpack_require__(8371),h.haarTree=__webpack_require__(579),h.refineMesh=__webpack_require__(8670),h.fixMesh=__webpack_require__(9852),h.smoothVertices=__webpack_require__(7619),h.deformLaplacian=__webpack_require__(7065),h.loopSubdivide=__webpack_require__(1255),h.meanCurvature=__webpack_require__(8570),h.alphaShape=__webpack_require__(1591),h.geodesicDistance=__webpack_require__(3190).j,h.hull2D=__webpack_require__(4787),h.fft=__webpack_require__(3071),h.gaussBlur=__webpack_require__(6667),h.pool=__webpack_require__(4964),h.ndarray=__webpack_require__(2917),h.ndarrayOps=__webpack_require__(1641);class v extends THREE.Geometry{constructor(e,n,r,o,a){super();n=n||[[-1,-1,-1],[1,1,1]],a=a||"surfaceNets",o=o||0;if("number"==typeof(e=e||32)){g=n[1][0]-n[0][0],y=n[1][1]-n[0][1],E=n[1][2]-n[0][2];var i=Math.max(g,y,E)/e;(e=[])[0]=Math.max(~~(g/i),4),e[1]=Math.max(~~(y/i),4),e[2]=Math.max(~~(E/i),4)}var s,l,c,u=new f;switch(a){case"surfaceNets":s=u.surfaceNets(e,r,n,o);break;case"marchingCubes":s=u.marchingCubes(e,r,n,o);break;case"marchingTetrahedra":s=u.marchingTetrahedra(e,r,n,o)}for(var d=0;d<s.vertices.length;++d)l=s.vertices[d],this.vertices.push(new THREE.Vector3(l[0],l[1],l[2]));for(d=0;d<s.faces.length;++d)3===(c=s.faces[d]).length?this.faces.push(new THREE.Face3(c[0],c[1],c[2])):4===c.length&&(this.faces.push(new THREE.Face3(c[0],c[1],c[2])),this.faces.push(new THREE.Face3(c[0],c[2],c[3])));if(this.mergeVertices(),"function"==typeof r){for(var p,h,v,m,x=.001,g=new THREE.Vector3(x,0,0),y=new THREE.Vector3(0,x,0),E=new THREE.Vector3(0,0,x),w=new THREE.Vector3,b=[],_=(d=0,this.vertices.length);d<_;d++)l=this.vertices[d],p=T(w.addVectors(l,g))-T(w.subVectors(l,g)),h=T(w.addVectors(l,y))-T(w.subVectors(l,y)),v=T(w.addVectors(l,E))-T(w.subVectors(l,E)),m=new THREE.Vector3(p,h,v).normalize(),b.push(m);for(d=0,_=this.faces.length;d<_;d++)(c=this.faces[d]).vertexNormals=[b[c.a],b[c.b],b[c.c]];function T(e){return r(e.x,e.y,e.z)}}else this.computeVertexNormals();t.createFaceVertexUVs(this)}}v.prototype.isIsosurfaceGeometry=!0,t.IsosurfaceGeometry=v;class m extends THREE.BufferGeometry{constructor(e,t){super();var n=null;"xz"===(t=(t||"xz").toLowerCase())?n=d().from(e.map((e=>[e.x,e.z]))):"xy"===t?n=d().from(e.map((e=>[e.x,e.y]))):"yz"===t&&(n=d().from(e.map((e=>[e.y,e.z]))));var r=new Uint16Array(n.triangles);this.setIndex(new THREE.BufferAttribute(r,1)),this.setFromPoints(e),this.computeVertexNormals()}}m.prototype.isUDelaunayGeometry=!0,t.UDelaunayGeometry=m;class x extends THREE.BufferGeometry{constructor(e,n,r){super();n=n||[],r=r||[];var o=0;e.forEach((e=>{e.id=o++}));var a=new p.SweepContext(e);n.length>0&&(n.forEach((e=>{e.forEach((e=>{e.id=o++}))})),a.addHoles(n)),r.length>0&&(r.forEach((e=>{e.id=o++})),a.addPoints(r)),a.triangulate();var i=a.getTriangles(),s=[];i.forEach((e=>{e.getPoints().forEach((e=>{s.push(e.id)}))})),this.setIndex(new THREE.Uint16BufferAttribute(s,1));var l=e.concat(n,r);l=t.flattenArray(l),this.setFromPoints(l),this.computeVertexNormals()}}x.prototype.isCDelaunayGeometry=!0,t.CDelaunayGeometry=x,t.simplifyGeometry=function(e,n){n=n||.5;if(!e.isGeometry&&!e.isBufferGeometry)return null;e=t.toGeometry(e);var r=Math.floor(e.vertices.length*n);return(e=(new THREE.SimplifyModifier).modify(e,r)).computeVertexNormals(),e},t.subdivideGeometry=function(e,t){t=t||1;return e.isGeometry||e.isBufferGeometry?e=new THREE.SubdivisionModifier(t).modify(e):null};class g extends THREE.BufferGeometry{constructor(e,t,n,r,o,a){super();var i=new THREE.Geometry;e=e||.5,t=t||1,o=void 0!==o?o:0,a=void 0!==a?a:2*Math.PI,n=void 0!==n?Math.max(3,n):8;var s,l,c=[],f=e,u=(t-e)/(r=void 0!==r?Math.max(1,r):1);for(s=0;s<r+1;s++){for(l=0;l<n+1;l++){var d=new THREE.Vector3,p=o+l/n*a;d.x=f*Math.cos(p),d.z=f*Math.sin(p),i.vertices.push(d),c.push(new THREE.Vector2(l/n,s/r))}f+=u}var h=new THREE.Vector3(1,0,0);for(s=0;s<r;s++){var v=s*(n+1);for(l=0;l<n;l++){var m=p=l+v,x=p+n+1,g=p+n+2;i.faces.push(new THREE.Face3(m,x,g,[h.clone(),h.clone(),h.clone()])),i.faceVertexUvs[0].push([c[m].clone(),c[x].clone(),c[g].clone()]),m=p,x=p+n+2,g=p+1,i.faces.push(new THREE.Face3(m,x,g,[h.clone(),h.clone(),h.clone()])),i.faceVertexUvs[0].push([c[m].clone(),c[x].clone(),c[g].clone()])}}this.copy(i.toBufferGeometry())}}g.prototype.isRingGeometry=!0,t.RingGeometry=g,t.computeChildVertexFaceAmount=function(e){var t=0,n=0,r=0;return e.traverse((function(e){if(t++,e.isMesh){var o=1;!0===e.isInstancedMesh&&(o=e.count);var a=e.geometry;a.isGeometry?(n+=a.vertices.length,r+=a.faces.length):a.isBufferGeometry&&(n+=a.attributes.position.count*o,null!==a.index?r+=a.index.count/3*o:r+=a.attributes.position.count/3*o)}})),{objects:t,vertices:n,faces:r}},t.computeMassProperties=function(e){var t=0,n=0;return e.traverse((function(e){if(e.isMesh){var o=function(e){var t=0,n=0,o=new THREE.Triangle,a=e.geometry;if(a.isGeometry){if(a.faces.length<1)return{area:0,volume:0};var i=a.vertices;a.faces.forEach((function(e){t+=o.set(i[e.a],i[e.b],i[e.c]).getArea(),n+=r(i[e.a],i[e.b],i[e.c])}))}else if(a.isBufferGeometry){var s=new THREE.Vector3,l=new THREE.Vector3,c=new THREE.Vector3;if(a.index){if(a.index.count<3)return{area:0,volume:0};for(var f,u,d,p=a.attributes.position.array,h=a.index.array,v=0,m=a.index.count;v<m;v+=3)f=h[v+0],u=h[v+1],d=h[v+2],s.set(p[3*f],p[3*f+1],p[3*f+2]),l.set(p[3*u],p[3*u+1],p[3*u+2]),c.set(p[3*d],p[3*d+1],p[3*d+2]),t+=o.set(s,l,c).getArea(),n+=r(s,l,c)}else{if(a.attributes.position.count<3)return{area:0,volume:0};p=a.attributes.position.array;var x=3*a.attributes.position.count;for(v=0;v<x;v+=9)s.set(p[v+0],p[v+1],p[v+2]),l.set(p[v+3],p[v+4],p[v+5]),c.set(p[v+6],p[v+7],p[v+8]),t+=o.set(s,l,c).getArea(),n+=r(s,l,c)}}if(!0===e.isInstancedMesh){var g=e.count;return{area:t*g,volume:n*g}}return{area:t,volume:n}}(e);t+=o.area,n+=o.volume}})),{area:t,volume:n};function r(e,t,n){return(-(n.x*t.y*e.z)+t.x*n.y*e.z+n.x*e.y*t.z-e.x*n.y*t.z-t.x*e.y*n.z+e.x*t.y*n.z)/6}},t.isEmptyGeometry=function(e){return!(e.isGeometry&&e.vertices.length>0)&&!(e.isBufferGeometry&&e.attributes.position.count>0)},t.translateGeometry=function(e,t){if(t.isVector3){var n=(new THREE.Matrix4).makeTranslation(t.x,t.y,t.z);e.applyMatrix(n)}},t.rotateGeometry=function(e,t,n){if(0!==n){var r=new THREE.Matrix4;switch(t.toLowerCase()){case"x":r.makeRotationX(n);break;case"y":r.makeRotationY(n);break;case"z":r.makeRotationZ(n);break;default:return}e.applyMatrix(r)}},t.computeVertexNormals=function(e){var t=!1;if(!0===e.isGeometry){var n=e.faces[0].vertexNormals;n&&3===n.length&&(t=!0)}else if(!0===e.isBufferGeometry){var r=e.attributes.normal;r&&r.count>0&&(t=!0)}!1===t&&e.computeVertexNormals()},t.toNonIndexedBufferGeometry=function(e){var t=e;return e instanceof THREE.Geometry?t=e.toBufferGeometry():e instanceof THREE.BufferGeometry&&null!==e.index&&(t=e.toNonIndexed()),t},t.toBufferGeometry=function(e){var t=e;return e instanceof THREE.Geometry&&(t=e.toBufferGeometry()),t},t.toGeometry=function(e){return e instanceof THREE.BufferGeometry&&(e=(new THREE.Geometry).fromBufferGeometry(e)).mergeVertices(),e},t.rectangularPositions=function(e){var t=void 0!==(e=e||{}).axis?e.axis:"y",n=void 0!==e.width?e.width:1,r=void 0!==e.height?e.height:1,o=void 0!==e.numWidth?Math.floor(e.numWidth):1,a=void 0!==e.numHeight?Math.floor(e.numHeight):1,i=[];function s(e,t,n,r,o,a,s){var l,c,f,u,d=a<=1?1:r/(a-1),p=s<=1?1:o/(s-1),h=a<=1?0:r/2,v=s<=1?0:o/2,m=new THREE.Vector3;for(c=0;c<s;c++)for(u=c*p-v,l=0;l<a;l++)f=l*d-h,m[e]=f,m[t]=u,m[n]=0,i.push(m.x,m.y,m.z)}return"x"===t?s("y","z",t,n,r,o,a):"y"===t?s("z","x",t,n,r,o,a):"z"===t&&s("x","y",t,n,r,o,a),i},t.circularPositions=function(e){var t=void 0!==(e=e||{}).axis?e.axis:"y",n=void 0!==e.radiusStart?e.radiusStart:1,r=void 0!==e.radiusLength?e.radiusLength:n+1,o=void 0!==e.numRadius?Math.floor(e.numRadius):1,a=void 0!==e.angleStart?e.angleStart:0,i=void 0!==e.angleLength?e.angleLength:2*Math.PI,s=void 0!==e.numAngle?Math.floor(e.numAngle):4,l=[];function c(e,t,c){var f,u,d,p,h=o<=1?1:r/(o-1),v=s<=1?1:i/(s-1);i===2*Math.PI&&(v=i/s);var m=new THREE.Vector3;for(f=0;f<o;f++)for(d=f*h+n,u=0;u<s;u++)p=u*v+a,m[e]=d*Math.cos(p),m[t]=d*Math.sin(p),m[c]=0,l.push(m.x,m.y,m.z)}return"x"===t?c("y","z",t):"y"===t?c("z","x",t):"z"===t&&c("x","y",t),l},t.structuredPositions=function(e){return(e=e||{}).positions?e.positions:"rectangular"===e.pattern?t.rectangularPositions(e):"circular"===e.pattern?t.circularPositions(e):[]},t.scatteredPositions=function(e){if((e=e||{}).positions)return{positions:e.positions,rotations:e.rotations,scales:e.scales};for(var n,r,o,a=void 0!==e.seed?t.createRandFloat(e.seed):t.randFloat,i=.5*t.WORLD_SIZE,s=e.pmin||[-i,-i,-i],l=e.pmax||[i,i,i],c=e.rmin||[0,0,0],f=e.rmax||[0,0,0],u=e.smin||[1,1,1],d=e.smax||[1,1,1],p=void 0!==e.numInstances?Math.floor(e.numInstances):1,h=[],v=[],m=[],x=0;x<p;x++)n=a(s[0],l[0]),r=a(s[1],l[1]),o=a(s[2],l[2]),h.push(n,r,o),n=a(c[0],f[0]),r=a(c[1],f[1]),o=a(c[2],f[2]),v.push(n,r,o),n=a(u[0],d[0]),r=a(u[1],d[1]),o=a(u[2],d[2]),m.push(n,r,o);return{positions:h,rotations:v,scales:m}},t.createNoiseHeightGeometry=function(e,t,n,r,o){e=e||500,t=t||500;var a=(o=o||50)/88,i=function(e,t){for(var n=e*t,r=1,o=Math.random(),a=new Uint8Array(n),i=new THREE.ImprovedNoise,s=0;s<4;s++){for(var l=0;l<n;l++){var c=l%e,f=~~(l/e);a[l]+=Math.abs(i.noise(c/r,f/r,o)*r)}r*=5}return a}(n=n||256,r=r||256),s=new THREE.PlaneBufferGeometry(e,t,n-1,r-1);s.rotateX(-Math.PI/2);for(var l=s.attributes.position.array,c=0,f=0,u=l.length/3;c<u;c++,f+=3)l[f+1]=i[c]*a;return s.computeVertexNormals(),s};class y{constructor(e){this.convexPoints=new Array(3);var t=[];if(!0===e.isGeometry)for(var n=e.vertices,r=0,o=n.length;r<o;r++)t.push(n[r].toArray());else{if(!0!==e.isBufferGeometry)return void console.warn("warning: THREE.BufferGeometry or THREE.Geometry required in JAMIE.ConvexInOut()...");var a=e.attributes.position.array;for(r=0,o=a.length;r<o;r+=3)t.push([a[r],a[r+1],a[r+2]])}for(var i=0;i<3;i++){var s=(i+1)%3,l=(i+2)%3,c=t.map((e=>[e[s],e[l]]));this.convexPoints[i]=[];var f=h.convexHull(c);for(r=0,o=f.length;r<o;r++)this.convexPoints[i].push(c[f[r][0]])}}isPointOutside(e){for(var t=!0===e.isVector3?e.toArray():e,n=0;n<3;n++){var r=(n+2)%3,o=[t[(n+1)%3],t[r]];if(1===h.pointInPolygon(this.convexPoints[n],o))return!0}return!1}}y.prototype.isConvexInOut=!0,t.ConvexInOut=y,t.createIsosurfaceFromPoints=function(e,n,r,o){var a,i,s;o=o||0;"number"==typeof(r=r||64)?a=i=s=r:(a=r[0],i=r[1],s=r[2]);var l=Math.max(a,i,s),f=new THREE.Vector3,u=new THREE.Box3;u.setFromArray(e),u.getSize(f);var d,p,h,v,m,x,g=.1*Math.min(f.x,f.y,f.z);u.expandByScalar(g),d=u.min.x,p=u.max.x,h=u.min.y,v=u.max.y;var y=[[d,h,m=u.min.z],[p,v,x=u.max.z]],E=(p-d)/(a-1),w=(v-h)/(i-1),b=(x-m)/(s-1),_=Math.sqrt(E*E+w*w+b*b),T=2*_;t.Timer.start("octree");for(var A=new c.PointOctree(u.min,u.max,0,0,o),S=[],R=0,M=e.length;R<M;R+=3){var C={pi:R};(P=new THREE.Vector3).fromArray(e,R),A.insert(P,C),S.push(P)}t.Timer.end(),t.Timer.start("convex");var L,P,k,N,H,z,D=new THREE.ConvexBufferGeometry(S),F=new t.ConvexInOut(D);t.Timer.end();var I=[],O=new THREE.Vector3;t.Timer.start("volumeData");for(var U=0,G=m;U<s;U++,G+=b)for(var B=0,V=h;B<i;B++,V+=w){R=0;for(var W=d;R<a;R++,W+=E){if(O.set(W,V,G),null===(L=A.findNearestPoint(O,_))){if(F.isPointOutside(O)){I.push(T);continue}null===(L=A.findNearestPoint(O,_*l/4))&&(L=A.findNearestPoint(O))}P=L.point,k=n[C=L.data.pi],N=n[C+1],H=n[C+2],z=(O.x-P.x)*k+(O.y-P.y)*N+(O.z-P.z)*H,I.push(z)}}t.Timer.end(),t.Timer.start("isosurface");var j=new t.IsosurfaceGeometry([a,i,s],y,I);return t.Timer.end(),j},t.msh2Geometry=function(e,n){for(var r,o,a=new THREE.Geometry,i=a.vertices,s=a.faces,l=0,c=e.positions.length;l<c;l++)r=e.positions[l],i.push(new THREE.Vector3(r[0],r[1],r[2]));for(l=0,c=e.cells.length;l<c;l++)o=e.cells[l],s.push(new THREE.Face3(o[2],o[1],o[0]));a.mergeVertices();var f=(n=n||{}).uv,u=n.uv2,d=n.uvauto;if(void 0!==f||void 0!==u){var p=f&&f.isBufferAttribute,h=u&&u.isBufferAttribute;p||h?(a=t.toBufferGeometry(a),p&&a.setAttribute("uv",f),h&&a.setAttribute("uv2",u)):(Array.isArray(f)&&(a.faceVertexUvs[0]=f),Array.isArray(u)&&(a.faceVertexUvs[1]=u))}else!0===d&&t.createFaceVertexUVs(a);return a.computeVertexNormals(),a},t.geometry2Msh=function(e){for(var n,r,o=(e=t.toGeometry(e)).vertices,a=e.faces,i=new Array(o.length),s=0,l=o.length;s<l;s++)n=o[s],i[s]=[n.x,n.y,n.z];var c=new Array(a.length);for(s=0,l=a.length;s<l;s++)r=a[s],c[s]=[r.c,r.b,r.a];return{cells:c,positions:i}},t.updateVerticesFromMsh=function(e,n,r){var o,a=n.positions;if(!0===e.isGeometry){for(var i=e.vertices,s=0,l=a.length;s<l;s++)o=a[s],i[s].set(o[0],o[1],o[2]);e.verticesNeedUpdate=!0}else if(!0===e.isBufferGeometry){if(void 0===r){var c=t.toGeometry(e);r=t.geometryIndexMap(c,e)}var f,u=e.attributes.position;for(s=0,l=a.length;s<l;s++){o=a[s],f=r.vtx_to_pos[s];var d=0;for(l=posIndex.length;d<l;d++)u.setXYZ(f[d],o[0],o[1],o[2])}u.needsUpdate=!0}},t.geometryIndexMap=function(e,t,n){n=void 0!==n?n:4,n=Math.pow(10,n);for(var r,o,a=e.vertices,i=t.attributes.position.array,s=[],l={},c={},f=0,u=a.length;f<u;f++)o=a[f],r=Math.round(o.x*n)+"_"+Math.round(o.y*n)+"_"+Math.round(o.z*n),l[f]=r,c[r]=f;var d={},p={};for(f=0,u=i.length;f<u;f+=3){if(s[0]=i[f],s[1]=i[f+1],s[2]=i[f+2],void 0===c[r=Math.round(s[0]*n)+"_"+Math.round(s[1]*n)+"_"+Math.round(s[2]*n)])return console.warn("JAMIE.geometryIndexMap: index map not found due to different geometries"),{};d[f]=r,void 0===p[r]&&(p[r]=[]),p[r].push(f)}var h={},v={};for(f=0,u=a.length;f<u;f++)h[f]=p[l[f]];for(f=0,u=i.length;f<u;f+=3)v[f]=c[d[f]];return{vtx_to_pos:h,pos_to_vtx:v}},t.getTextureUV=function(e){return e.isGeometry?{uv:e.faceVertexUvs[0],uv2:e.faceVertexUvs[1]}:e.isBufferGeometry?{uv:e.getAttribute("uv"),uv2:e.getAttribute("uv")}:void 0},t.reconstructGeometry=function(e,n){var r=t.geometry2Msh(e),o=h.haarTree.rasterize(r.cells,r.positions,n);return r=h.haarTree.contour(o),t.msh2Geometry(r)},t.refineGeometry=function(e,n){if(!e.isGeometry&&!e.isBufferGeometry)return null;var r=t.geometry2Msh(e),o=h.normals.vertexNormals(r.cells,r.positions);return r=h.refineMesh(r.cells,r.positions,o,n),t.msh2Geometry(r)},t.fixGeometry=function(e,n){var r=t.geometry2Msh(e);return r=h.fixMesh(r.cells,r.positions,n),t.msh2Geometry(r)},t.smoothGeometry=function(e,n){var r=t.getTextureUV(e),o=t.geometry2Msh(e);return o.positions=h.smoothVertices(o.cells,o.positions,n),t.msh2Geometry(o,r)},t.deformGeometry=function(e,n,r){var o=t.getTextureUV(e),a=t.geometry2Msh(e),i=n.vertices.length;!function e(a,s){var l=[n.vertices[a],n.offsets[a],n.handles_rings[a],n.unconstrained_rings[a]];h.deformLaplacian.run(s,...l,(function(n){if(++a!=i)return e(a,n);var s=t.msh2Geometry(n,o);r&&r(s)}))}(0,a)},t.loopSubdivideGeometry=function(e){var n=t.geometry2Msh(e);return n=h.loopSubdivide(n.cells,n.positions),t.msh2Geometry(n)},t.addColorToGeometry=function(e,t,n){var r=void 0!==(n=n||{}).coloring?n.coloring:"vertex",o=void 0!==n.colorMap?n.colorMap:"rainbow",a=!0===Array.isArray(n.valueROI)?n.valueROI:[0,1],i=new THREE.Lut;i.setColorMap(o);var s,l,c=t.min(),f=t.max();if(i.setMin(c+(f-c)*a[0]),i.setMax(c+(f-c)*a[1]),!0===e.isGeometry){if("vertex"===r)for(var u=0,d=(s=e.faces).length;u<d;u++)(l=s[u]).vertexColors=[],l.vertexColors.push(i.getColor(t[l.a])),l.vertexColors.push(i.getColor(t[l.b])),l.vertexColors.push(i.getColor(t[l.c]));else if("face"===r)for(u=0,d=(s=e.faces).length;u<d;u++)h=(t[(l=s[u]).a]+t[l.b]+t[l.c])/3,l.color=i.getColor(h)}else if(!0===e.isBufferGeometry){var p,h,v,m=e.attributes.position.array,x=new Float32Array(m.length),g={},y=1e4,E=0;for(u=0,d=m.length;u<d;u+=3)void 0===g[p=Math.round(m[u]*y)+"_"+Math.round(m[u+1]*y)+"_"+Math.round(m[u+2]*y)]&&(g[p]=t[E++]);if("vertex"===r)for(u=0,d=m.length;u<d;u+=3)h=g[p=Math.round(m[u]*y)+"_"+Math.round(m[u+1]*y)+"_"+Math.round(m[u+2]*y)],v=i.getColor(h),x[u]=v.r,x[u+1]=v.g,x[u+2]=v.b;else if("face"===r)for(u=0,d=m.length;u<d;u+=9)h=(g[p=Math.round(m[u]*y)+"_"+Math.round(m[u+1]*y)+"_"+Math.round(m[u+2]*y)]+g[p=Math.round(m[u+3]*y)+"_"+Math.round(m[u+4]*y)+"_"+Math.round(m[u+5]*y)]+g[p=Math.round(m[u+6]*y)+"_"+Math.round(m[u+7]*y)+"_"+Math.round(m[u+8]*y)])/3,v=i.getColor(h),x[u]=x[u+3]=x[u+6]=v.r,x[u+1]=x[u+4]=x[u+7]=v.g,x[u+2]=x[u+5]=x[u+8]=v.b;e.setAttribute("color",new THREE.BufferAttribute(x,3))}},t.computeGeometryCurvature=function(e,n){var r=t.geometry2Msh(e),o=h.meanCurvature(r.cells,r.positions);return void 0!==n&&t.addColorToGeometry(e,o,n),o},t.alphaShapeGeometry=function(e,n){var r=h.alphaShape(e,n);if(0!==r.length){n=t.removeIsolatedPositions(r,n);return t.msh2Geometry({cells:r,positions:n})}console.warn("No cells produced...")},t.computeGeodesicDistance=function(e,n,r){var o=t.geometry2Msh(e);return h.geodesicDistance(o.cells,o.positions,n,r)},t.voxelizeGeometry=function(e,n){if(void 0===n){var r=new THREE.Vector3;e.computeBoundingBox(),e.boundingBox.getSize(r),n=Math.max(r.x,r.y,r.z)/100}for(var o=t.geometry2Msh(e),a=h.voxelize(o.cells,o.positions,n),i=a.voxels,s=i.shape,l=a.origin,c=(n=a.resolution,[]),f=2;f<s[2];f++)for(var u=0;u<s[1];u++)for(var d=0;d<s[0];d++)0===i.get(d,u,f)&&c.push(n*d,n*u,n*f);return{origin:[l[0],l[1],l[2]],size:n,positions:c}},t.removeIsolatedPositions=function(e,t){for(var n,r,o=0,a=[],i={},s=0,l=e.length;s<l;s++){r=e[s];for(var c=0;c<3;c++)void 0===i[n=r[c]]?(i[n]=o,a.push(t[n].slice(0)),r[c]=o,o++):r[c]=i[n]}return console.log("isolated vertices:",t.length-a.length),a},t.getOuterloop2D=function(e,t,n){var r,o;t=t||1.5,n=void 0!==n?n:4,n=Math.pow(10,n);for(var a=[],i=[],s={},l=0,c=e.length;l<c;l++)r=e[l],a.push([r.x,r.y]),s[o=Math.round(r.x*n)+"_"+Math.round(r.y*n)]=l;var f=h.hull2D(a,t);for(l=0,c=f.length;l<c;l++)r=f[l],o=Math.round(r[0]*n)+"_"+Math.round(r[1]*n),i.push(s[o]);return i},t.ShaderChunk={},t.ShaderChunk.mod289="float mod289(float x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }",t.ShaderChunk.permute="float permute(float x) { return mod289(((x*34.0)+1.0)*x); }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }",t.ShaderChunk.snoise2="float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);vec2 i  = floor(v + dot(v, C.yy) );vec2 x0 = v -   i + dot(i, C.xx);vec2 i1;i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);vec4 x12 = x0.xyxy + C.xxzz;x12.xy -= i1;i = mod289(i);vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0) );vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);m = m*m; m = m*m ;vec3 x = 2.0 * fract(p * C.www) - 1.0;vec3 h = abs(x) - 0.5;vec3 ox = floor(x + 0.5);vec3 a0 = x - ox;m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );vec3 g;g.x  = a0.x  * x0.x  + h.x  * x0.y;g.yz = a0.yz * x12.xz + h.yz * x12.yw;return 130.0 * dot(m, g); }",t.ShaderChunk.taylorInvSqrt="float taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }",t.ShaderChunk.snoise3="float snoise(vec3 v) { const vec2 C = vec2(1.0/6.0, 1.0/3.0);const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);vec3 i = floor(v + dot(v, C.yyy));vec3 x0 = v - i + dot(i, C.xxx);vec3 g = step(x0.yzx, x0.xyz);vec3 l = 1.0 - g;vec3 i1 = min(g.xyz, l.zxy);vec3 i2 = max(g.xyz, l.zxy);vec3 x1 = x0 - i1 + C.xxx;vec3 x2 = x0 - i2 + C.yyy;vec3 x3 = x0 - D.yyy;i = mod289(i);vec4 p = permute( permute( permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));float n_ = 0.142857142857;vec3 ns = n_ * D.wyz - D.xzx;vec4 j = p - 49.0 * floor(p * ns.z * ns.z);vec4 x_ = floor(j * ns.z);vec4 y_ = floor(j - 7.0 * x_);vec4 x = x_ *ns.x + ns.yyyy;vec4 y = y_ *ns.x + ns.yyyy;vec4 h = 1.0 - abs(x) - abs(y);vec4 b0 = vec4( x.xy, y.xy );vec4 b1 = vec4( x.zw, y.zw );vec4 s0 = floor(b0)*2.0 + 1.0;vec4 s1 = floor(b1)*2.0 + 1.0;vec4 sh = -step(h, vec4(0.0));vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;vec3 p0 = vec3(a0.xy,h.x);vec3 p1 = vec3(a0.zw,h.y);vec3 p2 = vec3(a1.xy,h.z);vec3 p3 = vec3(a1.zw,h.w);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);m = m * m;return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3))); }",t.ShaderChunk.grad4="vec4 grad4(float j, vec4 ip) { const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p; }",t.ShaderChunk.snoise4="float snoise(vec4 v) { const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);vec4 i  = floor(v + dot(v, vec4(0.309016994374947451)));vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + C.xxxx;vec4 x2 = x0 - i2 + C.yyyy;vec4 x3 = x0 - i3 + C.zzzz;vec4 x4 = x0 + C.wwww;i = mod289(i);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 )) + i.z + vec4(i1.z, i2.z, i3.z, 1.0 )) + i.y + vec4(i1.y, i2.y, i3.y, 1.0 )) + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * (dot(m0*m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1*m1, vec2(dot(p3, x3), dot(p4, x4)))); }",t.ShaderChunk.fade2="vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}",t.ShaderChunk.cnoise2="float cnoise(vec2 P){vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);Pi = mod289(Pi);vec4 ix = Pi.xzxz;vec4 iy = Pi.yyww;vec4 fx = Pf.xzxz;vec4 fy = Pf.yyww;vec4 i = permute(permute(ix) + iy);vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0;vec4 gy = abs(gx) - 0.5;vec4 tx = floor(gx + 0.5);gx = gx - tx;vec2 g00 = vec2(gx.x,gy.x);vec2 g10 = vec2(gx.y,gy.y);vec2 g01 = vec2(gx.z,gy.z);vec2 g11 = vec2(gx.w,gy.w);vec4 norm = 1.79284291400159 - 0.85373472095314 * vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));g00 *= norm.x;g01 *= norm.y;g10 *= norm.z;g11 *= norm.w;float n00 = dot(g00, vec2(fx.x, fy.x));float n10 = dot(g10, vec2(fx.y, fy.y));float n01 = dot(g01, vec2(fx.z, fy.z));float n11 = dot(g11, vec2(fx.w, fy.w));vec2 fade_xy = fade(Pf.xy);vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);float n_xy = mix(n_x.x, n_x.y, fade_xy.y);return 2.3 * n_xy; }",t.ShaderChunk.fade3="vec3 fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }",t.ShaderChunk.cnoise3="float cnoise(vec3 P) { vec3 Pi0 = floor(P);vec3 Pi1 = Pi0 + vec3(1.0);Pi0 = mod289(Pi0);Pi1 = mod289(Pi1);vec3 Pf0 = fract(P);vec3 Pf1 = Pf0 - vec3(1.0);vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);vec4 iy = vec4(Pi0.yy, Pi1.yy);vec4 iz0 = Pi0.zzzz;vec4 iz1 = Pi1.zzzz;vec4 ixy = permute(permute(ix) + iy);vec4 ixy0 = permute(ixy + iz0);vec4 ixy1 = permute(ixy + iz1);vec4 gx0 = ixy0 * (1.0 / 7.0);vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;gx0 = fract(gx0);vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);vec4 sz0 = step(gz0, vec4(0.0));gx0 -= sz0 * (step(0.0, gx0) - 0.5);gy0 -= sz0 * (step(0.0, gy0) - 0.5);vec4 gx1 = ixy1 * (1.0 / 7.0);vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;gx1 = fract(gx1);vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);vec4 sz1 = step(gz1, vec4(0.0));gx1 -= sz1 * (step(0.0, gx1) - 0.5);gy1 -= sz1 * (step(0.0, gy1) - 0.5);vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));g000 *= norm0.x;g010 *= norm0.y;g100 *= norm0.z;g110 *= norm0.w;vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));g001 *= norm1.x;g011 *= norm1.y;g101 *= norm1.z;g111 *= norm1.w;float n000 = dot(g000, Pf0);float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));float n111 = dot(g111, Pf1);vec3 fade_xyz = fade(Pf0);vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);return 2.2 * n_xyz;}",t.ShaderChunk.pnoise3="float pnoise(vec3 P, vec3 rep) { vec3 Pi0 = mod(floor(P), rep);vec3 Pi1 = mod(Pi0 + vec3(1.0), rep);Pi0 = mod289(Pi0);Pi1 = mod289(Pi1);vec3 Pf0 = fract(P);vec3 Pf1 = Pf0 - vec3(1.0);vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);vec4 iy = vec4(Pi0.yy, Pi1.yy);vec4 iz0 = Pi0.zzzz;vec4 iz1 = Pi1.zzzz;vec4 ixy = permute(permute(ix) + iy);vec4 ixy0 = permute(ixy + iz0);vec4 ixy1 = permute(ixy + iz1);vec4 gx0 = ixy0 * (1.0 / 7.0);vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;gx0 = fract(gx0);vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);vec4 sz0 = step(gz0, vec4(0.0));gx0 -= sz0 * (step(0.0, gx0) - 0.5);gy0 -= sz0 * (step(0.0, gy0) - 0.5);vec4 gx1 = ixy1 * (1.0 / 7.0);vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;gx1 = fract(gx1);vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);vec4 sz1 = step(gz1, vec4(0.0));gx1 -= sz1 * (step(0.0, gx1) - 0.5);gy1 -= sz1 * (step(0.0, gy1) - 0.5);vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));g000 *= norm0.x;g010 *= norm0.y;g100 *= norm0.z;g110 *= norm0.w;vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));g001 *= norm1.x;g011 *= norm1.y;g101 *= norm1.z;g111 *= norm1.w;float n000 = dot(g000, Pf0);float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));float n111 = dot(g111, Pf1);vec3 fade_xyz = fade(Pf0);vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);return 2.2 * n_xyz;}",t.ShaderChunk.random="float random(vec2 p) { return fract(sin(mod(dot(p.xy, vec2(12.9898, 78.233)), 3.14))*43758.5453123); }",t.ShaderChunk.hash="float hash(float x) { return fract(sin(x) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }",t.ShaderChunk.noise2="float noise(vec2 p) { vec2 i = floor(p);vec2 f = fract(p);float a = hash(i);float b = hash(i + vec2(1.0, 0.0));float c = hash(i + vec2(0.0, 1.0));float d = hash(i + vec2(1.0, 1.0));vec2 u = f*f*(3.0 - 2.0*f);return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y; }",t.ShaderChunk.noise3="float noise(vec3 x) { const vec3 step = vec3(110, 241, 171);vec3 i = floor(x);vec3 f = fract(x);float n = dot(i, step);vec3 u = f * f * (3.0 - 2.0 * f);return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);}",t.ShaderChunk.fbm2="float fbm(vec2 p) { const int NUM_OCTAVES = 5;float v = 0.0;float a = 0.5;vec2 shift = vec2(100.0);mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));for (int i = 0; i < NUM_OCTAVES; ++i) {v += a * noise(p);p = rot * p * 2.0 + shift;a *= 0.5;}return v; }",t.ShaderChunk.fbm3="float fbm(vec3 x) { const int NUM_OCTAVES = 5;float v = 0.0;float a = 0.5;vec3 shift = vec3(100.0);for (int i = 0; i < NUM_OCTAVES; ++i) {v += a * noise(x);x = x * 2.0 + shift;a *= 0.5;}return v; }",t.ShaderChunk.fbm2IQ="float fbmIQ(vec2 p){ const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);float f = 0.0;f += 0.5000*noise( p ); p = m2*p*2.02;f += 0.2500*noise( p ); p = m2*p*2.03;f += 0.1250*noise( p ); p = m2*p*2.01;f += 0.0625*noise( p );return f/0.9375; }",t.ShaderChunk.clipToScreenPos="\nvec2 clipToScreenPos( vec4 clipPos ) {\n    vec2 ndcPos = clipPos.xy / clipPos.w; // ndc = [-1,1]\n    vec2 screenPos = ndcPos * 0.5 + 0.5;  // screenPos = [0,1]\n    return screenPos;\n}",t.ShaderChunk.caustics="\nvec3 caustics( vec2 uv, float density, vec3 baseColor )\n// density: larger -> higher frequent (1.0 ~ 16.0)\n{\n    const int MAX_ITER = 10;\n    const float inten = 0.005; // light intensity: larger -> brighter (range = 0.015 ~ 0.055)\n    const float speed = 1.5;   // water speed: larger -> slower (range = 0.1 ~ 1.5)\n    const float speed2 = 3.0;  // water speed: larger -> faster (range = 0.0 ~ 10.0)\n    const float freq = 0.8;    // water ripples (range = 0.5 ~ 1.0(= oil))\n    const float xflow = 0.0;   // flow speed in x direction (range = -10 ~ +10)\n    const float zflow = 0.0;   // flow speed in z direction (range = -10 ~ +10)\n    float c = 1.5;             // global brightness: larger -> darker (default = 1.0, range = 0.0 ~ 5.0)\n    vec2 p = mod( uv * PI2*density, PI2*density ) - 250.0;\n    vec2 i = p;\n    for( int n = 0; n < MAX_ITER; n++ ) {\n        float t = time * (1.0 - (3.0 / (float(n) + speed)));\n        i = p + vec2( cos(t - i.x * freq) + sin(t + i.y * freq) + (time * xflow), sin(t - i.y * freq) + cos(t + i.x * freq) + (time * zflow) );\n        c += 1.0 / length( vec2( p.x / (sin(i.x + t * speed2) / inten), p.y / (cos(i.y + t * speed2) / inten) ) );\n    }\n    c /= float( MAX_ITER );\n    c = 1.17 - pow( c, 1.4 );\n    vec3 color = vec3( pow( abs(c), 8.0 ) );\n    color = saturate( baseColor + color );\n    return color;\n}",t.ToonShader={uniforms:{uDirLightPos:{value:new THREE.Vector3},uDirLightColor:{value:new THREE.Color(16777215)},uMaterialColor:{value:new THREE.Color(16777215)},uKd:{value:.97},uBorder:{value:.4}},vertexShader:["varying vec3 vNormal;","varying vec3 vViewPosition;","void main() {","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","vNormal = normalize( normalMatrix * normal );","vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","vViewPosition = -mvPosition.xyz;","}"].join("\n"),fragmentShader:["uniform vec3 uMaterialColor;","uniform vec3 uDirLightPos;","uniform vec3 uDirLightColor;","uniform float uKd;","uniform float uBorder;","varying vec3 vNormal;","varying vec3 vViewPosition;","void main() {","vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );","vec3 lVector = normalize( lDirection.xyz );","vec3 normal = normalize( vNormal );","float diffuse = dot( normal, lVector );","if ( diffuse > 0.6 ) { diffuse = 1.0; }","else if ( diffuse > -0.2 ) { diffuse = 0.7; }","else { diffuse = 0.3; }","gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );","}"].join("\n")},t.SkyShader={uniforms:{turbidity:{value:10},rayleigh:{value:3},mieCoefficient:{value:.005},mieDirectionalG:{value:.7},luminance:{value:1},sunPosition:{value:new THREE.Vector3}},vertexShader:["uniform vec3 sunPosition;","uniform float rayleigh;","uniform float turbidity;","uniform float mieCoefficient;","varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","const vec3 up = vec3( 0.0, 1.0, 0.0 );","const float e = 2.71828182845904523536028747135266249775724709369995957;","const float pi = 3.141592653589793238462643383279502884197169;","const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );","const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );","const float v = 4.0;","const vec3 K = vec3( 0.686, 0.678, 0.666 );","const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );","const float cutoffAngle = 1.6110731556870734;","const float steepness = 1.5;","const float EE = 1000.0;","float sunIntensity( float zenithAngleCos ) {","\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );","\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );","}","vec3 totalMie( float T ) {","\tfloat c = ( 0.2 * T ) * 10E-18;","\treturn 0.434 * c * MieConst;","}","void main() {","\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );","\tvWorldPosition = worldPosition.xyz;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","\tvSunDirection = normalize( sunPosition );","\tvSunE = sunIntensity( dot( vSunDirection, up ) );","\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );","\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );","\tvBetaR = totalRayleigh * rayleighCoefficient;","\tvBetaM = totalMie( turbidity ) * mieCoefficient;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","uniform float luminance;","uniform float mieDirectionalG;","const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );","const float pi = 3.141592653589793238462643383279502884197169;","const float n = 1.0003;","const float N = 2.545E25;","const float rayleighZenithLength = 8.4E3;","const float mieZenithLength = 1.25E3;","const vec3 up = vec3( 0.0, 1.0, 0.0 );","const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;","const float THREE_OVER_SIXTEENPI = 0.05968310365946075;","const float ONE_OVER_FOURPI = 0.07957747154594767;","float rayleighPhase( float cosTheta ) {","\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );","}","float hgPhase( float cosTheta, float g ) {","\tfloat g2 = pow( g, 2.0 );","\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );","\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );","}","const float A = 0.15;","const float B = 0.50;","const float C = 0.10;","const float D = 0.20;","const float E = 0.02;","const float F = 0.30;","const float whiteScale = 1.0748724675633854;","vec3 Uncharted2Tonemap( vec3 x ) {","\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;","}","void main() {","\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );","\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );","\tfloat sR = rayleighZenithLength * inverse;","\tfloat sM = mieZenithLength * inverse;","\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );","\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );","\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );","\tvec3 betaRTheta = vBetaR * rPhase;","\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );","\tvec3 betaMTheta = vBetaM * mPhase;","\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );","\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );","\tvec3 direction = normalize( vWorldPosition - cameraPos );","\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]","\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]","\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );","\tvec3 L0 = vec3( 0.1 ) * Fex;","\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );","\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;","\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );","\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );","\tvec3 color = curr * whiteScale;","\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );","\tgl_FragColor = vec4( retColor, 1.0 );","}"].join("\n")},t.SkyDomeShader={uniforms:{topColor:{value:new THREE.Color(30719)},bottomColor:{value:new THREE.Color(16777215)},offset:{value:33},exponent:{value:.6}},vertexShader:["varying vec3 vWorldPosition;","void main() {","vec4 worldPosition = modelMatrix * vec4(position, 1.0);","vWorldPosition = worldPosition.xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),fragmentShader:["uniform vec3 topColor;","uniform vec3 bottomColor;","uniform float offset;","uniform float exponent;","varying vec3 vWorldPosition;","void main() {","float h = normalize(vWorldPosition + offset).y;","gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);","}"].join("\n")},t.CloudDomeShader={uniforms:{noiseTex:{value:null},time:{value:1},sharp:{value:.9},cover:{value:.5},clouds:{value:1},depth:{value:0}},vertexShader:["uniform sampler2D noiseTex;","uniform float time;","varying vec2 vUv;","void main()","{","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float time;","uniform float depth;","uniform float sharp;","uniform float cover;","uniform float clouds;","uniform sampler2D noiseTex;","varying vec2 vUv;","vec3 noise3(vec2 p) {","\treturn texture2D(noiseTex, p).xyz;","}","vec3 fNoise(vec2 uv) {","\tvec3 f = vec3(0.0);","\tfloat scale = 1.;","\tfor (int i=0; i<5; i++) {","\t\tscale *= 2.0;","\t\tf += noise3(uv * scale) / scale;","\t}","\treturn f;","}","void main(void)","{","\tvec2 uv = vUv;","\tvec3 ff1 = fNoise(uv * 0.01 + time * 0.00015 * vec2(-1.0, 1.0));","\tvec3 ff2 = fNoise(uv * 0.1 + time * 0.0005 * vec2(1.0, 1.0));","\tfloat t = ff1.x * 0.9 + ff1.y * 0.15;","\tt = t * 0.99 + ff2.x * 0.01;","\tfloat o = clamp ( length(uv * 2.0 - vec2(1., 1.)), 0.0, 1.0 );","\to =  1.0 - o * o * o * o;","\to -= (1.0 - t) * 0.95;","\tt = max(t - (1.0 - cover), 0.0);","\tt = 1.0 - pow(1.0 - sharp, t);","\tt = min(t * 1.9, 1.0);","\tif (depth > 0.0) {","\t\tif (o < 0.4 && t < 0.8) discard;","\t\tgl_FragColor = vec4(gl_FragCoord.z, 1.0, 1.0, 1.0);","\t}","\telse {","\t\tgl_FragColor = vec4(t, t, t, o);","\t}","}"].join("\n")},t.RainDropShader={uniforms:{time:{value:0}},vertexShader:["precision highp float;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform float time;","attribute vec3 position;","attribute vec3 offset;","void main(void) {","vec3 translate = vec3(position.x, position.y - time, position.z);","gl_Position = projectionMatrix * modelViewMatrix * vec4(translate + offset, 1.0);","}"].join("\n"),fragmentShader:["precision highp float;","uniform float time;","void main(void) {","gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);","}"].join("\n")},t.RainRippleShader={uniforms:{time:{value:0}},vertexShader:["precision highp float;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","attribute vec3 position;","attribute vec3 offset;","varying vec3 vPosition;","varying vec3 vOffset;","void main(void) {","gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + offset.x, 0.0, position.z + offset.z, 1.0);","vPosition = position;","vOffset = offset;","}"].join("\n"),fragmentShader:["precision highp float;","uniform float time;","varying vec3 vPosition;","varying vec3 vOffset;","void main(void) {","float a = abs(0.04 * time * vOffset.y - length(vPosition));","float b = 0.004 / a;","float c = step(0.9, b);","gl_FragColor = vec4(1.0, 1.0, 1.0, c);","}"].join("\n")},t.SmokeShader={uniforms:{time:{value:0},size:{value:3},smokeTex:{value:null},lifetime:{value:10},projection:{value:0}},vertexShader:["attribute float shift;","uniform float time;","uniform float size;","uniform float lifetime;","uniform float projection;","varying float progress;","float cubicOut( float t ) {","float f = t - 1.0;","return f * f * f + 1.0;","}","void main () {","progress = fract( time * 2.0 / lifetime + shift );","float eased = cubicOut( progress );","vec3 pos = vec3( position.x * eased, position.y * eased, position.z * eased  );","gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );","gl_PointSize = ( projection * size ) / gl_Position.w;","}"].join("\n"),fragmentShader:["uniform sampler2D smokeTex;","varying float progress;","void main() {","vec3 color = vec3( 1.0 );","gl_FragColor = texture2D( smokeTex, gl_PointCoord ) * vec4( color, 0.3 * ( 1.0 - progress ) );","}"].join("\n")},t.VolumeFireShader={uniforms:{fireNoise:{value:null},fireProfile:{value:null},time:{value:1}},vertexShader:["attribute vec3 tex;","varying vec3 texOut;","void main ( void ) {","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );","texOut = tex;","}"].join("\n"),fragmentShader:["uniform sampler2D fireNoise;","uniform sampler2D fireProfile;","uniform float time;","varying vec3 texOut;","const float modulus = 61.0;  // Value used in pregenerated noise texture.","const float magnatude = 1.3;","const int octives = 4;","const float lacunarity = 2.0;","const float gain = 0.5;","vec2 mBBS( vec2 val, float modulus ) {","val = mod( val, modulus ); // For numerical consistancy.","return mod(val * val, modulus);","}","float mnoise ( vec3 pos ) {","float intArg = floor( pos.z );","float fracArg = fract( pos.z );","vec2 hash = mBBS( intArg * 3.0 + vec2( 0.0, 3.0 ), modulus );","vec4 g = vec4 (","texture2D( fireNoise, vec2( pos.x, pos.y + hash.x ) / modulus ).xy,","texture2D( fireNoise, vec2( pos.x, pos.y + hash.y ) / modulus ).xy) * 2.0 - 1.0;","return mix(","g.x + g.y * fracArg,","g.z + g.w * ( fracArg - 1.0 ),","smoothstep( 0.0, 1.0, fracArg )",");","}","float turbulence( vec3 pos ) {","float sum  = 0.0;","float freq = 1.0;","float amp  = 1.0;","for ( int i = 0; i < 4; i++ ) {","sum += abs( mnoise( pos * freq ) ) * amp;","freq *= lacunarity;","amp *= gain;","}","return sum;","}","vec4 sampleFire( vec3 loc, vec4 scale ) {","loc.xz = loc.xz * 2.0 - 1.0;","vec2 st = vec2( sqrt( dot( loc.xz, loc.xz ) ), loc.y );","loc.y -= time * scale.w; // Scrolling noise upwards over time.","loc *= scale.xyz; // Scaling noise space.","float offset = sqrt( st.y ) * magnatude * turbulence( loc );","st.y += offset;","if ( st.y > 1.0 ) {","return vec4( 0.0, 0.0, 0.0, 1.0 );","}","vec4 result = texture2D( fireProfile, st );","if ( st.y < 0.1 ) {","result *= st.y / 0.1;","}","return result;","}","void main( void ) {","vec3 color = sampleFire( texOut, vec4( 1.0, 2.0, 1.0, 0.5 ) ).xyz;","gl_FragColor = vec4( color * 1.5, 1.0 );","}"].join("\n")},t.FireParticlesShader={uniforms:{color:{value:null},strength:{value:0},texture:{value:null},time:{value:0},heightOfNearPlane:{value:0}},vertexShader:["attribute float randam;","attribute float sprite;","uniform float time;","uniform float strength;","uniform float heightOfNearPlane;","varying float vSprite;","varying float vOpacity;","float PI = 3.14;","float quadraticIn( float t ) {","float tt = t * t;","return tt * tt;","}","void main() {","float progress = fract( time + ( 2.0 * randam - 1.0 ) );","float progressNeg = 1.0 - progress;","float ease = quadraticIn( progress );","float influence = sin( PI * ease );","vec3 newPosition = position * vec3( 1.0, ease, 1.0 );","gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );","gl_PointSize = ( heightOfNearPlane * strength ) / gl_Position.w;","vOpacity = min( influence * 4.0, 1.0 ) * progressNeg;","vSprite = sprite;","}"].join("\n"),fragmentShader:["uniform vec3 color;","uniform sampler2D uTexture;","varying float vSprite;","varying float vOpacity;","float ONE_SPRITE_ROW_LENGTH = 0.25;","void main() {","vec2 texCoord = vec2(","gl_PointCoord.x * ONE_SPRITE_ROW_LENGTH + vSprite,","gl_PointCoord.y",");","gl_FragColor = vec4( texture2D( uTexture, vec2( texCoord ) ).xyz * color * vOpacity, 1.0 );","}"].join("\n")},t.GPUParticlesShader={uniforms:{uTime:{value:0},uScale:{value:1},tNoise:{value:null},tSprite:{value:null}},vertexShader:["uniform float uTime;","uniform float uScale;","uniform sampler2D tNoise;","attribute vec3 positionStart;","attribute float startTime;","attribute vec3 velocity;","attribute float turbulence;","attribute vec3 color;","attribute float size;","attribute float lifeTime;","varying vec4 vColor;","varying float lifeLeft;","void main() {","\tvColor = vec4( color, 1.0 );","\tvec3 newPosition;","\tvec3 v;","\tfloat timeElapsed = uTime - startTime;","\tlifeLeft = 1.0 - ( timeElapsed / lifeTime );","\tgl_PointSize = ( uScale * size ) * lifeLeft;","\tfloat velLength = length( velocity );","\tv.x = ( velocity.x - 0.5 ) * 3.0 * velLength;","\tv.y = ( velocity.y - 0.5 ) * 3.0 * velLength;","\tv.z = ( velocity.z - 0.5 ) * 3.0 * velLength;","\tnewPosition = positionStart + ( v * 10.0 ) * timeElapsed;","\tvec3 noise = texture2D( tNoise, vec2( newPosition.x * 0.015 + ( uTime * 0.05 ), newPosition.y * 0.02 + ( uTime * 0.015 ) ) ).rgb;","\tvec3 noiseVel = ( noise.rgb - 0.5 ) * 60.0 * velLength;","\tnewPosition = mix( newPosition, newPosition + vec3( noiseVel * turbulence ), ( timeElapsed / lifeTime ) );","\tif( v.y > 0.0 && v.y < 0.05 ) {","\t\tlifeLeft = 0.0;","\t}","\tif( v.x < - 1.45 ) {","\t\tlifeLeft = 0.0;","\t}","\tif( timeElapsed > 0.0 ) {","\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );","\t} else {","\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","\t\tlifeLeft = 0.0;","\t\tgl_PointSize = 0.0;","\t}","}"].join("\n"),fragmentShader:["float scaleLinear( float value, vec2 valueDomain ) {","\treturn ( value - valueDomain.x ) / ( valueDomain.y - valueDomain.x );","}","float scaleLinear( float value, vec2 valueDomain, vec2 valueRange ) {","\treturn mix( valueRange.x, valueRange.y, scaleLinear( value, valueDomain ) );","}","varying vec4 vColor;","varying float lifeLeft;","uniform sampler2D tSprite;","void main() {","\tfloat alpha = 0.0;","\tif( lifeLeft > 0.995 ) {","\t\talpha = scaleLinear( lifeLeft, vec2( 1.0, 0.995 ), vec2( 0.0, 1.0 ) );","\t} else {","\t\talpha = lifeLeft * 0.75;","\t}","\tvec4 tex = texture2D( tSprite, gl_PointCoord );","\tgl_FragColor = vec4( vColor.rgb * tex.a, alpha * tex.a );","}"].join("\n")},t.WaterShader={uniforms:{tReflectionMap:{value:null},tRefractionMap:{value:null},tNormalMap:{value:null},textureMatrix:{value:null},time:{value:0},alpha:{value:.7},reflectivity:{value:.02},noiseScale:{value:1},distortionScale:{value:.5},waterColor:{value:null},sunColor:{value:null},sunDirection:{value:null},tHeightMap:{value:null},terrainHeight:{value:0},terrainBottom:{value:0},tFoam:{value:null},tShore:{value:null},foamRanges:{value:new THREE.Vector2},foamIntensity:{value:0},shoreRange:{value:0},shoreColor:{value:new THREE.Color}},vertexShader:"\n\t\t#include <fog_pars_vertex>\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n        varying vec4 vWaterPosition;\n\t\tvoid main() {\n\t\t    vUv = uv;\n\t\t    vCoord = textureMatrix * vec4( position, 1.0 );\n\t\t    vWaterPosition = modelMatrix * vec4( position, 1.0 );\n\t\t    vec4 mvPosition = viewMatrix * vWaterPosition; // used in fog_vertex\n            gl_Position = projectionMatrix * mvPosition;\n\t\t    #include <fog_vertex>\n\t\t}\n\t",fragmentShader:`\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap;\n\t\tuniform float time;\n\t\tuniform float alpha;\n\t\tuniform float reflectivity;\n\t\tuniform float noiseScale;\n\t\tuniform float distortionScale;\n\t\tuniform vec3 waterColor;\n\t\tuniform vec3 sunColor;\n        uniform vec3 sunDirection;\n    #ifdef USE_HEIGHTMAP\n        uniform sampler2D tHeightMap;\n        uniform float terrainHeight; // height size of terrain\n        uniform float terrainBottom; // bottom y coord of terrain\n        uniform sampler2D tFoam;\n        uniform sampler2D tShore;\n        uniform vec2 foamRanges; // x = range for shore foam, y = range for near shore foam\n        uniform float foamIntensity;\n        uniform float shoreRange;\n        uniform vec3 shoreColor;\n    #endif\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n        varying vec4 vWaterPosition;\n        vec4 getNoise( vec2 uv )\n        {\n\t\t    vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t    vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t    vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t    vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t    vec4 noise = texture2D( tNormalMap, uv0 ) +\n\t\t    \ttexture2D( tNormalMap, uv1 ) +\n\t\t    \ttexture2D( tNormalMap, uv2 ) +\n\t\t    \ttexture2D( tNormalMap, uv3 );\n\t\t    return noise * 0.5 - 1.0;\n\t\t}\n        void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor )\n        {\n\t\t    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t    specularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n        }\n    #ifdef USE_HEIGHTMAP\n        float getWaterDepth( vec2 uv, float waterY )\n        {\n            float h = texture2D( tHeightMap, uv ).x * terrainHeight;\n            return waterY - (terrainBottom + h);\n        }\n        vec3 depthRefraction( float waterDepth, vec3 waterPos, vec3 refractColor )\n        {\n            // const vec3 deepWaterColor = vec3(0.031, 0.101, 0.349);\n            const vec3 deepWaterColor = vec3(0.0, 0.007, 0.121);\n            const float waterClarity = 0.25;\n            const float visibility = 10.0;\n\n            // (cf) waterExtinction: (r,g,b) die out at water depth = (4.5(m), 75(m), 300(m))\n            // (cf) Assumed max_depth of water (in this scene) = 600 (m)\n            float extinctScale = (waterPos.y - terrainBottom) / 600.0;\n            vec3 waterExtinction = vec3(4.5, 75.0, 300.0) * extinctScale;\n\n            float eyeToWater = length( cameraPosition - waterPos );\n            float eyeToBottom = cameraPosition.y - terrainBottom;\n            float viewWaterDepth = eyeToWater * waterDepth / (eyeToBottom - waterDepth);\n\n            float accDepth = viewWaterDepth * waterClarity; // accumulated water depth\n            float accDepthExp = saturate( accDepth / (2.5 * visibility) );\n            // accDepthExp *= (1.0 - accDepthExp) * accDepthExp * accDepthExp + 1.0; // out cubic\n\n            float shoreRange = max( foamRanges.x, foamRanges.y ) * 2.0;\n            vec3 waterColorS = mix( shoreColor, waterColor, saturate(waterDepth/shoreRange) );\n            vec3 waterColorD = mix( waterColorS, deepWaterColor, saturate(waterDepth/waterExtinction) );\n\n            refractColor = mix( refractColor, waterColorS * waterColorD, saturate(accDepth/visibility) );\n            refractColor = mix( refractColor, deepWaterColor, accDepthExp );\n            refractColor = mix( refractColor, deepWaterColor * waterColorD, saturate(waterDepth/waterExtinction) );\n            return refractColor;\n        }\n        float foamColor( sampler2D tex, vec2 uv, vec2 uv2, vec2 ranges, vec2 factors, float waterDepth, float baseColor )\n        {\n            float f1 = texture2D(tex, uv).r;\n            float f2 = texture2D(tex, uv2).r;\n            return mix( f1*factors.x + f2*factors.y, baseColor, smoothstep(ranges.x, ranges.y, waterDepth) );\n        }\n        float foamValue( float waterDepth, vec3 waterPos )\n        {\n            const float foamSpeed = 10.0;\n            const vec2 foamNoise = vec2(0.37, 0.5); // (shore,outer)\n            const vec2 noiseSpeed = vec2(-0.3, 0.05); // (shore,outer)\n            const vec2 foamTiling = vec2(2.0, 0.5);\n\n            float s = sin(time*0.01 + waterPos.x);\n            vec2 uv = waterPos.xz + foamSpeed + s * 0.05;\n            s = sin(time*0.01 + waterPos.z);\n            vec2 uv2 = (waterPos.xz + foamSpeed*1.5 + s * 0.05) * 0.5;\n            vec2 uv3 = uv * foamTiling.x;\n            vec2 uv4 = (waterPos.xz + foamSpeed*1.5*(-0.3) + s * 0.05) * 0.5 * foamTiling.y;\n            uv *= foamTiling.y;\n            uv2 *= foamTiling.y;\n\n            vec2 ranges = foamRanges;\n            ranges.x += rand( waterPos.xz + noiseSpeed.x ) * foamNoise.x;\n            ranges.y += rand( waterPos.xz + noiseSpeed.y ) * foamNoise.y;\n            ranges = clamp(ranges, 0.0, 10.0);\n\n            float foamEdge = max( ranges.x, ranges.y );\n            float deepFoam = foamColor( tFoam, uv, uv2, vec2(ranges.x, foamEdge), vec2(1.0, 0.5), waterDepth, 0.0 );\n            float foam = foamColor( tShore, uv3*0.25, uv4, vec2(0.0, ranges.x), vec2(0.75, 1.5), waterDepth, deepFoam );\n            return foam;\n        }\n    #endif\n    #ifdef USE_CAUSTICS\n        ${t.ShaderChunk.caustics}\n    #endif\n        void main()\n        {\n\t\t    vec4 noise = getNoise( vWaterPosition.xz * noiseScale );\n            vec3 waterNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n            vec3 waterToEye = cameraPosition - vWaterPosition.xyz;\n            vec3 eyeDirection = normalize( waterToEye );\n\n            // fresnel\n            float dotNV = max( dot( eyeDirection, waterNormal ), 0.0 );\n            // float fresnel = mix( 1.0 - dotNV, 1.0, reflectivity ); // reflectance\n            float fresnel = mix( 0.1*(1.0 - dotNV), 1.0, reflectivity ); // reflectance\n\n            // sun light\n\t\t    vec3 diffuseLight = vec3(0.0);\n            vec3 specularLight = vec3(0.0);\n            sunLight( waterNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n            // diffuse\n            vec3 diffuseColor = saturate( diffuseLight * waterColor );\n\n            // (pure) reflection & refraction\n\t\t    vec3 coord = vCoord.xyz / vCoord.w;\n\t\t    vec2 uv = coord.xy + coord.z * waterNormal.xz * 0.05 * distortionScale;\n            vec3 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) ).rgb;\n            vec3 refractColor = texture2D( tRefractionMap, uv ).rgb;\n\n            // set reflectColor = refractColor when looking up in the water\n            reflectColor = mix( refractColor, reflectColor, step(0.0, eyeDirection.y) );\n\n        #ifdef USE_HEIGHTMAP\n            // water depth\n            float waterDepth = getWaterDepth( vUv, vWaterPosition.y );\n\n            // refract based on water depth\n            vec3 refractColorD = depthRefraction( waterDepth, vWaterPosition.xyz, refractColor );\n\n            // foam\n            float foam = foamValue( waterDepth, vWaterPosition.xyz );\n            foam *= foamIntensity;\n\n            // shoreFade\n            float shoreFade = 0.2;\n            shoreFade = saturate( waterDepth * shoreFade );\n\n            // refraction\n            refractColor = mix( refractColor, reflectColor, fresnel * saturate( waterDepth / (foamRanges.x * 0.4) ) );\n            refractColor = mix( refractColor, shoreColor, 0.30 * shoreFade );\n\n            // final color\n            vec3 color = mix( refractColorD, reflectColor, fresnel );\n            color = saturate( diffuseColor + color + max( specularLight, foam * sunColor ) );\n            color = mix( refractColor + specularLight*shoreFade, color, shoreFade );\n        #else\n            vec3 color = mix( diffuseColor + refractColor, specularLight + reflectColor, fresnel );\n        #endif\n\n        #ifdef USE_CAUSTICS\n            color += caustics( vUv, 8.0, vec3(0.0) ) * 0.5;\n        #endif\n\n            gl_FragColor = vec4( color, alpha );\n\n\t\t    #include <tonemapping_fragment>\n\t\t    #include <fog_fragment>\n\t\t}\n\t`},t.WaterFlowShader={uniforms:{tReflectionMap:{value:null},tRefractionMap:{value:null},tNormalMap0:{value:null},tNormalMap1:{value:null},textureMatrix:{value:null},config:{value:new THREE.Vector3},time:{value:0},alpha:{value:.7},reflectivity:{value:.02},noiseScale:{value:1},distortionScale:{value:.5},waterColor:{value:null},sunColor:{value:null},sunDirection:{value:null}},vertexShader:"\n\t\t#include <fog_pars_vertex>\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vWaterPosition;\n\t\tvoid main() {\n\t\t    vUv = uv;\n\t\t    vCoord = textureMatrix * vec4( position, 1.0 );\n\t\t    vWaterPosition = modelMatrix * vec4( position, 1.0 );\n\t\t    vec4 mvPosition = viewMatrix * vWaterPosition; // used in fog_vertex\n\t\t    gl_Position = projectionMatrix * mvPosition;\n\t\t    #include <fog_vertex>\n\t\t}\n\t",fragmentShader:"\n\t\t#include <common>\n\t\t#include <fog_pars_fragment>\n\t\tuniform sampler2D tReflectionMap;\n\t\tuniform sampler2D tRefractionMap;\n\t\tuniform sampler2D tNormalMap0;\n\t\tuniform sampler2D tNormalMap1;\n\t\tuniform vec3 config;\n\t\t#ifdef USE_FLOWMAP\n\t\t    uniform sampler2D tFlowMap;\n\t\t#else\n\t\t    uniform vec2 flowDirection;\n\t\t#endif\n\t\tuniform float time;\n\t\tuniform float alpha;\n\t\tuniform float reflectivity;\n\t\tuniform float noiseScale;\n\t\tuniform float distortionScale;\n\t\tuniform vec3 waterColor;\n\t\tuniform vec3 sunColor;\n\t\tuniform vec3 sunDirection;\n\t\tvarying vec4 vCoord;\n\t\tvarying vec2 vUv;\n\t\tvarying vec4 vWaterPosition;\n\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t    vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t    float direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t    specularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t    diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t}\n\t\tvoid main() {\n\t\t    float flowMapOffset0 = config.x;\n\t\t    float flowMapOffset1 = config.y;\n\t\t    float halfCycle = config.z;\n\t\t    vec3 waterToEye = cameraPosition - vWaterPosition.xyz;\n\t\t    vec3 eyeDirection = normalize( waterToEye );\n\t\t    vec2 flow;\n\t\t    #ifdef USE_FLOWMAP\n\t\t    \tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\n\t\t    #else\n\t\t    \tflow = flowDirection;\n\t\t    #endif\n\t\t    flow.x *= - 1.0;\n\t\t    vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * noiseScale ) + flow * flowMapOffset0 );\n\t\t    vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * noiseScale ) + flow * flowMapOffset1 );\n\t\t    float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\n\t\t    vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\n\t\t    vec3 waterNormal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n\t\t    vec3 diffuseLight = vec3(0.0);\n\t\t    vec3 specularLight = vec3(0.0);\n\t\t    sunLight( waterNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\t\t    float dotNV = max( dot( eyeDirection, waterNormal ), 0.0 );\n\t\t    float reflectance = mix( 1.0 - dotNV, 1.0, reflectivity ); // fresnel\n\t\t    vec3 coord = vCoord.xyz / vCoord.w;\n\t\t    vec2 uv = coord.xy + coord.z * waterNormal.xz * 0.05 * distortionScale;\n\t\t    vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\n\t\t    vec4 refractColor = texture2D( tRefractionMap, uv );\n\t\t    vec3 reflected = reflectColor.rgb + specularLight;\n\t\t    vec3 refracted = refractColor.rgb + diffuseLight * waterColor;\n\t\t    vec3 color = mix( refracted, reflected, reflectance );\n\t\t    gl_FragColor = vec4( color, alpha );\n\t\t    #include <tonemapping_fragment>\n\t\t    #include <fog_fragment>\n\t\t}\n\t"},t.NoiseShader={uniforms:{scale:{value:10}},vertexShader:["varying vec3 vPosition;","varying vec2 vUv;","void main() {","vPosition = normalize(position);","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);","}"].join("\n"),fragmentShader:["varying vec3 vPosition;","varying vec2 vUv;","uniform float scale;",t.ShaderChunk.mod289,t.ShaderChunk.permute,t.ShaderChunk.taylorInvSqrt,t.ShaderChunk.snoise3,"void main() {","float n = snoise(vPosition * scale);","n = n*0.5 + 0.5;","gl_FragColor = vec4(n, n, n, 1.0);","}"].join("\n")},t.TerrainHeightShader={uniforms:{landscape:{value:5},scale:{value:new THREE.Vector2(1.5,1.5)},offset:{value:new THREE.Vector2(0,0)}},vertexShader:["uniform vec2 scale;","uniform vec2 offset;","varying vec2 vUv;","void main( void ) {","vUv = uv * scale + offset;","gl_Position = projectionMatrix * (modelViewMatrix * vec4( position, 1.0 ));","}"].join("\n"),fragmentShader:["uniform int landscape;","varying vec2 vUv;",t.ShaderChunk.hash,t.ShaderChunk.noise2,t.ShaderChunk.mod289,t.ShaderChunk.permute,t.ShaderChunk.snoise2,t.ShaderChunk.fbm2IQ,"#define BADLAND_TERRAIN\t\t0\t// used for bandland terrains","#define MOUNTAIN_TERRAIN\t\t1\t// used for mountainous terrains","#define DOME_TERRAIN\t\t\t2\t// used for dome-shaped terrains","#define RIDGE_TERRAIN\t\t\t3\t// used for sharp-shaped terrains","#define DESIGN_TERRAIN\t\t\t4\t// used for user-defined terrains","#define GIANT_TERRAIN\t\t\t5\t// used for giant terrains","#define TRIANGLE_TERRAIN\t\t6\t// used for triangle terrains","float badlandTerrain(vec2 p){","const int octaves = 5;","float flatten = 1.0;","mat2 m2 = mat2(0.8,-0.6,0.6,0.8);","float a = 0.0;","float b = 0.5;","float d = 0.0;","for(int i=0; i<octaves; i++)","{","float n = snoise(p);","d += n;","a += b*n/(1.0+d*d);","b *= 0.5;","p = m2*(p*2.0);","}","return pow(a, flatten);","}","float mountainTerrain(vec2 p){","const int octaves = 5;","float flatten = 2.0;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","v += a * snoise(p);","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v*0.5 + 0.5, flatten);","}","float domeTerrain(vec2 p){","const int octaves = 2;","float flatten = 1.5;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","v += a * abs( snoise(p) );","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v, flatten);","}","float ridgeTerrain(vec2 p){","const int octaves = 5;","float flatten = 2.0;","float v = 0.0;","float a = 0.5;","vec2 shift = vec2(100.0);","for(int i=0; i<octaves; i++)","{","float n = 1.0 - abs( snoise(p) );","v += a * (n*n);","p = p * 2.0 + shift;","a *= 0.5;","}","return pow(v, flatten);","}","float designTerrain(vec2 p){","float ridgeTerrain = ridgeTerrain(p*9.0);","float flatTerrain = mountainTerrain(p*2.0);","float ctrlTerrain = domeTerrain(p);","ctrlTerrain += 0.25 * ctrlTerrain;","float e = ctrlTerrain / 100.0;","const float b = 0.5;","const float off = 0.05;","return mix( flatTerrain, ridgeTerrain, smoothstep(b-off, b+off, e) );","}","float giantTerrain(vec2 p){","mat2 m2 = mat2(1.3623, 1.7531, -1.7131, 1.4623);","const int octaves = 5;","float flatten = 2.0;","vec2 pos = p*5.0;","float w = fbmIQ(pos*0.25)*0.75+0.25;","w = 2.0 * w * w;","float f = 0.0;","for(int i = 0; i < octaves; i++){","f += w * fbmIQ(pos);","w = -w * 0.5;","pos = m2 * pos;","}","float ff = fbmIQ(pos*0.002);","f += pow(abs(ff), 10.0);","return pow(f, flatten);","}","float tri(float x){ return abs(fract(x)-0.5); }","float triXY(vec2 p){ return tri(p.x+tri((p.y-0.25)*1.5)) + tri(p.y-tri((p.x+0.5)*1.5)); }","float triSmooth(float x){ return 0.25+0.25*cos((x)*6.2831853); }","float triSmoothXY(vec2 p){ return triSmooth(p.x+triSmooth((p.y-0.25)*1.5)) + triSmooth(p.y-triSmooth((p.x+0.5)*1.5)); }","float smoothCurve(float x) {","x = max((x - 0.3)/0.7, 0.0);","return x*x*(3.0 - 2.0*x);","}","float triangleTerrain(vec2 p){","p *= 2.0;","float h = triSmoothXY( p/2.0 )*0.66 + triSmoothXY( p/1.0 )*0.34;","h = smoothCurve( h )*0.75 + triXY( p/1.0 )*0.15 + triXY( p*4.0 )*0.1;","return h * 0.75;","}","float terrain( int type, vec2 p ){","float h = 0.0;","p *= 3.0;","if( type == BADLAND_TERRAIN ) h = badlandTerrain(p);","else if( type == MOUNTAIN_TERRAIN ) h = mountainTerrain(p);","else if( type == DOME_TERRAIN ) h = domeTerrain(p);","else if( type == RIDGE_TERRAIN ) h = ridgeTerrain(p);","else if( type == DESIGN_TERRAIN ) h = designTerrain(p);","else if( type == GIANT_TERRAIN ) h = giantTerrain(p);","else if( type == TRIANGLE_TERRAIN ) h = triangleTerrain(p);","return h;","}","void main(){","float h = terrain( landscape, vUv );","gl_FragColor = vec4( h, h, h, 1.0 );","}"].join("\n")},t.TerrainNormalShader={uniforms:{tHeight:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tHeight;","varying vec2 vUv;","float terrainHeight( in sampler2D tex, in vec2 uv ) {","return texture2D( tex, uv ).x;","}","vec3 terrainNormal( in sampler2D tex, in vec3 p, in float tol ) {","vec2 eps = vec2( 0.002*tol, 0.0 );","return normalize( vec3(","terrainHeight(tex, p.xz-eps.xy) - terrainHeight(tex, p.xz+eps.xy),","2.0*eps.x,","terrainHeight(tex, p.xz-eps.yx) - terrainHeight(tex, p.xz+eps.yx)));","}","void main() {","vec3 normal = terrainNormal( tHeight, vec3( vUv.x, 0.0, vUv.y ), 1.0 );","gl_FragColor = vec4( 0.5*normal.xzy + 0.5, 1.0 );","}"].join("\n")},t.CurlNoiseParticleShader={uniforms:{time:{value:0},tPosition:{value:null},color1:{value:null},color2:{value:null},opacity:{value:.75},sizeBase:{value:0},sizeExtra:{value:9.9},hardness:{value:.16},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(0,1,0)}},vertexShader:["varying float vColor;","varying float vAlpha;","uniform sampler2D tPosition;","uniform float opacity;","uniform float sizeBase;","uniform float sizeExtra;","uniform vec3 emitPos;","uniform vec3 emitVec;",t.ShaderChunk.random,"void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec3 pos = texture2D( tPosition, uv ).xyz;","float t = dot(emitDir, pos - emitPos);","if( t < 0.0 ) { pos = pos - t*emitDir; t = 0.0; }","vec3 tpos = emitPos + t*emitDir;","vec3 rvec = pos - tpos;","float r = (1.0 - cos(smoothstep(0.0, 0.2*emitLength, t) * 3.141592654)) * 0.5;","pos = pos + (r-1.0) * rvec;","vColor = random(uv + vec2(23.0, 31.22));","gl_Position = projectionMatrix * viewMatrix  * vec4( pos, 1.0 );","vAlpha = smoothstep(0.8*emitLength + 0.2*emitLength*random(uv + 1.0), 0.7*emitLength, t);","vAlpha *= clamp(1000.0 / gl_Position.z, 0.0, 1.0) * opacity;","gl_PointSize = (sizeBase + random(uv) * sizeExtra) * (500.0 / gl_Position.z);","}"].join("\n"),fragmentShader:["varying float vColor;","varying float vAlpha;","uniform vec3 color1;","uniform vec3 color2;","uniform float hardness;","uniform float time;","void main() {","float d = length(gl_PointCoord.xy - .5) * 2.0;","if( d > 1.0 ) discard;","float c = 1.0 - smoothstep(hardness, 1.0, d);","gl_FragColor = vec4(mix(color1, color2, vColor) * c, 1.0) * vAlpha;","}"].join("\n")},t.CurlNoiseCopyShader={uniforms:{resolution:{value:null},texture:{value:null}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D texture;","void main() {","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 color = texture2D( texture, uv ).xyz;","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")},t.CurlNoiseVelocityShader={uniforms:{time:{value:0},tPosition:{value:null},resolution:{value:null},speed:{value:1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tPosition;","uniform float speed;","uniform vec3 emitPos;","uniform vec3 emitVec;",t.ShaderChunk.mod289,t.ShaderChunk.permute,t.ShaderChunk.taylorInvSqrt,t.ShaderChunk.snoise3,t.ShaderChunk.random,"vec3 snoiseVec3( vec3 x ){","float s  = snoise(vec3( x ));","float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));","float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));","vec3 c = vec3( s , s1 , s2 );","return c;","}","vec3 curlNoise( vec3 p ){","const float e = .1;","vec3 dx = vec3( e   , 0.0 , 0.0 );","vec3 dy = vec3( 0.0 , e   , 0.0 );","vec3 dz = vec3( 0.0 , 0.0 , e   );","vec3 p_x0 = snoiseVec3( p - dx );","vec3 p_x1 = snoiseVec3( p + dx );","vec3 p_y0 = snoiseVec3( p - dy );","vec3 p_y1 = snoiseVec3( p + dy );","vec3 p_z0 = snoiseVec3( p - dz );","vec3 p_z1 = snoiseVec3( p + dz );","float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;","float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;","float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;","const float divisor = 1.0 / ( 2.0 * e );","return normalize( vec3( x , y , z ) * divisor );","}","void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = curlNoise(position * 0.02) * 0.1;","float t = dot(emitDir, position - emitPos);","float v = pow(smoothstep(0.0, emitLength, t), 2.0);","v = 0.05 + v * (0.2 + random(uv) * 0.2);","v = clamp(v, 0.01, 5.0);","velocity += emitDir * v;","velocity *= speed;","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},t.CurlNoiseVelocity4dShader={uniforms:{time:{value:0},tPosition:{value:null},resolution:{value:null},speed:{value:1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tPosition;","uniform float time;","uniform float speed;","uniform vec3 emitPos;","uniform vec3 emitVec;",t.ShaderChunk.mod289,t.ShaderChunk.permute,t.ShaderChunk.taylorInvSqrt,t.ShaderChunk.grad4,t.ShaderChunk.snoise4,t.ShaderChunk.random,"vec4 snoiseVec4( vec4 x ){","float s  = snoise(vec4( x ));","float s1 = snoise(vec4( x.y - 19.1 , x.z + 33.4 , x.w + 47.2 , x.x + 12.2 ));","float s2 = snoise(vec4( x.z + 74.2 , x.w - 124.5 , x.x + 99.4 , x.y - 123.2 ));","float s3 = snoise(vec4( x.w + 21.2 , x.x - 52.5 , x.y + 60.4 , x.z + 42.2 ));","vec4 c = vec4( s , s1 , s2 , s3 );","return c;","}","vec4 curlNoise( vec4 p ){","const float e = .1;","vec4 dx = vec4( e   , 0.0 , 0.0 , 0.0 );","vec4 dy = vec4( 0.0 , e   , 0.0 , 0.0 );","vec4 dz = vec4( 0.0 , 0.0 , e   , 0.0 );","vec4 dw = vec4( 0.0 , 0.0 , 0.0 , e  );","vec4 p_x0 = snoiseVec4( p - dx );","vec4 p_x1 = snoiseVec4( p + dx );","vec4 p_y0 = snoiseVec4( p - dy );","vec4 p_y1 = snoiseVec4( p + dy );","vec4 p_z0 = snoiseVec4( p - dz );","vec4 p_z1 = snoiseVec4( p + dz );","vec4 p_w0 = snoiseVec4( p - dw );","vec4 p_w1 = snoiseVec4( p + dw );","float x = p_y1.z - p_y0.z - p_z1.w + p_z0.w + p_w0.y - p_w1.y;","float y = p_z1.w - p_z0.w - p_w1.x + p_w0.x + p_x0.z - p_x1.z;","float z = p_w1.x - p_w0.x - p_x1.y + p_x0.y + p_y0.w - p_y1.w;","float w = p_x1.y - p_x0.y - p_y1.z + p_y0.z + p_z0.x - p_y1.x;","const float divisor = 1.0 / ( 2.0 * e );","return normalize( vec4( x , y , z, w ) * divisor );","}","void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = curlNoise(vec4(position * 0.02, time * 0.001 * speed)).xyz * 0.1;","float t = dot(emitDir, position - emitPos);","float l = pow(smoothstep(0.0, emitLength, t), 2.0);","l = 0.05 + l * (0.2 + random(uv) * 0.2);","l = clamp(l, 0.01, 5.0);","velocity += emitDir * l;","velocity *= speed;","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},t.CurlNoisePositionShader={uniforms:{delta:{value:0},tPosition:{value:null},tVelocity:{value:null},resolution:{value:null},spread:{value:.1},emitPos:{value:new THREE.Vector3(0,0,0)},emitVec:{value:new THREE.Vector3(1,0,0)}},vertexShader:["void main() {","gl_Position = vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 resolution;","uniform sampler2D tVelocity;","uniform sampler2D tPosition;","uniform float delta;","uniform vec3 emitPos;","uniform vec3 emitVec;","uniform float spread;",t.ShaderChunk.random,"void main() {","float emitLength = length(emitVec);","vec3 emitDir = emitVec / emitLength;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 position = texture2D( tPosition, uv ).xyz;","vec3 velocity = texture2D( tVelocity, uv ).xyz;","position += velocity * delta * 1.0;","float t = dot(emitDir, position - emitPos);","if(t > emitLength) {","position = emitPos;","position.x += emitLength*spread*(random(uv + vec2(21.3, 63.21))-0.5);","position.y += emitLength*spread*(random(uv + vec2(32.3, 734.21))-0.5);","position.z += emitLength*spread*(random(uv + vec2(127.3, 31.21))-0.5);","}","gl_FragColor = vec4( position, 1.0 );","}"].join("\n")},t.ShaderChunk.fishAnimation=["#define twoPI 6.28318530718","vec3 fishAnimation( vec3 position )","{","float wave_factor = 0.0001;","float twist_factor = 0.0001;","float bend_factor = 0.1;","float speed_factor = 1.0 + 3.0 * smoothstep( 20.0, 0.1, fishLength );","float curTime = time * speed_factor + fishSpeed;","vec3 new_pos = position;","vec3 tmp_pos = position;","float head_z = fishLength/2.0;","float tail_z = -fishLength/2.0;","float z = position.z;","z = (z - head_z) / (tail_z - head_z);","z = smoothstep( 0.0, 1.0, z );","float wave_ang = cos( (curTime - z) * twoPI ) * wave_factor * z;","new_pos.x += wave_ang;","float twist_ang = cos( (curTime - z) * twoPI ) * twist_factor;","float twist_cos = cos( twist_ang );","float twist_sin = sin( twist_ang );","tmp_pos.x = new_pos.x * twist_cos - new_pos.y * twist_sin;","tmp_pos.y = new_pos.x * twist_sin + new_pos.y * twist_cos;","new_pos = tmp_pos;","float bend_ang = cos( (curTime - z) * twoPI ) * bend_factor * z;","float bend_cos = cos( bend_ang );","float bend_sin = sin( bend_ang );","tmp_pos.x = new_pos.x * bend_cos - new_pos.z * bend_sin;","tmp_pos.z = new_pos.x * bend_sin + new_pos.z * bend_cos;","new_pos = tmp_pos;","return new_pos;","}"].join("\n"),t.BoidsPositionShader={uniforms:{time:{value:0},delta:{value:0},bounds:{value:new THREE.Vector3(1e3,1e3,1e3)},central:{value:new THREE.Vector3(0,0,0)}},fragmentShader:["uniform float time;","uniform float delta;","uniform vec3 bounds;","uniform vec3 central;","void main() {","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec4 tmpPos = texture2D( tPosition, uv );","vec3 position = tmpPos.xyz;","vec3 velocity = texture2D( tVelocity, uv ).xyz;","float phase = tmpPos.w;","phase = mod( ( phase + delta +","length( velocity ) * delta * 6.0 ), 62.83 );","vec3 fragPos = position + velocity * delta * 15.0;","vec3 minBound = central - bounds * 0.5;","vec3 maxBound = central + bounds * 0.5;","fragPos = clamp( fragPos, minBound, maxBound );","gl_FragColor = vec4( fragPos, phase );","}"].join("\n")},t.BoidsVelocityShader={uniforms:{time:{value:0},delta:{value:0},seperationDistance:{value:20},alignmentDistance:{value:20},cohesionDistance:{value:20},bounds:{value:new THREE.Vector3(1e3,1e3,1e3)},central:{value:new THREE.Vector3(0,0,0)},speedLimit:{value:9},predator:{value:new THREE.Vector3}},fragmentShader:["uniform float time;","uniform float delta;","uniform float seperationDistance;","uniform float alignmentDistance;","uniform float cohesionDistance;","uniform vec3 bounds;","uniform vec3 central;","uniform float speedLimit;","uniform vec3 predator;","const float width = resolution.x;","const float height = resolution.y;","const float PI = 3.141592653589793;","const float PI_2 = PI * 2.0;","float zoneRadius = 40.0;","float zoneRadiusSquared = 1600.0;","float separationThresh = 0.45;","float alignmentThresh = 0.65;","float rand(vec2 co){","return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);","}","void main() {","zoneRadius = seperationDistance + alignmentDistance + cohesionDistance;","separationThresh = seperationDistance / zoneRadius;","alignmentThresh = ( seperationDistance + alignmentDistance ) / zoneRadius;","zoneRadiusSquared = zoneRadius * zoneRadius;","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec3 birdPosition, birdVelocity;","vec3 selfPosition = texture2D( tPosition, uv ).xyz;","vec3 selfVelocity = texture2D( tVelocity, uv ).xyz;","float dist;","vec3 dir;","float distSquared;","float seperationSquared = seperationDistance * seperationDistance;","float cohesionSquared = cohesionDistance * cohesionDistance;","float f;","float percent;","vec3 velocity = selfVelocity;","float limit = speedLimit;","dir = predator * bounds - selfPosition;","dist = length( dir );","distSquared = dist * dist;","float preyRadius = 50.0;","float preyRadiusSq = preyRadius * preyRadius;","if (dist < preyRadius) {","f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 10.0;","velocity += normalize( dir ) * f;","limit = min( limit*3.0, limit+5.0 );","}","dir = selfPosition - central;","dist = length( dir );","velocity -= normalize( dir ) * delta * 5.0;","for( float y = 0.0; y < height; y++ )","{","for( float x = 0.0; x < width; x++)","{","vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;","birdPosition = texture2D( tPosition, ref ).xyz;","dir = birdPosition - selfPosition;","dist = length(dir);","if (dist < 0.0001) continue;","distSquared = dist * dist;","if (distSquared > zoneRadiusSquared ) continue;","percent = distSquared / zoneRadiusSquared;","if ( percent < separationThresh ) { // low","f = (separationThresh / percent - 1.0) * delta;","velocity -= normalize(dir) * f;","} else if ( percent < alignmentThresh ) { // high","float threshDelta = alignmentThresh - separationThresh;","float adjustedPercent = ( percent - separationThresh ) / threshDelta;","birdVelocity = texture2D( tVelocity, ref ).xyz;","f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;","velocity += normalize(birdVelocity) * f;","} else {","float threshDelta = 1.0 - alignmentThresh;","float adjustedPercent = ( percent - alignmentThresh ) / threshDelta;","f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;","velocity += normalize(dir) * f;","}","}","}","if ( length( velocity ) > limit ) {","velocity = normalize( velocity ) * limit;","}","gl_FragColor = vec4( velocity, 1.0 );","}"].join("\n")},t.BoidsDrawShader={uniforms:{time:{value:0},boidType:{value:0},boidLength:{value:0},color:{value:new THREE.Color(16777215)},tDiffuse:{value:new THREE.Texture},tSpecular:{value:new THREE.Texture},tPosition:{value:new THREE.Texture},tVelocity:{value:new THREE.Texture}},vertexShader:["#define twoPI 6.28318530718","attribute vec2 boidSite;","attribute vec3 boidColor;","attribute float boidVertex;","uniform int boidType;","uniform float boidLength;","uniform sampler2D tPosition;","uniform sampler2D tVelocity;","uniform float time;","varying vec3 vNormal;","varying vec2 vUv;","varying vec4 vColor;","varying vec3 vViewPosition;","vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {","    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );","}",THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.fog_pars_vertex,t.ShaderChunk.random,"vec3 fishAnimation( vec3 pos )","{","float r = random( boidSite );","float h = r - 0.5;","float wave_factor = 0.4;","float twist_factor = 0.3 * h;","float bend_factor = 0.2 * h;","float speed_factor = length( texture2D( tVelocity, boidSite ).xyz );","speed_factor = log(speed_factor + 1.0) * 3.0;","speed_factor = clamp( speed_factor, 1.0, 3.0 );","float curTime = time * speed_factor;","vec3 new_pos = pos;","vec3 tmp_pos = pos;","float head_z = boidLength/2.0;","float tail_z = -boidLength/2.0;","float z = pos.z;","z = (z - head_z) / (tail_z - head_z);","z = smoothstep( 0.0, 1.0, z );","float wave_ang = sin( (curTime - z) * twoPI ) * wave_factor * z;","new_pos.x += wave_ang;","float twist_ang = sin( (curTime - z) * twoPI ) * twist_factor;","float twist_cos = cos( twist_ang );","float twist_sin = sin( twist_ang );","tmp_pos.x = new_pos.x * twist_cos - new_pos.y * twist_sin;","tmp_pos.y = new_pos.x * twist_sin + new_pos.y * twist_cos;","new_pos = tmp_pos;","float bend_ang = sin( (curTime) * twoPI ) * bend_factor * z;","float bend_cos = cos( bend_ang );","float bend_sin = sin( bend_ang );","tmp_pos.x = new_pos.x * bend_cos - new_pos.z * bend_sin;","tmp_pos.z = new_pos.x * bend_sin + new_pos.z * bend_cos;","new_pos = tmp_pos;","return new_pos;","}","void main() {","vec4 tmpPos = texture2D( tPosition, boidSite );","vec3 pos = tmpPos.xyz;","vec3 velocity = normalize(texture2D( tVelocity, boidSite ).xyz);","vec3 newPosition = position;","if( boidType == 0 ) {","if ( boidVertex == 4.0 || boidVertex == 7.0 ) {","newPosition.y = sin( tmpPos.w ) * 5.0;","}","}","else {","newPosition = fishAnimation( position );","}","newPosition = mat3( modelMatrix ) * newPosition;","velocity.z *= -1.0;","float xz = length( velocity.xz );","float xyz = 1.0;","float x = sqrt( 1.0 - velocity.y * velocity.y );","float cosry = velocity.x / xz;","float sinry = velocity.z / xz;","float cosrz = x / xyz;","float sinrz = velocity.y / xyz;","mat3 maty =  mat3(","cosry, 0.0, -sinry,","0.0  , 1.0, 0.0   ,","sinry, 0.0, cosry ",");","mat3 matz =  mat3(","cosrz , sinrz, 0.0,","-sinrz, cosrz, 0.0,","0.0   , 0.0  , 1.0 ",");","newPosition = maty * matz * newPosition;","newPosition += pos;","vec4 worldPosition = vec4( newPosition, 1.0 );","vec4 mvPosition = viewMatrix  * worldPosition;","gl_Position = projectionMatrix * mvPosition;","vViewPosition = -mvPosition.xyz;","vUv = uv;","vNormal = normalize( normalMatrix * normal );","vColor = vec4( boidColor, 1.0 );",THREE.ShaderChunk.beginnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.shadowmap_vertex,THREE.ShaderChunk.fog_vertex,"}"].join("\n"),fragmentShader:["uniform int boidType;","uniform vec3 color;","uniform sampler2D tDiffuse;","uniform sampler2D tSpecular;","varying vec3 vNormal;","varying vec2 vUv;","varying vec4 vColor;","varying vec3 vViewPosition;",THREE.ShaderChunk.common,THREE.ShaderChunk.packing,THREE.ShaderChunk.bsdfs,THREE.ShaderChunk.lights_pars_begin,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {","if ( decayExponent > 0.0 ) {","return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );","}","return 1.0;","}","void main() {","vec3 fragColor = vec3( 0.0 );","vec3 totalLd = vec3( 0.0 );","vec3 totalLs = vec3( 0.0 );","vec3 N = normalize( vNormal );","vec3 V = normalize( vViewPosition );","float shininess = 32.0;","vec3 specularTex = texture2D( tSpecular, vUv ).rgb;","#if NUM_POINT_LIGHTS > 0","for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {","vec3 L = pointLights[ i ].position + vViewPosition.xyz;","float atten = calcLightAttenuation( length( L ), pointLights[ i ].distance, pointLights[ i ].decay );","L = normalize( L );","vec3 H = normalize( L + V );","float NoH = max( dot( N, H ), 0.0 );","float diffWt = max( dot( N, L ), 0.0 );","float specWt = specularTex.r * max( pow( NoH, shininess ), 0.0 );","totalLd += atten * pointLights[ i ].color * diffWt;","totalLs += atten * pointLights[ i ].color * specWt * diffWt;","}","#endif","#if NUM_DIR_LIGHTS > 0","for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {","vec3 Lc = directionalLights[ i ].color;","vec3 L = directionalLights[ i ].direction;","vec3 H = normalize( L + V );","float NoH = max( dot( N, H ), 0.0 );","float NoL = max( dot( N, L ), 0.0 );","totalLd += Lc * NoL;","totalLs += Lc * NoL * specularTex * max( pow( NoH, shininess ), 0.0 );","}","#endif","#if NUM_HEMI_LIGHTS > 0","for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {","vec3 L = hemisphereLights[ i ].direction;","vec3 gndLc = hemisphereLights[ i ].groundColor;","vec3 skyLc = hemisphereLights[ i ].skyColor;","float NoL = dot( N, L );","float diffWt = 0.5 * NoL + 0.5;","totalLd += mix( gndLc, skyLc, diffWt );","float specWt = 0.0;","vec3 skyH = normalize( L + V );","float skyNoH = 0.5 * dot( N, skyH ) + 0.5;","specWt += specularTex.r * max( pow( skyNoH, shininess ), 0.0 );","vec3 gndH = normalize( -L + V );","float gndNoH = 0.5 * dot( N, gndH ) + 0.5;","specWt += specularTex.r * max( pow( gndNoH, shininess ), 0.0 );","totalLs += mix( gndLc, skyLc, diffWt ) * specWt * diffWt;","}","#endif","vec4 albedo = vec4( 1.0 );","if( boidType == 0 ) {","albedo = vec4( mix( color, vColor.rgb, 0.8 ), 1.0 );","fragColor = albedo.rgb;","}","if( boidType == 1 ) {","albedo.rgb = color * texture2D( tDiffuse, vUv ).rgb;","fragColor = albedo.rgb * ( totalLd + ambientLightColor + totalLs );","}","gl_FragColor = vec4( fragColor, albedo.a );",THREE.ShaderChunk.fog_fragment,"}"].join("\n")},t.UnderWaterShader={uniforms:{tDiffuse:{value:null},time:{value:0},distort_speed:{value:5e-4},distortion:{value:.04},centerX:{value:.5},centerY:{value:.5}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float time;","uniform float distort_speed;","uniform float distortion;","uniform float centerX;","uniform float centerY;","varying vec2 vUv;","void main() {","vec2 p = vUv;","vec2 center_coord;","float distance_to_center;","float projected_distance_to_center;","float distort_degree;","center_coord.x = p.x - centerX;","center_coord.y = p.y - centerY;","distance_to_center = sqrt(center_coord.x * center_coord.x + center_coord.y * center_coord.y);","distort_degree = abs( mod(distort_speed* time, distortion) - (distortion / 2.0)) + 1.0;","projected_distance_to_center = pow(1.0, distort_degree - 1.0) * pow(distance_to_center/1.0, distort_degree);","p.x = projected_distance_to_center * center_coord.x/ distance_to_center + centerX;","p.y = projected_distance_to_center * center_coord.y/ distance_to_center + centerY;","vec4 color = texture2D(tDiffuse, p);","gl_FragColor = color;","}"].join("\n")},t.ParticleEngineShader={uniforms:{particleTexture:{value:null}},vertexShader:["attribute vec3  customColor;","attribute float customOpacity;","attribute float customSize;","attribute float customAngle;","attribute float customVisible;","varying vec4  vColor;","varying float vAngle;","void main()","{","if ( customVisible > 0.5 )","vColor = vec4( customColor, customOpacity );","else","vColor = vec4(0.0, 0.0, 0.0, 0.0);","vAngle = customAngle;","vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );","gl_PointSize = customSize * ( 300.0 / length( mvPosition.xyz ) );","gl_Position = projectionMatrix * mvPosition;","}"].join("\n"),fragmentShader:["uniform sampler2D particleTexture;","varying vec4 vColor;","varying float vAngle;","void main()","{","gl_FragColor = vColor;","float c = cos(vAngle);","float s = sin(vAngle);","vec2 rotatedUV = vec2(c * (gl_PointCoord.x - 0.5) + s * (gl_PointCoord.y - 0.5) + 0.5,","c * (gl_PointCoord.y - 0.5) - s * (gl_PointCoord.x - 0.5) + 0.5);","vec4 rotatedTexture = texture2D( particleTexture, rotatedUV );","gl_FragColor = gl_FragColor * rotatedTexture;","}"].join("\n")},t.TerrainLODShader={uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,{diffuse:{value:new THREE.Color(16777215)},specular:{value:new THREE.Color(16777215)},shininess:{value:30},opacity:{value:1},enableDiffuse1:{value:!0},enableDiffuse2:{value:!0},enableSpecular:{value:!1},tDiffuse1:{value:null},tDiffuse2:{value:null},tSpecular:{value:null},uvRepeatOverlay:{value:new THREE.Vector2(1,1)},uvOffset:{value:new THREE.Vector2(0,0)},worldWidth:{value:1024},tileResolution:{value:64},edgeMorph:{value:0},globalOffset:{value:null},tileOffset:{value:null},heightMap:{value:null},tileScale:{value:64},maxHeight:{value:100},winterSnow:{value:!1},summerGreen:{value:!1}}]),vertexShader:["uniform float worldWidth;","uniform float tileResolution;","uniform vec3 globalOffset;","uniform vec2 tileOffset;","uniform sampler2D heightMap;","uniform float tileScale;","uniform float maxHeight;","varying float vMorphFactor;","varying vec3 vPosition;","varying vec2 vUv;","varying vec3 vViewPosition;","vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {","    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );","}",THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.fog_pars_vertex,"float getHeight(vec3 p) {","float lod = 1.0;","vec2 st = p.xy / worldWidth;","float h = 1024.0 * texture2DLodEXT(heightMap, st, lod).r;","h += 64.0 * texture2DLodEXT(heightMap, 16.0 * st, lod).r;","h += 4.0 * texture2DLodEXT(heightMap, 256.0 * st, lod).r;","return h / 1092.0 * maxHeight;","}","#define EGDE_MORPH_TOP    1","#define EGDE_MORPH_LEFT   2","#define EGDE_MORPH_BOTTOM 4","#define EGDE_MORPH_RIGHT  8","#define MORPH_REGION      0.3","uniform int edgeMorph;","bool edgePresent(int edge) {","int e = edgeMorph / edge;","return 2 * ( e / 2 ) != e;","}","float calculateMorph(vec3 p) {","float morphFactor = 0.0;","if( edgePresent(EGDE_MORPH_TOP) && p.y >= 1.0 - MORPH_REGION ) {","float m = 1.0 - clamp((1.0 - p.y) / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_LEFT) && p.x <= MORPH_REGION ) {","float m = 1.0 - clamp(p.x / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_BOTTOM) && p.y <= MORPH_REGION ) {","float m = 1.0 - clamp(p.y / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","if( edgePresent(EGDE_MORPH_RIGHT) && p.x >= 1.0 - MORPH_REGION ) {","float m = 1.0 - clamp((1.0 - p.x) / MORPH_REGION, 0.0, 1.0);","morphFactor = max(m, morphFactor);","}","return morphFactor;","}","void main() {","vMorphFactor = calculateMorph(position);","vPosition = tileScale * position + vec3(tileOffset, 0.0) + globalOffset;","float grid = tileScale / tileResolution;","vPosition = floor(vPosition / grid) * grid;","if( vMorphFactor > 0.0 ) {","grid = 2.0 * grid;","vec3 position2 = floor(vPosition / grid) * grid;","vPosition = mix(vPosition, position2, vMorphFactor);","}","vPosition = vPosition + normal * getHeight(vPosition);","vec4 mvPosition =  modelViewMatrix * vec4( vPosition, 1.0 );","gl_Position = projectionMatrix * mvPosition;","vUv = uv;","vPosition.xyz = vPosition.yzx;","vViewPosition.xyz = -mvPosition.yzx;","#if defined (USE_SHADOWMAP)","vec4 worldPosition = modelMatrix * vec4( vPosition, 1.0 );","#endif",THREE.ShaderChunk.beginnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.shadowmap_vertex,THREE.ShaderChunk.fog_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;","uniform vec3 specular;","uniform float shininess;","uniform float opacity;","uniform bool enableDiffuse1;","uniform bool enableDiffuse2;","uniform bool enableSpecular;","uniform sampler2D tDiffuse1;","uniform sampler2D tDiffuse2;","uniform sampler2D tSpecular;","uniform vec2 uvRepeatOverlay;","uniform vec2 uvOffset;","uniform float worldWidth;","uniform sampler2D heightMap;","uniform float maxHeight;","uniform bool winterSnow;","uniform bool summerGreen;","varying float vMorphFactor;","varying vec3 vPosition;","varying vec2 vUv;","varying vec3 vViewPosition;",THREE.ShaderChunk.common,THREE.ShaderChunk.packing,THREE.ShaderChunk.bsdfs,THREE.ShaderChunk.lights_pars_begin,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,"float getHeight(vec3 p) {","vec2 st = p.zx / worldWidth;","float h = 1024.0 * texture2D(heightMap, st).r;","h += 64.0 * texture2D(heightMap, 16.0 * st).r;","h += 4.0 * texture2D(heightMap, 256.0 * st).r;","return h / 1092.0 * maxHeight;","}","vec3 getNormal() {","float height = getHeight( vPosition );","vec3 p = vec3( vPosition.x, height, vPosition.z );","vec3 dPositiondx = dFdx(p);","vec3 dPositiondy = dFdy(p);","return normalize(cross(dPositiondx, dPositiondy));","}","float calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {","if ( decayExponent > 0.0 && cutoffDistance > 0.0 ) {","return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), 2.0 );","}","return 1.0;","}","void main() {","vec4 diffuseColor = vec4( diffuse, opacity );","vec3 specularTex = vec3( 1.0 );","vec2 uvOverlay = uvRepeatOverlay * vUv + uvOffset;","vec3 viewPosition = normalize( vViewPosition );","vec3 normal = getNormal();","vec3 outgoingLight = vec3( 0.0 );","vec3 totalDiffuseLight = vec3( 0.0 );","vec3 totalSpecularLight = vec3( 0.0 );","if( enableDiffuse1 && enableDiffuse2 ) {","vec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );","vec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );","colDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );","colDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );","diffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - getHeight( vPosition ) / worldWidth );","} else if( enableDiffuse1 ) {","diffuseColor *= texture2D( tDiffuse1, uvOverlay );","} else if( enableDiffuse2 ) {","diffuseColor *= texture2D( tDiffuse2, uvOverlay );","}","if( enableSpecular )","specularTex = texture2D( tSpecular, uvOverlay ).xyz;","if( winterSnow )","{","vec3 snowColor = vec3( 0.93, 0.97, 1.0 );","float snowStick = dot( vec3( 0.0, 1.0, 0.0 ), normal );","snowStick = pow( snowStick, 3.0 );","snowStick = step( 0.2, snowStick );","diffuseColor.xyz = mix( diffuseColor.xyz, snowColor, snowStick );","}","if( summerGreen )","{","vec3 water = vec3( 0.0, 0.12, 0.06 );","vec3 grass = vec3( 0.07, 0.43, 0.08 );","vec3 rock = vec3( 0.31, 0.11, 0.09 );","float grassStick = dot( vec3( 0.0, 1.0, 0.0 ), normal );","float stickExponent = 1.2 + 1.8 * float( winterSnow );","grassStick = pow( grassStick, stickExponent );","float minVal = 0.2 + 0.1 * float( winterSnow );","grassStick = step( minVal, grassStick );","vec3 waterGrass = mix( water, grass, smoothstep( 7.0, 14.0, vPosition.y ) );","vec3 rockWaterGrass = mix( rock, waterGrass, 0.5 );","diffuseColor.xyz = mix( diffuseColor.xyz, rockWaterGrass, grassStick );","}","#if NUM_POINT_LIGHTS > 0","for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {","vec3 lVector = pointLights[ i ].position + vViewPosition.xyz;","float attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );","lVector = normalize( lVector );","vec3 pointHalfVector = normalize( lVector + viewPosition );","float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );","float pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );","float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );","totalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;","totalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;","}","#endif","#if NUM_DIR_LIGHTS > 0","vec3 dirDiffuse = vec3( 0.0 );","vec3 dirSpecular = vec3( 0.0 );","for( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {","vec3 dirVector = directionalLights[ i ].direction;","vec3 dirHalfVector = normalize( dirVector + viewPosition );","float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );","float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );","float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );","totalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;","totalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;","}","#endif","#if NUM_HEMI_LIGHTS > 0","vec3 hemiDiffuse  = vec3( 0.0 );","vec3 hemiSpecular = vec3( 0.0 );","for( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {","vec3 lVector = hemisphereLights[ i ].direction;","float dotProduct = dot( normal, lVector );","float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;","totalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );","float hemiSpecularWeight = 0.0;","vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );","float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;","hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );","vec3 lVectorGround = -lVector;","vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );","float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;","hemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );","totalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;","}","#endif","outgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );","float mistAmount = clamp( 1.0 - vPosition.y / 15.0, 0.0, 1.0 );","mistAmount = pow( mistAmount, 5.4 );","vec3 mistColor = vec3( 0.835, 0.843, 0.850 );","outgoingLight = mix( outgoingLight, mistColor, mistAmount );","gl_FragColor = vec4( outgoingLight, diffuseColor.a );",THREE.ShaderChunk.tonemapping_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},t.GrayScaleShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float gray = dot( texel.rgb, vec3(0.299, 0.587, 0.114) );","gl_FragColor = vec4( gray, gray, gray, texel.a );","}"].join("\n")},t.LuminanceShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float luma = dot( texel.rgb, vec3(0.2125, 0.7154, 0.0721) );","gl_FragColor = vec4( luma, luma, luma, texel.a );","}"].join("\n")},t.InvertImageShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor.rgb = vec3(1.0) - texel.rgb;","gl_FragColor.a = texel.a;","}"].join("\n")},t.BrightnessShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec3 black = vec3(0.0);","gl_FragColor.rgb = mix( black, texel.rgb, 2.0 );","gl_FragColor.a = texel.a;","}"].join("\n")},t.SaturationShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float luma = dot( texel.rgb, vec3(0.2125, 0.7154, 0.0721) );","gl_FragColor.rgb = mix( vec3(luma), texel.rgb, 0.5 );","gl_FragColor.a = texel.a;","}"].join("\n")},t.ContrastShader={uniforms:{tDiffuse:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor.rgb = mix( vec3(0.5), texel.rgb, 2.0 );","gl_FragColor.a = texel.a;","}"].join("\n")},t.DitheringShader={uniforms:{tDiffuse:{value:null},tNoise:{value:null}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform sampler2D tNoise;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","float grayscale = length( texel.rgb * vec3(0.2126, 0.7152, 0.0722) );","vec3 ditherPixel = texture2D( tNoise, vec2( mod( gl_FragCoord.xy / vec2(8.0), 1.0) ) ).xyz;","float ditherGrayscale = ( ditherPixel.x + ditherPixel.y + ditherPixel.z ) / 3.0;","ditherGrayscale -= 0.5;","float ditheredResult = grayscale + ditherGrayscale;","float bit = (ditheredResult >= 0.5) ? 1.0 : 0.0;","gl_FragColor.rgb = vec3( bit );","gl_FragColor.a = texel.a;","}"].join("\n")},t.GaussianBlurShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)},strength:{value:3.5},horizontalPass:{value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","uniform float strength;","uniform int horizontalPass;","varying vec2 vUv;","void main() {","const float pi = 3.14159265;","const float numBlurPixelsPerSide = 16.0;","vec2 texOffset = resolution;","vec2 blurMultiplyVec = 0 < horizontalPass ? vec2(1.0, 0.0) : vec2(0.0, 1.0);","vec3 incrementalGaussian;","incrementalGaussian.x = 1.0 / (sqrt(2.0 * pi) * strength);","incrementalGaussian.y = exp(-0.5 / (strength * strength));","incrementalGaussian.z = incrementalGaussian.y * incrementalGaussian.y;","vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);","float coefficientSum = 0.0;","avgValue += texture2D( tDiffuse, vUv ) * incrementalGaussian.x;","coefficientSum += incrementalGaussian.x;","incrementalGaussian.xy *= incrementalGaussian.yz;","for (float i = 1.0; i <= numBlurPixelsPerSide; i++) {","avgValue += texture2D( tDiffuse, vUv - i * texOffset * blurMultiplyVec ) * incrementalGaussian.x;","avgValue += texture2D( tDiffuse, vUv + i * texOffset * blurMultiplyVec ) * incrementalGaussian.x;","coefficientSum += 2.0 * incrementalGaussian.x;","incrementalGaussian.xy *= incrementalGaussian.yz;","}","gl_FragColor = avgValue / coefficientSum;","}"].join("\n")},t.EdgeDetectionShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","mat3 G[9];","const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );","const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );","const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );","const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );","const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );","const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );","const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );","const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );","const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );","void main(void)","{","G[0] = g0,","G[1] = g1,","G[2] = g2,","G[3] = g3,","G[4] = g4,","G[5] = g5,","G[6] = g6,","G[7] = g7,","G[8] = g8;","mat3 I;","float cnv[9];","vec3 sample;","for (float i=0.0; i<3.0; i++) {","for (float j=0.0; j<3.0; j++) {","sample = texture2D(tDiffuse, vUv + resolution * vec2(i-1.0,j-1.0) ).rgb;","I[int(i)][int(j)] = length(sample);","}","}","for (int i=0; i<9; i++) {","float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);","cnv[i] = dp3 * dp3;","}","float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);","float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);","gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);","}"].join("\n")},t.EdgeDetection2Shader={defines:{EDGE_FUNC:"edge"},uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2(1/512,1/512)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","varying vec2 vUv;","const mat3 sobelKernelX = mat3(1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0);","const mat3 sobelKernelY = mat3(-1.0, -2.0, -1.0, 0.0, 0.0, 0.0, 1.0, 2.0, 1.0);","float convolve(mat3 kernel, mat3 image) {","float result = 0.0;","for (int i = 0; i < 3; i++) {","for (int j = 0; j < 3; j++) {","result += kernel[i][j]*image[i][j];","}","}","return result;","}","float convolveComponent(mat3 kernelX, mat3 kernelY, mat3 image) {","vec2 result;","result.x = convolve(kernelX, image);","result.y = convolve(kernelY, image);","return clamp(length(result), 0.0, 255.0);","}","vec4 colorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {","vec4 colors[9];","colors[0] = texture2D(tDiffuse,center + vec2(-stepx,stepy));","colors[1] = texture2D(tDiffuse,center + vec2(0,stepy));","colors[2] = texture2D(tDiffuse,center + vec2(stepx,stepy));","colors[3] = texture2D(tDiffuse,center + vec2(-stepx,0));","colors[4] = texture2D(tDiffuse,center);","colors[5] = texture2D(tDiffuse,center + vec2(stepx,0));","colors[6] = texture2D(tDiffuse,center + vec2(-stepx,-stepy));","colors[7] = texture2D(tDiffuse,center + vec2(0,-stepy));","colors[8] = texture2D(tDiffuse,center + vec2(stepx,-stepy));","mat3 imageR, imageG, imageB, imageA;","for (int i = 0; i < 3; i++) {","for (int j = 0; j < 3; j++) {","imageR[i][j] = colors[i*3+j].r;","imageG[i][j] = colors[i*3+j].g;","imageB[i][j] = colors[i*3+j].b;","imageA[i][j] = colors[i*3+j].a;","}","}","vec4 color;","color.r = convolveComponent(kernelX, kernelY, imageR);","color.g = convolveComponent(kernelX, kernelY, imageG);","color.b = convolveComponent(kernelX, kernelY, imageB);","color.a = convolveComponent(kernelX, kernelY, imageA);","return color;","}","vec4 edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){","mat3 image = mat3(length(texture2D(tDiffuse,center + vec2(-stepx,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(0,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(-stepx,0)).rgb),","length(texture2D(tDiffuse,center).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,0)).rgb),","length(texture2D(tDiffuse,center + vec2(-stepx,-stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(0,-stepy)).rgb),","length(texture2D(tDiffuse,center + vec2(stepx,-stepy)).rgb));","vec2 result;","result.x = convolve(kernelX, image);","result.y = convolve(kernelY, image);","float color = clamp(length(result), 0.0, 255.0);","return vec4(color);","}","vec4 trueColorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {","vec4 edgeVal = edge(stepx, stepy, center, kernelX, kernelY);","return edgeVal * texture2D(tDiffuse,center);","}","void main(void)","{","vec4 texel = texture2D( tDiffuse, vUv );","vec4 result = EDGE_FUNC( resolution.x, resolution.y, vUv, sobelKernelX, sobelKernelY );","gl_FragColor = vec4( result.rgb, texel.a );","}"].join("\n")},t.VignetteShader={uniforms:{tDiffuse:{value:null},offset:{value:1},darkness:{value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform float offset;","uniform float darkness;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );","gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );","}"].join("\n")},t.FilmGrainShader={uniforms:{tDiffuse:{value:null},aspectCorrection:{value:!1},aspect:{value:1},grainScale:{value:.005},grainTime:{value:0},noiseAlpha:{value:.25},offset:{value:new THREE.Vector2(0,0)},scale:{value:new THREE.Vector2(1,1)},smoothEdge:{value:new THREE.Vector2(0,1)},color1:{value:new THREE.Color(16777215)},color2:{value:new THREE.Color(2635844)}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:[t.ShaderChunk.mod289,t.ShaderChunk.permute,t.ShaderChunk.taylorInvSqrt,t.ShaderChunk.snoise3,t.ShaderChunk.fade3,t.ShaderChunk.pnoise3,"float grain(vec2 texCoord, vec2 resolution, float frame, float multiplier) {","vec2 mult = texCoord * resolution;","float offset = snoise(vec3(mult / multiplier, frame));","float n1 = pnoise(vec3(mult, offset), vec3(1.0/texCoord * resolution, 1.0));","return n1 / 2.0 + 0.5;","}","float grain(vec2 texCoord, vec2 resolution, float frame) {","return grain(texCoord, resolution, frame, 2.5);","}","float grain(vec2 texCoord, vec2 resolution) {","return grain(texCoord, resolution, 0.0);","}","vec3 blendSoftLight(vec3 base, vec3 blend) {","return mix(","sqrt(base) * (2.0 * blend - 1.0) + 2.0 * base * (1.0 - blend),","2.0 * base * blend + base * base * (1.0 - 2.0 * blend),","step(base, vec3(0.5))",");","}","uniform sampler2D tDiffuse;","uniform vec3 color1;","uniform vec3 color2;","uniform float aspect;","uniform vec2 offset;","uniform vec2 scale;","uniform float noiseAlpha;","uniform bool aspectCorrection;","uniform float grainScale;","uniform float grainTime;","uniform vec2 smoothEdge;","varying vec2 vUv;","void main() {","vec2 q = vec2(vUv - 0.5);","if( aspectCorrection ) {","q.x *= aspect;","}","q /= scale;","q -= offset;","float dst = length(q);","dst = smoothstep(smoothEdge.x, smoothEdge.y, dst);","vec3 color12 = mix(color1, color2, dst);","vec3 color3 = texture2D(tDiffuse, vUv).rgb;","vec3 color = mix(color12, color3, 0.75);","if( noiseAlpha > 0.0 && grainScale > 0.0 ) {","float gSize = 1.0 / grainScale;","float g = grain(vUv, vec2(gSize * aspect, gSize), grainTime);","vec3 noiseColor = blendSoftLight(color, vec3(g));","gl_FragColor.rgb = mix(color, noiseColor, noiseAlpha);","} else {","gl_FragColor.rgb = color;","}","gl_FragColor.a = 1.0;","}"].join("\n")},t.BackgroundShader={uniforms:{devicePixelRatio:{value:window.devicePixelRatio},time:{value:0},resolution:{value:null},textureMaps:{value:[]}},vertexShader:"void main(){ gl_Position = vec4(position, 1.0); }",cloudsFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        #define iChannel0 textureMaps[0]\n        # define T texture2D(iChannel0, fract((s*p.zw + ceil(s*p.x)) / 200.0)).y / (s += s) * 4.0\n        const vec3 skyColor = vec3(0.360, 0.650, 0.792); // 0x5ca6ca\n        const vec3 cloudColor = vec3(0.2, 0.301, 0.501); // 0x334d80\n        const vec3 lightColor = vec3(1.0); // 0xffffff\n        const float speed = 1.0;\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n            vec4 p, d = vec4(0.8, 0, fragCoord / resolution.y - 0.65);\n            vec3 out1 = skyColor - d.w; // sky gradient\n            float s, f, t = 200.0 + sin(dot(fragCoord, fragCoord));\n            const float MAX_ITER = 100.0;\n            for (float i = 1.0; i <= MAX_ITER; i += 1.0) {\n            t -= 2.0; if (t < 0.0) { break; } // march step\n            p = 0.05 * t * d;\n            p.xz += time * 0.50000 * speed; // movement through space\n            p.x += sin(time * 0.25 * speed) * 0.25;\n            s = 2.0;\n            f = p.w + 1.0-T-T-T-T;\n            if (f < 0.0) {\n                vec3 cloudShading = mix(lightColor, cloudColor, -f);\n                out1 = mix(out1, cloudShading, -f * 0.4);\n            }\n            }\n            fragColor = vec4(out1, 1.0);\n        }\n        void main() {\n            gl_FragDepth = 1.0;\n            mainImage( gl_FragColor, gl_FragCoord.xy );\n        }\n    ",cellsFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        const vec3 color1 = vec3(0, 0.549, 0.549);\n        const vec3 color2 = vec3(0.949, 0.905, 0.207);\n        const float size = 1.5;\n        float length2(vec2 p) { return dot(p, p); }\n        float noise(vec2 p){\n            return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);\n        }\n        float worley(vec2 p) {\n            float d = 1e30;\n            for (int xo = -1; xo <= 1; ++xo) {\n                for (int yo = -1; yo <= 1; ++yo) {\n                    vec2 tp = floor(p) + vec2(xo, yo);\n                    d = min(d, length2(p - tp - vec2(noise(tp))));\n                }\n            }\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            float timeOffset =  0.15 * sin(time * 2.0 + 10.0*(uv.x - uv.y));\n            return 3.0*exp(-4.0*abs(2.0*d - 1.0 + timeOffset));\n        }\n        float fworley(vec2 p) {\n            return sqrt(sqrt(sqrt(\n            1.1 * // light\n            worley(p*5. + .3 + time*.0525) *\n            sqrt(worley(p * 50. / size + 0.3 + time * -0.15)) *\n            sqrt(sqrt(worley(p * -10. + 9.3))))));\n        }\n        void main() {\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            float t = fworley(uv * resolution.xy / 1500.0);\n            t *= exp(-length2(abs(0.7*uv - 1.0)));\n            float tExp = pow(t, 0.5 - t);\n            vec3 c1 = color1 * (1.0 - t);\n            vec3 c2 = color2 * tExp;\n            gl_FragColor = vec4(pow(t, 1.0 - t) * (c1 + c2), 1.0);\n            gl_FragDepth = 1.0;\n        }\n    ",fogFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        const vec3 baseColor = vec3(1.0, 0.921, 0.921);\n        const vec3 lowlightColor = vec3(0.176, 0.0, 1.0);\n        const vec3 midtoneColor = vec3(1.0, 0.121, 0.0);\n        const vec3 highlightColor = vec3(1.0, 0.764, 0.0);\n        const float blurFactor = 0.21;//0.6;\n        const float zoom = 1.0;\n        float random (in vec2 uv) {\n            return fract(sin(dot(uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n        }\n        float noise (in vec2 uv) {\n            vec2 i = floor(uv);\n            vec2 f = fract(uv);\n            // Four corners in 2D of a tile\n            float a = random(i);\n            float b = random(i + vec2(1.0, 0.0));\n            float c = random(i + vec2(0.0, 1.0));\n            float d = random(i + vec2(1.0, 1.0));\n            vec2 u = f * f * (3.0 - 2.0 * f);\n            return mix(a, b, u.x) +\n                    (c - a)* u.y * (1.0 - u.x) +\n                    (d - b) * u.x * u.y;\n        }\n        #define NUM_OCTAVES 6\n        float fbm( in vec2 uv ) {\n            float v = 0.0;\n            float a = blurFactor;\n            vec2 shift = vec2(100.0);\n            // Rotate to reduce axial bias\n            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n            for (int i = 0; i < NUM_OCTAVES; ++i) {\n                v += a * noise(uv);\n                uv = rot * uv * 2.0 + shift;\n                a *= (1. - blurFactor);\n            }\n            return v;\n        }\n        void main() {\n            vec2 st = gl_FragCoord.xy / resolution.xy*3.;\n            st.x *= 0.7 * resolution.x / resolution.y ; // Still keep it more landscape than square\n            st *= zoom;\n            // st += st * abs(sin(time*0.1)*3.0);\n            vec3 color = vec3(0.0);\n            vec2 q = vec2(0.);\n            q.x = fbm( st + 0.00*time);\n            q.y = fbm( st + vec2(1.0));\n            vec2 dir = vec2(0.15,0.126);\n            vec2 r = vec2(0.);\n            r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ dir.x*time );\n            r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ dir.y*time);\n            float f = fbm(st+r);\n            color = mix(baseColor, lowlightColor, clamp((f*f)*4.0,0.0,1.0));\n            color = mix(color, midtoneColor, clamp(length(q),0.0,1.0));\n            color = mix(color, highlightColor, clamp(length(r.x),0.0,1.0));\n            vec3 finalColor = mix(baseColor, color, f*f*f+.6*f*f+.5*f);\n            gl_FragColor = vec4(finalColor,1.0);\n            gl_FragDepth = 1.0;\n        }\n    ",sunsetFS:"        // include.glsl\n        #define gl_FragCoord (gl_FragCoord / devicePixelRatio)\n        uniform float devicePixelRatio;\n        uniform float time;\n        uniform vec2 resolution;\n        uniform sampler2D textureMaps[4];\n        //\n        float rand(float x) { return fract(sin(x) * 71523.5413291); }\n        float rand(vec2 x) { return rand(dot(x, vec2(13.4251, 15.5128))); }\n        float noise(vec2 x)\n        {\n            vec2 i = floor(x);\n            vec2 f = x - i;\n            f *= f*(3.-2.*f);\n            return mix(mix(rand(i), rand(i+vec2(1,0)), f.x), mix(rand(i+vec2(0,1)), rand(i+vec2(1,1)), f.x), f.y);\n        }\n        float fbm(vec2 x)\n        {\n            float r = 0.0, s = 1.0, w = 1.0;\n            for (int i=0; i<5; i++) {\n                s *= 2.0;\n                w *= 0.5;\n                r += w * noise(s * x);\n            }\n            return r;\n        }\n        float cloud(vec2 uv, float scalex, float scaley, float density, float sharpness, float speed)\n        {\n            return pow(saturate(fbm(vec2(scalex,scaley)*(uv+vec2(speed,0)*time))-(1.0-density)), 1.0-sharpness);\n        }\n        vec3 render(vec2 uv)\n        {\n            // sky\n            vec3 color = mix(vec3(1.0,0.831,0.650), vec3(0.8,0.921,1.0), uv.y);\n            // sun\n            vec2 spos = uv - vec2(0.1, 0.4);\n            float sun = exp(-20.*dot(spos,spos));\n            vec3 scol = vec3(1.0,0.607,0.4) * sun * 0.7;\n            color += scol;\n            // clouds\n            vec3 cl1 = mix(vec3(0.592,0.541,0.6), vec3(0.650,0.749,0.878),uv.y);\n            float d1 = mix(0.9,0.1,pow(uv.y, 0.7));\n            color = mix(color, cl1, cloud(uv,2.,8.,d1,0.4,0.04));\n            color = mix(color, vec3(0.9), 8.*cloud(uv,14.,18.,0.9,0.75,0.02) * cloud(uv,2.,5.,0.6,0.15,0.01)*uv.y);\n            color = mix(color, vec3(0.8), 5.*cloud(uv,12.,15.,0.9,0.75,0.03) * cloud(uv,2.,8.,0.5,0.0,0.02)*uv.y);\n            // post\n            color *= vec3(1.0,0.93,0.81)*1.04;\n            color = mix(0.75*vec3(1.0,0.803,0.631), color, smoothstep(-0.1,0.3,uv.y));\n            color = pow(color,vec3(1.3));\n            return color;\n        }\n        void main() {\n            vec2 uv = gl_FragCoord.xy / resolution.xy;\n            uv.x -= 0.5;\n            uv.x *= resolution.x / resolution.y;\n            gl_FragColor = vec4(render(uv), 1.0);\n            gl_FragDepth = 1.0;\n        }\n    "};var E=__webpack_require__(5744),w=__webpack_require__(9756),b=__webpack_require__(16);t.GraphicWorks=function(e){var n=this;e=e||{};this.appName=e.appName||"GraphicWorks",this.customer=e.customer||"NovaGraphix";var r,[o,a]=A();if(this.width=e.width||o,this.height=e.height||a,this.widthRatio=this.width/o,this.heightRatio=this.height/a,this.dom=document.createElement("div"),this.dom.id=this.appName,this.dom.className="GraphicWorks",this.dom.tabIndex=t.tabIndices[this.dom.id],this.dom.style.width=this.width+"px",this.dom.style.height=this.height+"px",this.signals=null,!0===e.signals){var i=E.Signal;this.signals={startPlayer:new i,stopPlayer:new i,appWorksCleared:new i,autoSaveStarted:new i,autoSaveFinished:new i,themeChanged:new i,transformModeChanged:new i,snapChanged:new i,spaceChanged:new i,sceneBackgroundChanged:new i,sceneFogChanged:new i,sceneGraphChanged:new i,cameraChanged:new i,geometryChanged:new i,objectSelected:new i,objectFocused:new i,objectsSelected:new i,objectAdded:new i,objectChanged:new i,objectRemoved:new i,helperAdded:new i,helperChanged:new i,helperRemoved:new i,materialChanged:new i,windowResize:new i,axesHelperChanged:new i,gridHelperChanged:new i,initSidebar:new i,historyChanged:new i},(r=n.signals).startPlayer.add((function(){n.history.historyDisabled=!0})),r.stopPlayer.add((function(){n.history.historyDisabled=!1})),r.themeChanged.add((function(){})),r.sceneBackgroundChanged.add((function(e){n.config.setSettings("background",e)})),r.sceneFogChanged.add((function(e){n.createSceneFog(e),T()})),r.gridHelperChanged.add((function(e,r,o){t.dispose(n.gridHelper),n.gridHelper=b(e,r,o),n.sceneHelpers.add(n.gridHelper),T()})),r.geometryChanged.add((function(e){})),r.materialChanged.add((function(e){})),r.objectAdded.add((function(e){var t=n.selectables;e.traverse((function(e){t.push(e)}))})),r.objectRemoved.add((function(e){n.transformControls&&n.transformControls.object===e&&n.transformControls.detach();var t=n.selectables;e.traverse((function(e){t.splice(t.indexOf(e),1)}))})),r.objectChanged.add((function(e){e instanceof THREE.PerspectiveCamera&&e.updateProjectionMatrix(),!e.helper||e.helper instanceof THREE.SkeletonHelper||(e.helper.update(),r.helperChanged.dispatch(e.helper)),T()})),r.objectsSelected.add((function(e){if(Array.isArray(e)){if(1===e.length){var t=e[0];if(null===t.parent)return;var r=n.transformControls.enabled;n.transformControls.detach(),n.transformControls.attach(t),n.transformControls.visible=r,n.transformControls.enabled=r}if(n.outlinePass.enabled){var o=n.outlinePass;o.selectedObjects=[],e.forEach((function(e){e.traverse((function(e){0===e.children.length&&o.selectedObjects.push(e)}))}))}}})),r.objectFocused.add((function(e){var r=new THREE.Vector3;e&&r.copy(e.position),n.controls instanceof THREE.OrbitControls||n.controls instanceof THREE.TrackballControls?(n.controls.target.copy(r),n.controls.update()):n.controls instanceof THREE.FirstPersonControls&&(n.controls.lookAt(r),n.controls.update(t.getDeltaTime()))})),r.helperAdded.add((function(e){var t=e.getObjectByName("picker");n.selectables.push(t)})),r.helperChanged.add((function(e){var t=e.light;t&&(e.visible=t.visible)})),r.helperRemoved.add((function(e){var t=n.selectables,r=e.getObjectByName("picker");t.splice(t.indexOf(r),1)})),r.cameraChanged.add((function(e){e&&(n.config.setSettings("cameraFov",e.fov),n.config.setSettings("cameraNear",e.near),n.config.setSettings("cameraFar",e.far)),T()})),r.historyChanged.add((function(){var e=n.history;e.undos.length,e.redos.length})),r.appWorksCleared.add((function(){n.select(null),n.focus(),T()})),r.autoSaveStarted.add((function(){})),r.autoSaveFinished.add((function(){})),r.transformModeChanged.add((function(e){n.transformControls.setMode(e)})),r.snapChanged.add((function(e){n.transformControls.setTranslationSnap(e)})),r.spaceChanged.add((function(e){n.transformControls.setSpace(e)})),r.windowResize.add((function(){S()}))}this.config=null,!0===e.config&&(this.config=new t.Config(this.appName),this.config.initDatabase((function(){var e;function t(){!1!==n.config.getSettings("autosave")&&(clearTimeout(e),e=setTimeout((function(){n.signals.autoSaveStarted.dispatch(),e=setTimeout((function(){n.config.setDatabase(n.toJSON()),n.signals.autoSaveFinished.dispatch()}),100)}),1e3))}n.config.getDatabase((function(e){void 0!==e&&n.fromJSON(e)}));var r=n.signals;r.geometryChanged.add(t),r.materialChanged.add(t),r.objectAdded.add(t),r.objectChanged.add(t),r.objectRemoved.add(t),r.sceneBackgroundChanged.add(t),r.sceneFogChanged.add(t),r.sceneGraphChanged.add(t),r.historyChanged.add(t)}))),this.history=null,!0===e.history&&(this.history=new t.History(this)),2===e.glVersion&&t.isWebGL2Available()?this.renderer=new THREE.WebGLRenderer({alpha:!0,powerPreference:"high-performance"}):this.renderer=new THREE.WebGL1Renderer({alpha:!0,powerPreference:"high-performance"}),this.renderer.autoClear=!0,this.renderer.setClearColor(0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.width,this.height),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=THREE.PCFSoftShadowMap,this.renderer.outputEncoding=THREE.sRGBEncoding,this.renderer.gammaFactor=2.2,this.renderer.toneMapping=THREE.LinearToneMapping,this.renderer.toneMappingExposure=1,this.dom.appendChild(this.renderer.domElement),this.scene=new THREE.Scene,this.scene.name="scene",this.scene.appName=this.appName,this.createSceneFog=function(e){this.scene.fog=t.createFog(e)},this.createSceneFog(e.fog),this.createSceneBackground=function(e){e=void 0!==e?e:this.config?this.config.getSettings("background"):null;this.scene.background&&this.scene.background.dispose&&this.scene.background.dispose(),this.scene.background=t.createBackground(e)},this.createSceneBackground(e.background);var s,l,c,f,u,d,p,h,v,m=e.cameraFov||this.config?this.config.getSettings("cameraFov"):50,x=e.cameraNear||this.config?this.config.getSettings("cameraNear"):.01,g=e.cameraFar||this.config?this.config.getSettings("cameraFar"):1e4,y=e.cameraPosition||this.config?this.config.getSettings("cameraPosition"):[0,0,50];function b(e,r,o){e=e||n.config?n.config.getSettings("gridHelperSize"):500,r=r||n.config?n.config.getSettings("gridHelperSpacing"):5,o=o||n.config?n.config.getSettings("gridHelperColor"):4210752;e=~~(e/r),e*=r;var a=new THREE.GridHelper(e,e/r,16729156,o);a.position.y=0,a.name="gridHelper";for(var i=.05*r,s=e/2,l=[],c=-s;c<=s;c+=r)l.push(c.toFixed(2));return l.forEach((function(e){var n=t.createTextSprite(e,{textHeight:i,fontWeight:"bold"}),r=n.clone();n.position.set(parseFloat(e),i/2,0),r.position.set(0,i/2,parseFloat(e)),a.add(n),a.add(r)})),a}function _(){n.animateID=window.requestAnimationFrame(_),function(){var e=t.getDeltaTime(),r=t.getCurrentTime();n.stats&&n.stats.update();n.animator.update(e),n.scene.traverse((function(t){t.update&&t.update(e,r)})),n.sceneHUD&&n.sceneHUD.traverse((function(t){t.update&&t.update(e,r)}));var o=n.controls;o.enabled&&(o instanceof THREE.OrbitControls?!0!==o.autoRotate&&!0!==o.enableDamping||o.update():o instanceof THREE.TrackballControls?o.update():(o instanceof THREE.FirstPersonControls||!0===o.isTPSCameraControl)&&o.update(e))}(),T()}function T(){n.effect?(n.renderer.setRenderTarget(null),n.effect.render(n.scene,n.camera)):n.composer?n.composer.render(t.getDeltaTime()):"MedicalWorks"!==n.appName&&n.renderer.render(n.scene,n.camera)}function A(){return[Math.max(document.documentElement.clientWidth||0,window.innerWidth||0),Math.max(document.documentElement.clientHeight||0,window.innerHeight||0)]}function S(){var[e,t]=A();(n.width=n.widthRatio*e,n.height=n.heightRatio*t,n.dom.style.width=n.width+"px",n.dom.style.height=n.height+"px",n.camera.aspect=n.width/n.height,n.camera.updateProjectionMatrix(),function(){if(!n.sceneHUD||!n.cameraHUD)return;var e=n.cameraHUD,t=e.right,r=e.top,o=n.width/2,a=n.height/2;e.left=-o,e.right=o,e.top=a,e.bottom=-a,e.updateProjectionMatrix(),n.sceneHUD.children.forEach((e=>{var n=e.position;n.x*=1+(o-t)/Math.abs(n.x),n.y*=1+(a-r)/Math.abs(n.y)}))}(),n.FXAAShader.enabled&&n.FXAAShader.uniforms.resolution.value.set(1/n.width,1/n.height),n.renderer.setSize(n.width,n.height),n.composer&&n.composer.setSize(n.width,n.height),n.effect&&n.effect.setSize(n.width,n.height),n.controls.enabled&&(n.controls instanceof THREE.OrbitControls||n.controls.handleResize()),"NatureWorks"===n.appName)&&n.scene.getObjectsByType("FireParticles").forEach((function(e){e.setNearPlaneHeight()}))}function R(e){var r=n.dom.getBoundingClientRect(),o=t.getMouseScreenCoords(e);return o.x=(o.x-r.left)/r.width*2-1,o.y=-(o.y-r.top)/r.height*2+1,o}function M(e,t){return n.raycaster.setFromCamera(e,n.camera),n.raycaster.intersectObjects(t,!0)}function C(){var e=n.getIntersectObject(n.xinfo);e&&("picker"===e.name?n.select(e.userData.object):event.ctrlKey?n.select(e,"multiple"):event.altKey?n.select(e,"ancestor"):n.select(e),T())}function L(e){n.mouseUpPosition.copy(R(e)),C(),document.removeEventListener("mouseup",L,!1)}function P(e){e.preventDefault(),h&&(clearTimeout(h),v=!1),n.mouseUpPosition.copy(R(e)),C(),document.removeEventListener("touchend",P,!1)}function k(e){n.mouseUpPosition.copy(n.mouseDownPosition),N(e)}function N(e){n.guiContextMenu&&(n.getIntersectObject()&&n.guiContextMenu.toggle(e))}function H(e){switch(n.appName){case"ViewWorks":!function(e){switch(e.stopPropagation(),e.keyCode){case 8:e.preventDefault();case 27:n.controls.enabled=!0;break;case 49:t.nextShowroom("background");break;case 50:t.nextShowroom("floor");break;case 66:break;case 79:if(n.animator&&n.selectObject){var r=n.selectObject.activeAction;r.paused=!r.paused}break;case 80:n.animator&&n.selectObject&&n.playNextAction(n.selectObject)}}(e);break;case"GameWorks":!function(e){switch(e.keyCode){case 66:t.demoApplication();break;case 191:t.gamePlay()}}(e);break;case"NatureWorks":!function(e){122!==e.keyCode&&e.preventDefault();e.stopPropagation();var r=t.isCtrlKeyDown(e);if(r&&90===e.keyCode)return void n.undo();if(r&&89===e.keyCode)return void n.redo();switch(e.keyCode){case 8:e.preventDefault();case 46:var o=n.selectObject;o&&o.parent&&n.remove(o);break;case 18:break;case 27:n.controls.enabled=!0;break;case 49:t.filmGrainBackground();break;case 50:break;case 66:t.demoApplication();break;case 67:n.controls instanceof THREE.OrbitControls?n.controls=t.createCameraControls("FirstPersonControls"):n.controls instanceof THREE.FirstPersonControls&&(n.controls=t.createCameraControls("OrbitControls"));break;case 70:t.demoLoadFiles();break;case 72:t.add(t.createHemisphereLight());break;case 73:t.cameraAutoView({isWorking:!0})?t.cameraAutoView({viewMode:"stop"}):t.cameraAutoView({viewMode:"circle"});break;case 76:t.toggleLightHelpers();break;case 77:void 0!==n.sound&&(n.sound.playing()?n.sound.pause():n.sound.play());break;case 78:t.add(t.createSky()),t.add(t.createSunLight());break;case 79:if(n.animator&&n.selectObject){var a=n.selectObject.activeAction;a.paused=!a.paused}break;case 80:n.animator&&n.selectObject&&n.playNextAction(n.selectObject);break;case 86:t.demoRaymarchToPoints();break;case 112:n.appGUI&&n.appGUI.toggle(n.guiSceneGraph.dom);break;case 113:n.appGUI&&n.appGUI.toggle();break;case 114:n.dragControls.enabled=!n.dragControls.enabled;break;case 115:n.transformControls.visible=!n.transformControls.visible,n.transformControls.enabled=!n.transformControls.enabled;break;case 116:n.guiSidebar&&n.guiSidebar.select(n.guiStrings.getKey("menubar/edit/scene"),"inclusive");break;case 117:t.screenCapture();break;case 118:break;case 119:n.selectObject&&n.focus(n.selectObject);break;case 120:n.config.clearSettings(),console.log('>> clear the "window.localStorage"...');break;case 121:n.config.clearDatabase(),console.log('>> clear the "window.indexedDB"...');break;case 123:void 0!==n.dragVertexControls&&(n.dragVertexControls.enabled=!n.dragVertexControls.enabled,n.controls.enabled=!n.dragVertexControls.enabled);break;case 191:t.gamePlay();break;case 81:n.transformControls.setSpace("local"===n.transformControls.space?"world":"local");break;case 17:n.transformControls.setTranslationSnap(n.config.getSettings("translationSnap")),n.transformControls.setRotationSnap(THREE.Math.degToRad(n.config.getSettings("rotationSnap")));break;case 87:n.transformControls.setMode("translate");break;case 69:n.transformControls.setMode("rotate");break;case 82:n.transformControls.setMode("scale");break;case 187:case 107:n.transformControls.setSize(n.transformControls.size+.1);break;case 189:case 109:n.transformControls.setSize(Math.max(n.transformControls.size-.1,.1));break;case 88:n.transformControls.showX=!n.transformControls.showX;break;case 89:n.transformControls.showY=!n.transformControls.showY;break;case 90:n.transformControls.showZ=!n.transformControls.showZ;break;case 32:n.transformControls.visible=!n.transformControls.visible,n.transformControls.enabled=!n.transformControls.enabled}}(e);break;case"MedicalWorks":t.MedicalKeyboard(e)}}this.defaultCamera=new THREE.PerspectiveCamera(m,this.width/this.height,x,g),this.defaultCamera.position.set(y[0],y[1],y[2]),this.defaultCamera.lookAt(this.scene.position),this.defaultCamera.name="camera",this.camera=this.defaultCamera.clone(),this.controls=t.createCameraControls(e.controlsType,this.camera,this.renderer.domElement),this.animator=new t.Animator(this.scene),this.playAction=function(e,t,n){this.animator.playAction(e,t,n)},this.playNextAction=function(e){this.animator.playNextAction(e)},this.stopAction=function(e,t){this.animator.stopAction(e,t)},this.stats=null,!0!==e.stats||t.isDeviceMobile()||(this.stats=new w,this.stats.dom.style.cssText="position:absolute; bottom:0px; right:0px",this.dom.appendChild(this.stats.dom)),this.raycaster=new THREE.Raycaster,this.selectObject=null,this.selectObjects=[],this.selectables=[],this.mouseMovePosition=new THREE.Vector2,this.mouseDownPosition=new THREE.Vector2,this.mouseUpPosition=new THREE.Vector2,this.mouseDoubleClickPosition=new THREE.Vector2,this.playAudio=function(e){this.sound&&this.sound.unload(),this.sound=t.playAudio(e)},this.playAudio(e.audioFiles),this.sceneHelpers=new THREE.Scene,"NatureWorks"===this.appName&&(this.gridHelper=b(),this.gridHelper.visible=e.gridVisible||!1,this.sceneHelpers.add(this.gridHelper)),this.sceneHUD=null,this.cameraHUD=null,!0===e.hud&&(this.sceneHUD=new THREE.Scene,this.cameraHUD=new THREE.OrthographicCamera(-this.width/2,this.width/2,this.height/2,-this.height/2,.1,100.1),this.cameraHUD.position.z=50.1),function(e){e=e||{};n.composer=new THREE.EffectComposer(n.renderer),n.composer.setSize(n.width,n.height),n.renderPass=new THREE.RenderPass(n.scene,n.camera),n.renderPass.clear=!0,n.renderPass.clearDepth=!1,n.composer.addPass(n.renderPass),n.sceneHelpers&&(n.renderPass2=new THREE.RenderPass(n.sceneHelpers,n.camera),n.renderPass2.clear=!1,n.renderPass2.clearDepth=!1,n.composer.addPass(n.renderPass2));n.sceneHUD&&(n.renderPass3=new THREE.RenderPass(n.sceneHUD,n.cameraHUD),n.renderPass3.clear=!1,n.renderPass3.clearDepth=!1,n.composer.addPass(n.renderPass3));void 0!==e.bleachEnabled&&(n.bleachShader=new THREE.ShaderPass(THREE.BleachBypassShader),n.bleachShader.enabled=e.bleachEnabled,n.composer.addPass(n.bleachShader));void 0!==e.bloomEnabled&&(n.bloomPass=new THREE.UnrealBloomPass(new THREE.Vector2(n.width,n.height),2.5,.45,.88),n.bloomPass.enabled=e.bloomEnabled,n.composer.addPass(n.bloomPass));void 0!==e.dotScreenEnabled&&(n.dotScreenShader=new THREE.ShaderPass(THREE.DotScreenShader),n.dotScreenShader.uniforms.scale.value=4,n.dotScreenShader.enabled=e.dotScreenEnabled,n.composer.addPass(n.dotScreenShader));void 0!==e.glitchEnabled&&(n.glitchPass=new THREE.GlitchPass(0),n.glitchPass.enabled=e.glitchEnabled,n.composer.addPass(n.glitchPass));void 0!==e.sepiaEnabled&&(n.sepiaShader=new THREE.ShaderPass(THREE.SepiaShader),n.sepiaShader.enabled=e.sepiaEnabled,n.composer.addPass(n.sepiaShader));if(void 0!==e.outlineEnabled){n.outlinePass=new THREE.OutlinePass(new THREE.Vector2(n.width,n.height),n.scene,n.camera),n.outlinePass.enabled=e.outlineEnabled,n.composer.addPass(n.outlinePass),(new THREE.TextureLoader).load("images/tri_pattern.jpg",(function(e){e.wrapS=THREE.RepeatWrapping,e.wrapT=THREE.RepeatWrapping,n.outlinePass.patternTexture=e}))}e.FXAAEnabled=!0,void 0!==e.FXAAEnabled&&(n.FXAAShader=new THREE.ShaderPass(THREE.FXAAShader),n.FXAAShader.uniforms.resolution.value.set(1/n.width,1/n.height),n.FXAAShader.enabled=e.FXAAEnabled,n.composer.addPass(n.FXAAShader));void 0!==e.ssaoEnabled&&(n.ssaoPass=new THREE.SSAOPass(n.scene,n.camera,n.width,n.height),n.ssaoPass.enabled=e.ssaoEnabled,n.composer.addPass(n.ssaoPass));void 0!==e.godRaysEnabled&&(n.godRaysPass=new t.GodRaysPass(n.scene,n.camera,n.width,n.height),n.godRaysPass.enabled=e.godRaysEnabled,n.composer.addPass(n.godRaysPass));void 0!==e.bokehEnabled&&(n.bokehPass=new THREE.BokehPass(n.scene,n.camera,{width:n.width,height:n.height,vignetting:1}),n.bokehPass.enabled=e.bokehEnabled,n.composer.addPass(n.bokehPass));void 0!==e.vignetteEnabled&&(n.vignetteShader=new THREE.ShaderPass(THREE.VignetteShader),n.vignetteShader.enabled=e.vignetteEnabled,n.composer.addPass(n.vignetteShader));n.gammaCorrection=new THREE.ShaderPass(THREE.GammaCorrectionShader),n.composer.addPass(n.gammaCorrection)}(e),this.cameraEffect=function(e){this.effect=t.createCameraEffect(e,this.renderer),this.effect?this.effect.setSize(this.width,this.height):this.renderer.setSize(this.width,this.height)},this.cameraEffect(e.effectType),this.fileExplorer=null,!0===e.fileExplorer&&(this.fileExplorer=new t.FileExplorer(this)),this.dragControls=null,!0===e.dragControls&&(this.dragControls=(s=this.scene.children,l=this.camera,c=this.renderer,f=null,(u=new THREE.DragControls(s,l,c.domElement)).enabled=!1,u.addEventListener("dragstart",(function(e){if(this.enabled){var t=e.object;f=t.position.clone(),n.controls.enabled=!1,n.select(t)}})),u.addEventListener("dragend",(function(e){if(this.enabled){var t=e.object;void 0!==t&&(f.equals(t.position)||n.setPosition(t,t.position,f)),n.controls.enabled=!0}})),u)),this.transformControls=null,!0===e.transformControls&&(this.transformControls=function(e,t){var r=null,o=null,a=null,i=new THREE.TransformControls(e,t.domElement);return i.visible=!0,i.enabled=!0,i.addEventListener("change",(function(){var e=i.object;e&&e.helper&&!e.helper instanceof THREE.SkeletonHelper&&e.helper.update()})),i.addEventListener("mouseDown",(function(){var e=i.object;r=e.position.clone(),o=e.rotation.clone(),a=e.scale.clone(),n.controls.enabled=!1})),i.addEventListener("mouseUp",(function(){var e=i.object;if(void 0!==e)switch(i.getMode()){case"translate":r.equals(e.position)||n.setPosition(e,e.position,r);break;case"rotate":o.equals(e.rotation)||n.setRotation(e,e.rotation,o);break;case"scale":a.equals(e.scale)||n.setScale(e,e.scale,a)}n.controls.enabled=!0})),i}(this.camera,this.renderer),this.transformControls.setSize(.5),this.sceneHelpers.add(this.transformControls)),window.addEventListener("orientationchange",(function(){[n.widthRatio,n.heightRatio]=[n.heightRatio,n.widthRatio]}),!1),window.addEventListener("resize",S,!1),this.dom.addEventListener("click",(function(e){n.dom.focus()}),!1),this.dom.addEventListener("dblclick",(function(e){n.mouseDoubleClickPosition.copy(R(e));var t=n.getIntersectObject("mouseDoubleClick");t&&n.focus(t)}),!1),this.dom.addEventListener("mousemove",(function(e){n.mouseMovePosition.copy(R(e)),n.bokehPass&&n.bokehPass.enabled&&n.bokehPass.mouse.copy(n.mouseMovePosition)}),!1),this.dom.addEventListener("mousedown",(function(e){n.mouseDownPosition.copy(R(e)),document.addEventListener("mouseup",L,!1)}),!1),this.dom.addEventListener("touchmove",(function(e){e.preventDefault(),h&&clearTimeout(h);n.mouseMovePosition.copy(R(e)),n.bokehPass&&n.bokehPass.enabled&&n.bokehPass.mouse.copy(n.mouseMovePosition)}),!0),this.dom.addEventListener("touchstart",(function(e){n.guiContextMenu&&n.guiContextMenu.setDisplay("none");if(e.preventDefault(),v)return;h=setTimeout(k,500,e),v=!0,n.mouseDownPosition.copy(R(e)),document.addEventListener("touchend",P,!1)}),!1),this.dom.addEventListener("keydown",H,!1),this.dom.addEventListener("keyup",(function(e){switch(n.appName){case"NatureWorks":!function(e){switch(e.preventDefault(),e.stopPropagation(),e.keyCode){case 17:n.transformControls.setTranslationSnap(null),n.transformControls.setRotationSnap(null),n.controls.enabled=!0}}(e)}}),!1),this.dom.addEventListener("contextmenu",N,!1),this.renderScene=function(){_()},this.resize=function(e,t){var[n,r]=A();this.widthRatio=(e||n)/n,this.heightRatio=(t||r)/r,S()},this.onKeyDown=function(e){H(e)},this.getBoundingBox=function(){return t.computeBoundingBox(this.scene)},this.getMousePosition=function(e){return R(e)},this.getIntersectObject=function(e){if("string"==typeof e){var t;if("mouseDown"===e)t=this.mouseDownPosition;else if("mouseUp"===e)t=this.mouseUpPosition;else{if("mouseDoubleClick"!==e)return null;t=this.mouseDoubleClickPosition}return(n=M(t,this.selectables)).length>0?n[0].object:null}var n;return this.mouseDownPosition.equals(this.mouseUpPosition)&&(n=M(this.mouseUpPosition,this.selectables)).length>0?(void 0!==e&&(e.object=n[0].object,e.distance=n[0].distance,e.point=n[0].point,e.uv=n[0].uv),n[0].object):null},this.select=function(e,t){if(e){var r=e;if("ancestor"===t)e.traverseAncestors((function(e){e.parent===n.scene&&(r=e)})),this.selectObjects=[r];else if("multiple"===t){var o=this.selectObjects.indexOf(r);-1===o?this.selectObjects.push(r):this.selectObjects.splice(o,1)}else this.selectObjects=[r];this.selectObject=r,this.signals.objectSelected.dispatch(r),this.signals.objectsSelected.dispatch(this.selectObjects)}else this.selectObject=null,this.selectObjects=[],this.signals.objectSelected.dispatch(null),this.signals.objectsSelected.dispatch(this.selectObjects)},this.selectById=function(e,t){e!==this.camera.id?this.select(this.scene.getObjectById(e,!0),t):this.select(this.camera,t)},this.selectByUuid=function(e,t){this.scene.traverse((function(n){n.uuid===e&&this.select(n,t)}))},this.deselect=function(){this.selectObject=null},this.focus=function(e){this.signals&&this.signals.objectFocused.dispatch(e)},this.focusById=function(e){this.focus(this.scene.getObjectById(e,!0))},this.objectByUuid=function(e){return this.scene.getObjectByProperty("uuid",e)},this.addObject=function(e,t,r){e.traverse((function(e){n.addHelper(e)})),void 0===t?this.scene.add(e):(t.children.splice(r,0,e),e.parent=t),this.signals.objectAdded.dispatch(e),this.signals.sceneGraphChanged.dispatch()},this.moveObject=function(e,t,n){if(void 0===t&&(t=this.scene),t.add(e),void 0!==n){var r=t.children.indexOf(n);t.children.splice(r,0,e),t.children.pop()}this.signals.sceneGraphChanged.dispatch()},this.removeObject=function(e){null!==e.parent&&(e.traverse((function(e){n.removeHelper(e)})),e.parent.remove(e),this.signals.objectRemoved.dispatch(e),this.signals.sceneGraphChanged.dispatch())},this.addHelper=(d=new THREE.SphereBufferGeometry(2,4,2),p=new THREE.MeshBasicMaterial({color:16711680,visible:!1}),function(e){if(!t.isDeviceMobile()){var n;if(e instanceof THREE.Camera)(n=new THREE.CameraHelper(e)).name="cameraHelper";else if(e instanceof THREE.PointLight)(n=new THREE.PointLightHelper(e,1)).name="pointLightHelper";else if(e instanceof THREE.DirectionalLight)(n=new THREE.DirectionalLightHelper(e,1)).name="directionalLightHelper","SunLight"===e.userData.type&&(n.visible=!1);else if(e instanceof THREE.SpotLight)(n=new THREE.SpotLightHelper(e)).name="spotLightHelper";else if(e instanceof THREE.HemisphereLight)(n=new THREE.HemisphereLightHelper(e,1)).name="hemisphereLightHelper";else{if(!(e instanceof THREE.SkinnedMesh))return;(n=new THREE.SkeletonHelper(e)).name="skeletonHelper"}var r=new THREE.Mesh(d,p);r.name="picker",r.userData.object=e,n.add(r),e.helper=n,this.sceneHelpers.add(n),this.signals.helperAdded.dispatch(n)}}),this.removeHelper=function(e){var t=e.helper;void 0!==t&&(t.parent.remove(t),this.signals.helperRemoved.dispatch(t))},this.getObjectMaterial=function(e,t){var n=void 0;return e&&(n=e.material,Array.isArray(n)&&void 0!==t&&(n=n[t])),n},this.setObjectMaterial=function(e,t,n){Array.isArray(e.material)&&void 0!==t?e.material[t]=n:e.material=n},this.clear=function(){this.history&&this.history.clear(),this.config&&this.config.clearDatabase(),this.camera.copy(this.defaultCamera);for(var e=this.scene.children;e.length>0;)this.removeObject(e[0]);this.deselect(),this.signals.appWorksCleared.dispatch(),this.signals.windowResize.dispatch()},this.fromJSON=function(e){var t=new THREE.ObjectLoader,r=t.parse(e.camera);this.camera.copy(r),this.camera.aspect=this.defaultCamera.aspect,this.camera.updateProjectionMatrix(),this.history&&this.history.fromJSON(e.history),t.parse(e.scene,(function(e){n.setScene(e)}))},this.toJSON=function(){return{metadata:{},camera:this.camera.toJSON(),scene:this.scene.toJSON(),history:this.history?this.history.toJSON():""}},this.execute=function(e,t){this.history&&this.history.execute(e,t)},this.undo=function(){this.history&&this.history.undo()},this.redo=function(){this.history&&this.history.redo()},this.add=function(e){this.execute(new t.AddObjectCommand(e))},this.remove=function(e){this.execute(new t.RemoveObjectCommand(e))},this.replace=function(e,n){var r=[];r.push(new t.RemoveObjectCommand(e)),r.push(new t.AddObjectCommand(n)),this.multiCmds(r)},this.move=function(e,n,r){e.parent?this.execute(new t.MoveObjectCommand(e,n,r)):Alert("The object cannot be moved to the new parent")},this.moveTo=function(e,t,n){this.add(e),this.move(e,t,n)},this.setPosition=function(e,n,r){this.execute(new t.SetPositionCommand(e,n,r))},this.setRotation=function(e,n,r){this.execute(new t.SetRotationCommand(e,n,r))},this.setScale=function(e,n,r){this.execute(new t.SetScaleCommand(e,n,r))},this.setGeometry=function(e,n){this.execute(new t.SetGeometryCommand(e,n))},this.setGeometryValue=function(e,n,r){this.execute(new t.SetGeometryValueCommand(e,n,r))},this.setMaterial=function(e,n,r){this.execute(new t.SetMaterialCommand(e,n,r))},this.setMaterialValue=function(e,n,r,o){this.execute(new t.SetMaterialValueCommand(e,n,r,o))},this.setMaterialVector=function(e,n,r,o){this.execute(new t.SetMaterialVectorCommand(e,n,r,o))},this.setMaterialColor=function(e,n,r,o){this.execute(new t.SetMaterialColorCommand(e,n,r,o))},this.setMaterialMap=function(e,n,r,o){this.execute(new t.SetMaterialMapCommand(e,n,r,o))},this.setUuid=function(e,n){this.execute(new t.SetUuidCommand(e,n))},this.setValue=function(e,n,r){this.execute(new t.SetValueCommand(e,n,r))},this.setColor=function(e,n,r){this.execute(new t.SetColorCommand(e,n,r))},this.setScene=function(e){this.execute(new t.SetSceneCommand(e))},this.multiCmds=function(e){this.execute(new t.MultiCmdsCommand(e))},t.appWorks=this,"NatureWorks"===this.appName||("ViewWorks"===this.appName?"wordpress.org"!==this.customer&&(t.viewWorksInfo(),t.createFlashtext("ViewWorks",{fontSize:"10vw"}),setTimeout((()=>{t.hideFlashtext()}),3e3)):"MedicalWorks"===this.appName&&(t.createFlashtext("MedicalWorks",{fontSize:"8vw"}),setTimeout((()=>{t.hideFlashtext(),t.demoMedicalExamples()}),3e3)))},t.viewWorksInfo=function(){var e=document.createElement("div");e.id="infoButton",e.innerHTML='        <img src="images/info.png" border="0" />\n    ',e.style.cssText="        position: absolute;\n        left: 0;\n        top: 0;\n        z-index: 2;\n        padding: 8px;\n        margin: 0 0 0 0;\n        text-align: left;\n        display: block;\n    ",e.addEventListener("click",(function(e){var t=document.getElementById("infoPanel").style;t.display="block"==t.display?"none":"block"})),document.getElementById("app-container").parentNode.appendChild(e);var t=document.createElement("div");t.id="infoPanel",t.innerHTML='        <b>ViewWorks - 3D model viewer</b>\n        <p>\n        To view your 3D models,<br>\n        <b>drag & drop the model file(s) onto the browser.</b><br><br>\n        Supported file formats<br>\n        JSON, OBJ(+MTL), STL, PLY, DAE(COLLADA),<br>\n        GLTF, GLB, AMF, 3MF, WRL(VRML), FBX,<br>\n        3DS, DRC, KMZ, MD2, SVG, VTK<br>\n        </p>\n        (C) <a href="https://www.nova-graphix.com/" target="_blank" style="color: #ffa500; text-decoration: none;">NovaGraphix, Co.</a>, 2018.\n    ',t.style.cssText="        position: absolute;\n        left: 0;\n        top: 0;\n        z-index: 1;\n        padding: 32px;\n        margin: 0.5em 0em 0em 0.4em;\n        background: #121212;\n        color: #fff;\n        opacity: 0.8;\n        border-radius: 20px;\n        text-align: left;\n        font-family: 'Karla', sans-serif;\n        font-size: 80%;\n        display: none;\n    ",document.getElementById("app-container").parentNode.appendChild(t)},t.createBackground=function(e){if(!e)return null;if(e.isTexture)return e.encoding=THREE.sRGBEncoding,e;if("number"==typeof e)return new THREE.Color(e);if("string"==typeof e)return"FS"===e.substr(-2,2)?function(e){var n=new THREE.Vector2;t.appWorks.renderer.getSize(n);var r=t.BackgroundShader;(l=THREE.UniformsUtils.clone(r.uniforms)).resolution.value=n;var o=r.vertexShader,a=r[e],i=t.isWebGL1()?{gl_FragDepth:"gl_FragDepthEXT"}:{},s=new THREE.ShaderMaterial({defines:i,uniforms:l,vertexShader:o,fragmentShader:a});if("cloudsFS"===e){var l=s.uniforms,c=(new THREE.TextureLoader).load("images/raymarch/rgbaNoise256.png",(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));l.textureMaps.value.push(c)}s.extensions={derivatives:!0,fragDepth:!0,drawBuffers:!0,shaderTextureLOD:!0};var f=new THREE.PlaneBufferGeometry(2,2);return(e=new THREE.Mesh(f,s)).name="backgroundMesh",e.frustumCulled=!1,e.update=function(e,r){t.appWorks.renderer.getSize(n);var o=this.material.uniforms;o.time.value=r,o.resolution.value=n},e}(e):function(e){var t=".jpg",n="images/background/"+e+"/";switch(e){case"cloud":case"galaxy":case"redSky":case"smallLake":t=".png";break;default:t=".jpg"}var r=["posx"+t,"negx"+t,"posy"+t,"negy"+t,"posz"+t,"negz"+t],o=(new THREE.CubeTextureLoader).setPath(n).load(r);return o.format=THREE.RGBFormat,o.encoding=THREE.sRGBEncoding,o}(e)},t.createFog=function(e){var n=void 0!==(e=e||{}).color?e.color:t.FOG_COLOR;if("linear"===e.type){var r=void 0!==e.near?e.near:this.camera.near,o=void 0!==e.far?e.far:this.camera.far;return new THREE.Fog(n,r,o)}if("exp2"===e.type){var a=void 0!==e.density?e.density:.001;return new THREE.FogExp2(n,a)}return null},t.createCameraControls=function(e,n,r){var o;e=void 0!==e?e:"OrbitControls",n=void 0!==n?n:t.appWorks.camera,r=void 0!==r?r:t.appWorks.renderer.domElement;return t.appWorks&&t.appWorks.controls&&t.appWorks.controls.dispose(),"TrackballControls"===e?((o=new THREE.TrackballControls(n,r)).rotateSpeed=10,o.zoomSpeed=5,o.panSpeed=2,o.staticMoving=!1,o.dynamicDampingFactor=.2,o.enabled=!0):"FirstPersonControls"===e?((o=new THREE.FirstPersonControls(n,r)).movementSpeed=100,o.lookSpeed=.05,o.lookVertical=!0,o.activeLook=!0,o.constrainVertical=!0,o.verticalMin=1.1,o.verticalMax=2.2,o.enabled=!0):((o=new THREE.OrbitControls(n,r)).enablePan=!0,o.enableZoom=!0,o.enableDamping=!0,o.screenSpacePanning=!0,o.dampingFactor=.2,o.panSpeed=1,o.rotateSpeed=1,o.enabled=!0),o},t.playAudio=function(e,n){if(!(Array.isArray(e)&&e.length>0))return null;var r=new b.Howl({src:[e[0]],autoplay:!0,loop:!0,volume:.5,onend:function(){e.shift(),e.length>0&&t.playAudio(e)}});return r.play(),r},t.createCameraEffect=function(e,n){e=void 0!==e?e:"NoEffect",n=void 0!==n?n:t.appWorks.renderer;return"AnaglyphEffect"===e?new THREE.AnaglyphEffect(n):"StereoEffect"===e?new THREE.StereoEffect(n):"ParallaxBarrierEffect"===e?new THREE.ParallaxBarrierEffect(n):null},t.Animator=function(e){e=void 0!==e?e:t.appWorks.scene;this.mixer=new THREE.AnimationMixer(e),this.update=function(e){this.mixer.update(e)},this.addAnimation=function(e,t){t.length>0&&(e.animations=t)},this.createActions=function(e){var t={},n=e.animations;if(void 0!==n){for(var r of n)t[r.name]=this.mixer.clipAction(r,e),e.activeAction||(e.activeAction=t[r.name]);return t}},this.playAction=function(e,n,r){if(e.animations&&0!==e.animations.length){var o=(r=r||{}).duration||1,a=r.loopMode||THREE.LoopRepeat,i=r.repetitions||1/0,s=r.combine||"crossFade";e=void 0!==e?e:t.appWorks.selectObject,n=void 0!==n?n:e.animations[0];if("crossFade"==s){var l=e.activeAction,c=this.mixer.clipAction(n,e);return c?(c.enabled=!0,c.setLoop(a,i),l?(l.enabled=!0,l.crossFadeTo(c,o).play()):c.play(),e.activeAction=c,c):void 0}if("overlap"===s){var f=this.mixer.clipAction(n,e);return f.play(),e.activeAction=f,f}}},this.playNextAction=function(e){var n=(e=void 0!==e?e:t.appWorks.selectObject).animations;if(void 0!==n&&n.length>0){var r=-1;if(e.activeAction){var o=e.activeAction.getClip();r=n.indexOf(o)}var a=n[r=~~((r+1)%n.length)];e.activeAction=this.playAction(e,a),console.log('>> playAction: "'+a.name+'"')}},this.stopAction=function(e,t){if(e&&t)(n=this.mixer.clipAction(t,e)).enabled=!0,n.stop();else if(e&&!t){var n;(n=e.activeAction)&&(n.enabled=!0,n.stop())}},this.stopAllActions=function(){this.mixer.stopAllAction()}},t.createAmbientLight=function(e){var t=(e=e||{}).color||16777215,n=e.intensity||.2,r=new THREE.AmbientLight(t,n);return r.name="ambientLight",r},t.createPointLight=function(e){var n=(e=e||{}).color||16777215,r=e.intensity||1,o=e.distance||0,a=e.decay||2,i=e.near||.01,s=e.far||.2*t.appWorks.camera.far,l=new THREE.PointLight(n,r,o,a);return l.castShadow=!0,l.shadow.camera.near=i,l.shadow.camera.far=s,l.shadow.mapSize.width=2048,l.shadow.mapSize.height=2048,l.shadow.radius=1.5,l.name="pointLight",l},t.createSpotLight=function(e){var n=(e=e||{}).color||16777215,r=e.intensity||1,o=e.distance||0,a=e.angle||.1*Math.PI,i=e.penumbra||.05,s=e.decay||2,l=e.near||.01,c=e.far||.2*t.appWorks.camera.far,f=e.target,u=new THREE.SpotLight(n,r,o,a,i,s);return u.castShadow=!0,u.shadow.camera.near=l,u.shadow.camera.far=c,u.shadow.mapSize.width=2048,u.shadow.mapSize.height=2048,u.shadow.radius=1.5,u.name="spotLight",f&&f.isObject3D&&(u.target=f,t.appWorks.scene.getObjectById(f.id)||t.add(f)),u},t.createDirectionalLight=function(e){var n=(e=e||{}).color||16777215,r=e.intensity||1,o=e.target,a=e.shadowCameraSize||.2*t.appWorks.camera.far,i=new THREE.DirectionalLight(n,r);return i.castShadow=!0,i.shadow.camera.top=a,i.shadow.camera.bottom=-a,i.shadow.camera.left=-a,i.shadow.camera.right=a,i.shadow.camera.near=.01,i.shadow.camera.far=2.5*a,i.shadow.mapSize.width=2048,i.shadow.mapSize.height=2048,i.shadow.radius=1.5,i.shadow.bias=1e-4,i.name="directionalLight",o&&o.isObject3D&&(i.target=o,t.appWorks.scene.getObjectById(o.id)||t.add(o)),i},t.createHemisphereLight=function(e){var t=(e=e||{}).skyColor||(new THREE.Color).setHSL(.6,1,.6),n=e.groundColor||(new THREE.Color).setHSL(.095,1,.75),r=e.intensity||1,o=new THREE.HemisphereLight(t,n,r);return o.name="hemisphereLight",o},t.createThreePointLights=function(){var e,n=new THREE.Object3D;return n.name="threePointLights",(e=t.createAmbientLight({color:1052688})).name="ambient_light",n.add(e),(e=t.createDirectionalLight({color:16777215,intensity:.225})).position.set(26,10,30),e.name="back_light",n.add(e),(e=t.createDirectionalLight({color:16777215,intensity:.375})).position.set(-20,-10,0),e.name="key_light",n.add(e),(e=t.createDirectionalLight({color:16777215,intensity:.75})).position.set(30,30,20),e.name="fill_light",n.add(e),n},t.createSunsetLights=function(){var e,n=new THREE.Object3D;return n.name="sunsetLights",(e=t.createAmbientLight({color:526344})).name="ambient_light",n.add(e),(e=t.createDirectionalLight({color:1644912,intensity:1})).name="midnightblue_light",e.position.set(50,10,0),n.add(e),(e=t.createDirectionalLight({color:9109504,intensity:1.5})).name="darkred_light",e.position.set(0,10,0),n.add(e),n},t.createThreeSpotLights=function(e,n){n=n||{},e=void 0!==e?e:100;var r=new THREE.Object3D;r.name="threeSpotLights";var o=2*Math.PI,a=Math.PI/3,i=Math.PI/6,s=Math.cos(i),l=Math.sin(i),c=.6*e,f=t.createSpotLight();f.position.set(0,c,e),r.add(f),n.target&&(f.target=n.target),!0===n.rotate&&(f.update=function(t,n){var r=.1*n%o;f.position.x=e*Math.sin(r),f.position.z=e*Math.cos(r)});var u=t.createSpotLight();u.position.set(-e*s,c,-e*l),r.add(u),n.target&&(u.target=n.target),!0===n.rotate&&(u.update=function(t,n){var r=.1*n%o;u.position.x=e*-Math.sin(r+a),u.position.z=e*-Math.cos(r+a)});var d=t.createSpotLight();return d.position.set(e*s,c,-e*l),r.add(d),n.target&&(d.target=n.target),!0===n.rotate&&(d.update=function(t,n){var r=.1*n%o;d.position.x=e*Math.cos(r+i),d.position.z=e*-Math.sin(r+i)}),r};var _=__webpack_require__(743);t.loadJSON=function(e){function n(n,r){var o,a=new THREE.LegacyJSONLoader(e.manager).parse(n,r),i=a.geometry;if(i instanceof THREE.Geometry&&(i.morphTargets.length>0||i.skinIndices.length>0)){i=t.toNonIndexedBufferGeometry(a.geometry);var s=a.geometry.animations;s&&(i.animations=s)}var l=a.materials;if(function(e,t){var n=THREE.NoColors;if(e instanceof THREE.Geometry){var r=!1,o=!1;e.faces[0].vertexColors.length>0&&(r=!0),e.faces[0].color.equals(new THREE.Color)||(o=!0),n=r?THREE.VertexColors:o?THREE.FaceColors:THREE.NoColors}else e.attributes.color&&(n=THREE.VertexColors);t.forEach((function(e){e.vertexColors=n}))}(i,l),i instanceof THREE.BufferGeometry&&i.attributes.skinIndex){o=new THREE.SkinnedMesh(i,l);for(var c=[],f=n.bones,u=0,d=f.length;u<d;u++){var p=(new THREE.Vector3).fromArray(f[u].pos),h=(new THREE.Quaternion).fromArray(f[u].rotq),v=new THREE.Bone;v.position.copy(p),v.quaternion.copy(h),v.name=f[u].name,c.push(v)}var m=new THREE.Skeleton(c);o.bind(m)}else o=new THREE.Mesh(i,l);return i.animations&&(l.forEach((function(e){e.morphTargets=!0})),i.animations.length>0&&(o.animations=i.animations)),o.castShadow=!0,o.receiveShadow=!0,o.name=e.url,o}function r(r,o){var a;switch(void 0===r.metadata&&(r.metadata={type:"Geometry"}),void 0===r.metadata.type&&(r.metadata.type="Geometry"),void 0!==r.metadata.formatVersion&&(r.metadata.version=r.metadata.formatVersion),r.metadata.type.toLowerCase()){case"buffergeometry":a=function(t){var n=new THREE.BufferGeometryLoader(e.manager).parse(t);return mesh=new THREE.Mesh(n),mesh.castShadow=!0,mesh.receiveShadow=!0,mesh.name=e.url,mesh}(r);break;case"geometry":a=n(r,o);break;case"object":a=function(n,r){var o=new THREE.ObjectLoader(e.manager);o.setPath(r),o.setResourcePath(r);var a=o.parse(n);if(a instanceof THREE.Scene)t.appWorks.setScene(a),a.name=e.url;else{if("natureObject"===a.name){var i=new THREE.Object3D;a.children.forEach((function(n){if(void 0!==e.resourcePath){var r=n.userData.options.textureFiles;void 0!==r&&r.forEach(((t,n)=>{r[n]=e.resourcePath+t}))}i.add(t.cloneObject(n))})),a=i}a.castShadow=!0,a.receiveShadow=!0,a.name=e.url}return a}(r,o)}e.callback&&e.callback(a)}var o=null!=e.basePath?e.basePath:"models/json/";new THREE.FileLoader(e.manager).load(e.url,(function(e){r(JSON.parse(e),o)}))},t.loadOBJ=function(e){var t=e.obj||null,n=e.mtl||null,r=e.basePath||"";function o(t,n,r){var o=new THREE.OBJLoader(e.manager);o.setPath(t),r&&o.setMaterials(r),o.load(n,(function(r){r.traverse((function(e){e instanceof THREE.Mesh&&(e.castShadow=!0,e.receiveShadow=!0)})),r.name=t+n,e.callback&&e.callback(r)}),(function(e){if(e.lengthComputable){var t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% loaded")}}),(function(e){console.log("OBJLoader: error happened")}))}if(n){var a=new THREE.MTLLoader(e.manager);a.setPath(r),a.load(n,(function(e){e.preload(),o(r,t,e)}))}else o(r,t)},t.loadSTL=function(e){new THREE.STLLoader(e.manager).load(e.url,(function(n){!function(n){var r;t.computeVertexNormals(n),r=n.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial;var o=new THREE.Mesh(n,r);o.castShadow=!0,o.receiveShadow=!0,o.name=e.url,e.callback&&e.callback(o)}(n)}))},t.loadPLY=function(e){new THREE.PLYLoader(e.manager).load(e.url,(function(n){!function(n){t.computeVertexNormals(n);var r=new THREE.Mesh(n,new THREE.MeshStandardMaterial);r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(n)}))},t.loadDAE=function(e){new THREE.ColladaLoader(e.manager).load(e.url,(function(t){!function(t){var n=t.scene;t.animations.length>0&&(n.animations=t.animations),n.frustumCulled=!1,n.castShadow=!0,n.receiveShadow=!0,n.name=e.url,e.callback&&e.callback(n)}(t)}))},t.loadGLB=function(e){var n=new THREE.DRACOLoader(e.manager);n.setDecoderPath("js/draco/");var r=new THREE.GLTFLoader(e.manager);r.setDRACOLoader(n),r.load(e.url,(function(n){!function(n){var r=n.scene||n.scenes[0],o=n.animations||[],a=t.appWorks.scene.background;a&&a.isCubeTexture&&r.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=a,t.needsUpdate=!0)})),o.length>0&&(r.animations=o),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(n)}),void 0,(function(e){console.error(e)}))},t.loadGLTF=function(e){var n=new THREE.DRACOLoader(e.manager);n.setDecoderPath("js/draco/");var r=new THREE.GLTFLoader(e.manager);r.setDRACOLoader(n),r.load(e.url,(function(n){!function(n){var r=n.scene||n.scenes[0],o=n.animations||[];r.traverse((function(e){if(e.isMesh){var t=e.geometry.attributes.color;if(t&&4===t.itemSize){var n=e.material;!0===n.vertexColors&&(n.vertexColors=!1,n.needsUpdate=!0)}}}));var a=t.appWorks.scene.background;a&&a.isCubeTexture&&r.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=a,t.needsUpdate=!0)})),o.length>0&&(r.animations=o),r.frustumCulled=!1,r.castShadow=!0,r.receiveShadow=!0,r.name=e.url,e.callback&&e.callback(r)}(n)}),void 0,(function(e){console.error(e)}))},t.loadAMF=function(e){new THREE.AMFLoader(e.manager).load(e.url,(function(t){!function(t){t.castShadow=!0,t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},t.load3MF=function(e){var t=new THREE.ThreeMFLoader(e.manager);t.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension),t.load(e.url,(function(t){!function(t){t.castShadow=!0,t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},t.loadWRL=function(e){new THREE.VRMLLoader(e.manager).load(e.url,(function(t){!function(t){t.traverse((function(e){e instanceof THREE.Mesh&&(e.material.map?(e.material.color.setHex(16777215),e.material.vertexColors=THREE.NoColors):e.geometry.attributes.color&&(e.material.vertexColors=THREE.VertexColors,e.material.color.setHex(16777215)))})),t.receiveShadow=!0,t.name=e.url,e.callback&&e.callback(t)}(t)}))},t.loadFBX=function(e){new THREE.FBXLoader(e.manager).load(e.url,(function(t){!function(t){var n=t;n.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),n.frustumCulled=!1,n.castShadow=!0,n.receiveShadow=!0,n.name=e.url,e.callback&&e.callback(n)}(t)}))},t.loadMedical=function(e){var n=new t.MedicalLoader,r=e.basePath||"";n.setPath(r),n.load(e.url,(function(n){!function(n){let r=new t.MedicalVolume(n);Array.isArray(e.url)&&e.url.length>0?r.name=e.url[0]:r.name="medicalVolume";let o=new t.LookupTables;o.lut="default",r.lutTexture=o.texture,r.lut=!0;let a=n.worldCenter();t.appWorks.camera.lookAt(a),t.appWorks.controls.target.copy(a),e.callback&&e.callback(r)}(n)}))},t.loadFiles=function(e){var n=e.url;if(void 0!==n){var r=n.split(".").pop().toLowerCase();switch(r){case"js":case"json":t.loadJSON(e);break;case"obj":var o=e.acrossDomain||!1,a=n.split("/").pop(),i=a.replace(r,"mtl"),s=n.replace(a,"");t.fileExist(s+i,(n=>{t.loadOBJ({obj:a,mtl:n?i:null,basePath:s,callback:e.callback})}),o);break;case"stl":t.loadSTL(e);break;case"ply":t.loadPLY(e);break;case"dae":t.loadDAE(e);break;case"glb":t.loadGLB(e);break;case"gltf":t.loadGLTF(e);break;case"amf":t.loadAMF(e);break;case"3mf":t.load3MF(e);break;case"wrl":t.loadWRL(e);break;case"fbx":t.loadFBX(e);break;default:e.callback&&e.callback(null)}}else alert("There is no url to the file.")},t.Loader=function(){var e=this;function n(e,t){t.length>0&&e.animations.push(...t)}function r(e){t.add(e),t.welcomeObject(e)}function o(e){t.appWorks.setScene(e)}function a(n){switch(void 0===n.metadata&&(n.metadata={type:"Geometry"}),void 0===n.metadata.type&&(n.metadata.type="Geometry"),void 0!==n.metadata.formatVersion&&(n.metadata.version=n.metadata.formatVersion),n.metadata.type.toLowerCase()){case"buffergeometry":var a=(i=new THREE.BufferGeometryLoader).parse(n);r(new THREE.Mesh(a));break;case"geometry":console.error('Loader: "Geometry" is no longer supported.');break;case"object":var i;(i=new THREE.ObjectLoader).setResourcePath(e.texturePath),i.parse(n,(function(e){e.isScene?o(e):"natureObject"===e.name?e.children.forEach((function(e){t.add(t.cloneObject(e))})):r(e)}));break;case"app":t.appWorks.fromJSON(n)}}this.texturePath="",this.loadItemList=function(n){t.LoaderUtils.getFilesFromItemList(n,(function(t,n){e.loadFiles(t,n)}))},this.loadFiles=function(n,r){if(n.length>0){r=r||t.LoaderUtils.createFilesMap(n);var o=new THREE.LoadingManager;o.onStart=()=>{t.createProgressbar()},o.onProgress=(e,n,r)=>{t.updateProgressbar(n,r)},o.onLoad=()=>{t.hideProgressbar()},o.onError=e=>{t.errorProgressbar("There was an error loading "+e)},o.setURLModifier((function(e){e=e.replace(/^(\.?\/)/,"");var t=r[e];return t?(console.log("Loading",e),URL.createObjectURL(t)):e})),o.addHandler(/\.tga$/i,new THREE.TGALoader);for(var a=0;a<n.length;a++)e.loadFile(n[a],o)}},this.loadFile=function(e,i){var s=e.name,l=s.split(".").pop().toLowerCase(),c=new FileReader;switch(c.addEventListener("progress",(function(e){var t="("+Math.floor(e.total/1e3).format()+" KB)",n=Math.floor(e.loaded/e.total*100)+"%";console.log("Loading",s,t,n)})),l){case"3ds":c.addEventListener("load",(function(e){var t=new THREE.TDSLoader(i).parse(e.target.result);t.name=s,r(t)}),!1),c.readAsArrayBuffer(e);break;case"3mf":c.addEventListener("load",(function(e){var t=new THREE.ThreeMFLoader;t.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension);var n=t.parse(e.target.result);n.name=s,r(n)}),!1),c.readAsArrayBuffer(e);break;case"amf":c.addEventListener("load",(function(e){var t=(new THREE.AMFLoader).parse(e.target.result);t.name=s,r(t)}),!1),c.readAsArrayBuffer(e);break;case"dae":c.addEventListener("load",(function(e){var t=e.target.result,o=new THREE.ColladaLoader(i).parse(t);o.scene.name=s,n(o.scene,o.animations),r(o.scene)}),!1),c.readAsText(e);break;case"drc":c.addEventListener("load",(function(e){var n=e.target.result,o=new THREE.DRACOLoader;o.setDecoderPath("js/draco/"),o.decodeDracoFile(n,(function(e){var n;if(e.center(),t.computeVertexNormals(e),null!==e.index){var o=new THREE.MeshStandardMaterial;(n=new THREE.Mesh(e,o)).name=s}else{o=new THREE.PointsMaterial({size:.01});!0===e.hasAttribute("color")&&(o.vertexColors=!0),(n=new THREE.Points(e,o)).name=s}r(n)}))}),!1),c.readAsArrayBuffer(e);break;case"fbx":c.addEventListener("load",(function(e){var t=e.target.result,o=new THREE.FBXLoader(i).parse(t);o.name=s,n(o,o.animations),r(o)}),!1),c.readAsArrayBuffer(e);break;case"glb":c.addEventListener("load",(function(e){var t=e.target.result,o=new THREE.DRACOLoader;o.setDecoderPath("js/draco/");var a=new THREE.GLTFLoader(i);a.setDRACOLoader(o),a.parse(t,"",(function(e){var t=e.scene;t.name=s,n(t,e.animations),r(t)}))}),!1),c.readAsArrayBuffer(e);break;case"gltf":c.addEventListener("load",(function(e){var t=e.target.result;if(function(e){var t;if("string"==typeof e)t=e;else{if("glTF"===THREE.LoaderUtils.decodeText(new Uint8Array(e,0,4)))return new DataView(e).getUint32(4,!0)<2;t=THREE.LoaderUtils.decodeText(new Uint8Array(e))}var n=JSON.parse(t);return null!=n.asset&&n.asset.version[0]<2}(t))alert("Import of glTF asset not possible. Only versions >= 2.0 are supported. Please try to upgrade the file to glTF 2.0 using glTF-Pipeline.");else{var o,a=new THREE.DRACOLoader;a.setDecoderPath("js/draco/"),(o=new THREE.GLTFLoader(i)).setDRACOLoader(a)}o.parse(t,"",(function(e){var t=e.scene;t.name=s,t.traverse((function(e){if(e.isMesh){var t=e.geometry.attributes.color;if(t&&4===t.itemSize){var n=e.material;!0===n.vertexColors&&(n.vertexColors=!1,n.needsUpdate=!0)}}})),n(t,e.animations),r(t)}))}),!1),c.readAsArrayBuffer(e);break;case"js":case"json":c.addEventListener("load",(function(e){var t,n=e.target.result;if(-1!==n.indexOf("postMessage")){var r=new Blob([n],{type:"text/javascript"}),o=URL.createObjectURL(r),i=new Worker(o);return i.onmessage=function(e){e.data.metadata={version:2},a(e.data)},void i.postMessage(Date.now())}try{t=JSON.parse(n)}catch(e){return void alert(e)}a(t)}),!1),c.readAsText(e);break;case"kmz":c.addEventListener("load",(function(e){var t=(new THREE.KMZLoader).parse(e.target.result);t.scene.name=s,r(t.scene)}),!1),c.readAsArrayBuffer(e);break;case"md2":c.addEventListener("load",(function(e){var t=e.target.result,o=(new THREE.MD2Loader).parse(t),a=new THREE.MeshStandardMaterial({morphTargets:!0,morphNormals:!0}),i=new THREE.Mesh(o,a);i.mixer=new THREE.AnimationMixer(i),i.name=s,n(i,o.animations),r(i)}),!1),c.readAsArrayBuffer(e);break;case"obj":c.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.OBJLoader).parse(t);n.name=s,r(n)}),!1),c.readAsText(e);break;case"ply":c.addEventListener("load",(function(e){var n=e.target.result,o=(new THREE.PLYLoader).parse(n);t.computeVertexNormals(o);var a=new THREE.MeshStandardMaterial,i=new THREE.Mesh(o,a);i.name=s,r(i)}),!1),c.readAsArrayBuffer(e);break;case"stl":c.addEventListener("load",(function(e){var n,o=e.target.result,a=(new THREE.STLLoader).parse(o);t.computeVertexNormals(a),n=a.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial;var i=new THREE.Mesh(a,n);i.name=s,r(i)}),!1),void 0!==c.readAsBinaryString?c.readAsBinaryString(e):c.readAsArrayBuffer(e);break;case"svg":c.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.SVGLoader).parse(t).paths,o=new THREE.Group;o.scale.multiplyScalar(.1),o.scale.y*=-1;for(var a=0;a<n.length;a++)for(var i=n[a],l=new THREE.MeshBasicMaterial({color:i.color,depthWrite:!1}),c=THREE.SVGLoader.createShapes(i),f=0;f<c.length;f++){var u=c[f],d=new THREE.ShapeGeometry(u),p=new THREE.Mesh(d,l);o.add(p)}o.name=s,r(o)}),!1),c.readAsText(e);break;case"vtk":c.addEventListener("load",(function(e){var n=e.target.result,o=(new THREE.VTKLoader).parse(n);t.computeVertexNormals(o);var a=new THREE.MeshStandardMaterial,i=new THREE.Mesh(o,a);i.name=s,r(i)}),!1),c.readAsArrayBuffer(e);break;case"wrl":c.addEventListener("load",(function(e){var t=e.target.result,n=(new THREE.VRMLLoader).parse(t);n.name=s,o(n)}),!1),c.readAsText(e);break;case"zip":c.addEventListener("load",(function(e){!function(e){var o=(0,_.unzipSync)(new Uint8Array(e));if(o["model.obj"]&&o["materials.mtl"]){var a=(new MTLLoader).parse((0,_.strFromU8)(o["materials.mtl"]));r((new OBJLoader).setMaterials(a).parse((0,_.strFromU8)(o["model.obj"])))}for(var i in o){var s=o[i],l=new THREE.LoadingManager;switch(l.onStart=()=>{t.createProgressbar()},l.onProgress=(e,n,r)=>{t.updateProgressbar(n,r)},l.onLoad=()=>{t.hideProgressbar()},l.onError=e=>{t.errorProgressbar("There was an error loading "+e)},l.setURLModifier((function(e){var t=o[e];if(t){console.log("Loading",e);var n=new Blob([t.buffer],{type:"application/octet-stream"});return URL.createObjectURL(n)}return e})),i.split(".").pop().toLowerCase()){case"fbx":r((f=new THREE.FBXLoader(l)).parse(s.buffer));break;case"glb":(c=new DRACOLoader).setDecoderPath("js/draco/"),(f=new GLTFLoader).setDRACOLoader(c),f.parse(s.buffer,"",(function(e){var t=e.scene;n(t,e.animations),r(t)}));break;case"gltf":var c,f;(c=new DRACOLoader).setDecoderPath("js/draco/"),(f=new GLTFLoader(l)).setDRACOLoader(c),f.parse((0,_.strFromU8)(s),"",(function(e){var t=e.scene;n(t,e.animations),r(t)}))}}}(e.target.result)}),!1),c.readAsArrayBuffer(e)}}},t.LoaderUtils={createFilesMap:function(e){for(var t={},n=0;n<e.length;n++){var r=e[n];t[r.name]=r}return t},getFilesFromItemList:function(e,t){var n=0,r=0,o=[],a={};function i(){++n===r&&t(o,a)}function s(e){if(e){if(e.isDirectory)e.createReader().readEntries((function(e){for(var t=0;t<e.length;t++)s(e[t]);i()}));else e.isFile&&e.file((function(t){o.push(t),a[e.fullPath.substr(1)]=t,i()}));r++}}for(var l=0;l<e.length;l++)s(e[l].webkitGetAsEntry())}},t.Loader2=function(){var e=this;this.fromFiles=function(e,t){if(e[0].name.match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i))return void this._loadMedicalFiles(t);const n=new Map;e.forEach((e=>n.set(e.name,e))),this.loadFiles(n)},this.fromEvent=function(t){if(t.dataTransfer.files[0].name.match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i))return void this._loadMedicalFiles(t);let n;if(t.dataTransfer.items)n=[].slice.call(t.dataTransfer.items).map((e=>e.webkitGetAsEntry()));else if(1===(t.dataTransfer.files||[]).length){const e=t.dataTransfer.files[0];return"application/zip"===e.type?void alert("zip file: not supported"):void this.loadFiles(new Map([[e.name,e]]))}n||alert("Required drag & drop is not supported in this browser."),1===n.length&&n[0].name.match(/\.zip$/)?alert("zip file: not supported"):function t(n,r){const o=r.pop();if(!o)return void e.loadFiles(n);if(o.isFile)o.file((e=>{n.set(o.fullPath,e),t(n,r)}),(()=>console.error("Could not load file: %s",o.fullPath)));else if(o.isDirectory){const e=o.createReader(),a=o=>{o.length?(r=r.concat(o),e.readEntries(a)):t(n,r)};e.readEntries(a)}else console.warn("Unknown asset type: "+o.fullPath),t(n,r)}(new Map,n)},this.loadFiles=function(n){for(var r of n.values())console.log("Loading:",r.name,"("+t.humanFileSize(r.size)+")");var o;let a,i;var s=[];Array.from(n).forEach((([e,t])=>{t.name.match(/\.(js|json|obj|stl|ply|dae|gltf|glb|amf|3mf|wrl|fbx|md2|vtk)$/i)?(a=t,i=e.replace(t.name,""),o=t.name.split(".").pop().toLowerCase()):t.name.match(/\.(png|jpg|gif)$/i)&&s.push(t)})),a||console.warn("No asset found.");const l="string"==typeof a?a:URL.createObjectURL(a),c=THREE.LoaderUtils.extractUrlBase(l);return new Promise(((r,f)=>{const u=[],d=new THREE.LoadingManager;switch(d.onStart=()=>{t.createProgressbar()},d.onProgress=(e,n,r)=>{t.updateProgressbar(n,r)},d.onLoad=()=>{t.hideProgressbar()},d.onError=e=>{t.errorProgressbar("There was an error loading "+e)},d.setURLModifier(((e,t)=>{const r=i+decodeURI(e).replace(c,"").replace(/^(\.?\/)/,"");if(n.has(r)){const e=n.get(r),t=URL.createObjectURL(e);return u.push(t),t}return(t||"")+e})),o){case"js":case"json":!function(n,o){function i(e,t){var n=THREE.NoColors;if(e instanceof THREE.Geometry){var r=!1,o=!1;e.faces[0].vertexColors.length>0&&(r=!0),e.faces[0].color.equals(new THREE.Color)||(o=!0),n=r?THREE.VertexColors:o?THREE.FaceColors:THREE.NoColors}else e.attributes.color&&(n=THREE.VertexColors);t.forEach((function(e){e.vertexColors=n}))}function s(e,t){var n=new THREE.BufferGeometryLoader(t).parse(e);return mesh=new THREE.Mesh(n),h(mesh),mesh}function l(e,n,r){var o,a=new THREE.LegacyJSONLoader(n).parse(e,r),s=a.geometry;if(s instanceof THREE.Geometry&&(s.morphTargets.length>0||s.skinIndices.length>0)){s=t.toNonIndexedBufferGeometry(a.geometry);var l=a.geometry.animations;l&&(s.animations=l)}var c=a.materials;if(i(s,c),s instanceof THREE.BufferGeometry&&s.attributes.skinIndex){o=new THREE.SkinnedMesh(s,c);for(var f=[],u=e.bones,d=0,p=u.length;d<p;d++){var v=(new THREE.Vector3).fromArray(u[d].pos),m=(new THREE.Quaternion).fromArray(u[d].rotq),x=new THREE.Bone;x.position.copy(v),x.quaternion.copy(m),x.name=u[d].name,f.push(x)}var g=new THREE.Skeleton(f);o.bind(g)}else o=new THREE.Mesh(s,c);return s.animations&&(c.forEach((function(e){e.morphTargets=!0})),s.animations.length>0&&(o.animations=s.animations)),h(o),o}function c(e,n,r){var o=new THREE.ObjectLoader(n);o.setPath(r),o.setResourcePath(r);var i=o.parse(e);return i instanceof THREE.Scene?(t.appWorks.setScene(i),i.name=a.name):"natureObject"===i.name?i.children.forEach((function(e){t.add(t.cloneObject(e))})):h(i),i}function d(e,t,n){switch(void 0===e.metadata&&(e.metadata={type:"Geometry"}),void 0===e.metadata.type&&(e.metadata.type="Geometry"),void 0!==e.metadata.formatVersion&&(e.metadata.version=e.metadata.formatVersion),e.metadata.type.toLowerCase()){case"buffergeometry":s(e,t);break;case"geometry":l(e,t,n);break;case"object":c(e,t,n)}}new THREE.FileLoader(o).load(n,(t=>{d(JSON.parse(t),o,e.basePath),u.forEach(URL.revokeObjectURL),r(t)}),p,f)}(l,d);break;case"obj":!function(e,t){var o;for(var a of n.values())if(a.name.match(/\.(mtl|MTL)$/)){o=a;break}function i(e){if(void 0!==e){const n=URL.createObjectURL(e);new THREE.MTLLoader(t).load(n,(e=>{e.preload(),s(e),r(e)}),p,f)}else s()}function s(n){var o=new THREE.OBJLoader(t);n&&o.setMaterials(n),o.load(e,(e=>{h(e),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}i(o)}(l,d);break;case"stl":!function(e,n){new THREE.STLLoader(n).load(e,(e=>{var n;t.computeVertexNormals(e),n=e.hasColors?new THREE.MeshStandardMaterial({vertexColors:THREE.VertexColors}):new THREE.MeshStandardMaterial,h(new THREE.Mesh(e,n)),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"ply":!function(e,n){new THREE.PLYLoader(n).load(e,(e=>{t.computeVertexNormals(e),h(new THREE.Mesh(e,new THREE.MeshStandardMaterial)),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"dae":!function(e,t){new THREE.ColladaLoader(t).load(e,(e=>{var t=e.scene;e.animations.length>0&&(t.animations=e.animations),h(t),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"gltf":case"glb":!function(e,n){const o=new THREE.DRACOLoader(n);o.setDecoderPath("js/draco/");const a=new THREE.GLTFLoader(n);a.setDRACOLoader(o),a.load(e,(e=>{var n=e.scene||e.scenes[0],o=e.animations||[],a=t.appWorks.scene.background;a&&a.isCubeTexture&&n.traverse((function(e){var t=e.material;t&&(t.isMeshStandardMaterial||t.isShaderMaterial&&void 0!==t.envMap)&&(t.envMap=a,t.needsUpdate=!0)})),o.length>0&&(n.animations=o),h(n),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"amf":!function(e,t){new THREE.AMFLoader(t).load(e,(e=>{h(e),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"3mf":!function(e,t){var n=new THREE.ThreeMFLoader(t);n.addExtension(THREE.ThreeMFLoader.MaterialsAndPropertiesExtension),n.load(e,(e=>{h(e),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"wrl":!function(e,t){new THREE.VRMLLoader(t).load(e,(e=>{e.traverse((function(e){e instanceof THREE.Mesh&&(e.material.map?(e.material.color.setHex(16777215),e.material.vertexColors=THREE.NoColors):e.geometry.attributes.color&&(e.material.vertexColors=THREE.VertexColors,e.material.color.setHex(16777215)))})),h(e),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"fbx":!function(e,t){new THREE.FBXLoader(t).load(e,(e=>{e.traverse((function(e){e.isMesh&&(e.castShadow=!0,e.receiveShadow=!0)})),h(e),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"md2":!function(e,t){new THREE.MD2Loader(t).load(e,(e=>{var t=null;1===s.length&&(t=(new THREE.TextureLoader).load(URL.createObjectURL(s[0])));var n,o,a=new THREE.MeshStandardMaterial({map:t,morphTargets:!0,morphNormals:!0}),i=new THREE.Mesh(e,a);i.mixer=new THREE.AnimationMixer(i),n=i,(o=e.animations).length>0&&(n.animations=o),h(i),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;case"vtk":!function(e,n){new THREE.VTKLoader(n).load(e,(e=>{e.center(),t.computeVertexNormals(e);var n=new THREE.MeshStandardMaterial;h(new THREE.Mesh(e,n)),u.forEach(URL.revokeObjectURL),r(e)}),p,f)}(l,d);break;default:r(null)}function p(e){if(e.lengthComputable){var t=e.loaded/e.total*100;console.log(Math.round(t,2)+"% loaded")}}function h(e){e.name=a.name,t.add(e),t.welcomeObject(e)}}))},this._loadMedicalFiles=function(e){t.MedicalLoadFiles(e,(e=>{t.removeMedicalWorkspace(),t.createMedicalWorkspace(e,"quadWorkspace")}))}},t.Saver=function(){var e=document.createElement("a");this.saveFile=function(n){var r,o=n.split(".").pop().toLowerCase();switch("NatureWorks"===appWorks.appName?((r=new THREE.Object3D).name="natureObject",appWorks.scene.children.forEach((function(e){r.add(t.cloneObject(e))}))):r=appWorks.scene,o){case"json":!function(e,t){t=t||"object.json";var n=e.toJSON();try{n=(n=JSON.stringify(n,a,"\t")).replace(/[\n\t]+([\d\.e\-\[\]]+)/g,"$1")}catch(e){n=JSON.stringify(n)}i(n,t)}(r,n);break;case"obj":!function(e,t){t=t||"model.obj";i((new THREE.OBJExporter).parse(e),t)}(r,n);break;case"dae":!function(e,t){t=t||"scene.dae";(new THREE.ColladaExporter).parse(e,(function(e){i(e.data,t)}))}(r,n);break;case"glb":!function(e,t){t=t||"scene.glb";(new THREE.GLTFExporter).parse(e,(function(e){s(e,t)}),{binary:!0,forceIndices:!0,forcePowerOfTwoTextures:!0})}(r,n);break;case"gltf":!function(e,t){t=t||"scene.gltf";(new THREE.GLTFExporter).parse(e,(function(e){i(JSON.stringify(e,null,2),t)}))}(r,n);break;case"stl":!function(e,t,n){t=t||"model.stl";var r=new THREE.STLExporter;!0===n?i(r.parse(e),t):s(r.parse(e,{binary:!0}),t)}(r,n);break;case"ply":!function(e,t){t=t||"model.ply";i((new THREE.PLYExporter).parse(e),t)}(r,n);break;default:alert('The file type "'+o+'" is not supported.')}function a(e,t){return"number"==typeof t?parseFloat(t.toFixed(6)):t}function i(e,t){l(new Blob([e],{type:"text/plain"}),t)}function s(e,t){l(new Blob([e],{type:"application/octet-stream"}),t)}function l(t,n){e.href=URL.createObjectURL(t),e.download=n||"data.json",e.dispatchEvent(new MouseEvent("click"))}}},t.FileExplorer=function(e){e=e||t.appWorks;var n=this;this.basePath="models/",this.openFile=function(){this.fileInput.click()},this.saveAsFile=function(e){this.fileOutput.fileExtension=e,this.fileOutput.click()},this.saver=new t.Saver,this.fileOutput=document.createElement("div"),this.fileOutput.addEventListener("click",(function(){var e=n.fileOutput.fileExtension;n.saver.saveFile("model."+e)})),this.loader=new t.Loader,this.loader2=new t.Loader2;var r=document.createElement("input");r.type="file",r.multiple=!0,r.style.display="none",this.fileInput=r,r.addEventListener("change",(function(e){for(var t,o=[].slice.call(r.files),a=0;a<o.length;a++)if((t=o[a].name).match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i)||t.match(/\.(json|js|obj|mtl|md2|vtk)$/i))return void n.loader2.fromFiles(o,e);n.loader.loadFiles(r.files)}));var o=e.dom;o.addEventListener("dragover",(function(e){e.preventDefault(),e.stopPropagation(),o.classList.add("dragover")})),o.addEventListener("dragleave",(function(e){e.preventDefault(),e.stopPropagation(),o.classList.remove("dragover")})),o.addEventListener("drop",(function(e){if(e.preventDefault(),"text/plain"!==e.dataTransfer.types[0]){for(var t,r=e.dataTransfer.files,o=0;o<r.length;o++)if((t=r[o].name).match(/\.(nii|dcm|dic|dicom|ima|mhd|nrrd|mgh|mgz|gz)$/i)||t.match(/\.(json|js|obj|mtl|md2|vtk)$/i))return void n.loader2.fromEvent(e);e.dataTransfer.items?n.loader.loadItemList(e.dataTransfer.items):n.loader.loadFiles(e.dataTransfer.files)}}),!1)},t.HGTLoader=function(){this.loadTile=function(e,n,r){var o=this,a=new THREE.TextureLoader;a.crossOrigin=!0;a.load("https://maps.googleapis.com/maps/api/staticmap?center="+e+","+n+"&zoom="+r+"&size=512x512&scale=2&maptype=satellite&key=AIzaSyA1qxvvl1sFBFLj5rx4cXHJ_1soxQ_GMpw",(function(a){var i=new THREE.PlaneBufferGeometry(20,20,128,128),s=new THREE.MeshPhongMaterial({map:a,shading:THREE.SmoothShading});o.heightMapping(i,e,n,r);var l=new THREE.Mesh(i,s);l.rotation.x=-Math.PI/2,l.frustumCulled=!1,l.castShadow=!1,l.receiveShadow=!0,l.name="SRTM.hgt",t.add(l)}))},this.heightMapping=function(e,t,n,r){var o=e.attributes.position,a=Math.sqrt(o.count),i=o.array,s=20/(Math.abs(40075160*Math.cos(t*(Math.PI/180)))/Math.pow(2,r-1)),l=360/Math.pow(2,r-1),c=Math.abs(360*Math.cos(t*(Math.PI/180))/Math.pow(2,r-1)),f=t-c/2,u=t+c/2;console.log(f);var d=n-l/2,p=n+l/2;console.log(l),console.log(c);var h=Math.abs(Math.floor(1201*l)),v=Math.abs(Math.floor(1201*c));console.log(h,v);var m=a/h,x=a/v;console.log(x,m);var g,y,E=1200-Math.abs(1200*(u-Math.floor(u))),w=Math.abs(1200*(d-Math.floor(d))),b=1200-Math.abs(1200*(f-Math.floor(f))),_=Math.abs(1200*(p-Math.floor(p)));console.log(E,w);for(var T=Math.floor(u);T>=Math.floor(f);T--)for(var A=Math.floor(d);A<=Math.floor(p);A++){g=T>0?"N"+Math.abs(Math.floor(T)):"S"+Math.abs(Math.floor(T)),y=A>0?A<100?"E0"+Math.abs(Math.floor(A)):"E"+Math.abs(Math.floor(A)):A>=-99?"W0"+Math.abs(Math.floor(A)):"W"+Math.abs(Math.floor(A));var S=0,R=0,M=1200,C=1200;T==Math.floor(f)&&(M=b),T==Math.floor(u)&&(S=E),A==Math.floor(d)&&(R=w),A==Math.floor(p)&&(C=_);var L=Math.floor(u)-T,P=A-Math.floor(d),k=0;L>0&&(k=1201-E+1201*(L-1));var N=0;P>0&&(N=1201-w+1201*(P-1));var H=new XMLHttpRequest;H.start_row=S,H.start_column=R,H.end_row=M,H.end_column=C,H.passed_rows=k,H.passed_columns=N;var z=Math.round(k/v*a),D=Math.round((k+M-S)/v*a);D=Math.min(D,500);var F=Math.round(N/h*a),I=Math.round((N+C-R)/h*a);I=Math.min(I,500),H.filename="models/hgt/"+g+y+".hgt",H.start_i=z,H.end_i=D,H.start_j=F,H.end_j=I,H.open("GET","models/hgt/"+g+y+".hgt",!0),H.responseType="arraybuffer",H.onload=function(t){var n=this.response;if(2884802==n.byteLength){new Int16Array(n);var r=new DataView(n),l=0,c=0;console.log(this.filename),console.log(this.start_row,this.start_column),console.log("Vertex rows:",this.start_i,this.end_i),console.log("Vertex columns:",this.start_j,this.end_j),console.log("Passed rows/columns:",this.passed_rows,this.passed_columns);for(var f=this.start_i;f<=this.end_i;f++){l=f/x;for(var u=this.start_j;u<=this.end_j;u++){c=u/m;var d=0,p=0;l>=this.passed_rows&&(d=(E+l)%1201),c>=this.passed_columns&&(p=(w+c)%1201),p=Math.min(1200,p),d=Math.min(1200,d);var h,v,g,y,b=p-Math.round(p),_=d-Math.round(d);d=Math.round(d),p=Math.round(p),f==this.start_i&&console.log("Start vertex row "+this.start_i+" at file row "+d),u==this.start_j&&console.log("Start vertex column "+this.start_j+" at file column "+p),f==this.end_i&&console.log("End vertex row "+this.end_i+" at file row "+d),u==this.end_j&&console.log("End vertex column "+this.end_j+" at file column "+p),h=Math.floor(1201*d+p),v=p<1200?Math.floor(1201*d+p+1):Math.floor(1201*d+p),g=d<1200?Math.floor(1201*(d+1)+p):Math.floor(1201*d+p),y=d<1200&&p<1200?Math.floor(1201*(d+1)+p+1):Math.floor(1201*d+p);var T=r.getInt16(2*h,!1),A=r.getInt16(2*v,!1),S=(1-b)*(1-_)*T+(1-b)*_*r.getInt16(2*g,!1)+b*(1-_)*A+b*_*r.getInt16(2*y,!1);i[3*(f*a+u)+2]=S*s}}o.needsUpdate=!0,e.computeVertexNormals()}},H.send(null)}}},t.shaders={vs:{},fs:{},ss:{}},t.shaders.vs.curlVS=__webpack_require__(8083),t.shaders.fs.curlFS=__webpack_require__(6512),t.shaders.ss.curlSS=__webpack_require__(5179),t.shaders.vs.quadVS=__webpack_require__(114),t.shaders.fs.iceFS=__webpack_require__(2387),t.shaders.fs.boxesFS=__webpack_require__(4324),t.shaders.fs.spheresFS=__webpack_require__(3136),t.shaders.fs.spoutFS=__webpack_require__(4367),t.shaders.fs.mountainsFS=__webpack_require__(7155),t.shaders.fs.terrain2FS=__webpack_require__(2109),t.shaders.fs.terrainFS=__webpack_require__(5749),t.shaders.fs.canyonFS=__webpack_require__(9299),t.shaders.fs.cavesFS=__webpack_require__(3923),t.shaders.fs.tunnelFS=__webpack_require__(6056),t.shaders.fs.seaFS=__webpack_require__(2105),t.shaders.fs.pbrFS=__webpack_require__(8226),t.shaders.fs.galaxyFS=__webpack_require__(5243),t.shaders.fs.weatherFS=__webpack_require__(2992),t.shaders.fs.riverFS=__webpack_require__(4650),t.shaders.fs.forestFS=__webpack_require__(456),t.shaders.fs.fishFS=__webpack_require__(3806);class T extends THREE.Mesh{constructor(e,t){super(),void 0!==arguments[0]&&arguments[0].isObject3D?this.fromObject(arguments[0]):this.create(e,t),this.userData.type="Raymarch"}create(e,n){n=void 0!==n?n:{},e=void 0!==e?e:"spheresFS";this.size=new THREE.Vector2,t.appWorks.renderer.getSize(this.size);var r=t.shaders,o={devicePixelRatio:{value:window.devicePixelRatio},time:{value:0},resolution:{value:new THREE.Vector2(this.size.x,this.size.y)},cameraNear:{value:t.appWorks.camera.near},cameraFar:{value:t.appWorks.camera.far},cameraWorldMatrix:{value:t.appWorks.camera.matrixWorld},cameraProjectionMatrixInverse:{value:t.appWorks.camera.projectionMatrixInverse},textureMaps:{value:[]}};if("pbrFS"===e){var a={envMap:{value:null},ambientLightColor:{value:new THREE.Color},directionalLights:{value:[]},pointLights:{value:[]},spotLights:{value:[]},hemisphereLights:{value:[]},useAlbedoMaps:{value:[]},useMetalnessMaps:{value:[]},useRoughnessMaps:{value:[]},albedoMaps:{value:[]},metalnessMaps:{value:[]},roughnessMaps:{value:[]},albedos:{value:[]},metalnesss:{value:[]},roughnesss:{value:[]}};o=THREE.UniformsUtils.merge([o,a])}if(t.isWebGL1()){var i=["#define gl_FragDepth gl_FragDepthEXT","#define texture texture2D","#define textureProj texture2DProj","#define textureLod texture2DLodEXT","#define textureProjLod texture2DProjLodEXT","#define textureGrad texture2DGradEXT","#define textureProjGrad texture2DProjGradEXT","#define textureGrad texture2DGradEXT"].join("\n"),s="";t.isDeviceMobile()&&(s=["highp float glFragDepth;","#define gl_FragDepthEXT glFragDepth"].join("\n"));var l=r.vs.quadVS,c=i+"\n"+s+"\n"+r.fs[e]}else if(t.isWebGL2())l=r.vs.quadVS,c=r.fs[e];var f=new THREE.PlaneBufferGeometry(2,2),u=new THREE.ShaderMaterial({defines:{},uniforms:o,vertexShader:l,fragmentShader:c}),d=(o=u.uniforms,new THREE.TextureLoader);if(n.textureFiles&&n.textureFiles.length>0&&n.textureFiles.forEach((function(e){var t=d.load(e,(e=>{e.wrapS=e.wrapT=THREE.RepeatWrapping}));o.textureMaps.value.push(t)})),"pbrFS"===e){o.envMap.value=t.appWorks.scene.background;var p=t.WORLD_SIZE;t.appWorks.scene.traverse((function(e){if(e instanceof THREE.AmbientLight)(t={}).color=e.color.clone().multiplyScalar(e.intensity),o.ambientLightColor.value.copy(t.color);else if(e instanceof THREE.DirectionalLight){(t={}).direction=e.position.clone().normalize(),t.color=e.color.clone().multiplyScalar(e.intensity),o.directionalLights.value.push(t)}else if(e instanceof THREE.PointLight){(t={}).position=e.position.clone(),t.color=e.color.clone().multiplyScalar(e.intensity),t.distance=0===e.distance?p:e.distance,t.decay=e.decay,o.pointLights.value.push(t)}else if(e instanceof THREE.SpotLight){(t={}).position=e.position.clone(),t.direction=e.position.clone().normalize(),t.color=e.color.clone().multiplyScalar(e.intensity),t.distance=0===e.distance?p:e.distance,t.decay=e.decay,t.coneCos=Math.cos(e.angle),t.penumbraCos=Math.cos(e.penumbra),o.spotLights.value.push(t)}else if(e instanceof THREE.HemisphereLight){var t;(t={}).direction=new THREE.Vector3(0,1,0),t.skyColor=e.color.clone().multiplyScalar(e.intensity),t.groundColor=e.groundColor.clone(),o.hemisphereLights.value.push(t)}}));var h=new THREE.Color(16777215);n.albedo&&(n.albedo=[]);for(var v=4-n.albedo.length,m=0;m<v;m++)n.albedo.push(null);n.albedo&&n.albedo.forEach((function(e){if("string"==typeof e){var t=d.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));o.albedoMaps.value.push(t),o.albedos.value.push(h),o.useAlbedoMaps.value.push(1)}else o.albedoMaps.value.push(null),o.albedos.value.push(null===e?h:e),o.useAlbedoMaps.value.push(0)})),n.metalness||(n.metalness=[]);for(v=4-n.metalness.length,m=0;m<v;m++)n.metalness.push(null);n.metalness&&n.metalness.forEach((function(e){if("string"==typeof e){var t=d.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));o.metalnessMaps.value.push(t),o.metalnesss.value.push(.1),o.useMetalnessMaps.value.push(1)}else o.metalnessMaps.value.push(null),o.metalnesss.value.push(e),o.useMetalnessMaps.value.push(0)})),n.roughness||(n.roughness=[]);for(v=4-n.roughness.length,m=0;m<v;m++)n.roughness.push(null);n.roughness&&n.roughness.forEach((function(e){if("string"==typeof e){var t=d.load(e,(function(e){e.wrapS=e.wrapT=THREE.RepeatWrapping}));o.roughnessMaps.value.push(t),o.roughnesss.value.push(.1),o.useRoughnessMaps.value.push(1)}else o.roughnessMaps.value.push(null),o.roughnesss.value.push(e),o.useRoughnessMaps.value.push(0)}))}u.extensions={derivatives:!0,fragDepth:!0,drawBuffers:!0,shaderTextureLOD:!0},this.geometry=f,this.material=u,this.name="raymarch",this.frustumCulled=!1,this.userData.shaderTitle=e,this.userData.options=n}fromObject(e){var t=e.userData.shaderTitle,n=e.userData.options;if("pbrFS"===t&&n.albedo)for(var r=n.albedo,o=0,a=r.length;o<a;o++)"number"==typeof r[o]&&(r[o]=new THREE.Color(r[o]));this.create(t,n),this.name=e.name}clone(){return new t.Raymarch(this)}update(e,n){t.appWorks.renderer.getSize(this.size);var r=this.material.uniforms;r.time.value=n,r.resolution.value.set(this.size.x,this.size.y),r.cameraNear.value=t.appWorks.camera.near,r.cameraFar.value=t.appWorks.camera.far,r.cameraWorldMatrix.value=t.appWorks.camera.matrixWorld,r.cameraProjectionMatrixInverse.value=t.appWorks.camera.projectionMatrixInverse,"pbrFS"===this.userData.shaderTitle&&(r.envMap.value=t.appWorks.scene.background)}updateVisible(e){t.appWorks.setValue(this,"visible",e)}raycast(e,n){var r=t.appWorks;if(r.renderer.extensions.get("WEBGL_depth_texture")){if(r.mouseUpPosition.equals(r.mouseDownPosition)&&r.mouseUpPosition.equals(r.mouseMovePosition)){var o=r.mouseUpPosition;this.rayIntersect(o,n)}}else console.warn("WEBGL_depth_texture: not supported on your computer...")}}T.prototype.isRaymarch=!0,t.Raymarch=T,t.createRaymarch=function(e,n){return new t.Raymarch(e,n)},t.raymarchIce=function(){return t.appWorks.playAudio(["audio/boxesFS.mp3"]),t.createRaymarch("iceFS",{textureFiles:["images/raymarch/pebbles.jpg","images/raymarch/steel.jpg","images/raymarch/ruby.jpg","images/raymarch/frozen.jpg"]})},t.raymarchBoxes=function(){return t.appWorks.playAudio(["audio/boxesFS.mp3"]),t.createRaymarch("boxesFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},t.raymarchSpheres=function(){return t.appWorks.playAudio(["audio/spheresFS.mp3"]),t.createRaymarch("spheresFS")},t.raymarchSpout=function(){return t.createRaymarch("spoutFS",{textureFiles:["images/ground/bathroom.jpg"]})},t.raymarchTerrain=function(){return t.appWorks.playAudio(["audio/terrainFS.mp3"]),t.createRaymarch("terrainFS",{textureFiles:["images/raymarch/grayNoise256.png"]})},t.raymarchTerrain2=function(){return t.appWorks.playAudio(["audio/terrain2FS.mp3"]),t.createRaymarch("terrain2FS",{textureFiles:["images/raymarch/lichen.jpg","images/raymarch/organic1.jpg","images/raymarch/grayNoise256.png","images/raymarch/lichen.jpg"]})},t.raymarchTunnels=function(){return t.appWorks.playAudio(["audio/tunnelFS.mp3"]),t.createRaymarch("tunnelFS",{textureFiles:["images/raymarch/lichen.jpg"]})},t.raymarchPBR=function(){return t.appWorks.playAudio(["audio/pbrFS.mp3"]),t.createRaymarch("pbrFS",{albedo:["images/pbr/rustIronA.png","images/pbr/plasticA.png","images/pbr/wallA.png"],metalness:["images/pbr/rustIronM.png",null,null],roughness:["images/pbr/rustIronR.png","images/pbr/plasticR.png","images/pbr/wallR.png"]})},t.raymarchGalaxy=function(){return t.appWorks.playAudio(["audio/galaxyFS.mp3"]),t.createRaymarch("galaxyFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},t.raymarchMountains=function(){return t.appWorks.playAudio(["audio/mountainsFS.mp3"]),t.createRaymarch("mountainsFS",{textureFiles:["images/raymarch/pebbles.jpg"]})},t.raymarchCanyon=function(){return t.appWorks.playAudio(["audio/canyonFS.mp3"]),t.createRaymarch("canyonFS",{textureFiles:["images/raymarch/organic2.jpg","images/raymarch/abstract1.jpg","images/raymarch/rgbaNoise256.png"]})},t.raymarchCaves=function(){return t.appWorks.playAudio(["audio/cavesFS.mp3"]),t.createRaymarch("cavesFS",{textureFiles:["images/raymarch/pebbles.jpg","images/raymarch/organic1.jpg"]})},t.raymarchSea=function(){return t.appWorks.playAudio(["audio/seaFS.mp3"]),t.createRaymarch("seaFS")},t.raymarchWeather=function(){return t.appWorks.playAudio(["audio/thunderRain.mp3"]),t.createRaymarch("weatherFS",{textureFiles:["images/raymarch/rgbaNoise256.png"]})},t.raymarchRiver=function(){return t.appWorks.playAudio(["audio/riverFS.mp3"]),t.createRaymarch("riverFS",{textureFiles:["images/raymarch/grayNoise256.png","images/raymarch/organic1.jpg"]})},t.raymarchForest=function(){return t.appWorks.playAudio(["audio/forestFS.mp3"]),t.createRaymarch("forestFS",{textureFiles:["images/raymarch/grayNoise256.png"]})},t.raymarchFish=function(){return t.appWorks.playAudio(["audio/fishFS.mp3"]),t.createRaymarch("fishFS",{textureFiles:["images/raymarch/organic2.jpg","images/raymarch/abstract1.jpg","images/raymarch/grayNoise256.png","images/raymarch/lichen.jpg"]})},t.createBirdBasic=function(e,t){e=e||10,t=t||4;var n=new THREE.BufferGeometry,r=.4*e,o=.6*e,a=.5*o,i=new Float32Array([0,-0,-r,0,.08*e,-r,0,0,o,0,0,-a,-t,0,0,0,0,a,0,0,a,t,0,0,0,0,-a]);n.setAttribute("position",new THREE.BufferAttribute(i,3));var s=new THREE.MeshBasicMaterial({color:16777215,side:THREE.DoubleSide}),l=new THREE.Mesh(n,s);return l.castShadow=!0,l.receiveShadow=!0,l.name="birdBasic",l},t.createEyeball=function(e){e=e||5;var t=new THREE.Mesh(new THREE.SphereBufferGeometry(e,32,16),new THREE.ShaderMaterial({uniforms:{eyeTex:{value:(new THREE.TextureLoader).load("images/eye.jpg")}},vertexShader:["varying vec3 vNormal;","void main() {","vNormal = normal;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D eyeTex;","varying vec3 vNormal;","void main() {","vec2 uv = normalize( vNormal ).xy * 0.5 + 0.5;","vec3 color = texture2D( eyeTex, uv ).rgb;","if ( vNormal.z < - 0.85 ) color = vec3( 0.777, 0.74, 0.74 ); // back of eye","gl_FragColor = vec4( color, 1.0 );","}"].join("\n")}));return t.castShadow=!0,t.receiveShadow=!0,t.name="eyeball",t},t.createLowPolyTree=function(e,n,r){function o(e,t,n,r,o){for(var a,i,s=new THREE.Vector3,l=e[0].clone(),c=0;c<t;c++)s=e[c+(a=n*t+1)].clone(),l.y=s.y,i=s.sub(l),o?c%2==0?(i.normalize().multiplyScalar(r/6),e[c+a].add(i)):(i.normalize().multiplyScalar(r),e[c+a].add(i),e[c+a].y=e[c+a+t].y+.05):c%2!=0?(i.normalize().multiplyScalar(r/6),e[c+a].add(i)):(i.normalize().multiplyScalar(r),e[c+a].add(i),e[c+a].y=e[c+a+t].y+.05)}function a(e,t,n){for(var r,o,a=new THREE.Vector3,i=e[0].clone(),s=0;s<t;s++)a=e[s+(r=n*t+1)].clone(),i.y=a.y,(o=a.sub(i)).normalize().multiplyScalar(.06),e[s+r].sub(o)}e=e||10,n=n||.4;var i=r=r||16,s=t.randFloat(.05,.2),l=new THREE.ConeGeometry(.5,1,i,6),c=new THREE.MeshStandardMaterial({color:3407667,flatShading:!0});o(l.vertices,i,0,s),a(l.vertices,i,1),o(l.vertices,i,2,1.1*s,!0),a(l.vertices,i,3),o(l.vertices,i,4,1.2*s),a(l.vertices,i,5);var f=new THREE.Mesh(l,c);f.castShadow=!0,f.receiveShadow=!1,f.position.y=.5+n,f.rotation.y=t.randFloat(0,Math.PI);var u=n+.01,d=new THREE.CylinderGeometry(.1,.1,u),p=new THREE.MeshStandardMaterial({color:8939059,flatShading:!0}),h=new THREE.Mesh(d,p);h.position.y=u/2;var v=new THREE.Object3D;return v.add(h),v.add(f),v.scale.setScalar(e/(1+n)),v.castShadow=!0,v.receiveShadow=!1,v.name="lowPolyTree",v},t.createProcCity=function(){(i=new THREE.BoxGeometry(1,1,1)).applyMatrix((new THREE.Matrix4).makeTranslation(0,.5,0));for(var e=new THREE.Mesh(i),n=new THREE.Color(16777215),r=new THREE.Color(3158096),o=new THREE.Geometry,a=0;a<2e4;a++){e.position.x=~~t.randFloat(-1e3,1e3),e.position.z=~~t.randFloat(-1e3,1e3),e.rotation.y=Math.random()*Math.PI*2,e.scale.x=t.randFloat(2,10),e.scale.y=t.randFloat(1.5,5*e.scale.x),e.scale.z=e.scale.x;for(var i,s=1-Math.random(),l=new THREE.Color(s+.1*Math.random(),s,s+.1*Math.random()),c=l.clone().multiply(n),f=l.clone().multiply(r),u=(new THREE.Color(16711680),0),d=(i=e.geometry).faces.length;u<d;u++)0===u||1===u||8===u||9===u?i.faces[u].vertexColors=[c,c,c]:2===u||3===u||10===u||11===u?i.faces[u].vertexColors=[f,f,f]:4===u||5===u?i.faces[u].vertexColors=[l,l,l]:6!==u&&7!==u||(i.faces[u].vertexColors=[l,l,l]);o.mergeMesh(e)}var p=new THREE.Texture(function(){var e=document.createElement("canvas");e.width=32,e.height=64,(o=e.getContext("2d")).fillStyle="#ffffff",o.fillRect(0,0,32,64);for(var t=2;t<64;t+=2)for(var n=0;n<32;n+=2){var r=Math.floor(64*Math.random());o.fillStyle="rgb("+[r,r,r].join(",")+")",o.fillRect(n,t,2,1)}var o,a=document.createElement("canvas");return a.width=512,a.height=1024,(o=a.getContext("2d")).imageSmoothingEnabled=!1,o.webkitImageSmoothingEnabled=!1,o.mozImageSmoothingEnabled=!1,o.drawImage(e,0,0,a.width,a.height),a}());p.anisotropy=t.appWorks.renderer.capabilities.getMaxAnisotropy(),p.needsUpdate=!0;var h=new THREE.MeshLambertMaterial({map:p,vertexColors:THREE.VertexColors});return new THREE.Mesh(o,h)},t.createAcrylicPlane=function(e,n){var r=t.appWorks.scene.background;r instanceof THREE.Texture||(r=null);e=void 0!==e?e:100,n=void 0!==n?n:100;var o=new THREE.Object3D;o.name="planeAcryl";var a=new THREE.PlaneBufferGeometry(e,n),i=new THREE.Mesh(a,new THREE.MeshStandardMaterial({color:12632256,map:r,transparent:!0,opacity:.7}));i.position.z=0,i.receiveShadow=!0,o.add(i);var s=new THREE.Reflector(a,{clipBias:.003,textureWidth:~~(t.appWorks.width*window.devicePixelRatio),textureHeight:~~(t.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1});return s.position.z=-Math.min(.001*e,2),o.add(s),o},t.createAcrylicCircle=function(e){var n=t.appWorks.scene.background;n instanceof THREE.Texture||(n=null);e=void 0!==e?e:50;var r=new THREE.Object3D;r.name="circleAcryl";var o=new THREE.CircleBufferGeometry(e,64),a=new THREE.Mesh(o,new THREE.MeshStandardMaterial({color:12632256,map:n,transparent:!0,opacity:.7}));a.position.z=0,a.receiveShadow=!0,r.add(a);var i=new THREE.Reflector(o,{clipBias:.003,textureWidth:~~(t.appWorks.width*window.devicePixelRatio),textureHeight:~~(t.appWorks.height*window.devicePixelRatio),color:7829367});return i.position.z=-Math.min(.001*e,2),r.add(i),r},t.createMirrorPlane=function(e,n){e=void 0!==e?e:100,n=void 0!==n?n:100;var r=new THREE.PlaneBufferGeometry(e,n);return new THREE.Reflector(r,{clipBias:.003,textureWidth:~~(t.appWorks.width*window.devicePixelRatio),textureHeight:~~(t.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1})},t.createMirrorCircle=function(e){e=void 0!==e?e:50;var n=new THREE.CircleBufferGeometry(e,64);return new THREE.Reflector(n,{clipBias:.003,textureWidth:~~(t.appWorks.width*window.devicePixelRatio),textureHeight:~~(t.appWorks.height*window.devicePixelRatio),color:7829367,recursion:1})},t.createArenaRow=function(e){for(var t=(e=e||{}).radius||.5,n=e.nCluster||30,r=e.conesPerSection||5,o=e.heightMin||.1,a=e.heightMax||.15,i=e.radiusMin||.04,s=e.radiusMax||.04,l=2*Math.PI,c=new THREE.Object3D,f=new THREE.MeshPhongMaterial({color:"teal"}),u=0;u<n;u++)for(var d=u/n*l,p=0;p<r;p++){var h=THREE.Math.randFloatSpread(2/n)*l,v=THREE.Math.randFloat(o,a),m=THREE.Math.randFloat(i,s),x=new THREE.CylinderGeometry(0,m,v),g=new THREE.Mesh(x,f);g.position.y=v/2,g.position.x=t*Math.cos(d+h),g.position.z=t*Math.sin(d+h),c.add(g)}return c},t.createViewWorks=function(e,n){return t.viewWorks=new t.GraphicWorks({appName:"ViewWorks",width:e||window.innerWidth,height:n||window.innerHeight,glVersion:2,background:(new THREE.TextureLoader).load("images/wallpaper/arctic.jpg"),controlsType:"OrbitControls",FXAAEnabled:!0,fileExplorer:!0}),t.viewWorks.renderScene(),t.viewWorks},t.createWPViewWorks=function(e,n){return t.viewWorks=new t.GraphicWorks({appName:"ViewWorks",customer:"wordpress.org",width:e||window.innerWidth,height:n||window.innerHeight,glVersion:2,background:12632256,controlsType:"OrbitControls",FXAAEnabled:!0,fileExplorer:!0}),t.viewWorks.renderScene(),t.viewWorks},t.createGameWorks=function(e,n){return t.gameWorks=new t.GraphicWorks({appName:"GameWorks",width:e||window.innerWidth,height:n||window.innerHeight,glVersion:2,hud:!0}),t.gameWorks.renderScene(),t.gameWorks},t.createNatureWorks=function(e,n){return t.natureWorks=new t.GraphicWorks({appName:"NatureWorks",width:e||window.innerWidth,height:n||window.innerHeight,signals:!0,config:!0,history:!0,glVersion:2,fog:{type:"exp2"},controlsType:"OrbitControls",stats:!0,audioFiles:void 0,gridVisible:!1,hud:!0,bleachEnabled:!1,bloomEnabled:!1,dotScreenEnabled:!1,glitchEnabled:!1,sepiaEnabled:!1,outlineEnabled:!1,FXAAEnabled:!0,ssaoEnabled:!1,godRaysEnabled:!1,bokehEnabled:!1,vignetteEnabled:!1,effectType:void 0,fileExplorer:!0,dragControls:!0,transformControls:!0}),t.natureWorks.renderScene(),t.natureWorks},t.createMedicalWorks=function(e,n){return t.medicalWorks=new t.GraphicWorks({appName:"MedicalWorks",width:e||window.innerWidth,height:n||window.innerHeight,signals:!0,glVersion:2,stats:!0,fileExplorer:!0}),t.medicalWorks.renderScene(),t.medicalWorks},t.add=function(e){t.updateMaterialMapEncoding(e,THREE.sRGBEncoding),t.appWorks.history?t.appWorks.add(e):t.appWorks.scene.add(e)},t.remove=function(e){e&&(t.appWorks.history?t.appWorks.remove(e):e.parent&&e.parent.remove(e))},t.dispose=function(e){e&&(e.parent&&e.parent.remove(e),e.traverse((function(e){var t=e.geometry;t&&t.dispose();var n=e.material;n&&(Array.isArray(n)?n:[n]).forEach((function(e){Object.keys(e).forEach((t=>{e[t]&&"function"==typeof e[t].dispose&&e[t].dispose()})),e.dispose()}))})))},window.URL=window.URL||window.webkitURL,window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,window.JAMIE=t})()})();